   1              	 .syntax unified
   2              	 .cpu cortex-m4
   3              	 .eabi_attribute 27,3
   4              	 .fpu fpv4-sp-d16
   5              	 .eabi_attribute 20,1
   6              	 .eabi_attribute 21,1
   7              	 .eabi_attribute 23,3
   8              	 .eabi_attribute 24,1
   9              	 .eabi_attribute 25,1
  10              	 .eabi_attribute 26,1
  11              	 .eabi_attribute 30,2
  12              	 .eabi_attribute 34,1
  13              	 .eabi_attribute 18,4
  14              	 .thumb
  15              	 .file "arm_mat_inverse_f32.c"
  16              	 .text
  17              	.Ltext0:
  18              	 .cfi_sections .debug_frame
  19              	 .section .text.arm_mat_inverse_f32,"ax",%progbits
  20              	 .align 2
  21              	 .global arm_mat_inverse_f32
  22              	 .thumb
  23              	 .thumb_func
  25              	arm_mat_inverse_f32:
  26              	.LFB135:
  27              	 .file 1 "../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c"
   1:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** /* ----------------------------------------------------------------------
   2:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * Project:      CMSIS DSP Library
   3:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * Title:        arm_mat_inverse_f32.c
   4:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * Description:  Floating-point matrix inverse
   5:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  *
   6:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * $Date:        27. January 2017
   7:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * $Revision:    V.1.5.1
   8:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  *
   9:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * Target Processor: Cortex-M cores
  10:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * -------------------------------------------------------------------- */
  11:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** /*
  12:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * Copyright (C) 2010-2017 ARM Limited or its affiliates. All rights reserved.
  13:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  *
  14:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * SPDX-License-Identifier: Apache-2.0
  15:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  *
  16:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * Licensed under the Apache License, Version 2.0 (the License); you may
  17:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * not use this file except in compliance with the License.
  18:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * You may obtain a copy of the License at
  19:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  *
  20:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * www.apache.org/licenses/LICENSE-2.0
  21:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  *
  22:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * Unless required by applicable law or agreed to in writing, software
  23:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  24:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  25:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * See the License for the specific language governing permissions and
  26:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * limitations under the License.
  27:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  */
  28:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
  29:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** #include "CMSIS_DSP/cmsis_dsp.h"
  30:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
  31:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** /**
  32:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * @ingroup groupMatrix
  33:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  */
  34:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
  35:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** /**
  36:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * @defgroup MatrixInv Matrix Inverse
  37:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  *
  38:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * Computes the inverse of a matrix.
  39:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  *
  40:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * The inverse is defined only if the input matrix is square and non-singular (the determinant
  41:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * is non-zero). The function checks that the input and output matrices are square and of the
  42:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * same size.
  43:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  *
  44:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * Matrix inversion is numerically sensitive and the CMSIS DSP library only supports matrix
  45:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * inversion of floating-point matrices.
  46:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  *
  47:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * \par Algorithm
  48:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * The Gauss-Jordan method is used to find the inverse.
  49:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * The algorithm performs a sequence of elementary row-operations until it
  50:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * reduces the input matrix to an identity matrix. Applying the same sequence
  51:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * of elementary row-operations to an identity matrix yields the inverse matrix.
  52:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * If the input matrix is singular, then the algorithm terminates and returns error status
  53:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * <code>ARM_MATH_SINGULAR</code>.
  54:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * \image html MatrixInverse.gif "Matrix Inverse of a 3 x 3 matrix using Gauss-Jordan Method"
  55:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  */
  56:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
  57:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** /**
  58:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * @addtogroup MatrixInv
  59:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * @{
  60:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  */
  61:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
  62:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** /**
  63:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * @brief Floating-point matrix inverse.
  64:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * @param[in]       *pSrc points to input matrix structure
  65:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * @param[out]      *pDst points to output matrix structure
  66:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * @return     		The function returns
  67:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * <code>ARM_MATH_SIZE_MISMATCH</code> if the input matrix is not square or if the size
  68:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * of the output matrix does not match the size of the input matrix.
  69:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * If the input matrix is found to be singular (non-invertible), then the function returns
  70:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  * <code>ARM_MATH_SINGULAR</code>.  Otherwise, the function returns <code>ARM_MATH_SUCCESS</code>.
  71:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****  */
  72:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
  73:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** arm_status arm_mat_inverse_f32(
  74:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   const arm_matrix_instance_f32 * pSrc,
  75:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   arm_matrix_instance_f32 * pDst)
  76:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** {
  28              	 .loc 1 76 0
  29              	 .cfi_startproc
  30              	 
  31              	 
  32              	.LVL0:
  33 0000 2DE9F04F 	 push {r4,r5,r6,r7,r8,r9,r10,fp,lr}
  34              	.LCFI0:
  35              	 .cfi_def_cfa_offset 36
  36              	 .cfi_offset 4,-36
  37              	 .cfi_offset 5,-32
  38              	 .cfi_offset 6,-28
  39              	 .cfi_offset 7,-24
  40              	 .cfi_offset 8,-20
  41              	 .cfi_offset 9,-16
  42              	 .cfi_offset 10,-12
  43              	 .cfi_offset 11,-8
  44              	 .cfi_offset 14,-4
  77:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   float32_t *pIn = pSrc->pData;                  /* input data matrix pointer */
  78:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   float32_t *pOut = pDst->pData;                 /* output data matrix pointer */
  79:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   float32_t *pInT1, *pInT2;                      /* Temporary input data matrix pointer */
  80:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   float32_t *pOutT1, *pOutT2;                    /* Temporary output data matrix pointer */
  81:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   float32_t *pPivotRowIn, *pPRT_in, *pPivotRowDst, *pPRT_pDst;  /* Temporary input and output data 
  82:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   uint32_t numRows = pSrc->numRows;              /* Number of rows in the matrix  */
  45              	 .loc 1 82 0
  46 0004 0388     	 ldrh r3,[r0]
  83:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   uint32_t numCols = pSrc->numCols;              /* Number of Cols in the matrix  */
  84:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
  85:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** #if defined (ARM_MATH_DSP)
  86:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   float32_t maxC;                                /* maximum value in the column */
  87:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
  88:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   /* Run the below code for Cortex-M4 and Cortex-M3 */
  89:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
  90:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   float32_t Xchg, in = 0.0f, in1;                /* Temporary input values  */
  91:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   uint32_t i, rowCnt, flag = 0u, j, loopCnt, k, l;      /* loop counters */
  92:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   arm_status status;                             /* status of matrix inverse */
  93:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
  94:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** #ifdef ARM_MATH_MATRIX_CHECK
  95:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
  96:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
  97:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   /* Check for matrix mismatch condition */
  98:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   if ((pSrc->numRows != pSrc->numCols) || (pDst->numRows != pDst->numCols)
  47              	 .loc 1 98 0
  48 0006 4488     	 ldrh r4,[r0,#2]
  77:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   float32_t *pIn = pSrc->pData;                  /* input data matrix pointer */
  49              	 .loc 1 77 0
  50 0008 4268     	 ldr r2,[r0,#4]
  76:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   float32_t *pIn = pSrc->pData;                  /* input data matrix pointer */
  51              	 .loc 1 76 0
  52 000a 89B0     	 sub sp,sp,#36
  53              	.LCFI1:
  54              	 .cfi_def_cfa_offset 72
  55              	 .loc 1 98 0
  56 000c 9C42     	 cmp r4,r3
  77:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   float32_t *pIn = pSrc->pData;                  /* input data matrix pointer */
  57              	 .loc 1 77 0
  58 000e 0292     	 str r2,[sp,#8]
  59              	.LVL1:
  78:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   float32_t *pInT1, *pInT2;                      /* Temporary input data matrix pointer */
  60              	 .loc 1 78 0
  61 0010 4A68     	 ldr r2,[r1,#4]
  62              	.LVL2:
  63 0012 0192     	 str r2,[sp,#4]
  64              	.LVL3:
  65              	 .loc 1 98 0
  66 0014 04D0     	 beq .L71
  67              	.LVL4:
  68              	.L36:
  99:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****      || (pSrc->numRows != pDst->numRows))
 100:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   {
 101:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     /* Set status as ARM_MATH_SIZE_MISMATCH */
 102:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     status = ARM_MATH_SIZE_MISMATCH;
  69              	 .loc 1 102 0
  70 0016 FD20     	 movs r0,#253
  71              	.LVL5:
  72              	.L2:
  73 0018 40B2     	 sxtb r0,r0
 103:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   }
 104:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   else
 105:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** #endif /*    #ifdef ARM_MATH_MATRIX_CHECK    */
 106:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 107:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   {
 108:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 109:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     /*---------------------------------------------------------------------------------------------
 110:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 * Matrix Inverse can be solved using elementary row operations.
 111:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *
 112:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *	Gauss-Jordan Method:
 113:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *
 114:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *	   1. First combine the identity matrix and the input matrix separated by a bar to form an
 115:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *        augmented matrix as follows:
 116:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *				        _ 	      	       _         _	       _
 117:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *					   |  a11  a12 | 1   0  |       |  X11 X12  |
 118:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *					   |           |        |   =   |           |
 119:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *					   |_ a21  a22 | 0   1 _|       |_ X21 X21 _|
 120:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *
 121:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *		2. In our implementation, pDst Matrix is used as identity matrix.
 122:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *
 123:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *		3. Begin with the first row. Let i = 1.
 124:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *
 125:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *	    4. Check to see if the pivot for column i is the greatest of the column.
 126:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *		   The pivot is the element of the main diagonal that is on the current row.
 127:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *		   For instance, if working with row i, then the pivot element is aii.
 128:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *		   If the pivot is not the most significant of the columns, exchange that row with a row
 129:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *		   below it that does contain the most significant value in column i. If the most
 130:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *         significant value of the column is zero, then an inverse to that matrix does not exist.
 131:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *		   The most significant value of the column is the absolute maximum.
 132:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *
 133:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *	    5. Divide every element of row i by the pivot.
 134:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *
 135:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *	    6. For every row below and  row i, replace that row with the sum of that row and
 136:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *		   a multiple of row i so that each new element in column i below row i is zero.
 137:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *
 138:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *	    7. Move to the next row and column and repeat steps 2 through 5 until you have zeros
 139:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *		   for every element below and above the main diagonal.
 140:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *
 141:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *		8. Now an identical matrix is formed to the left of the bar(input matrix, pSrc).
 142:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *		   Therefore, the matrix to the right of the bar is our solution(pDst matrix, pDst).
 143:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *------------------------------------------------------------------------------------------------
 144:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 145:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     /* Working pointer for destination matrix */
 146:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     pOutT1 = pOut;
 147:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 148:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     /* Loop over the number of rows */
 149:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     rowCnt = numRows;
 150:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 151:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     /* Making the destination matrix as identity matrix */
 152:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     while (rowCnt > 0u)
 153:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     {
 154:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Writing all zeroes in lower triangle of the destination matrix */
 155:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       j = numRows - rowCnt;
 156:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       while (j > 0u)
 157:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 158:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         *pOutT1++ = 0.0f;
 159:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         j--;
 160:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       }
 161:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 162:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Writing all ones in the diagonal of the destination matrix */
 163:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       *pOutT1++ = 1.0f;
 164:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 165:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Writing all zeroes in upper triangle of the destination matrix */
 166:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       j = rowCnt - 1u;
 167:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       while (j > 0u)
 168:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 169:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         *pOutT1++ = 0.0f;
 170:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         j--;
 171:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       }
 172:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 173:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Decrement the loop counter */
 174:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       rowCnt--;
 175:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     }
 176:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 177:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     /* Loop over the number of columns of the input matrix.
 178:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****        All the elements in each column are processed by the row operations */
 179:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     loopCnt = numCols;
 180:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 181:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     /* Index modifier to navigate through the columns */
 182:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     l = 0u;
 183:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 184:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     while (loopCnt > 0u)
 185:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     {
 186:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Check if the pivot element is zero..
 187:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****        * If it is zero then interchange the row with non zero row below.
 188:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****        * If there is no non zero element to replace in the rows below,
 189:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****        * then the matrix is Singular. */
 190:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 191:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Working pointer for the input matrix that points
 192:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****        * to the pivot element of the particular row  */
 193:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       pInT1 = pIn + (l * numCols);
 194:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 195:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Working pointer for the destination matrix that points
 196:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****        * to the pivot element of the particular row  */
 197:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       pOutT1 = pOut + (l * numCols);
 198:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 199:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Temporary variable to hold the pivot value */
 200:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       in = *pInT1;
 201:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 202:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Grab the most significant value from column l */
 203:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       maxC = 0;
 204:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       for (i = l; i < numRows; i++)
 205:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 206:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         maxC = *pInT1 > 0 ? (*pInT1 > maxC ? *pInT1 : maxC) : (-*pInT1 > maxC ? -*pInT1 : maxC);
 207:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         pInT1 += numCols;
 208:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       }
 209:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 210:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Update the status if the matrix is singular */
 211:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       if (maxC == 0.0f)
 212:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 213:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         return ARM_MATH_SINGULAR;
 214:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       }
 215:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 216:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Restore pInT1  */
 217:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       pInT1 = pIn;
 218:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 219:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Destination pointer modifier */
 220:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       k = 1u;
 221:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 222:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Check if the pivot element is the most significant of the column */
 223:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       if ( (in > 0.0f ? in : -in) != maxC)
 224:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 225:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         /* Loop over the number rows present below */
 226:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         i = numRows - (l + 1u);
 227:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 228:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         while (i > 0u)
 229:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         {
 230:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           /* Update the input and destination pointers */
 231:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           pInT2 = pInT1 + (numCols * l);
 232:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           pOutT2 = pOutT1 + (numCols * k);
 233:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 234:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           /* Look for the most significant element to
 235:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****            * replace in the rows below */
 236:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           if ((*pInT2 > 0.0f ? *pInT2: -*pInT2) == maxC)
 237:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           {
 238:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             /* Loop over number of columns
 239:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****              * to the right of the pilot element */
 240:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             j = numCols - l;
 241:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 242:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             while (j > 0u)
 243:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             {
 244:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****               /* Exchange the row elements of the input matrix */
 245:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****               Xchg = *pInT2;
 246:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****               *pInT2++ = *pInT1;
 247:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****               *pInT1++ = Xchg;
 248:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 249:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****               /* Decrement the loop counter */
 250:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****               j--;
 251:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             }
 252:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 253:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             /* Loop over number of columns of the destination matrix */
 254:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             j = numCols;
 255:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 256:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             while (j > 0u)
 257:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             {
 258:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****               /* Exchange the row elements of the destination matrix */
 259:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****               Xchg = *pOutT2;
 260:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****               *pOutT2++ = *pOutT1;
 261:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****               *pOutT1++ = Xchg;
 262:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 263:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****               /* Decrement the loop counter */
 264:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****               j--;
 265:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             }
 266:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 267:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             /* Flag to indicate whether exchange is done or not */
 268:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             flag = 1u;
 269:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 270:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             /* Break after exchange is done */
 271:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             break;
 272:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           }
 273:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 274:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           /* Update the destination pointer modifier */
 275:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           k++;
 276:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 277:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           /* Decrement the loop counter */
 278:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           i--;
 279:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         }
 280:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       }
 281:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 282:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Update the status if the matrix is singular */
 283:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       if ((flag != 1u) && (in == 0.0f))
 284:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 285:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         return ARM_MATH_SINGULAR;
 286:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       }
 287:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 288:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Points to the pivot row of input and destination matrices */
 289:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       pPivotRowIn = pIn + (l * numCols);
 290:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       pPivotRowDst = pOut + (l * numCols);
 291:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 292:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Temporary pointers to the pivot row pointers */
 293:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       pInT1 = pPivotRowIn;
 294:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       pInT2 = pPivotRowDst;
 295:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 296:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Pivot element of the row */
 297:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       in = *pPivotRowIn;
 298:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 299:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Loop over number of columns
 300:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****        * to the right of the pilot element */
 301:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       j = (numCols - l);
 302:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 303:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       while (j > 0u)
 304:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 305:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         /* Divide each element of the row of the input matrix
 306:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****          * by the pivot element */
 307:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         in1 = *pInT1;
 308:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         *pInT1++ = in1 / in;
 309:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 310:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         /* Decrement the loop counter */
 311:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         j--;
 312:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       }
 313:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 314:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Loop over number of columns of the destination matrix */
 315:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       j = numCols;
 316:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 317:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       while (j > 0u)
 318:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 319:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         /* Divide each element of the row of the destination matrix
 320:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****          * by the pivot element */
 321:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         in1 = *pInT2;
 322:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         *pInT2++ = in1 / in;
 323:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 324:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         /* Decrement the loop counter */
 325:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         j--;
 326:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       }
 327:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 328:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Replace the rows with the sum of that row and a multiple of row i
 329:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****        * so that each new element in column i above row i is zero.*/
 330:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 331:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Temporary pointers for input and destination matrices */
 332:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       pInT1 = pIn;
 333:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       pInT2 = pOut;
 334:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 335:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* index used to check for pivot element */
 336:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       i = 0u;
 337:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 338:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Loop over number of rows */
 339:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /*  to be replaced by the sum of that row and a multiple of row i */
 340:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       k = numRows;
 341:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 342:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       while (k > 0u)
 343:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 344:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         /* Check for the pivot element */
 345:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         if (i == l)
 346:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         {
 347:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           /* If the processing element is the pivot element,
 348:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****              only the columns to the right are to be processed */
 349:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           pInT1 += numCols - l;
 350:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 351:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           pInT2 += numCols;
 352:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         }
 353:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         else
 354:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         {
 355:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           /* Element of the reference row */
 356:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           in = *pInT1;
 357:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 358:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           /* Working pointers for input and destination pivot rows */
 359:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           pPRT_in = pPivotRowIn;
 360:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           pPRT_pDst = pPivotRowDst;
 361:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 362:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           /* Loop over the number of columns to the right of the pivot element,
 363:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****              to replace the elements in the input matrix */
 364:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           j = (numCols - l);
 365:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 366:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           while (j > 0u)
 367:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           {
 368:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             /* Replace the element by the sum of that row
 369:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****                and a multiple of the reference row  */
 370:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             in1 = *pInT1;
 371:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             *pInT1++ = in1 - (in * *pPRT_in++);
 372:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 373:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             /* Decrement the loop counter */
 374:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             j--;
 375:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           }
 376:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 377:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           /* Loop over the number of columns to
 378:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****              replace the elements in the destination matrix */
 379:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           j = numCols;
 380:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 381:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           while (j > 0u)
 382:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           {
 383:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             /* Replace the element by the sum of that row
 384:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****                and a multiple of the reference row  */
 385:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             in1 = *pInT2;
 386:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             *pInT2++ = in1 - (in * *pPRT_pDst++);
 387:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 388:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             /* Decrement the loop counter */
 389:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             j--;
 390:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           }
 391:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 392:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         }
 393:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 394:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         /* Increment the temporary input pointer */
 395:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         pInT1 = pInT1 + l;
 396:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 397:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         /* Decrement the loop counter */
 398:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         k--;
 399:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 400:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         /* Increment the pivot index */
 401:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         i++;
 402:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       }
 403:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 404:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Increment the input pointer */
 405:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       pIn++;
 406:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 407:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Decrement the loop counter */
 408:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       loopCnt--;
 409:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 410:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Increment the index modifier */
 411:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       l++;
 412:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     }
 413:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 414:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 415:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** #else
 416:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 417:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   /* Run the below code for Cortex-M0 */
 418:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 419:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   float32_t Xchg, in = 0.0f;                     /* Temporary input values  */
 420:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   uint32_t i, rowCnt, flag = 0u, j, loopCnt, k, l;      /* loop counters */
 421:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   arm_status status;                             /* status of matrix inverse */
 422:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 423:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** #ifdef ARM_MATH_MATRIX_CHECK
 424:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 425:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   /* Check for matrix mismatch condition */
 426:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   if ((pSrc->numRows != pSrc->numCols) || (pDst->numRows != pDst->numCols)
 427:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****      || (pSrc->numRows != pDst->numRows))
 428:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   {
 429:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     /* Set status as ARM_MATH_SIZE_MISMATCH */
 430:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     status = ARM_MATH_SIZE_MISMATCH;
 431:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   }
 432:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   else
 433:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** #endif /*      #ifdef ARM_MATH_MATRIX_CHECK    */
 434:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   {
 435:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 436:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     /*---------------------------------------------------------------------------------------------
 437:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 * Matrix Inverse can be solved using elementary row operations.
 438:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *
 439:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *	Gauss-Jordan Method:
 440:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *
 441:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *	   1. First combine the identity matrix and the input matrix separated by a bar to form an
 442:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *        augmented matrix as follows:
 443:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *				        _  _	      _	    _	   _   _         _	       _
 444:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *					   |  |  a11  a12  | | | 1   0  |   |       |  X11 X12  |
 445:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *					   |  |            | | |        |   |   =   |           |
 446:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *					   |_ |_ a21  a22 _| | |_0   1 _|  _|       |_ X21 X21 _|
 447:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *
 448:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *		2. In our implementation, pDst Matrix is used as identity matrix.
 449:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *
 450:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *		3. Begin with the first row. Let i = 1.
 451:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *
 452:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *	    4. Check to see if the pivot for row i is zero.
 453:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *		   The pivot is the element of the main diagonal that is on the current row.
 454:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *		   For instance, if working with row i, then the pivot element is aii.
 455:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *		   If the pivot is zero, exchange that row with a row below it that does not
 456:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *		   contain a zero in column i. If this is not possible, then an inverse
 457:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *		   to that matrix does not exist.
 458:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *
 459:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *	    5. Divide every element of row i by the pivot.
 460:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *
 461:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *	    6. For every row below and  row i, replace that row with the sum of that row and
 462:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *		   a multiple of row i so that each new element in column i below row i is zero.
 463:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *
 464:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *	    7. Move to the next row and column and repeat steps 2 through 5 until you have zeros
 465:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *		   for every element below and above the main diagonal.
 466:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *
 467:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *		8. Now an identical matrix is formed to the left of the bar(input matrix, src).
 468:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *		   Therefore, the matrix to the right of the bar is our solution(dst matrix, dst).
 469:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 	 *------------------------------------------------------------------------------------------------
 470:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 471:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     /* Working pointer for destination matrix */
 472:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     pOutT1 = pOut;
 473:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 474:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     /* Loop over the number of rows */
 475:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     rowCnt = numRows;
 476:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 477:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     /* Making the destination matrix as identity matrix */
 478:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     while (rowCnt > 0u)
 479:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     {
 480:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Writing all zeroes in lower triangle of the destination matrix */
 481:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       j = numRows - rowCnt;
 482:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       while (j > 0u)
 483:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 484:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         *pOutT1++ = 0.0f;
 485:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         j--;
 486:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       }
 487:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 488:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Writing all ones in the diagonal of the destination matrix */
 489:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       *pOutT1++ = 1.0f;
 490:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 491:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Writing all zeroes in upper triangle of the destination matrix */
 492:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       j = rowCnt - 1u;
 493:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       while (j > 0u)
 494:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 495:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         *pOutT1++ = 0.0f;
 496:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         j--;
 497:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       }
 498:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 499:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Decrement the loop counter */
 500:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       rowCnt--;
 501:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     }
 502:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 503:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     /* Loop over the number of columns of the input matrix.
 504:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****        All the elements in each column are processed by the row operations */
 505:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     loopCnt = numCols;
 506:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 507:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     /* Index modifier to navigate through the columns */
 508:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     l = 0u;
 509:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     //for(loopCnt = 0u; loopCnt < numCols; loopCnt++)
 510:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     while (loopCnt > 0u)
 511:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     {
 512:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Check if the pivot element is zero..
 513:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****        * If it is zero then interchange the row with non zero row below.
 514:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****        * If there is no non zero element to replace in the rows below,
 515:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****        * then the matrix is Singular. */
 516:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 517:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Working pointer for the input matrix that points
 518:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****        * to the pivot element of the particular row  */
 519:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       pInT1 = pIn + (l * numCols);
 520:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 521:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Working pointer for the destination matrix that points
 522:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****        * to the pivot element of the particular row  */
 523:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       pOutT1 = pOut + (l * numCols);
 524:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 525:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Temporary variable to hold the pivot value */
 526:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       in = *pInT1;
 527:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 528:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Destination pointer modifier */
 529:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       k = 1u;
 530:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 531:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Check if the pivot element is zero */
 532:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       if (*pInT1 == 0.0f)
 533:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 534:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         /* Loop over the number rows present below */
 535:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         for (i = (l + 1u); i < numRows; i++)
 536:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         {
 537:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           /* Update the input and destination pointers */
 538:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           pInT2 = pInT1 + (numCols * l);
 539:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           pOutT2 = pOutT1 + (numCols * k);
 540:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 541:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           /* Check if there is a non zero pivot element to
 542:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****            * replace in the rows below */
 543:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           if (*pInT2 != 0.0f)
 544:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           {
 545:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             /* Loop over number of columns
 546:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****              * to the right of the pilot element */
 547:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             for (j = 0u; j < (numCols - l); j++)
 548:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             {
 549:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****               /* Exchange the row elements of the input matrix */
 550:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****               Xchg = *pInT2;
 551:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****               *pInT2++ = *pInT1;
 552:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****               *pInT1++ = Xchg;
 553:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             }
 554:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 555:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             for (j = 0u; j < numCols; j++)
 556:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             {
 557:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****               Xchg = *pOutT2;
 558:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****               *pOutT2++ = *pOutT1;
 559:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****               *pOutT1++ = Xchg;
 560:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             }
 561:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 562:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             /* Flag to indicate whether exchange is done or not */
 563:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             flag = 1u;
 564:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 565:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             /* Break after exchange is done */
 566:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             break;
 567:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           }
 568:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 569:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           /* Update the destination pointer modifier */
 570:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           k++;
 571:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         }
 572:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       }
 573:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 574:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Update the status if the matrix is singular */
 575:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       if ((flag != 1u) && (in == 0.0f))
 576:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 577:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         return ARM_MATH_SINGULAR;
 578:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       }
 579:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 580:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Points to the pivot row of input and destination matrices */
 581:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       pPivotRowIn = pIn + (l * numCols);
 582:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       pPivotRowDst = pOut + (l * numCols);
 583:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 584:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Temporary pointers to the pivot row pointers */
 585:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       pInT1 = pPivotRowIn;
 586:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       pOutT1 = pPivotRowDst;
 587:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 588:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Pivot element of the row */
 589:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       in = *(pIn + (l * numCols));
 590:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 591:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Loop over number of columns
 592:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****        * to the right of the pilot element */
 593:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       for (j = 0u; j < (numCols - l); j++)
 594:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 595:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         /* Divide each element of the row of the input matrix
 596:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****          * by the pivot element */
 597:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         *pInT1 = *pInT1 / in;
 598:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         pInT1++;
 599:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       }
 600:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       for (j = 0u; j < numCols; j++)
 601:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 602:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         /* Divide each element of the row of the destination matrix
 603:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****          * by the pivot element */
 604:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         *pOutT1 = *pOutT1 / in;
 605:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         pOutT1++;
 606:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       }
 607:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 608:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Replace the rows with the sum of that row and a multiple of row i
 609:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****        * so that each new element in column i above row i is zero.*/
 610:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 611:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Temporary pointers for input and destination matrices */
 612:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       pInT1 = pIn;
 613:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       pOutT1 = pOut;
 614:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 615:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       for (i = 0u; i < numRows; i++)
 616:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 617:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         /* Check for the pivot element */
 618:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         if (i == l)
 619:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         {
 620:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           /* If the processing element is the pivot element,
 621:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****              only the columns to the right are to be processed */
 622:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           pInT1 += numCols - l;
 623:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           pOutT1 += numCols;
 624:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         }
 625:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         else
 626:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         {
 627:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           /* Element of the reference row */
 628:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           in = *pInT1;
 629:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 630:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           /* Working pointers for input and destination pivot rows */
 631:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           pPRT_in = pPivotRowIn;
 632:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           pPRT_pDst = pPivotRowDst;
 633:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 634:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           /* Loop over the number of columns to the right of the pivot element,
 635:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****              to replace the elements in the input matrix */
 636:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           for (j = 0u; j < (numCols - l); j++)
 637:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           {
 638:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             /* Replace the element by the sum of that row
 639:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****                and a multiple of the reference row  */
 640:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             *pInT1 = *pInT1 - (in * *pPRT_in++);
 641:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             pInT1++;
 642:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           }
 643:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           /* Loop over the number of columns to
 644:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****              replace the elements in the destination matrix */
 645:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           for (j = 0u; j < numCols; j++)
 646:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           {
 647:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             /* Replace the element by the sum of that row
 648:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****                and a multiple of the reference row  */
 649:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             *pOutT1 = *pOutT1 - (in * *pPRT_pDst++);
 650:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             pOutT1++;
 651:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           }
 652:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 653:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         }
 654:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         /* Increment the temporary input pointer */
 655:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         pInT1 = pInT1 + l;
 656:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       }
 657:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Increment the input pointer */
 658:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       pIn++;
 659:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 660:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Decrement the loop counter */
 661:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       loopCnt--;
 662:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       /* Increment the index modifier */
 663:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       l++;
 664:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     }
 665:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 666:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 667:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** #endif /* #if defined (ARM_MATH_DSP) */
 668:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 669:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     /* Set status as ARM_MATH_SUCCESS */
 670:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     status = ARM_MATH_SUCCESS;
 671:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 672:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     if ((flag != 1u) && (in == 0.0f))
 673:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     {
 674:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       pIn = pSrc->pData;
 675:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       for (i = 0; i < numRows * numCols; i++)
 676:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 677:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         if (pIn[i] != 0.0f)
 678:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             break;
 679:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       }
 680:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 681:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       if (i == numRows * numCols)
 682:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         status = ARM_MATH_SINGULAR;
 683:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     }
 684:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   }
 685:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   /* Return to application */
 686:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   return (status);
 687:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** }
  74              	 .loc 1 687 0
  75 001a 09B0     	 add sp,sp,#36
  76              	.LCFI2:
  77              	 .cfi_remember_state
  78              	 .cfi_def_cfa_offset 36
  79              	 
  80 001c BDE8F08F 	 pop {r4,r5,r6,r7,r8,r9,r10,fp,pc}
  81              	.LVL6:
  82              	.L71:
  83              	.LCFI3:
  84              	 .cfi_restore_state
  98:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****      || (pSrc->numRows != pDst->numRows))
  85              	 .loc 1 98 0 discriminator 1
  86 0020 0A88     	 ldrh r2,[r1]
  87              	.LVL7:
  88 0022 4B88     	 ldrh r3,[r1,#2]
  89 0024 9342     	 cmp r3,r2
  90 0026 F6D1     	 bne .L36
  99:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****      || (pSrc->numRows != pDst->numRows))
  91              	 .loc 1 99 0
  92 0028 9C42     	 cmp r4,r3
  93 002a F4D1     	 bne .L36
  94              	.LVL8:
 152:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     {
  95              	 .loc 1 152 0
  96 002c 002C     	 cmp r4,#0
  97 002e 00F0DD80 	 beq .L29
  98 0032 04F18046 	 add r6,r4,#1073741824
 163:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
  99              	 .loc 1 163 0
 100 0036 2346     	 mov r3,r4
 101 0038 013E     	 subs r6,r6,#1
 152:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     {
 102              	 .loc 1 152 0
 103 003a 4FF00009 	 mov r9,#0
 104 003e 671E     	 subs r7,r4,#1
 105 0040 B600     	 lsls r6,r6,#2
 106 0042 019D     	 ldr r5,[sp,#4]
 163:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 107              	 .loc 1 163 0
 108 0044 4FF07E5A 	 mov r10,#1065353216
 109 0048 4C46     	 mov r4,r9
 110 004a 9846     	 mov r8,r3
 111 004c 06E0     	 b .L33
 112              	.LVL9:
 113              	.L72:
 114 004e FFF7FEFF 	 bl memset
 115              	.LVL10:
 116 0052 3544     	 add r5,r5,r6
 117              	.LVL11:
 118 0054 0134     	 adds r4,r4,#1
 119 0056 043E     	 subs r6,r6,#4
 120 0058 09F10409 	 add r9,r9,#4
 121              	.L33:
 122              	.LVL12:
 123 005c 4A46     	 mov r2,r9
 124 005e 2846     	 mov r0,r5
 125 0060 0021     	 movs r1,#0
 156:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 126              	 .loc 1 156 0
 127 0062 14B1     	 cbz r4,.L4
 128              	.LVL13:
 129 0064 FFF7FEFF 	 bl memset
 130              	.LVL14:
 131 0068 4D44     	 add r5,r5,r9
 132              	.LVL15:
 133              	.L4:
 163:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 134              	 .loc 1 163 0
 135 006a C5F800A0 	 str r10,[r5]
 167:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 136              	 .loc 1 167 0
 137 006e BC42     	 cmp r4,r7
 163:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 138              	 .loc 1 163 0
 139 0070 05F10405 	 add r5,r5,#4
 140              	.LVL16:
 141 0074 3246     	 mov r2,r6
 142 0076 2846     	 mov r0,r5
 143 0078 4FF00001 	 mov r1,#0
 167:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 144              	 .loc 1 167 0
 145 007c E7D1     	 bne .L72
 146 007e 4346     	 mov r3,r8
 147 0080 9D00     	 lsls r5,r3,#2
 148              	.LVL17:
 149 0082 A046     	 mov r8,r4
 150 0084 1C46     	 mov r4,r3
 151              	.LVL18:
 152 0086 2B1D     	 adds r3,r5,#4
 153 0088 0793     	 str r3,[sp,#28]
 154 008a 029B     	 ldr r3,[sp,#8]
 155 008c DDF804C0 	 ldr ip,[sp,#4]
 156 0090 CDF81080 	 str r8,[sp,#16]
 157 0094 0027     	 movs r7,#0
 158 0096 A946     	 mov r9,r5
 159 0098 0697     	 str r7,[sp,#24]
 160 009a 1E46     	 mov r6,r3
 161 009c A646     	 mov lr,r4
  77:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****   float32_t *pOut = pDst->pData;                 /* output data matrix pointer */
 162              	 .loc 1 77 0
 163 009e 0393     	 str r3,[sp,#12]
 164              	.LVL19:
 165              	.L27:
 204:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 166              	 .loc 1 204 0
 167 00a0 BC42     	 cmp r4,r7
 200:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 168              	 .loc 1 200 0
 169 00a2 96ED007A 	 flds s14,[r6]
 170              	.LVL20:
 204:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 171              	 .loc 1 204 0
 172 00a6 00F0BB80 	 beq .L67
 173 00aa DFED716A 	 flds s13,.L75
 174 00ae 3A46     	 mov r2,r7
 175 00b0 3346     	 mov r3,r6
 176              	.LVL21:
 177              	.L10:
 206:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         pInT1 += numCols;
 178              	 .loc 1 206 0
 179 00b2 D3ED007A 	 flds s15,[r3]
 180 00b6 F5EEC07A 	 fcmpezs s15
 181 00ba F1EE10FA 	 fmstat
 182 00be D8BF     	 it le
 183 00c0 F1EE677A 	 fnegsle s15,s15
 184 00c4 F4EE667A 	 fcmps s15,s13
 185 00c8 F1EE10FA 	 fmstat
 204:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 186              	 .loc 1 204 0
 187 00cc 02F10102 	 add r2,r2,#1
 188              	.LVL22:
 206:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         pInT1 += numCols;
 189              	 .loc 1 206 0
 190 00d0 C8BF     	 it gt
 191 00d2 F0EE676A 	 fcpysgt s13,s15
 192              	.LVL23:
 204:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 193              	 .loc 1 204 0
 194 00d6 9442     	 cmp r4,r2
 207:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       }
 195              	 .loc 1 207 0
 196 00d8 2B44     	 add r3,r3,r5
 197              	.LVL24:
 204:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 198              	 .loc 1 204 0
 199 00da EAD1     	 bne .L10
 211:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 200              	 .loc 1 211 0
 201 00dc F5EE406A 	 fcmpzs s13
 202 00e0 F1EE10FA 	 fmstat
 203 00e4 00F09C80 	 beq .L67
 204              	.LVL25:
 223:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 205              	 .loc 1 223 0
 206 00e8 B5EEC07A 	 fcmpezs s14
 207 00ec F1EE10FA 	 fmstat
 208 00f0 D4BF     	 ite le
 209 00f2 F1EE477A 	 fnegsle s15,s14
 210 00f6 F0EE477A 	 fcpysgt s15,s14
 211 00fa F4EE667A 	 fcmps s15,s13
 212 00fe F1EE10FA 	 fmstat
 213 0102 10D0     	 beq .L15
 214              	.LVL26:
 228:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         {
 215              	 .loc 1 228 0
 216 0104 049B     	 ldr r3,[sp,#16]
 217 0106 73B1     	 cbz r3,.L15
 218 0108 B5EEC07A 	 fcmpezs s14
 219 010c F1EE10FA 	 fmstat
 236:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           {
 220              	 .loc 1 236 0
 221 0110 F1EE477A 	 fnegs s15,s14
 222 0114 C8BF     	 it gt
 223 0116 F0EE477A 	 fcpysgt s15,s14
 224 011a F4EE667A 	 fcmps s15,s13
 225 011e F1EE10FA 	 fmstat
 226 0122 00F08180 	 beq .L73
 227              	.LVL27:
 228              	.L15:
 283:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 229              	 .loc 1 283 0
 230 0126 069B     	 ldr r3,[sp,#24]
 231 0128 33B9     	 cbnz r3,.L66
 283:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 232              	 .loc 1 283 0 is_stmt 0 discriminator 1
 233 012a B5EE407A 	 fcmpzs s14
 234 012e F1EE10FA 	 fmstat
 235 0132 75D0     	 beq .L67
 236 0134 0023     	 movs r3,#0
 237 0136 0693     	 str r3,[sp,#24]
 238              	.LVL28:
 239              	.L66:
 240 0138 0CEB0503 	 add r3,ip,r5
 241 013c 0593     	 str r3,[sp,#20]
 242              	.LVL29:
 243              	.L19:
 244 013e 7246     	 mov r2,lr
 245 0140 3346     	 mov r3,r6
 246              	.LVL30:
 247              	.L20:
 307:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         *pInT1++ = in1 / in;
 248              	 .loc 1 307 0 is_stmt 1
 249 0142 D3ED007A 	 flds s15,[r3]
 250              	.LVL31:
 308:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 251              	 .loc 1 308 0
 252 0146 C7EE877A 	 fdivs s15,s15,s14
 253              	.LVL32:
 303:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 254              	 .loc 1 303 0
 255 014a 013A     	 subs r2,r2,#1
 256              	.LVL33:
 308:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 257              	 .loc 1 308 0
 258 014c E3EC017A 	 fstmias r3!,{s15}
 259              	.LVL34:
 303:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 260              	 .loc 1 303 0
 261 0150 F7D1     	 bne .L20
 262 0152 2146     	 mov r1,r4
 263 0154 6346     	 mov r3,ip
 264              	.LVL35:
 265              	.L21:
 321:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         *pInT2++ = in1 / in;
 266              	 .loc 1 321 0
 267 0156 D3ED007A 	 flds s15,[r3]
 268              	.LVL36:
 322:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 269              	 .loc 1 322 0
 270 015a C7EE877A 	 fdivs s15,s15,s14
 271              	.LVL37:
 317:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 272              	 .loc 1 317 0
 273 015e 0139     	 subs r1,r1,#1
 274              	.LVL38:
 322:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 275              	 .loc 1 322 0
 276 0160 E3EC017A 	 fstmias r3!,{s15}
 277              	.LVL39:
 317:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 278              	 .loc 1 317 0
 279 0164 F7D1     	 bne .L21
 280              	.LVL40:
 281 0166 0198     	 ldr r0,[sp,#4]
 282 0168 DDF80CB0 	 ldr fp,[sp,#12]
 283 016c 4FEA8708 	 lsl r8,r7,#2
 284              	.LVL41:
 285              	.L26:
 345:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         {
 286              	 .loc 1 345 0
 287 0170 B942     	 cmp r1,r7
 288 0172 79D0     	 beq .L74
 356:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 289              	 .loc 1 356 0
 290 0174 9BED007A 	 flds s14,[fp]
 291              	.LVL42:
 292 0178 7246     	 mov r2,lr
 293 017a B246     	 mov r10,r6
 294 017c 5B46     	 mov r3,fp
 295              	.LVL43:
 296              	.L24:
 370:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             *pInT1++ = in1 - (in * *pPRT_in++);
 297              	 .loc 1 370 0
 298 017e D3ED007A 	 flds s15,[r3]
 299              	.LVL44:
 300 0182 FAEC016A 	 fldmias r10!,{s13}
 301              	.LVL45:
 371:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 302              	 .loc 1 371 0
 303 0186 E6EEC77A 	 vfms.f32 s15,s13,s14
 304              	.LVL46:
 366:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           {
 305              	 .loc 1 366 0
 306 018a 013A     	 subs r2,r2,#1
 307              	.LVL47:
 371:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 308              	 .loc 1 371 0
 309 018c E3EC017A 	 fstmias r3!,{s15}
 310              	.LVL48:
 366:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           {
 311              	 .loc 1 366 0
 312 0190 F5D1     	 bne .L24
 313 0192 CB44     	 add fp,fp,r9
 314              	.LVL49:
 315 0194 2246     	 mov r2,r4
 316 0196 E246     	 mov r10,ip
 317              	.LVL50:
 318 0198 0346     	 mov r3,r0
 319              	.LVL51:
 320              	.L25:
 385:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             *pInT2++ = in1 - (in * *pPRT_pDst++);
 321              	 .loc 1 385 0
 322 019a D3ED007A 	 flds s15,[r3]
 323              	.LVL52:
 324 019e FAEC016A 	 fldmias r10!,{s13}
 325              	.LVL53:
 386:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 326              	 .loc 1 386 0
 327 01a2 E6EEC77A 	 vfms.f32 s15,s13,s14
 328              	.LVL54:
 381:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           {
 329              	 .loc 1 381 0
 330 01a6 013A     	 subs r2,r2,#1
 331              	.LVL55:
 386:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 332              	 .loc 1 386 0
 333 01a8 E3EC017A 	 fstmias r3!,{s15}
 334              	.LVL56:
 381:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           {
 335              	 .loc 1 381 0
 336 01ac F5D1     	 bne .L25
 337 01ae 2844     	 add r0,r0,r5
 338              	.LVL57:
 339              	.L23:
 401:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       }
 340              	 .loc 1 401 0
 341 01b0 0131     	 adds r1,r1,#1
 342              	.LVL58:
 342:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 343              	 .loc 1 342 0
 344 01b2 8C42     	 cmp r4,r1
 395:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 345              	 .loc 1 395 0
 346 01b4 C344     	 add fp,fp,r8
 347              	.LVL59:
 342:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 348              	 .loc 1 342 0
 349 01b6 DBD1     	 bne .L26
 405:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 350              	 .loc 1 405 0
 351 01b8 039B     	 ldr r3,[sp,#12]
 352 01ba DDF814C0 	 ldr ip,[sp,#20]
 353              	.LVL60:
 354 01be 0433     	 adds r3,r3,#4
 355 01c0 0393     	 str r3,[sp,#12]
 356              	.LVL61:
 357 01c2 079B     	 ldr r3,[sp,#28]
 358              	.LVL62:
 359 01c4 1E44     	 add r6,r6,r3
 360              	.LVL63:
 361 01c6 049B     	 ldr r3,[sp,#16]
 184:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     {
 362              	 .loc 1 184 0
 363 01c8 BEF1010E 	 subs lr,lr,#1
 364              	.LVL64:
 365 01cc 03F1FF33 	 add r3,r3,#-1
 411:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     }
 366              	 .loc 1 411 0
 367 01d0 07F10107 	 add r7,r7,#1
 368              	.LVL65:
 369 01d4 0493     	 str r3,[sp,#16]
 370 01d6 A9F10409 	 sub r9,r9,#4
 184:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     {
 371              	 .loc 1 184 0
 372 01da 7FF461AF 	 bne .L27
 373              	.LVL66:
 672:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     {
 374              	 .loc 1 672 0
 375 01de 069B     	 ldr r3,[sp,#24]
 376 01e0 03BB     	 cbnz r3,.L30
 672:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     {
 377              	 .loc 1 672 0 is_stmt 0 discriminator 1
 378 01e2 B5EE407A 	 fcmpzs s14
 379 01e6 F1EE10FA 	 fmstat
 380 01ea 1BD1     	 bne .L30
 381              	.LVL67:
 382              	.L29:
 675:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 383              	 .loc 1 675 0 is_stmt 1
 384 01ec 04FB04F4 	 mul r4,r4,r4
 385 01f0 B4B1     	 cbz r4,.L67
 677:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             break;
 386              	 .loc 1 677 0
 387 01f2 029A     	 ldr r2,[sp,#8]
 388 01f4 D2ED007A 	 flds s15,[r2]
 389 01f8 F5EE407A 	 fcmpzs s15
 390 01fc F1EE10FA 	 fmstat
 391 0200 1346     	 mov r3,r2
 392 0202 0FD1     	 bne .L30
 393 0204 0433     	 adds r3,r3,#4
 394 0206 1A46     	 mov r2,r3
 395 0208 0023     	 movs r3,#0
 396 020a 06E0     	 b .L31
 397              	.LVL68:
 398              	.L32:
 399 020c F2EC017A 	 fldmias r2!,{s15}
 400 0210 F5EE407A 	 fcmpzs s15
 401 0214 F1EE10FA 	 fmstat
 402 0218 04D1     	 bne .L30
 403              	.LVL69:
 404              	.L31:
 675:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****       {
 405              	 .loc 1 675 0 discriminator 2
 406 021a 0133     	 adds r3,r3,#1
 407              	.LVL70:
 408 021c A342     	 cmp r3,r4
 409 021e F5D1     	 bne .L32
 410              	.LVL71:
 411              	.L67:
 682:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****     }
 412              	 .loc 1 682 0
 413 0220 FB20     	 movs r0,#251
 414 0222 F9E6     	 b .L2
 415              	.LVL72:
 416              	.L30:
 670:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 417              	 .loc 1 670 0
 418 0224 0020     	 movs r0,#0
 419 0226 F7E6     	 b .L2
 420              	.LVL73:
 421              	.L73:
 236:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****           {
 422              	 .loc 1 236 0
 423 0228 039B     	 ldr r3,[sp,#12]
 424              	.LVL74:
 425 022a 7146     	 mov r1,lr
 426 022c 3246     	 mov r2,r6
 427              	.LVL75:
 428              	.L16:
 245:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****               *pInT2++ = *pInT1;
 429              	 .loc 1 245 0
 430 022e 1068     	 ldr r0,[r2]
 431              	.LVL76:
 246:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****               *pInT1++ = Xchg;
 432              	 .loc 1 246 0
 433 0230 D3F80080 	 ldr r8,[r3]
 434 0234 42F8048B 	 str r8,[r2],#4
 435              	.LVL77:
 242:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             {
 436              	 .loc 1 242 0
 437 0238 0139     	 subs r1,r1,#1
 438              	.LVL78:
 247:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 439              	 .loc 1 247 0
 440 023a 43F8040B 	 str r0,[r3],#4
 441              	.LVL79:
 242:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             {
 442              	 .loc 1 242 0
 443 023e F6D1     	 bne .L16
 444 0240 0CEB0503 	 add r3,ip,r5
 445              	.LVL80:
 446 0244 0593     	 str r3,[sp,#20]
 447 0246 1946     	 mov r1,r3
 448              	.LVL81:
 449 0248 2246     	 mov r2,r4
 450              	.LVL82:
 451 024a 6346     	 mov r3,ip
 452              	.LVL83:
 453              	.L18:
 259:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****               *pOutT2++ = *pOutT1;
 454              	 .loc 1 259 0
 455 024c 0868     	 ldr r0,[r1]
 456              	.LVL84:
 260:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****               *pOutT1++ = Xchg;
 457              	 .loc 1 260 0
 458 024e D3F80080 	 ldr r8,[r3]
 459 0252 41F8048B 	 str r8,[r1],#4
 460              	.LVL85:
 256:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             {
 461              	 .loc 1 256 0
 462 0256 013A     	 subs r2,r2,#1
 463              	.LVL86:
 261:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 464              	 .loc 1 261 0
 465 0258 43F8040B 	 str r0,[r3],#4
 466              	.LVL87:
 256:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****             {
 467              	 .loc 1 256 0
 468 025c F6D1     	 bne .L18
 268:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 469              	 .loc 1 268 0
 470 025e 0123     	 movs r3,#1
 471              	.LVL88:
 472 0260 96ED007A 	 flds s14,[r6]
 473              	.LVL89:
 474 0264 0693     	 str r3,[sp,#24]
 475              	.LVL90:
 476 0266 6AE7     	 b .L19
 477              	.LVL91:
 478              	.L74:
 349:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c **** 
 479              	 .loc 1 349 0
 480 0268 CB44     	 add fp,fp,r9
 481              	.LVL92:
 351:../Dave/Generated/CMSIS_DSP/MatrixFunctions/arm_mat_inverse_f32.c ****         }
 482              	 .loc 1 351 0
 483 026a 2844     	 add r0,r0,r5
 484              	.LVL93:
 485 026c A0E7     	 b .L23
 486              	.L76:
 487 026e 00BF     	 .align 2
 488              	.L75:
 489 0270 00000000 	 .word 0
 490              	 .cfi_endproc
 491              	.LFE135:
 493              	 .text
 494              	.Letext0:
 495              	 .file 2 "c:\\infineon\\tools\\dave ide\\4.5.0.202105191637\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\machine\\_default_types.h"
 496              	 .file 3 "c:\\infineon\\tools\\dave ide\\4.5.0.202105191637\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\stdint.h"
 497              	 .file 4 "C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Dave/Generated/CMSIS_DSP/arm_math.h"
DEFINED SYMBOLS
                            *ABS*:00000000 arm_mat_inverse_f32.c
    {standard input}:20     .text.arm_mat_inverse_f32:00000000 $t
    {standard input}:25     .text.arm_mat_inverse_f32:00000000 arm_mat_inverse_f32
    {standard input}:489    .text.arm_mat_inverse_f32:00000270 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
memset
