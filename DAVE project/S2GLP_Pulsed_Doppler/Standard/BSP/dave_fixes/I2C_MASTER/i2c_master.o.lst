   1              	 .syntax unified
   2              	 .cpu cortex-m4
   3              	 .eabi_attribute 27,3
   4              	 .fpu vfp
   5              	 .eabi_attribute 20,1
   6              	 .eabi_attribute 21,1
   7              	 .eabi_attribute 23,3
   8              	 .eabi_attribute 24,1
   9              	 .eabi_attribute 25,1
  10              	 .eabi_attribute 26,1
  11              	 .eabi_attribute 30,2
  12              	 .eabi_attribute 34,1
  13              	 .eabi_attribute 18,4
  14              	 .thumb
  15              	 .file "i2c_master.c"
  16              	 .text
  17              	.Ltext0:
  18              	 .cfi_sections .debug_frame
  19              	 .section .text.I2C_MASTER_GetAppVersion,"ax",%progbits
  20              	 .align 2
  21              	 .global I2C_MASTER_GetAppVersion
  22              	 .thumb
  23              	 .thumb_func
  25              	I2C_MASTER_GetAppVersion:
  26              	.LFB235:
  27              	 .file 1 "../BSP/dave_fixes/I2C_MASTER/i2c_master.c"
   1:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** /**
   2:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * @file i2c_master.c
   3:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * @date 2017-12-20
   4:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  *
   5:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * NOTE:
   6:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * This file is generated by DAVE. Any manual modification done to this file will be lost when the 
   7:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  */
   8:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** /**
   9:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * @cond
  10:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  **************************************************************************************************
  11:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * I2C_MASTER v4.1.28 Configures USIC channel to transmit & receive data using I2C protocol.
  12:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  *
  13:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * Copyright (c) 2015-2018, Infineon Technologies AG
  14:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * All rights reserved.
  15:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  *
  16:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * Redistribution and use in source and binary forms, with or without modification,are permitted pr
  17:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * following conditions are met:
  18:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  *
  19:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  *   Redistributions of source code must retain the above copyright notice, this list of conditions
  20:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  *   disclaimer.
  21:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  *
  22:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  *   Redistributions in binary form must reproduce the above copyright notice, this list of conditi
  23:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  *   following disclaimer in the documentation and/or other materials provided with the distributio
  24:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  *
  25:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  *   Neither the name of the copyright holders nor the names of its contributors may be used to end
  26:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  *   products derived from this software without specific prior written permission.
  27:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  *
  28:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR I
  29:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTI
  30:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, IN
  31:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBS
  32:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THE
  33:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
  34:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  35:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  *
  36:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * To improve the quality of the software, users are encouraged to share modifications, enhancement
  37:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * with Infineon Technologies AG (dave@infineon.com).
  38:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  **************************************************************************************************
  39:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  *
  40:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * Change History
  41:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * --------------
  42:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  *
  43:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * 2015-02-16:
  44:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  *     - Initial version<br>
  45:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  *
  46:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * 2015-06-10:
  47:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  *     - AbortTransmit and AbortReceive API return type modified. <br>
  48:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  *
  49:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * 2015-07-31:
  50:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  *     - DMA support APIs added
  51:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  *
  52:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * 2017-01-19:
  53:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  *     - Avoid unintended interrupts when filling FIFO
  54:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  *
  55:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * 2017-11-17:
  56:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  *     - Use tx_irqn of channel config structure in the call of NVIC_ClearPendingIRQ()
  57:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  *
  58:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * 2017-12-20:
  59:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  *     - Fix TX DMA issues
  60:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  *
  61:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * @endcond
  62:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  *
  63:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  */
  64:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** /**************************************************************************************************
  65:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * HEADER FILES
  66:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  **************************************************************************************************
  67:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #include "i2c_master.h"
  68:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
  69:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** /**************************************************************************************************
  70:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * MACROS
  71:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  **************************************************************************************************
  72:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #define I2C_MASTER_TDF_RECEIVE_ACK             (0x0200U)
  73:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #define I2C_MASTER_TDF_RECEIVE_NACK       (3U << 8U)
  74:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #define I2C_MASTER_DMA_SRC_DST_TR_WIDTH_MASK   (0x7EU)
  75:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #define I2C_MASTER_DMA_SRC_ADDR_INC_MASK       (0x600U)
  76:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #define I2C_MASTER_DMA_SRC_ADDR_INC_POS        (9U)
  77:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #define I2C_MASTER_DMA_SRC_TRANSFER_WIDTH_POS  (4U)
  78:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #define I2C_MASTER_DMA_DST_TRANSFER_WIDTH_POS  (1U)
  79:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
  80:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #define I2C_DMA_MAX_BLOCK_SIZE (4095U)
  81:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
  82:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** /**************************************************************************************************
  83:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * LOCAL DATA
  84:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  **************************************************************************************************
  85:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
  86:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** /**************************************************************************************************
  87:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * LOCAL ROUTINES
  88:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  **************************************************************************************************
  89:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  /*
  90:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * Function monitors the configured protocol interrupt flags. It is called from the protocol interr
  91:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * service handler.
  92:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * Function reads the status of the USIC channel and checks for configured flags in the app UI.
  93:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * If any callback function is provided in the app UI, it will be called when the selected flag is 
  94:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  *
  95:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * I2C_MASTER_t * pointer to the I2C_MASTER APP instance handle
  96:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  *
  97:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  */
  98:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** void I2C_MASTER_ProtocolHandler(I2C_MASTER_t * const handle);
  99:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 100:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #if ((I2C_MASTER_INTERRUPT_TX_ENABLED == 1) || (I2C_MASTER_INTERRUPT_RX_ENABLED == 1))
 101:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** static uint32_t calculate_minfifosize(uint32_t a, uint32_t b)
 102:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** {
 103:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   uint32_t result;
 104:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 105:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   if (a < b)
 106:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
 107:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     result = a;
 108:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   }
 109:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   else
 110:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
 111:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     result = b;
 112:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   }
 113:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   return (result);
 114:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** }
 115:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #endif
 116:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 117:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #if ((I2C_MASTER_INTERRUPT_TX_ENABLED == 1) || (I2C_MASTER_INTERRUPT_RX_ENABLED == 1) || \
 118:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     (I2C_MASTER_DIRECT_TX_ENABLED == 1) || (I2C_MASTER_DIRECT_RX_ENABLED == 1))
 119:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** static void I2C_MASTER_lSendStart_Or_RepeatedStart(I2C_MASTER_t * handle, const uint32_t address,
 120:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****                                                const XMC_I2C_CH_CMD_t cmd);
 121:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #endif
 122:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 123:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #if ((I2C_MASTER_INTERRUPT_TX_ENABLED == 1) || (I2C_MASTER_INTERRUPT_RX_ENABLED == 1))
 124:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** static void I2C_MASTER_lSendStop_JumpTo_TxCallback(I2C_MASTER_t *const handle);
 125:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #endif
 126:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 127:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #if (I2C_MASTER_INTERRUPT_TX_ENABLED == 1)
 128:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** static void I2C_MASTER_AbortTransmitIRQ(const I2C_MASTER_t *const handle);
 129:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #endif
 130:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 131:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #if (I2C_MASTER_INTERRUPT_RX_ENABLED == 1)
 132:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** static void I2C_MASTER_lSendStop_JumpTo_RxCallback(I2C_MASTER_t *const handle);
 133:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** static void I2C_MASTER_lReconfigureRxFIFO(const I2C_MASTER_t * const handle, uint32_t data_size);
 134:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 135:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** static void I2C_MASTER_lReceive_FIFOData(I2C_MASTER_t * const handle, bool send_start, const uint32
 136:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****                                          const uint32_t count);
 137:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 138:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** static void I2C_MASTER_lReceive_StdData(I2C_MASTER_t * const handle, bool send_start, const uint32_
 139:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** static void I2C_MASTER_lAbortReceiveIRQ(const I2C_MASTER_t *const handle);
 140:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #endif
 141:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 142:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 143:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #if (I2C_MASTER_DIRECT_TX_ENABLED == 1)
 144:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** static I2C_MASTER_STATUS_t I2C_MASTER_lStartTransmitPolling(I2C_MASTER_t *const handle, bool send_s
 145:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****                                                         const uint32_t slave_address, uint8_t *data
 146:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****                               bool send_stop);
 147:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #endif
 148:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #if I2C_MASTER_DIRECT_RX_ENABLED
 149:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** static I2C_MASTER_STATUS_t I2C_MASTER_lStartReceivePolling(I2C_MASTER_t *const handle, bool send_st
 150:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****                                                        uint8_t *data, uint32_t count, bool send_sto
 151:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****                                bool send_nack);
 152:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #endif
 153:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #if (I2C_MASTER_DMA_TX_ENABLED == 1)
 154:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** static void I2C_MASTER_lAbortTransmitDMA(const I2C_MASTER_t *const handle);
 155:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #endif
 156:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #if (I2C_MASTER_DMA_RX_ENABLED == 1)
 157:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** static void I2C_MASTER_lAbortReceiveDMA(const I2C_MASTER_t *const handle);
 158:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #endif
 159:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 160:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #if (I2C_MASTER_DMA_TX_ENABLED == 1) && (I2C_MASTER_DMA_RX_ENABLED == 1)
 161:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** /* DMA buffer to send the ACK */
 162:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** static uint16_t ack_buf[1];
 163:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** static uint16_t nack_buf[1];
 164:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #endif
 165:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 166:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** /**************************************************************************************************
 167:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** * API IMPLEMENTATION
 168:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** ***************************************************************************************************
 169:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 170:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** /*
 171:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * @brief API to retrieve the version of the I2C_MASTER APP.
 172:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  *
 173:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * @return DAVE_APP_VERSION_t Structure containing major version, minor version
 174:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  *         and patch version.
 175:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  */
 176:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** DAVE_APP_VERSION_t I2C_MASTER_GetAppVersion(void)
 177:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** {
  28              	 .loc 1 177 0
  29              	 .cfi_startproc
  30              	 
  31              	 
  32              	 
  33              	.LVL0:
 178:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   DAVE_APP_VERSION_t version;
 179:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 180:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   version.major = I2C_MASTER_MAJOR_VERSION;
 181:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   version.minor = I2C_MASTER_MINOR_VERSION;
 182:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   version.patch = I2C_MASTER_PATCH_VERSION;
 183:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 184:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   return (version);
  34              	 .loc 1 184 0
  35 0000 0423     	 movs r3,#4
  36 0002 0020     	 movs r0,#0
  37 0004 63F30700 	 bfi r0,r3,#0,#8
  38 0008 0123     	 movs r3,#1
  39 000a 63F30F20 	 bfi r0,r3,#8,#8
  40 000e 1C23     	 movs r3,#28
  41 0010 63F31740 	 bfi r0,r3,#16,#8
 177:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   DAVE_APP_VERSION_t version;
  42              	 .loc 1 177 0
  43 0014 82B0     	 sub sp,sp,#8
  44              	.LCFI0:
  45              	 .cfi_def_cfa_offset 8
 185:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** }
  46              	 .loc 1 185 0
  47 0016 02B0     	 add sp,sp,#8
  48              	.LCFI1:
  49              	 .cfi_def_cfa_offset 0
  50              	 
  51 0018 7047     	 bx lr
  52              	 .cfi_endproc
  53              	.LFE235:
  55 001a 00BF     	 .section .text.I2C_MASTER_Init,"ax",%progbits
  56              	 .align 2
  57              	 .global I2C_MASTER_Init
  58              	 .thumb
  59              	 .thumb_func
  61              	I2C_MASTER_Init:
  62              	.LFB236:
 186:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 187:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** /* Function to initialize the USIC Channel with GUI configured values.*/
 188:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** I2C_MASTER_STATUS_t I2C_MASTER_Init(const I2C_MASTER_t *const handle)
 189:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** {
  63              	 .loc 1 189 0
  64              	 .cfi_startproc
  65              	 
  66              	 
  67              	.LVL1:
 190:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   I2C_MASTER_STATUS_t status;
 191:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 192:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   if (handle != NULL)
  68              	 .loc 1 192 0
  69 0000 28B1     	 cbz r0,.L5
 189:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   I2C_MASTER_STATUS_t status;
  70              	 .loc 1 189 0
  71 0002 08B5     	 push {r3,lr}
  72              	.LCFI2:
  73              	 .cfi_def_cfa_offset 8
  74              	 .cfi_offset 3,-8
  75              	 .cfi_offset 14,-4
 193:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
 194:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     /*Initialize the multiplexers required for I2C_MASTER configuration*/
 195:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     handle->config->fptr_i2c_config();
  76              	 .loc 1 195 0
  77 0004 4368     	 ldr r3,[r0,#4]
  78 0006 5B68     	 ldr r3,[r3,#4]
  79 0008 9847     	 blx r3
  80              	.LVL2:
 196:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 197:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     status = I2C_MASTER_STATUS_SUCCESS;
  81              	 .loc 1 197 0
  82 000a 0020     	 movs r0,#0
  83 000c 08BD     	 pop {r3,pc}
  84              	.LVL3:
  85              	.L5:
  86              	.LCFI3:
  87              	 .cfi_def_cfa_offset 0
  88              	 .cfi_restore 3
  89              	 .cfi_restore 14
 198:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   }
 199:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   else
 200:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
 201:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     status = I2C_MASTER_STATUS_FAILURE;
  90              	 .loc 1 201 0
  91 000e 0120     	 movs r0,#1
  92              	.LVL4:
  93 0010 7047     	 bx lr
  94              	 .cfi_endproc
  95              	.LFE236:
  97 0012 00BF     	 .section .text.I2C_MASTER_GetFlagStatus,"ax",%progbits
  98              	 .align 2
  99              	 .global I2C_MASTER_GetFlagStatus
 100              	 .thumb
 101              	 .thumb_func
 103              	I2C_MASTER_GetFlagStatus:
 104              	.LFB237:
 202:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   }
 203:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   return (status);
 204:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** }
 205:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 206:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** /* Function to get flag status of the requested parameter */
 207:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** uint32_t I2C_MASTER_GetFlagStatus(const I2C_MASTER_t *handle, uint32_t flagtype)
 208:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** {
 105              	 .loc 1 208 0
 106              	 .cfi_startproc
 107              	 
 108              	 
 109              	 
 110              	.LVL5:
 209:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   uint32_t status;
 210:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 211:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   status = XMC_I2C_CH_GetStatusFlag(handle->channel);
 111              	 .loc 1 211 0
 112 0000 0368     	 ldr r3,[r0]
 113              	.LVL6:
 114              	.LBB162:
 115              	.LBB163:
 116              	 .file 2 "C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc/xmc_i2c.h"
   1:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** /**
   2:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @file xmc_i2c.h
   3:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @date 2016-05-20
   4:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
   5:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @cond
   6:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  **************************************************************************************************
   7:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * XMClib v2.1.16 - XMC Peripheral Driver Library 
   8:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
   9:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * Copyright (c) 2015-2017, Infineon Technologies AG
  10:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * All rights reserved.                        
  11:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *                                             
  12:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * Redistribution and use in source and binary forms, with or without modification,are permitted pr
  13:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * following conditions are met:   
  14:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *                                                                              
  15:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * Redistributions of source code must retain the above copyright notice, this list of conditions a
  16:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * disclaimer.                        
  17:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * 
  18:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * Redistributions in binary form must reproduce the above copyright notice, this list of condition
  19:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * disclaimer in the documentation and/or other materials provided with the distribution.          
  20:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * 
  21:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * Neither the name of the copyright holders nor the names of its contributors may be used to endor
  22:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * products derived from this software without specific prior written permission.                  
  23:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *                                                                              
  24:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR I
  25:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTI
  26:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, IN
  27:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBS
  28:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THE
  29:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
  30:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                            
  31:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *                                                                              
  32:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * To improve the quality of the software, users are encouraged to share modifications, enhancement
  33:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * Infineon Technologies AG dave@infineon.com).                                                    
  34:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  **************************************************************************************************
  35:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
  36:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * Change History
  37:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * --------------
  38:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
  39:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * 2015-02-20:
  40:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *     - Initial <br>
  41:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *      
  42:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * 2015-05-20:
  43:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *     - Description updated <br>
  44:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *     - Added XMC_I2C_CH_TriggerServiceRequest() and XMC_I2C_CH_SelectInterruptNodePointer() <br>
  45:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
  46:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * 2015-06-20:
  47:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *     - Removed version macros and declaration of GetDriverVersion API <br>
  48:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
  49:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * 2015-08-27:
  50:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *     - Added APIs for external input for BRG configuration:XMC_I2C_CH_ConfigExternalInputSignalTo
  51:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
  52:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * 2015-09-01:
  53:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *     - Added APIs for enabling or disabling the ACK response to a 0x00 slave address: XMC_I2C_CH_
  54:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *       XMC_I2C_CH_DisableSlaveAcknowledgeTo00(). <br>
  55:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *     - Modified XMC_I2C_CH_SetInputSource() API for avoiding complete DXCR register overwriting. 
  56:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *     - Modified XMC_I2C_CH_EVENT_t enum for supporting XMC_I2C_CH_EnableEvent() and XMC_I2C_CH_Di
  57:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *       for supporting multiple events configuration <br>
  58:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
  59:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * 2015-10-02:
  60:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *     - Fix 10bit addressing
  61:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
  62:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * 2015-10-07:
  63:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *     - Fix register access in XMC_I2C_CH_EnableSlaveAcknowledgeTo00() and XMC_I2C_CH_DisableSlave
  64:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *     - Naming of APIs modified: from XMC_I2C_CH_EnableSlaveAcknowledgeTo00() to  XMC_I2C_CH_Enabl
  65:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *       and from XMC_I2C_CH_DisableSlaveAcknowledgeTo00() to XMC_I2C_CH_DisableAcknowledgeAddress0
  66:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
  67:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * 2016-05-20:
  68:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *     - Added XMC_I2C_CH_EnableDataTransmission() and XMC_I2C_CH_DisableDataTransmission()
  69:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
  70:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * 2016-08-17:
  71:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *     - Improved documentation of slave address passing
  72:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
  73:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @endcond 
  74:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
  75:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  */
  76:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** 
  77:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** #ifndef XMC_I2C_H
  78:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** #define XMC_I2C_H
  79:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** 
  80:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** /*******************************************************************************
  81:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * HEADER FILES
  82:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *******************************************************************************/
  83:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** 
  84:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** #include "xmc_usic.h"
  85:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** 
  86:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** /**
  87:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @addtogroup XMClib XMC Peripheral Library
  88:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @{
  89:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  */
  90:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** 
  91:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** /**
  92:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @addtogroup I2C
  93:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @brief Inter Integrated Circuit(IIC) driver for the XMC microcontroller family. 
  94:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
  95:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * USIC IIC Features: <br>
  96:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *  * Two-wire interface, with one line for shift clock transfer and synchronization (shift clock S
  97:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *	* Communication in standard mode (100 kBit/s) or in fast mode (up to 400 kBit/s) <br>
  98:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *	* Support of 7-bit addressing, as well as 10-bit addressing <br>
  99:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *	* Master mode operation, where the IIC controls the bus transactions and provides the clock sign
 100:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *	* Slave mode operation, where an external master controls the bus transactions and provides the 
 101:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *	* Multi-master mode operation, where several masters can be connected to the bus and bus arbitra
 102:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** 	  The master/slave operation of an IIC bus participant can change from frame to frame. <br>
 103:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *	* Efficient frame handling (low software effort), also allowing DMA transfers <br>
 104:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *	* Powerful interrupt handling due to multitude of indication flags <br>
 105:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @{
 106:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  */
 107:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** 
 108:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** /*******************************************************************************
 109:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * MACROS
 110:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *******************************************************************************/
 111:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** 
 112:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** #if defined(USIC0)
 113:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** #define XMC_I2C0_CH0 XMC_USIC0_CH0                   /**< USIC0 channel 0 base address */
 114:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** #define XMC_I2C0_CH1 XMC_USIC0_CH1                   /**< USIC0 channel 1 base address */
 115:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** #endif
 116:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** 
 117:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** #if defined(USIC1)
 118:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** #define XMC_I2C1_CH0 XMC_USIC1_CH0                   /**< USIC1 channel 0 base address */
 119:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** #define XMC_I2C1_CH1 XMC_USIC1_CH1                   /**< USIC1 channel 1 base address */
 120:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** #endif
 121:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** 
 122:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** #if defined(USIC2)
 123:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** #define XMC_I2C2_CH0 XMC_USIC2_CH0                   /**< USIC2 channel 0 base address */
 124:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** #define XMC_I2C2_CH1 XMC_USIC2_CH1                   /**< USIC2 channel 1 base address */
 125:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** #endif
 126:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** 
 127:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** #define XMC_I2C_10BIT_ADDR_GROUP       (0x7800U)	 /**< Value to verify the address is 10-bit or not
 128:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** 
 129:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** /*******************************************************************************
 130:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * ENUMS
 131:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *******************************************************************************/
 132:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** 
 133:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** /**
 134:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @brief I2C Status
 135:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  */
 136:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** typedef enum XMC_I2C_CH_STATUS
 137:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** {
 138:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****   XMC_I2C_CH_STATUS_OK,      /**< Status OK */
 139:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****   XMC_I2C_CH_STATUS_ERROR,   /**< Status ERROR */
 140:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****   XMC_I2C_CH_STATUS_BUSY     /**< Status BUSY */
 141:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** } XMC_I2C_CH_STATUS_t;
 142:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** 
 143:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** /**
 144:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @brief I2C status
 145:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  */
 146:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** typedef enum XMC_I2C_CH_STATUS_FLAG
 147:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** {
 148:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****   XMC_I2C_CH_STATUS_FLAG_SLAVE_SELECT = USIC_CH_PSR_IICMode_SLSEL_Msk,                     /**< Sla
 149:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****   XMC_I2C_CH_STATUS_FLAG_WRONG_TDF_CODE_FOUND = USIC_CH_PSR_IICMode_WTDF_Msk,              /**< Wro
 150:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****   XMC_I2C_CH_STATUS_FLAG_START_CONDITION_RECEIVED = USIC_CH_PSR_IICMode_SCR_Msk,           /**< Sta
 151:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****   XMC_I2C_CH_STATUS_FLAG_REPEATED_START_CONDITION_RECEIVED = USIC_CH_PSR_IICMode_RSCR_Msk, /**< Rep
 152:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****   XMC_I2C_CH_STATUS_FLAG_STOP_CONDITION_RECEIVED = USIC_CH_PSR_IICMode_PCR_Msk,            /**< Sto
 153:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****   XMC_I2C_CH_STATUS_FLAG_NACK_RECEIVED = USIC_CH_PSR_IICMode_NACK_Msk,                     /**< NAC
 154:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****   XMC_I2C_CH_STATUS_FLAG_ARBITRATION_LOST = USIC_CH_PSR_IICMode_ARL_Msk,                   /**< Arb
 155:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****   XMC_I2C_CH_STATUS_FLAG_SLAVE_READ_REQUESTED = USIC_CH_PSR_IICMode_SRR_Msk,               /**< Sla
 156:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****   XMC_I2C_CH_STATUS_FLAG_ERROR = USIC_CH_PSR_IICMode_ERR_Msk,                              /**< Err
 157:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****   XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED = USIC_CH_PSR_IICMode_ACK_Msk,                       /**< ACK
 158:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****   XMC_I2C_CH_STATUS_FLAG_RECEIVER_START_INDICATION = USIC_CH_PSR_IICMode_RSIF_Msk,         /**< Rec
 159:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****   XMC_I2C_CH_STATUS_FLAG_DATA_LOST_INDICATION = USIC_CH_PSR_IICMode_DLIF_Msk,              /**< Dat
 160:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****   XMC_I2C_CH_STATUS_FLAG_TRANSMIT_SHIFT_INDICATION = USIC_CH_PSR_IICMode_TSIF_Msk,         /**< Tra
 161:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****   XMC_I2C_CH_STATUS_FLAG_TRANSMIT_BUFFER_INDICATION = USIC_CH_PSR_IICMode_TBIF_Msk,        /**< Tra
 162:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****   XMC_I2C_CH_STATUS_FLAG_RECEIVE_INDICATION = USIC_CH_PSR_IICMode_RIF_Msk,                 /**< Rec
 163:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****   XMC_I2C_CH_STATUS_FLAG_ALTERNATIVE_RECEIVE_INDICATION = USIC_CH_PSR_IICMode_AIF_Msk,     /**< Alt
 164:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****   XMC_I2C_CH_STATUS_FLAG_BAUD_RATE_GENERATOR_INDICATION = USIC_CH_PSR_IICMode_BRGIF_Msk    /**< Bau
 165:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** } XMC_I2C_CH_STATUS_FLAG_t;
 166:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** 
 167:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** /**
 168:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @brief I2C receiver status. The received data byte is available at the bit
 169:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * positions RBUF[7:0], whereas the additional information is monitored at the bit positions
 170:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** *  RBUF[12:8].
 171:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  */
 172:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** typedef enum XMC_I2C_CH_RECEIVER_STATUS_FLAG
 173:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** {
 174:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****   XMC_I2C_CH_RECEIVER_STATUS_FLAG_ACK = 0x1U,      /**< Bit 8:  Value of Received Acknowledgement b
 175:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****   XMC_I2C_CH_RECEIVER_STATUS_FLAG_FIN = 0x2U,      /**< Bit 9:  A 1 at this bit position indicates 
 176:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****                                                                 followed by the address reception t
 177:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****                                                                 been received. A 0 at this bit posi
 178:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****   XMC_I2C_CH_RECEIVER_STATUS_FLAG_MODE = 0x4U,     /**< Bit 10: A 0 at this bit position indicates 
 179:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****                                                                 when the device has been in slave m
 180:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****   XMC_I2C_CH_RECEIVER_STATUS_FLAG_ERR = 0x8U,      /**< Bit 11: A 1 at this bit position indicates 
 181:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****                                                                 data byte in the receive buffer */
 182:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****   XMC_I2C_CH_RECEIVER_STATUS_FLAG_ADR = 0x10       /**< Bit 12: A 0 at this bit position indicates 
 183:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****                                                                 has been received. A 1 indicates a 
 184:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** } XMC_I2C_CH_RECEIVER_STATUS_FLAG_t;
 185:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** 
 186:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** /**
 187:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @brief I2C commands
 188:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  */
 189:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** typedef enum XMC_I2C_CH_CMD
 190:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** {
 191:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****   XMC_I2C_CH_CMD_WRITE,                            /**< I2C Command Write */
 192:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****   XMC_I2C_CH_CMD_READ                              /**< I2C Command Read */
 193:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** } XMC_I2C_CH_CMD_t;
 194:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** 
 195:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** /**
 196:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @brief I2C events
 197:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  */
 198:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** typedef enum XMC_I2C_CH_EVENT
 199:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** {
 200:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****   XMC_I2C_CH_EVENT_RECEIVE_START       = USIC_CH_CCR_RSIEN_Msk,  /**< Receive start event */
 201:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****   XMC_I2C_CH_EVENT_DATA_LOST           = USIC_CH_CCR_DLIEN_Msk,  /**< Data lost event */
 202:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****   XMC_I2C_CH_EVENT_TRANSMIT_SHIFT      = USIC_CH_CCR_TSIEN_Msk,  /**< Transmit shift event */
 203:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****   XMC_I2C_CH_EVENT_TRANSMIT_BUFFER     = USIC_CH_CCR_TBIEN_Msk,  /**< Transmit buffer event */
 204:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****   XMC_I2C_CH_EVENT_STANDARD_RECEIVE    = USIC_CH_CCR_RIEN_Msk,   /**< Receive event */
 205:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****   XMC_I2C_CH_EVENT_ALTERNATIVE_RECEIVE = USIC_CH_CCR_AIEN_Msk,   /**< Alternate receive event */
 206:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****   XMC_I2C_CH_EVENT_BAUD_RATE_GENERATOR = USIC_CH_CCR_BRGIEN_Msk, /**< Baudrate generator event */
 207:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** 
 208:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****   XMC_I2C_CH_EVENT_START_CONDITION_RECEIVED = USIC_CH_PCR_IICMode_SCRIEN_Msk,             /**< Star
 209:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****   XMC_I2C_CH_EVENT_REPEATED_START_CONDITION_RECEIVED = USIC_CH_PCR_IICMode_RSCRIEN_Msk,   /**< Repe
 210:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****   XMC_I2C_CH_EVENT_STOP_CONDITION_RECEIVED = USIC_CH_PCR_IICMode_PCRIEN_Msk,              /**< Stop
 211:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****   XMC_I2C_CH_EVENT_NACK = USIC_CH_PCR_IICMode_NACKIEN_Msk,                                /**< NACK
 212:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****   XMC_I2C_CH_EVENT_ARBITRATION_LOST = USIC_CH_PCR_IICMode_ARLIEN_Msk,                     /**< Arbi
 213:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****   XMC_I2C_CH_EVENT_SLAVE_READ_REQUEST = USIC_CH_PCR_IICMode_SRRIEN_Msk,                   /**< Slav
 214:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****   XMC_I2C_CH_EVENT_ERROR = USIC_CH_PCR_IICMode_ERRIEN_Msk,	                              /**< Error
 215:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****   XMC_I2C_CH_EVENT_ACK = USIC_CH_PCR_IICMode_ACKIEN_Msk                                   /**< ACK 
 216:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** } XMC_I2C_CH_EVENT_t;
 217:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** 
 218:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** /**
 219:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @brief I2C input stage selection
 220:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  */
 221:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** typedef enum XMC_I2C_CH_INPUT
 222:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** {
 223:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****   XMC_I2C_CH_INPUT_SDA = 0U,   /**< selection of sda input stage */
 224:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** #if UC_FAMILY == XMC1
 225:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****   XMC_I2C_CH_INPUT_SDA1 = 3U,
 226:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****   XMC_I2C_CH_INPUT_SDA2 = 5U,
 227:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** #endif  
 228:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****   XMC_I2C_CH_INPUT_SCL = 1U,  /**< selection of scl input stage */
 229:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** #if UC_FAMILY == XMC1
 230:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****   XMC_I2C_CH_INPUT_SCL1 = 4U
 231:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** #endif  
 232:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** } XMC_I2C_CH_INPUT_t;
 233:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** 
 234:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** /**
 235:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * I2C channel interrupt node pointers
 236:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  */
 237:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** typedef enum XMC_I2C_CH_INTERRUPT_NODE_POINTER
 238:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** {
 239:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****   XMC_I2C_CH_INTERRUPT_NODE_POINTER_TRANSMIT_SHIFT      = XMC_USIC_CH_INTERRUPT_NODE_POINTER_TRANSM
 240:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****   XMC_I2C_CH_INTERRUPT_NODE_POINTER_TRANSMIT_BUFFER     = XMC_USIC_CH_INTERRUPT_NODE_POINTER_TRANSM
 241:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****   XMC_I2C_CH_INTERRUPT_NODE_POINTER_RECEIVE             = XMC_USIC_CH_INTERRUPT_NODE_POINTER_RECEIV
 242:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****   XMC_I2C_CH_INTERRUPT_NODE_POINTER_ALTERNATE_RECEIVE   = XMC_USIC_CH_INTERRUPT_NODE_POINTER_ALTERN
 243:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****   XMC_I2C_CH_INTERRUPT_NODE_POINTER_PROTOCOL            = XMC_USIC_CH_INTERRUPT_NODE_POINTER_PROTOC
 244:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** } XMC_I2C_CH_INTERRUPT_NODE_POINTER_t;
 245:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** 
 246:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** /*******************************************************************************
 247:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * DATA STRUCTURES
 248:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *******************************************************************************/
 249:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** /**
 250:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @brief I2C_CH configuration structure
 251:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  */
 252:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** typedef struct XMC_I2C_CH_CONFIG
 253:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** {
 254:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****   uint32_t baudrate;   /**< baud rate configuration upto max of 400KHz */
 255:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****   uint16_t address;    /**< slave address 
 256:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****                             A 7-bit address needs to be left shifted it by 1.
 257:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****                             A 10-bit address needs to be ORed with XMC_I2C_10BIT_ADDR_GROUP. */
 258:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** } XMC_I2C_CH_CONFIG_t;
 259:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** 
 260:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** /*******************************************************************************
 261:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * API PROTOTYPES
 262:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *******************************************************************************/
 263:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** 
 264:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** #ifdef __cplusplus
 265:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** extern "C" {
 266:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** #endif
 267:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** 
 268:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** /**
 269:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @param channel Constant pointer to USIC channel structure of type @ref XMC_USIC_CH_t
 270:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @param config  Constant pointer to I2C channel config structure of type @ref XMC_I2C_CH_CONFIG_t
 271:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
 272:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @return None<br>
 273:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
 274:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * \par<b>Description:</b><br>
 275:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * Initializes the I2C \a channel.<br>
 276:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
 277:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * \par
 278:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * Configures the data format in SCTR register. Sets the slave address, baud rate. Enables transmit
 279:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * and disables parity generation.<br>
 280:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
 281:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * \par<b>Related APIs:</b><br>
 282:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * XMC_USIC_CH_Enable()\n\n
 283:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  */
 284:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** 
 285:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** void XMC_I2C_CH_Init(XMC_USIC_CH_t *const channel, const XMC_I2C_CH_CONFIG_t *const config);
 286:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** 
 287:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** /**
 288:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @param channel Constant pointer to USIC channel structure of type @ref XMC_USIC_CH_t
 289:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @param rate  baud rate of I2C channel
 290:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
 291:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @return None<br>
 292:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
 293:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * \par<b>Description:</b><br>
 294:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * Sets the rate of I2C \a channel.
 295:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
 296:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * \par<b>Note:</b><br>
 297:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * Standard over sampling is considered if rate <= 100KHz and fast over sampling is considered if r
 298:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
 299:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * \par<b>Related APIs:</b><br>
 300:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * XMC_USIC_CH_SetBaudrate()\n\n
 301:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  */
 302:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** XMC_I2C_CH_STATUS_t XMC_I2C_CH_SetBaudrate(XMC_USIC_CH_t *const channel, const uint32_t rate);
 303:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** 
 304:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** /**
 305:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @param channel Constant pointer to USIC channel structure of type @ref XMC_USIC_CH_t
 306:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
 307:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @return None<br>
 308:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
 309:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * \par<b>Description:</b><br>
 310:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * Starts the I2C \a channel.
 311:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
 312:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * \par
 313:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * Sets the USIC input operation mode to I2C mode using CCR register.
 314:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
 315:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * \par<b>Related APIs:</b><br>
 316:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * XMC_USIC_CH_SetMode()\n\n
 317:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  */
 318:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** __STATIC_INLINE void XMC_I2C_CH_Start(XMC_USIC_CH_t *const channel)
 319:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** {
 320:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****   XMC_USIC_CH_SetMode(channel, XMC_USIC_CH_OPERATING_MODE_I2C);
 321:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** }
 322:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** 
 323:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** /**
 324:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @param channel Constant pointer to USIC channel structure of type @ref XMC_USIC_CH_t
 325:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
 326:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @return @ref XMC_I2C_CH_STATUS_t<br>
 327:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
 328:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * \par<b>Description:</b><br>
 329:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * Stops the I2C \a channel.<br>
 330:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
 331:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * \par
 332:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * Sets the USIC input operation to IDLE mode using CCR register.
 333:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
 334:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * \par<b>Related APIs:</b><br>
 335:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * XMC_USIC_CH_SetMode()\n\n
 336:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  */
 337:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** XMC_I2C_CH_STATUS_t XMC_I2C_CH_Stop(XMC_USIC_CH_t *const channel);
 338:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** 
 339:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** /**
 340:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @param channel Constant pointer to USIC channel structure of type @ref XMC_USIC_CH_t
 341:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @param service_request Service request number in the range of 0-5
 342:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @return None<br>
 343:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
 344:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * \par<b>Description:</b><br>
 345:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * Sets the interrupt node for protocol interrupt.<br>
 346:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
 347:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * \par
 348:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * To generate interrupt for an event, node pointer should be configured with service request numbe
 349:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * The NVIC node gets linked to the interrupt event by doing so.<br>
 350:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
 351:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * \par<b>Note:</b><br>
 352:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * NVIC node should be separately enabled to generate the interrupt. After setting the node pointer
 353:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
 354:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * \par<b>Related APIs:</b><br>
 355:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * XMC_I2C_CH_EnableEvent(), NVIC_SetPriority(), NVIC_EnableIRQ(), XMC_I2C_CH_SetInputSource()<br>
 356:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  */
 357:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** __STATIC_INLINE void XMC_I2C_CH_SetInterruptNodePointer(XMC_USIC_CH_t *const channel,
 358:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****                                                         const uint8_t service_request)
 359:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** {
 360:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****   XMC_USIC_CH_SetInterruptNodePointer(channel, XMC_USIC_CH_INTERRUPT_NODE_POINTER_PROTOCOL, service
 361:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** }
 362:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** 
 363:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** 
 364:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** /**
 365:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @param channel Pointer to USIC channel handler of type @ref XMC_USIC_CH_t \n
 366:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * 				  \b Range: @ref XMC_I2C0_CH0, @ref XMC_I2C0_CH1,@ref XMC_I2C1_CH0,@ref XMC_I2C1_CH1,@ref XM
 367:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @param  interrupt_node Interrupt node pointer to be configured. \n
 368:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * 						  \b Range: @ref XMC_I2C_CH_INTERRUPT_NODE_POINTER_TRANSMIT_SHIFT,
 369:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * 						  			@ref XMC_I2C_CH_INTERRUPT_NODE_POINTER_TRANSMIT_BUFFER etc.
 370:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @param service_request Service request number.\n
 371:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * 						  \b Range: 0 to 5.
 372:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @return None
 373:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
 374:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * \par<b>Description</b><br>
 375:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * Sets the interrupt node for USIC channel events. \n\n
 376:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * For an event to generate interrupt, node pointer should be configured with service request(SR0, 
 377:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * The NVIC node gets linked to the interrupt event by doing so.<br>
 378:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * Note: NVIC node should be separately enabled to generate the interrupt.
 379:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
 380:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * \par<b>Related APIs:</b><BR>
 381:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * XMC_I2C_CH_EnableEvent() \n\n\n
 382:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  */
 383:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** __STATIC_INLINE void XMC_I2C_CH_SelectInterruptNodePointer(XMC_USIC_CH_t *const channel,
 384:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****                                                            const XMC_I2C_CH_INTERRUPT_NODE_POINTER_
 385:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****                                                            const uint32_t service_request)
 386:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** {
 387:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****   XMC_USIC_CH_SetInterruptNodePointer(channel, (XMC_USIC_CH_INTERRUPT_NODE_POINTER_t)interrupt_node
 388:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** 		                                       (uint32_t)service_request);
 389:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** }
 390:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** 
 391:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** /**
 392:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @param  channel Pointer to USIC channel handler of type @ref XMC_USIC_CH_t \n
 393:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * 				   \b Range: @ref XMC_I2C0_CH0, @ref XMC_I2C0_CH1,@ref XMC_I2C1_CH0,@ref XMC_I2C1_CH1,@ref X
 394:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @param  service_request_line service request number of the event to be triggered. \n
 395:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * 			\b Range: 0 to 5.
 396:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @return None
 397:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
 398:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * \par<b>Description</b><br>
 399:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * Trigger a I2C interrupt service request.\n\n
 400:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * When the I2C service request is triggered, the NVIC interrupt associated with it will be
 401:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * generated if enabled.
 402:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
 403:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * \par<b>Related APIs:</b><BR>
 404:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * XMC_I2C_CH_SelectInterruptNodePointer() \n\n\n
 405:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  */
 406:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** __STATIC_INLINE void XMC_I2C_CH_TriggerServiceRequest(XMC_USIC_CH_t *const channel, const uint32_t 
 407:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** {
 408:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****   XMC_USIC_CH_TriggerServiceRequest(channel, (uint32_t)service_request_line);
 409:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** }
 410:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** 
 411:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** /**
 412:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @param channel Constant pointer to USIC channel structure of type @ref XMC_USIC_CH_t
 413:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @param input I2C channel input stage of type @ref XMC_I2C_CH_INPUT_t
 414:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @param source Input source select for the input stage(0->DX0A, 1->DX1A, .. 7->DX7G)
 415:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @return None<br>
 416:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
 417:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * \par<b>Description:</b><br>
 418:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * Sets the input source for I2C \a channel.<br>
 419:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * Defines the input stage for the corresponding input line.
 420:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
 421:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @note After configuring the input source for corresponding channel, interrupt node pointer is se
 422:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
 423:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * \par<b>Related APIs:</b><br>
 424:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * XMC_USIC_CH_SetInptSource(), XMC_USIC_CH_SetInterruptNodePointer()
 425:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
 426:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  */
 427:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** __STATIC_INLINE void XMC_I2C_CH_SetInputSource(XMC_USIC_CH_t *const channel, const XMC_I2C_CH_INPUT
 428:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** {
 429:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****   channel->DXCR[input] =  (uint32_t)(channel->DXCR[input] & (~USIC_CH_DX0CR_INSW_Msk)) | USIC_CH_DX
 430:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****   XMC_USIC_CH_SetInputSource(channel, (XMC_USIC_CH_INPUT_t)input, source);
 431:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** }
 432:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** 
 433:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** /**
 434:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @param channel Constant pointer to USIC channel structure of type @ref XMC_USIC_CH_t
 435:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @param address I2C slave address
 436:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @return None<br>
 437:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
 438:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * \par<b>Description:</b><br>
 439:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * Sets the I2C \a channel slave address.<br>
 440:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
 441:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * \par
 442:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * Address is set in PCR_IICMode register by checking if it is in 10-bit address group or 7-bit add
 443:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * (If first five bits of address are assigned with 0xF0, then address mode is 10-bit mode otherwis
 444:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @note A 7-bit address should include an additional bit at the LSB for read/write indication. For
 445:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * be provided as 0x0a. A 10-bit address should be provided with the identifier 0b11110xx at the mo
 446:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * address 0x305 should be provided as 0x7b05(bitwise OR with 0x7800).
 447:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
 448:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * \par<b>Related APIs:</b><br>
 449:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * XMC_I2C_CH_GetSlaveAddress()\n\n
 450:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  */
 451:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** void XMC_I2C_CH_SetSlaveAddress(XMC_USIC_CH_t *const channel, const uint16_t address);
 452:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** 
 453:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** /**
 454:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @param channel Constant pointer to USIC channel handler of type @ref XMC_USIC_CH_t
 455:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @return uint16_t Slave address<br>
 456:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
 457:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * \par<b>Description:</b><br>
 458:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * Gets the I2C \a channel slave address.<br>
 459:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
 460:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * \par
 461:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * Returns the address using PCR_IICMode register by checking if it is in 10-bit address group or 7
 462:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * (If first five bits of address are assigned with 0xF0, then address mode is considered as 10-bit
 463:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @note A 7-bit address will include an additional bit at the LSB. For example, address 0x05 will 
 464:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * 10-bit address will not include the 10-bit address identifier 0b11110xx at the most signifcant b
 465:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
 466:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * \par<b>Related APIs:</b><br>
 467:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * XMC_I2C_CH_SetSlaveAddress()\n\n
 468:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  */
 469:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** uint16_t XMC_I2C_CH_GetSlaveAddress(const XMC_USIC_CH_t *const channel);
 470:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** 
 471:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** /**
 472:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @param channel Constant pointer to USIC channel structure of type @ref XMC_USIC_CH_t
 473:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @param addr I2C master address
 474:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @param command read/write command
 475:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @return None<br>
 476:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
 477:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * \par<b>Description:</b><br>
 478:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * Starts the I2C master \a channel.<br>
 479:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
 480:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * \par
 481:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * Sends the Start condition with read/write command by updating IN/TBUF register based on FIFO/non
 482:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @note Address(addr) should reserve an additional bit at the LSB for read/write indication. For e
 483:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * be provided as 0x0a. If the address is 10-bit, only most significant bits with the 10-bit identi
 484:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * For example, if the 10-bit address is 0x305, the address should be provided as 0xf6(prepend with
 485:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * followed by 1-bit field for read/write).
 486:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
 487:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * \par<b>Related APIs:</b><br>
 488:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * XMC_I2C_CH_MasterTransmit(), XMC_USIC_CH_GetTransmitBufferStatus()\n\n
 489:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  */
 490:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** void XMC_I2C_CH_MasterStart(XMC_USIC_CH_t *const channel, const uint16_t addr, const XMC_I2C_CH_CMD
 491:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** 
 492:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** /**
 493:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @param channel Constant pointer to USIC channel structure of type @ref XMC_USIC_CH_t
 494:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @param addr I2C master address
 495:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @param command read/write command
 496:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @return None<br>
 497:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
 498:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * \par<b>Description:</b><br>
 499:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * Sends the repeated start condition from I2C master \a channel.<br>
 500:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
 501:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * \par
 502:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * Sends the repeated start condition with read/write command by updating IN/TBUF register based on
 503:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @note Address(addr) should reserve an additional bit at the LSB for read/write indication. For e
 504:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * be provided as 0x0a. If the address is 10-bit, only most significant bits with the 10-bit identi
 505:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * For example, if the 10-bit address is 0x305, the address should be provided as 0xf6(prepend with
 506:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * followed by 1-bit field for read/write).
 507:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
 508:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * \par<b>Related APIs:</b><br>
 509:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * XMC_I2C_CH_MasterTransmit(), XMC_USIC_CH_GetTransmitBufferStatus()\n\n
 510:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  */
 511:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** void XMC_I2C_CH_MasterRepeatedStart(XMC_USIC_CH_t *const channel, const uint16_t addr, const XMC_I2
 512:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** 
 513:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** /**
 514:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @param channel Constant pointer to USIC channel structure of type @ref XMC_USIC_CH_t
 515:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @return None<br>
 516:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
 517:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * \par<b>Description:</b><br>
 518:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * Stops the I2C master \a channel.<br>
 519:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
 520:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * \par
 521:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****   * Reads the transmit buffer status is busy or not and thereby updates IN/TBUF register based on F
 522:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
 523:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * \par<b>Related APIs:</b><br>
 524:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * XMC_I2C_CH_MasterTransmit(), XMC_USIC_CH_GetTransmitBufferStatus()\n\n
 525:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  */
 526:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** void XMC_I2C_CH_MasterStop(XMC_USIC_CH_t *const channel);
 527:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** 
 528:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** /**
 529:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @param channel Constant pointer to USIC channel structure of type @ref XMC_USIC_CH_t
 530:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @param data data to transmit from I2C \a channel
 531:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @return None<br>
 532:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
 533:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * \par<b>Description:</b><br>
 534:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * Transmit the data from the I2C master \a channel.<br>
 535:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
 536:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * \par
 537:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * Reads the transmit buffer status is busy or not and thereby updates IN/TBUF register based on FI
 538:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
 539:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * \par<b>Related APIs:</b><br>
 540:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * XMC_USIC_CH_GetTransmitBufferStatus()\n\n
 541:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  */
 542:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** void XMC_I2C_CH_MasterTransmit(XMC_USIC_CH_t *const channel, const uint8_t data);
 543:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** 
 544:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** /**
 545:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @param channel Constant pointer to USIC channel structure of type @ref XMC_USIC_CH_t
 546:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @param data data to transmit from I2C \a channel
 547:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @return None<br>
 548:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
 549:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * \par<b>Description:</b><br>
 550:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * Transmit the data from the I2C slave \a channel.<br>
 551:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
 552:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * \par
 553:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * Reads the transmit buffer status is busy or not and thereby updates IN/TBUF register based on FI
 554:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
 555:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * \par<b>Related APIs:</b><br>
 556:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * XMC_USIC_CH_GetTransmitBufferStatus(),XMC_I2C_CH_ClearStatusFlag()\n\n
 557:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  */
 558:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** void XMC_I2C_CH_SlaveTransmit(XMC_USIC_CH_t *const channel, const uint8_t data);
 559:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** 
 560:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** /**
 561:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @param channel Constant pointer to USIC channel structure of type @ref XMC_USIC_CH_t
 562:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @return None<br>
 563:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
 564:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * \par<b>Description:</b><br>
 565:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * Sends the Ack request from I2C master \a channel.<br>
 566:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
 567:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * \par
 568:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** * Reads the transmit buffer status is busy or not and thereby updates IN/TBUF register based on FIF
 569:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
 570:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * \par<b>Related APIs:</b><br>
 571:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * XMC_I2C_CH_MasterTransmit()\n\n
 572:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  */
 573:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** void XMC_I2C_CH_MasterReceiveAck(XMC_USIC_CH_t *const channel);
 574:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** 
 575:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** /**
 576:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @param channel Constant pointer to USIC channel structure of type @ref XMC_USIC_CH_t
 577:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @return None<br>
 578:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
 579:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * \par<b>Description:</b><br>
 580:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * Sends the Nack request from I2C master \a channel.<br>
 581:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
 582:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * \par
 583:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * Reads the transmit buffer status is busy or not and thereby updates IN/TBUF register based on FI
 584:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
 585:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * \par<b>Related APIs:</b><br>
 586:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * XMC_I2C_CH_MasterTransmit()\n\n
 587:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  */
 588:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** void XMC_I2C_CH_MasterReceiveNack(XMC_USIC_CH_t *const channel);
 589:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** 
 590:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** /**
 591:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @param channel Constant pointer to USIC channel structure of type @ref XMC_USIC_CH_t
 592:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @return uint8_t OUTR/RBUF register data<br>
 593:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
 594:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * \par<b>Description:</b><br>
 595:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * Reads the data from I2C \a channel.<br>
 596:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
 597:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * \par
 598:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * Data is read by using OUTR/RBUF register based on FIFO/non-FIFO modes.
 599:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
 600:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * \par<b>Related APIs:</b><br>
 601:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * XMC_I2C_CH_MasterTransmit()\n\n
 602:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  */
 603:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** uint8_t XMC_I2C_CH_GetReceivedData(const XMC_USIC_CH_t *const channel);
 604:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** 
 605:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** /**
 606:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @param channel Constant pointer to USIC channel structure of type @ref XMC_USIC_CH_t
 607:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @return uint8_t Receiver status flag<br>
 608:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
 609:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * \par<b>Description:</b><br>
 610:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * Gets the receiver status of I2C \a channel using RBUF register of bits 8-12 which gives informat
 611:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
 612:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * \par<b>Related APIs:</b><br>
 613:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * XMC_I2C_CH_MasterTransmit()\n\n
 614:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  */
 615:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** __STATIC_INLINE uint8_t XMC_I2C_CH_GetReceiverStatusFlag(XMC_USIC_CH_t *const channel)
 616:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** {
 617:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****   return((uint8_t)((channel->RBUF) >> 8U));
 618:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** }
 619:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** 
 620:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** /**
 621:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @param channel Constant pointer to USIC channel structure of type @ref XMC_USIC_CH_t
 622:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @param event ORed values of @ref XMC_I2C_CH_EVENT_t enum
 623:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @return None<br>
 624:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
 625:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * \par<b>Description:</b><br>
 626:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * Enables the input parameter @ref XMC_I2C_CH_EVENT_t event using PCR_IICMode register.
 627:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
 628:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * \par<b>Related APIs:</b><br>
 629:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * XMC_I2C_CH_DisableEvent()\n\n
 630:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  */
 631:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** void XMC_I2C_CH_EnableEvent(XMC_USIC_CH_t *const channel, uint32_t event);
 632:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** 
 633:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** /**
 634:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @param channel Constant pointer to USIC channel structure of type @ref XMC_USIC_CH_t
 635:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @param event ORed values of @ref XMC_I2C_CH_EVENT_t enum
 636:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @return None<br>
 637:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
 638:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * \par<b>Description:</b><br>
 639:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * Disables the input parameter @ref XMC_I2C_CH_EVENT_t event using PCR_IICMode register.
 640:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
 641:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * \par<b>Related APIs:</b><br>
 642:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * XMC_I2C_CH_EnableEvent()\n\n
 643:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  */
 644:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** void XMC_I2C_CH_DisableEvent(XMC_USIC_CH_t *const channel, uint32_t event);
 645:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** 
 646:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** /**
 647:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @param channel Constant pointer to USIC channel structure of type @ref XMC_USIC_CH_t
 648:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @return uint32_t Status byte<br>
 649:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
 650:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * \par<b>Description:</b><br>
 651:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * Retrieves the status byte of I2C \a channel using PSR_IICMode register.\n
 652:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
 653:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * \par<b>Related APIs:</b><br>
 654:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * XMC_I2C_CH_ClearStatusFlag()\n\n
 655:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  */
 656:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** __STATIC_INLINE uint32_t XMC_I2C_CH_GetStatusFlag(XMC_USIC_CH_t *const channel)
 657:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** {
 658:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****   return (channel->PSR_IICMode);
 117              	 .loc 2 658 0
 118 0002 986C     	 ldr r0,[r3,#72]
 119              	.LVL7:
 120              	.LBE163:
 121              	.LBE162:
 212:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 213:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   return (status & flagtype);
 214:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** }
 122              	 .loc 1 214 0
 123 0004 0840     	 ands r0,r0,r1
 124 0006 7047     	 bx lr
 125              	 .cfi_endproc
 126              	.LFE237:
 128              	 .section .text.I2C_MASTER_ClearFlag,"ax",%progbits
 129              	 .align 2
 130              	 .global I2C_MASTER_ClearFlag
 131              	 .thumb
 132              	 .thumb_func
 134              	I2C_MASTER_ClearFlag:
 135              	.LFB238:
 215:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 216:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** /* Function to clear flag status of the requested parameter */
 217:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** void I2C_MASTER_ClearFlag(const I2C_MASTER_t *handle, uint32_t flagtype)
 218:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** {
 136              	 .loc 1 218 0
 137              	 .cfi_startproc
 138              	 
 139              	 
 140              	 
 141              	.LVL8:
 219:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   XMC_I2C_CH_ClearStatusFlag(handle->channel,flagtype);
 142              	 .loc 1 219 0
 143 0000 0268     	 ldr r2,[r0]
 144              	.LVL9:
 145              	.LBB164:
 146              	.LBB165:
 659:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** }
 660:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** 
 661:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** /**
 662:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @param channel Constant pointer to USIC channel structure of type @ref XMC_USIC_CH_t
 663:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @param flag Status flag
 664:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * @return None<br>
 665:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
 666:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * \par<b>Description:</b><br>
 667:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * Clears the status flag of I2C \a channel by setting the input parameter \a flag in PSCR register
 668:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  *
 669:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * \par<b>Related APIs:</b><br>
 670:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  * XMC_I2C_CH_GetStatusFlag()\n\n
 671:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****  */
 672:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** __STATIC_INLINE void XMC_I2C_CH_ClearStatusFlag(XMC_USIC_CH_t *const channel, uint32_t flag)
 673:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** {
 674:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h ****   channel->PSCR |= flag;
 147              	 .loc 2 674 0
 148 0002 D36C     	 ldr r3,[r2,#76]
 149 0004 1943     	 orrs r1,r1,r3
 150              	.LVL10:
 151 0006 D164     	 str r1,[r2,#76]
 152 0008 7047     	 bx lr
 153              	.LBE165:
 154              	.LBE164:
 155              	 .cfi_endproc
 156              	.LFE238:
 158 000a 00BF     	 .section .text.I2C_MASTER_Transmit,"ax",%progbits
 159              	 .align 2
 160              	 .global I2C_MASTER_Transmit
 161              	 .thumb
 162              	 .thumb_func
 164              	I2C_MASTER_Transmit:
 165              	.LFB239:
 220:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** }
 221:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 222:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** /* Function to transmit the data to slave device */
 223:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** I2C_MASTER_STATUS_t I2C_MASTER_Transmit(I2C_MASTER_t *handle, bool send_start, const uint32_t addre
 224:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****                                         uint8_t *data, const uint32_t size, bool send_stop)
 225:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** {
 166              	 .loc 1 225 0
 167              	 .cfi_startproc
 168              	 
 169              	 
 170              	.LVL11:
 171 0000 2DE9F047 	 push {r4,r5,r6,r7,r8,r9,r10,lr}
 172              	.LCFI4:
 173              	 .cfi_def_cfa_offset 32
 174              	 .cfi_offset 4,-32
 175              	 .cfi_offset 5,-28
 176              	 .cfi_offset 6,-24
 177              	 .cfi_offset 7,-20
 178              	 .cfi_offset 8,-16
 179              	 .cfi_offset 9,-12
 180              	 .cfi_offset 10,-8
 181              	 .cfi_offset 14,-4
 182              	 .loc 1 225 0
 183 0004 0546     	 mov r5,r0
 226:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   I2C_MASTER_STATUS_t status;
 227:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 228:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   status = I2C_MASTER_STATUS_BUSY;
 229:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 230:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   if (handle->config->transmit_mode == I2C_MASTER_TRANSFER_MODE_INTERRUPT)
 184              	 .loc 1 230 0
 185 0006 4068     	 ldr r0,[r0,#4]
 186              	.LVL12:
 225:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   I2C_MASTER_STATUS_t status;
 187              	 .loc 1 225 0
 188 0008 089F     	 ldr r7,[sp,#32]
 189              	 .loc 1 230 0
 190 000a 90F82440 	 ldrb r4,[r0,#36]
 225:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   I2C_MASTER_STATUS_t status;
 191              	 .loc 1 225 0
 192 000e 9DF82480 	 ldrb r8,[sp,#36]
 193              	.LVL13:
 194              	 .loc 1 230 0
 195 0012 012C     	 cmp r4,#1
 196 0014 02D8     	 bhi .L105
 228:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 197              	 .loc 1 228 0
 198 0016 0220     	 movs r0,#2
 199 0018 BDE8F087 	 pop {r4,r5,r6,r7,r8,r9,r10,pc}
 200              	.LVL14:
 201              	.L105:
 202 001c 9946     	 mov r9,r3
 203              	.LBB241:
 204              	.LBB242:
 231:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
 232:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #if (I2C_MASTER_INTERRUPT_TX_ENABLED == 1)
 233:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     status = I2C_MASTER_StartTransmitIRQ(handle, send_start, address, data, size, send_stop);
 234:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #endif
 235:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   }
 236:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   else if (handle->config->transmit_mode == I2C_MASTER_TRANSFER_MODE_DMA)
 237:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
 238:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #if (I2C_MASTER_DMA_TX_ENABLED == 1)
 239:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     status = I2C_MASTER_STATUS_UNSUPPORTED_MODE;
 240:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #endif
 241:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   }
 242:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   else
 243:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
 244:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #if (I2C_MASTER_DIRECT_TX_ENABLED == 1)
 245:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     status = I2C_MASTER_lStartTransmitPolling(handle, send_start, address, data, size, send_stop);
 246:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #endif
 247:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   }
 248:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 249:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   return (status);
 250:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** } /* end of function */
 251:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 252:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #if ((I2C_MASTER_INTERRUPT_TX_ENABLED == 1) || (I2C_MASTER_INTERRUPT_RX_ENABLED == 1))
 253:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** /*
 254:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * Transmit interrupt handler for the APP.
 255:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * This is a common interrupt handling function called for different instances of the APP.
 256:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  *
 257:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  *  @param  handle I2C_MASTER APP handle pointer of type I2C_MASTER_t*
 258:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  *
 259:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  *  @return void
 260:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  */
 261:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** void I2C_MASTER_TransmitHandler(I2C_MASTER_t * const handle)
 262:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** {
 263:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   I2C_MASTER_RUNTIME_t * ptr_runtime;
 264:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   uint8_t fifo_min;
 265:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 266:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   ptr_runtime = handle->runtime;
 267:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   fifo_min = 0U;
 268:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 269:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   /* check if any error flag is set */
 270:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   if (I2C_MASTER_GetFlagStatus(handle, ((uint32_t)XMC_I2C_CH_STATUS_FLAG_NACK_RECEIVED |
 271:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****                                         (uint32_t)XMC_I2C_CH_STATUS_FLAG_ARBITRATION_LOST |
 272:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****                                         (uint32_t)XMC_I2C_CH_STATUS_FLAG_ERROR |
 273:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****                     (uint32_t)XMC_I2C_CH_STATUS_FLAG_WRONG_TDF_CODE_FOUND)))
 274:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
 275:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     /* Disable the transmit events */
 276:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     XMC_USIC_CH_TXFIFO_DisableEvent(handle->channel,(uint32_t)XMC_USIC_CH_TXFIFO_EVENT_CONF_STANDAR
 277:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     XMC_USIC_CH_DisableEvent(handle->channel, (uint32_t)XMC_USIC_CH_EVENT_TRANSMIT_BUFFER);
 278:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 279:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     I2C_MASTER_ProtocolHandler(handle);
 280:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   }
 281:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   else
 282:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
 283:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** /**************************************************************************************************
 284:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   Direction = Transmit, Tx FIFO enabled
 285:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** ***************************************************************************************************
 286:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   if (ptr_runtime->direction == (uint32_t)I2C_MASTER_DIRECTION_TRANSMIT)
 287:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
 288:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     if (handle->config->txFIFO_size > 0)
 289:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     {
 290:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       if (ptr_runtime->tx_data_index < ptr_runtime->tx_data_count)
 291:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       {
 292:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       I2C_MASTER_DisableEvent(handle,(uint32_t)XMC_I2C_CH_EVENT_ACK);
 293:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       XMC_USIC_CH_TXFIFO_EnableEvent(handle->channel, (uint32_t)XMC_USIC_CH_TXFIFO_EVENT_CONF_STAND
 294:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         /*Fill the transmit FIFO */
 295:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         while (I2C_MASTER_IsTXFIFOFull(handle) == false)
 296:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         {
 297:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           /* transmit each byte till index reaches to the last byte */
 298:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           if (ptr_runtime->tx_data_index < ptr_runtime->tx_data_count)
 299:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           {
 300:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****             /* load the FIFO, byte by byte till either FIFO is full or all data is loaded*/
 301:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****             I2C_MASTER_TransmitByte(handle, (uint8_t)ptr_runtime->tx_data[ptr_runtime->tx_data_inde
 302:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****             ptr_runtime->tx_data_index++;
 303:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           }
 304:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           else
 305:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           {
 306:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****             break;
 307:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           }
 308:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         } /* end of while */
 309:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       }
 310:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       else
 311:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       {
 312:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         /* if index is reached to last byte and "bus acquired" flag is set to true, then issue Send
 313:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       XMC_USIC_CH_TXFIFO_DisableEvent(handle->channel, (uint32_t)XMC_USIC_CH_TXFIFO_EVENT_CONF_STAN
 314:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       NVIC_ClearPendingIRQ(handle->config->tx_irqn);
 315:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 316:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       /*make sure data is transmitted in FIFO*/
 317:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         while (!XMC_USIC_CH_TXFIFO_IsEmpty(handle->channel)){}
 318:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 319:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           if (ptr_runtime->bus_acquired == true)
 320:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           {
 321:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****             I2C_MASTER_lSendStop_JumpTo_TxCallback(handle);
 322:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           }
 323:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       }
 324:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     } /* end of  if (handle->config->txFIFO_size > 0) */
 325:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** /**************************************************************************************************
 326:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     Direction = transmit and Tx FIFO disabled
 327:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** ***************************************************************************************************
 328:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     else
 329:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     {
 330:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       /* transmit each byte till the last byte */
 331:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       if (ptr_runtime->tx_data_index < ptr_runtime->tx_data_count)
 332:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       {
 333:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         I2C_MASTER_TransmitByte(handle, ptr_runtime->tx_data[ptr_runtime->tx_data_index]);
 334:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         ptr_runtime->tx_data_index++;
 335:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       }
 336:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       else
 337:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       {
 338:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         /* if index reaches last byte and bus_acquired flag is set to true, issue send stop */
 339:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         if (ptr_runtime->bus_acquired == true)
 340:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         {
 341:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           I2C_MASTER_lSendStop_JumpTo_TxCallback(handle);
 342:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         }
 343:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       }
 344:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     }
 345:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   } /* end of if (ptr_runtime->direction == (uint32_t)I2C_MASTER_DIRECTION_TRANSMIT) */
 346:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   else
 347:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
 348:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** /**************************************************************************************************
 349:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   Direction = Receive, Tx, Rx FIFO enabled.
 350:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   Minimum FIFO value is calculated by comparing Tx FIFO and Rx FIFO size.
 351:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   If Rx FIFO is not enabled, default size of 2 is considered.
 352:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** ***************************************************************************************************
 353:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     if (handle->config->txFIFO_size > 0)
 354:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     {
 355:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       if ((handle->config->rxFIFO_size > 0))
 356:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       {
 357:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         fifo_min = (uint8_t)calculate_minfifosize(((uint32_t)1 << (uint32_t)handle->config->txFIFO_
 358:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****                                               ((uint32_t)1 << (uint32_t)handle->config->rxFIFO_size
 359:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       }
 360:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       else
 361:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       {
 362:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         /* if Rx FIFO is disabled, set minimum FIFO size as 2 */
 363:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         fifo_min = 2U;
 364:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       }
 365:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 366:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       XMC_USIC_CH_TXFIFO_DisableEvent(handle->channel, (uint32_t)XMC_USIC_CH_TXFIFO_EVENT_CONF_STAN
 367:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 368:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       /* fill the FIFO */
 369:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       while (I2C_MASTER_IsTXFIFOFull(handle) == false)
 370:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       {
 371:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         if (ptr_runtime->tx_data_index < ptr_runtime->tx_data_count)
 372:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         {
 373:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           /* check for last byte and send_nack is set to true */
 374:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           if (((ptr_runtime->tx_data_index + 1U) == ptr_runtime->tx_data_count) && (ptr_runtime->se
 375:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           {
 376:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****             I2C_MASTER_ReceiveNACK(handle);
 377:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           }
 378:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           else
 379:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           {
 380:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****             I2C_MASTER_ReceiveACK(handle);
 381:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           }
 382:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           ptr_runtime->tx_data_index++;
 383:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 384:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           /*if index reaches fifo size - break*/
 385:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           if ((ptr_runtime->tx_data_index) >= fifo_min)
 386:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           {
 387:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****             break;
 388:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           }
 389:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         }
 390:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         else
 391:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         {
 392:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           break;
 393:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         }
 394:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       } /* end of while */
 395:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     } /* end of if (handle->config->txFIFO_size > 0) */
 396:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** /**************************************************************************************************
 397:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****    Direction = Receive, Tx FIFO disabled
 398:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  **************************************************************************************************
 399:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     else
 400:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     {
 401:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       /* check for last byte and send_nack is set to true */
 402:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       if (((ptr_runtime->tx_data_index + 1U) == ptr_runtime->tx_data_count) && (ptr_runtime->send_n
 403:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       {
 404:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         I2C_MASTER_ReceiveNACK(handle);
 405:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       }
 406:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       else
 407:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       {
 408:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         I2C_MASTER_ReceiveACK(handle);
 409:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       }
 410:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       ptr_runtime->tx_data_index++;
 411:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     }
 412:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 413:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** /**************************************************************************************************
 414:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****    If last byte, then disable ACK event
 415:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  **************************************************************************************************
 416:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****      if (handle->runtime->tx_data_index == handle->runtime->tx_data_count)
 417:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****      {
 418:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****        I2C_MASTER_DisableEvent(handle,(uint32_t)XMC_I2C_CH_EVENT_ACK);
 419:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****      }
 420:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   } /* end of else */
 421:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  } /* end of else */
 422:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** }
 423:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 424:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** /* Function to issue Send Stop command and jump to callback routine */
 425:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** static void I2C_MASTER_lSendStop_JumpTo_TxCallback(I2C_MASTER_t *const handle)
 426:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** {
 427:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   I2C_MASTER_RUNTIME_t * ptr_runtime;
 428:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 429:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   ptr_runtime = handle->runtime;
 430:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 431:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   I2C_MASTER_DisableEvent(handle,((uint32_t)XMC_I2C_CH_EVENT_ACK ));
 432:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 433:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   if (ptr_runtime->send_stop == true)
 434:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
 435:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     ptr_runtime->bus_acquired = false;
 436:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     I2C_MASTER_SendStop(handle);
 437:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   }
 438:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 439:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   while (XMC_USIC_CH_GetTransmitBufferStatus(handle->channel) == XMC_USIC_CH_TBUF_STATUS_BUSY){}
 440:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 441:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   /*All data is transmitted*/
 442:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   ptr_runtime->tx_busy = false;
 443:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 444:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   if (handle->config->tx_cbhandler != NULL)
 445:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
 446:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     /*Execute the 'End of transmission' callback function*/
 447:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     handle->config->tx_cbhandler();
 448:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   }
 449:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** }
 450:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #endif
 451:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 452:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** /**************************************************************************************************
 453:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * @brief This function registers the receive request by configuring the I2C_MASTER
 454:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * receive FIFO/Standard buffer (depending on the user configuration). The data
 455:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * is received asynchronously. When the requested number of data bytes are received,
 456:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * optionally, the user configured callback function will be executed. If a callback
 457:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * function is not configured on the APP UI, the user has to poll for the status of
 458:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * rx_busy variable of the APP handle structure.
 459:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  *
 460:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * Note: In FIFO mode, FIFO trigger limit should be adjusted manually to
 461:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * read required amount of data from FIFO buffer.
 462:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  *
 463:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  *
 464:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * @param  I2C_MASTER_t* I2C_MASTER APP handle pointer of type I2C_MASTER_t
 465:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * @param  bool      flag for send_start
 466:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * @param  uint32_t  slave address
 467:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * @param  uint8_t*  Pointer to data array
 468:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * @param  uint32_t  Total no of bytes to be read.
 469:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * @param  bool      flag for send_stop
 470:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * @param  bool      flag for send_nack
 471:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  *
 472:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * @return  I2C_MASTER_STATUS_t I2C_MASTER_STATUS_SUCCESS if the request is accepted.
 473:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  *                              I2C_MASTER_STATUS_BUSY if a reception is in progress.
 474:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  *
 475:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * <i>Imp Note:</i> Return value should be validated by user to ensure that the
 476:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * request is registered.
 477:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  *
 478:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  *
 479:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  **************************************************************************************************
 480:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** I2C_MASTER_STATUS_t I2C_MASTER_Receive(I2C_MASTER_t *handle, bool send_start, const uint32_t addres
 481:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****                                    const uint32_t count, bool send_stop, bool send_nack)
 482:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** {
 483:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   I2C_MASTER_STATUS_t status;
 484:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 485:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   status = I2C_MASTER_STATUS_BUSY;
 486:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 487:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   if (handle->config->receive_mode == I2C_MASTER_TRANSFER_MODE_INTERRUPT)
 488:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
 489:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #if (I2C_MASTER_INTERRUPT_RX_ENABLED == 1)
 490:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   status = I2C_MASTER_StartReceiveIRQ(handle, send_start, address, data, count, send_stop, send_nac
 491:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #endif
 492:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   }
 493:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   else if (handle->config->receive_mode == I2C_MASTER_TRANSFER_MODE_DMA)
 494:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
 495:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #if (I2C_MASTER_DMA_RX_ENABLED == 1)
 496:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   status = I2C_MASTER_STATUS_UNSUPPORTED_MODE;
 497:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #endif
 498:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   }
 499:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   else
 500:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
 501:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #if (I2C_MASTER_DIRECT_RX_ENABLED == 1)
 502:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     status = I2C_MASTER_lStartReceivePolling(handle, send_start, address, data, count, send_stop, s
 503:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #endif
 504:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   }
 505:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 506:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   return (status);
 507:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** }
 508:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 509:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #if (I2C_MASTER_INTERRUPT_RX_ENABLED == 1)
 510:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** /**************************************************************************************************
 511:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****      Rx FIFO data
 512:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** ***************************************************************************************************
 513:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** static void I2C_MASTER_lReceive_FIFOData(I2C_MASTER_t * const handle, bool send_start, const uint32
 514:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****                                      const uint32_t count)
 515:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** {
 516:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   I2C_MASTER_RUNTIME_t * ptr_runtime;
 517:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 518:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   ptr_runtime = handle->runtime;
 519:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 520:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   /*Clear the receive FIFO, configure the trigger lime
 521:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****    * and enable the receive events*/
 522:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   XMC_USIC_CH_RXFIFO_Flush(handle->channel);
 523:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 524:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   /*Configure the FIFO trigger limit based on the required data size*/
 525:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   I2C_MASTER_lReconfigureRxFIFO(handle, count);
 526:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 527:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   XMC_USIC_CH_RXFIFO_EnableEvent(handle->channel,
 528:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****                                 (uint32_t)((uint32_t)XMC_USIC_CH_RXFIFO_EVENT_CONF_STANDARD |
 529:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****                                            (uint32_t)XMC_USIC_CH_RXFIFO_EVENT_CONF_ALTERNATE));
 530:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   if (send_start == true)
 531:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
 532:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   if (!((handle->config->transmit_mode == I2C_MASTER_TRANSFER_MODE_DMA) ||
 533:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****      (handle->config->transmit_mode == I2C_MASTER_TRANSFER_MODE_DIRECT)))
 534:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
 535:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     I2C_MASTER_EnableEvent(handle, (uint32_t)XMC_I2C_CH_EVENT_ACK);
 536:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     XMC_I2C_CH_SetInterruptNodePointer(handle->channel,ptr_runtime->tx_ack_sr);
 537:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   }
 538:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     I2C_MASTER_lSendStart_Or_RepeatedStart(handle,address, (XMC_I2C_CH_CMD_t)XMC_I2C_CH_CMD_READ);
 539:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 540:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #if (I2C_MASTER_DMA_TX_ENABLED)
 541:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     if (handle->config->transmit_mode == I2C_MASTER_TRANSFER_MODE_DMA)
 542:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     {
 543:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     if (((ptr_runtime->tx_data_index + 1U) == ptr_runtime->tx_data_count) && (ptr_runtime->send_nac
 544:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     {
 545:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     I2C_MASTER_ReceiveNACK(handle);
 546:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     }
 547:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     else
 548:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     {
 549:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     I2C_MASTER_ReceiveACK(handle);
 550:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     }
 551:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     ptr_runtime->tx_data_index++;
 552:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     }
 553:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #endif
 554:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     if (handle->config->transmit_mode == I2C_MASTER_TRANSFER_MODE_DIRECT)
 555:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     {
 556:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       if (handle->config->txFIFO_size != XMC_USIC_CH_FIFO_DISABLED)
 557:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       {
 558:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     /*Fill the transmit FIFO */
 559:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       while (I2C_MASTER_IsTXFIFOFull(handle) == false)
 560:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       {
 561:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         if (ptr_runtime->tx_data_index < ptr_runtime->tx_data_count)
 562:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       {
 563:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         if (((ptr_runtime->tx_data_index + 1U) == ptr_runtime->tx_data_count) && (ptr_runtime->send
 564:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       {
 565:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           I2C_MASTER_ReceiveNACK(handle);
 566:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       }
 567:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       else
 568:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         {
 569:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           I2C_MASTER_ReceiveACK(handle);
 570:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         }
 571:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       ptr_runtime->tx_data_index++;
 572:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       }
 573:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       else
 574:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       {
 575:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         break;
 576:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       }
 577:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     } /* end of while */
 578:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       }
 579:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       else
 580:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       {
 581:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         /* if it is last byte and send_nack true */
 582:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       if (((ptr_runtime->tx_data_index + 1U) == ptr_runtime->tx_data_count) && (ptr_runtime->send_n
 583:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     {
 584:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       I2C_MASTER_ReceiveNACK(handle);
 585:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     }
 586:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     else
 587:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     {
 588:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       I2C_MASTER_ReceiveACK(handle);
 589:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     }
 590:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     ptr_runtime->tx_data_index++;
 591:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       }
 592:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     } /* end of if (handle->config->transmit_mode == I2C_MASTER_TRANSFER_MODE_DIRECT) */
 593:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   } /* end of if (send_start == true) */
 594:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   else
 595:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
 596:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     /* if Tx FIFO enabled */
 597:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     if (handle->config->txFIFO_size > 0)
 598:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     {
 599:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       XMC_USIC_CH_TXFIFO_DisableEvent(handle->channel,
 600:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****                                      (uint32_t)XMC_USIC_CH_TXFIFO_EVENT_CONF_STANDARD);
 601:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       /*Fill the transmit FIFO */
 602:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       while (I2C_MASTER_IsTXFIFOFull(handle) == false)
 603:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       {
 604:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         if (ptr_runtime->tx_data_index < ptr_runtime->tx_data_count)
 605:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         {
 606:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           if (((ptr_runtime->tx_data_index + 1U) == ptr_runtime->tx_data_count) &&
 607:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****                (ptr_runtime->send_nack == true))
 608:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           {
 609:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****             I2C_MASTER_ReceiveNACK(handle);
 610:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           }
 611:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           else
 612:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           {
 613:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****             I2C_MASTER_ReceiveACK(handle);
 614:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           }
 615:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           ptr_runtime->tx_data_index++;
 616:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         }
 617:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         else
 618:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         {
 619:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           break;
 620:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         }
 621:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       } /* end of while */
 622:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     }
 623:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     else  /* Tx FIFO disabled and Rx FIFO enabled */
 624:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     {
 625:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       if (ptr_runtime->tx_data_index < ptr_runtime->tx_data_count)
 626:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       {
 627:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         if (((ptr_runtime->tx_data_index + 1U) == ptr_runtime->tx_data_count) &&
 628:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****              (ptr_runtime->send_nack == true))
 629:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         {
 630:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           I2C_MASTER_ReceiveNACK(handle);
 631:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         }
 632:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         else
 633:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         {
 634:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           XMC_I2C_CH_ClearStatusFlag(handle->channel, ((uint32_t)XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVE
 635:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****                                               (uint32_t)XMC_I2C_CH_STATUS_FLAG_TRANSMIT_BUFFER_INDI
 636:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****                           (uint32_t)XMC_I2C_CH_STATUS_FLAG_TRANSMIT_SHIFT_INDICATION|
 637:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****                                               (uint32_t)XMC_I2C_CH_STATUS_FLAG_RECEIVE_INDICATION |
 638:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****                           (uint32_t)XMC_I2C_CH_STATUS_FLAG_ALTERNATIVE_RECEIVE_INDICATION));
 639:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           I2C_MASTER_ReceiveACK(handle);
 640:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         }
 641:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         ptr_runtime->tx_data_index++;
 642:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       }
 643:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     } /* end of else */
 644:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****    } /* end of  if (send_start == false) */
 645:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** }
 646:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** /**************************************************************************************************
 647:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     Standard receive mode
 648:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** ***************************************************************************************************
 649:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** static void I2C_MASTER_lReceive_StdData(I2C_MASTER_t * const handle, bool send_start, const uint32_
 650:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** {
 651:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   I2C_MASTER_RUNTIME_t * ptr_runtime;
 652:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 653:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   ptr_runtime = handle->runtime;
 654:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 655:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   XMC_USIC_CH_EnableEvent(handle->channel, (uint32_t)((uint32_t)XMC_USIC_CH_EVENT_STANDARD_RECEIVE 
 656:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****                                                       (uint32_t)XMC_USIC_CH_EVENT_ALTERNATIVE_RECEI
 657:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 658:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   if (send_start == true)
 659:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
 660:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   if (!((handle->config->transmit_mode == I2C_MASTER_TRANSFER_MODE_DMA) ||
 661:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****      (handle->config->transmit_mode == I2C_MASTER_TRANSFER_MODE_DIRECT)))
 662:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
 663:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     I2C_MASTER_EnableEvent(handle, (uint32_t)XMC_I2C_CH_EVENT_ACK);
 664:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     XMC_I2C_CH_SetInterruptNodePointer(handle->channel,ptr_runtime->tx_ack_sr);
 665:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   }
 666:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     I2C_MASTER_lSendStart_Or_RepeatedStart(handle, address, (XMC_I2C_CH_CMD_t)XMC_I2C_CH_CMD_READ);
 667:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 668:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     if ((handle->config->transmit_mode == I2C_MASTER_TRANSFER_MODE_DMA) ||
 669:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         (handle->config->transmit_mode == I2C_MASTER_TRANSFER_MODE_DIRECT))
 670:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
 671:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     if (((ptr_runtime->tx_data_index + 1U) == ptr_runtime->tx_data_count) && (ptr_runtime->send_nac
 672:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     {
 673:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         I2C_MASTER_ReceiveNACK(handle);
 674:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     }
 675:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     else
 676:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     {
 677:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     I2C_MASTER_ReceiveACK(handle);
 678:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       }
 679:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     ptr_runtime->tx_data_index++;
 680:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   }
 681:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   }
 682:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   else
 683:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
 684:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** /**************************************************************************************************
 685:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****      send_start flag is set to false and Tx FIFO is disabled
 686:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** ***************************************************************************************************
 687:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     if (handle->config->txFIFO_size == 0)
 688:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     {
 689:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       if (((ptr_runtime->tx_data_index + 1U) == ptr_runtime->tx_data_count) && (ptr_runtime->send_n
 690:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       {
 691:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         I2C_MASTER_ReceiveNACK(handle);
 692:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       }
 693:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       else
 694:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       {
 695:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         I2C_MASTER_ReceiveACK(handle);
 696:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       }
 697:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 698:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       ptr_runtime->tx_data_index++;
 699:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     }
 700:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** /**************************************************************************************************
 701:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****      send_start flag is set to false and Tx FIFO is enabled
 702:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** ***************************************************************************************************
 703:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     else
 704:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     {
 705:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       XMC_USIC_CH_TXFIFO_DisableEvent(handle->channel,(uint32_t)XMC_USIC_CH_TXFIFO_EVENT_CONF_STAND
 706:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 707:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       /*Fill the transmit FIFO */
 708:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       while (I2C_MASTER_IsTXFIFOFull(handle) == false)
 709:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       {
 710:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         if (ptr_runtime->tx_data_index < ptr_runtime->tx_data_count)
 711:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         {
 712:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           if (((ptr_runtime->tx_data_index + 1U) == ptr_runtime->tx_data_count) && (ptr_runtime->se
 713:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           {
 714:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****             I2C_MASTER_ReceiveNACK(handle);
 715:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           }
 716:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           else
 717:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           {
 718:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****             I2C_MASTER_ReceiveACK(handle);
 719:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           }
 720:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           ptr_runtime->tx_data_index++;
 721:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         }
 722:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         else
 723:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         {
 724:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           break;
 725:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         }
 726:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       } /* end of while */
 727:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     } /* end of else */
 728:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   } /* end of else */
 729:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** } /* end of function */
 730:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #endif
 731:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 732:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #if ((I2C_MASTER_INTERRUPT_TX_ENABLED == 1) || (I2C_MASTER_INTERRUPT_RX_ENABLED == 1) || \
 733:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     (I2C_MASTER_DIRECT_TX_ENABLED == 1) || (I2C_MASTER_DIRECT_RX_ENABLED == 1))
 734:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** /* Function to issue Send Start/Repeated Start command */
 735:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** static void I2C_MASTER_lSendStart_Or_RepeatedStart(I2C_MASTER_t * handle,const uint32_t address,
 736:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****                                                const XMC_I2C_CH_CMD_t cmd)
 737:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** {
 738:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   if (handle->runtime->bus_acquired == true)
 739:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
 740:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   I2C_MASTER_SendRepeatedStart(handle, (uint16_t)address, cmd);
 741:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   }
 742:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   else
 743:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
 744:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     handle->runtime->bus_acquired = true;
 745:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     I2C_MASTER_SendStart(handle, (uint16_t)address, cmd);
 746:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   }
 747:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** }
 748:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #endif
 749:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 750:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #if (I2C_MASTER_INTERRUPT_TX_ENABLED == 1)
 751:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** I2C_MASTER_STATUS_t I2C_MASTER_StartTransmitIRQ(I2C_MASTER_t *handle, bool send_start, const uint32
 752:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****                                                 uint8_t *data, const uint32_t size, bool send_stop)
 753:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** {
 754:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   I2C_MASTER_STATUS_t status;
 755:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   I2C_MASTER_RUNTIME_t * ptr_runtime;
 756:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 757:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   status = I2C_MASTER_STATUS_BUSY;
 758:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   ptr_runtime = handle->runtime;
 759:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 760:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   /* If send_stop is set to TRUE, bus_acquired flag is set to FALSE.
 761:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****    If send_start is set to FALSE and bus_acquired is set to FALSE then API will return an error. */
 762:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   if (((send_start == false) && (handle->runtime->bus_acquired == false)) || (data == NULL) || (siz
 763:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
 764:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   status = I2C_MASTER_STATUS_FAILURE;
 765:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   }
 766:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   else
 767:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
 768:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     ptr_runtime->direction = (uint32_t)I2C_MASTER_DIRECTION_TRANSMIT;
 769:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 770:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     if (ptr_runtime->tx_busy == false)
 771:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     {
 772:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     /*If there is no transmission in progress, obtain the address of data, size of data*/
 773:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     ptr_runtime->tx_data = data;
 774:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     ptr_runtime->tx_data_count = size;
 775:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 776:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     /*Initialize to first index and set the busy flag*/
 777:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     ptr_runtime->tx_data_index = 0U;
 778:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     ptr_runtime->tx_busy = true;
 779:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     ptr_runtime->send_stop = send_stop;
 780:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 781:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     /* Enable ACK event */
 782:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     I2C_MASTER_EnableEvent(handle, (uint32_t)XMC_I2C_CH_EVENT_ACK);
 783:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     XMC_I2C_CH_SetInterruptNodePointer(handle->channel,ptr_runtime->tx_ack_sr);
 784:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 785:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     if (send_start == true)
 786:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     {
 787:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       I2C_MASTER_lSendStart_Or_RepeatedStart(handle, address, (XMC_I2C_CH_CMD_t)XMC_I2C_CH_CMD_WRIT
 788:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     }
 789:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     else
 790:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     {
 791:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       /*Trigger the Ack interrupt*/
 792:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       XMC_USIC_CH_TriggerServiceRequest(handle->channel, (uint32_t)ptr_runtime->tx_ack_sr);
 793:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     }
 794:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 795:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     status = I2C_MASTER_STATUS_SUCCESS;
 796:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   }
 797:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   }
 798:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   return (status);
 799:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** }
 800:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 801:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** static void I2C_MASTER_AbortTransmitIRQ(const I2C_MASTER_t *const handle)
 802:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** {
 803:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   handle->runtime->tx_busy = false;
 804:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   handle->runtime->tx_data = NULL;
 805:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   handle->runtime->bus_acquired = false;
 806:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 807:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   /*Disable the transmit interrupts*/
 808:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   if (handle->config->txFIFO_size != XMC_USIC_CH_FIFO_DISABLED)
 809:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
 810:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     /*Disable the transmit FIFO event*/
 811:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     XMC_USIC_CH_TXFIFO_DisableEvent(handle->channel,(uint32_t)XMC_USIC_CH_TXFIFO_EVENT_CONF_STANDAR
 812:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     XMC_USIC_CH_TXFIFO_Flush(handle->channel);
 813:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   }
 814:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   I2C_MASTER_DisableEvent((I2C_MASTER_t *)handle,((uint32_t)XMC_I2C_CH_EVENT_ACK ));
 815:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** }
 816:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #endif
 817:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 818:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #if (I2C_MASTER_INTERRUPT_RX_ENABLED == 1)
 819:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** I2C_MASTER_STATUS_t I2C_MASTER_StartReceiveIRQ(I2C_MASTER_t *handle, bool send_start, const uint32_
 820:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****                                                uint8_t * data, const uint32_t count, bool send_stop
 821:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** {
 822:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   I2C_MASTER_STATUS_t status;
 823:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   I2C_MASTER_RUNTIME_t * ptr_runtime;
 824:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 825:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   status = I2C_MASTER_STATUS_BUSY;
 826:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   ptr_runtime = handle->runtime;
 827:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 828:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   if (((handle == NULL) || ((send_start == false) && (handle->runtime->bus_acquired == false)) || (
 829:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****      (count == 0U)))
 830:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
 831:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     status = I2C_MASTER_STATUS_FAILURE;
 832:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   }
 833:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   else
 834:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
 835:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     if (ptr_runtime->rx_busy == false)
 836:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     {
 837:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     ptr_runtime->direction = (uint32_t)I2C_MASTER_DIRECTION_RECEIVE;
 838:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 839:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       /* If no active reception in progress, obtain the address of data buffer and number of data b
 840:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     ptr_runtime->rx_data = data;
 841:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     ptr_runtime->rx_data_count = count;
 842:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     ptr_runtime->tx_data = data;
 843:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     ptr_runtime->tx_data_count = count;
 844:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     ptr_runtime->tx_busy = true;
 845:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     ptr_runtime->rx_busy = true;
 846:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     ptr_runtime->send_stop = send_stop;
 847:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     ptr_runtime->send_nack = send_nack;
 848:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     ptr_runtime->rx_data_index = 0U;
 849:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     ptr_runtime->tx_data_index = 0U;
 850:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 851:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     if (handle->config->rxFIFO_size > 0)
 852:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     {
 853:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       I2C_MASTER_lReceive_FIFOData(handle, send_start, address, count);
 854:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     }
 855:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     else
 856:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     {
 857:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       I2C_MASTER_lReceive_StdData(handle, send_start, address);
 858:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     }
 859:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     status = I2C_MASTER_STATUS_SUCCESS;
 860:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   }
 861:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   }
 862:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   return (status);
 863:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** }
 864:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 865:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** /*
 866:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * Receive interrupt handler for the APP.
 867:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * This is a common interrupt handling function for different instances of the I2C_MASTER APP.
 868:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  *
 869:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * @param  handle I2C_MASTER APP handle pointer of type I2C_MASTER_t*
 870:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  *
 871:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * @return void
 872:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  */
 873:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** void I2C_MASTER_ReceiveHandler(I2C_MASTER_t * const handle)
 874:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** {
 875:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   I2C_MASTER_RUNTIME_t * ptr_runtime;
 876:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   uint8_t fifo_lindex;
 877:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   uint8_t fifo_min;
 878:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 879:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   ptr_runtime = handle->runtime;
 880:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   fifo_lindex = 0U;
 881:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 882:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   if (ptr_runtime->rx_busy == true)
 883:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
 884:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     if (handle->config->rxFIFO_size > 0)
 885:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     {
 886:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       /********************************************************************************************
 887:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****        Rx FIFO enabled
 888:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       *********************************************************************************************
 889:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       while (I2C_MASTER_IsRXFIFOEmpty(handle) == false)
 890:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       {
 891:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         /*Read all the content of Receive FIFO */
 892:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         ptr_runtime->rx_data[ptr_runtime->rx_data_index] = (uint8_t)I2C_MASTER_GetReceivedByte(hand
 893:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         ptr_runtime->rx_data_index++;
 894:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 895:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         if (ptr_runtime->rx_data_index == ptr_runtime->rx_data_count)
 896:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         {
 897:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           /*Reception complete*/
 898:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           ptr_runtime->rx_busy = false;
 899:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 900:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****             /*Disable both standard receive and alternative receive FIFO events*/
 901:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****             XMC_USIC_CH_RXFIFO_DisableEvent(handle->channel,
 902:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****                                           (uint32_t)((uint32_t)XMC_USIC_CH_RXFIFO_EVENT_CONF_STANDA
 903:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****                                                      (uint32_t)XMC_USIC_CH_RXFIFO_EVENT_CONF_ALTERN
 904:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 905:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           break;
 906:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         }
 907:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       } /* end of while(I2C_MASTER_IsRXFIFOEmpty(handle) == false)*/
 908:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 909:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       /*Set the trigger limit if data still to be received*/
 910:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       if (ptr_runtime->rx_data_index < ptr_runtime->rx_data_count)
 911:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       {
 912:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         I2C_MASTER_lReconfigureRxFIFO(handle,(uint32_t)(ptr_runtime->rx_data_count - ptr_runtime->r
 913:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 914:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         if ((handle->config->txFIFO_size > 0))
 915:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         {
 916:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           fifo_min = (uint8_t)calculate_minfifosize(((uint32_t)1 << (uint32_t)handle->config->txFIF
 917:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****                                                     ((uint32_t)1 << (uint32_t)handle->config->rxFIF
 918:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****        }
 919:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****        else
 920:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****        {
 921:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           fifo_min = 2U;
 922:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****        }
 923:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****        /*******************************************************************************************
 924:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****          Rx and Tx FIFO enabled
 925:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         *******************************************************************************************
 926:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         if (handle->config->txFIFO_size > 0)
 927:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         {
 928:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           /*Fill the transmit FIFO */
 929:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           while (I2C_MASTER_IsTXFIFOFull(handle) == false)
 930:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           {
 931:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****             if (ptr_runtime->tx_data_index < ptr_runtime->tx_data_count)
 932:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****             {
 933:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****               if (((ptr_runtime->tx_data_index + 1U) == ptr_runtime->tx_data_count) && (ptr_runtime
 934:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****               {
 935:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****                 I2C_MASTER_ReceiveNACK(handle);
 936:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****               }
 937:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****               else
 938:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****               {
 939:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****                 I2C_MASTER_ReceiveACK(handle);
 940:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****               }
 941:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****               ptr_runtime->tx_data_index++;
 942:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 943:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****               /* if fifo size- break */
 944:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****               if ((++fifo_lindex) >= fifo_min)
 945:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****               {
 946:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****                 fifo_lindex = 0U;
 947:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****                 break;
 948:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****               }
 949:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****             }/* end of if (handle->runtime->tx_data_index < handle->runtime->tx_data_count) */
 950:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****             else
 951:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****             {
 952:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****               break;
 953:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****             }
 954:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****          }
 955:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****        } /* end of  if ((handle->config->txFIFO_size > 0)) */
 956:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****        /*******************************************************************************************
 957:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           Rx FIFO is enabled, Tx FIFO disabled
 958:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****        ********************************************************************************************
 959:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****        else
 960:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****        {
 961:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****          if (((ptr_runtime->tx_data_index + 1U) == ptr_runtime->tx_data_count) && (ptr_runtime->sen
 962:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****          {
 963:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****            I2C_MASTER_ReceiveNACK(handle);
 964:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****          }
 965:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****          else
 966:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****          {
 967:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****            I2C_MASTER_ReceiveACK(handle);
 968:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****          }
 969:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 970:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****          ptr_runtime->tx_data_index++;
 971:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****        }
 972:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****      } /* end of if (ptr_runtime->rx_data_index < ptr_runtime->rx_data_count) */
 973:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** /**************************************************************************************************
 974:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****      if last byte to receive then disable receive events and jump to callback routine
 975:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** ***************************************************************************************************
 976:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****      if (ptr_runtime->rx_data_index == ptr_runtime->rx_data_count)
 977:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****      {
 978:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****        /*Clear both standard receive and alternative receive FIFO events*/
 979:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****        XMC_USIC_CH_RXFIFO_DisableEvent(handle->channel, (uint32_t)((uint32_t)XMC_USIC_CH_RXFIFO_EVE
 980:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****                                                                    (uint32_t)XMC_USIC_CH_RXFIFO_EVE
 981:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 982:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****        /*Disable both standard receive and alternative receive events*/
 983:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****        XMC_USIC_CH_DisableEvent(handle->channel, (uint32_t)((uint32_t)XMC_USIC_CH_EVENT_ALTERNATIVE
 984:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****                                                             (uint32_t)XMC_USIC_CH_EVENT_STANDARD_RE
 985:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 986:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****        if (ptr_runtime->bus_acquired == true)
 987:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****        {
 988:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****          I2C_MASTER_lSendStop_JumpTo_RxCallback(handle);
 989:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****        }
 990:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****      }
 991:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     } /*  end of if (handle->config->rxFIFO_size > 0) */
 992:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** /**************************************************************************************************
 993:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****      Rx FIFO disabled
 994:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** ***************************************************************************************************
 995:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     else
 996:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     {
 997:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       ptr_runtime->rx_data[ptr_runtime->rx_data_index] = (uint8_t)I2C_MASTER_GetReceivedByte(handle
 998:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       ptr_runtime->rx_data_index++;
 999:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1000:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       if (ptr_runtime->rx_data_index < ptr_runtime->rx_data_count)
1001:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       {
1002:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         if (ptr_runtime->tx_data_index < ptr_runtime->tx_data_count)
1003:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         {
1004:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           /* if receive byte is end of byte and send_nack is true, send to receive Nack otherwise A
1005:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           if (((ptr_runtime->tx_data_index) == (ptr_runtime->tx_data_count - 1U)) && (ptr_runtime->
1006:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           {
1007:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****             I2C_MASTER_ReceiveNACK(handle);
1008:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           }
1009:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           else
1010:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           {
1011:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****             I2C_MASTER_ReceiveACK(handle);
1012:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           }
1013:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           ptr_runtime->tx_data_index++;
1014:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         }
1015:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       }
1016:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       else
1017:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       {
1018:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         /*Disable both standard receive and alternative receive events*/
1019:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         XMC_USIC_CH_DisableEvent(handle->channel, (uint32_t)((uint32_t)XMC_USIC_CH_EVENT_ALTERNATIV
1020:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****                                                              (uint32_t)XMC_USIC_CH_EVENT_STANDARD_R
1021:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         if (ptr_runtime->bus_acquired == true)
1022:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         {
1023:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           I2C_MASTER_lSendStop_JumpTo_RxCallback(handle);
1024:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         }
1025:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       }
1026:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     }
1027:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   } /* end of  if (ptr_runtime->rx_busy == true)*/
1028:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** }
1029:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1030:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** /* Function to issue Send Stop command and jump to receive callback routine */
1031:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** static void I2C_MASTER_lSendStop_JumpTo_RxCallback(I2C_MASTER_t *const handle)
1032:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** {
1033:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   I2C_MASTER_RUNTIME_t * ptr_runtime;
1034:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1035:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   ptr_runtime = handle->runtime;
1036:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1037:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   if (ptr_runtime->send_stop == true)
1038:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
1039:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     while (XMC_USIC_CH_GetTransmitBufferStatus(handle->channel) == XMC_USIC_CH_TBUF_STATUS_BUSY){}
1040:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1041:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     ptr_runtime->bus_acquired = false;
1042:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1043:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     I2C_MASTER_SendStop(handle);
1044:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   }
1045:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1046:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   while (XMC_USIC_CH_GetTransmitBufferStatus(handle->channel) == XMC_USIC_CH_TBUF_STATUS_BUSY){}
1047:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1048:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   /* Reception complete */
1049:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   ptr_runtime->rx_busy = false;
1050:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   ptr_runtime->tx_busy = false;
1051:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1052:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   if (handle->config->rx_cbhandler != NULL)
1053:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
1054:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     /*Execute the 'End of reception' callback function*/
1055:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     handle->config->rx_cbhandler();
1056:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   }
1057:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** }
1058:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1059:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1060:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** static void I2C_MASTER_lAbortReceiveIRQ(const I2C_MASTER_t *const handle)
1061:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** {
1062:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   /* Reset the user buffer pointer to null */
1063:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   handle->runtime->rx_busy = false;
1064:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   handle->runtime->tx_busy = false;
1065:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   handle->runtime->rx_data = NULL;
1066:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1067:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   handle->runtime->bus_acquired = false;
1068:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1069:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   /* Disable the receive interrupts */
1070:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   if (handle->config->rxFIFO_size != XMC_USIC_CH_FIFO_DISABLED)
1071:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
1072:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     XMC_USIC_CH_RXFIFO_DisableEvent(handle->channel, (uint32_t)((uint32_t)XMC_USIC_CH_RXFIFO_EVENT_
1073:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****                                                     (uint32_t)XMC_USIC_CH_RXFIFO_EVENT_CONF_ALTERNA
1074:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   }
1075:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   else
1076:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
1077:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     XMC_USIC_CH_DisableEvent(handle->channel, (uint32_t)((uint32_t)XMC_USIC_CH_EVENT_STANDARD_RECEI
1078:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****                                                  (uint32_t)XMC_USIC_CH_EVENT_ALTERNATIVE_RECEIVE));
1079:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   }
1080:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   I2C_MASTER_DisableEvent((I2C_MASTER_t *)handle,((uint32_t)XMC_I2C_CH_EVENT_ACK ));
1081:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** }
1082:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #endif
1083:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1084:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** /*
1085:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * Protocol interrupt handling function.
1086:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * The function is common for different instances of the I2C_MASTER APP.
1087:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  *
1088:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * @param  handle I2C_MASTER APP handle pointer of type I2C_MASTER_t*
1089:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  *
1090:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * @return void
1091:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  */
1092:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** void I2C_MASTER_ProtocolHandler(I2C_MASTER_t * const handle)
1093:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** {
1094:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   uint32_t psr_status;
1095:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1096:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   psr_status = XMC_I2C_CH_GetStatusFlag(handle->channel);
1097:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1098:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   /* Check for nack event */
1099:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   if ((handle->config->nack_cbhandler != NULL) && (psr_status & (uint32_t)XMC_I2C_CH_STATUS_FLAG_NA
1100:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
1101:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     I2C_MASTER_ClearFlag(handle,(uint32_t)XMC_I2C_CH_STATUS_FLAG_NACK_RECEIVED);
1102:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     handle->config->nack_cbhandler();
1103:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   }
1104:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1105:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   /* Check for arbitration lost */
1106:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   if ((handle->config->arbitration_cbhandler != NULL) && (psr_status & (uint32_t)XMC_I2C_CH_STATUS_
1107:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
1108:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     I2C_MASTER_ClearFlag(handle,(uint32_t)XMC_I2C_CH_STATUS_FLAG_ARBITRATION_LOST);
1109:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     handle->config->arbitration_cbhandler();
1110:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   }
1111:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1112:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   /* Check for error detected */
1113:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   if ((handle->config->error_cbhandler != NULL) && (psr_status & ((uint32_t)XMC_I2C_CH_STATUS_FLAG_
1114:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
1115:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     I2C_MASTER_ClearFlag(handle,(uint32_t)XMC_I2C_CH_STATUS_FLAG_ERROR);
1116:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     handle->config->error_cbhandler();
1117:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   }
1118:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** }
1119:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1120:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #if (I2C_MASTER_INTERRUPT_RX_ENABLED == 1)
1121:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** /*
1122:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * @brief A local function to reconfigure Receive FIFO with the given size and trigger limit.
1123:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * Size is needed because the FIFO should be disabled before changing the trigger limit by
1124:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * clearing the FIFO size.
1125:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  *
1126:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * @param I2C_MASTER_t * pointer to the I2C_MASTER APP handle
1127:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * @param uint32_t  number of bytes to be received.
1128:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  *
1129:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * @return void.
1130:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  */
1131:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1132:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** static void I2C_MASTER_lReconfigureRxFIFO(const I2C_MASTER_t * const handle, uint32_t data_size)
1133:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** {
1134:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   uint32_t minfifo_value;
1135:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   uint8_t tx_fifo_size;
1136:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   uint8_t rx_fifo_size;
1137:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   uint8_t fifo_limit;
1138:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1139:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   rx_fifo_size = (uint8_t)((uint8_t)1 << handle->config->rxFIFO_size);
1140:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1141:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   if ((handle->config->txFIFO_size > 0))
1142:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
1143:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     tx_fifo_size = (uint8_t)((uint8_t)1 << handle->config->txFIFO_size);
1144:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   }
1145:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   else
1146:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
1147:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     tx_fifo_size = 1U;
1148:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   }
1149:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1150:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   minfifo_value = (uint32_t)(calculate_minfifosize((uint32_t)tx_fifo_size, (uint32_t)rx_fifo_size))
1151:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1152:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   fifo_limit = (uint8_t)(calculate_minfifosize(data_size, minfifo_value));
1153:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1154:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   /* Set the limit value */
1155:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   I2C_MASTER_SetRXFIFOTriggerLimit((I2C_MASTER_t *)handle, handle->config->rxFIFO_size, ((uint32_t)
1156:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** }
1157:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #endif
1158:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1159:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** /**************************************************************************************************
1160:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * @brief Aborts the ongoing data transmission.
1161:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * @param I2C_MASTER_t*  I2C_MASTER APP handle pointer of type I2C_MASTER_t
1162:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * @return I2C_MASTER_STATUS_t
1163:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  *
1164:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * Details of function:
1165:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * If there is a transmission in progress, it will be stopped. If transmit FIFO is used,
1166:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * the existing data will be flushed. After the transmission is stopped, user can start
1167:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * a new transmission without delay.
1168:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  **************************************************************************************************
1169:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** I2C_MASTER_STATUS_t I2C_MASTER_AbortTransmit(const I2C_MASTER_t *const handle)
1170:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** {
1171:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   I2C_MASTER_STATUS_t status;
1172:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1173:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   status = I2C_MASTER_STATUS_SUCCESS;
1174:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1175:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   if (handle->config->transmit_mode == I2C_MASTER_TRANSFER_MODE_INTERRUPT)
1176:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
1177:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #if (I2C_MASTER_INTERRUPT_TX_ENABLED == 1)
1178:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     I2C_MASTER_AbortTransmitIRQ(handle);
1179:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #endif
1180:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   }
1181:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   else if (handle->config->transmit_mode == I2C_MASTER_TRANSFER_MODE_DMA)
1182:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
1183:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #if (I2C_MASTER_DMA_TX_ENABLED == 1)
1184:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     I2C_MASTER_lAbortTransmitDMA(handle);
1185:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #endif
1186:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   }
1187:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   else
1188:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
1189:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     status = I2C_MASTER_STATUS_FAILURE;
1190:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   }
1191:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   handle->channel->PSCR |= USIC_CH_PSR_IICMode_WTDF_Msk; /*clear WDTF*/
1192:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   handle->channel->FMR = 0x00000002U;/*clear TDV*/
1193:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1194:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   return (status);
1195:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** }
1196:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1197:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** /**************************************************************************************************
1198:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * @brief Aborts the ongoing data reception.
1199:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * @param I2C_MASTER_t* I2C_MASTER APP handle pointer of type I2C_MASTER_t
1200:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * @return I2C_MASTER_STATUS_t
1201:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  *
1202:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * Details of function:
1203:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * If a reception is in progress, it will be stopped. When a reception request
1204:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * is active, user will not be able to place a new receive request till the active
1205:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * reception is complete. This API can stop the progressing reception to make
1206:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * a new receive request.
1207:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  **************************************************************************************************
1208:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** I2C_MASTER_STATUS_t I2C_MASTER_AbortReceive(const I2C_MASTER_t *const handle)
1209:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** {
1210:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   I2C_MASTER_STATUS_t status;
1211:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1212:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   status = I2C_MASTER_STATUS_SUCCESS;
1213:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1214:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   if (handle->config->receive_mode == I2C_MASTER_TRANSFER_MODE_INTERRUPT)
1215:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
1216:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #if (I2C_MASTER_INTERRUPT_RX_ENABLED == 1)
1217:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     I2C_MASTER_lAbortReceiveIRQ(handle);
1218:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #endif
1219:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   }
1220:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   else if (handle->config->receive_mode == I2C_MASTER_TRANSFER_MODE_DMA)
1221:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
1222:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #if (I2C_MASTER_DMA_RX_ENABLED == 1)
1223:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     I2C_MASTER_lAbortReceiveDMA(handle);
1224:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #endif
1225:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   }
1226:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   else
1227:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
1228:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     status = I2C_MASTER_STATUS_FAILURE;
1229:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   }
1230:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1231:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   return (status);
1232:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** }
1233:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1234:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #if (I2C_MASTER_DMA_RX_ENABLED == 1)
1235:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** I2C_MASTER_STATUS_t I2C_MASTER_StartReceiveDMA(const I2C_MASTER_t *const handle, uint32_t data_coun
1236:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** {
1237:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   I2C_MASTER_STATUS_t status;
1238:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   const I2C_MASTER_DMA_CONFIG_t *rx_dma_config;
1239:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   const GLOBAL_DMA_t *rx_dma_config_global;
1240:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1241:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #if (I2C_MASTER_DMA_TX_ENABLED == 1)
1242:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   const I2C_MASTER_DMA_CONFIG_t *tx_dma_config;
1243:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   const GLOBAL_DMA_t *tx_dma_config_global;
1244:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   uint8_t tx_ch_num;
1245:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   tx_ch_num = 0U;
1246:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   tx_dma_config = handle->config->transmit_dma_config;
1247:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   tx_dma_config_global = handle->config->transmit_dma_config->global_dma;
1248:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #endif
1249:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1250:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   status = I2C_MASTER_STATUS_BUSY;
1251:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   rx_dma_config = handle->config->receive_dma_config;
1252:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   rx_dma_config_global = handle->config->receive_dma_config->global_dma;
1253:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   
1254:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   if ((addr == NULL) || (data_count > I2C_DMA_MAX_BLOCK_SIZE) || (data_count == 0U))
1255:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
1256:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     status = I2C_MASTER_STATUS_FAILURE;
1257:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   }
1258:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   else
1259:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
1260:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     if (handle->runtime->rx_busy == false)
1261:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     {
1262:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       handle->runtime->rx_busy = true;
1263:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     I2C_MASTER_DisableEvent((I2C_MASTER_t *)handle, (uint32_t)XMC_I2C_CH_EVENT_ACK);
1264:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     handle->runtime->rx_dma_data_count = data_count;
1265:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1266:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     XMC_USIC_CH_EnableEvent(handle->channel, ((uint32_t)XMC_USIC_CH_EVENT_STANDARD_RECEIVE |
1267:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****                                               (uint32_t)XMC_USIC_CH_EVENT_ALTERNATIVE_RECEIVE));
1268:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #if (I2C_MASTER_DMA_TX_ENABLED == 1)
1269:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     XMC_DMA_CH_SetBlockSize(rx_dma_config_global->dma, rx_dma_config->dma_channel, data_count);
1270:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #else
1271:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     XMC_DMA_CH_SetBlockSize(rx_dma_config_global->dma, rx_dma_config->dma_channel, 1);
1272:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #endif
1273:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     XMC_DMA_CH_SetSourceAddress(rx_dma_config_global->dma, rx_dma_config->dma_channel, (uint32_t)&h
1274:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     XMC_DMA_CH_SetDestinationAddress(rx_dma_config_global->dma, rx_dma_config->dma_channel, (uint32
1275:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1276:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     if (handle->config->transmit_mode == I2C_MASTER_TRANSFER_MODE_DMA)
1277:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     {
1278:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #if (I2C_MASTER_DMA_TX_ENABLED == 1)
1279:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     /* ACK TDF value */
1280:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       ack_buf[0] = (uint16_t)I2C_MASTER_TDF_RECEIVE_ACK;
1281:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       nack_buf[0] = (uint16_t)I2C_MASTER_TDF_RECEIVE_NACK;
1282:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     handle->runtime->direction = (uint32_t)I2C_MASTER_DIRECTION_RECEIVE;
1283:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     /* need to make source reload for tx, transfer width for tx= 2 bytes */
1284:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     tx_ch_num = handle->config->transmit_dma_config->dma_channel;
1285:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     /* clear the bits */
1286:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     tx_dma_config_global->dma->CH[tx_ch_num].CTLL &= ~((uint32_t)I2C_MASTER_DMA_SRC_DST_TR_WIDTH_MA
1287:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****                                                         (uint32_t)I2C_MASTER_DMA_SRC_ADDR_INC_MASK)
1288:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1289:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     /* set the src and dest transf width as XMC_DMA_CH_TRANSFER_WIDTH_16 */
1290:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     tx_dma_config_global->dma->CH[tx_ch_num].CTLL |= (((uint32_t)XMC_DMA_CH_TRANSFER_WIDTH_16 <<
1291:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****                                                         (uint32_t)I2C_MASTER_DMA_DST_TRANSFER_WIDTH
1292:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****                                                        ((uint32_t)XMC_DMA_CH_TRANSFER_WIDTH_16 <<
1293:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****                                                       (uint32_t)I2C_MASTER_DMA_SRC_TRANSFER_WIDTH_P
1294:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1295:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       /* set the tx channel src address inc mode to XMC_DMA_CH_ADDRESS_COUNT_MODE_NO_CHANGE */
1296:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     tx_dma_config_global->dma->CH[tx_ch_num].CTLL |= ((uint32_t)XMC_DMA_CH_ADDRESS_COUNT_MODE_NO_CH
1297:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****                                                        (uint32_t)I2C_MASTER_DMA_SRC_ADDR_INC_POS);
1298:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1299:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1300:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1301:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       XMC_USIC_CH_EnableEvent(handle->channel, (uint32_t)XMC_USIC_CH_EVENT_RECEIVE_START);
1302:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1303:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1304:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1305:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         if (data_count == 1U)
1306:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     {
1307:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           XMC_DMA_CH_SetSourceAddress(tx_dma_config_global->dma, tx_dma_config->dma_channel, (uint3
1308:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           XMC_DMA_CH_SetBlockSize(tx_dma_config_global->dma, tx_dma_config->dma_channel, 1);
1309:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     }
1310:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         else
1311:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         {
1312:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           XMC_DMA_CH_SetSourceAddress(tx_dma_config_global->dma, tx_dma_config->dma_channel, (uint3
1313:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           XMC_DMA_CH_SetBlockSize(tx_dma_config_global->dma, tx_dma_config->dma_channel, data_count
1314:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         }
1315:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         XMC_DMA_CH_SetDestinationAddress(tx_dma_config_global->dma, tx_dma_config->dma_channel,
1316:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****                                      (uint32_t)&handle->channel->TBUF[0]);
1317:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1318:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1319:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1320:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1321:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         XMC_DMA_CH_Enable(tx_dma_config_global->dma, tx_dma_config->dma_channel);
1322:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #endif
1323:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     }
1324:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       else
1325:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       {
1326:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         if (data_count > 1U)
1327:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         {
1328:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           I2C_MASTER_ReceiveACK((I2C_MASTER_t * const)handle);
1329:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         }
1330:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         else
1331:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         {
1332:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       I2C_MASTER_ReceiveNACK((I2C_MASTER_t * const)handle);
1333:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     }
1334:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1335:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     }
1336:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     XMC_DMA_CH_Enable(rx_dma_config_global->dma, rx_dma_config->dma_channel);
1337:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1338:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     status = I2C_MASTER_STATUS_SUCCESS;
1339:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1340:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     } /* end of if (handle->runtime->rx_busy == false) */
1341:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   } /* end of else */
1342:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1343:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   return (status);
1344:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** }
1345:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** /**************************************************************************************************
1346:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * @brief Aborts the ongoing data reception.
1347:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * @param I2C_MASTER_t* I2C_MASTER APP handle pointer of type I2C_MASTER_t
1348:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * @return None
1349:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  *
1350:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * Details of function:
1351:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * If a reception is in progress, it will be stopped. When a reception request
1352:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * is active, user will not be able to place a new receive request till the active
1353:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * reception is complete. This API can stop the progressing reception to make
1354:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * a new receive request.
1355:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  **************************************************************************************************
1356:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** static void I2C_MASTER_lAbortReceiveDMA(const I2C_MASTER_t *const handle)
1357:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** {
1358:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   const I2C_MASTER_DMA_CONFIG_t *rx_dma_config;
1359:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   const GLOBAL_DMA_t *rx_dma_config_global;
1360:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #if (I2C_MASTER_DMA_TX_ENABLED == 1)
1361:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   const I2C_MASTER_DMA_CONFIG_t *tx_dma_config;
1362:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   const GLOBAL_DMA_t *tx_dma_config_global;
1363:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #endif
1364:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1365:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   rx_dma_config = handle->config->receive_dma_config;
1366:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   rx_dma_config_global = handle->config->receive_dma_config->global_dma;
1367:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #if (I2C_MASTER_DMA_TX_ENABLED == 1)
1368:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   tx_dma_config = handle->config->transmit_dma_config;
1369:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   tx_dma_config_global = handle->config->transmit_dma_config->global_dma;
1370:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #endif
1371:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1372:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   /* Reset the user buffer pointer to null */
1373:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   handle->runtime->rx_busy = false;
1374:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   handle->runtime->rx_dma_data_index = 0U;
1375:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1376:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   if (XMC_DMA_CH_IsEnabled(rx_dma_config_global->dma, rx_dma_config->dma_channel))
1377:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
1378:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     XMC_DMA_CH_Disable(rx_dma_config_global->dma, rx_dma_config->dma_channel);
1379:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   }
1380:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #if (I2C_MASTER_DMA_TX_ENABLED == 1)
1381:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   if (handle->config->transmit_mode == I2C_MASTER_TRANSFER_MODE_DMA)
1382:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
1383:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     if (XMC_DMA_CH_IsEnabled(tx_dma_config_global->dma, tx_dma_config->dma_channel))
1384:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     {
1385:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       XMC_DMA_CH_Disable(tx_dma_config_global->dma, tx_dma_config->dma_channel);
1386:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     }
1387:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     while (XMC_DMA_CH_IsEnabled(tx_dma_config_global->dma, tx_dma_config->dma_channel) == 1U){}
1388:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   }
1389:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #endif
1390:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1391:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   while (XMC_DMA_CH_IsEnabled(rx_dma_config_global->dma, rx_dma_config->dma_channel) == 1U){}
1392:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1393:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1394:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   XMC_USIC_CH_DisableEvent(handle->channel, ((uint32_t)XMC_USIC_CH_EVENT_STANDARD_RECEIVE |
1395:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****                                              (uint32_t)XMC_USIC_CH_EVENT_ALTERNATIVE_RECEIVE));
1396:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** }
1397:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #endif
1398:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1399:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #if (I2C_MASTER_DMA_TX_ENABLED == 1)
1400:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** I2C_MASTER_STATUS_t I2C_MASTER_StartTransmitDMA(const I2C_MASTER_t *const handle, uint32_t block_si
1401:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** {
1402:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   I2C_MASTER_STATUS_t status;
1403:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   const I2C_MASTER_DMA_CONFIG_t *tx_dma_config;
1404:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   const GLOBAL_DMA_t *tx_dma_config_global;
1405:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   uint8_t tx_ch_num;
1406:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  
1407:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   status = I2C_MASTER_STATUS_BUSY;
1408:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  
1409:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   tx_dma_config = handle->config->transmit_dma_config;
1410:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   tx_dma_config_global = handle->config->transmit_dma_config->global_dma;
1411:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   
1412:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   tx_ch_num = 0U;
1413:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  
1414:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   if ((addr == NULL) || (block_size > I2C_DMA_MAX_BLOCK_SIZE) || (!block_size))
1415:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
1416:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     status = I2C_MASTER_STATUS_FAILURE;
1417:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   }
1418:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   else
1419:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
1420:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     if (handle->runtime->tx_busy == false)
1421:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     {
1422:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       tx_ch_num = handle->config->transmit_dma_config->dma_channel;
1423:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       /* clear the bits */
1424:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       tx_dma_config_global->dma->CH[tx_ch_num].CTLL &= ~((uint32_t)I2C_MASTER_DMA_SRC_DST_TR_WIDTH_
1425:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       /* set the src and dest transf width as XMC_DMA_CH_TRANSFER_WIDTH_8 */
1426:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       tx_dma_config_global->dma->CH[tx_ch_num].CTLL |= (((uint32_t)XMC_DMA_CH_TRANSFER_WIDTH_8 << (
1427:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****                                                         ((uint32_t)XMC_DMA_CH_TRANSFER_WIDTH_8 << (
1428:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       /* set the tx channel src address inc mode to XMC_DMA_CH_ADDRESS_COUNT_MODE_INCREMENT */
1429:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       tx_dma_config_global->dma->CH[tx_ch_num].CTLL |= ((uint32_t)XMC_DMA_CH_ADDRESS_COUNT_MODE_INC
1430:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  
1431:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       XMC_DMA_ClearRequestLine(tx_dma_config_global->dma, handle->config->transmit_dma_config->dma_
1432:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       I2C_MASTER_EnableEvent((I2C_MASTER_t * const)handle, (uint32_t)XMC_I2C_CH_EVENT_ACK);
1433:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  
1434:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       handle->runtime->direction = (uint32_t)I2C_MASTER_DIRECTION_TRANSMIT;
1435:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       handle->runtime->tx_busy = true;
1436:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1437:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       XMC_I2C_CH_MasterTransmit(handle->channel,*addr);
1438:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       block_size--;
1439:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  
1440:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       if (block_size)
1441:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       {
1442:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         XMC_DMA_CH_SetBlockSize(tx_dma_config_global->dma, tx_dma_config->dma_channel, block_size);
1443:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         XMC_DMA_CH_SetSourceAddress(tx_dma_config_global->dma, tx_dma_config->dma_channel, (uint32_
1444:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         XMC_DMA_CH_SetDestinationAddress(tx_dma_config_global->dma, tx_dma_config->dma_channel, (ui
1445:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  
1446:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         XMC_DMA_CH_Enable(tx_dma_config_global->dma, tx_dma_config->dma_channel);
1447:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       }
1448:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       else
1449:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       {
1450:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         handle->runtime->tx_busy = false;
1451:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         if (handle->config->tx_cbhandler)
1452:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         {
1453:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           handle->config->tx_cbhandler();
1454:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         }
1455:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       }
1456:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1457:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       status = I2C_MASTER_STATUS_SUCCESS;
1458:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     }
1459:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   }
1460:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1461:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   return (status);
1462:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** }
1463:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1464:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** /**************************************************************************************************
1465:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * @brief Aborts the ongoing data transmission.
1466:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * @param I2C_MASTER_t*  I2C_MASTER APP handle pointer of type I2C_MASTER_t
1467:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * @return None
1468:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  *
1469:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * Details of function:
1470:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * If there is a transmission in progress, it will be stopped. If transmit FIFO is used,
1471:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * the existing data will be flushed. After the transmission is stopped, user can start
1472:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  * a new transmission without delay.
1473:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****  **************************************************************************************************
1474:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** static void I2C_MASTER_lAbortTransmitDMA(const I2C_MASTER_t *const handle)
1475:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** {
1476:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   const I2C_MASTER_DMA_CONFIG_t *tx_dma_config;
1477:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   const GLOBAL_DMA_t *tx_dma_config_global;
1478:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   
1479:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   tx_dma_config = handle->config->transmit_dma_config;
1480:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   tx_dma_config_global = handle->config->transmit_dma_config->global_dma;
1481:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1482:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   handle->runtime->tx_busy = false;
1483:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1484:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   if (XMC_DMA_CH_IsEnabled(tx_dma_config_global->dma, tx_dma_config->dma_channel))
1485:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
1486:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     XMC_DMA_CH_Disable(tx_dma_config_global->dma, tx_dma_config->dma_channel);
1487:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   }
1488:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1489:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   while (XMC_DMA_CH_IsEnabled(tx_dma_config_global->dma, tx_dma_config->dma_channel) == 1U){}
1490:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1491:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   I2C_MASTER_DisableEvent((I2C_MASTER_t *)handle, (uint32_t)XMC_I2C_CH_EVENT_ACK);
1492:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** }
1493:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1494:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #endif
1495:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1496:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #if (I2C_MASTER_DIRECT_TX_ENABLED == 1)
1497:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** volatile uint32_t I2C_Timeout = 0;
1498:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** static I2C_MASTER_STATUS_t I2C_MASTER_lStartTransmitPolling(I2C_MASTER_t *const handle, bool send_s
1499:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****                                                         const uint32_t slave_address, uint8_t *data
1500:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****                               bool send_stop)
1501:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** {
1502:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   uint32_t buffer_index;
1503:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   I2C_MASTER_STATUS_t status;
1504:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   uint32_t psr_status;
1505:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1506:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   status = I2C_MASTER_STATUS_BUSY;
1507:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1508:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   buffer_index = 0U;
1509:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1510:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   if ((((send_start == false) && (handle->runtime->bus_acquired == false)) || (data == NULL) || (si
 205              	 .loc 1 1510 0
 206 001e 21B9     	 cbnz r1,.L13
 207 0020 AB68     	 ldr r3,[r5,#8]
 208              	.LVL15:
 209 0022 93F82830 	 ldrb r3,[r3,#40]
 210 0026 002B     	 cmp r3,#0
 211 0028 4CD0     	 beq .L103
 212              	.L13:
 213 002a B9F1000F 	 cmp r9,#0
 214 002e 49D0     	 beq .L103
 215 0030 002F     	 cmp r7,#0
 216 0032 47D0     	 beq .L103
1511:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
1512:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     status = I2C_MASTER_STATUS_FAILURE;
1513:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   }
1514:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   else
1515:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
1516:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     if (send_start == true)
 217              	 .loc 1 1516 0
 218 0034 0029     	 cmp r1,#0
 219 0036 4AD0     	 beq .L15
1517:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     {
1518:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       if (handle->runtime->bus_acquired == false)
 220              	 .loc 1 1518 0
 221 0038 A968     	 ldr r1,[r5,#8]
 222              	.LVL16:
 223 003a 91F82830 	 ldrb r3,[r1,#40]
 224 003e 03F0FF04 	 and r4,r3,#255
 225 0042 002B     	 cmp r3,#0
 226 0044 00F08980 	 beq .L16
 227 0048 0246     	 mov r2,r0
 228              	.LVL17:
 229 004a 2868     	 ldr r0,[r5]
 230              	.L17:
1519:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       {
1520:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         I2C_MASTER_lSendStart_Or_RepeatedStart(handle, slave_address, XMC_I2C_CH_CMD_WRITE);
1521:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1522:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         /* Wait for ACK or timeout */
1523:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         I2C_Timeout = 0X1FFFFF;
1524:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         while ((I2C_MASTER_GetFlagStatus(handle, (uint32_t)XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED) == 
1525:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         {
1526:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           /* Get flag status */
1527:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           psr_status = XMC_I2C_CH_GetStatusFlag(handle->channel);
1528:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1529:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           /* Check if an error flag is set */
1530:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           if (psr_status & ((uint32_t)XMC_I2C_CH_STATUS_FLAG_NACK_RECEIVED |
1531:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****                             (uint32_t)XMC_I2C_CH_STATUS_FLAG_ARBITRATION_LOST |
1532:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****                             (uint32_t)XMC_I2C_CH_STATUS_FLAG_ERROR |
1533:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****                             (uint32_t)XMC_I2C_CH_STATUS_FLAG_WRONG_TDF_CODE_FOUND))
1534:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           {
1535:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****    	        /* Check for NACK event */
1536:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     	    if (psr_status & (uint32_t)XMC_I2C_CH_STATUS_FLAG_NACK_RECEIVED)
1537:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     	    {
1538:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     	      I2C_MASTER_ClearFlag(handle,(uint32_t)XMC_I2C_CH_STATUS_FLAG_NACK_RECEIVED);
1539:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     	    }
1540:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1541:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     	    /* Check for arbitration lost */
1542:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     	    if (psr_status & (uint32_t)XMC_I2C_CH_STATUS_FLAG_ARBITRATION_LOST)
1543:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     	    {
1544:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     	      I2C_MASTER_ClearFlag(handle,(uint32_t)XMC_I2C_CH_STATUS_FLAG_ARBITRATION_LOST);
1545:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     	    }
1546:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1547:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     	    /* Check for error detected */
1548:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     	    if (psr_status & ((uint32_t)XMC_I2C_CH_STATUS_FLAG_ERROR | (uint32_t)XMC_I2C_CH_STATUS_FLA
1549:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     	    {
1550:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     	      I2C_MASTER_ClearFlag(handle,(uint32_t)XMC_I2C_CH_STATUS_FLAG_ERROR);
1551:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     	    }
1552:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1553:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****             status = I2C_MASTER_STATUS_FAILURE;
1554:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****             return (status);
1555:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           }
1556:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1557:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           I2C_Timeout--;
1558:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         }
1559:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1560:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         /* Undefined error, return Timeout */
1561:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         if (I2C_Timeout == 0)
1562:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         {
1563:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           status = I2C_MASTER_STATUS_TIMEOUT;
1564:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           return (status);
1565:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         }
1566:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1567:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         I2C_MASTER_ClearFlag(handle, (uint32_t)XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED);
1568:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       }
1569:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     }
1570:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     if (handle->config->txFIFO_size == XMC_USIC_CH_FIFO_DISABLED)
 231              	 .loc 1 1570 0
 232 004c 92F82630 	 ldrb r3,[r2,#38]
 233 0050 002B     	 cmp r3,#0
 234 0052 42D0     	 beq .L50
 235              	.L48:
1571:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     {
1572:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       /* send data, byte by byte */
1573:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       while (buffer_index < size)
1574:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       {
1575:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         I2C_MASTER_TransmitByte(handle, data[buffer_index]);
1576:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1577:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         /* Wait for ACK or timeout */
1578:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         I2C_Timeout = 0X2FFFFF;
1579:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         psr_status = 0;
1580:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         while ((I2C_MASTER_GetFlagStatus(handle, (uint32_t)XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED) == 
1581:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         {
1582:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           /* Get flag status */
1583:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           psr_status = XMC_I2C_CH_GetStatusFlag(handle->channel);
1584:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1585:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           /* Check if an error flag is set */
1586:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           if (psr_status & ((uint32_t)XMC_I2C_CH_STATUS_FLAG_NACK_RECEIVED |
1587:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****                             (uint32_t)XMC_I2C_CH_STATUS_FLAG_ARBITRATION_LOST |
1588:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****                             (uint32_t)XMC_I2C_CH_STATUS_FLAG_ERROR |
1589:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****                             (uint32_t)XMC_I2C_CH_STATUS_FLAG_WRONG_TDF_CODE_FOUND))
1590:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           {
1591:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 	        /* Check for NACK event */
1592:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 	        if (psr_status & (uint32_t)XMC_I2C_CH_STATUS_FLAG_NACK_RECEIVED)
1593:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 	        {
1594:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 	          I2C_MASTER_ClearFlag(handle,(uint32_t)XMC_I2C_CH_STATUS_FLAG_NACK_RECEIVED);
1595:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 	        }
1596:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1597:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 	        /* Check for arbitration lost */
1598:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 	        if (psr_status & (uint32_t)XMC_I2C_CH_STATUS_FLAG_ARBITRATION_LOST)
1599:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 	        {
1600:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 	          I2C_MASTER_ClearFlag(handle,(uint32_t)XMC_I2C_CH_STATUS_FLAG_ARBITRATION_LOST);
1601:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 	        }
1602:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1603:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 	        /* Check for error detected */
1604:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 	        if (psr_status & ((uint32_t)XMC_I2C_CH_STATUS_FLAG_ERROR | (uint32_t)XMC_I2C_CH_STATUS_FLA
1605:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 	        {
1606:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 	          I2C_MASTER_ClearFlag(handle,(uint32_t)XMC_I2C_CH_STATUS_FLAG_ERROR);
1607:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 	        }
1608:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1609:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****             status = I2C_MASTER_STATUS_FAILURE;
1610:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****             return (status);
1611:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           }
1612:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1613:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           I2C_Timeout--;
1614:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         }
1615:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1616:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         /* Undefined error, return Timeout */
1617:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         if (I2C_Timeout == 0)
1618:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         {
1619:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           status = I2C_MASTER_STATUS_TIMEOUT;
1620:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           return (status);
1621:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         }
1622:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1623:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         I2C_MASTER_ClearFlag(handle, (uint32_t)XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED);
1624:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1625:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         buffer_index++;
1626:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       }
1627:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     }
1628:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     else
1629:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     {
1630:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       while (buffer_index < size)
1631:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       {
1632:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         /* Fill the transmit FIFO */
1633:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         while (I2C_MASTER_IsTXFIFOFull(handle) == false)
 236              	 .loc 1 1633 0
 237 0054 0024     	 movs r4,#0
 238              	.LVL18:
 239              	.L30:
 240              	.LBB243:
 241              	.LBB244:
 242              	.LBB245:
 243              	 .file 3 "C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc/xmc_usic.h"
   1:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
   2:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @file xmc_usic.h
   3:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @date 2017-02-10
   4:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
   5:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @cond
   6:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  **************************************************************************************************
   7:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * XMClib v2.1.16 - XMC Peripheral Driver Library 
   8:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
   9:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Copyright (c) 2015-2017, Infineon Technologies AG
  10:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * All rights reserved.                        
  11:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *                                             
  12:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Redistribution and use in source and binary forms, with or without modification,are permitted pr
  13:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * following conditions are met:   
  14:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *                                                                              
  15:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Redistributions of source code must retain the above copyright notice, this list of conditions a
  16:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * disclaimer.                        
  17:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 
  18:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Redistributions in binary form must reproduce the above copyright notice, this list of condition
  19:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * disclaimer in the documentation and/or other materials provided with the distribution.          
  20:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 
  21:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Neither the name of the copyright holders nor the names of its contributors may be used to endor
  22:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * products derived from this software without specific prior written permission.                  
  23:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *                                                                              
  24:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR I
  25:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTI
  26:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, IN
  27:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBS
  28:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THE
  29:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
  30:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                            
  31:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *                                                                              
  32:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * To improve the quality of the software, users are encouraged to share modifications, enhancement
  33:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Infineon Technologies AG dave@infineon.com).                                                    
  34:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  **************************************************************************************************
  35:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
  36:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Change History
  37:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * --------------
  38:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
  39:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 2015-02-20:
  40:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *     - Initial draft<br>
  41:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *     - Documentation improved <br>
  42:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
  43:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 2015-05-08:
  44:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *     - Added XMC_USIC_CH_SetInputTriggerCombinationMode() and XMC_USIC_CH_SetTransmitBufferStatus
  45:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *      
  46:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 2015-06-20:
  47:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *     - Removed version macros and declaration of GetDriverVersion API
  48:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 
  49:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 2015-08-17:
  50:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *     - Bug fixed in XMC_USIC_CH_SetTransmitBufferStatus API. OR operator removed.
  51:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
  52:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 2015-08-24:
  53:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *     - Added APIs for enabling/disabling delay compensation XMC_USIC_CH_DisableDelayCompensation(
  54:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *       XMC_USIC_CH_DisableDelayCompensation()
  55:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
  56:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 2015-08-25:
  57:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *     - Added APIs for defining if the data shift unit input is derived
  58:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *       from the input data path DXn or from the selected protocol pre-processors: XMC_USIC_CH_Con
  59:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *       and XMC_USIC_CH_ConnectInputDataShiftToDataInput()
  60:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
  61:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 2015-08-27:
  62:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *     - Fixed bug in XMC_USIC_CH_BRG_CLOCK_SOURCE_DX1T value.
  63:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *     - Added APIs for direct TBUF access: XMC_USIC_CH_WriteToTBUF() and XMC_USIC_CH_WriteToTBUFTC
  64:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *     - Added APIs for external input for BRG configuration:XMC_USIC_CH_ConfigExternalInputSignalT
  65:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
  66:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 2015-08-28:
  67:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *     - Added API for enabling the transfer trigger unit to set bit TCSR.TE if the trigger signal 
  68:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *       Clear to Send (CTS) signal: XMC_USIC_CH_EnableTBUFDataValidTrigger() and XMC_USIC_CH_Disab
  69:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
  70:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 2016-03-09:
  71:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *     - Optimization of write only registers
  72:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
  73:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 2016-04-10:
  74:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *     - Added an API to put the data into FIFO when hardware port control is enabled: XMC_USIC_CH_
  75:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
  76:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 2017-02-10:
  77:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *     - Added XMC_USIC_CH_SetShiftDirection() to allow selection of shift direction of the data wo
  78:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *     - Added XMC_USIC_CH_GetCaptureTimerValue() and XMC_USIC_CH_SetFractionalDivider()
  79:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
  80:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @endcond
  81:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
  82:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
  83:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
  84:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** #ifndef XMC_USIC_H
  85:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** #define XMC_USIC_H
  86:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /*******************************************************************************
  87:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * HEADER FILES
  88:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *******************************************************************************/
  89:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
  90:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** #include "xmc_common.h"
  91:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
  92:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
  93:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @addtogroup XMClib XMC Peripheral Library
  94:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @{
  95:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
  96:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
  97:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
  98:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @addtogroup USIC
  99:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @brief Universal Serial Interface Channel(USIC) driver for serial communication.
 100:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
 101:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * The Universal Serial Interface Channel(USIC) module is a flexible interface module
 102:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * covering several serial communication protocols. A USIC module contains two
 103:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * independent communication channels named USICx_CH0 and USICx_CH1, with x
 104:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * being the number of the USIC module. The user can program, during run-time, which protocol will 
 105:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * by each communication channel and which pins are used.
 106:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * The driver provides APIs, configuration structures and enumerations to configure common features
 107:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * communication protocols.
 108:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 
 109:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * USIC driver features:
 110:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * -# Allows configuration of FIFO for transmit and receive functions.
 111:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * -# Provides a structure type XMC_USIC_CH_t to represent the USIC channel registers in a programm
 112:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  friendly format.
 113:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * -# Allows configuration of automatic update for frame length, word length, slave select or slave
 114:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * -# Allows transmission of data to FIFO using XMC_USIC_CH_TXFIFO_PutData() and XMC_USIC_CH_TXFIFO
 115:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * -# Allows reading of received data in FIFO using XMC_USIC_CH_RXFIFO_GetData()
 116:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * -# Allows configuration of baudrate using XMC_USIC_CH_SetBaudrate()
 117:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * -# Provides API to trigger interrupts using XMC_USIC_CH_TriggerServiceRequest()
 118:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @{
 119:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
 120:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
 121:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /*******************************************************************************
 122:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * MACROS
 123:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *******************************************************************************/
 124:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
 125:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** #define XMC_USIC0 ((XMC_USIC_t *)USIC0_BASE)			/**< USIC0 module base address */
 126:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** #define XMC_USIC0_CH0 ((XMC_USIC_CH_t *)USIC0_CH0_BASE)	/**< USIC0 channel 0 base address */
 127:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** #define XMC_USIC0_CH1 ((XMC_USIC_CH_t *)USIC0_CH1_BASE)	/**< USIC0 channel 1 base address */
 128:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
 129:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** #if defined(USIC1)
 130:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** #define XMC_USIC1 ((XMC_USIC_t *)USIC1_BASE)			/**< USIC1 module base address */
 131:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** #define XMC_USIC1_CH0 ((XMC_USIC_CH_t *)USIC1_CH0_BASE)	/**< USIC1 channel 0 base address */
 132:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** #define XMC_USIC1_CH1 ((XMC_USIC_CH_t *)USIC1_CH1_BASE)	/**< USIC1 channel 1 base address */
 133:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** #endif
 134:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
 135:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** #if defined(USIC2)
 136:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** #define XMC_USIC2 ((XMC_USIC_t *)USIC2_BASE)			/**< USIC2 module base address */
 137:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** #define XMC_USIC2_CH0 ((XMC_USIC_CH_t *)USIC2_CH0_BASE)	/**< USIC2 channel 0 base address */
 138:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** #define XMC_USIC2_CH1 ((XMC_USIC_CH_t *)USIC2_CH1_BASE)	/**< USIC2 channel 1 base address */
 139:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** #endif
 140:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
 141:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** #define USIC_CH_DXCR_DSEL_Msk  USIC_CH_DX0CR_DSEL_Msk   /**< Common mask for DSEL bitfield mask in 
 142:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** #define USIC_CH_DXCR_DSEL_Pos  USIC_CH_DX0CR_DSEL_Pos   /**< Common mask for DSEL bitfield position
 143:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** #define USIC_CH_DXCR_SFSEL_Pos USIC_CH_DX0CR_SFSEL_Pos  /**< Common mask for SFSEL bitfield positio
 144:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** #define USIC_CH_DXCR_SFSEL_Msk USIC_CH_DX0CR_SFSEL_Msk  /**< Common mask for SFSEL bitfield mask in
 145:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** #define USIC_CH_DXCR_DPOL_Msk  USIC_CH_DX0CR_DPOL_Msk   /**< Common mask for DPOL bitfield mask in 
 146:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** #define USIC_CH_DXCR_DFEN_Msk  USIC_CH_DX0CR_DFEN_Msk   /**< Common mask for DFEN bitfield mask in 
 147:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** #define USIC_CH_DXCR_DSEN_Msk  USIC_CH_DX0CR_DSEN_Msk   /**< Common mask for DSEN bitfield mask in 
 148:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** #define USIC_CH_DXCR_CM_Pos    USIC_CH_DX0CR_CM_Pos     /**< Common mask for CM bitfield position i
 149:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** #define USIC_CH_DXCR_CM_Msk    USIC_CH_DX0CR_CM_Msk     /**< Common mask for CM bitfield mask in DX
 150:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** #define USIC_CH_DXCR_INSW_Msk  USIC_CH_DX0CR_INSW_Msk   /**< Common mask for INSW bitfield mask in 
 151:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** #define USIC_CH_DXCR_INSW_pos  USIC_CH_DX0CR_INSW_Pos   /**< Common mask for INSW bitfield position
 152:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
 153:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** #if UC_FAMILY == XMC1
 154:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  #include "xmc1_usic_map.h"
 155:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** #endif
 156:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
 157:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** #if UC_FAMILY == XMC4
 158:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  #include "xmc4_usic_map.h"
 159:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** #endif
 160:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
 161:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /*******************************************************************************
 162:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * ENUMS
 163:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *******************************************************************************/
 164:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
 165:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
 166:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * USIC channel driver status
 167:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
 168:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** typedef enum XMC_USIC_CH_STATUS
 169:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
 170:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_STATUS_OK,    /**< USIC driver status : OK */
 171:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_STATUS_ERROR, /**< USIC driver status : ERROR */
 172:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_STATUS_BUSY   /**< USIC driver status : BUSY */
 173:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** } XMC_USIC_CH_STATUS_t;
 174:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
 175:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
 176:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** * USIC channel kernel mode
 177:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** */
 178:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** typedef enum XMC_USIC_CH_KERNEL_MODE
 179:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
 180:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_KERNEL_MODE_RUN_0  = 0x0UL,  /**< Run mode 0 (transmission and reception possible)*/
 181:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_KERNEL_MODE_RUN_1  = 0x1UL << USIC_CH_KSCFG_NOMCFG_Pos,  /**< Run mode 1 (transmissio
 182:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_KERNEL_MODE_STOP_0 = 0x2UL << USIC_CH_KSCFG_NOMCFG_Pos,  /**< Stop mode 0 (no transmi
 183:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_KERNEL_MODE_STOP_1 = 0x3UL << USIC_CH_KSCFG_NOMCFG_Pos   /**< Stop mode 1 (both trans
 184:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** } XMC_USIC_CH_KERNEL_MODE_t;
 185:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
 186:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
 187:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * USIC channel operating mode
 188:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
 189:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** typedef enum XMC_USIC_CH_OPERATING_MODE
 190:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
 191:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_OPERATING_MODE_IDLE = 0x0UL, /**< USIC channel idle */
 192:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_OPERATING_MODE_SPI  = 0x1UL << USIC_CH_CCR_MODE_Pos, /**< SPI mode */
 193:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_OPERATING_MODE_UART = 0x2UL << USIC_CH_CCR_MODE_Pos, /**< UART mode */
 194:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_OPERATING_MODE_I2S  = 0x3UL << USIC_CH_CCR_MODE_Pos, /**< I2S mode */
 195:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_OPERATING_MODE_I2C  = 0x4UL << USIC_CH_CCR_MODE_Pos  /**< I2C mode */
 196:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** } XMC_USIC_CH_OPERATING_MODE_t;
 197:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
 198:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
 199:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * USIC channel inputs
 200:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
 201:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** typedef enum XMC_USIC_CH_INPUT
 202:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
 203:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_INPUT_DX0, /**< DX0 input */
 204:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_INPUT_DX1, /**< DX1 input */
 205:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_INPUT_DX2, /**< DX2 input */
 206:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_INPUT_DX3, /**< DX3 input */
 207:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_INPUT_DX4, /**< DX4 input */
 208:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_INPUT_DX5  /**< DX5 input */
 209:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** } XMC_USIC_CH_INPUT_t;
 210:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
 211:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
 212:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * USIC channel input source sampling frequency
 213:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
 214:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** typedef enum XMC_USIC_CH_INPUT_SAMPLING_FREQ
 215:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
 216:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_INPUT_SAMPLING_FREQ_FPERIPH            = 0x0UL, /**< Use fperiph frequency for input 
 217:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_INPUT_SAMPLING_FREQ_FRACTIONAL_DIVIDER = 0x1UL << USIC_CH_DXCR_SFSEL_Pos  /**< Use fF
 218:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** } XMC_USIC_CH_INPUT_SAMPLING_FREQ_t;
 219:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
 220:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
 221:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * USIC channel input combination mode
 222:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
 223:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** typedef enum XMC_USIC_CH_INPUT_COMBINATION_MODE
 224:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
 225:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_INPUT_COMBINATION_MODE_TRIGGER_DISABLED = 0x0UL, /**< The trigger activation is disab
 226:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_INPUT_COMBINATION_MODE_RISING_EDGE      = 0x1UL, /**< A rising edge activates DXnT*/
 227:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_INPUT_COMBINATION_MODE_FALLING_EDGE     = 0x2UL, /**< A falling edge activates DXnT*/
 228:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_INPUT_COMBINATION_MODE_BOTH_EDGES       = 0x3UL, /**< Both edges activate DXnT*/
 229:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** } XMC_USIC_CH_INPUT_COMBINATION_MODE_t;
 230:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
 231:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
 232:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * USIC channel data transmission start modes.
 233:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Data shifted out of the transmit pin depends on the value configured for the
 234:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * TDEN bitfield of the TCSR register. Following enum values are used for configuring
 235:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * the TCSR->TDEN bitfield.
 236:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
 237:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** typedef enum XMC_USIC_CH_START_TRANSMISION_MODE
 238:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
 239:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_START_TRANSMISION_DISABLED      = 0x0U, /**< Passive data level is sent out on transm
 240:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_START_TRANSMISION_ON_TDV        = 0x1UL << USIC_CH_TCSR_TDEN_Pos, /**< Transmission o
 241:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_START_TRANSMISION_ON_TDV_DX2S_0 = 0x2UL << USIC_CH_TCSR_TDEN_Pos, /**< Transmission o
 242:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_START_TRANSMISION_ON_TDV_DX2S_1 = 0x3UL << USIC_CH_TCSR_TDEN_Pos  /**< Transmission o
 243:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** } XMC_USIC_CH_START_TRANSMISION_MODE_t;
 244:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
 245:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
 246:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * USIC channel interrupt node pointers
 247:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
 248:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** typedef enum XMC_USIC_CH_INTERRUPT_NODE_POINTER
 249:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
 250:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_INTERRUPT_NODE_POINTER_TRANSMIT_SHIFT      = USIC_CH_INPR_TSINP_Pos, /**< Node pointe
 251:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_INTERRUPT_NODE_POINTER_TRANSMIT_BUFFER     = USIC_CH_INPR_TBINP_Pos, /**< Node pointe
 252:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_INTERRUPT_NODE_POINTER_RECEIVE             = USIC_CH_INPR_RINP_Pos,  /**< Node pointe
 253:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_INTERRUPT_NODE_POINTER_ALTERNATE_RECEIVE   = USIC_CH_INPR_AINP_Pos,  /**< Node pointe
 254:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_INTERRUPT_NODE_POINTER_PROTOCOL            = USIC_CH_INPR_PINP_Pos   /**< Node pointe
 255:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** } XMC_USIC_CH_INTERRUPT_NODE_POINTER_t;
 256:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
 257:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
 258:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * USIC channel events
 259:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
 260:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** typedef enum XMC_USIC_CH_EVENT
 261:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
 262:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_EVENT_RECEIVE_START       = USIC_CH_CCR_RSIEN_Msk, /**< Receive start event */
 263:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_EVENT_DATA_LOST           = USIC_CH_CCR_DLIEN_Msk, /**< Data lost event */
 264:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_EVENT_TRANSMIT_SHIFT      = USIC_CH_CCR_TSIEN_Msk, /**< Transmit shift event */
 265:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_EVENT_TRANSMIT_BUFFER     = USIC_CH_CCR_TBIEN_Msk, /**< Transmit buffer event */
 266:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_EVENT_STANDARD_RECEIVE    = USIC_CH_CCR_RIEN_Msk,  /**< Receive event */
 267:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_EVENT_ALTERNATIVE_RECEIVE = USIC_CH_CCR_AIEN_Msk,  /**< Alternate receive event */
 268:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_EVENT_BAUD_RATE_GENERATOR = USIC_CH_CCR_BRGIEN_Msk /**< Baudrate generator event */
 269:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** } XMC_USIC_CH_EVENT_t;
 270:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
 271:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
 272:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** * USIC channel parity mode
 273:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** */
 274:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** typedef enum XMC_USIC_CH_PARITY_MODE
 275:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
 276:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_PARITY_MODE_NONE     = 0x0UL,  /**< Disable parity mode */
 277:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_PARITY_MODE_EVEN     = 0x2UL << USIC_CH_CCR_PM_Pos,  /**< Enable even parity mode */
 278:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_PARITY_MODE_ODD      = 0x3UL << USIC_CH_CCR_PM_Pos   /**< Enable odd parity mode */
 279:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** } XMC_USIC_CH_PARITY_MODE_t;
 280:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
 281:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
 282:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** * USIC channel data output mode
 283:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** */
 284:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** typedef enum XMC_USIC_CH_DATA_OUTPUT_MODE
 285:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
 286:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_DATA_OUTPUT_MODE_NORMAL   = 0x0UL,  /**< Data output normal mode */
 287:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_DATA_OUTPUT_MODE_INVERTED = 0x1UL << USIC_CH_SCTR_DOCFG_Pos   /**< Data output invert
 288:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** } XMC_USIC_CH_DATA_OUTPUT_MODE_t;
 289:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
 290:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
 291:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** * USIC channel data transmit buffer status
 292:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** */
 293:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** typedef enum XMC_USIC_CH_TBUF_STATUS
 294:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
 295:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_TBUF_STATUS_IDLE = 0x0UL,                 /**< Transfer buffer is currently idle*/
 296:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_TBUF_STATUS_BUSY = USIC_CH_TCSR_TDV_Msk   /**< Transfer buffer is currently busy*/
 297:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** } XMC_USIC_CH_TBUF_STATUS_t;
 298:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
 299:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
 300:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
 301:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
 302:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** * USIC channel data transmit buffer status modification
 303:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** */
 304:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** typedef enum XMC_USIC_CH_TBUF_STATUS_SET
 305:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
 306:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_TBUF_STATUS_SET_BUSY   = 0x1UL, /**< Set Transfer buffer status to busy*/
 307:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_TBUF_STATUS_SET_IDLE   = 0x2UL  /**< Set Transfer buffer status to idle*/
 308:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** } XMC_USIC_CH_TBUF_STATUS_SET_t;
 309:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
 310:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
 311:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** * USIC channel receive buffer status
 312:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** */
 313:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** typedef enum XMC_USIC_CH_RBUF_STATUS
 314:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
 315:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_RBUF_STATUS_DATA_VALID0 = USIC_CH_RBUFSR_RDV0_Msk, /**< RBUF0 data has not yet been r
 316:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_RBUF_STATUS_DATA_VALID1 = USIC_CH_RBUFSR_RDV1_Msk  /**< RBUF1 data has not yet been r
 317:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** } XMC_USIC_CH_RBUF_STATUS_t;
 318:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
 319:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
 320:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * USIC channel output signal passive data level
 321:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** */
 322:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** typedef enum XMC_USCI_CH_PASSIVE_DATA_LEVEL
 323:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
 324:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_PASSIVE_DATA_LEVEL0 = 0x0UL, /**< Passive level(idle mode signal level) 0 */
 325:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_PASSIVE_DATA_LEVEL1 = 0x1UL << USIC_CH_SCTR_PDL_Pos  /**< Passive level(idle mode sig
 326:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** } XMC_USIC_CH_PASSIVE_DATA_LEVEL_t;
 327:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
 328:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
 329:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** * USIC channel receive FIFO size
 330:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** */
 331:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** typedef enum XMC_USIC_CH_FIFO_SIZE
 332:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
 333:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_FIFO_DISABLED     = 0x0U,  /**< FIFO Disabled */
 334:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_FIFO_SIZE_2WORDS  = 0x1U,  /**< FIFO size: 2 words */
 335:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_FIFO_SIZE_4WORDS  = 0x2U,  /**< FIFO size: 4 words */
 336:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_FIFO_SIZE_8WORDS  = 0x3U,  /**< FIFO size: 8 words */
 337:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_FIFO_SIZE_16WORDS = 0x4U,  /**< FIFO size: 16 words */
 338:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_FIFO_SIZE_32WORDS = 0x5U,  /**< FIFO size: 32 words */
 339:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_FIFO_SIZE_64WORDS = 0x6U   /**< FIFO size: 64 words */
 340:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** } XMC_USIC_CH_FIFO_SIZE_t;
 341:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
 342:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
 343:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** * USIC channel transmit FIFO interrupt node pointers
 344:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** */
 345:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** typedef enum XMC_USIC_CH_TXFIFO_INTERRUPT_NODE_POINTER
 346:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
 347:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_TXFIFO_INTERRUPT_NODE_POINTER_STANDARD  = USIC_CH_TBCTR_STBINP_Pos,  /**< Node pointe
 348:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_TXFIFO_INTERRUPT_NODE_POINTER_ALTERNATE = USIC_CH_TBCTR_ATBINP_Pos   /**< Node pointe
 349:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** } XMC_USIC_CH_TXFIFO_INTERRUPT_NODE_POINTER_t;
 350:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
 351:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
 352:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** * USIC channel transmit FIFO event configuration
 353:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** */
 354:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** typedef enum XMC_USIC_CH_TXFIFO_EVENT_CONF
 355:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
 356:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_TXFIFO_EVENT_CONF_STANDARD  = USIC_CH_TBCTR_STBIEN_Msk,   /**< Enable FIFO standard t
 357:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_TXFIFO_EVENT_CONF_ERROR     = (int32_t)USIC_CH_TBCTR_TBERIEN_Msk  /**< Enable transmi
 358:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** } XMC_USIC_CH_TXFIFO_EVENT_CONF_t;
 359:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
 360:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
 361:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** * USIC channel transmit FIFO status
 362:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** */
 363:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** typedef enum XMC_USIC_CH_TXFIFO_EVENT
 364:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
 365:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_TXFIFO_EVENT_STANDARD = USIC_CH_TRBSR_STBI_Msk,    /**< Transmit FIFO status: Standar
 366:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_TXFIFO_EVENT_ERROR    = USIC_CH_TRBSR_TBERI_Msk    /**< Transmit FIFO status: Error e
 367:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** } XMC_USIC_CH_TXFIFO_EVENT_t;
 368:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
 369:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
 370:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** * USIC channel receive FIFO interrupt node pointers
 371:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** */
 372:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** typedef enum XMC_USIC_CH_RXFIFO_INTERRUPT_NODE_POINTER
 373:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
 374:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_RXFIFO_INTERRUPT_NODE_POINTER_STANDARD  = USIC_CH_RBCTR_SRBINP_Pos, /**< Node pointer
 375:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_RXFIFO_INTERRUPT_NODE_POINTER_ALTERNATE = USIC_CH_RBCTR_ARBINP_Pos  /**< Node pointer
 376:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** } XMC_USIC_CH_RXFIFO_INTERRUPT_NODE_POINTER_t;
 377:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
 378:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
 379:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** * USIC channel receive FIFO event configuration
 380:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** */
 381:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** typedef enum XMC_USIC_CH_RXFIFO_EVENT_CONF
 382:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
 383:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_RXFIFO_EVENT_CONF_STANDARD  = USIC_CH_RBCTR_SRBIEN_Msk,   /**< Enable FIFO standard r
 384:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_RXFIFO_EVENT_CONF_ERROR     = (int32_t)USIC_CH_RBCTR_RBERIEN_Msk,  /**< Enable receiv
 385:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_RXFIFO_EVENT_CONF_ALTERNATE = USIC_CH_RBCTR_ARBIEN_Msk   /**< Enable FIFO alternative
 386:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** } XMC_USIC_CH_RXFIFO_EVENT_CONF_t;
 387:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
 388:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
 389:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** * USIC channel receive FIFO status
 390:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** */
 391:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** typedef enum XMC_USIC_CH_RXFIFO_EVENT
 392:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
 393:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_RXFIFO_EVENT_STANDARD  = USIC_CH_TRBSR_SRBI_Msk,   /**< Receive FIFO status: Standard
 394:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_RXFIFO_EVENT_ERROR     = USIC_CH_TRBSR_RBERI_Msk,  /**< Receive FIFO status: Error ev
 395:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_RXFIFO_EVENT_ALTERNATE = USIC_CH_TRBSR_ARBI_Msk    /**< Receive FIFO status: Alternat
 396:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** } XMC_USIC_CH_RXFIFO_EVENT_t;
 397:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
 398:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
 399:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** * USIC channel baudrate generator clock source
 400:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** */
 401:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** typedef enum XMC_USIC_CH_BRG_CLOCK_SOURCE
 402:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
 403:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_BRG_CLOCK_SOURCE_DIVIDER = 0x0UL, /**< Baudrate generator clock source : Source divid
 404:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_BRG_CLOCK_SOURCE_DX1T    = 0x2UL << USIC_CH_BRG_CLKSEL_Pos  /**< Baudrate generator c
 405:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** } XMC_USIC_CH_BRG_CLOCK_SOURCE_t;
 406:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
 407:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
 408:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** * USIC channel baudrate generator divider mode
 409:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** */
 410:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** typedef enum XMC_USIC_CH_BRG_CLOCK_DIVIDER_MODE
 411:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
 412:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_BRG_CLOCK_DIVIDER_MODE_DISABLED   = 0x0UL, /**< Baudrate generator clock divider: Dis
 413:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_BRG_CLOCK_DIVIDER_MODE_NORMAL     = 0x1UL << USIC_CH_FDR_DM_Pos, /**< Baudrate genera
 414:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_BRG_CLOCK_DIVIDER_MODE_FRACTIONAL = 0x2UL << USIC_CH_FDR_DM_Pos  /**< Baudrate genera
 415:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** } XMC_USIC_CH_BRG_CLOCK_DIVIDER_MODE_t;
 416:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
 417:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
 418:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** * USIC channel baudrate generator master clock passive level
 419:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** */
 420:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** typedef enum XMC_USIC_CH_BRG_MASTER_CLOCK_PASSIVE_LEVEL
 421:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
 422:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_BRG_MASTER_CLOCK_PASSIVE_LEVEL_0 = 0x0UL, /**< Baudrate generator master clock passiv
 423:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_BRG_MASTER_CLOCK_PASSIVE_LEVEL_1 = 0x1UL << USIC_CH_BRG_MCLKCFG_Pos  /**< Baudrate ge
 424:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** } XMC_USIC_CH_BRG_MASTER_CLOCK_PASSIVE_LEVEL_t;
 425:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
 426:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
 427:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** * USIC channel baudrate generator shift clock passive level
 428:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** */
 429:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** typedef enum XMC_USIC_CH_BRG_SHIFT_CLOCK_PASSIVE_LEVEL
 430:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
 431:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_BRG_SHIFT_CLOCK_PASSIVE_LEVEL_0_DELAY_DISABLED = 0x0UL, /**< Shift clock passive leve
 432:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_BRG_SHIFT_CLOCK_PASSIVE_LEVEL_1_DELAY_DISABLED = 0x1UL << USIC_CH_BRG_SCLKCFG_Pos, /*
 433:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_BRG_SHIFT_CLOCK_PASSIVE_LEVEL_0_DELAY_ENABLED  = (int32_t)(0x2UL << USIC_CH_BRG_SCLKC
 434:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_BRG_SHIFT_CLOCK_PASSIVE_LEVEL_1_DELAY_ENABLED  = (int32_t)(0x3UL << USIC_CH_BRG_SCLKC
 435:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** } XMC_USIC_CH_BRG_SHIFT_CLOCK_PASSIVE_LEVEL_t;
 436:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
 437:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
 438:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** * USIC channel baudrate generator shift clock output
 439:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** */
 440:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** typedef enum XMC_USIC_CH_BRG_SHIFT_CLOCK_OUTPUT
 441:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
 442:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_BRG_SHIFT_CLOCK_OUTPUT_SCLK = 0x0UL, /**< Baudrate generator shift clock output: SCL.
 443:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_BRG_SHIFT_CLOCK_OUTPUT_DX1 = 0x1UL << USIC_CH_BRG_SCLKOSEL_Pos   /**< Baudrate genera
 444:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** } XMC_USIC_CH_BRG_SHIFT_CLOCK_OUTPUT_t;
 445:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
 446:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
 447:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** * USIC channel shift direction.
 448:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** * Defines the shift direction of the data words for transmission and reception
 449:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** */
 450:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** typedef enum XMC_USIC_CH_SHIFT_DIRECTION
 451:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
 452:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_SHIFT_DIRECTION_LSB_FIRST = 0x0UL, /**< Shift LSB first. The first data bit of a data
 453:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   XMC_USIC_CH_SHIFT_DIRECTION_MSB_FIRST = 0x1UL << USIC_CH_SCTR_SDIR_Msk /**< Shift MSB first. The 
 454:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** } XMC_USIC_CH_SHIFT_DIRECTION_t;
 455:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
 456:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
 457:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /*******************************************************************************
 458:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * DATA STRUCTURES
 459:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *******************************************************************************/
 460:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
 461:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /*Anonymous structure/union guard start*/
 462:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** #if defined(__CC_ARM)
 463:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   #pragma push
 464:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   #pragma anon_unions
 465:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** #elif defined(__TASKING__)
 466:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   #pragma warning 586
 467:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** #endif
 468:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
 469:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
 470:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * USIC module structure
 471:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
 472:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** typedef USIC_GLOBAL_TypeDef XMC_USIC_t;
 473:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
 474:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
 475:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * USIC channel structure.<br> The members of the structure are same as in the device header file, 
 476:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * except for some registers.
 477:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * DX0CR, DX1CR, DX2CR, DX3CR, DX4CR and DX5CR are replaced with the array DXCR[6].
 478:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * TBUF0 to TBUF31 are replaced with TBUF[32].
 479:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * IN0 to IN31 are replaced with IN[32].
 480:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
 481:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** typedef struct XMC_USIC_CH
 482:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
 483:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   __I  uint32_t  RESERVED0;
 484:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   __I  uint32_t  CCFG;			/**< Channel configuration register*/
 485:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   __I  uint32_t  RESERVED1;
 486:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   __IO uint32_t  KSCFG;			/**< Kernel state configuration register*/
 487:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   __IO uint32_t  FDR;			/**< Fractional divider configuration register*/
 488:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   __IO uint32_t  BRG;			/**< Baud rate generator register*/
 489:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   __IO uint32_t  INPR;			/**< Interrupt node pointer register*/
 490:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   __IO uint32_t  DXCR[6];		/**< Input control registers DX0 to DX5.*/
 491:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   __IO uint32_t  SCTR;			/**< Shift control register*/
 492:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   __IO uint32_t  TCSR;
 493:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
 494:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   union {
 495:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****     __IO uint32_t  PCR_IICMode;	/**< I2C protocol configuration register*/
 496:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****     __IO uint32_t  PCR_IISMode; /**< I2S protocol configuration register*/
 497:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****     __IO uint32_t  PCR_SSCMode;	/**< SPI protocol configuration register*/
 498:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****     __IO uint32_t  PCR;			/**< Protocol configuration register*/
 499:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****     __IO uint32_t  PCR_ASCMode;	/**< UART protocol configuration register*/
 500:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   };
 501:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   __IO uint32_t  CCR;			/**< Channel control register*/
 502:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   __IO uint32_t  CMTR;			/**< Capture mode timer register*/
 503:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
 504:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   union {
 505:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****     __IO uint32_t  PSR_IICMode;	/**< I2C protocol status register*/
 506:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****     __IO uint32_t  PSR_IISMode;	/**< I2S protocol status register*/
 507:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****     __IO uint32_t  PSR_SSCMode;	/**< SPI protocol status register*/
 508:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****     __IO uint32_t  PSR;			/**< Protocol status register*/
 509:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****     __IO uint32_t  PSR_ASCMode;	/**< UART protocol status register*/
 510:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   };
 511:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   __O  uint32_t  PSCR;			/**< Protocol status clear register*/
 512:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   __I  uint32_t  RBUFSR;		/**< Receive buffer status register*/
 513:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   __I  uint32_t  RBUF;			/**< Receive buffer register*/
 514:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   __I  uint32_t  RBUFD;			/**< Debug mode receive buffer register*/
 515:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   __I  uint32_t  RBUF0;			/**< Receive buffer 0*/
 516:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   __I  uint32_t  RBUF1;			/**< Receive buffer 1*/
 517:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   __I  uint32_t  RBUF01SR;		/**< Receive buffer status register*/
 518:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   __O  uint32_t  FMR;			/**< Flag modification register*/
 519:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   __I  uint32_t  RESERVED2[5];
 520:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   __IO uint32_t  TBUF[32];		/**< Tranmsit buffer registers*/
 521:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   __IO uint32_t  BYP;			/**< FIFO bypass register*/
 522:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   __IO uint32_t  BYPCR;			/**< FIFO bypass control register*/
 523:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   __IO uint32_t  TBCTR;			/**< Transmit FIFO control register*/
 524:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   __IO uint32_t  RBCTR;			/**< Receive FIFO control register*/
 525:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   __I  uint32_t  TRBPTR;		/**< Transmit/recive buffer pointer register*/
 526:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   __IO uint32_t  TRBSR;			/**< Transmit/receive buffer status register*/
 527:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   __O  uint32_t  TRBSCR;		/**< Transmit/receive buffer status clear register*/
 528:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   __I  uint32_t  OUTR;			/**< Receive FIFO output register*/
 529:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   __I  uint32_t  OUTDR;			/**< Receive FIFO debug output register*/
 530:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   __I  uint32_t  RESERVED3[23];
 531:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   __O  uint32_t  IN[32];		/**< Transmit FIFO input register*/
 532:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** } XMC_USIC_CH_t;
 533:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
 534:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
 535:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /*Anonymous structure/union guard end*/
 536:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** #if defined(__CC_ARM)
 537:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   #pragma pop
 538:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** #elif defined(__TASKING__)
 539:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   #pragma warning restore
 540:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** #endif
 541:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
 542:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /*******************************************************************************
 543:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * API PROTOTYPES
 544:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  ******************************************************************************/
 545:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
 546:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** #ifdef __cplusplus
 547:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** extern "C" {
 548:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** #endif
 549:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
 550:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** __STATIC_INLINE bool XMC_USIC_IsModuleValid(const XMC_USIC_t *const module)
 551:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
 552:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   bool tmp;
 553:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
 554:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   tmp = (module == XMC_USIC0);
 555:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** #if defined(XMC_USIC1)  
 556:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   tmp = tmp || (module == XMC_USIC1);
 557:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** #endif
 558:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** #if defined(XMC_USIC2)  
 559:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   tmp = tmp || (module == XMC_USIC2);
 560:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** #endif
 561:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
 562:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   return tmp;
 563:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** }
 564:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
 565:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** __STATIC_INLINE bool XMC_USIC_IsChannelValid(const XMC_USIC_CH_t *const channel)
 566:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
 567:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   bool tmp;
 568:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
 569:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   tmp = ((channel == XMC_USIC0_CH0) || (channel == XMC_USIC0_CH1));
 570:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** #if defined(XMC_USIC1)  
 571:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   tmp = tmp || ((channel == XMC_USIC1_CH0) || (channel == XMC_USIC1_CH1));
 572:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** #endif
 573:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** #if defined(XMC_USIC2)  
 574:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   tmp = tmp || ((channel == XMC_USIC2_CH0) || (channel == XMC_USIC2_CH1));
 575:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** #endif
 576:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
 577:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   return tmp;
 578:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** }
 579:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
 580:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /* Common APIs */
 581:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
 582:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
 583:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param  usic Pointer to USIC module handler of type @ref XMC_USIC_t.\n
 584:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				\b Range: @ref XMC_USIC0 to @ref XMC_USIC2 based on device support.
 585:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @return None
 586:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 
 587:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Description</b><br>
 588:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Enables the USIC module.\n\n
 589:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Enables the clock for the USIC module by following the
 590:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * clock enabling sequence for the selected device.
 591:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
 592:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Related APIs:</b><BR>
 593:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * XMC_USIC_CH_Enable(), XMC_USIC_Disable() \n\n\n
 594:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
 595:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** void XMC_USIC_Enable(XMC_USIC_t *const usic);
 596:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
 597:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param  usic Pointer to USIC module handler of type @ref XMC_USIC_t.\n
 598:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				\b Range: @ref XMC_USIC0 to @ref XMC_USIC2 based on device support.
 599:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @return None
 600:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
 601:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Description</b><br>
 602:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Disables the USIC module.\n\n
 603:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Disables the clock for the USIC module by following the clock
 604:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * disabling sequence for the selected device.
 605:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
 606:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Related APIs:</b><BR>
 607:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * XMC_USIC_CH_Disable(), XMC_USIC_Enable() \n\n\n
 608:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
 609:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** void XMC_USIC_Disable(XMC_USIC_t *const usic);
 610:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
 611:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param  channel Pointer to USIC channel handler of type @ref XMC_USIC_CH_t \n
 612:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				   \b Range: @ref XMC_USIC0_CH0, @ref XMC_USIC0_CH1 to @ref XMC_USIC2_CH1 based on device su
 613:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @return None
 614:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
 615:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Description</b><br>
 616:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Enables the USIC channel. \n\n
 617:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * USIC channel is enabled by setting the module enable bit in KSCFG register bitfield MODEN.
 618:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * On enabling, the channel is set to idle mode.
 619:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
 620:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Related APIs:</b><BR>
 621:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * XMC_USIC_CH_Disable(), XMC_USIC_Enable() \n\n\n
 622:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
 623:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** void XMC_USIC_CH_Enable(XMC_USIC_CH_t *const channel);
 624:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
 625:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param  channel Pointer to USIC channel handler of type @ref XMC_USIC_CH_t \n
 626:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				   \b Range: @ref XMC_USIC0_CH0, @ref XMC_USIC0_CH1 to @ref XMC_USIC2_CH1 based on device su
 627:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @return None
 628:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
 629:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Description</b><br>
 630:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Disables the USIC channel.\n\n
 631:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * USIC channel is disabled by setting the module enable bit(MDEN) to 0 in the register KSCFG.
 632:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
 633:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Related APIs:</b><BR>
 634:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * XMC_USIC_CH_Enable(), XMC_USIC_Disable() \n\n\n
 635:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
 636:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** void XMC_USIC_CH_Disable(XMC_USIC_CH_t *const channel);
 637:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
 638:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
 639:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param  channel Pointer to USIC channel handler of type @ref XMC_USIC_CH_t \n
 640:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				   \b Range: @ref XMC_USIC0_CH0, @ref XMC_USIC0_CH1 to @ref XMC_USIC2_CH1 based on device su
 641:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param  rate Desired baudrate. \b Range: minimum value = 100, maximum value depends on the perip
 642:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				and \a oversampling. Maximum baudrate can be derived using the formula: (fperiph * 1023)/(10
 643:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param  oversampling Required oversampling. The value indicates the number of time quanta for on
 644:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 						This can be related to the number of samples for each logic state of the data signal. \n
 645:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 						\b Range: 1 to 32. Value should be chosen based on the protocol used.
 646:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @return Status indicating the baudrate configuration.\n
 647:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 			\b Range: @ref XMC_USIC_CH_STATUS_OK if baudrate is successfully configured,
 648:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 					  @ref XMC_USIC_CH_STATUS_ERROR if desired baudrate or oversampling is invalid.
 649:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
 650:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Description</b><br>
 651:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Configures the baudrate of the USIC channel. \n\n
 652:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Baudrate is configured by considering the peripheral frequency and the desired baudrate.
 653:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Optimum values of FDR->STEP and BRG->PDIV are calulated and used for generating the desired
 654:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * baudrate.
 655:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
 656:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Related APIs:</b><BR>
 657:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * XMC_USIC_CH_SetStartTransmisionMode(), XMC_USIC_CH_SetInputSource() \n\n\n
 658:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
 659:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** XMC_USIC_CH_STATUS_t XMC_USIC_CH_SetBaudrate(XMC_USIC_CH_t *const channel, uint32_t rate, uint32_t 
 660:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
 661:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
 662:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param  channel Pointer to USIC channel handler of type @ref XMC_USIC_CH_t \n
 663:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				   \b Range: @ref XMC_USIC0_CH0, @ref XMC_USIC0_CH1 to @ref XMC_USIC2_CH1 based on device su
 664:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param  pdiv Desired divider for the external frequency input. \b Range: minimum value = 1, maxi
 665:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param  oversampling Required oversampling. The value indicates the number of time quanta for on
 666:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 						This can be related to the number of samples for each logic state of the data signal. \n
 667:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 						\b Range: 1 to 32. Value should be chosen based on the protocol used.
 668:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param  combination_mode Selects which edge of the synchronized(and optionally filtered) signal 
 669:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *                          output DXnT of the input stage.
 670:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
 671:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @return None
 672:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
 673:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Description</b><br>
 674:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Enables the external frequency input for the Baudrate Generator and configures the divider, over
 675:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * the combination mode of the USIC channel. \n\n
 676:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
 677:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Related APIs:</b><BR>
 678:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * XMC_USIC_CH_SetBRGInputClockSource(), XMC_USIC_CH_SetInputTriggerCombinationMode() \n\n\n
 679:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
 680:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** void XMC_USIC_CH_ConfigExternalInputSignalToBRG(XMC_USIC_CH_t *const channel,
 681:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 		                                         const uint16_t pdiv,
 682:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 												 const uint32_t oversampling,
 683:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 												 const XMC_USIC_CH_INPUT_COMBINATION_MODE_t combination_mode);
 684:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
 685:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
 686:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param  channel Pointer to USIC channel handler of type @ref XMC_USIC_CH_t \n
 687:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				   \b Range: @ref XMC_USIC0_CH0, @ref XMC_USIC0_CH1 to @ref XMC_USIC2_CH1 based on device su
 688:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param  input USIC channel input stage of type @ref XMC_USIC_CH_INPUT_t. \n
 689:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				 \b Range: @ref XMC_USIC_CH_INPUT_DX0 to @ref XMC_USIC_CH_INPUT_DX5
 690:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param  source Input source select for the input stage. The table below maps the enum value with
 691:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * <table><tr><td>0</td><td>DXnA</td></tr><tr><td>1</td><td>DXnB</td></tr><tr><td>2</td><td>DXnC</t
 692:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * <tr><td>4</td><td>DXnE</td></tr><tr><td>5</td><td>DXnF</td></tr><tr><td>6</td><td>DXnG</td></tr>
 693:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * </tr></table>
 694:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @return None
 695:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
 696:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Description</b><br>
 697:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Selects the data source for USIC input stage.\n\n
 698:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Selects the input data signal source among DXnA, DXnB.. DXnG for the input stage. The API can be
 699:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * like DX0CR, DX1CR etc. 
 700:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *  
 701:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Related APIs:</b><BR>
 702:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * XMC_USIC_CH_EnableInputInversion(), XMC_USIC_CH_EnableInputDigitalFilter(), XMC_USIC_CH_EnableIn
 703:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * XMC_USIC_CH_SetInputSamplingFreq()\n\n\n
 704:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
 705:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** __STATIC_INLINE void XMC_USIC_CH_SetInputSource(XMC_USIC_CH_t *const channel, const XMC_USIC_CH_INP
 706:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
 707:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   channel->DXCR[input] = (uint32_t)((channel->DXCR[input] & (uint32_t)(~USIC_CH_DXCR_DSEL_Msk)) |
 708:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****                          ((uint32_t)source << USIC_CH_DXCR_DSEL_Pos));
 709:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** }
 710:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
 711:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param  channel Pointer to USIC channel handler of type @ref XMC_USIC_CH_t \n
 712:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				   \b Range: @ref XMC_USIC0_CH0, @ref XMC_USIC0_CH1 to @ref XMC_USIC2_CH1 based on device su
 713:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param  input USIC channel input stage of type @ref XMC_USIC_CH_INPUT_t. \n
 714:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				 \b Range: @ref XMC_USIC_CH_INPUT_DX0 to @ref XMC_USIC_CH_INPUT_DX5
 715:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @return None
 716:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
 717:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Description</b><br>
 718:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * The input of the data shift unit is controlled by the
 719:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * protocol pre-processor. \n\n
 720:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
 721:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Related APIs:</b><BR>
 722:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * XMC_USIC_CH_ConnectInputDataShiftToDataInput()\n\n\n
 723:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
 724:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** __STATIC_INLINE void XMC_USIC_CH_ConnectInputDataShiftToPPP(XMC_USIC_CH_t *const channel, const XMC
 725:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
 726:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   channel->DXCR[input] &=(uint32_t)~USIC_CH_DXCR_INSW_Msk;
 727:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** }
 728:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
 729:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
 730:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param  channel Pointer to USIC channel handler of type @ref XMC_USIC_CH_t \n
 731:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				   \b Range: @ref XMC_USIC0_CH0, @ref XMC_USIC0_CH1 to @ref XMC_USIC2_CH1 based on device su
 732:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param  input USIC channel input stage of type @ref XMC_USIC_CH_INPUT_t. \n
 733:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				 \b Range: @ref XMC_USIC_CH_INPUT_DX0 to @ref XMC_USIC_CH_INPUT_DX5
 734:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @return None
 735:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
 736:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Description</b><br>
 737:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * The input of the data shift unit is connected to
 738:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * the selected data input line. \n\n
 739:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
 740:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * This setting is used
 741:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * if the signals are directly derived from an input
 742:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * pin without treatment by the protocol preprocessor.
 743:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Related APIs:</b><BR>
 744:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * XMC_USIC_CH_ConnectInputDataShiftToPPP()\n\n\n
 745:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
 746:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** __STATIC_INLINE void XMC_USIC_CH_ConnectInputDataShiftToDataInput(XMC_USIC_CH_t *const channel, con
 747:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
 748:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   channel->DXCR[input] |= USIC_CH_DXCR_INSW_Msk;
 749:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** }
 750:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
 751:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
 752:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param  channel Pointer to USIC channel handler of type @ref XMC_USIC_CH_t \n
 753:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				   \b Range: @ref XMC_USIC0_CH0, @ref XMC_USIC0_CH1 to @ref XMC_USIC2_CH1 based on device su
 754:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param  input USIC channel input stage of type @ref XMC_USIC_CH_INPUT_t. \n
 755:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				 \b Range: @ref XMC_USIC_CH_INPUT_DX0 to @ref XMC_USIC_CH_INPUT_DX5
 756:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @return None
 757:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
 758:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Description</b><br>
 759:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Enables input inversion for USIC channel input data signal. \n\n
 760:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
 761:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Polarity of the input source can be changed to provide inverted data input.
 762:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Related APIs:</b><BR>
 763:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * XMC_USIC_CH_DisableInputInversion()\n\n\n
 764:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
 765:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** __STATIC_INLINE void XMC_USIC_CH_EnableInputInversion(XMC_USIC_CH_t *const channel, const XMC_USIC_
 766:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
 767:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   channel->DXCR[input] |= USIC_CH_DXCR_DPOL_Msk;
 768:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** }
 769:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
 770:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
 771:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param  channel Pointer to USIC channel handler of type @ref XMC_USIC_CH_t \n
 772:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				   \b Range: @ref XMC_USIC0_CH0, @ref XMC_USIC0_CH1 to @ref XMC_USIC2_CH1 based on device su
 773:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param  input USIC channel input stage of type @ref XMC_USIC_CH_INPUT_t. \n
 774:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				 \b Range: @ref XMC_USIC_CH_INPUT_DX0 to @ref XMC_USIC_CH_INPUT_DX5
 775:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @return None
 776:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
 777:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Description</b><br>
 778:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Disables input inversion for USIC channel. \n\n
 779:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
 780:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Resets the input data polarity for the USIC channel input data signal.
 781:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Related APIs:</b><BR>
 782:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * XMC_USIC_CH_EnableInputInversion()\n\n\n
 783:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
 784:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** __STATIC_INLINE void XMC_USIC_CH_DisableInputInversion(XMC_USIC_CH_t *const channel, const XMC_USIC
 785:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
 786:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   channel->DXCR[input] &=(uint32_t)~USIC_CH_DXCR_DPOL_Msk;
 787:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** }
 788:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
 789:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
 790:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param  channel Pointer to USIC channel handler of type @ref XMC_USIC_CH_t \n
 791:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				   \b Range: @ref XMC_USIC0_CH0, @ref XMC_USIC0_CH1 to @ref XMC_USIC2_CH1 based on device su
 792:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @return None
 793:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
 794:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Description</b><br>
 795:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Enables delay compensation. \n\n
 796:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
 797:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Delay compensation can be applied to the receive path.
 798:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Related APIs:</b><BR>
 799:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * XMC_USIC_CH_DisableDelayCompensation()\n\n\n
 800:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
 801:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** __STATIC_INLINE void XMC_USIC_CH_EnableDelayCompensation(XMC_USIC_CH_t *const channel)
 802:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
 803:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   channel->DXCR[1U] |= USIC_CH_DX1CR_DCEN_Msk;
 804:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** }
 805:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
 806:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
 807:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param  channel Pointer to USIC channel handler of type @ref XMC_USIC_CH_t \n
 808:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				   \b Range: @ref XMC_USIC0_CH0, @ref XMC_USIC0_CH1 to @ref XMC_USIC2_CH1 based on device su
 809:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @return None
 810:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
 811:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Description</b><br>
 812:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Disables delay compensation.. \n\n
 813:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
 814:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Related APIs:</b><BR>
 815:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * XMC_USIC_CH_EnableDelayCompensation()\n\n\n
 816:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
 817:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** __STATIC_INLINE void XMC_USIC_CH_DisableDelayCompensation(XMC_USIC_CH_t *const channel)
 818:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
 819:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   channel->DXCR[1U] &=(uint32_t)~USIC_CH_DX1CR_DCEN_Msk;
 820:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** }
 821:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
 822:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
 823:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param  channel Pointer to USIC channel handler of type @ref XMC_USIC_CH_t \n
 824:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				   \b Range: @ref XMC_USIC0_CH0, @ref XMC_USIC0_CH1 to @ref XMC_USIC2_CH1 based on device su
 825:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param  input USIC channel input stage of type @ref XMC_USIC_CH_INPUT_t. \n
 826:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				 \b Range: @ref XMC_USIC_CH_INPUT_DX0 to @ref XMC_USIC_CH_INPUT_DX5
 827:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @return None
 828:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
 829:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Description</b><br>
 830:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Enables the input digital filter for USIC channel input data signal. \n\n
 831:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Input data signal from the selected multiplexer will be digitally filtered.
 832:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
 833:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Related APIs:</b><BR>
 834:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * XMC_USIC_CH_DisableInputDigitalFilter()\n\n\n
 835:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
 836:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** __STATIC_INLINE void XMC_USIC_CH_EnableInputDigitalFilter(XMC_USIC_CH_t *const channel, const XMC_U
 837:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
 838:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   channel->DXCR[input] |= (uint32_t)USIC_CH_DXCR_DFEN_Msk;
 839:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** }
 840:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
 841:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param  channel Pointer to USIC channel handler of type @ref XMC_USIC_CH_t \n
 842:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				   \b Range: @ref XMC_USIC0_CH0, @ref XMC_USIC0_CH1 to @ref XMC_USIC2_CH1 based on device su
 843:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param  input USIC channel input stage of type @ref XMC_USIC_CH_INPUT_t. \n
 844:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				 \b Range: @ref XMC_USIC_CH_INPUT_DX0 to @ref XMC_USIC_CH_INPUT_DX5
 845:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @return None
 846:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
 847:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Description</b><br>
 848:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Disables the input digital filter for USIC channel input data signal. \n\n
 849:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Input data signal from the selected multiplexer will not be digitally filtered.
 850:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
 851:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Related APIs:</b><BR>
 852:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * XMC_USIC_CH_EnableInputDigitalFilter()\n\n\n
 853:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
 854:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** __STATIC_INLINE void XMC_USIC_CH_DisableInputDigitalFilter(XMC_USIC_CH_t *const channel, const XMC_
 855:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
 856:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   channel->DXCR[input] &=(uint32_t)~USIC_CH_DXCR_DFEN_Msk;
 857:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** }
 858:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
 859:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param  channel Pointer to USIC channel handler of type @ref XMC_USIC_CH_t \n
 860:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				   \b Range: @ref XMC_USIC0_CH0, @ref XMC_USIC0_CH1 to @ref XMC_USIC2_CH1 based on device su
 861:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param  input USIC channel input stage of type @ref XMC_USIC_CH_INPUT_t. \n
 862:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				 \b Range: @ref XMC_USIC_CH_INPUT_DX0 to @ref XMC_USIC_CH_INPUT_DX5
 863:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @return None
 864:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
 865:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Description</b><br>
 866:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Enables input synchronization for the USIC channel input data signal. \n\n
 867:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Input data signal from the selected multiplexer will be synchronized with fPERIPH.
 868:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * A noisy signal can be synchronized and filtered by enabling the digital filter.
 869:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
 870:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Related APIs:</b><BR>
 871:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * XMC_USIC_CH_DisableInputSync(), XMC_USIC_CH_EnableInputDigitalFilter()\n\n\n
 872:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
 873:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** __STATIC_INLINE void XMC_USIC_CH_EnableInputSync(XMC_USIC_CH_t *const channel, const XMC_USIC_CH_IN
 874:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
 875:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   channel->DXCR[input] |=(uint32_t)USIC_CH_DXCR_DSEN_Msk;
 876:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** }
 877:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
 878:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param  channel Pointer to USIC channel handler of type @ref XMC_USIC_CH_t \n
 879:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				   \b Range: @ref XMC_USIC0_CH0, @ref XMC_USIC0_CH1 to @ref XMC_USIC2_CH1 based on device su
 880:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param  input USIC channel input stage of type @ref XMC_USIC_CH_INPUT_t. \n
 881:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				 \b Range: @ref XMC_USIC_CH_INPUT_DX0 to @ref XMC_USIC_CH_INPUT_DX5
 882:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @return None
 883:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
 884:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Description</b><br>
 885:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Disables input synchronization for the USIC channel input data signal. \n\n
 886:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Input data signal from the selected multiplexer will not be synchronized.
 887:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
 888:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Related APIs:</b><BR>
 889:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * XMC_USIC_CH_EnableInputSync(), XMC_USIC_CH_DisableInputDigitalFilter() \n\n\n
 890:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
 891:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** __STATIC_INLINE void XMC_USIC_CH_DisableInputSync(XMC_USIC_CH_t *const channel, const XMC_USIC_CH_I
 892:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
 893:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   channel->DXCR[input] &=(uint32_t)~USIC_CH_DXCR_DSEN_Msk;
 894:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** }
 895:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
 896:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param  channel Pointer to USIC channel handler of type @ref XMC_USIC_CH_t \n
 897:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				   \b Range: @ref XMC_USIC0_CH0, @ref XMC_USIC0_CH1 to @ref XMC_USIC2_CH1 based on device su
 898:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param  input USIC channel input stage of type @ref XMC_USIC_CH_INPUT_t. \n
 899:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				 \b Range: @ref XMC_USIC_CH_INPUT_DX0 to @ref XMC_USIC_CH_INPUT_DX5
 900:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param  sampling_freq Sampling frequency value of type \a XMC_USIC_CH_INPUT_SAMPLING_FREQ_t.
 901:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @return None
 902:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
 903:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Description</b><br>
 904:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Sets sampling frequency for USIC channel input data signal. \n\n
 905:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
 906:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Related APIs:</b><BR>
 907:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * XMC_USIC_CH_SetInputSource(), XMC_USIC_CH_EnableInputSync(), XMC_USIC_CH_EnableInputDigitalFilte
 908:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
 909:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** __STATIC_INLINE void XMC_USIC_CH_SetInputSamplingFreq(XMC_USIC_CH_t *const channel,
 910:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 		                                              const XMC_USIC_CH_INPUT_t input,
 911:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 		                                              const XMC_USIC_CH_INPUT_SAMPLING_FREQ_t sampling_fr
 912:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
 913:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   channel->DXCR[input] = (uint32_t)(channel->DXCR[input] & (~USIC_CH_DXCR_SFSEL_Msk)) |
 914:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****                          ((uint32_t)sampling_freq);
 915:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** }
 916:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
 917:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
 918:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param  channel Pointer to USIC channel handler of type @ref XMC_USIC_CH_t \n
 919:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				   \b Range: @ref XMC_USIC0_CH0, @ref XMC_USIC0_CH1 to @ref XMC_USIC2_CH1 based on device su
 920:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param  input USIC channel input stage of type @ref XMC_USIC_CH_INPUT_t. \n
 921:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				 \b Range: @ref XMC_USIC_CH_INPUT_DX0 to @ref XMC_USIC_CH_INPUT_DX5
 922:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param  combination_mode Combination mode value of type \a XMC_USIC_CH_INPUT_COMBINATION_MODE_t.
 923:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @return None
 924:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
 925:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Description</b><br>
 926:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Selects which edge of the synchronized signal DXnS activates the trigger output DXnT of the inpu
 927:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
 928:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Related APIs:</b><BR>
 929:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * XMC_USIC_CH_SetInputSource(), XMC_USIC_CH_EnableInputSync(), XMC_USIC_CH_EnableInputDigitalFilte
 930:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
 931:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** __STATIC_INLINE void XMC_USIC_CH_SetInputTriggerCombinationMode(XMC_USIC_CH_t *const channel,
 932:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 		                                                        const XMC_USIC_CH_INPUT_t input,
 933:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 		                                                        const XMC_USIC_CH_INPUT_COMBINATION_MODE_
 934:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
 935:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   channel->DXCR[input] = (uint32_t)(channel->DXCR[input] & (~USIC_CH_DXCR_CM_Msk)) |
 936:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****                          ((uint32_t)combination_mode << USIC_CH_DXCR_CM_Pos);
 937:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** }
 938:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
 939:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
 940:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param  channel Pointer to USIC channel handler of type @ref XMC_USIC_CH_t \n
 941:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				   \b Range: @ref XMC_USIC0_CH0, @ref XMC_USIC0_CH1 to @ref XMC_USIC2_CH1 based on device su
 942:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param  clock_source clock source for the BRG.
 943:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @return None
 944:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
 945:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Description</b><br>
 946:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Sets the clock source for the BRG. \n\n
 947:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
 948:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Related APIs:</b><BR>
 949:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * XMC_USIC_CH_SetInputTriggerCombinationMode(), XMC_USIC_CH_SetExternalClockBRGDivider()\n\n\n
 950:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
 951:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** __STATIC_INLINE void XMC_USIC_CH_SetBRGInputClockSource(XMC_USIC_CH_t *const channel, const XMC_USI
 952:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
 953:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   channel->BRG = (uint32_t)(channel->BRG & (~USIC_CH_BRG_CLKSEL_Msk)) | (uint32_t)(clock_source);
 954:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** }
 955:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
 956:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
 957:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param channel Pointer to USIC channel handler of type @ref XMC_USIC_CH_t \n
 958:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				   \b Range: @ref XMC_USIC0_CH0, @ref XMC_USIC0_CH1 to @ref XMC_USIC2_CH1 based on device su
 959:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param data Data to be transmitted. \n
 960:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *           \b Range: 16bit unsigned data. minimum= 0, maximum= 65535
 961:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @return None
 962:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
 963:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Description</b><br>
 964:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Writes data into the transmit buffer. \n\n
 965:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * The data provided is placed in TBUF[0U].
 966:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
 967:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
 968:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Related APIs:</b><BR>
 969:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * XMC_USIC_CH_WriteToTBUFTCI() \n\n\n
 970:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
 971:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** __STATIC_INLINE void XMC_USIC_CH_WriteToTBUF(XMC_USIC_CH_t *const channel, const uint16_t data)
 972:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
 973:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   channel->TBUF[0U] = data;
 974:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** }
 975:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
 976:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
 977:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param channel Pointer to USIC channel handler of type @ref XMC_USIC_CH_t \n
 978:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				   \b Range: @ref XMC_USIC0_CH0, @ref XMC_USIC0_CH1 to @ref XMC_USIC2_CH1 based on device su
 979:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param data Data to be transmitted.
 980:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param transmit_control_information transmit control information to be configured while transmit
 981:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 			\b Range: minimum= 0, maximum= 31.
 982:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @return None
 983:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
 984:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Description</b><br>
 985:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Writes data to the transmit buffer in a control mode. \n\n
 986:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * When the respective control mode is enabled , this API can be used.
 987:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
 988:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
 989:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Related APIs:</b><BR>
 990:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * XMC_USIC_CH_WriteToTBUF() \n\n\n
 991:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
 992:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** __STATIC_INLINE void XMC_USIC_CH_WriteToTBUFTCI(XMC_USIC_CH_t *const channel,
 993:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****                                              const uint16_t data,
 994:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****                                              const uint32_t transmit_control_information)
 995:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
 996:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   channel->TBUF[transmit_control_information] = data;
 997:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** }
 998:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
 999:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
1000:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param  channel Pointer to USIC channel handler of type @ref XMC_USIC_CH_t \n
1001:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				   \b Range: @ref XMC_USIC0_CH0, @ref XMC_USIC0_CH1 to @ref XMC_USIC2_CH1 based on device su
1002:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param  word_length Number of bits to be configured for a data word. \n
1003:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 					   \b Range: minimum= 1, maximum= 16. \n
1004:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 					   e.g: For word length of 8, \a word_length should be provided as 8.
1005:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @return None
1006:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
1007:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Description</b><br>
1008:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Sets the data word length in number of bits. \n\n
1009:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Sets the number of bits to represent a data word. Frame length should be a multiple of word leng
1010:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
1011:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Related APIs:</b><BR>
1012:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * XMC_USIC_CH_SetFrameLength()\n\n\n
1013:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
1014:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** __STATIC_INLINE void XMC_USIC_CH_SetWordLength(XMC_USIC_CH_t *const channel, const uint8_t word_len
1015:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
1016:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   channel->SCTR = (uint32_t)(channel->SCTR & (~USIC_CH_SCTR_WLE_Msk)) |
1017:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****                   (uint32_t)(((uint32_t)word_length - 1UL)  << USIC_CH_SCTR_WLE_Pos);
1018:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** }
1019:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
1020:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
1021:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param  channel Pointer to USIC channel handler of type @ref XMC_USIC_CH_t \n
1022:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *           \b Range: @ref XMC_USIC0_CH0, @ref XMC_USIC0_CH1 to @ref XMC_USIC2_CH1 based on device
1023:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param  word_length Number of bits to be configured for a data word. \n
1024:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *             \b Range: minimum= 1, maximum= 16. \n
1025:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *             e.g: For word length of 8, \a word_length should be provided as 8.
1026:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @return None
1027:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
1028:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Description</b><br>
1029:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Sets the data word length in number of bits. \n\n
1030:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Sets the number of bits to represent a data word. Frame length should be a multiple of word leng
1031:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
1032:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Related APIs:</b><BR>
1033:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * XMC_USIC_CH_SetFrameLength()\n\n\n
1034:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
1035:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** __STATIC_INLINE void XMC_USIC_CH_SetShiftDirection(XMC_USIC_CH_t *const channel, const XMC_USIC_CH_
1036:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
1037:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   channel->SCTR = (uint32_t)(channel->SCTR & (~USIC_CH_SCTR_SDIR_Msk)) | (uint32_t)shift_direction;
1038:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** }
1039:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
1040:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
1041:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
1042:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param  channel Pointer to USIC channel handler of type @ref XMC_USIC_CH_t \n
1043:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *           \b Range: @ref XMC_USIC0_CH0, @ref XMC_USIC0_CH1 to @ref XMC_USIC2_CH1 based on device
1044:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @return Captured counter value 
1045:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
1046:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
1047:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Description</b><br>
1048:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * The value of the counter is captured if one of the trigger signals DX0T or DX1T are activated by
1049:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
1050:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** __STATIC_INLINE uint32_t XMC_USIC_CH_GetCaptureTimerValue(const XMC_USIC_CH_t *const channel)
1051:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
1052:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   return channel->CMTR;
1053:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** }
1054:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
1055:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
1056:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param  channel Pointer to USIC channel handler of type @ref XMC_USIC_CH_t \n
1057:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *           \b Range: @ref XMC_USIC0_CH0, @ref XMC_USIC0_CH1 to @ref XMC_USIC2_CH1 based on device
1058:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param  mode divider mode ::XMC_USIC_CH_BRG_CLOCK_DIVIDER_MODE_t \n
1059:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param  step divider \n
1060:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *             \b XMC_USIC_CH_BRG_CLOCK_DIVIDER_MODE_NORMAL resulting divider = 1023 - step \n
1061:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *             \b XMC_USIC_CH_BRG_CLOCK_DIVIDER_MODE_FRACTIONAL resulting divider = 1023 / step \n
1062:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 
1063:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @return None
1064:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 
1065:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Description</b><br>
1066:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * The fractional divider generates its output frequency fFD by either dividing the input frequency
1067:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
1068:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
1069:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** __STATIC_INLINE void XMC_USIC_CH_SetFractionalDivider(XMC_USIC_CH_t *const channel, const XMC_USIC_
1070:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
1071:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   channel->FDR = mode | step;
1072:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** }
1073:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
1074:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
1075:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param  channel Pointer to USIC channel handler of type @ref XMC_USIC_CH_t \n
1076:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				   \b Range: @ref XMC_USIC0_CH0, @ref XMC_USIC0_CH1 to @ref XMC_USIC2_CH1 based on device su
1077:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param  frame_length Number of bits in a frame. \n
1078:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 						\b Range: minimum= 1, maximum= 0x3f. The maximum value for fixed frame size is 0x3f. \n
1079:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 						e.g: For a frame length of 16, \a frame_length should be provided as 16.
1080:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @return None
1081:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
1082:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Description</b><br>
1083:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Define the data frame length.\n\n
1084:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Set the number of bits to be serially transmitted in a frame.
1085:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * The frame length should be multiples of word length. If the value is set to 0x40, the frame leng
1086:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * has to be controlled explicitly. 
1087:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
1088:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Related APIs:</b><BR>
1089:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * XMC_USIC_CH_SetWordLength(), XMC_USIC_CH_EnableFrameLengthControl() \n\n\n
1090:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
1091:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** __STATIC_INLINE void XMC_USIC_CH_SetFrameLength(XMC_USIC_CH_t *const channel, const uint8_t frame_l
1092:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
1093:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   channel->SCTR = (uint32_t)(channel->SCTR & (~USIC_CH_SCTR_FLE_Msk)) |
1094:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****                   (((uint32_t)frame_length - 0x1U)  << USIC_CH_SCTR_FLE_Pos);
1095:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** }
1096:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
1097:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
1098:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param channel Pointer to USIC channel handler of type @ref XMC_USIC_CH_t \n
1099:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				   \b Range: @ref XMC_USIC0_CH0, @ref XMC_USIC0_CH1 to @ref XMC_USIC2_CH1 based on device su
1100:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param event Bit mask of the channel events to be enabled. Use @ref XMC_USIC_CH_EVENT_t for the 
1101:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				\b Range: @ref XMC_USIC_CH_EVENT_RECEIVE_START, @ref XMC_USIC_CH_EVENT_DATA_LOST etc. Multip
1102:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				can be combined using \a OR operation.
1103:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @return None
1104:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
1105:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Description</b><br>
1106:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Enable the channel interrupt events.\n\n
1107:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Common channel events related to serial communication can be configured using this API.
1108:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Multiple events can be combined using the bitwise OR operation and configured in one function ca
1109:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * XMC_USIC_CH_EVENT_t enumerates multiple protocol event bitmasks. These enumerations can be used 
1110:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
1111:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Related APIs:</b><BR>
1112:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * XMC_USIC_CH_DisableEvent(), XMC_USIC_CH_SetInterruptNodePointer() \n\n\n
1113:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
1114:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** __STATIC_INLINE void XMC_USIC_CH_EnableEvent(XMC_USIC_CH_t *const channel, const uint32_t event)
1115:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
1116:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   channel->CCR |= event;
1117:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** }
1118:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
1119:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
1120:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param channel Pointer to USIC channel handler of type @ref XMC_USIC_CH_t \n
1121:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				  \b Range: @ref XMC_USIC0_CH0, @ref XMC_USIC0_CH1 to @ref XMC_USIC2_CH1 based on device sup
1122:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param event Bit mask of the channel events to be disabled. Use @ref XMC_USIC_CH_EVENT_t for the
1123:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				\b Range: @ref XMC_USIC_CH_EVENT_RECEIVE_START, @ref XMC_USIC_CH_EVENT_DATA_LOST etc. Multip
1124:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				can be combined using \a OR operation.
1125:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @return None
1126:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
1127:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Description</b><br>
1128:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Disable the channel interrupt events. \n\n
1129:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Multiple events can be combined using the bitwise OR operation and configured in one function ca
1130:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * XMC_USIC_CH_EVENT_t enumerates multiple protocol event bitmasks. These enumerations can be used 
1131:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
1132:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Related APIs:</b><BR>
1133:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * XMC_USIC_CH_EnableEvent(), XMC_USIC_CH_SetInterruptNodePointer() \n\n\n
1134:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** */
1135:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** __STATIC_INLINE void XMC_USIC_CH_DisableEvent(XMC_USIC_CH_t *const channel, const uint32_t event)
1136:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
1137:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   channel->CCR &= (uint32_t)~event;
1138:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** }
1139:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
1140:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
1141:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param channel Pointer to USIC channel handler of type @ref XMC_USIC_CH_t \n
1142:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				  \b Range: @ref XMC_USIC0_CH0, @ref XMC_USIC0_CH1 to @ref XMC_USIC2_CH1 based on device sup
1143:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param  interrupt_node Interrupt node pointer to be configured. \n
1144:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 						  \b Range: @ref XMC_USIC_CH_INTERRUPT_NODE_POINTER_TRANSMIT_SHIFT,
1145:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 						  			@ref XMC_USIC_CH_INTERRUPT_NODE_POINTER_TRANSMIT_BUFFER etc.
1146:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param service_request Service request number.\n
1147:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 						  \b Range: 0 to 5.
1148:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @return None
1149:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
1150:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Description</b><br>
1151:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Sets the interrupt node for USIC channel events. \n\n
1152:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * For an event to generate interrupt, node pointer should be configured with service request(SR0, 
1153:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * The NVIC node gets linked to the interrupt event by doing so.<br>
1154:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Note: NVIC node should be separately enabled to generate the interrupt.
1155:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
1156:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Related APIs:</b><BR>
1157:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * XMC_USIC_CH_EnableEvent() \n\n\n
1158:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
1159:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** void XMC_USIC_CH_SetInterruptNodePointer(XMC_USIC_CH_t *const channel,
1160:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****                                          const XMC_USIC_CH_INTERRUPT_NODE_POINTER_t interrupt_node,
1161:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****                                          const uint32_t service_request);
1162:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
1163:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
1164:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param  channel Pointer to USIC channel handler of type @ref XMC_USIC_CH_t \n
1165:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				   \b Range: @ref XMC_USIC0_CH0, @ref XMC_USIC0_CH1 to @ref XMC_USIC2_CH1 based on device su
1166:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @return Stataus @ref XMC_USIC_CH_TBUF_STATUS_IDLE if transmit buffer is free,
1167:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *                 @ref XMC_USIC_CH_TBUF_STATUS_BUSY if transmit buffer is busy.
1168:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
1169:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Description</b><br>
1170:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Gets transmit buffer status. \n\n
1171:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Status indicates whether the transmit buffer is free, or busy transmitting data.
1172:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * The status depends on the value of TDV flag in TCSR register.
1173:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * This status can be used while transmitting data. Transmit data when the transmit buffer
1174:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * status is @ref XMC_USIC_CH_TBUF_STATUS_IDLE.
1175:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
1176:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Related APIs:</b><BR>
1177:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * XMC_USIC_CH_SetDataOutputMode() \n\n\n
1178:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
1179:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** __STATIC_INLINE XMC_USIC_CH_TBUF_STATUS_t XMC_USIC_CH_GetTransmitBufferStatus(XMC_USIC_CH_t *const 
1180:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
1181:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   return (XMC_USIC_CH_TBUF_STATUS_t)(channel->TCSR & USIC_CH_TCSR_TDV_Msk);
1182:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** }
1183:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
1184:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
1185:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @brief API to get receive buffer status
1186:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param  channel Pointer to USIC channel handler of type @ref XMC_USIC_CH_t \n
1187:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				   \b Range: @ref XMC_USIC0_CH0, @ref XMC_USIC0_CH1 to @ref XMC_USIC2_CH1 based on device su
1188:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @return Status of data validity check for RBUF0 and RBUF1. \n
1189:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 		   Returned value should be masked with RDV0 and RDV1 bits to know the status. \n
1190:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 		   \b Range: @ref XMC_USIC_CH_RBUF_STATUS_DATA_VALID0, @ref XMC_USIC_CH_RBUF_STATUS_DATA_VALID
1191:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
1192:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Description</b><br>
1193:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Checks if RBUF0 and RBUF1 have valid unread data. \n\n
1194:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * It checks the bits RDV0 and RDV1 of the RBUFSR register.
1195:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Returns the value of RBUFSR masked with bitmasks of RDV0 and RDV1.
1196:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * It can be used to decide whether 2bytes has to be read from RBUF or 1 byte. 
1197:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * If both bitmasks XMC_USIC_CH_RBUF_STATUS_DATA_VALID0 and XMC_USIC_CH_RBUF_STATUS_DATA_VALID1
1198:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * are set, then 2 bytes can be read from RBUF. If only either of them is set, then only one byte
1199:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * can be read from RBUF.
1200:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Related APIs:</b><BR>
1201:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * XMC_USIC_CH_GetTransmitBufferStatus() \n\n\n
1202:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
1203:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** __STATIC_INLINE uint32_t XMC_USIC_CH_GetReceiveBufferStatus(XMC_USIC_CH_t *const channel)
1204:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
1205:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   return ((uint32_t) (channel->RBUFSR & (USIC_CH_RBUFSR_RDV0_Msk | USIC_CH_RBUFSR_RDV1_Msk)));
1206:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** }
1207:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
1208:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
1209:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
1210:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param  channel Pointer to USIC channel handler of type @ref XMC_USIC_CH_t \n
1211:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				   \b Range: @ref XMC_USIC0_CH0, @ref XMC_USIC0_CH1 to @ref XMC_USIC2_CH1 based on device su
1212:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param  start_transmision_mode Transmission mode to be enabled. \n
1213:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 								\b Range: @ref XMC_USIC_CH_START_TRANSMISION_DISABLED,
1214:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 								@ref XMC_USIC_CH_START_TRANSMISION_ON_TDV, @ref XMC_USIC_CH_START_TRANSMISION_ON_TDV_DX2
1215:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 								@ref XMC_USIC_CH_START_TRANSMISION_ON_TDV_DX2S_1
1216:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *                              
1217:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @return None
1218:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
1219:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Description</b><br>
1220:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Configures data transmission. \n\n
1221:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * The configuration affects the data shifted on the DOUT0 pin.
1222:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 
1223:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Related APIs:</b><BR>
1224:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * XMC_USIC_CH_GetTransmitBufferStatus(), XMC_USIC_CH_SetDataOutputMode() \n\n\n
1225:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
1226:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** __STATIC_INLINE void XMC_USIC_CH_SetStartTransmisionMode(XMC_USIC_CH_t *const channel,
1227:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****                                                          const XMC_USIC_CH_START_TRANSMISION_MODE_t
1228:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
1229:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   channel->TCSR = (uint32_t)(channel->TCSR & (~USIC_CH_TCSR_TDEN_Msk)) | (uint32_t)start_transmisio
1230:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** }
1231:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
1232:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
1233:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
1234:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param  channel Pointer to USIC channel handler of type @ref XMC_USIC_CH_t \n
1235:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				   \b Range: @ref XMC_USIC0_CH0, @ref XMC_USIC0_CH1 to @ref XMC_USIC2_CH1 based on device su
1236:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param  data_output_mode  Data output mode. \n
1237:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 			\b Range: @ref XMC_USIC_CH_DATA_OUTPUT_MODE_NORMAL, @ref XMC_USIC_CH_DATA_OUTPUT_MODE_INVERTE
1238:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @return None
1239:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
1240:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Description</b><br>
1241:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Configures the mode for data output. \n\n
1242:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * USIC channel can be configured to shift inverted data or direct data based on the input to the A
1243:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 
1244:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Related APIs:</b><BR>
1245:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * XMC_USIC_CH_SetStartTransmisionMode() \n\n\n
1246:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
1247:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** __STATIC_INLINE void XMC_USIC_CH_SetDataOutputMode(XMC_USIC_CH_t *const channel,
1248:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****                                                    const XMC_USIC_CH_DATA_OUTPUT_MODE_t data_output
1249:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
1250:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   channel->SCTR = (uint32_t)(channel->SCTR & (~USIC_CH_SCTR_DOCFG_Msk)) | (uint32_t)data_output_mod
1251:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** }
1252:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
1253:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
1254:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param  channel Pointer to USIC channel handler of type @ref XMC_USIC_CH_t \n
1255:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				   \b Range: @ref XMC_USIC0_CH0, @ref XMC_USIC0_CH1 to @ref XMC_USIC2_CH1 based on device su
1256:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @return None
1257:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
1258:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Description</b><br>
1259:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Enables automatic update of frame length. \n\n
1260:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * When the automatic update of frame length is enabled, frame length is configured based on the 
1261:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * index of the TBUF[]/IN[] register array. When the data is written to TBUF[x], frame length is co
1262:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * with the mask value of \a x at the last 5 bit positions. Same logic is applicable if data is wri
1263:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * IN[x] register.
1264:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
1265:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Related APIs:</b><BR>
1266:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * XMC_USIC_CH_DisableFrameLengthControl(), XMC_USIC_CH_TXFIFO_PutDataFLEMode() \n\n\n
1267:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
1268:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** __STATIC_INLINE void XMC_USIC_CH_EnableFrameLengthControl(XMC_USIC_CH_t *const channel)
1269:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
1270:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   channel->TCSR = (uint32_t)(channel->TCSR & (~(USIC_CH_TCSR_WLEMD_Msk |
1271:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****                                          USIC_CH_TCSR_SELMD_Msk |
1272:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****                                          USIC_CH_TCSR_WAMD_Msk |
1273:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****                                          USIC_CH_TCSR_HPCMD_Msk))) |
1274:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****                                          (uint32_t)USIC_CH_TCSR_FLEMD_Msk;
1275:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** }
1276:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
1277:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
1278:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param  channel Pointer to USIC channel handler of type @ref XMC_USIC_CH_t \n
1279:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				   \b Range: @ref XMC_USIC0_CH0, @ref XMC_USIC0_CH1 to @ref XMC_USIC2_CH1 based on device su
1280:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @return None
1281:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
1282:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Description</b><br>
1283:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Disables automatic update of frame length. \n\n
1284:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * When automatic update of frame length is disabled, frame length has to configured explicitly.
1285:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Frame length remains fixed until it is changed again.
1286:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
1287:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Related APIs:</b><BR>
1288:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * XMC_USIC_CH_DisableFrameLengthControl(), XMC_USIC_CH_SetFrameLength() \n\n\n
1289:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
1290:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** __STATIC_INLINE void XMC_USIC_CH_DisableFrameLengthControl(XMC_USIC_CH_t *const channel)
1291:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
1292:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   channel->TCSR &= (uint32_t)~USIC_CH_TCSR_FLEMD_Msk;
1293:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** }
1294:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
1295:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
1296:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param  channel Pointer to USIC channel handler of type @ref XMC_USIC_CH_t \n
1297:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				   \b Range: @ref XMC_USIC0_CH0, @ref XMC_USIC0_CH1 to @ref XMC_USIC2_CH1 based on device su
1298:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @return None
1299:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
1300:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Description</b><br>
1301:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Bit TCSR.TE is set if DX2T becomes active while TDV = 1. \n\n
1302:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Enables the transfer trigger unit to set bit TCSR.TE if the trigger signal DX2T becomes active
1303:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * for event driven transfer starts.
1304:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
1305:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Related APIs:</b><BR>
1306:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * XMC_USIC_CH_DisableTBUFDataValidTrigger()\n\n\n
1307:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
1308:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** __STATIC_INLINE void XMC_USIC_CH_EnableTBUFDataValidTrigger(XMC_USIC_CH_t *const channel)
1309:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
1310:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   channel->TCSR |= (uint32_t)USIC_CH_TCSR_TDVTR_Msk;
1311:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** }
1312:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
1313:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
1314:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param  channel Pointer to USIC channel handler of type @ref XMC_USIC_CH_t \n
1315:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				   \b Range: @ref XMC_USIC0_CH0, @ref XMC_USIC0_CH1 to @ref XMC_USIC2_CH1 based on device su
1316:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @return None
1317:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
1318:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Description</b><br>
1319:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Disables the trigger of TDV depending on DX2T signal. \n\n
1320:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Bit TCSR.TE is permanently set.
1321:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
1322:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Related APIs:</b><BR>
1323:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * XMC_USIC_CH_EnableTBUFDataValidTrigger() \n\n\n
1324:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
1325:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** __STATIC_INLINE void XMC_USIC_CH_DisableTBUFDataValidTrigger(XMC_USIC_CH_t *const channel)
1326:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
1327:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   channel->TCSR &= (uint32_t)~USIC_CH_TCSR_TDVTR_Msk;
1328:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** }
1329:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
1330:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
1331:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param  channel Pointer to USIC channel handler of type @ref XMC_USIC_CH_t \n
1332:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				   \b Range: @ref XMC_USIC0_CH0, @ref XMC_USIC0_CH1 to @ref XMC_USIC2_CH1 based on device su
1333:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param  service_request_line service request number of the event to be triggered. \n
1334:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 			\b Range: 0 to 5.
1335:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @return None
1336:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
1337:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Description</b><br>
1338:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Trigger a USIC interrupt service request.\n\n
1339:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * When the USIC service request is triggered, the NVIC interrupt associated with it will be 
1340:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * generated if enabled. 
1341:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
1342:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Related APIs:</b><BR>
1343:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * XMC_USIC_CH_SetInterruptNodePointer() \n\n\n
1344:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
1345:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** __STATIC_INLINE void XMC_USIC_CH_TriggerServiceRequest(XMC_USIC_CH_t *const channel, const uint32_t
1346:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
1347:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   channel->FMR = (uint32_t)(USIC_CH_FMR_SIO0_Msk << service_request_line);
1348:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** }
1349:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
1350:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
1351:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param  channel Pointer to USIC channel handler of type @ref XMC_USIC_CH_t \n
1352:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				   \b Range: @ref XMC_USIC0_CH0, @ref XMC_USIC0_CH1 to @ref XMC_USIC2_CH1 based on device su
1353:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param  transmit_buffer_status clearing or setting the TDV flag. \n
1354:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
1355:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @return None
1356:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
1357:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Description</b><br>
1358:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Modify TCSR.TDV and TCSR.TE to control the start of a data word transmission by software.
1359:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
1360:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Related APIs:</b><BR>
1361:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * XMC_USIC_CH_GetTransmitBufferStatus() \n\n\n
1362:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
1363:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** __STATIC_INLINE void XMC_USIC_CH_SetTransmitBufferStatus(XMC_USIC_CH_t *const channel,
1364:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 		                                                 const XMC_USIC_CH_TBUF_STATUS_SET_t transmit_buf
1365:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
1366:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   channel->FMR = (uint32_t)transmit_buffer_status;
1367:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** }
1368:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
1369:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
1370:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param  channel Pointer to USIC channel handler of type @ref XMC_USIC_CH_t \n
1371:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				   \b Range: @ref XMC_USIC0_CH0, @ref XMC_USIC0_CH1 to @ref XMC_USIC2_CH1 based on device su
1372:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param  passive_level Value of passive level for the channel. \n
1373:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 			\b Range: @ref XMC_USIC_CH_PASSIVE_DATA_LEVEL0, @ref XMC_USIC_CH_PASSIVE_DATA_LEVEL1
1374:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @return None
1375:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
1376:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Description</b><br>
1377:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Set the passive data level of the output signal. \n\n
1378:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * When the USIC channel transmit stage is idle, the output signal level stays at the 
1379:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * configured passive level.
1380:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 
1381:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Related APIs:</b><BR>
1382:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * XMC_USIC_CH_GetTransmitBufferStatus(), XMC_USIC_CH_SetStartTransmisionMode() \n\n\n
1383:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
1384:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** __STATIC_INLINE void XMC_USIC_CH_SetPassiveDataLevel(XMC_USIC_CH_t *const channel,
1385:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****                                                      const XMC_USIC_CH_PASSIVE_DATA_LEVEL_t passive
1386:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
1387:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   channel->SCTR &= (~USIC_CH_SCTR_PDL_Msk);
1388:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   channel->SCTR |= (uint32_t)passive_level;
1389:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** }
1390:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
1391:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /* TX FIFO APIs */
1392:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
1393:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param channel Pointer to USIC channel handler of type @ref XMC_USIC_CH_t \n
1394:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				   \b Range: @ref XMC_USIC0_CH0, @ref XMC_USIC0_CH1 to @ref XMC_USIC2_CH1 based on device su
1395:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param data_pointer Start position inside the FIFO buffer. \n
1396:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 		\b Range: 0 to 63.
1397:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param size Required size of the transmit FIFO. \n
1398:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 		\b Range: @ref XMC_USIC_CH_FIFO_DISABLED, @ref XMC_USIC_CH_FIFO_SIZE_2WORDS.. @ref XMC_USIC_CH
1399:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param limit Threshold of transmit FIFO filling level to be considered for generating events. \n
1400:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 		\b Range: 0 to \a size -1.
1401:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @return None
1402:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
1403:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Description</b><br>
1404:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Initializes the transmit FIFO. \n\n
1405:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Transmit FIFO is a subset of a common FIFO sized 64 words. This FIFO is shared between 2 channel
1406:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Each channel can share the FIFO for transmission and reception. \a data_pointer represents the s
1407:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * from where transmit data can be put, for the selected USIC channel. \a size represents the size 
1408:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 2. Since the FIFO is shared between 2 USIC channels, FIFO size should be carefully selected. A F
1409:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * event is generated when the FIFO filling level falls below the \a limit value.
1410:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
1411:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Related APIs:</b><BR>
1412:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * XMC_USIC_CH_TXFIFO_EnableEvent(), XMC_USIC_CH_TXFIFO_SetInterruptNodePointer() \n\n\n
1413:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
1414:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** void XMC_USIC_CH_TXFIFO_Configure(XMC_USIC_CH_t *const channel,
1415:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****                                   const uint32_t data_pointer,
1416:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****                                   const XMC_USIC_CH_FIFO_SIZE_t size,
1417:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****                                   const uint32_t limit);
1418:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
1419:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
1420:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param channel Pointer to USIC channel handler of type @ref XMC_USIC_CH_t \n
1421:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				   \b Range: @ref XMC_USIC0_CH0, @ref XMC_USIC0_CH1 to @ref XMC_USIC2_CH1 based on device su
1422:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param size Required size of the transmit FIFO. \n
1423:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 		\b Range: @ref XMC_USIC_CH_FIFO_DISABLED, @ref XMC_USIC_CH_FIFO_SIZE_2WORDS.. @ref XMC_USIC_CH
1424:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param limit Threshold for transmit FIFO filling level to be considered for generating events. \
1425:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 		\b Range: 0 to \a size -1.
1426:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @return None
1427:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
1428:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Description</b><br>
1429:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Sets the size and trigger limit for the transmit FIFO. \n\n
1430:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * The API is not to be called for initializing the transmit FIFO. The API shall be used for the 
1431:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * runtime change of transmit FIFO trigger limit. FIFO start position will not be affected on execu
1432:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
1433:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Related APIs:</b><BR>
1434:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * XMC_USIC_CH_RXFIFO_SetSizeTriggerLimit() \n\n\n
1435:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
1436:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** void XMC_USIC_CH_TXFIFO_SetSizeTriggerLimit(XMC_USIC_CH_t *const channel,
1437:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****                                             const XMC_USIC_CH_FIFO_SIZE_t size,
1438:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****                                             const uint32_t limit);
1439:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
1440:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
1441:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
1442:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param channel Pointer to USIC channel handler of type @ref XMC_USIC_CH_t \n
1443:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				   \b Range: @ref XMC_USIC0_CH0, @ref XMC_USIC0_CH1 to @ref XMC_USIC2_CH1 based on device su
1444:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param event Events to be enabled. Multiple events can be bitwise OR combined. @ref XMC_USIC_CH_
1445:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @return None
1446:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
1447:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Description</b><br>
1448:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Enables the interrupt events related to transmit FIFO. \n\n
1449:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Event bitmasks can be constructed using the enumeration @ref XMC_USIC_CH_TXFIFO_EVENT_CONF_t.
1450:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Multiple events can be enabled by providing multiple events in a single call. For providing 
1451:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * multiple events, combine the events using bitwise OR operation. Events are configured in the TBC
1452:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 
1453:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Note: API only enables the events. For interrupt generation, interrupt node must be configured a
1454:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * must be enabled.
1455:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
1456:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Related APIs:</b><BR>
1457:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * XMC_USIC_CH_TXFIFO_SetInterruptNodePointer() \n\n\n
1458:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
1459:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** __STATIC_INLINE void XMC_USIC_CH_TXFIFO_EnableEvent(XMC_USIC_CH_t *const channel, const uint32_t ev
1460:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
1461:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   channel->TBCTR |= event;
1462:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** }
1463:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
1464:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
1465:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
1466:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param channel Pointer to USIC channel handler of type @ref XMC_USIC_CH_t \n
1467:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				   \b Range: @ref XMC_USIC0_CH0, @ref XMC_USIC0_CH1 to @ref XMC_USIC2_CH1 based on device su
1468:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param event Events to be disabled. @ref XMC_USIC_CH_TXFIFO_EVENT_CONF_t \n
1469:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @return None
1470:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
1471:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Description</b><br>
1472:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Disables the interrupt events related to transmit FIFO. \n\n
1473:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * By disabling the interrupt events, generation of interrupt is stopped. User can poll the event 
1474:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * flags from the status register using the API XMC_USIC_CH_TXFIFO_GetEvent(). 
1475:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Event bitmasks can be constructed using the enumeration @ref XMC_USIC_CH_TXFIFO_EVENT_CONF_t. Fo
1476:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * multiple events, combine the events using bitwise OR operation.
1477:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
1478:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Related APIs:</b><BR>
1479:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * XMC_USIC_CH_TXFIFO_GetEvent(), XMC_USIC_CH_TXFIFO_EnableEvent() \n\n\n
1480:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
1481:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** __STATIC_INLINE void XMC_USIC_CH_TXFIFO_DisableEvent(XMC_USIC_CH_t *const channel, const uint32_t e
1482:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
1483:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   channel->TBCTR &= (uint32_t)~event;
1484:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** }
1485:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
1486:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
1487:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param channel Pointer to USIC channel handler of type @ref XMC_USIC_CH_t \n
1488:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				      \b Range: @ref XMC_USIC0_CH0, @ref XMC_USIC0_CH1 to @ref XMC_USIC2_CH1 based on device
1489:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param interrupt_node Node pointer representing the transmit FIFO events. \n
1490:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 						  \b Range: @ref XMC_USIC_CH_TXFIFO_INTERRUPT_NODE_POINTER_STANDARD,
1491:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 						  			@ref XMC_USIC_CH_TXFIFO_INTERRUPT_NODE_POINTER_ALTERNATE
1492:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param service_request The service request to be used for interrupt generation. \n
1493:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 						  \b Range: 0 to 5.
1494:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @return None
1495:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
1496:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Description</b><br>
1497:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Sets an interrupt node for the transmit FIFO events.\n\n
1498:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * A node pointer represents one or more interrupt events. Service request represents the interrupt
1499:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * among the 6 interrupt nodes available for USIC module.
1500:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * API configures the service request to be used for interrupt generation for the events selected.
1501:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * A transmit FIFO event can generate an interrupt only if the interrupt node is configured for the
1502:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * the interrupt generation is enabled for the event. For example, transmit FIFO standard transmit 
1503:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * interrupt is generated if the interrupt node for the same is set and interrupt is enabled.<br>
1504:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
1505:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Note: NVIC node should be explicitly enabled for the interrupt generation.
1506:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
1507:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Related APIs:</b><BR>
1508:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * XMC_USIC_CH_TXFIFO_EnableEvent() \n\n\n
1509:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
1510:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** void XMC_USIC_CH_TXFIFO_SetInterruptNodePointer(XMC_USIC_CH_t *const channel,
1511:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****                                                 const XMC_USIC_CH_TXFIFO_INTERRUPT_NODE_POINTER_t i
1512:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****                                                 const uint32_t service_request);
1513:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
1514:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
1515:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param channel Pointer to USIC channel handler of type @ref XMC_USIC_CH_t \n
1516:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				   \b Range: @ref XMC_USIC0_CH0, @ref XMC_USIC0_CH1 to @ref XMC_USIC2_CH1 based on device su
1517:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param data Data to be transmitted. \n
1518:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *           \b Range: 16bit unsigned data. minimum= 0, maximum= 65535
1519:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @return None
1520:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
1521:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Description</b><br>
1522:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Writes data into the transmit FIFO. \n\n
1523:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * The data provided is placed in the transmit FIFO.
1524:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * The transmit FIFO should be configured before calling this API.
1525:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
1526:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Related APIs:</b><BR>
1527:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * XMC_USIC_CH_TXFIFO_EnableEvent() \n\n\n
1528:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
1529:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** __STATIC_INLINE void XMC_USIC_CH_TXFIFO_PutData(XMC_USIC_CH_t *const channel, const uint16_t data)
1530:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
1531:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   channel->IN[0] = data;
1532:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** }
1533:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
1534:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
1535:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param channel Pointer to USIC channel handler of type @ref XMC_USIC_CH_t \n
1536:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				   \b Range: @ref XMC_USIC0_CH0, @ref XMC_USIC0_CH1 to @ref XMC_USIC2_CH1 based on device su
1537:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param data Data to be transmitted.
1538:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param frame_length Frame length to be configured while transmitting the data. \n
1539:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 			\b Range: minimum= 0, maximum= 31. e.g: For a frame length of 16, set \a frame_length as 15.
1540:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @return None
1541:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
1542:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Description</b><br>
1543:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Writes data to the transmit FIFO in frame length control mode. \n\n
1544:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * When frame length control is enabled for dynamic update of frame length, this API can be used.
1545:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \a frame_length represents the frame length to be updated by the peripheral. 
1546:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \a frame_length is used as index for the IN[] register array.
1547:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 
1548:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Related APIs:</b><BR>
1549:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * XMC_USIC_CH_EnableFrameLengthControl() \n\n\n
1550:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
1551:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** __STATIC_INLINE void XMC_USIC_CH_TXFIFO_PutDataFLEMode(XMC_USIC_CH_t *const channel,
1552:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****                                                        const uint16_t data,
1553:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****                                                        const uint32_t frame_length)
1554:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
1555:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   channel->IN[frame_length] = data;
1556:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** }
1557:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
1558:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
1559:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param channel Pointer to USIC channel handler of type @ref XMC_USIC_CH_t \n
1560:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				   \b Range: @ref XMC_USIC0_CH0, @ref XMC_USIC0_CH1 to @ref XMC_USIC2_CH1 based on device su
1561:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param data Data to be transmitted.
1562:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param frame_length Frame length to be configured while transmitting the data. \n
1563:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 			\b Range: minimum= 0, maximum= 31. e.g: For a frame length of 16, set \a frame_length as 15.
1564:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @return None
1565:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
1566:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Description</b><br>
1567:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Writes data to the transmit FIFO in hardware port control mode. \n\n
1568:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * When hardware port control is enabled for dynamic update of frame length, this API can be used.
1569:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \a frame_length represents the frame length to be updated by the peripheral. 
1570:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \a frame_length is used as index for the IN[] register array.
1571:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 
1572:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Related APIs:</b><BR>
1573:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * XMC_USIC_CH_EnableFrameLengthControl() \n\n\n
1574:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
1575:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** __STATIC_INLINE void XMC_USIC_CH_TXFIFO_PutDataHPCMode(XMC_USIC_CH_t *const channel,
1576:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****                                                        const uint16_t data,
1577:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****                                                        const uint32_t frame_length)
1578:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
1579:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   channel->IN[frame_length] = data;
1580:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** }
1581:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
1582:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
1583:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param channel Pointer to USIC channel handler of type @ref XMC_USIC_CH_t \n
1584:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				   \b Range: @ref XMC_USIC0_CH0, @ref XMC_USIC0_CH1 to @ref XMC_USIC2_CH1 based on device su
1585:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @return None
1586:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
1587:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Description</b><br>
1588:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Clears the contents of transmit FIFO. \n\n
1589:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Transmit FIFO contents will be cleared and the filling level will be reset to 0.
1590:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 
1591:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Related APIs:</b><BR>
1592:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * XMC_USIC_CH_TXFIFO_GetLevel() \n\n\n
1593:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
1594:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** __STATIC_INLINE void XMC_USIC_CH_TXFIFO_Flush(XMC_USIC_CH_t *const channel)
1595:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
1596:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   channel->TRBSCR = (uint32_t)USIC_CH_TRBSCR_FLUSHTB_Msk;
1597:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** }
1598:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
1599:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
1600:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param channel Pointer to USIC channel handler of type @ref XMC_USIC_CH_t \n
1601:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				   \b Range: @ref XMC_USIC0_CH0, @ref XMC_USIC0_CH1 to @ref XMC_USIC2_CH1 based on device su
1602:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @return Status \a true if transmit FIFO is full
1603:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *              \a false if transmit FIFO is not full.
1604:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
1605:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Description</b><br>
1606:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Checks if transmit FIFO is full. \n\n
1607:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * When the transmit FIFO filling level reaches the configured size, FIFO full flag is set.
1608:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * User should not write to the FIFO when the transmit FIFO is full.
1609:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 
1610:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Related APIs:</b><BR>
1611:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * XMC_USIC_CH_TXFIFO_IsEmpty(), XMC_USIC_CH_TXFIFO_Flush() \n\n\n
1612:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
1613:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** __STATIC_INLINE bool XMC_USIC_CH_TXFIFO_IsFull(XMC_USIC_CH_t *const channel)
1614:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
1615:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   return (bool)(channel->TRBSR & USIC_CH_TRBSR_TFULL_Msk);
 244              	 .loc 3 1615 0
 245 0056 D0F81431 	 ldr r3,[r0,#276]
 246              	.LBE245:
 247              	.LBE244:
 248              	.LBE243:
 249              	 .loc 1 1633 0
 250 005a DA04     	 lsls r2,r3,#19
 251 005c 11D4     	 bmi .L52
1634:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         {
1635:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           /* transmit each byte till index reaches to the last byte */
1636:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           if (buffer_index < size)
 252              	 .loc 1 1636 0
 253 005e A742     	 cmp r7,r4
 254 0060 33D9     	 bls .L53
 255 0062 09EB0406 	 add r6,r9,r4
 256 0066 01E0     	 b .L45
 257              	.LVL19:
 258              	.L42:
 259 0068 A742     	 cmp r7,r4
 260 006a 2ED9     	 bls .L53
 261              	.L45:
 262              	.LVL20:
 263              	.LBB248:
 264              	.LBB249:
 265              	 .file 4 "../BSP/dave_fixes/I2C_MASTER/i2c_master.h"
   1:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** /**
   2:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @file i2c_master.h
   3:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @date 2017-12-20
   4:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
   5:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * NOTE:
   6:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * This file is generated by DAVE. Any manual modification done to this file will be lost when the 
   7:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * regenerated.
   8:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  */
   9:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** /**
  10:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @cond
  11:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  **************************************************************************************************
  12:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * I2C_MASTER v4.1.28 Configures USIC channel to transmit & receive data using I2C protocol.
  13:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
  14:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Copyright (c) 2015-2018, Infineon Technologies AG
  15:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * All rights reserved.
  16:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
  17:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Redistribution and use in source and binary forms, with or without modification,are permitted pr
  18:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * following conditions are met:
  19:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
  20:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Redistributions of source code must retain the above copyright notice, this list of conditions a
  21:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * disclaimer.
  22:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
  23:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Redistributions in binary form must reproduce the above copyright notice, this list of condition
  24:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * following disclaimer in the documentation and/or other materials provided with the distribution.
  25:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
  26:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Neither the name of the copyright holders nor the names of its contributors may be used to endor
  27:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * products derived from this software without specific prior written permission.
  28:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
  29:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR I
  30:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTI
  31:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, IN
  32:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBS
  33:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THE
  34:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
  35:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  36:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
  37:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * To improve the quality of the software, users are encouraged to share modifications, enhancement
  38:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * with Infineon Technologies AG (dave@infineon.com).
  39:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  **************************************************************************************************
  40:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
  41:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Change History
  42:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * --------------
  43:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
  44:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * 2015-02-16:
  45:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *     - Initial version<br>
  46:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
  47:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * 2015-06-10:
  48:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *     - AbortTransmit and AbortReceive API return type modified. <br>
  49:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
  50:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * 2015-08-31:
  51:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *     - DMA support APIs added
  52:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * 2015-10-20:
  53:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *     - Code snippets updated
  54:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * 2016-08-18:
  55:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *     - Documentation of slave address formatting improved.
  56:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * 2017-11-17:
  57:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *     - Added tx_irqn and rx_irqn to I2C_MASTER_CONFIG_t
  58:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * 2017-12-20:
  59:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *     - Added I2C_MASTER_FlushTxFifo(), I2C_MASTER_FlushRxFifo(), I2C_MASTER_DisableOutputs(), I2C
  60:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
  61:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @endcond
  62:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
  63:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  */
  64:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** 
  65:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** #ifndef I2C_MASTER_H
  66:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** #define I2C_MASTER_H
  67:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** 
  68:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** 
  69:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** 
  70:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** /**************************************************************************************************
  71:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * HEADER FILES
  72:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  **************************************************************************************************
  73:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** #include <xmc_gpio.h>
  74:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** #include <xmc_i2c.h>
  75:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** #include "i2c_master_conf.h"
  76:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** 
  77:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** #if (UC_FAMILY == XMC4)
  78:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** #if ((I2C_MASTER_DMA_TX_ENABLED == 1) || (I2C_MASTER_DMA_RX_ENABLED == 1))
  79:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** #include "GLOBAL_DMA/global_dma.h"
  80:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** #endif
  81:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** #endif
  82:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** 
  83:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** #include <DAVE_Common.h>
  84:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** 
  85:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** 
  86:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** typedef void(*i2c_master_fptr_cbhandler)(void);
  87:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** 
  88:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** /**************************************************************************************************
  89:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * MACROS
  90:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  **************************************************************************************************
  91:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** #if (!((XMC_LIB_MAJOR_VERSION == 2U) && \
  92:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****        (XMC_LIB_MINOR_VERSION >= 0U) && \
  93:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****        (XMC_LIB_PATCH_VERSION >= 0U)))
  94:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** #error "I2C_MASTER requires XMC Peripheral Library v2.0.0 or higher"
  95:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** #endif
  96:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** 
  97:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** /**************************************************************************************************
  98:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * ENUMS
  99:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  **************************************************************************************************
 100:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** /**
 101:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @ingroup I2C_MASTER_enumerations
 102:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @{
 103:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  */
 104:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** /**
 105:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Initialization status.
 106:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  */
 107:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** typedef enum I2C_MASTER_STATUS
 108:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** {
 109:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****   I2C_MASTER_STATUS_SUCCESS = 0U,           /*!< I2C_MASTER SUCCESS */
 110:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****   I2C_MASTER_STATUS_FAILURE = 1U,           /*!< I2C_MASTER FAILURE */
 111:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****   I2C_MASTER_STATUS_BUSY = 2U,              /*!< I2C_MASTER BUSY */
 112:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****   I2C_MASTER_STATUS_UNSUPPORTED_MODE = 3U,  /*!< I2C_MASTER UNSUPPORTED MODE */
 113:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****   I2C_MASTER_STATUS_TIMEOUT = 4U            /*!< I2C_MASTER TIMEOUT */
 114:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** } I2C_MASTER_STATUS_t;
 115:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** 
 116:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** /**
 117:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Direction
 118:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  */
 119:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** typedef enum I2C_MASTER_DIRECTION
 120:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** {
 121:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****   I2C_MASTER_DIRECTION_TRANSMIT = 0U,   /*!< Direction indicates transmit */
 122:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****   I2C_MASTER_DIRECTION_RECEIVE = 1U     /*!< Direction indicates receive */
 123:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** } I2C_MASTER_DIRECTION_t;
 124:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** 
 125:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** /**
 126:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @brief Enum used to identify the transfer type used for either transmit or receive function.
 127:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  */
 128:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** typedef enum I2C_MASTER_TRANSFER_MODE
 129:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** {
 130:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****   I2C_MASTER_TRANSFER_MODE_INTERRUPT,  /**< Implement data transmit or receive using interrupts */
 131:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****   I2C_MASTER_TRANSFER_MODE_DMA,        /**< Implement data transmit or receive using DMA */
 132:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****   I2C_MASTER_TRANSFER_MODE_DIRECT      /**< This configuration exposes signals for external APP con
 133:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** } I2C_MASTER_TRANSFER_MODE_t;
 134:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** /**
 135:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @}
 136:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  */
 137:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** /**************************************************************************************************
 138:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** * DATA STRUCTURES
 139:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** ***************************************************************************************************
 140:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** 
 141:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** /**
 142:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @ingroup I2C_MASTER_datastructures
 143:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @{
 144:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  */
 145:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** /**
 146:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @brief Structure for DMA configuration.
 147:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  */
 148:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** #if ((I2C_MASTER_DMA_TX_ENABLED == 1) || (I2C_MASTER_DMA_RX_ENABLED == 1))
 149:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** typedef struct I2C_MASTER_DMA_CONFIG
 150:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** {
 151:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****   const XMC_DMA_CH_CONFIG_t * dma_ch_config;   /**< Pointer to the DMA channel configuration.*/
 152:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****   GLOBAL_DMA_t * global_dma;                   /**< Global DMA handle */
 153:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****   uint8_t dma_channel;                         /**< DMA channel number */
 154:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** } I2C_MASTER_DMA_CONFIG_t;
 155:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** #endif
 156:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** /**
 157:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @brief Constant structure for holding the configuration parameters of I2C channel.
 158:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  */
 159:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** typedef struct I2C_MASTER_CONFIG
 160:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** {
 161:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****    const XMC_I2C_CH_CONFIG_t *brg_config;             /*!< Basic I2C configuration from the GUI wit
 162:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** #if (I2C_MASTER_DMA_TX_ENABLED == 1)
 163:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****    const I2C_MASTER_DMA_CONFIG_t * const transmit_dma_config; /**< Pointer to the DMA channel confi
 164:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****                                                                    data transmission.*/
 165:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** #endif
 166:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** #if (I2C_MASTER_DMA_RX_ENABLED == 1)
 167:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****    const I2C_MASTER_DMA_CONFIG_t * const receive_dma_config;  /**< Pointer to the DMA channel confi
 168:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****                                                                    data reception.*/
 169:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** #endif
 170:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****    i2c_master_fptr_cbhandler fptr_i2c_config;         /*!< Function pointer to configure the MUX va
 171:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****    i2c_master_fptr_cbhandler fptr_i2c_enable_io;      /*!< Function pointer to enable SDA/SCL outpu
 172:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****    i2c_master_fptr_cbhandler fptr_i2c_disable_io;     /*!< Function pointer to disable SDA/SCL outp
 173:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** 
 174:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****    i2c_master_fptr_cbhandler tx_cbhandler;            /*!< Function pointer to hold the callback fu
 175:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****                                                            called when the transmission is complete
 176:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****    i2c_master_fptr_cbhandler rx_cbhandler;            /*!< Function pointer to hold the callback fu
 177:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****                                                            called when the reception is complete*/
 178:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****    i2c_master_fptr_cbhandler nack_cbhandler;          /*!< Function pointer to hold the callback fu
 179:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****                                                            called when nack is received*/
 180:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****    i2c_master_fptr_cbhandler arbitration_cbhandler;   /*!< Function pointer to hold the callback fu
 181:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****                                                            called when arbitration lost is occured*
 182:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****    i2c_master_fptr_cbhandler error_cbhandler;         /*!< Function pointer to hold the callback fu
 183:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****                                                            called when error is detected.*/
 184:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****    I2C_MASTER_TRANSFER_MODE_t transmit_mode;          /**< Mode used for transmitting data. Data ca
 185:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****                                                            interrupt, DMA or direct(using polling o
 186:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****    I2C_MASTER_TRANSFER_MODE_t receive_mode;           /**< Mode used for receiving data. Data can b
 187:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****                                                            interrupt, DMA or direct(using polling o
 188:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** 
 189:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****    XMC_USIC_CH_FIFO_SIZE_t txFIFO_size;               /*!< TxFIFO size configuration*/
 190:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****    XMC_USIC_CH_FIFO_SIZE_t rxFIFO_size;               /*!< RxFIFO size configuration*/
 191:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** 
 192:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****    IRQn_Type tx_irqn;
 193:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****    IRQn_Type rx_irqn; 
 194:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** } I2C_MASTER_CONFIG_t;
 195:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** 
 196:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** /**
 197:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @brief Structure to hold the dynamic variables for the I2C_MASTER communication.
 198:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  */
 199:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** typedef struct I2C_MASTER_RUNTIME
 200:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** {
 201:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****   uint8_t * tx_data;                     /*!< Pointer to the transmit data buffer*/
 202:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****   uint8_t * rx_data;                     /*!< Pointer to the receive data buffer*/
 203:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****   uint32_t tx_data_count;                /*!< Number of bytes of data to be transmitted*/
 204:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****   volatile uint32_t tx_data_index;       /*!< Index to the byte to be transmitted next in the tx_da
 205:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****   uint32_t rx_data_count;                /*!< Number of bytes of data to be received*/
 206:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** #if (I2C_MASTER_DMA_RX_ENABLED == 1)
 207:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****   uint32_t rx_dma_data_count;            /*!< Number of bytes of data to be received-DMA mode*/
 208:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****   uint32_t rx_dma_data_index;            /*!< Index of bytes of data to be received-DMA mode*/
 209:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** #endif
 210:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****   volatile uint32_t rx_data_index;       /*!< Indicates the number of bytes currently available in 
 211:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****   volatile uint32_t direction;           /*!< Indicates TRANSMIT/RECEIVE */
 212:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****   uint32_t send_stop;                    /*!< Indicates to stop the I2C */
 213:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****   uint32_t send_nack;                    /*!< Indicates to send nack */
 214:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****   uint8_t tx_ack_sr;                         /*!< Service request number assigned to transmit inter
 215:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****   uint8_t rx_sr;                         /*!< Service request number assigned to receive interrupts
 216:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****   volatile bool tx_busy;                 /*!< Status flag to indicate busy when a transmission is a
 217:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****   volatile bool rx_busy;                 /*!< Status flag to indicate busy when a reception is assi
 218:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****   volatile bool bus_acquired;            /*!< flag to indicate whether bus is acquired or not */
 219:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** } I2C_MASTER_RUNTIME_t;
 220:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** 
 221:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** 
 222:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** /**
 223:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @brief Handler structure with pointers to dynamic and static parameters.
 224:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  */
 225:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** typedef struct I2C_MASTER
 226:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** {
 227:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****   XMC_USIC_CH_t *channel;                    /*!< USIC channel*/
 228:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****   const I2C_MASTER_CONFIG_t * const config;  /*!< I2C configuration structure pointer*/
 229:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****   I2C_MASTER_RUNTIME_t * const runtime;      /*!< Pointer to the structure holding all variables,
 230:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****    	                                               that can change at runtime*/
 231:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** } I2C_MASTER_t;
 232:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** 
 233:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** /**
 234:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @}
 235:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  */
 236:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** 
 237:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** #ifdef __cplusplus
 238:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** extern "C" {
 239:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** #endif
 240:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** 
 241:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** 
 242:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** /**
 243:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @ingroup I2C_MASTER_apidoc
 244:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @{
 245:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  */
 246:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** 
 247:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** /**************************************************************************************************
 248:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * API PROTOTYPES
 249:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  **************************************************************************************************
 250:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** /**
 251:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @brief Get I2C_MASTER APP version.
 252:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @return \a DAVE_APP_VERSION_t APP version information (major, minor and patch number)
 253:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 254:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * \par<b>Description: </b><br>
 255:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * The function can be used to check application software compatibility with a
 256:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * specific version of the APP.
 257:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 258:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @code
 259:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  #include <DAVE.h>
 260:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 261:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  int main(void)
 262:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  {
 263:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    DAVE_APP_VERSION_t version;
 264:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    DAVE_Init();
 265:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    version = I2C_MASTER_GetAppVersion();
 266:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    if (version.major != 4U)
 267:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    {
 268:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    }
 269:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    while(1)
 270:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    {}
 271:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    return 0;
 272:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  }
 273:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @endcode<BR> </p>
 274:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  */
 275:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** DAVE_APP_VERSION_t I2C_MASTER_GetAppVersion(void);
 276:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** /**
 277:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @brief This function initializes the I2C_MASTER APP based on user provided configuration.
 278:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 279:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @return None
 280:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 281:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * \par<b>Description: </b><br>
 282:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * I2C configurations like channel selection,baud rate setting,
 283:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * FIFO configuration etc are done in this API.
 284:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Protocol specific interrupts can also be enabled using the I2C_MASTER_Init
 285:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * function.
 286:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 287:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Pre-requisite: Instantiate I2C_MASTER APP and generate code before using below code snippet.
 288:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @code
 289:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 290:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  #include <DAVE.h>
 291:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  int main(void)
 292:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  {
 293:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *   // Initializing the modules and the multiplexer
 294:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *   DAVE_Init(); // I2C_MASTER_Init will be called from DAVE_Init()
 295:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *   while(1)
 296:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *   {}
 297:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *   return 0;
 298:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  }
 299:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @endcode<BR> </p>
 300:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 301:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  */
 302:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** 
 303:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** I2C_MASTER_STATUS_t I2C_MASTER_Init(const I2C_MASTER_t *const handle);
 304:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** 
 305:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** 
 306:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** /**
 307:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @brief  Receives the data from I2C slave device.
 308:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @param  handle I2C device handle of type I2C_MASTER_t*
 309:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @param  send_start Flag to indicate that the start condition need to be send.
 310:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @param  address I2C slave device address.
 311:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @param  data buffer to receive data.
 312:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @param  count The number of bytes to be received from slave.
 313:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @param  send_stop The flag to indicate that the stop condition need to be send.
 314:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @param  send_nack The flag to indicate that the NACK condition need to be send for the last byte
 315:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @return @ref I2C_MASTER_STATUS_t Status.
 316:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * \par<b>NOTE: </b><br>
 317:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * I2C_MASTER_Receive API can be used in Interrupt and Direct modes.\n
 318:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Address(address) should reserve an additional bit at the LSB for read/write indication. For exam
 319:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * be provided as 0x0a. If the address is 10-bit, only most significant bits with the 10-bit identi
 320:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * For example, if the 10-bit address is 0x305, the address should be provided as 0xf6(prepend with
 321:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * followed by 1-bit field for read/write).\n
 322:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Pre-requisite: Instantiate I2C_MASTER APP and generate code before using below code snippet.
 323:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 324:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @code
 325:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 326:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  #include <DAVE.h>
 327:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  #define SLAVE_ADDRESS 0xA0
 328:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  #define BYTES_TO_READ 10
 329:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  #define BYTES_TO_TRANSMIT 10
 330:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 331:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  typedef enum PCA9502_REGADDR {
 332:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    IO_DIR    = 0xA << 3,
 333:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    IO_STATE  = 0xB << 3,
 334:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    IO_INTE   = 0xC << 3,
 335:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    IO_CTRL   = 0xE << 3
 336:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  } PCA9502_REGADDR_t;
 337:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** 
 338:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  uint8_t mem_address[2];
 339:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  uint8_t data = 0x55;
 340:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  uint8_t rx_data;
 341:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 342:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  int main(void)
 343:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  {
 344:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *   DAVE_STATUS_t init_status;  
 345:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *   init_status = DAVE_Init();
 346:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *   if (init_status == DAVE_STATUS_SUCCESS)
 347:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *   {
 348:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *     mem_address[0] = IO_STATE;//memory which need to be read from slave
 349:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *     //Write data to IO EXPANDER
 350:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *     I2C_MASTER_Transmit(&I2C_MASTER_0,true,SLAVE_ADDRESS,mem_address,1,false);
 351:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *     while(I2C_MASTER_IsTxBusy(&I2C_MASTER_0));
 352:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 353:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *     I2C_MASTER_Transmit(&I2C_MASTER_0,false,SLAVE_ADDRESS,&data,1,true);
 354:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *     while(I2C_MASTER_IsTxBusy(&I2C_MASTER_0));
 355:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** 
 356:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *     //Read data from IO EXPANDER
 357:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *     I2C_MASTER_Transmit(&I2C_MASTER_0,true,SLAVE_ADDRESS,mem_address,1,false);
 358:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *     while(I2C_MASTER_IsTxBusy(&I2C_MASTER_0));
 359:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 360:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *     I2C_MASTER_Receive(&I2C_MASTER_0,true,SLAVE_ADDRESS,&rx_data,1,true,true);
 361:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *     while(I2C_MASTER_IsRxBusy(&I2C_MASTER_0));
 362:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *   }
 363:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *   while(1)
 364:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *   { }
 365:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  return 0;
 366:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * }
 367:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 368:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @endcode<BR> </p>
 369:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 370:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  */
 371:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** I2C_MASTER_STATUS_t I2C_MASTER_Receive(I2C_MASTER_t *handle, bool send_start, const uint32_t addres
 372:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****                                        uint8_t * data, const uint32_t count, bool send_stop, bool s
 373:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** 
 374:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** /**
 375:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @brief Transmits data to I2C slave device.
 376:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 377:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @param  handle I2C device handle of type I2C_MASTER_t*
 378:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @param  send_start The flag to indicate that the start condition need to be send.
 379:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @param  address I2C slave device address.
 380:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @param  data buffer containing the data to transmit.
 381:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @param  size The number of bytes to be send to slave.
 382:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @param  send_stop The flag to indicate that the stop condition need to be send.
 383:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 384:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @return @ref I2C_MASTER_STATUS_t Status.
 385:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * \par<b>NOTE: </b><br>
 386:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * I2C_MASTER_Transmit API can be used in Interrupt and Direct modes.\n
 387:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Address(address) should reserve an additional bit at the LSB for read/write indication. For exam
 388:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * be provided as 0x0a. If the address is 10-bit, only most significant bits with the 10-bit identi
 389:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * For example, if the 10-bit address is 0x305, the address should be provided as 0xf6(prepend with
 390:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * followed by 1-bit field for read/write). \n
 391:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Pre-requisite: Instantiate I2C_MASTER APP and generate code before using below code snippet.
 392:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * 
 393:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @code
 394:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 395:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  #include <DAVE.h>
 396:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  #define SLAVE_ADDRESS (0xA0)
 397:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  typedef enum PCA9502_REGADDR {
 398:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    IO_DIR    = 0xA << 3,
 399:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    IO_STATE  = 0xB << 3,
 400:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    IO_INTE   = 0xC << 3,
 401:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    IO_CTRL   = 0xE << 3
 402:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  } PCA9502_REGADDR_t;
 403:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 404:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  uint8_t tx_buffer[64] = {0x01,0x02,0x03,0x04,0x05};
 405:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  uint8_t mem_address[2];
 406:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 407:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  int main(void)
 408:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  {
 409:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    DAVE_STATUS_t init_status;
 410:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    init_status = DAVE_Init();
 411:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    if (init_status == DAVE_STATUS_SUCCESS)
 412:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    {
 413:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      mem_address[0] = IO_STATE;//memory which need to be read from slave
 414:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      //Write data to IO EXPANDER
 415:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      I2C_MASTER_Transmit(&I2C_MASTER_0,true,SLAVE_ADDRESS,mem_address,1,false);
 416:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      while(I2C_MASTER_IsTxBusy(&I2C_MASTER_0));
 417:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 418:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      I2C_MASTER_Transmit(&I2C_MASTER_0,false,SLAVE_ADDRESS,tx_buffer,5,true);
 419:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      while(I2C_MASTER_IsTxBusy(&I2C_MASTER_0));
 420:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    }
 421:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    while(1)
 422:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    { }
 423:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** 
 424:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *   return 0;
 425:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * }
 426:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 427:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @endcode<BR> </p>
 428:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 429:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  */
 430:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** I2C_MASTER_STATUS_t I2C_MASTER_Transmit(I2C_MASTER_t *handle, bool send_start, const uint32_t addre
 431:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** 		                                uint8_t *data, const uint32_t size, bool send_stop);
 432:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** 
 433:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** /**
 434:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @brief Get the I2C flag status.
 435:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 436:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @param  handle I2C device handle of type I2C_MASTER_t*
 437:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @param  flagtype   single or multiple flags, whose status need to be checked.
 438:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *			 	      bitwise OR operation on elements of enum XMC_I2C_CH_STATUS_FLAG_t can be used to selec
 439:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *                    multiple flags.
 440:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 441:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @return uint32_t Flag status.
 442:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 443:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Pre-requisite: Instantiate I2C_MASTER APP and generate code before using below code snippet.
 444:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 445:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @code
 446:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 447:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  #include <DAVE.h>
 448:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 449:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  #define SLAVE_ADDRESS (0xA0)
 450:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  int main(void)
 451:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  {
 452:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    DAVE_STATUS_t init_status;
 453:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    init_status = DAVE_Init();
 454:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    if (init_status == DAVE_STATUS_SUCCESS)
 455:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    {
 456:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      I2C_MASTER_SendStart(&I2C_MASTER_0, SLAVE_ADDRESS, XMC_I2C_CH_CMD_WRITE);
 457:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      while(I2C_MASTER_GetFlagStatus(&I2C_MASTER_0, XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED) == 0U)
 458:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      {
 459:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *       // wait for ACK
 460:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      }
 461:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    }
 462:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    while(1)
 463:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    {}
 464:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 465:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *   return 0;
 466:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  }
 467:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 468:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @endcode<BR> </p>
 469:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 470:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  */
 471:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** uint32_t I2C_MASTER_GetFlagStatus(const I2C_MASTER_t *handle, uint32_t flagtype);
 472:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** 
 473:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** /**
 474:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @brief Clear the I2C flag status.
 475:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 476:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @param  handle I2C device handle of type I2C_MASTER_t*
 477:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @param  flagtype   single or multiple flags, whose status need to be checked.
 478:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *                    The bitwise OR operation on elements of enum XMC_I2C_CH_STATUS_FLAG_t can be 
 479:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *                    multiple flags.
 480:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 481:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @return None <BR>
 482:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Pre-requisite: Instantiate I2C_MASTER APP and generate code before using below code snippet.
 483:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @code
 484:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 485:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  #include <DAVE.h>
 486:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 487:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  #define SLAVE_ADDRESS (0xA0)
 488:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  int main(void)
 489:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  {
 490:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    DAVE_STATUS_t init_status;
 491:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 492:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    init_status = DAVE_Init();
 493:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    if (init_status == DAVE_STATUS_SUCCESS)
 494:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    {
 495:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      I2C_MASTER_SendStart(&I2C_MASTER_0, SLAVE_ADDRESS, XMC_I2C_CH_CMD_WRITE);
 496:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      while(I2C_MASTER_GetFlagStatus(&I2C_MASTER_0, XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED) == 0U)
 497:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      {
 498:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *       // wait for ACK
 499:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      }
 500:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      I2C_MASTER_ClearFlag(&I2C_MASTER_0,XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED);
 501:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    }
 502:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    while(1)
 503:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    {}
 504:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 505:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *   return 0;
 506:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * }
 507:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @endcode<BR> </p>
 508:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 509:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  */
 510:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** void I2C_MASTER_ClearFlag(const I2C_MASTER_t *handle, uint32_t flagtype);
 511:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** 
 512:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** /**
 513:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @brief Aborts the ongoing data transmission.
 514:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @param handle  I2C_MASTER APP handle pointer of type @ref I2C_MASTER_t
 515:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @return I2C_MASTER_STATUS_t status
 516:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 517:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * \par<b>Description:</b><br>
 518:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * If there is a transmission in progress, it will be stopped. Once the transmission is stopped, 
 519:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * user can start a new transmission without delay.
 520:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 521:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Pre-requisite: Instantiate I2C_MASTER APP and generate code before using below code snippet.
 522:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 523:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 524:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Example Usage:
 525:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @code
 526:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 527:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
 528:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  #define SLAVE_ADDRESS 0xA0
 529:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  uint8_t tx_buf[50] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
 530:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** 
 531:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  int main(void)
 532:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  {
 533:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    DAVE_STATUS_t init_status;
 534:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    init_status = DAVE_Init();
 535:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    if (init_status == DAVE_STATUS_SUCCESS)
 536:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    {
 537:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      I2C_MASTER_Transmit(&I2C_MASTER_0, true, SLAVE_ADDRESS, &tx_buf[0], 16, true);
 538:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      I2C_MASTER_AbortTransmit(&I2C_MASTER_0);
 539:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      I2C_MASTER_SendStop(&I2C_MASTER_0);
 540:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      I2C_MASTER_Transmit(&I2C_MASTER_0, true, SLAVE_ADDRESS, &tx_buf[0], 16, true);
 541:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      while(I2C_MASTER_IsTxBusy(&I2C_MASTER_0));
 542:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    }
 543:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    while(1U)
 544:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    {
 545:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    }
 546:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 547:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    return 1U;
 548:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  }
 549:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 550:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @endcode
 551:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 552:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  */
 553:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** I2C_MASTER_STATUS_t I2C_MASTER_AbortTransmit(const I2C_MASTER_t *const handle);
 554:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** 
 555:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** /**
 556:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** * @brief Stops the active data reception request.
 557:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @param handle I2C_MASTER APP handle pointer of type @ref I2C_MASTER_t
 558:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @return I2C_MASTER_STATUS_t status
 559:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 560:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * \par<b>Description:</b><br>
 561:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * If a reception is in progress, it will be stopped. When a reception request
 562:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * is active, user will not be able to place a new receive request till the active
 563:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * reception is complete. This API can stop the progressing reception to make
 564:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * a new receive request.
 565:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 566:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Pre-requisite: Instantiate I2C_MASTER APP and generate code before using below code snippet.
 567:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 568:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Example Usage:
 569:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @code
 570:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 571:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
 572:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  #define SLAVE_ADDRESS 0xA0
 573:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  int main(void)
 574:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  {
 575:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *   uint8_t rx_buf[25];
 576:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *   uint8_t tx_buf[2];
 577:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *   DAVE_STATUS_t init_status;
 578:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *   init_status = DAVE_Init();
 579:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *   if (init_status == DAVE_STATUS_SUCCESS)
 580:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *   {
 581:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *     //send the address from which data to be transfered
 582:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *     tx_buf[0] = 0;
 583:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *     I2C_MASTER_Transmit(&I2C_MASTER_0, true, SLAVE_ADDRESS, &tx_buf[0], 1, false);
 584:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *     while(I2C_MASTER_IsTxBusy(&I2C_MASTER_0));
 585:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *     I2C_MASTER_Receive(&I2C_MASTER_0, true, SLAVE_ADDRESS, &rx_buf[0], 16, true, true);
 586:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *     I2C_MASTER_AbortReceive(&I2C_MASTER_0);
 587:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *     I2C_MASTER_SendStop(&I2C_MASTER_0);
 588:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *     I2C_MASTER_Transmit(&I2C_MASTER_0, true, SLAVE_ADDRESS, &tx_buf[0], 1, false);
 589:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *     while(I2C_MASTER_IsTxBusy(&I2C_MASTER_0));
 590:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *     I2C_MASTER_Receive(&I2C_MASTER_0, true, SLAVE_ADDRESS, &rx_buf[0], 16, true, true);
 591:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *     while(I2C_MASTER_IsRxBusy(&I2C_MASTER_0));
 592:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *   }
 593:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *   while(1U)
 594:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *   {
 595:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *   }
 596:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 597:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *   return 1U;
 598:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * }
 599:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 600:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @endcode
 601:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 602:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  */
 603:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** I2C_MASTER_STATUS_t I2C_MASTER_AbortReceive(const I2C_MASTER_t *const handle);
 604:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** 
 605:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** 
 606:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** #if (I2C_MASTER_DMA_TX_ENABLED == 1U) || defined(DOXYGEN)
 607:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** /**
 608:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @brief Registers a request for transmitting data over I2C channel using DMA.
 609:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 610:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @param  handle  I2C_MASTER APP handle pointer of type @ref I2C_MASTER_t
 611:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @param  block_size size of the block
 612:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @param  addr    address\n
 613:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * \b Range: minimum= 1, maximum= 4095.
 614:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 615:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @return  I2C_MASTER_STATUS_t: Status of transmit request.\n
 616:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *                        @ref I2C_MASTER_STATUS_SUCCESS if the request is accepted.\n
 617:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *                        @ref I2C_MASTER_STATUS_BUSY if a transmission is in progress.\n
 618:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 619:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * <i>Imp Note:</i> Return value should be validated by user to ensure that the
 620:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * request is registered.
 621:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 622:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * \par<b>Description:</b><br>
 623:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * The data transmission is accomplished using DMA. User can configure a callback function in the A
 624:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * When the data is fully transmitted, the callback function will be executed. The function uses AP
 625:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * structure to store the status of transmission.
 626:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * This function only registers a data transmission request, if there is no active transmission in 
 627:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Actual data transmission happens through DMA channel.
 628:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * A maximum of 4095 bytes can be transmitted in one API call. This limit is because of the DMA sin
 629:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Callback function is executed when all the data bytes are transmitted.
 630:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * If a callback function is not configured, user has to poll for the value of \a tx_busy flag of
 631:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * the APP handle structure( \a handle->runtime->tx_busy ) to check for
 632:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * the completion of data transmission.
 633:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * If data more than the block size of 4095 have to be transmitted, user will have to transmit them
 634:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * calls to this API.
 635:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * \par<b>NOTE: </b><br>
 636:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * I2C_MASTER_StartTransmitDMA API can be used in DMA mode.
 637:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Transmit should be configured as "DMA" mode in advanced settings tab. \n
 638:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Address(addr) should reserve an additional bit at the LSB for read/write indication. For example
 639:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * be provided as 0x0a. If the address is 10-bit, only most significant bits with the 10-bit identi
 640:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * For example, if the 10-bit address is 0x305, the address should be provided as 0xf6(prepend with
 641:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * followed by 1-bit field for read/write).<br>
 642:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Example Usage:
 643:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 644:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @code
 645:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 646:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
 647:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  #define SLAVE_ADDRESS 0xA0
 648:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  uint8_t Send_Data[] = "Infineon Technologies";
 649:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  int main(void)
 650:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  {
 651:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    DAVE_STATUS_t init_status;
 652:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 653:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    init_status = DAVE_Init();
 654:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    if (init_status == DAVE_STATUS_SUCCESS)
 655:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    {
 656:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      I2C_MASTER_SendStart(&I2C_MASTER_0, SLAVE_ADDRESS, XMC_I2C_CH_CMD_WRITE);
 657:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *	    while(I2C_MASTER_GetFlagStatus(&I2C_MASTER_0, XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED) == 0U)
 658:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *	    {
 659:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *	      // wait for ACK
 660:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *	    }
 661:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      I2C_MASTER_ClearFlag(&I2C_MASTER_0,XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED);
 662:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      // write to address 0
 663:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      I2C_MASTER_TransmitByte(&I2C_MASTER_0, 0x00);
 664:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *	    while(I2C_MASTER_GetFlagStatus(&I2C_MASTER_0, XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED) == 0U)
 665:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *	    {
 666:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *	      // wait for ACK
 667:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *	    }
 668:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      I2C_MASTER_ClearFlag(&I2C_MASTER_0,XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED);
 669:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      // trigger the DMA
 670:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      I2C_MASTER_StartTransmitDMA(&I2C_MASTER_0, sizeof(Send_Data), Send_Data);
 671:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      while(I2C_MASTER_IsTxBusy(&I2C_MASTER_0));
 672:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    }
 673:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    else
 674:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    {
 675:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      XMC_DEBUG("main: Application initialization failed");
 676:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      while(1U)
 677:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      {
 678:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      }
 679:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    }
 680:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    return 1U;
 681:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * }
 682:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @endcode
 683:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 684:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  */
 685:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** I2C_MASTER_STATUS_t I2C_MASTER_StartTransmitDMA(const I2C_MASTER_t *const handle, uint32_t block_si
 686:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** #endif
 687:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** 
 688:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** #if (I2C_MASTER_DMA_RX_ENABLED == 1U) || defined(DOXYGEN)
 689:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** /**
 690:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @brief Registers a request for receiving data over I2C_MASTER channel using DMA.
 691:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 692:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 693:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @param  handle  Pointer to I2C_MASTER_t handle structure
 694:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @param block_size  size of the block
 695:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @param  addr  address \n
 696:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * \b Range: minimum= 1, maximum= 4095.
 697:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 698:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @return  I2C_MASTER_STATUS_t: Status for receive request.\n
 699:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *                        @ref I2C_MASTER_STATUS_SUCCESS if the request is accepted.\n
 700:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *                        @ref I2C_MASTER_STATUS_BUSY if a reception is in progress.\n
 701:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 702:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * \par<b>Description:</b><br>
 703:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Data will be received asynchronously. When the requested number of data bytes are received, opti
 704:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * configured callback function will be executed.
 705:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * This function only registers a request to receive a number of data bytes from a USIC channel.
 706:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * When all the requested number of data bytes are received, the configured callback function will 
 707:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * If a callback function is not configured, the user has to poll for the value of the variable, \a
 708:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * handle->runtime->rx_busy to be false. The value is updated to \a false when all the requested nu
 709:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * are received.
 710:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * A maximum of 4095 bytes can be received in one API call. This limit is because of the DMA single
 711:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 712:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * \par<b>NOTE: </b><br>: I2C_MASTER_StartReceiveDMA API can be used only in DMA mode
 713:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Receive should be configured as "DMA" mode in advanced settings tab \n
 714:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Address(addr) should reserve an additional bit at the LSB for read/write indication. For example
 715:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * be provided as 0x0a. If the address is 10-bit, only most significant bits with the 10-bit identi
 716:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * For example, if the 10-bit address is 0x305, the address should be provided as 0xf6(prepend with
 717:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * followed by 1-bit field for read/write).<br>
 718:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 719:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Example Usage:
 720:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @code
 721:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 722:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
 723:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  #define SLAVE_ADDRESS 0xA0
 724:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  //Pre condition:
 725:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  //Transmit mode and receive mode should be configured to "DMA" in advanced settings tab
 726:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 727:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  uint8_t ReadData[256];
 728:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  int main(void)
 729:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  {
 730:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    DAVE_STATUS_t init_status;
 731:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 732:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    init_status = DAVE_Init();
 733:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    if (init_status == DAVE_STATUS_SUCCESS)
 734:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    {
 735:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      I2C_MASTER_SendStart(&I2C_MASTER_0, SLAVE_ADDRESS, XMC_I2C_CH_CMD_WRITE);
 736:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *	    while(I2C_MASTER_GetFlagStatus(&I2C_MASTER_0, XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED) == 0U)
 737:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *	    {
 738:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *	      // wait for ACK
 739:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *	    }
 740:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      I2C_MASTER_ClearFlag(&I2C_MASTER_0,XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED);
 741:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      // write to address 0
 742:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      I2C_MASTER_TransmitByte(&I2C_MASTER_0, 0x00);
 743:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *	    while(I2C_MASTER_GetFlagStatus(&I2C_MASTER_0, XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED) == 0U)
 744:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *	    {
 745:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *	      // wait for ACK
 746:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *	    }
 747:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      I2C_MASTER_ClearFlag(&I2C_MASTER_0,XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED);
 748:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      I2C_MASTER_SendRepeatedStart(&I2C_MASTER_0, SLAVE_ADDRESS, XMC_I2C_CH_CMD_READ);
 749:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *	    while(I2C_MASTER_GetFlagStatus(&I2C_MASTER_0, XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED) == 0U)
 750:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *	    {
 751:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *	      // wait for ACK
 752:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *	    }
 753:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      I2C_MASTER_ClearFlag(&I2C_MASTER_0,XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED);
 754:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  
 755:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      I2C_MASTER_StartReceiveDMA(&I2C_MASTER_0, 200, ReadData);
 756:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      while(I2C_MASTER_IsRxBusy(&I2C_MASTER_0));
 757:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    }
 758:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    else
 759:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    {
 760:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      XMC_DEBUG("main: Application initialization failed");
 761:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      while(1U)
 762:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      {
 763:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      }
 764:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    }
 765:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    return 1U;
 766:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  }
 767:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  @endcode
 768:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 769:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  */
 770:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** I2C_MASTER_STATUS_t I2C_MASTER_StartReceiveDMA(const I2C_MASTER_t *const handle, uint32_t block_siz
 771:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** #endif
 772:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** 
 773:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** #if (I2C_MASTER_INTERRUPT_TX_ENABLED == 1U)
 774:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** /**
 775:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @brief Registers a request for transmitting data over I2C_MASTER channel.
 776:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 777:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @param  handle  I2C_MASTER APP handle pointer of type @ref I2C_MASTER_t
 778:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @param  send_start flag to indicate the start condition
 779:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @param  address slave address
 780:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @param  data    pointer to buffer
 781:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @param  size    number of bytes
 782:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @param  send_stop flag to indicate the stop condition\n
 783:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * \b Range: minimum= 1, maximum= maximum supported by uint32_t.
 784:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 785:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @return  I2C_MASTER_STATUS_t: Status of transmit request.\n
 786:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *                        @ref I2C_MASTER_STATUS_SUCCESS if the request is accepted.\n
 787:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *                        @ref I2C_MASTER_STATUS_BUSY if a transmission is in progress.\n
 788:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 789:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * <i>Imp Note:</i> Return value should be validated by user to ensure that the
 790:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * request is registered.
 791:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 792:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * \par<b>Description:</b><br>
 793:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * The data transmission is accomplished using transmit interrupt. User can configure a callback fu
 794:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * When the data is fully transmitted, the callback function will be executed. If transmit FIFO is 
 795:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * the trigger limit is set to 1. So the transmit interrupt will be generated when all the data in 
 796:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * from FIFO. The function uses APP handle's runtime structure to store the data pointer, count, da
 797:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * status of transmission. This function only registers a data transmission request if there is no 
 798:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * in progress.
 799:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Actual data transmission happens in the transmit interrupt service routine. A trigger is generat
 800:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * interrupt to start loading the data. If transmit FIFO is configured, the data is filled into the
 801:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Transmit interrupt will be generated next time when the transmit FIFO is empty. At this point of
 802:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * some more data to be transmitted, it is loaded to the FIFO again. When FIFO is not enabled, data
 803:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * byte at a time. On transmission of each byte an interrupt is generated and the next byte is tran
 804:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * interrupt service routine. Callback function is executed when all the data bytes are transmitted
 805:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * If a callback function is not configured, user has to poll for the value of \a tx_busy flag of t
 806:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * structure( \a handle->runtime->tx_busy ) to check for the completion of data transmission.<br>
 807:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * \par<b>NOTE: </b><br>: I2C_MASTER_StartTransmitIRQ API can be used only in Interrupt mode.
 808:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Transmit should be configured as "Interrupt" mode in advanced settings tab.\n
 809:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Address(address) should reserve an additional bit at the LSB for read/write indication. For exam
 810:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * be provided as 0x0a. If the address is 10-bit, only most significant bits with the 10-bit identi
 811:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * For example, if the 10-bit address is 0x305, the address should be provided as 0xf6(prepend with
 812:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * followed by 1-bit field for read/write).
 813:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 814:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @code
 815:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 816:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  #include <DAVE.h>
 817:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  #define SLAVE_ADDRESS 0xA0
 818:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  uint8_t tx_buffer[64] = {0x01,0x02,0x03,0x04,0x05};
 819:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  uint8_t mem_address[2];
 820:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 821:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  int main(void)
 822:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  {
 823:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    DAVE_STATUS_t init_status;
 824:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    init_status = DAVE_Init();
 825:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    if (init_status == DAVE_STATUS_SUCCESS)
 826:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    {
 827:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      mem_address[0] = 0x00;//memory which need to be read from slave
 828:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      //Write data to IO EXPANDER
 829:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      I2C_MASTER_StartTransmitIRQ(&I2C_MASTER_0,true,SLAVE_ADDRESS,mem_address,1,false);
 830:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      while(I2C_MASTER_IsTxBusy(&I2C_MASTER_0));
 831:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 832:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      I2C_MASTER_StartTransmitIRQ(&I2C_MASTER_0,false,SLAVE_ADDRESS,tx_buffer,64,true);
 833:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      while(I2C_MASTER_IsTxBusy(&I2C_MASTER_0));
 834:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    }
 835:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    while(1)
 836:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    { }
 837:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** 
 838:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    return 0;
 839:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  }
 840:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 841:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @endcode<BR> </p>
 842:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 843:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  */
 844:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** 
 845:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** I2C_MASTER_STATUS_t I2C_MASTER_StartTransmitIRQ(I2C_MASTER_t *handle, bool send_start, const uint32
 846:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****                                                 uint8_t *data, const uint32_t size, bool send_stop)
 847:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** #endif
 848:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** #if (I2C_MASTER_INTERRUPT_RX_ENABLED == 1U)
 849:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** /**
 850:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @brief Registers a request for receiving data over I2C_MASTER channel.
 851:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 852:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 853:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @param  handle  Pointer to I2C_MASTER_t handle structure
 854:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @param  send_start flag to indicate the start condition
 855:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @param  address slave address
 856:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @param  data    pointer to buffer
 857:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @param  count    number of bytes
 858:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @param  send_stop flag to indicate the stop condition
 859:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @param  send_nack flag to indicate the nack condition\n
 860:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * \b Range: minimum= 1, maximum= maximum value supported by type uint32_t.
 861:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 862:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @return  I2C_MASTER_STATUS_t: Status for receive request.\n
 863:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *                        @ref I2C_MASTER_STATUS_SUCCESS if the request is accepted.\n
 864:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *                        @ref I2C_MASTER_STATUS_BUSY if a reception is in progress.\n
 865:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 866:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 867:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * \par<b>Description:</b><br>
 868:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Data will be received asynchronously. When the requested number of data bytes are received, opti
 869:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * configured callback function will be executed. Based on the UI configuration, either standard re
 870:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * receive FIFO is used for data reception. An interrupt is configured for reading received data fr
 871:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * function only registers a request to receive a number of data bytes from a USIC channel. If FIFO
 872:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * reception, the FIFO limit is dynamically configured to optimally utilize the CPU load.  When all
 873:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * of data bytes are received, the configured callback function will be executed. If a callback fun
 874:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * configured, the user has to poll for the value of the variable, \a handle->runtime->rx_busy to b
 875:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * is updated to \a false when all the requested number of data bytes are received.<br>
 876:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * \par<b>NOTE: </b><br>: I2C_MASTER_StartReceiveIRQ API can be used only in Interrupt mode.
 877:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Receive should be configured as "Interrupt" mode in advanced settings tab.\n
 878:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Address(address) should reserve an additional bit at the LSB for read/write indication. For exam
 879:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * be provided as 0x0a. If the address is 10-bit, only most significant bits with the 10-bit identi
 880:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * For example, if the 10-bit address is 0x305, the address should be provided as 0xf6(prepend with
 881:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * followed by 1-bit field for read/write).
 882:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 883:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @code
 884:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 885:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  #include <DAVE.h>
 886:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  #define SLAVE_ADDRESS 0xA0
 887:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  uint8_t rx_buffer[64];
 888:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  uint8_t mem_address[2];
 889:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 890:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  int main(void)
 891:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  {
 892:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    DAVE_STATUS_t init_status;
 893:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    init_status = DAVE_Init();
 894:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    if (init_status == DAVE_STATUS_SUCCESS)
 895:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    {
 896:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      mem_address[0] = 0x00;//memory which need to be read from slave
 897:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *     //Write data to IO EXPANDER
 898:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *     I2C_MASTER_StartTransmitIRQ(&I2C_MASTER_0,true,SLAVE_ADDRESS,mem_address,1,false);
 899:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *     while(I2C_MASTER_IsTxBusy(&I2C_MASTER_0));
 900:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 901:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *     I2C_MASTER_StartReceiveIRQ(&I2C_MASTER_0,true,SLAVE_ADDRESS,rx_buffer,64,true, true);
 902:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *     while(I2C_MASTER_IsRxBusy(&I2C_MASTER_0));
 903:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    }
 904:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    while(1)
 905:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    { }
 906:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    return 0;
 907:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  }
 908:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 909:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @endcode<BR> </p>
 910:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 911:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  */
 912:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  I2C_MASTER_STATUS_t I2C_MASTER_StartReceiveIRQ(I2C_MASTER_t *handle, bool send_start, const uint32
 913:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****                                                uint8_t * data, const uint32_t count, bool send_stop
 914:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** #endif
 915:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** 
 916:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** 
 917:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** /**
 918:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @brief Gets the transmit FIFO event flags.
 919:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 920:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @param  handle I2C_MASTER APP handle pointer of type @ref I2C_MASTER_t
 921:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 922:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @return uint32_t: Status of the STBI and TBERI bits in TRBSR register in
 923:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *                      their bit positions.\n
 924:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *                      \b Range: Use type @ref XMC_USIC_CH_TXFIFO_EVENT_t for the bitmask of event
 925:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 926:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * \par<b>Description:</b><br>
 927:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Function reads the value of TRBSR register. It masks the standard transmit buffer interrupt flag
 928:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * buffer error flag before providing the value.
 929:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * User has to mask the bits of interest before checking the status.
 930:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * \par<b>NOTE: </b><br>: Enable transmit fifo in Advanced settings tab. <br>
 931:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Example Usage:
 932:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 933:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @code
 934:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 935:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
 936:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  #define SLAVE_ADDRESS 0xA0
 937:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  uint8_t mem_address[2];
 938:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  int main(void)
 939:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  {
 940:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    DAVE_STATUS_t init_status;
 941:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    init_status = DAVE_Init();
 942:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    if (init_status == DAVE_STATUS_SUCCESS)
 943:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    {
 944:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      mem_address[0] = 0x00;//memory which need to be read from slave
 945:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      //Configure transmit fifo trigger limit as 10
 946:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      I2C_MASTER_SetTXFIFOTriggerLimit(&I2C_MASTER_0, 16, 10);
 947:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      I2C_MASTER_StartTransmitIRQ(&I2C_MASTER_0,true,SLAVE_ADDRESS,mem_address,1,false);
 948:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      while(I2C_MASTER_IsTxBusy(&I2C_MASTER_0));
 949:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      I2C_MASTER_StartTransmitIRQ(&I2C_MASTER_0,true,SLAVE_ADDRESS,mem_address,16,false);
 950:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      //Wait for FIFO transmit standard buffer interrupt to fill it again with remaining data
 951:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      while((I2C_MASTER_GetTXFIFOStatus(&I2C_MASTER_0) & XMC_USIC_CH_TXFIFO_EVENT_STANDARD) == 0)
 952:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      I2C_MASTER_ClearTXFIFOStatus(&I2C_MASTER_0, XMC_USIC_CH_TXFIFO_EVENT_STANDARD);
 953:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      I2C_MASTER_StartTransmitIRQ(&I2C_MASTER_0,true,SLAVE_ADDRESS,mem_address,6,false);
 954:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    }
 955:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    else
 956:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    {
 957:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      XMC_DEBUG("main: Application initialization failed");
 958:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      while(1U)
 959:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      {
 960:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      }
 961:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    }
 962:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    return 1U;
 963:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  }
 964:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @endcode
 965:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 966:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  */
 967:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** __STATIC_INLINE uint32_t I2C_MASTER_GetTXFIFOStatus(const I2C_MASTER_t* const handle)
 968:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** {
 969:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****   XMC_ASSERT("I2C_MASTER_GetTXFIFOStatus: invalid handle", (handle != NULL))
 970:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****   return XMC_USIC_CH_TXFIFO_GetEvent(handle->channel);
 971:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** }
 972:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** 
 973:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** /**
 974:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @brief Configures trigger limit for the transmit FIFO.
 975:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 976:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @param  handle I2C_MASTER APP handle pointer of type @ref I2C_MASTER_t
 977:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @param  size   FIFO size
 978:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @param  limit Value of transmit FIFO filling level, transition below which the interrupt should 
 979:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *               \bRange: 0 to transmit FIFO size.\n
 980:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *               e.g, If transmit FIFO size is 16, and limit is configured as 8, FIFO standard tran
 981:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *               will be generated when the FIFO filling level drops from 8 to 7.\n
 982:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 983:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @return None\n
 984:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 985:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * \par<b>Description:</b><br>
 986:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Transmit FIFO trigger limit is configured by setting its value in the TBCTR register.
 987:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Transmit FIFO is configured to generate interrupt when the FIFO filling level drops
 988:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * below the trigger limit.
 989:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 990:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Example Usage:
 991:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @code
 992:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 993:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
 994:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
 995:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  #define SLAVE_ADDRESS 0xA0
 996:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  uint8_t Send_Data[] = "Infineon Technologies";
 997:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  int main(void)
 998:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  {
 999:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    DAVE_STATUS_t init_status;
1000:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1001:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    init_status = DAVE_Init();
1002:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    if (init_status == DAVE_STATUS_SUCCESS)
1003:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    {
1004:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      //Configure transmit fifo trigger limit, draining level as 10
1005:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      I2C_MASTER_SetTXFIFOTriggerLimit(&I2C_MASTER_0, 16, 10);
1006:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      // Execution will happen two times in the interrupt handler as the limit is set to 10
1007:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      I2C_MASTER_Transmit(&I2C_MASTER_0, true, SLAVE_ADDRESS, Send_Data, 16, true);
1008:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      while(I2C_MASTER_IsTxBusy(&I2C_MASTER_0));
1009:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    }
1010:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    else
1011:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    {
1012:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      XMC_DEBUG("main: Application initialization failed");
1013:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      while(1U)
1014:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      {
1015:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      }
1016:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    }
1017:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    return 1U;
1018:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  }
1019:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1020:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @endcode
1021:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  */
1022:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** __STATIC_INLINE void I2C_MASTER_SetTXFIFOTriggerLimit(I2C_MASTER_t * const handle, const uint32_t s
1023:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** 		                                              const uint32_t limit)
1024:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** {
1025:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****   XMC_ASSERT("I2C_MASTER_SetTXFIFOTriggerLimit: invalid handle", (handle != NULL))
1026:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****   XMC_USIC_CH_TXFIFO_SetSizeTriggerLimit(handle->channel, (XMC_USIC_CH_FIFO_SIZE_t)size, limit);
1027:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** }
1028:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** /**
1029:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @brief Configures trigger limit for the receive FIFO.
1030:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1031:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @param  handle I2C_MASTER APP handle pointer of type @ref I2C_MASTER_t
1032:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @param  size   FIFO size
1033:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @param  limit Value of receive FIFO filling level, transition above which the interrupt should b
1034:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *               \bRange: 0 to receive FIFO size.\n
1035:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *               e.g, If receive FIFO size is 16, and limit is configured as 8, FIFO receive buffer
1036:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *               will be generated when the FIFO filling level rises from 8 to 9.\n
1037:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1038:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @return None\n
1039:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1040:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * \par<b>Description:</b><br>
1041:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Receive FIFO trigger limit is configured by setting its value in the RBCTR register.
1042:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Receive FIFO is configured to generate interrupt when the FIFO filling level rises
1043:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * above the trigger limit.
1044:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1045:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Example Usage:
1046:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @code
1047:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1048:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
1049:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1050:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  #define SLAVE_ADDRESS 0xA0
1051:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1052:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  uint8_t Rx_Data[256];
1053:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  int main(void)
1054:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  {
1055:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    DAVE_STATUS_t init_status;
1056:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1057:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    init_status = DAVE_Init();
1058:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    if (init_status == DAVE_STATUS_SUCCESS)
1059:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    {
1060:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      //Configure receive fifo trigger limit to filling level as 10
1061:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      I2C_MASTER_SetRXFIFOTriggerLimit(&I2C_MASTER_0, 16, 10);
1062:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      // Execution will happen two times in the receive interrupt handler as the limit is set to 
1063:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      I2C_MASTER_Receive(&I2C_MASTER_0, true, SLAVE_ADDRESS, Rx_Data, 16, true, true);
1064:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      while(I2C_MASTER_IsRxBusy(&I2C_MASTER_0));
1065:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    }
1066:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    else
1067:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    {
1068:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      XMC_DEBUG("main: Application initialization failed");
1069:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      while(1U)
1070:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      {
1071:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      }
1072:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    }
1073:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    return 1U;
1074:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  }
1075:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1076:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @endcode
1077:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  */
1078:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** __STATIC_INLINE void I2C_MASTER_SetRXFIFOTriggerLimit(I2C_MASTER_t * const handle, const uint32_t s
1079:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** 		                                              const uint32_t limit)
1080:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** {
1081:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****   XMC_ASSERT("I2C_MASTER_SetRXFIFOTriggerLimit: invalid handle", (handle != NULL))
1082:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****   XMC_USIC_CH_RXFIFO_SetSizeTriggerLimit(handle->channel, (XMC_USIC_CH_FIFO_SIZE_t)size, limit);
1083:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** }
1084:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** 
1085:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** /**
1086:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @brief Checks if the transmit FIFO is full.
1087:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1088:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @param  handle I2C_MASTER APP handle pointer of type @ref I2C_MASTER_t
1089:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1090:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @return bool Status of transmit FIFO filling level.
1091:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *              \bRange: \atrue- if transmit FIFO is full.<br>
1092:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *                       \afalse- if transmit FIFO is not full.<br>
1093:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * \par<b>Description:</b><br>
1094:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Checks the status using the register TRBSR. Can be used while filling
1095:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * data to the transmit FIFO.
1096:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * \par<b>NOTE: </b><br>: Transmit should be "Direct" mode in advanced settings tab.<br>
1097:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Example Usage:
1098:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1099:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @code
1100:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1101:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  #include <DAVE.h>                 //Declarations from DAVE Code Generation (includes SFR declar
1102:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  #define SLAVE_ADDRESS 0xA0
1103:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** 
1104:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1105:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  uint8_t send_data[] = "Infineon Technologies";
1106:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  int main(void)
1107:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  {
1108:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    DAVE_STATUS_t status;
1109:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    status = DAVE_Init();           // Initialization of DAVE APPs
1110:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1111:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    if (status == DAVE_STATUS_FAILURE)
1112:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    {
1113:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      XMC_DEBUG("DAVE APPs initialization failed\n");
1114:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1115:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      while(1U)
1116:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      {
1117:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      }
1118:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  }
1119:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  I2C_MASTER_Transmit(&I2C_MASTER_0, true, SLAVE_ADDRESS, &send_data[0], 10, false);
1120:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  //Wait when Tx FIFO is full
1121:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  while(!I2C_MASTER_IsTXFIFOFull(&I2C_MASTER_0))
1122:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  {
1123:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    I2C_MASTER_Transmit(&I2C_MASTER_0, false, SLAVE_ADDRESS, &send_data[0], 10, false);
1124:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  }
1125:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  while(1U)
1126:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  {
1127:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  }
1128:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * }
1129:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @endcode
1130:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  */
1131:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** __STATIC_INLINE bool I2C_MASTER_IsTXFIFOFull(const I2C_MASTER_t* const handle)
1132:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** {
1133:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****   XMC_ASSERT("I2C_MASTER_IsTXFIFOFull: invalid handle", (handle != NULL))
1134:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****   return XMC_USIC_CH_TXFIFO_IsFull(handle->channel);
1135:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** }
1136:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** 
1137:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** /**
1138:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @brief Checks if the receive FIFO is empty.
1139:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1140:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @param  handle I2C_MASTER APP handle pointer of type @ref I2C_MASTER_t
1141:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1142:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @return bool Status of receive FIFO filling level.
1143:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *              \bRange: \atrue- if receive FIFO is empty.<br>
1144:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *                       \afalse- if receive FIFO still has data.<br>
1145:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * \par<b>Description:</b><br>
1146:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Checks the status using the register TRBSR. Can be used while reading data from the receive FIFO
1147:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1148:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Example Usage:
1149:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @code
1150:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1151:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  #include <DAVE.h>                 //Declarations from DAVE Code Generation (includes SFR declar
1152:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  #define SLAVE_ADDRESS (0xA0)
1153:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  int main(void)
1154:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  {
1155:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    DAVE_STATUS_t init_status;
1156:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    uint8_t rec_data[64];
1157:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    uint8_t index = 0, loc_index = 0;
1158:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    init_status = DAVE_Init();
1159:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    if (init_status == DAVE_STATUS_SUCCESS)
1160:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    {
1161:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      I2C_MASTER_SendStart(&I2C_MASTER_0, SLAVE_ADDRESS, XMC_I2C_CH_CMD_WRITE);
1162:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      while(I2C_MASTER_GetFlagStatus(&I2C_MASTER_0, XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED) == 0U)
1163:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      {
1164:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *       // wait for ACK
1165:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      }
1166:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      I2C_MASTER_ClearFlag(&I2C_MASTER_0,XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED);
1167:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      // write to address 0
1168:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      I2C_MASTER_TransmitByte(&I2C_MASTER_0, 0x00);
1169:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      while(I2C_MASTER_GetFlagStatus(&I2C_MASTER_0, XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED) == 0U)
1170:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      {
1171:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *       // wait for ACK
1172:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      }
1173:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      I2C_MASTER_ClearFlag(&I2C_MASTER_0,XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED);
1174:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      I2C_MASTER_SendRepeatedStart(&I2C_MASTER_0, SLAVE_ADDRESS, XMC_I2C_CH_CMD_READ);
1175:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      while(I2C_MASTER_GetFlagStatus(&I2C_MASTER_0, XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED) == 0U)
1176:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      {
1177:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *       // wait for ACK
1178:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      }
1179:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      I2C_MASTER_ClearFlag(&I2C_MASTER_0,XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED);
1180:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      while(index < 16)
1181:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      {
1182:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *        I2C_MASTER_ReceiveACK(&I2C_MASTER_0);
1183:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *        index++;
1184:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      }
1185:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      //Wait when Rx FIFO is empty
1186:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      while(!I2C_MASTER_IsRXFIFOEmpty(&I2C_MASTER_0))
1187:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      {
1188:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *        rec_data[loc_index++] = I2C_MASTER_GetReceivedByte(&I2C_MASTER_0);
1189:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      }
1190:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    }
1191:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *   while(1U)
1192:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *   {
1193:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *   }
1194:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  }
1195:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @endcode
1196:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  */
1197:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** __STATIC_INLINE bool I2C_MASTER_IsRXFIFOEmpty(const I2C_MASTER_t* const handle)
1198:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** {
1199:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****   XMC_ASSERT("I2C_MASTER_IsRXFIFOEmpty: invalid handle", (handle != NULL))
1200:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****   return XMC_USIC_CH_RXFIFO_IsEmpty(handle->channel);
1201:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** }
1202:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** 
1203:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** /**
1204:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @brief Gets the status of event flags related to receive FIFO.
1205:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1206:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1207:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @param  handle I2C_MASTER APP handle pointer of type @ref I2C_MASTER_t
1208:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1209:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @return uint32_t: Status of standard receive buffer event, alternative receive buffer event and 
1210:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * error event in their bit positions in TRBSR register.\n
1211:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * \b Range: Use type @ref XMC_USIC_CH_RXFIFO_EVENT_t for event bitmasks. Multiple events' status c
1212:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * comparison using \a OR operation.
1213:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1214:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * \par<b>Description:</b><br>
1215:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * It provides the status of standard receive buffer event, alternative receive buffer event and re
1216:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * event.
1217:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Function masks the TRBSR register with the bitmask of SRBI, ARBI and RBERI flags. User has to ma
1218:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * interest before checking the status.
1219:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1220:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Example Usage:
1221:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @code
1222:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1223:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *   #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
1224:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *   #define SLAVE_ADDRESS 0xA0
1225:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *   uint8_t mem_address[2];
1226:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *   int main(void)
1227:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *   {
1228:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *     DAVE_STATUS_t init_status;
1229:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1230:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *     init_status = DAVE_Init();
1231:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *     if (init_status == DAVE_STATUS_SUCCESS)
1232:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *     {
1233:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *       mem_address[0] = 0x00;//memory which need to be read from slave
1234:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *       //Configure receive fifo trigger limit as 10
1235:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *       I2C_MASTER_SetRXFIFOTriggerLimit(&I2C_MASTER_0, 16, 10);
1236:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *       I2C_MASTER_StartTransmitIRQ(&I2C_MASTER_0,true,SLAVE_ADDRESS,mem_address,1,false);
1237:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *       while(I2C_MASTER_IsTxBusy(&I2C_MASTER_0));
1238:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *       I2C_MASTER_StartReceiveIRQ(&I2C_MASTER_0,true,SLAVE_ADDRESS,mem_address,16,true, true);
1239:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *       //Wait for FIFO transmit standard buffer interrupt to fill it again with remaining data
1240:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *       while((I2C_MASTER_GetRXFIFOStatus(&I2C_MASTER_0) & XMC_USIC_CH_RXFIFO_EVENT_STANDARD) == 0
1241:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *       I2C_MASTER_ClearRXFIFOStatus(&I2C_MASTER_0, XMC_USIC_CH_RXFIFO_EVENT_STANDARD);
1242:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *       I2C_MASTER_StartReceiveIRQ(&I2C_MASTER_0,true,SLAVE_ADDRESS,mem_address,6,false, false);
1243:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *     }
1244:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *     else
1245:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *     {
1246:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      XMC_DEBUG("main: Application initialization failed");
1247:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      while(1U)
1248:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      {
1249:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      }
1250:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *     }
1251:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      return 1U;
1252:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *   }
1253:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @endcode
1254:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1255:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  */
1256:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** __STATIC_INLINE uint32_t I2C_MASTER_GetRXFIFOStatus(const I2C_MASTER_t* const handle)
1257:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** {
1258:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****   XMC_ASSERT("I2C_MASTER_GetRXFIFOStatus: invalid handle", (handle != NULL))
1259:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****   return XMC_USIC_CH_RXFIFO_GetEvent(handle->channel);
1260:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** }
1261:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** 
1262:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** /**
1263:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @brief Function clears the specified FIFO event flag related to
1264:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * transmit FIFO.
1265:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1266:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1267:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @param  handle I2C_MASTER APP handle pointer of type @ref I2C_MASTER_t
1268:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @param  flag Value with event bits at their bit positions in TRBSR register to be cleared.\n
1269:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *             \b Range: Use type @ref XMC_USIC_CH_TXFIFO_EVENT_t. Multiple events can be combined 
1270:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *             \a OR operation.
1271:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1272:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @return    None
1273:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1274:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * \par<b>Description:</b><br>
1275:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Function clears a status bit in TRBSR register using the TRBSCR register. But the function does 
1276:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * value with the bit positions restricted to transmit FIFO status bits. User should ensure that th
1277:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * appropriately masked.
1278:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1279:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Example Usage:
1280:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @code
1281:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1282:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
1283:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  #define SLAVE_ADDRESS 0xA0
1284:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  uint8_t mem_address[2];
1285:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  int main(void)
1286:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  {
1287:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    DAVE_STATUS_t init_status;
1288:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1289:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    init_status = DAVE_Init();
1290:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    if (init_status == DAVE_STATUS_SUCCESS)
1291:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    {
1292:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      mem_address[0] = 0x00; //memory which need to be read from slave
1293:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      //Configure transmit fifo trigger limit as 10
1294:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      I2C_MASTER_SetTXFIFOTriggerLimit(&I2C_MASTER_0, 16, 10);
1295:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      I2C_MASTER_StartTransmitIRQ(&I2C_MASTER_0,true,SLAVE_ADDRESS,mem_address,1,false);
1296:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      while(I2C_MASTER_IsTxBusy(&I2C_MASTER_0));
1297:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      I2C_MASTER_StartTransmitIRQ(&I2C_MASTER_0,true,SLAVE_ADDRESS,mem_address,16,false);
1298:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      //Wait for FIFO transmit standard buffer interrupt to fill it again with remaining data
1299:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      while((I2C_MASTER_GetTXFIFOStatus(&I2C_MASTER_0) & XMC_USIC_CH_TXFIFO_EVENT_STANDARD) == 0)
1300:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      I2C_MASTER_ClearTXFIFOStatus(&I2C_MASTER_0, XMC_USIC_CH_TXFIFO_EVENT_STANDARD);
1301:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      I2C_MASTER_StartTransmitIRQ(&I2C_MASTER_0,true,SLAVE_ADDRESS,mem_address,6,false);
1302:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    }
1303:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    else
1304:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    {
1305:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      XMC_DEBUG("main: Application initialization failed");
1306:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      while(1U)
1307:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      {
1308:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      }
1309:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    }
1310:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    return 1U;
1311:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  }
1312:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @endcode
1313:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1314:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  */
1315:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** __STATIC_INLINE void I2C_MASTER_ClearTXFIFOStatus(const I2C_MASTER_t* const handle, const uint32_t 
1316:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** {
1317:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****   XMC_ASSERT("I2C_MASTER_ClearTXFIFOStatus: invalid handle", (handle != NULL))
1318:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****   XMC_USIC_CH_TXFIFO_ClearEvent(handle->channel, flag);
1319:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** }
1320:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** 
1321:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** /**
1322:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @brief Function clears the specified FIFO event flag related to receive FIFO. It should be used 
1323:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * of standard receive buffer interrupt, alternative receive buffer interrupt and receive buffer er
1324:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1325:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1326:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @param  handle I2C_MASTER APP handle pointer of type @ref I2C_MASTER_t
1327:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @param  flag Value with event bits at the bit positions in TRBSR register to be cleared.\n
1328:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *             \b Range: Use type @ref XMC_USIC_CH_RXFIFO_EVENT_t for providing events.
1329:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *             Multiple events can be input by using \a OR operation.
1330:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1331:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @return    None
1332:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1333:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * \par<b>Description:</b><br>
1334:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Function clears a status bit in TRBSR using the TRBSCR register.
1335:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * The function does not mask the input value to clear only receive buffer
1336:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * events. So user should appropriately mask the input value before calling
1337:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * the function.
1338:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1339:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Example Usage:
1340:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @code
1341:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1342:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
1343:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  #define SLAVE_ADDRESS 0xA0
1344:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  uint8_t mem_address[2];
1345:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  int main(void)
1346:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  {
1347:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    DAVE_STATUS_t init_status;
1348:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1349:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    init_status = DAVE_Init();
1350:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    if (init_status == DAVE_STATUS_SUCCESS)
1351:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    {
1352:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      mem_address[0] = 0x00;//memory which need to be read from slave
1353:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      //Configure receive fifo trigger limit as 10
1354:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      I2C_MASTER_SetRXFIFOTriggerLimit(&I2C_MASTER_0, 16, 10);
1355:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      I2C_MASTER_StartTransmitIRQ(&I2C_MASTER_0,true,SLAVE_ADDRESS,mem_address,1,false);
1356:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      while(I2C_MASTER_IsTxBusy(&I2C_MASTER_0));
1357:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      I2C_MASTER_StartReceiveIRQ(&I2C_MASTER_0,true,SLAVE_ADDRESS,mem_address,16,true, true);
1358:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      //Wait for FIFO transmit standard buffer interrupt to fill it again with remaining data
1359:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      while((I2C_MASTER_GetRXFIFOStatus(&I2C_MASTER_0) & XMC_USIC_CH_RXFIFO_EVENT_STANDARD) == 0)
1360:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      I2C_MASTER_ClearRXFIFOStatus(&I2C_MASTER_0, XMC_USIC_CH_RXFIFO_EVENT_STANDARD);
1361:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      I2C_MASTER_StartReceiveIRQ(&I2C_MASTER_0,true,SLAVE_ADDRESS,mem_address,6,false, false);
1362:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    }
1363:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    else
1364:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    {
1365:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      XMC_DEBUG("main: Application initialization failed");
1366:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      while(1U)
1367:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      {
1368:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      }
1369:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    }
1370:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    return 1U;
1371:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  }
1372:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @endcode
1373:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1374:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  */
1375:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** __STATIC_INLINE void I2C_MASTER_ClearRXFIFOStatus(const I2C_MASTER_t* const handle, const uint32_t 
1376:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** {
1377:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****   XMC_ASSERT("I2C_MASTER_ClearRXFIFOStatus: invalid handle", (handle != NULL))
1378:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****   XMC_USIC_CH_RXFIFO_ClearEvent(handle->channel, flag);
1379:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** }
1380:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** 
1381:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** /**
1382:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @brief Provides the received data from receive buffer.
1383:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1384:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @param  handle I2C_MASTER APP handle pointer of type @ref I2C_MASTER_t
1385:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @return uint8_t: Data read from RBUF.\n
1386:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1387:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * \par<b>Description:</b><br>
1388:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * This can be used in receive mode "Direct" to read the received data.
1389:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * If Rx FIFO is not configured, function reads the value of RBUF register.
1390:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Otherwise it reads the data from OUTR register.
1391:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Example Usage:
1392:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @code
1393:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1394:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
1395:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  #define SLAVE_ADDRESS 0xA0
1396:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  int main(void)
1397:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  {
1398:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    DAVE_STATUS_t init_status;
1399:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    uint8_t rec_data[10];
1400:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    uint8_t index = 0,loc_index = 0;
1401:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1402:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    init_status = DAVE_Init();
1403:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    if (init_status == DAVE_STATUS_SUCCESS)
1404:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    {
1405:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      I2C_MASTER_SendStart(&I2C_MASTER_0, SLAVE_ADDRESS, XMC_I2C_CH_CMD_WRITE);
1406:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      while(I2C_MASTER_GetFlagStatus(&I2C_MASTER_0, XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED) == 0U)
1407:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      {
1408:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *       // wait for ACK
1409:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      }
1410:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      I2C_MASTER_ClearFlag(&I2C_MASTER_0,XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED);
1411:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      // write to address 0
1412:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      I2C_MASTER_TransmitByte(&I2C_MASTER_0, 0x00);
1413:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      while(I2C_MASTER_GetFlagStatus(&I2C_MASTER_0, XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED) == 0U)
1414:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      {
1415:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *       // wait for ACK
1416:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      }
1417:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      I2C_MASTER_ClearFlag(&I2C_MASTER_0,XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED);
1418:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      I2C_MASTER_SendRepeatedStart(&I2C_MASTER_0, SLAVE_ADDRESS, XMC_I2C_CH_CMD_READ);
1419:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      while(I2C_MASTER_GetFlagStatus(&I2C_MASTER_0, XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED) == 0U)
1420:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      {
1421:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *        // wait for ACK
1422:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      }
1423:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      I2C_MASTER_ClearFlag(&I2C_MASTER_0,XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED);
1424:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      while(index < 16)
1425:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      {
1426:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *        I2C_MASTER_ReceiveACK(&I2C_MASTER_0);
1427:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *         index++;
1428:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      }
1429:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      //Wait when Rx FIFO is empty
1430:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      while(!I2C_MASTER_IsRXFIFOEmpty(&I2C_MASTER_0))
1431:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      {
1432:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *        rec_data[loc_index++] = I2C_MASTER_GetReceivedByte(&I2C_MASTER_0);
1433:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      }
1434:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    }
1435:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    else
1436:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    {
1437:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      XMC_DEBUG("main: Application initialization failed");
1438:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      while(1U)
1439:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      {
1440:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      }
1441:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    }
1442:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    return 1U;
1443:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  }
1444:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @endcode
1445:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1446:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  */
1447:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** /* Wrapper to the LLD API for reading back the value of the RBUF or OUTR register */
1448:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** __STATIC_INLINE uint8_t I2C_MASTER_GetReceivedByte(I2C_MASTER_t * const handle)
1449:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** {
1450:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****   XMC_ASSERT("I2C_MASTER_GetReceivedByte: invalid handle", (handle != NULL))
1451:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****   return (uint8_t)XMC_I2C_CH_GetReceivedData(handle->channel);
1452:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** }
1453:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** 
1454:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** /**
1455:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @brief Transmits single byte using I2C protocol.
1456:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1457:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @param  handle I2C_MASTER APP handle pointer of type @ref I2C_MASTER_t
1458:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @param  byte data byte to transmit. \n
1459:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @return None\n
1460:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * 
1461:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Example Usage:
1462:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1463:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @code
1464:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1465:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  #include <DAVE.h>                 //Declarations from DAVE Code Generation (includes SFR declar
1466:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  #define SLAVE_ADDRESS 0xA0
1467:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1468:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  int main(void)
1469:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  {
1470:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    DAVE_STATUS_t status;
1471:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1472:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    status = DAVE_Init();
1473:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1474:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    if (status == DAVE_STATUS_FAILURE)
1475:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    {
1476:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      XMC_DEBUG("DAVE APPs initialization failed\n");
1477:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1478:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      while(1U)
1479:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      {
1480:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1481:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      }
1482:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    }
1483:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    I2C_MASTER_SendStart(&I2C_MASTER_0, SLAVE_ADDRESS, XMC_I2C_CH_CMD_WRITE);
1484:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    while(I2C_MASTER_GetFlagStatus(&I2C_MASTER_0, XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED) == 0U)
1485:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    {
1486:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      // wait for ACK
1487:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    }
1488:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    I2C_MASTER_ClearFlag(&I2C_MASTER_0,XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED);
1489:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    I2C_MASTER_TransmitByte(&I2C_MASTER_0, 0x00);
1490:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    while(I2C_MASTER_GetFlagStatus(&I2C_MASTER_0, XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED) == 0U)
1491:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    {
1492:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      // wait for ACK
1493:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    }
1494:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    I2C_MASTER_ClearFlag(&I2C_MASTER_0,XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED);
1495:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    while(1U)
1496:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    {
1497:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    }
1498:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  }
1499:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @endcode
1500:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  */
1501:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** __STATIC_INLINE void I2C_MASTER_TransmitByte(I2C_MASTER_t * const handle, uint8_t byte)
1502:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** {
1503:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****   XMC_ASSERT("I2C_MASTER_TransmitByte: invalid handle", (handle != NULL))
1504:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****   XMC_I2C_CH_MasterTransmit(handle->channel, byte);
 266              	 .loc 4 1504 0
 267 006c 16F8011B 	 ldrb r1,[r6],#1
 268              	.LVL21:
 269 0070 FFF7FEFF 	 bl XMC_I2C_CH_MasterTransmit
 270              	.LVL22:
 271 0074 2868     	 ldr r0,[r5]
 272              	.LBE249:
 273              	.LBE248:
 274              	.LBB250:
 275              	.LBB247:
 276              	.LBB246:
 277              	 .loc 3 1615 0
 278 0076 D0F81431 	 ldr r3,[r0,#276]
 279              	.LBE246:
 280              	.LBE247:
 281              	.LBE250:
1633:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         {
 282              	 .loc 1 1633 0
 283 007a D904     	 lsls r1,r3,#19
1637:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           {
1638:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****             /* load the FIFO, byte by byte till either FIFO is full or all data is loaded*/
1639:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****             I2C_MASTER_TransmitByte(handle, data[buffer_index]);
1640:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****             buffer_index++;
 284              	 .loc 1 1640 0
 285 007c 04F10104 	 add r4,r4,#1
 286              	.LVL23:
1633:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         {
 287              	 .loc 1 1633 0
 288 0080 F2D5     	 bpl .L42
 289              	.L52:
1630:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       {
 290              	 .loc 1 1630 0
 291 0082 A742     	 cmp r7,r4
1633:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         {
 292              	 .loc 1 1633 0
 293 0084 0246     	 mov r2,r0
1630:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       {
 294              	 .loc 1 1630 0
 295 0086 E6D8     	 bhi .L30
 296              	.LVL24:
 297              	.L46:
 298              	.LBB251:
 299              	.LBB252:
1616:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** }
1617:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
1618:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
1619:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param channel Pointer to USIC channel handler of type @ref XMC_USIC_CH_t \n
1620:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				   \b Range: @ref XMC_USIC0_CH0, @ref XMC_USIC0_CH1 to @ref XMC_USIC2_CH1 based on device su
1621:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @return Status \a true if transmit FIFO is empty
1622:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *              \a false if transmit FIFO has some data.
1623:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
1624:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Description</b><br>
1625:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Checks if transmit FIFO is empty. \n\n
1626:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * When the transmit FIFO is empty, data can be written to FIFO.
1627:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * When the last written word to the transmit FIFO is transmitted out of the FIFO, 
1628:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * FIFO empty flag is set.
1629:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 
1630:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Related APIs:</b><BR>
1631:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * XMC_USIC_CH_TXFIFO_Flush(), XMC_USIC_CH_TXFIFO_PutData() \n\n\n
1632:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
1633:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** __STATIC_INLINE bool XMC_USIC_CH_TXFIFO_IsEmpty(XMC_USIC_CH_t *const channel)
1634:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
1635:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   return (bool)(channel->TRBSR & USIC_CH_TRBSR_TEMPTY_Msk);
 300              	 .loc 3 1635 0
 301 0088 D0F81431 	 ldr r3,[r0,#276]
 302              	.LBE252:
 303              	.LBE251:
1641:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           }
1642:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           else
1643:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           {
1644:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****             break;
1645:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           }
1646:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         }
1647:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       }
1648:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       /*make sure data is transmitted from FIFO*/
1649:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       while (!XMC_USIC_CH_TXFIFO_IsEmpty(handle->channel)){}
 304              	 .loc 1 1649 0
 305 008c 1B05     	 lsls r3,r3,#20
 306 008e FBD5     	 bpl .L46
 307              	.LVL25:
 308              	.L40:
1650:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     }
1651:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1652:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     if (send_stop == true)
 309              	 .loc 1 1652 0
 310 0090 B8F1000F 	 cmp r8,#0
 311 0094 40F09480 	 bne .L106
1653:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     {
1654:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       handle->runtime->bus_acquired = false;
1655:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       I2C_MASTER_SendStop(handle);
1656:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     }
1657:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1658:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     status = I2C_MASTER_STATUS_SUCCESS;
 312              	 .loc 1 1658 0
 313 0098 4046     	 mov r0,r8
 314              	.LVL26:
 315 009a BDE8F087 	 pop {r4,r5,r6,r7,r8,r9,r10,pc}
 316              	.LVL27:
 317              	.L24:
1536:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     	    {
 318              	 .loc 1 1536 0
 319 009e 9006     	 lsls r0,r2,#26
 320 00a0 03D5     	 bpl .L26
 321              	.LVL28:
 322              	.LBB253:
 323              	.LBB254:
 324              	.LBB255:
 325              	 .loc 2 674 0
 326 00a2 D96C     	 ldr r1,[r3,#76]
 327 00a4 41F02001 	 orr r1,r1,#32
 328 00a8 D964     	 str r1,[r3,#76]
 329              	.LVL29:
 330              	.L26:
 331              	.LBE255:
 332              	.LBE254:
 333              	.LBE253:
1542:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     	    {
 334              	 .loc 1 1542 0
 335 00aa 5106     	 lsls r1,r2,#25
 336 00ac 03D5     	 bpl .L27
 337              	.LVL30:
 338              	.LBB256:
 339              	.LBB257:
 340              	.LBB258:
 341              	 .loc 2 674 0
 342 00ae D96C     	 ldr r1,[r3,#76]
 343 00b0 41F04001 	 orr r1,r1,#64
 344 00b4 D964     	 str r1,[r3,#76]
 345              	.LVL31:
 346              	.L27:
 347              	.LBE258:
 348              	.LBE257:
 349              	.LBE256:
1548:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     	    {
 350              	 .loc 1 1548 0
 351 00b6 12F4817F 	 tst r2,#258
 352 00ba 03D0     	 beq .L103
 353              	.LVL32:
 354              	.LBB259:
 355              	.LBB260:
 356              	.LBB261:
 357              	 .loc 2 674 0
 358 00bc DA6C     	 ldr r2,[r3,#76]
 359 00be 42F48072 	 orr r2,r2,#256
 360 00c2 DA64     	 str r2,[r3,#76]
 361              	.LVL33:
 362              	.L103:
 363              	.LBE261:
 364              	.LBE260:
 365              	.LBE259:
1554:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           }
 366              	 .loc 1 1554 0
 367 00c4 0120     	 movs r0,#1
 368 00c6 BDE8F087 	 pop {r4,r5,r6,r7,r8,r9,r10,pc}
 369              	.LVL34:
 370              	.L53:
1636:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           {
 371              	 .loc 1 1636 0
 372 00ca 0246     	 mov r2,r0
 373              	.LVL35:
 374 00cc DCE7     	 b .L46
 375              	.LVL36:
 376              	.L15:
1570:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     {
 377              	 .loc 1 1570 0
 378 00ce 90F82630 	 ldrb r3,[r0,#38]
 379 00d2 002B     	 cmp r3,#0
 380 00d4 3FD0     	 beq .L47
 381 00d6 2868     	 ldr r0,[r5]
 382 00d8 BCE7     	 b .L48
 383              	.LVL37:
 384              	.L50:
 385 00da 0246     	 mov r2,r0
 386              	.L29:
 387 00dc 484E     	 ldr r6,.L112
1578:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         psr_status = 0;
 388              	 .loc 1 1578 0
 389 00de 494C     	 ldr r4,.L112+4
 390 00e0 4F44     	 add r7,r7,r9
 391              	.LVL38:
 392 00e2 B246     	 mov r10,r6
 393              	.LVL39:
 394              	.L39:
 395              	.LBB262:
 396              	.LBB263:
 397              	 .loc 4 1504 0
 398 00e4 1046     	 mov r0,r2
 399 00e6 19F8011B 	 ldrb r1,[r9],#1
 400              	.LVL40:
 401 00ea FFF7FEFF 	 bl XMC_I2C_CH_MasterTransmit
 402              	.LVL41:
 403              	.LBE263:
 404              	.LBE262:
 405              	.LBB264:
 406              	.LBB265:
 211:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 407              	 .loc 1 211 0
 408 00ee 2A68     	 ldr r2,[r5]
 409              	.LBE265:
 410              	.LBE264:
1578:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         psr_status = 0;
 411              	 .loc 1 1578 0
 412 00f0 3460     	 str r4,[r6]
 413              	.LVL42:
 414              	.LBB272:
 415              	.LBB270:
 416              	.LBB266:
 417              	.LBB267:
 658:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** }
 418              	 .loc 2 658 0
 419 00f2 936C     	 ldr r3,[r2,#72]
 420              	.LBE267:
 421              	.LBE266:
 422              	.LBE270:
 423              	.LBE272:
1580:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         {
 424              	 .loc 1 1580 0
 425 00f4 9B05     	 lsls r3,r3,#22
 426 00f6 0AD5     	 bpl .L31
 427 00f8 0DE0     	 b .L33
 428              	.LVL43:
 429              	.L108:
 430              	.LBB273:
 431              	.LBB274:
 658:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** }
 432              	 .loc 2 658 0
 433 00fa 936C     	 ldr r3,[r2,#72]
 434              	.LBE274:
 435              	.LBE273:
1586:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****                             (uint32_t)XMC_I2C_CH_STATUS_FLAG_ARBITRATION_LOST |
 436              	 .loc 1 1586 0
 437 00fc 13F4B17F 	 tst r3,#354
 438 0100 13D1     	 bne .L107
 439              	.LVL44:
1613:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         }
 440              	 .loc 1 1613 0
 441 0102 3368     	 ldr r3,[r6]
 442 0104 013B     	 subs r3,r3,#1
 443 0106 3360     	 str r3,[r6]
 444              	.LBB275:
 445              	.LBB271:
 446              	.LBB269:
 447              	.LBB268:
 658:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** }
 448              	 .loc 2 658 0
 449 0108 936C     	 ldr r3,[r2,#72]
 450              	.LBE268:
 451              	.LBE269:
 452              	.LBE271:
 453              	.LBE275:
1580:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         {
 454              	 .loc 1 1580 0
 455 010a 9805     	 lsls r0,r3,#22
 456 010c 03D4     	 bmi .L33
 457              	.LVL45:
 458              	.L31:
 459 010e DAF80030 	 ldr r3,[r10]
 460 0112 002B     	 cmp r3,#0
 461 0114 F1D1     	 bne .L108
 462              	.L33:
1617:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         {
 463              	 .loc 1 1617 0
 464 0116 3368     	 ldr r3,[r6]
 465 0118 002B     	 cmp r3,#0
 466 011a 4ED0     	 beq .L21
 467              	.LVL46:
 468              	.LBB276:
 469              	.LBB277:
 470              	.LBB278:
 471              	 .loc 2 674 0
 472 011c D36C     	 ldr r3,[r2,#76]
 473              	.LBE278:
 474              	.LBE277:
 475              	.LBE276:
1573:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       {
 476              	 .loc 1 1573 0
 477 011e B945     	 cmp r9,r7
 478              	.LBB281:
 479              	.LBB280:
 480              	.LBB279:
 481              	 .loc 2 674 0
 482 0120 43F40073 	 orr r3,r3,#512
 483 0124 D364     	 str r3,[r2,#76]
 484              	.LVL47:
 485              	.LBE279:
 486              	.LBE280:
 487              	.LBE281:
1573:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       {
 488              	 .loc 1 1573 0
 489 0126 DDD1     	 bne .L39
 490 0128 B2E7     	 b .L40
 491              	.LVL48:
 492              	.L107:
1592:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 	        {
 493              	 .loc 1 1592 0
 494 012a 9D06     	 lsls r5,r3,#26
 495              	.LVL49:
 496 012c 03D5     	 bpl .L36
 497              	.LVL50:
 498              	.LBB282:
 499              	.LBB283:
 500              	.LBB284:
 501              	 .loc 2 674 0
 502 012e D16C     	 ldr r1,[r2,#76]
 503 0130 41F02001 	 orr r1,r1,#32
 504 0134 D164     	 str r1,[r2,#76]
 505              	.LVL51:
 506              	.L36:
 507              	.LBE284:
 508              	.LBE283:
 509              	.LBE282:
1598:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 	        {
 510              	 .loc 1 1598 0
 511 0136 5C06     	 lsls r4,r3,#25
 512 0138 03D5     	 bpl .L37
 513              	.LVL52:
 514              	.LBB285:
 515              	.LBB286:
 516              	.LBB287:
 517              	 .loc 2 674 0
 518 013a D16C     	 ldr r1,[r2,#76]
 519 013c 41F04001 	 orr r1,r1,#64
 520 0140 D164     	 str r1,[r2,#76]
 521              	.LVL53:
 522              	.L37:
 523              	.LBE287:
 524              	.LBE286:
 525              	.LBE285:
1604:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 	        {
 526              	 .loc 1 1604 0
 527 0142 13F4817F 	 tst r3,#258
 528 0146 BDD0     	 beq .L103
 529              	.LVL54:
 530              	.LBB288:
 531              	.LBB289:
 532              	.LBB290:
 533              	 .loc 2 674 0
 534 0148 D36C     	 ldr r3,[r2,#76]
 535 014a 43F48073 	 orr r3,r3,#256
 536 014e D364     	 str r3,[r2,#76]
 537              	.LBE290:
 538              	.LBE289:
 539              	.LBE288:
1610:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****           }
 540              	 .loc 1 1610 0
 541 0150 0120     	 movs r0,#1
 542 0152 BDE8F087 	 pop {r4,r5,r6,r7,r8,r9,r10,pc}
 543              	.LVL55:
 544              	.L47:
 545 0156 2A68     	 ldr r2,[r5]
 546              	.LVL56:
 547 0158 C0E7     	 b .L29
 548              	.LVL57:
 549              	.L16:
 550              	.LBB291:
 551              	.LBB292:
 738:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
 552              	 .loc 1 738 0
 553 015a 91F82830 	 ldrb r3,[r1,#40]
 554 015e 03F0FF06 	 and r6,r3,#255
 555 0162 002B     	 cmp r3,#0
 556 0164 3BD1     	 bne .L109
 557 0166 2868     	 ldr r0,[r5]
 558              	.LVL58:
 744:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     I2C_MASTER_SendStart(handle, (uint16_t)address, cmd);
 559              	 .loc 1 744 0
 560 0168 0123     	 movs r3,#1
 561 016a 81F82830 	 strb r3,[r1,#40]
 562              	.LBB293:
 563              	.LBB294:
 564              	.LBB295:
 565              	.LBB296:
 566              	 .loc 2 674 0
 567 016e C36C     	 ldr r3,[r0,#76]
 568 0170 43F00403 	 orr r3,r3,#4
 569              	.LBE296:
 570              	.LBE295:
1505:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** }
1506:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** /**
1507:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @brief Enables the selected protocol events for interrupt generation.
1508:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1509:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @param  handle I2C_MASTER APP handle pointer of type @ref I2C_MASTER_t
1510:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @param  event  Protocol events to be enabled for interrupt generation. \n
1511:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *         \bRange: Use type \aXMC_I2C_CH_EVENT_t to select the event. Multiple events can be
1512:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *         combined using the bitwise OR operation.\n
1513:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @return None\n
1514:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1515:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * \par<b>Description:</b><br>
1516:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Enables the events by configuring CCR or PCR register based on the event.
1517:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * When the event is enabled, an interrupt can be generated on occurrence of the event.
1518:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * The API should be used only for \a Direct mode related events. Using this API for non \a Direct 
1519:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * may not yield expected result.
1520:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1521:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Example Usage:
1522:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @code
1523:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1524:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  #include <DAVE.h>                 //Declarations from DAVE Code Generation (includes SFR declar
1525:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1526:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  int main(void)
1527:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  {
1528:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    DAVE_STATUS_t status;
1529:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1530:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    status = DAVE_Init();
1531:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1532:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    if (status == DAVE_STATUS_FAILURE)
1533:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    {
1534:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      XMC_DEBUG("DAVE APPs initialization failed\n");
1535:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1536:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      while(1U)
1537:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      {
1538:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1539:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      }
1540:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    }
1541:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    I2C_MASTER_EnableEvent(&I2C_MASTER_0, XMC_I2C_CH_EVENT_NACK);
1542:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    while(1U)
1543:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    {
1544:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    }
1545:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  }
1546:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @endcode
1547:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  */
1548:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** __STATIC_INLINE void I2C_MASTER_EnableEvent(I2C_MASTER_t * const handle, uint32_t event)
1549:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** {
1550:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****   XMC_ASSERT("I2C_MASTER_EnableEvent: invalid handle", (handle != NULL))
1551:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****   XMC_I2C_CH_EnableEvent(handle->channel, event);
1552:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** }
1553:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** /**
1554:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @brief Disables selected events from generating interrupt.
1555:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1556:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @param  handle I2C_MASTER APP handle pointer of type @ref I2C_MASTER_t
1557:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @param  event  Events to be disabled from generating interrupt. \n
1558:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *         \bRange: Use type \aXMC_I2C_CH_EVENT_t to select the event. Multiple events can be
1559:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *         combined using the bitwise OR operation.\n
1560:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @return None
1561:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1562:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * \par<b>Description:</b><br>
1563:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Events are disabled by clearing their respective bits in either CCR, TBCTR or RBCTR.
1564:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1565:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Example Usage:
1566:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @code
1567:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1568:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  #include <DAVE.h>                 //Declarations from DAVE Code Generation (includes SFR declar
1569:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1570:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  int main(void)
1571:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  {
1572:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    DAVE_STATUS_t status;
1573:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1574:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    status = DAVE_Init();
1575:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1576:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    if (status == DAVE_STATUS_FAILURE)
1577:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    {
1578:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      XMC_DEBUG("DAVE APPs initialization failed\n");
1579:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1580:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      while(1U)
1581:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      {
1582:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1583:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      }
1584:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    }
1585:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    I2C_MASTER_DisableEvent(&I2C_MASTER_0, XMC_I2C_CH_EVENT_NACK);
1586:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    while(1U)
1587:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    {
1588:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    }
1589:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  }
1590:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @endcode
1591:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1592:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  */
1593:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** __STATIC_INLINE void I2C_MASTER_DisableEvent(I2C_MASTER_t * const handle, uint32_t event)
1594:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** {
1595:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****   XMC_ASSERT("I2C_MASTER_DisableEvent: invalid handle", (handle != NULL))
1596:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****   XMC_I2C_CH_DisableEvent(handle->channel, event);
1597:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** }
1598:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** 
1599:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** /**
1600:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @brief Receives the ACK from slave
1601:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @param handle  I2C_MASTER APP handle pointer of type @ref I2C_MASTER_t
1602:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @return None
1603:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1604:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * \par<b>Description:</b><br>
1605:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * After transmitting a byte, master receives the ack from slave.<br>
1606:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Pre-requisite: Instantiate I2C_MASTER APP and generate code before using below code snippet.
1607:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1608:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Example Usage:
1609:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @code
1610:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1611:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
1612:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  #define SLAVE_ADDRESS 0xA0
1613:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1614:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  int main(void)
1615:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  {
1616:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    DAVE_STATUS_t init_status;
1617:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    uint8_t index = 0, loc_index = 0;
1618:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    uint8_t rec_data[64];
1619:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    init_status = DAVE_Init();
1620:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    if (init_status == DAVE_STATUS_SUCCESS)
1621:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    {
1622:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      I2C_MASTER_SendStart(&I2C_MASTER_0, SLAVE_ADDRESS, XMC_I2C_CH_CMD_WRITE);
1623:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      while(I2C_MASTER_GetFlagStatus(&I2C_MASTER_0, XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED) == 0U)
1624:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      {
1625:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *       // wait for ACK
1626:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      }
1627:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      I2C_MASTER_ClearFlag(&I2C_MASTER_0,XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED);
1628:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      // write to address 0
1629:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      I2C_MASTER_TransmitByte(&I2C_MASTER_0, 0x00);
1630:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      while(I2C_MASTER_GetFlagStatus(&I2C_MASTER_0, XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED) == 0U)
1631:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      {
1632:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *       // wait for ACK
1633:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      }
1634:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      I2C_MASTER_ClearFlag(&I2C_MASTER_0,XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED);
1635:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      I2C_MASTER_SendRepeatedStart(&I2C_MASTER_0, SLAVE_ADDRESS, XMC_I2C_CH_CMD_READ);
1636:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      while(I2C_MASTER_GetFlagStatus(&I2C_MASTER_0, XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED) == 0U)
1637:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      {
1638:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *       // wait for ACK
1639:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      }
1640:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      I2C_MASTER_ClearFlag(&I2C_MASTER_0,XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED);
1641:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      while(index < 16)
1642:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      {
1643:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *        I2C_MASTER_ReceiveACK(&I2C_MASTER_0);
1644:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *        index++;
1645:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      }
1646:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      //Wait when Rx FIFO is empty
1647:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      while(!I2C_MASTER_IsRXFIFOEmpty(&I2C_MASTER_0))
1648:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      {
1649:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *        rec_data[loc_index++] = I2C_MASTER_GetReceivedByte(&I2C_MASTER_0);
1650:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      }
1651:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    }
1652:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    else
1653:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    {
1654:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      XMC_DEBUG("main: Application initialization failed");
1655:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      while(1U)
1656:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      {
1657:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      }
1658:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    }
1659:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    return 1U;
1660:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  }
1661:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @endcode
1662:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** */
1663:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** __STATIC_INLINE void I2C_MASTER_ReceiveACK(I2C_MASTER_t * const handle)
1664:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** {
1665:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****   XMC_ASSERT("I2C_MASTER_ReceiveACK: invalid handle", (handle != NULL))
1666:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****   XMC_I2C_CH_MasterReceiveAck(handle->channel);
1667:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** }
1668:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** /**
1669:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @brief Receives the NACK from slave
1670:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @param handle  I2C_MASTER APP handle pointer of type @ref I2C_MASTER_t
1671:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @return None
1672:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1673:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * \par<b>Description:</b><br>
1674:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * After transmitting a byte, master receives the nack from slave.<br>
1675:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Pre-requisite: Instantiate I2C_MASTER APP and generate code before using below code snippet.
1676:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1677:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Example Usage:
1678:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @code
1679:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1680:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
1681:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  #define SLAVE_ADDRESS (0xA0)
1682:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  int main(void)
1683:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  {
1684:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    DAVE_STATUS_t init_status;
1685:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    uint32_t index = 0, loc_index = 0;
1686:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    uint8_t rec_data[64];
1687:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    init_status = DAVE_Init();
1688:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    if (init_status == DAVE_STATUS_SUCCESS)
1689:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    {
1690:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      I2C_MASTER_SendStart(&I2C_MASTER_0, SLAVE_ADDRESS, XMC_I2C_CH_CMD_WRITE);
1691:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      while(I2C_MASTER_GetFlagStatus(&I2C_MASTER_0, XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED) == 0U)
1692:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      {
1693:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *       // wait for ACK
1694:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      }
1695:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      I2C_MASTER_ClearFlag(&I2C_MASTER_0,XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED);
1696:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      // write to address 0
1697:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      I2C_MASTER_TransmitByte(&I2C_MASTER_0, 0x00);
1698:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      while(I2C_MASTER_GetFlagStatus(&I2C_MASTER_0, XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED) == 0U)
1699:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      {
1700:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *       // wait for ACK
1701:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      }
1702:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      I2C_MASTER_ClearFlag(&I2C_MASTER_0,XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED);
1703:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      I2C_MASTER_SendRepeatedStart(&I2C_MASTER_0, SLAVE_ADDRESS, XMC_I2C_CH_CMD_READ);
1704:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      while(I2C_MASTER_GetFlagStatus(&I2C_MASTER_0, XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED) == 0U)
1705:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      {
1706:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *       // wait for ACK
1707:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      }
1708:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      I2C_MASTER_ClearFlag(&I2C_MASTER_0,XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED);
1709:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      while(index < 16)
1710:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      {
1711:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *        I2C_MASTER_ReceiveACK(&I2C_MASTER_0);
1712:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *        index++;
1713:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      }
1714:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      // only for the last byte
1715:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      I2C_MASTER_ReceiveNACK(&I2C_MASTER_0);
1716:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      //Wait when Rx FIFO is empty
1717:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      while(!I2C_MASTER_IsRXFIFOEmpty(&I2C_MASTER_0))
1718:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      {
1719:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *        rec_data[loc_index++] = I2C_MASTER_GetReceivedByte(&I2C_MASTER_0);
1720:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      }
1721:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    }
1722:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    else
1723:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    {
1724:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      XMC_DEBUG("main: Application initialization failed");
1725:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      while(1U)
1726:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      {
1727:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      }
1728:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    }
1729:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    return 1U;
1730:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  }
1731:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @endcode
1732:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** */
1733:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** __STATIC_INLINE void I2C_MASTER_ReceiveNACK(I2C_MASTER_t * const handle)
1734:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** {
1735:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****   XMC_ASSERT("I2C_MASTER_ReceiveNACK: invalid handle", (handle != NULL))
1736:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****   XMC_I2C_CH_MasterReceiveNack(handle->channel);
1737:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** }
1738:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** /**
1739:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @brief Sends stop command to slave
1740:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @param handle  I2C_MASTER APP handle pointer of type @ref I2C_MASTER_t
1741:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @return None
1742:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1743:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * \par<b>Description:</b><br>
1744:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * At the end of transmission, sends a stop command to slave <br>
1745:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Pre-requisite: Instantiate I2C_MASTER APP and generate code before using below code snippet.<br>
1746:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Example Usage:
1747:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @code
1748:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1749:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
1750:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  #define SLAVE_ADDRESS (0xA0)
1751:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  int main(void)
1752:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  {
1753:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    DAVE_STATUS_t init_status;
1754:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1755:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    init_status = DAVE_Init();
1756:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    if (init_status == DAVE_STATUS_SUCCESS)
1757:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    {
1758:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      I2C_MASTER_SendStart(&I2C_MASTER_0, SLAVE_ADDRESS, XMC_I2C_CH_CMD_WRITE);
1759:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      while(I2C_MASTER_GetFlagStatus(&I2C_MASTER_0, XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED) == 0U)
1760:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      {
1761:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *       // wait for ACK
1762:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      }
1763:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      I2C_MASTER_ClearFlag(&I2C_MASTER_0,XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED);
1764:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      //send the address to which data to be transfered
1765:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      XMC_I2C_CH_MasterTransmit(I2C_MASTER_0.channel, 0x00);
1766:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      while((XMC_I2C_CH_GetStatusFlag(I2C_MASTER_0.channel) & XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED
1767:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      {
1768:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      }
1769:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      XMC_I2C_CH_ClearStatusFlag(I2C_MASTER_0.channel, XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED);
1770:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** 
1771:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      I2C_MASTER_SendStop(&I2C_MASTER_0);
1772:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    }
1773:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    else
1774:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    {
1775:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      XMC_DEBUG("main: Application initialization failed");
1776:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      while(1U)
1777:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      {
1778:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      }
1779:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    }
1780:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    return 1U;
1781:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  }
1782:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @endcode
1783:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** */
1784:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** __STATIC_INLINE void I2C_MASTER_SendStop(I2C_MASTER_t * const handle)
1785:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** {
1786:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****   XMC_ASSERT("I2C_MASTER_SendStop: invalid handle", (handle != NULL))
1787:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****   XMC_I2C_CH_ClearStatusFlag(handle->channel, XMC_I2C_CH_STATUS_FLAG_STOP_CONDITION_RECEIVED);
1788:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****   XMC_I2C_CH_MasterStop(handle->channel);
1789:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** }
1790:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** /**
1791:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @brief Sends start command to slave
1792:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @param handle  I2C_MASTER APP handle pointer of type @ref I2C_MASTER_t
1793:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @param address slave address
1794:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @param cmd     command
1795:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @return None
1796:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1797:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * \par<b>Description:</b><br>
1798:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Before start of transmission, sends a start command to slave. \n
1799:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Address(address) should reserve an additional bit at the LSB for read/write indication. For exam
1800:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * be provided as 0x0a. If the address is 10-bit, only most significant bits with the 10-bit identi
1801:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * For example, if the 10-bit address is 0x305, the address should be provided as 0xf6(prepend with
1802:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * followed by 1-bit field for read/write).<br>
1803:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Pre-requisite: Instantiate I2C_MASTER APP and generate code before using below code snippet. <br
1804:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Example Usage:
1805:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @code
1806:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1807:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  #include <DAVE.h>
1808:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  #define SLAVE_ADDRESS 0xA0
1809:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  int main(void)
1810:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  {
1811:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    DAVE_STATUS_t init_status;
1812:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1813:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    init_status = DAVE_Init();
1814:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    if (init_status == DAVE_STATUS_SUCCESS)
1815:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    {
1816:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      I2C_MASTER_SendStart(&I2C_MASTER_0, SLAVE_ADDRESS, XMC_I2C_CH_CMD_WRITE);
1817:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      while((XMC_I2C_CH_GetStatusFlag(I2C_MASTER_0.channel) & XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED
1818:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      {
1819:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      }
1820:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      XMC_I2C_CH_ClearStatusFlag(I2C_MASTER_0.channel, XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED);
1821:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** 
1822:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      //send the address to which data to be transfered
1823:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      XMC_I2C_CH_MasterTransmit(I2C_MASTER_0.channel, 0x00);
1824:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      while((XMC_I2C_CH_GetStatusFlag(I2C_MASTER_0.channel) & XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED
1825:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      {
1826:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      }
1827:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      XMC_I2C_CH_ClearStatusFlag(I2C_MASTER_0.channel, XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED);
1828:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    }
1829:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    else
1830:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    {
1831:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *       XMC_DEBUG("main: Application initialization failed");
1832:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *       while(1U)
1833:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *       {
1834:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *       }
1835:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    }
1836:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    return 1U;
1837:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *   }
1838:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @endcode
1839:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** */
1840:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** __STATIC_INLINE void I2C_MASTER_SendStart(I2C_MASTER_t * const handle, const uint32_t address,
1841:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** 		                                  const XMC_I2C_CH_CMD_t cmd)
1842:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** {
1843:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****   XMC_ASSERT("I2C_MASTER_SendStart: invalid handle", (handle != NULL))
1844:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****   XMC_I2C_CH_ClearStatusFlag(handle->channel, XMC_I2C_CH_STATUS_FLAG_START_CONDITION_RECEIVED);
1845:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****   XMC_I2C_CH_MasterStart(handle->channel, (uint16_t)address, cmd);
 571              	 .loc 4 1845 0
 572 0174 91B2     	 uxth r1,r2
 573              	.LBB298:
 574              	.LBB297:
 575              	 .loc 2 674 0
 576 0176 C364     	 str r3,[r0,#76]
 577              	.LBE297:
 578              	.LBE298:
 579              	 .loc 4 1845 0
 580 0178 3246     	 mov r2,r6
 581              	.LVL59:
 582 017a FFF7FEFF 	 bl XMC_I2C_CH_MasterStart
 583              	.LVL60:
 584              	.L19:
 585              	.LBE294:
 586              	.LBE293:
 587              	.LBE292:
 588              	.LBE291:
1523:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         while ((I2C_MASTER_GetFlagStatus(handle, (uint32_t)XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED) == 
 589              	 .loc 1 1523 0
 590 017e 204E     	 ldr r6,.L112
 591 0180 214A     	 ldr r2,.L112+8
 592              	.LBB307:
 593              	.LBB308:
 211:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 594              	 .loc 1 211 0
 595 0182 2B68     	 ldr r3,[r5]
 596              	.LBE308:
 597              	.LBE307:
1523:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         while ((I2C_MASTER_GetFlagStatus(handle, (uint32_t)XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED) == 
 598              	 .loc 1 1523 0
 599 0184 3260     	 str r2,[r6]
 600              	.LVL61:
 601              	.LBB315:
 602              	.LBB313:
 603              	.LBB309:
 604              	.LBB310:
 658:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** }
 605              	 .loc 2 658 0
 606 0186 9A6C     	 ldr r2,[r3,#72]
 607              	.LBE310:
 608              	.LBE309:
 609              	.LBE313:
 610              	.LBE315:
1524:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         {
 611              	 .loc 1 1524 0
 612 0188 9405     	 lsls r4,r2,#22
 613 018a 14D4     	 bmi .L23
 614 018c 3268     	 ldr r2,[r6]
 615 018e 92B1     	 cbz r2,.L23
 616              	.LVL62:
 617              	.LBB316:
 618              	.LBB317:
 658:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** }
 619              	 .loc 2 658 0
 620 0190 9A6C     	 ldr r2,[r3,#72]
 621              	.LBE317:
 622              	.LBE316:
1530:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****                             (uint32_t)XMC_I2C_CH_STATUS_FLAG_ARBITRATION_LOST |
 623              	 .loc 1 1530 0
 624 0192 12F4B17F 	 tst r2,#354
 625 0196 82D1     	 bne .L24
1557:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         }
 626              	 .loc 1 1557 0
 627 0198 3146     	 mov r1,r6
 628 019a 06E0     	 b .L25
 629              	.L110:
1524:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         {
 630              	 .loc 1 1524 0
 631 019c 0A68     	 ldr r2,[r1]
 632 019e 52B1     	 cbz r2,.L23
 633              	.LBB319:
 634              	.LBB318:
 658:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** }
 635              	 .loc 2 658 0
 636 01a0 9A6C     	 ldr r2,[r3,#72]
 637              	.LBE318:
 638              	.LBE319:
1530:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****                             (uint32_t)XMC_I2C_CH_STATUS_FLAG_ARBITRATION_LOST |
 639              	 .loc 1 1530 0
 640 01a2 12F4B17F 	 tst r2,#354
 641 01a6 7FF47AAF 	 bne .L24
 642              	.L25:
1557:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         }
 643              	 .loc 1 1557 0
 644 01aa 3268     	 ldr r2,[r6]
 645 01ac 013A     	 subs r2,r2,#1
 646 01ae 3260     	 str r2,[r6]
 647              	.LBB320:
 648              	.LBB314:
 649              	.LBB312:
 650              	.LBB311:
 658:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** }
 651              	 .loc 2 658 0
 652 01b0 9A6C     	 ldr r2,[r3,#72]
 653              	.LBE311:
 654              	.LBE312:
 655              	.LBE314:
 656              	.LBE320:
1524:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         {
 657              	 .loc 1 1524 0
 658 01b2 9205     	 lsls r2,r2,#22
 659 01b4 F2D5     	 bpl .L110
 660              	.LVL63:
 661              	.L23:
1561:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         {
 662              	 .loc 1 1561 0
 663 01b6 3268     	 ldr r2,[r6]
 664 01b8 DAB9     	 cbnz r2,.L111
 665              	.LVL64:
 666              	.L21:
1564:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         }
 667              	 .loc 1 1564 0
 668 01ba 0420     	 movs r0,#4
 669 01bc BDE8F087 	 pop {r4,r5,r6,r7,r8,r9,r10,pc}
 670              	.LVL65:
 671              	.L106:
1654:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       I2C_MASTER_SendStop(handle);
 672              	 .loc 1 1654 0
 673 01c0 AB68     	 ldr r3,[r5,#8]
 674 01c2 4FF00008 	 mov r8,#0
 675              	.LVL66:
 676 01c6 83F82880 	 strb r8,[r3,#40]
 677              	.LVL67:
 678              	.LBB321:
 679              	.LBB322:
 680              	.LBB323:
 681              	.LBB324:
 682              	 .loc 2 674 0
 683 01ca D36C     	 ldr r3,[r2,#76]
 684 01cc 43F01003 	 orr r3,r3,#16
 685              	.LBE324:
 686              	.LBE323:
1788:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** }
 687              	 .loc 4 1788 0
 688 01d0 1046     	 mov r0,r2
 689              	.LBB326:
 690              	.LBB325:
 691              	 .loc 2 674 0
 692 01d2 D364     	 str r3,[r2,#76]
 693              	.LBE325:
 694              	.LBE326:
1788:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** }
 695              	 .loc 4 1788 0
 696 01d4 FFF7FEFF 	 bl XMC_I2C_CH_MasterStop
 697              	.LVL68:
 698              	.LBE322:
 699              	.LBE321:
 700              	 .loc 1 1658 0
 701 01d8 4046     	 mov r0,r8
 702 01da BDE8F087 	 pop {r4,r5,r6,r7,r8,r9,r10,pc}
 703              	.LVL69:
 704              	.L109:
 705 01de 2868     	 ldr r0,[r5]
 706              	.LVL70:
 707              	.LBB327:
 708              	.LBB306:
 709              	.LBB299:
 710              	.LBB300:
 711              	.LBB301:
 712              	.LBB302:
 713              	.LBB303:
 714              	 .loc 2 674 0
 715 01e0 C36C     	 ldr r3,[r0,#76]
 716 01e2 43F00803 	 orr r3,r3,#8
 717              	.LBE303:
 718              	.LBE302:
1846:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** }
1847:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** /**
1848:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @brief Sends repeated start command to slave
1849:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @param handle  I2C_MASTER APP handle pointer of type @ref I2C_MASTER_t
1850:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @param address slave address
1851:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @param cmd     command
1852:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @return None
1853:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1854:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * \par<b>Description:</b><br>
1855:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Before start of transmission, sends a repeatedstart command to slave if bus acquired is true.\n
1856:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Address(address) should reserve an additional bit at the LSB for read/write indication. For exam
1857:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * be provided as 0x0a. If the address is 10-bit, only most significant bits with the 10-bit identi
1858:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * For example, if the 10-bit address is 0x305, the address should be provided as 0xf6(prepend with
1859:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * followed by 1-bit field for read/write).<br>
1860:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Pre-requisite: Instantiate I2C_MASTER APP and generate code before using below code snippet. <br
1861:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * Example Usage:
1862:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @code
1863:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1864:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  #include <DAVE.h>         //Declarations from DAVE Code Generation (includes SFR declaration)
1865:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  #define SLAVE_ADDRESS 0xA0
1866:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  int main(void)
1867:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  {
1868:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    DAVE_STATUS_t init_status;
1869:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    uint8_t rx_buf[256];
1870:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1871:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    init_status = DAVE_Init();
1872:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    if (init_status == DAVE_STATUS_SUCCESS)
1873:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    {
1874:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      XMC_I2C_CH_MasterStart(I2C_MASTER_0.channel, SLAVE_ADDRESS, XMC_I2C_CH_CMD_WRITE);
1875:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      while((XMC_I2C_CH_GetStatusFlag(I2C_MASTER_0.channel) & XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED
1876:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      {
1877:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      }
1878:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      XMC_I2C_CH_ClearStatusFlag(I2C_MASTER_0.channel, XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED);
1879:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** 
1880:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *     //send the address to which data to be transfered
1881:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *     XMC_I2C_CH_MasterTransmit(I2C_MASTER_0.channel, 0x00);
1882:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *     while((XMC_I2C_CH_GetStatusFlag(I2C_MASTER_0.channel) & XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED)
1883:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *     {
1884:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *     }
1885:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *     XMC_I2C_CH_ClearStatusFlag(I2C_MASTER_0.channel, XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED);
1886:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** 
1887:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *     I2C_MASTER_SendRepeatedStart(&I2C_MASTER_0, SLAVE_ADDRESS, XMC_I2C_CH_CMD_READ);
1888:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *     while((XMC_I2C_CH_GetStatusFlag(I2C_MASTER_0.channel) & XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED)
1889:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *     {
1890:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *     }
1891:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *
1892:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *     XMC_I2C_CH_ClearStatusFlag(I2C_MASTER_0.channel, XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED);
1893:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * 	   memset(rx_buf,0,16);
1894:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *     I2C_MASTER_Receive(&I2C_MASTER_0, false, SLAVE_ADDRESS, rx_buf, 16, true, true);
1895:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    }
1896:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    else
1897:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    {
1898:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      XMC_DEBUG("main: Application initialization failed");
1899:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      while(1U)
1900:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      {
1901:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *      }
1902:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *    }
1903:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *   return 1U;
1904:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  *  }
1905:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****  * @endcode
1906:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** */
1907:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** __STATIC_INLINE void I2C_MASTER_SendRepeatedStart(I2C_MASTER_t * const handle, const uint32_t addre
1908:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** 		                                          const XMC_I2C_CH_CMD_t cmd)
1909:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** {
1910:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****   XMC_ASSERT("I2C_MASTER_SendRepeatedStart: invalid handle", (handle != NULL))
1911:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****   XMC_I2C_CH_ClearStatusFlag(handle->channel, XMC_I2C_CH_STATUS_FLAG_REPEATED_START_CONDITION_RECEI
1912:../BSP/dave_fixes/I2C_MASTER/i2c_master.h ****   XMC_I2C_CH_MasterRepeatedStart(handle->channel, (uint16_t)address, cmd);
 719              	 .loc 4 1912 0
 720 01e6 91B2     	 uxth r1,r2
 721              	.LBB305:
 722              	.LBB304:
 723              	 .loc 2 674 0
 724 01e8 C364     	 str r3,[r0,#76]
 725              	.LBE304:
 726              	.LBE305:
 727              	 .loc 4 1912 0
 728 01ea 2246     	 mov r2,r4
 729              	.LVL71:
 730 01ec FFF7FEFF 	 bl XMC_I2C_CH_MasterRepeatedStart
 731              	.LVL72:
 732 01f0 C5E7     	 b .L19
 733              	.LVL73:
 734              	.L111:
 735              	.LBE301:
 736              	.LBE300:
 737              	.LBE299:
 738              	.LBE306:
 739              	.LBE327:
 740              	.LBB328:
 741              	.LBB329:
 742              	.LBB330:
 743              	 .loc 2 674 0
 744 01f2 D96C     	 ldr r1,[r3,#76]
 745 01f4 6A68     	 ldr r2,[r5,#4]
 746 01f6 41F40071 	 orr r1,r1,#512
 747 01fa D964     	 str r1,[r3,#76]
 748 01fc 1846     	 mov r0,r3
 749 01fe 25E7     	 b .L17
 750              	.L113:
 751              	 .align 2
 752              	.L112:
 753 0200 00000000 	 .word .LANCHOR0
 754 0204 FFFF2F00 	 .word 3145727
 755 0208 FFFF1F00 	 .word 2097151
 756              	.LBE330:
 757              	.LBE329:
 758              	.LBE328:
 759              	.LBE242:
 760              	.LBE241:
 761              	 .cfi_endproc
 762              	.LFE239:
 764              	 .section .text.I2C_MASTER_Receive,"ax",%progbits
 765              	 .align 2
 766              	 .global I2C_MASTER_Receive
 767              	 .thumb
 768              	 .thumb_func
 770              	I2C_MASTER_Receive:
 771              	.LFB240:
 482:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   I2C_MASTER_STATUS_t status;
 772              	 .loc 1 482 0
 773              	 .cfi_startproc
 774              	 
 775              	 
 776              	.LVL74:
 777 0000 2DE9F84F 	 push {r3,r4,r5,r6,r7,r8,r9,r10,fp,lr}
 778              	.LCFI5:
 779              	 .cfi_def_cfa_offset 40
 780              	 .cfi_offset 3,-40
 781              	 .cfi_offset 4,-36
 782              	 .cfi_offset 5,-32
 783              	 .cfi_offset 6,-28
 784              	 .cfi_offset 7,-24
 785              	 .cfi_offset 8,-20
 786              	 .cfi_offset 9,-16
 787              	 .cfi_offset 10,-12
 788              	 .cfi_offset 11,-8
 789              	 .cfi_offset 14,-4
 482:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   I2C_MASTER_STATUS_t status;
 790              	 .loc 1 482 0
 791 0004 0446     	 mov r4,r0
 487:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
 792              	 .loc 1 487 0
 793 0006 4068     	 ldr r0,[r0,#4]
 794              	.LVL75:
 482:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   I2C_MASTER_STATUS_t status;
 795              	 .loc 1 482 0
 796 0008 0A9D     	 ldr r5,[sp,#40]
 487:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
 797              	 .loc 1 487 0
 798 000a 90F825E0 	 ldrb lr,[r0,#37]
 482:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   I2C_MASTER_STATUS_t status;
 799              	 .loc 1 482 0
 800 000e 9DF82C60 	 ldrb r6,[sp,#44]
 801 0012 9DF83080 	 ldrb r8,[sp,#48]
 487:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
 802              	 .loc 1 487 0
 803 0016 BEF1010F 	 cmp lr,#1
 804 001a 02D8     	 bhi .L160
 485:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 805              	 .loc 1 485 0
 806 001c 0220     	 movs r0,#2
 807 001e BDE8F88F 	 pop {r3,r4,r5,r6,r7,r8,r9,r10,fp,pc}
 808              	.LVL76:
 809              	.L160:
 810 0022 1F46     	 mov r7,r3
 811              	.LVL77:
 812              	.LBB395:
 813              	.LBB396:
1659:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   }
1660:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1661:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   return (status);
1662:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** }
1663:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #endif
1664:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1665:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** #if (I2C_MASTER_DIRECT_RX_ENABLED == 1)
1666:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** static I2C_MASTER_STATUS_t I2C_MASTER_lStartReceivePolling(I2C_MASTER_t *const handle, bool send_st
1667:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****                                                        uint32_t slave_address, uint8_t *data, uint3
1668:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****                                bool send_stop, bool send_nack)
1669:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** {
1670:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   I2C_MASTER_STATUS_t status;
1671:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   uint32_t buffer_index;
1672:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   uint32_t temp_index;
1673:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1674:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   status = I2C_MASTER_STATUS_BUSY;
1675:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   if ((((send_start == false) && (handle->runtime->bus_acquired == false)) || (data == NULL) || (co
 814              	 .loc 1 1675 0
 815 0024 19B9     	 cbnz r1,.L116
 816              	.LVL78:
 817 0026 A368     	 ldr r3,[r4,#8]
 818              	.LVL79:
 819 0028 93F82830 	 ldrb r3,[r3,#40]
 820 002c 83B3     	 cbz r3,.L146
 821              	.L116:
 822 002e 7FB3     	 cbz r7,.L146
 823 0030 75B3     	 cbz r5,.L146
 824              	.LVL80:
1676:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
1677:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     status = I2C_MASTER_STATUS_FAILURE;
1678:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   }
1679:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   else
1680:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
1681:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   buffer_index = 0U;
1682:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   temp_index = 0U;
1683:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     if (send_start == true)
 825              	 .loc 1 1683 0
 826 0032 0029     	 cmp r1,#0
 827 0034 43D1     	 bne .L161
1684:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     {
1685:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       I2C_MASTER_lSendStart_Or_RepeatedStart(handle, slave_address, XMC_I2C_CH_CMD_READ);
1686:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       while (I2C_MASTER_GetFlagStatus(handle, (uint32_t)XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED) == 0U)
1687:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     {
1688:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       /* wait for ACK */
1689:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     }
1690:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     I2C_MASTER_ClearFlag(handle, (uint32_t)XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED);
1691:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   }
1692:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1693:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   if (handle->config->txFIFO_size == XMC_USIC_CH_FIFO_DISABLED)
 828              	 .loc 1 1693 0
 829 0036 90F82630 	 ldrb r3,[r0,#38]
 830 003a 002B     	 cmp r3,#0
 831 003c 00F08A80 	 beq .L140
 832 0040 2268     	 ldr r2,[r4]
 833              	.LVL81:
 834              	.L141:
 835              	.LBB397:
 836              	.LBB398:
1736:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** }
 837              	 .loc 4 1736 0
 838 0042 4FF00009 	 mov r9,#0
 839 0046 CA46     	 mov r10,r9
 840              	.LVL82:
 841              	.L122:
 842 0048 B8F1000F 	 cmp r8,#0
 843 004c 07D0     	 beq .L139
 844 004e 27E0     	 b .L137
 845              	.LVL83:
 846              	.L162:
 847              	.LBE398:
 848              	.LBE397:
1694:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
1695:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     while (buffer_index < count)
1696:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     {
1697:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       if (((buffer_index + 1U) == count) && (send_nack == true))
1698:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     {
1699:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         I2C_MASTER_ReceiveNACK(handle);
1700:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     }
1701:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     else
1702:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     {
1703:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       I2C_MASTER_ReceiveACK(handle);
1704:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     }
1705:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1706:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       while ((I2C_MASTER_GetFlagStatus(handle, (uint32_t)XMC_I2C_CH_STATUS_FLAG_ALTERNATIVE_RECEIVE
1707:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****          (I2C_MASTER_GetFlagStatus(handle, (uint32_t)XMC_I2C_CH_STATUS_FLAG_RECEIVE_INDICATION) == 
1708:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     {
1709:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       /* wait for RSI */
1710:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     }
1711:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1712:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     I2C_MASTER_ClearFlag(handle, (uint32_t)XMC_I2C_CH_STATUS_FLAG_ALTERNATIVE_RECEIVE_INDICATION);
1713:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     I2C_MASTER_ClearFlag(handle, (uint32_t)XMC_I2C_CH_STATUS_FLAG_RECEIVE_INDICATION);
1714:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1715:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     data[buffer_index++] = I2C_MASTER_GetReceivedByte(handle);
1716:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     }
1717:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   } /* end of if (handle->config->txFIFO_size == XMC_USIC_CH_FIFO_DISABLED) */
1718:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   else
1719:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
1720:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     temp_index = buffer_index;
1721:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     while (temp_index < count)
1722:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     {
1723:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       while (I2C_MASTER_IsTXFIFOFull(handle) == false)
1724:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     {
1725:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       /* transmit each byte till index reaches to the last byte */
1726:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       if (temp_index < count)
 849              	 .loc 1 1726 0
 850 0050 5545     	 cmp r5,r10
 851 0052 79D9     	 bls .L129
 852              	.LBB400:
 853              	.LBB401:
1666:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** }
 854              	 .loc 4 1666 0
 855 0054 FFF7FEFF 	 bl XMC_I2C_CH_MasterReceiveAck
 856              	.LVL84:
 857 0058 2268     	 ldr r2,[r4]
 858              	.LBE401:
 859              	.LBE400:
1727:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       {
1728:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         /* load the FIFO, byte by byte till either FIFO is full or all data is loaded*/
1729:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         if (((temp_index + 1U) == count) && (send_nack == true))
 860              	 .loc 1 1729 0
 861 005a 0AF1010A 	 add r10,r10,#1
 862              	.LVL85:
 863              	.L139:
 864              	.LBB405:
 865              	.LBB406:
 866              	.LBB407:
1615:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** }
 867              	 .loc 3 1615 0
 868 005e D2F81431 	 ldr r3,[r2,#276]
 869              	.LBE407:
 870              	.LBE406:
 871              	.LBE405:
1723:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     {
 872              	 .loc 1 1723 0
 873 0062 13F4805F 	 tst r3,#4096
 874              	.LBB410:
 875              	.LBB402:
1666:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** }
 876              	 .loc 4 1666 0
 877 0066 1046     	 mov r0,r2
 878              	.LBE402:
 879              	.LBE410:
1723:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     {
 880              	 .loc 1 1723 0
 881 0068 F2D0     	 beq .L162
 882              	.LVL86:
 883              	.L138:
1730:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       {
1731:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         I2C_MASTER_ReceiveNACK(handle);
1732:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       }
1733:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****             else
1734:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       {
1735:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         I2C_MASTER_ReceiveACK(handle);
1736:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       }
1737:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       temp_index++;
1738:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       }
1739:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       else
1740:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       {
1741:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****         break;
1742:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       }
1743:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     } /* end of while (I2C_MASTER_IsTXFIFOFull(handle) == false) */
1744:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1745:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     while (buffer_index < temp_index)
 884              	 .loc 1 1745 0
 885 006a CA45     	 cmp r10,r9
 886 006c 68D9     	 bls .L133
 887              	.L142:
 888 006e 07EB090B 	 add fp,r7,r9
 889              	.LVL87:
 890              	.L134:
 891              	.LBB411:
 892              	.LBB412:
 893              	.LBB413:
1636:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** }
1637:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
1638:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
1639:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param channel Pointer to USIC channel handler of type @ref XMC_USIC_CH_t \n
1640:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				   \b Range: @ref XMC_USIC0_CH0, @ref XMC_USIC0_CH1 to @ref XMC_USIC2_CH1 based on device su
1641:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @return Transmit FIFO filling level. \n 
1642:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *           \b Range: minimum= 0(FIFO empty), maximum= transmit FIFO size.
1643:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
1644:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Description</b><br>
1645:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Gets the transmit FIFO filling level. \n\n
1646:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * For every word written to the FIFO, filling level is updated. The API gives the value
1647:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * of this filling level.
1648:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 
1649:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Related APIs:</b><BR>
1650:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * XMC_USIC_CH_TXFIFO_Flush(), XMC_USIC_CH_TXFIFO_PutData() \n\n\n
1651:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
1652:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** __STATIC_INLINE uint32_t XMC_USIC_CH_TXFIFO_GetLevel(XMC_USIC_CH_t *const channel)
1653:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
1654:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   return ((uint32_t)(channel->TRBSR & USIC_CH_TRBSR_TBFLVL_Msk) >> USIC_CH_TRBSR_TBFLVL_Pos);
1655:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** }
1656:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
1657:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
1658:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param channel Pointer to USIC channel handler of type @ref XMC_USIC_CH_t \n
1659:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				   \b Range: @ref XMC_USIC0_CH0, @ref XMC_USIC0_CH1 to @ref XMC_USIC2_CH1 based on device su
1660:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @return Status of standard transmit and transmit buffer error events. @ref XMC_USIC_CH_TXFIFO_EV
1661:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 
1662:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Description</b><br>
1663:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Gets the transmit FIFO event status. \n\n
1664:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Gives the status of transmit FIFO standard transmit buffer event and transmit buffer error event
1665:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * The status bits are located at their bit positions in the TRBSR register in the returned value.
1666:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * User can make use of the @ref XMC_USIC_CH_TXFIFO_EVENT_t enumeration for checking the status of 
1667:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * The status can be found by using the bitwise AND operation on the returned value with the enumer
1668:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 
1669:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Note: Event status flags should be cleared by the user explicitly.
1670:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
1671:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Related APIs:</b><BR>
1672:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * XMC_USIC_CH_TXFIFO_ClearEvent() \n\n\n
1673:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
1674:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** __STATIC_INLINE uint32_t XMC_USIC_CH_TXFIFO_GetEvent(XMC_USIC_CH_t *const channel)
1675:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
1676:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   return (uint32_t)((channel->TRBSR) & (USIC_CH_TRBSR_STBI_Msk |
1677:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****                               USIC_CH_TRBSR_TBERI_Msk));
1678:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** }
1679:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
1680:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
1681:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param channel Pointer to USIC channel handler of type @ref XMC_USIC_CH_t \n
1682:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				   \b Range: @ref XMC_USIC0_CH0, @ref XMC_USIC0_CH1 to @ref XMC_USIC2_CH1 based on device su
1683:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param  event Transmit FIFO events to be cleared. \n
1684:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 			     \b Range: @ref XMC_USIC_CH_TXFIFO_EVENT_STANDARD, @ref XMC_USIC_CH_TXFIFO_EVENT_ERROR.
1685:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @return None
1686:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
1687:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Description</b><br>
1688:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Clears the transmit FIFO event flags in the status register. \n\n
1689:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * USIC channel peripheral does not clear the event flags after they are read.
1690:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * This API clears the events provided in the \a mask value. 
1691:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * XMC_USIC_CH_TXFIFO_EVENT enumeration can be used as input. Multiple events
1692:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * can be cleared by providing a mask value obtained by bitwise OR operation of 
1693:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * multiple event enumerations.
1694:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
1695:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Related APIs:</b><BR>
1696:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * XMC_USIC_CH_TXFIFO_GetEvent() \n\n\n
1697:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
1698:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** __STATIC_INLINE void XMC_USIC_CH_TXFIFO_ClearEvent(XMC_USIC_CH_t *const channel,
1699:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****                                                    const uint32_t event)
1700:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
1701:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   channel->TRBSCR = event;
1702:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** }
1703:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
1704:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
1705:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param channel Pointer to USIC channel handler of type @ref XMC_USIC_CH_t \n
1706:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				   \b Range: @ref XMC_USIC0_CH0, @ref XMC_USIC0_CH1 to @ref XMC_USIC2_CH1 based on device su
1707:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param data_pointer Start position inside the FIFO buffer. \n
1708:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 		\b Range: 0 to 63.
1709:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param size Required size of the receive FIFO. \n
1710:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 		\b Range: @ref XMC_USIC_CH_FIFO_DISABLED, @ref XMC_USIC_CH_FIFO_SIZE_2WORDS.. @ref XMC_USIC_CH
1711:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param limit Threshold of receive FIFO filling level to be considered for generating events. \n
1712:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 		\b Range: 0 to \a size -1.
1713:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @return None
1714:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
1715:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Description</b><br>
1716:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Configures the receive FIFO. \n\n
1717:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Receive FIFO is the subset of a common FIFO sized 64 words. This FIFO is shared between 2 channe
1718:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Each channel can share the FIFO for transmission and reception. \a data_pointer represents the s
1719:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * from where received data can be put. \a size represents the size of receive FIFO as a multiple o
1720:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Since the FIFO is shared between 2 USIC channels, FIFO size should be carefully selected. A FIFO
1721:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * event or alternative receive buffer event is generated when the FIFO filling level exceeds the \
1722:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
1723:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Related APIs:</b><BR>
1724:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * XMC_USIC_CH_RXFIFO_EnableEvent(), XMC_USIC_CH_RXFIFO_SetInterruptNodePointer() \n\n\n
1725:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** */
1726:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** void XMC_USIC_CH_RXFIFO_Configure(XMC_USIC_CH_t *const channel,
1727:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****                                   const uint32_t data_pointer,
1728:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****                                   const XMC_USIC_CH_FIFO_SIZE_t size,
1729:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****                                   const uint32_t limit);
1730:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
1731:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
1732:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param channel Pointer to USIC channel handler of type @ref XMC_USIC_CH_t \n
1733:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				   \b Range: @ref XMC_USIC0_CH0, @ref XMC_USIC0_CH1 to @ref XMC_USIC2_CH1 based on device su
1734:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param size Required size of the receive FIFO. \n
1735:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 		\b Range: @ref XMC_USIC_CH_FIFO_DISABLED, @ref XMC_USIC_CH_FIFO_SIZE_2WORDS.. @ref XMC_USIC_CH
1736:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param limit Threshold for receive FIFO filling level to be considered for generating events. \n
1737:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 		\b Range: 0 to \a size -1.
1738:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @return None
1739:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
1740:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Description</b><br>
1741:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Sets the size and trigger limit for the receive FIFO. \n\n
1742:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * The API is not to be called for initializing the receive FIFO. The API shall be used for the 
1743:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * runtime change of receive FIFO trigger limit. FIFO start position will not be affected on execut
1744:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
1745:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Related APIs:</b><BR>
1746:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * XMC_USIC_CH_TXFIFO_SetSizeTriggerLimit()\ n\n\n
1747:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
1748:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** void XMC_USIC_CH_RXFIFO_SetSizeTriggerLimit(XMC_USIC_CH_t *const channel,
1749:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****                                             const XMC_USIC_CH_FIFO_SIZE_t size,
1750:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****                                             const uint32_t limit);
1751:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
1752:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
1753:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param channel Pointer to USIC channel handler of type @ref XMC_USIC_CH_t \n
1754:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				   \b Range: @ref XMC_USIC0_CH0, @ref XMC_USIC0_CH1 to @ref XMC_USIC2_CH1 based on device su
1755:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param event Events to be enabled. Multiple events can be bitwise OR combined. @ref XMC_USIC_CH_
1756:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @return None
1757:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
1758:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Description</b><br>
1759:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Enables the interrupt events related to transmit FIFO. \n\n
1760:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Event bitmasks can be constructed using the enumeration @ref XMC_USIC_CH_RXFIFO_EVENT_CONF_t.
1761:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Multiple events can be enabled by providing multiple events in a single call. For providing 
1762:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * multiple events, combine the events using bitwise OR operation.<br>
1763:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 
1764:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Note: API only enables the events. For interrupt generation, interrupt node must be configured a
1765:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * must be enabled.
1766:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
1767:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Related APIs:</b><BR>
1768:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * XMC_USIC_CH_RXFIFO_SetInterruptNodePointer() \n\n\n
1769:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
1770:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** __STATIC_INLINE void XMC_USIC_CH_RXFIFO_EnableEvent(XMC_USIC_CH_t *const channel, const uint32_t ev
1771:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
1772:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   channel->RBCTR |= event;
1773:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** }
1774:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
1775:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
1776:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
1777:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param channel Pointer to USIC channel handler of type @ref XMC_USIC_CH_t \n
1778:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				   \b Range: @ref XMC_USIC0_CH0, @ref XMC_USIC0_CH1 to @ref XMC_USIC2_CH1 based on device su
1779:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param event Events to be disabled. \n
1780:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 			\b Range: @ref XMC_USIC_CH_RXFIFO_EVENT_CONF_STANDARD, @ref XMC_USIC_CH_RXFIFO_EVENT_CONF_ERR
1781:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 			@ref XMC_USIC_CH_RXFIFO_EVENT_CONF_ALTERNATE.
1782:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @return None
1783:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
1784:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Description</b><br>
1785:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Disables the selected interrupt events related to receive FIFO. \n\n
1786:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * By disabling the interrupt events, generation of interrupt is stopped. User can poll the event 
1787:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * flags from the status register using the API XMC_USIC_CH_RXFIFO_GetEvent(). 
1788:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Event bitmasks can be constructed using the enumeration \a XMC_USIC_CH_RXFIFO_EVENT_CONF. For pr
1789:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * multiple events, combine the events using bitwise OR operation.
1790:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
1791:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Related APIs:</b><BR>
1792:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * XMC_USIC_CH_RXFIFO_GetEvent(), XMC_USIC_CH_RXFIFO_EnableEvent() \n\n\n
1793:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
1794:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** __STATIC_INLINE void XMC_USIC_CH_RXFIFO_DisableEvent(XMC_USIC_CH_t *const channel, const uint32_t e
1795:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
1796:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   channel->RBCTR &= (uint32_t)~event;
1797:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** }
1798:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
1799:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
1800:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param channel Pointer to USIC channel handler of type @ref XMC_USIC_CH_t \n
1801:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				   \b Range: @ref XMC_USIC0_CH0, @ref XMC_USIC0_CH1 to @ref XMC_USIC2_CH1 based on device su
1802:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param interrupt_node Node pointer representing the receive FIFO events. \n
1803:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 					\b Range: @ref XMC_USIC_CH_RXFIFO_INTERRUPT_NODE_POINTER_STANDARD,
1804:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 					@ref XMC_USIC_CH_RXFIFO_INTERRUPT_NODE_POINTER_ALTERNATE
1805:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param service_request The service request to be used for interrupt generation.\n
1806:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 					\b Range: 0 to 5.
1807:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @return None
1808:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
1809:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Description</b><br>
1810:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Sets an interrupt node for the receive FIFO events. \n\n
1811:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * A node pointer represents one or more interrupt events. Service request represents the interrupt
1812:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * among the 6 interrupt nodes available for USIC module.
1813:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * API configures the service request to be used for interrupt generation for the events selected.
1814:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * A receive FIFO event can generate an interrupt only if the interrupt node is configured for the 
1815:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * the interrupt generation is enabled for the event. For example, transmit FIFO standard transmit 
1816:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * interrupt is generated if the interrupt node for the same is set and interrupt is enabled.<br>
1817:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
1818:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Note: NVIC node should be explicitly enabled for the interrupt generation.
1819:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
1820:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Related APIs:</b><BR>
1821:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * XMC_USIC_CH_RXFIFO_EnableEvent() \n\n\n
1822:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
1823:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** void XMC_USIC_CH_RXFIFO_SetInterruptNodePointer(XMC_USIC_CH_t *const channel,
1824:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****                                                 const XMC_USIC_CH_RXFIFO_INTERRUPT_NODE_POINTER_t i
1825:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****                                                 const uint32_t service_request);
1826:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
1827:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
1828:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param channel Pointer to USIC channel handler of type @ref XMC_USIC_CH_t \n
1829:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				   \b Range: @ref XMC_USIC0_CH0, @ref XMC_USIC0_CH1 to @ref XMC_USIC2_CH1 based on device su
1830:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @return Value read from the receive FIFO. \n
1831:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 			\b Range: 16bit data. Length of data depends on the word length configuration.
1832:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
1833:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Description</b><br>
1834:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Gets data from the receive FIFO. \n\n
1835:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Receive FIFO should be read only if data is availble in the FIFO. This can be checked using
1836:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * the API XMC_USIC_CH_RXFIFO_IsEmpty(). Receive FIFO error flag will be set if an attempt is made
1837:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * to read from an empty receive FIFO. To read all the received data, user should keep reading data
1838:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * until receive FIFO is empty.
1839:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
1840:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Related APIs:</b><BR>
1841:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * XMC_USIC_CH_RXFIFO_ClearEvent() \n\n\n
1842:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
1843:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** __STATIC_INLINE uint16_t XMC_USIC_CH_RXFIFO_GetData(XMC_USIC_CH_t *const channel)
1844:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
1845:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   return (uint16_t)(channel->OUTR);
1846:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** }
1847:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
1848:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
1849:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param channel Pointer to USIC channel handler of type @ref XMC_USIC_CH_t \n
1850:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				   \b Range: @ref XMC_USIC0_CH0, @ref XMC_USIC0_CH1 to @ref XMC_USIC2_CH1 based on device su
1851:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @return None
1852:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
1853:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Description</b><br>
1854:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Clears the contents of receive FIFO. \n\n
1855:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Receive FIFO contents will be cleared and the filling level will be reset to 0.
1856:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 
1857:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Related APIs:</b><BR>
1858:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * XMC_USIC_CH_RXFIFO_GetLevel() \n\n\n
1859:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
1860:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** __STATIC_INLINE void XMC_USIC_CH_RXFIFO_Flush(XMC_USIC_CH_t *const channel)
1861:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
1862:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   channel->TRBSCR = (uint32_t)USIC_CH_TRBSCR_FLUSHRB_Msk;
1863:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** }
1864:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
1865:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
1866:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param channel Pointer to USIC channel handler of type @ref XMC_USIC_CH_t \n
1867:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				   \b Range: @ref XMC_USIC0_CH0, @ref XMC_USIC0_CH1 to @ref XMC_USIC2_CH1 based on device su
1868:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @return Status \a true if receive FIFO is full
1869:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *              \a false if receive FIFO is not full.
1870:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
1871:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Description</b><br>
1872:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Checks if receive FIFO is full. \n\n
1873:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * When the receive FIFO filling level reaches the configured size, FIFO full flag is set.
1874:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Any data received when the receive FIFO is full, is lost.
1875:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 
1876:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Related APIs:</b><BR>
1877:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * XMC_USIC_CH_RXFIFO_IsEmpty(), XMC_USIC_CH_RXFIFO_Flush() \n\n\n
1878:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
1879:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** __STATIC_INLINE bool XMC_USIC_CH_RXFIFO_IsFull(XMC_USIC_CH_t *const channel)
1880:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
1881:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   return (bool)(channel->TRBSR & USIC_CH_TRBSR_RFULL_Msk);
1882:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** }
1883:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** 
1884:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** /**
1885:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @param channel Pointer to USIC channel handler of type @ref XMC_USIC_CH_t \n
1886:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 				   \b Range: @ref XMC_USIC0_CH0, @ref XMC_USIC0_CH1 to @ref XMC_USIC2_CH1 based on device su
1887:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * @return Status \a true if receive FIFO is empty,
1888:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *              \a false if receive FIFO has some data.
1889:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  *
1890:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Description</b><br>
1891:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * Checks if receive FIFO is empty. \n\n
1892:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * When the receive FIFO is empty, received data will be put in receive FIFO.
1893:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * When the last received word in the FIFO is read, FIFO empty flag is set. Any attempt
1894:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * to read from an empty receive FIFO will set the receive FIFO error flag.
1895:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * 
1896:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * \par<b>Related APIs:</b><BR>
1897:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  * XMC_USIC_CH_RXFIFO_Flush(), XMC_USIC_CH_RXFIFO_PutData() \n\n\n
1898:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****  */
1899:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** __STATIC_INLINE bool XMC_USIC_CH_RXFIFO_IsEmpty(XMC_USIC_CH_t *const channel)
1900:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** {
1901:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h ****   return (bool)(channel->TRBSR & USIC_CH_TRBSR_REMPTY_Msk);
 894              	 .loc 3 1901 0
 895 0072 D2F81431 	 ldr r3,[r2,#276]
 896              	.LBE413:
 897              	.LBE412:
 898              	.LBE411:
1746:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     {
1747:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       /* wait for data to come in RX fifo */
1748:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       while (I2C_MASTER_IsRXFIFOEmpty(handle)){}
 899              	 .loc 1 1748 0
 900 0076 1B07     	 lsls r3,r3,#28
 901 0078 FBD4     	 bmi .L134
 902              	.LBB414:
 903              	.LBB415:
1451:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** }
 904              	 .loc 4 1451 0
 905 007a 1046     	 mov r0,r2
 906 007c FFF7FEFF 	 bl XMC_I2C_CH_GetReceivedData
 907              	.LVL88:
 908              	.LBE415:
 909              	.LBE414:
1749:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       data[buffer_index++] = I2C_MASTER_GetReceivedByte(handle);
 910              	 .loc 1 1749 0
 911 0080 09F10109 	 add r9,r9,#1
 912              	.LVL89:
1745:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     {
 913              	 .loc 1 1745 0
 914 0084 D145     	 cmp r9,r10
 915              	 .loc 1 1749 0
 916 0086 0BF8010B 	 strb r0,[fp],#1
1745:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     {
 917              	 .loc 1 1745 0
 918 008a 59D2     	 bcs .L133
 919 008c 2268     	 ldr r2,[r4]
 920 008e F0E7     	 b .L134
 921              	.LVL90:
 922              	.L146:
1677:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   }
 923              	 .loc 1 1677 0
 924 0090 0120     	 movs r0,#1
 925 0092 BDE8F88F 	 pop {r3,r4,r5,r6,r7,r8,r9,r10,fp,pc}
 926              	.LVL91:
 927              	.L163:
 928              	.LBB416:
 929              	.LBB399:
1736:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** }
 930              	 .loc 4 1736 0
 931 0096 1046     	 mov r0,r2
 932              	.LVL92:
 933 0098 FFF7FEFF 	 bl XMC_I2C_CH_MasterReceiveNack
 934              	.LVL93:
 935 009c AA46     	 mov r10,r5
 936              	.LVL94:
 937              	.L131:
 938 009e 2268     	 ldr r2,[r4]
 939              	.L137:
 940              	.LVL95:
 941              	.LBE399:
 942              	.LBE416:
 943              	.LBB417:
 944              	.LBB409:
 945              	.LBB408:
1615:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_usic.h **** }
 946              	 .loc 3 1615 0
 947 00a0 D2F81431 	 ldr r3,[r2,#276]
 948              	.LBE408:
 949              	.LBE409:
 950              	.LBE417:
1723:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     {
 951              	 .loc 1 1723 0
 952 00a4 13F4805F 	 tst r3,#4096
 953              	.LBB418:
 954              	.LBB403:
1666:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** }
 955              	 .loc 4 1666 0
 956 00a8 1046     	 mov r0,r2
 957              	.LBE403:
 958              	.LBE418:
1723:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     {
 959              	 .loc 1 1723 0
 960 00aa DED1     	 bne .L138
1726:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       {
 961              	 .loc 1 1726 0
 962 00ac 5545     	 cmp r5,r10
 963 00ae 4BD9     	 bls .L129
1729:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       {
 964              	 .loc 1 1729 0
 965 00b0 0AF1010A 	 add r10,r10,#1
 966              	.LVL96:
 967 00b4 5545     	 cmp r5,r10
 968 00b6 EED0     	 beq .L163
 969              	.LBB419:
 970              	.LBB404:
1666:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** }
 971              	 .loc 4 1666 0
 972 00b8 FFF7FEFF 	 bl XMC_I2C_CH_MasterReceiveAck
 973              	.LVL97:
 974 00bc EFE7     	 b .L131
 975              	.LVL98:
 976              	.L161:
 977              	.LBE404:
 978              	.LBE419:
 979              	.LBB420:
 980              	.LBB421:
 738:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
 981              	 .loc 1 738 0
 982 00be A368     	 ldr r3,[r4,#8]
 983 00c0 93F82810 	 ldrb r1,[r3,#40]
 984              	.LVL99:
 985 00c4 0029     	 cmp r1,#0
 986 00c6 55D1     	 bne .L164
 987 00c8 2068     	 ldr r0,[r4]
 988              	.LVL100:
 744:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     I2C_MASTER_SendStart(handle, (uint16_t)address, cmd);
 989              	 .loc 1 744 0
 990 00ca 4FF0010E 	 mov lr,#1
 991 00ce 83F828E0 	 strb lr,[r3,#40]
 992              	.LBB422:
 993              	.LBB423:
 994              	.LBB424:
 995              	.LBB425:
 996              	 .loc 2 674 0
 997 00d2 C36C     	 ldr r3,[r0,#76]
 998 00d4 43F00403 	 orr r3,r3,#4
 999              	.LBE425:
 1000              	.LBE424:
1845:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** }
 1001              	 .loc 4 1845 0
 1002 00d8 91B2     	 uxth r1,r2
 1003              	.LBB427:
 1004              	.LBB426:
 1005              	 .loc 2 674 0
 1006 00da C364     	 str r3,[r0,#76]
 1007              	.LBE426:
 1008              	.LBE427:
1845:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** }
 1009              	 .loc 4 1845 0
 1010 00dc 7246     	 mov r2,lr
 1011              	.LVL101:
 1012 00de FFF7FEFF 	 bl XMC_I2C_CH_MasterStart
 1013              	.LVL102:
 1014              	.L119:
 1015 00e2 2268     	 ldr r2,[r4]
 1016              	.L120:
 1017              	.LVL103:
 1018              	.LBE423:
 1019              	.LBE422:
 1020              	.LBE421:
 1021              	.LBE420:
 1022              	.LBB436:
 1023              	.LBB437:
 1024              	.LBB438:
 1025              	.LBB439:
 658:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** }
 1026              	 .loc 2 658 0
 1027 00e4 936C     	 ldr r3,[r2,#72]
 1028              	.LBE439:
 1029              	.LBE438:
 1030              	.LBE437:
 1031              	.LBE436:
1686:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     {
 1032              	 .loc 1 1686 0
 1033 00e6 9805     	 lsls r0,r3,#22
 1034 00e8 FCD5     	 bpl .L120
 1035              	.LVL104:
1693:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
 1036              	 .loc 1 1693 0
 1037 00ea 6168     	 ldr r1,[r4,#4]
 1038              	.LBB440:
 1039              	.LBB441:
 1040              	.LBB442:
 1041              	 .loc 2 674 0
 1042 00ec D36C     	 ldr r3,[r2,#76]
 1043              	.LBE442:
 1044              	.LBE441:
 1045              	.LBE440:
1693:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
 1046              	 .loc 1 1693 0
 1047 00ee 91F82610 	 ldrb r1,[r1,#38]
 1048              	.LBB445:
 1049              	.LBB444:
 1050              	.LBB443:
 1051              	 .loc 2 674 0
 1052 00f2 43F40073 	 orr r3,r3,#512
 1053 00f6 D364     	 str r3,[r2,#76]
 1054              	.LBE443:
 1055              	.LBE444:
 1056              	.LBE445:
1693:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
 1057              	 .loc 1 1693 0
 1058 00f8 0029     	 cmp r1,#0
 1059 00fa A2D1     	 bne .L141
 1060 00fc 1046     	 mov r0,r2
 1061              	.LVL105:
 1062              	.L121:
 1063 00fe 013F     	 subs r7,r7,#1
 1064              	.LVL106:
 1065 0100 4FF00009 	 mov r9,#0
 1066              	.LVL107:
 1067              	.L128:
1697:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     {
 1068              	 .loc 1 1697 0
 1069 0104 09F10109 	 add r9,r9,#1
 1070              	.LVL108:
 1071 0108 4D45     	 cmp r5,r9
 1072 010a 3DD0     	 beq .L165
 1073              	.L123:
 1074              	.LVL109:
 1075              	.LBB446:
 1076              	.LBB447:
1666:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** }
 1077              	 .loc 4 1666 0
 1078 010c FFF7FEFF 	 bl XMC_I2C_CH_MasterReceiveAck
 1079              	.LVL110:
 1080              	.L124:
 1081 0110 2068     	 ldr r0,[r4]
 1082 0112 02E0     	 b .L126
 1083              	.LVL111:
 1084              	.L166:
 1085              	.LBE447:
 1086              	.LBE446:
 1087              	.LBB448:
 1088              	.LBB449:
 1089              	.LBB450:
 1090              	.LBB451:
 658:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** }
 1091              	 .loc 2 658 0
 1092 0114 836C     	 ldr r3,[r0,#72]
 1093              	.LBE451:
 1094              	.LBE450:
 1095              	.LBE449:
 1096              	.LBE448:
1706:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****          (I2C_MASTER_GetFlagStatus(handle, (uint32_t)XMC_I2C_CH_STATUS_FLAG_RECEIVE_INDICATION) == 
 1097              	 .loc 1 1706 0
 1098 0116 5A04     	 lsls r2,r3,#17
 1099 0118 02D4     	 bmi .L125
 1100              	.LVL112:
 1101              	.L126:
 1102              	.LBB452:
 1103              	.LBB453:
 1104              	.LBB454:
 1105              	.LBB455:
 658:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** }
 1106              	 .loc 2 658 0
 1107 011a 836C     	 ldr r3,[r0,#72]
 1108              	.LBE455:
 1109              	.LBE454:
 1110              	.LBE453:
 1111              	.LBE452:
1706:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****          (I2C_MASTER_GetFlagStatus(handle, (uint32_t)XMC_I2C_CH_STATUS_FLAG_RECEIVE_INDICATION) == 
 1112              	 .loc 1 1706 0
 1113 011c 1904     	 lsls r1,r3,#16
 1114 011e F9D5     	 bpl .L166
 1115              	.L125:
 1116              	.LVL113:
 1117              	.LBB456:
 1118              	.LBB457:
 1119              	.LBB458:
 1120              	 .loc 2 674 0
 1121 0120 C36C     	 ldr r3,[r0,#76]
 1122 0122 43F40043 	 orr r3,r3,#32768
 1123 0126 C364     	 str r3,[r0,#76]
 1124              	.LVL114:
 1125              	.LBE458:
 1126              	.LBE457:
 1127              	.LBE456:
 1128              	.LBB459:
 1129              	.LBB460:
 1130              	.LBB461:
 1131 0128 C36C     	 ldr r3,[r0,#76]
 1132 012a 43F48043 	 orr r3,r3,#16384
 1133 012e C364     	 str r3,[r0,#76]
 1134              	.LVL115:
 1135              	.LBE461:
 1136              	.LBE460:
 1137              	.LBE459:
 1138              	.LBB462:
 1139              	.LBB463:
1451:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** }
 1140              	 .loc 4 1451 0
 1141 0130 FFF7FEFF 	 bl XMC_I2C_CH_GetReceivedData
 1142              	.LVL116:
 1143              	.LBE463:
 1144              	.LBE462:
1695:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     {
 1145              	 .loc 1 1695 0
 1146 0134 A945     	 cmp r9,r5
1715:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     }
 1147              	 .loc 1 1715 0
 1148 0136 07F8010F 	 strb r0,[r7,#1]!
1695:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     {
 1149              	 .loc 1 1695 0
 1150 013a 07D0     	 beq .L127
 1151 013c 2068     	 ldr r0,[r4]
 1152 013e E1E7     	 b .L128
 1153              	.LVL117:
 1154              	.L133:
1721:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     {
 1155              	 .loc 1 1721 0
 1156 0140 5545     	 cmp r5,r10
 1157 0142 03D9     	 bls .L127
 1158 0144 2268     	 ldr r2,[r4]
 1159 0146 7FE7     	 b .L122
 1160              	.LVL118:
 1161              	.L129:
1745:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     {
 1162              	 .loc 1 1745 0
 1163 0148 CA45     	 cmp r10,r9
 1164 014a 90D8     	 bhi .L142
 1165              	.LVL119:
 1166              	.L127:
1750:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     }
1751:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     } /* end of while (temp_index < count) */
1752:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   } /* end of else */
1753:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1754:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     if (send_stop == true)
 1167              	 .loc 1 1754 0
 1168 014c 26B9     	 cbnz r6,.L167
1755:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     {
1756:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       handle->runtime->bus_acquired = false;
1757:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       I2C_MASTER_SendStop(handle);
1758:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     }
1759:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
1760:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     status = I2C_MASTER_STATUS_SUCCESS;
 1169              	 .loc 1 1760 0
 1170 014e 3046     	 mov r0,r6
 1171              	.LVL120:
 1172 0150 BDE8F88F 	 pop {r3,r4,r5,r6,r7,r8,r9,r10,fp,pc}
 1173              	.LVL121:
 1174              	.L140:
 1175 0154 2068     	 ldr r0,[r4]
 1176 0156 D2E7     	 b .L121
 1177              	.LVL122:
 1178              	.L167:
1756:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****       I2C_MASTER_SendStop(handle);
 1179              	 .loc 1 1756 0
 1180 0158 A368     	 ldr r3,[r4,#8]
 1181 015a 2068     	 ldr r0,[r4]
 1182              	.LVL123:
 1183 015c 0026     	 movs r6,#0
 1184              	.LVL124:
 1185 015e 83F82860 	 strb r6,[r3,#40]
 1186              	.LBB464:
 1187              	.LBB465:
 1188              	.LBB466:
 1189              	.LBB467:
 1190              	 .loc 2 674 0
 1191 0162 C36C     	 ldr r3,[r0,#76]
 1192 0164 43F01003 	 orr r3,r3,#16
 1193 0168 C364     	 str r3,[r0,#76]
 1194              	.LBE467:
 1195              	.LBE466:
1788:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** }
 1196              	 .loc 4 1788 0
 1197 016a FFF7FEFF 	 bl XMC_I2C_CH_MasterStop
 1198              	.LVL125:
 1199              	.LBE465:
 1200              	.LBE464:
 1201              	 .loc 1 1760 0
 1202 016e 3046     	 mov r0,r6
 1203 0170 BDE8F88F 	 pop {r3,r4,r5,r6,r7,r8,r9,r10,fp,pc}
 1204              	.LVL126:
 1205              	.L164:
 1206 0174 2068     	 ldr r0,[r4]
 1207              	.LVL127:
 1208              	.LBB468:
 1209              	.LBB435:
 1210              	.LBB428:
 1211              	.LBB429:
 1212              	.LBB430:
 1213              	.LBB431:
 1214              	.LBB432:
 1215              	 .loc 2 674 0
 1216 0176 C36C     	 ldr r3,[r0,#76]
 1217 0178 43F00803 	 orr r3,r3,#8
 1218              	.LBE432:
 1219              	.LBE431:
 1220              	 .loc 4 1912 0
 1221 017c 91B2     	 uxth r1,r2
 1222              	.LBB434:
 1223              	.LBB433:
 1224              	 .loc 2 674 0
 1225 017e C364     	 str r3,[r0,#76]
 1226              	.LBE433:
 1227              	.LBE434:
 1228              	 .loc 4 1912 0
 1229 0180 0122     	 movs r2,#1
 1230              	.LVL128:
 1231 0182 FFF7FEFF 	 bl XMC_I2C_CH_MasterRepeatedStart
 1232              	.LVL129:
 1233 0186 ACE7     	 b .L119
 1234              	.LVL130:
 1235              	.L165:
 1236              	.LBE430:
 1237              	.LBE429:
 1238              	.LBE428:
 1239              	.LBE435:
 1240              	.LBE468:
1697:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****     {
 1241              	 .loc 1 1697 0
 1242 0188 B8F1000F 	 cmp r8,#0
 1243 018c BED0     	 beq .L123
 1244              	.LVL131:
 1245              	.LBB469:
 1246              	.LBB470:
1736:../BSP/dave_fixes/I2C_MASTER/i2c_master.h **** }
 1247              	 .loc 4 1736 0
 1248 018e FFF7FEFF 	 bl XMC_I2C_CH_MasterReceiveNack
 1249              	.LVL132:
 1250 0192 BDE7     	 b .L124
 1251              	.LBE470:
 1252              	.LBE469:
 1253              	.LBE396:
 1254              	.LBE395:
 1255              	 .cfi_endproc
 1256              	.LFE240:
 1258              	 .section .text.I2C_MASTER_ProtocolHandler,"ax",%progbits
 1259              	 .align 2
 1260              	 .global I2C_MASTER_ProtocolHandler
 1261              	 .thumb
 1262              	 .thumb_func
 1264              	I2C_MASTER_ProtocolHandler:
 1265              	.LFB242:
1093:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   uint32_t psr_status;
 1266              	 .loc 1 1093 0
 1267              	 .cfi_startproc
 1268              	 
 1269              	 
 1270              	.LVL133:
 1271 0000 70B5     	 push {r4,r5,r6,lr}
 1272              	.LCFI6:
 1273              	 .cfi_def_cfa_offset 16
 1274              	 .cfi_offset 4,-16
 1275              	 .cfi_offset 5,-12
 1276              	 .cfi_offset 6,-8
 1277              	 .cfi_offset 14,-4
1096:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 1278              	 .loc 1 1096 0
 1279 0002 90E80C00 	 ldmia r0,{r2,r3}
 1280              	.LVL134:
1099:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
 1281              	 .loc 1 1099 0
 1282 0006 9969     	 ldr r1,[r3,#24]
 1283              	.LBB471:
 1284              	.LBB472:
 658:C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/XMCLib/inc\xmc_i2c.h **** }
 1285              	 .loc 2 658 0
 1286 0008 956C     	 ldr r5,[r2,#72]
 1287              	.LBE472:
 1288              	.LBE471:
1093:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   uint32_t psr_status;
 1289              	 .loc 1 1093 0
 1290 000a 0446     	 mov r4,r0
1099:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
 1291              	 .loc 1 1099 0
 1292 000c 09B1     	 cbz r1,.L169
1099:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
 1293              	 .loc 1 1099 0 is_stmt 0 discriminator 1
 1294 000e A806     	 lsls r0,r5,#26
 1295              	.LVL135:
 1296 0010 19D4     	 bmi .L187
 1297              	.LVL136:
 1298              	.L169:
1106:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
 1299              	 .loc 1 1106 0 is_stmt 1
 1300 0012 DA69     	 ldr r2,[r3,#28]
 1301 0014 0AB1     	 cbz r2,.L170
1106:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
 1302              	 .loc 1 1106 0 is_stmt 0 discriminator 1
 1303 0016 6906     	 lsls r1,r5,#25
 1304 0018 0DD4     	 bmi .L188
 1305              	.L170:
1113:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
 1306              	 .loc 1 1113 0 is_stmt 1
 1307 001a 1B6A     	 ldr r3,[r3,#32]
 1308 001c 13B1     	 cbz r3,.L168
1113:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
 1309              	 .loc 1 1113 0 is_stmt 0 discriminator 1
 1310 001e 15F4817F 	 tst r5,#258
 1311 0022 00D1     	 bne .L189
 1312              	.L168:
 1313 0024 70BD     	 pop {r4,r5,r6,pc}
 1314              	.LVL137:
 1315              	.L189:
 1316              	.LBB473:
 1317              	.LBB474:
 219:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** }
 1318              	 .loc 1 219 0 is_stmt 1
 1319 0026 2168     	 ldr r1,[r4]
 1320              	.LVL138:
 1321              	.LBB475:
 1322              	.LBB476:
 1323              	 .loc 2 674 0
 1324 0028 CA6C     	 ldr r2,[r1,#76]
 1325 002a 42F48072 	 orr r2,r2,#256
 1326 002e CA64     	 str r2,[r1,#76]
 1327              	.LBE476:
 1328              	.LBE475:
 1329              	.LBE474:
 1330              	.LBE473:
1118:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 1331              	 .loc 1 1118 0
 1332 0030 BDE87040 	 pop {r4,r5,r6,lr}
 1333              	.LCFI7:
 1334              	 .cfi_remember_state
 1335              	 .cfi_restore 14
 1336              	 .cfi_restore 6
 1337              	 .cfi_restore 5
 1338              	 .cfi_restore 4
 1339              	 .cfi_def_cfa_offset 0
 1340              	.LVL139:
1116:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   }
 1341              	 .loc 1 1116 0
 1342 0034 1847     	 bx r3
 1343              	.LVL140:
 1344              	.L188:
 1345              	.LCFI8:
 1346              	 .cfi_restore_state
 1347              	.LBB477:
 1348              	.LBB478:
 219:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** }
 1349              	 .loc 1 219 0
 1350 0036 2168     	 ldr r1,[r4]
 1351              	.LVL141:
 1352              	.LBB479:
 1353              	.LBB480:
 1354              	 .loc 2 674 0
 1355 0038 CB6C     	 ldr r3,[r1,#76]
 1356 003a 43F04003 	 orr r3,r3,#64
 1357 003e CB64     	 str r3,[r1,#76]
 1358              	.LBE480:
 1359              	.LBE479:
 1360              	.LBE478:
 1361              	.LBE477:
1109:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   }
 1362              	 .loc 1 1109 0
 1363 0040 9047     	 blx r2
 1364              	.LVL142:
 1365 0042 6368     	 ldr r3,[r4,#4]
 1366 0044 E9E7     	 b .L170
 1367              	.LVL143:
 1368              	.L187:
 1369              	.LBB481:
 1370              	.LBB482:
 1371              	.LBB483:
 1372              	 .loc 2 674 0
 1373 0046 D36C     	 ldr r3,[r2,#76]
 1374 0048 43F02003 	 orr r3,r3,#32
 1375 004c D364     	 str r3,[r2,#76]
 1376              	.LBE483:
 1377              	.LBE482:
 1378              	.LBE481:
1102:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   }
 1379              	 .loc 1 1102 0
 1380 004e 8847     	 blx r1
 1381              	.LVL144:
 1382 0050 6368     	 ldr r3,[r4,#4]
 1383 0052 DEE7     	 b .L169
 1384              	 .cfi_endproc
 1385              	.LFE242:
 1387              	 .section .text.I2C_MASTER_AbortTransmit,"ax",%progbits
 1388              	 .align 2
 1389              	 .global I2C_MASTER_AbortTransmit
 1390              	 .thumb
 1391              	 .thumb_func
 1393              	I2C_MASTER_AbortTransmit:
 1394              	.LFB243:
1170:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   I2C_MASTER_STATUS_t status;
 1395              	 .loc 1 1170 0
 1396              	 .cfi_startproc
 1397              	 
 1398              	 
 1399              	 
 1400              	.LVL145:
1191:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   handle->channel->FMR = 0x00000002U;/*clear TDV*/
 1401              	 .loc 1 1191 0
 1402 0000 0368     	 ldr r3,[r0]
1175:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
 1403              	 .loc 1 1175 0
 1404 0002 4068     	 ldr r0,[r0,#4]
 1405              	.LVL146:
1191:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   handle->channel->FMR = 0x00000002U;/*clear TDV*/
 1406              	 .loc 1 1191 0
 1407 0004 DA6C     	 ldr r2,[r3,#76]
1175:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
 1408              	 .loc 1 1175 0
 1409 0006 90F82400 	 ldrb r0,[r0,#36]
 1410              	.LVL147:
1192:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 1411              	 .loc 1 1192 0
 1412 000a 0221     	 movs r1,#2
1195:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 1413              	 .loc 1 1195 0
 1414 000c 0128     	 cmp r0,#1
1191:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   handle->channel->FMR = 0x00000002U;/*clear TDV*/
 1415              	 .loc 1 1191 0
 1416 000e 42EA0102 	 orr r2,r2,r1
 1417 0012 DA64     	 str r2,[r3,#76]
1195:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 1418              	 .loc 1 1195 0
 1419 0014 94BF     	 ite ls
 1420 0016 0020     	 movls r0,#0
 1421              	.LVL148:
 1422 0018 0120     	 movhi r0,#1
1192:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 1423              	 .loc 1 1192 0
 1424 001a 9966     	 str r1,[r3,#104]
1195:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 1425              	 .loc 1 1195 0
 1426 001c 7047     	 bx lr
 1427              	 .cfi_endproc
 1428              	.LFE243:
 1430 001e 00BF     	 .section .text.I2C_MASTER_AbortReceive,"ax",%progbits
 1431              	 .align 2
 1432              	 .global I2C_MASTER_AbortReceive
 1433              	 .thumb
 1434              	 .thumb_func
 1436              	I2C_MASTER_AbortReceive:
 1437              	.LFB244:
1209:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   I2C_MASTER_STATUS_t status;
 1438              	 .loc 1 1209 0
 1439              	 .cfi_startproc
 1440              	 
 1441              	 
 1442              	 
 1443              	.LVL149:
1214:../BSP/dave_fixes/I2C_MASTER/i2c_master.c ****   {
 1444              	 .loc 1 1214 0
 1445 0000 4368     	 ldr r3,[r0,#4]
 1446 0002 93F82500 	 ldrb r0,[r3,#37]
 1447              	.LVL150:
1232:../BSP/dave_fixes/I2C_MASTER/i2c_master.c **** 
 1448              	 .loc 1 1232 0
 1449 0006 0128     	 cmp r0,#1
 1450 0008 94BF     	 ite ls
 1451 000a 0020     	 movls r0,#0
 1452 000c 0120     	 movhi r0,#1
 1453 000e 7047     	 bx lr
 1454              	 .cfi_endproc
 1455              	.LFE244:
 1457              	 .global I2C_Timeout
 1458              	 .section .bss.I2C_Timeout,"aw",%nobits
 1459              	 .align 2
 1460              	 .set .LANCHOR0,.+0
 1463              	I2C_Timeout:
 1464 0000 00000000 	 .space 4
 1465              	 .text
 1466              	.Letext0:
 1467              	 .file 5 "c:\\infineon\\tools\\dave ide\\4.5.0.202105191637\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\machine\\_default_types.h"
 1468              	 .file 6 "c:\\infineon\\tools\\dave ide\\4.5.0.202105191637\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\stdint.h"
 1469              	 .file 7 "C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/CMSIS/Infineon/XMC4700_series/Include/XMC4700.h"
 1470              	 .file 8 "C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Dave/Generated/DAVE_Common.h"
 1471              	 .file 9 "C:/Users/Utente/Desktop/Tesi/Firmware_Software/DAVE project/S2GLP_Pulsed_Doppler/Libraries/CMSIS/Include/core_cm4.h"
DEFINED SYMBOLS
                            *ABS*:00000000 i2c_master.c
    {standard input}:20     .text.I2C_MASTER_GetAppVersion:00000000 $t
    {standard input}:25     .text.I2C_MASTER_GetAppVersion:00000000 I2C_MASTER_GetAppVersion
    {standard input}:56     .text.I2C_MASTER_Init:00000000 $t
    {standard input}:61     .text.I2C_MASTER_Init:00000000 I2C_MASTER_Init
    {standard input}:98     .text.I2C_MASTER_GetFlagStatus:00000000 $t
    {standard input}:103    .text.I2C_MASTER_GetFlagStatus:00000000 I2C_MASTER_GetFlagStatus
    {standard input}:129    .text.I2C_MASTER_ClearFlag:00000000 $t
    {standard input}:134    .text.I2C_MASTER_ClearFlag:00000000 I2C_MASTER_ClearFlag
    {standard input}:159    .text.I2C_MASTER_Transmit:00000000 $t
    {standard input}:164    .text.I2C_MASTER_Transmit:00000000 I2C_MASTER_Transmit
    {standard input}:753    .text.I2C_MASTER_Transmit:00000200 $d
    {standard input}:765    .text.I2C_MASTER_Receive:00000000 $t
    {standard input}:770    .text.I2C_MASTER_Receive:00000000 I2C_MASTER_Receive
    {standard input}:1259   .text.I2C_MASTER_ProtocolHandler:00000000 $t
    {standard input}:1264   .text.I2C_MASTER_ProtocolHandler:00000000 I2C_MASTER_ProtocolHandler
    {standard input}:1388   .text.I2C_MASTER_AbortTransmit:00000000 $t
    {standard input}:1393   .text.I2C_MASTER_AbortTransmit:00000000 I2C_MASTER_AbortTransmit
    {standard input}:1431   .text.I2C_MASTER_AbortReceive:00000000 $t
    {standard input}:1436   .text.I2C_MASTER_AbortReceive:00000000 I2C_MASTER_AbortReceive
    {standard input}:1463   .bss.I2C_Timeout:00000000 I2C_Timeout
    {standard input}:1459   .bss.I2C_Timeout:00000000 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
XMC_I2C_CH_MasterTransmit
XMC_I2C_CH_MasterStart
XMC_I2C_CH_MasterStop
XMC_I2C_CH_MasterRepeatedStart
XMC_I2C_CH_MasterReceiveAck
XMC_I2C_CH_GetReceivedData
XMC_I2C_CH_MasterReceiveNack
