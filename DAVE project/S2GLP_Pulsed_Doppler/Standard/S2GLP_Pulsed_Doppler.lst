
S2GLP_Pulsed_Doppler.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00000294  08000000  0c000000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0000ff84  08020000  0c020000  00010000  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .ARM.exidx    00000008  0802ff84  0c02ff84  0001ff84  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 Stack         00001000  1ffe8000  1ffe8000  00028000  2**0
                  ALLOC
  4 .data         000006a8  1ffe9000  0c02ff8c  00021000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .bss          0000706c  1ffe96a8  0c030634  000216a8  2**2
                  ALLOC
  6 USB_RAM       00000e00  20000000  20000000  00028000  2**2
                  ALLOC
  7 .no_init      00000014  2003ffc0  2003ffc0  00027fc0  2**2
                  ALLOC
  8 .debug_aranges 00001d30  00000000  00000000  000216a8  2**3
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_info   0007a2ab  00000000  00000000  000233d8  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 0000d355  00000000  00000000  0009d683  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   0001abe5  00000000  00000000  000aa9d8  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_frame  000054d0  00000000  00000000  000c55c0  2**2
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    00018211  00000000  00000000  000caa90  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    0001f4b7  00000000  00000000  000e2ca1  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_ranges 00005550  00000000  00000000  00102158  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .build_attributes 000018d5  00000000  00000000  001076a8  2**0
                  CONTENTS, READONLY

Disassembly of section .text:

08020000 <ds_get_board_variant>:
	return def_settings_changed;
}

uint32_t ds_get_board_variant( void )
{
	return detected_board_variant;
 8020000:	4b01      	ldr	r3, [pc, #4]	; (8020008 <ds_get_board_variant+0x8>)
}
 8020002:	6818      	ldr	r0, [r3, #0]
 8020004:	4770      	bx	lr
 8020006:	bf00      	nop
 8020008:	1ffe96ac 	.word	0x1ffe96ac

0802000c <ds_store_algo_result_ptr>:

//============================================================================

void ds_store_algo_result_ptr(algo_result_t *p_result)
{
	p_ds_algo_results = p_result;
 802000c:	4b01      	ldr	r3, [pc, #4]	; (8020014 <ds_store_algo_result_ptr+0x8>)
 802000e:	6018      	str	r0, [r3, #0]
 8020010:	4770      	bx	lr
 8020012:	bf00      	nop
 8020014:	1ffe96a8 	.word	0x1ffe96a8

08020018 <ds_algo_get_settings>:
//============================================================================

algo_settings_t *ds_algo_get_settings(void)
{
  return &ds_algo_settings;
}
 8020018:	4800      	ldr	r0, [pc, #0]	; (802001c <ds_algo_get_settings+0x4>)
 802001a:	4770      	bx	lr
 802001c:	1ffe96b4 	.word	0x1ffe96b4

08020020 <ds_algo_check_settings>:
 */
uint32_t ds_algo_check_settings(algo_settings_t *ptr)
{
  uint32_t retval = 0;

  if (!((ptr->speed_detection_threshold >= BSP_MIN_SPEED_DETECTION_THRESHOLD) && (ptr->speed_detection_threshold <= BSP_MAX_SPEED_DETECTION_THRESHOLD)))
 8020020:	edd0 7a02 	vldr	s15, [r0, #8]
 8020024:	eeb7 7a00 	vmov.f32	s14, #112	; 0x70
 8020028:	eef4 7ac7 	vcmpe.f32	s15, s14
 802002c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr

/* if staged Algo settings are with-in range 0 is return, otherwise non-zero
 * the return value could be interpreted as bit field to identify the failure, if needed!
 */
uint32_t ds_algo_check_settings(algo_settings_t *ptr)
{
 8020030:	4603      	mov	r3, r0
  uint32_t retval = 0;

  if (!((ptr->speed_detection_threshold >= BSP_MIN_SPEED_DETECTION_THRESHOLD) && (ptr->speed_detection_threshold <= BSP_MAX_SPEED_DETECTION_THRESHOLD)))
 8020032:	db33      	blt.n	802009c <ds_algo_check_settings+0x7c>
 8020034:	ed9f 7a1b 	vldr	s14, [pc, #108]	; 80200a4 <ds_algo_check_settings+0x84>
 8020038:	eef4 7ac7 	vcmpe.f32	s15, s14
 802003c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8020040:	bf95      	itete	ls
 8020042:	2202      	movls	r2, #2
 8020044:	2203      	movhi	r2, #3
 8020046:	2000      	movls	r0, #0
 8020048:	2001      	movhi	r0, #1
  {
    retval += 1;
  }
  if (!(ptr->max_speed_kmph > ptr->min_speed_kmph) && (ptr->max_speed_kmph <= BSP_MAX_SPEED_KMPH))
 802004a:	edd3 7a04 	vldr	s15, [r3, #16]
 802004e:	ed93 7a03 	vldr	s14, [r3, #12]
 8020052:	eef4 7ac7 	vcmpe.f32	s15, s14
 8020056:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802005a:	dc07      	bgt.n	802006c <ds_algo_check_settings+0x4c>
 802005c:	eddf 6a12 	vldr	s13, [pc, #72]	; 80200a8 <ds_algo_check_settings+0x88>
  {
    retval += 2;
 8020060:	eef4 7a66 	vcmp.f32	s15, s13
 8020064:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8020068:	bf98      	it	ls
 802006a:	4610      	movls	r0, r2
  }
  if (ptr->min_speed_kmph > ptr->max_speed_kmph)
 802006c:	eef4 7ac7 	vcmpe.f32	s15, s14
  {
    retval += 4;
  }
  if (!(ptr->motion_detection_threshold >= BSP_MIN_MOTION_DETECTION_THRESHOLD) && (ptr->motion_detection_threshold <= BSP_MAX_MOTION_DETECTION_THRESHOLD))
 8020070:	edd3 7a0a 	vldr	s15, [r3, #40]	; 0x28
 8020074:	eeb7 7a00 	vmov.f32	s14, #112	; 0x70
  }
  if (!(ptr->max_speed_kmph > ptr->min_speed_kmph) && (ptr->max_speed_kmph <= BSP_MAX_SPEED_KMPH))
  {
    retval += 2;
  }
  if (ptr->min_speed_kmph > ptr->max_speed_kmph)
 8020078:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  {
    retval += 4;
  }
  if (!(ptr->motion_detection_threshold >= BSP_MIN_MOTION_DETECTION_THRESHOLD) && (ptr->motion_detection_threshold <= BSP_MAX_MOTION_DETECTION_THRESHOLD))
 802007c:	eef4 7ac7 	vcmpe.f32	s15, s14
  {
    retval += 2;
  }
  if (ptr->min_speed_kmph > ptr->max_speed_kmph)
  {
    retval += 4;
 8020080:	bf48      	it	mi
 8020082:	3004      	addmi	r0, #4
  }
  if (!(ptr->motion_detection_threshold >= BSP_MIN_MOTION_DETECTION_THRESHOLD) && (ptr->motion_detection_threshold <= BSP_MAX_MOTION_DETECTION_THRESHOLD))
 8020084:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8020088:	da07      	bge.n	802009a <ds_algo_check_settings+0x7a>
 802008a:	ed9f 7a06 	vldr	s14, [pc, #24]	; 80200a4 <ds_algo_check_settings+0x84>
 802008e:	eef4 7ac7 	vcmpe.f32	s15, s14
 8020092:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  {
	 retval += 8;
 8020096:	bf98      	it	ls
 8020098:	3008      	addls	r0, #8
  }
  
  return retval;
}
 802009a:	4770      	bx	lr
 802009c:	2203      	movs	r2, #3
{
  uint32_t retval = 0;

  if (!((ptr->speed_detection_threshold >= BSP_MIN_SPEED_DETECTION_THRESHOLD) && (ptr->speed_detection_threshold <= BSP_MAX_SPEED_DETECTION_THRESHOLD)))
  {
    retval += 1;
 802009e:	2001      	movs	r0, #1
 80200a0:	e7d3      	b.n	802004a <ds_algo_check_settings+0x2a>
 80200a2:	bf00      	nop
 80200a4:	44fa0000 	.word	0x44fa0000
 80200a8:	44870000 	.word	0x44870000

080200ac <ds_dev_check_settings>:

/* if staged Algo settings are with-in range 0 is return, otherwise non-zero
 * the return value could be interpreted as bit field to identify the failure, if needed!
 */
uint32_t ds_dev_check_settings(device_settings_t *ptr)
{
 80200ac:	b570      	push	{r4, r5, r6, lr}

  if (!((ptr->num_sample_skip_count >= BSP_MIN_SAMPLE_SKIP_COUNT) && (ptr->num_sample_skip_count <= BSP_MAX_SAMPLE_SKIP_COUNT)))
  {
    retval += 1;
  }
  if (!(ptr->adc_sampling_freq_Hz >= BSP_MIN_DOPPLER_SAMPLING_FREQ_HZ && (ptr->adc_sampling_freq_Hz <= BSP_MAX_DOPPLER_SAMPLING_FREQ_HZ)))
 80200ae:	6943      	ldr	r3, [r0, #20]
 */
uint32_t ds_dev_check_settings(device_settings_t *ptr)
{
  uint32_t retval = 0;

  if (!((ptr->num_sample_skip_count >= BSP_MIN_SAMPLE_SKIP_COUNT) && (ptr->num_sample_skip_count <= BSP_MAX_SAMPLE_SKIP_COUNT)))
 80200b0:	6ac4      	ldr	r4, [r0, #44]	; 0x2c

/* if staged Algo settings are with-in range 0 is return, otherwise non-zero
 * the return value could be interpreted as bit field to identify the failure, if needed!
 */
uint32_t ds_dev_check_settings(device_settings_t *ptr)
{
 80200b2:	4605      	mov	r5, r0
  uint32_t retval = 0;

  if (!((ptr->num_sample_skip_count >= BSP_MIN_SAMPLE_SKIP_COUNT) && (ptr->num_sample_skip_count <= BSP_MAX_SAMPLE_SKIP_COUNT)))
 80200b4:	f5b4 7f7a 	cmp.w	r4, #1000	; 0x3e8
  {
    retval += 1;
  }
  if (!(ptr->adc_sampling_freq_Hz >= BSP_MIN_DOPPLER_SAMPLING_FREQ_HZ && (ptr->adc_sampling_freq_Hz <= BSP_MAX_DOPPLER_SAMPLING_FREQ_HZ)))
 80200b8:	f5a3 737a 	sub.w	r3, r3, #1000	; 0x3e8
 */
uint32_t ds_dev_check_settings(device_settings_t *ptr)
{
  uint32_t retval = 0;

  if (!((ptr->num_sample_skip_count >= BSP_MIN_SAMPLE_SKIP_COUNT) && (ptr->num_sample_skip_count <= BSP_MAX_SAMPLE_SKIP_COUNT)))
 80200bc:	bf8c      	ite	hi
 80200be:	2401      	movhi	r4, #1
 80200c0:	2400      	movls	r4, #0
  {
    retval += 1;
  }
  if (!(ptr->adc_sampling_freq_Hz >= BSP_MIN_DOPPLER_SAMPLING_FREQ_HZ && (ptr->adc_sampling_freq_Hz <= BSP_MAX_DOPPLER_SAMPLING_FREQ_HZ)))
 80200c2:	f5b3 6f7a 	cmp.w	r3, #4000	; 0xfa0
  {
    retval += 2;
 80200c6:	bf88      	it	hi
 80200c8:	3402      	addhi	r4, #2
  }
  if (!(ptr->frame_period_usec >= bsp_calc_min_frame_interval_usec(ptr)) && (ptr->frame_period_usec*1000 <= BSP_MAX_FRAME_PERIOD_MSEC))
 80200ca:	6a2e      	ldr	r6, [r5, #32]
 80200cc:	f009 fff4 	bl	802a0b8 <bsp_calc_min_frame_interval_usec>
 80200d0:	4286      	cmp	r6, r0
 80200d2:	d208      	bcs.n	80200e6 <ds_dev_check_settings+0x3a>
 80200d4:	6a2a      	ldr	r2, [r5, #32]
 80200d6:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80200da:	fb03 f302 	mul.w	r3, r3, r2
 80200de:	f5b3 6ffa 	cmp.w	r3, #2000	; 0x7d0
  {
    retval += 4;
 80200e2:	bf98      	it	ls
 80200e4:	3404      	addls	r4, #4
  }
  if (!(ptr->num_samples_per_chirp >= BSP_MIN_NUM_SAMPLES_PER_CHIRP) && (ptr->num_samples_per_chirp <= BSP_MAX_NUM_SAMPLES_PER_CHIRP))
 80200e6:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 80200e8:	2b1f      	cmp	r3, #31
  {
	 retval += 8;
  }
  if (ptr->adc_resolution != 12)
 80200ea:	7e2b      	ldrb	r3, [r5, #24]
  {
    retval += 4;
  }
  if (!(ptr->num_samples_per_chirp >= BSP_MIN_NUM_SAMPLES_PER_CHIRP) && (ptr->num_samples_per_chirp <= BSP_MAX_NUM_SAMPLES_PER_CHIRP))
  {
	 retval += 8;
 80200ec:	bf98      	it	ls
 80200ee:	3408      	addls	r4, #8
  }
  if (ptr->adc_resolution != 12)
 80200f0:	2b0c      	cmp	r3, #12
  {
	  retval += 16;
 80200f2:	bf18      	it	ne
 80200f4:	3410      	addne	r4, #16
  }
  return retval;
}
 80200f6:	4620      	mov	r0, r4
 80200f8:	bd70      	pop	{r4, r5, r6, pc}
 80200fa:	bf00      	nop

080200fc <ds_device_get_settings>:
//============================================================================

device_settings_t *ds_device_get_settings(void)
{
  return &ds_device_settings;
}
 80200fc:	4800      	ldr	r0, [pc, #0]	; (8020100 <ds_device_get_settings+0x4>)
 80200fe:	4770      	bx	lr
 8020100:	1ffe9724 	.word	0x1ffe9724

08020104 <ds_device_get_shadow_settings>:
//============================================================================

device_settings_t *ds_device_get_shadow_settings(void)
{
  return &ds_shadow_device_settings;
}
 8020104:	4800      	ldr	r0, [pc, #0]	; (8020108 <ds_device_get_shadow_settings+0x4>)
 8020106:	4770      	bx	lr
 8020108:	1ffe96e4 	.word	0x1ffe96e4

0802010c <ds_is_device_settings_updated>:

//============================================================================

/* handling for staged setting */
uint32_t ds_is_device_settings_updated(void)
{
 802010c:	b508      	push	{r3, lr}
  int32_t retval = 0;
  
  /* if both structs are identical, retval is 0, otherwise != 0 */
  retval = memcmp(&ds_shadow_device_settings,&ds_device_settings, sizeof(ds_shadow_device_settings));
 802010e:	4904      	ldr	r1, [pc, #16]	; (8020120 <ds_is_device_settings_updated+0x14>)
 8020110:	4804      	ldr	r0, [pc, #16]	; (8020124 <ds_is_device_settings_updated+0x18>)
 8020112:	2240      	movs	r2, #64	; 0x40
 8020114:	f00d fa04 	bl	802d520 <memcmp>
  
  // result of memcmp could be negative!
  return (retval == 0) ? 0U : 1U;
}
 8020118:	3000      	adds	r0, #0
 802011a:	bf18      	it	ne
 802011c:	2001      	movne	r0, #1
 802011e:	bd08      	pop	{r3, pc}
 8020120:	1ffe9724 	.word	0x1ffe9724
 8020124:	1ffe96e4 	.word	0x1ffe96e4

08020128 <ds_device_settings_copy_to_shadow>:

//============================================================================

void ds_device_settings_copy_to_shadow(void)
{
 8020128:	b430      	push	{r4, r5}
  memcpy(&ds_shadow_device_settings, &ds_device_settings, sizeof(ds_shadow_device_settings));
 802012a:	4d07      	ldr	r5, [pc, #28]	; (8020148 <ds_device_settings_copy_to_shadow+0x20>)
 802012c:	4c07      	ldr	r4, [pc, #28]	; (802014c <ds_device_settings_copy_to_shadow+0x24>)
 802012e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8020130:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8020132:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8020134:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8020136:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8020138:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 802013a:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 802013e:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
}
 8020142:	bc30      	pop	{r4, r5}
 8020144:	4770      	bx	lr
 8020146:	bf00      	nop
 8020148:	1ffe9724 	.word	0x1ffe9724
 802014c:	1ffe96e4 	.word	0x1ffe96e4

08020150 <ds_device_settings_revert_from_shadow>:

//============================================================================

void ds_device_settings_revert_from_shadow(void)
{
 8020150:	b430      	push	{r4, r5}
  memcpy(&ds_device_settings, &ds_shadow_device_settings,  sizeof(ds_shadow_device_settings));
 8020152:	4d07      	ldr	r5, [pc, #28]	; (8020170 <ds_device_settings_revert_from_shadow+0x20>)
 8020154:	4c07      	ldr	r4, [pc, #28]	; (8020174 <ds_device_settings_revert_from_shadow+0x24>)
 8020156:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8020158:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 802015a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 802015c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 802015e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8020160:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8020162:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 8020166:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
}
 802016a:	bc30      	pop	{r4, r5}
 802016c:	4770      	bx	lr
 802016e:	bf00      	nop
 8020170:	1ffe96e4 	.word	0x1ffe96e4
 8020174:	1ffe9724 	.word	0x1ffe9724

08020178 <ds_init>:

static char rf_board_id_1[] = RF_BOARD_ID;
static char rf_board_id_2[] = "RBBPDV10";  // Check for previous compatible board-id

uint32_t ds_init(void)
{
 8020178:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
#ifdef DS_USE_EEPROM
  RF_SHIELD_STATUS_t shield_status = RF_SHIELD_BOARD_NOT_CONNECTED;
  EEPROM_STATUS_t ret_status = EEPROM_STATUS_FAILURE;

  /* Read RF board ID, check if a valid board ID is written in EEPROM */
  shield_status = ds_eeprom_read_board_id(rf_board_id_1, sizeof(rf_board_id_1));
 802017c:	48bd      	ldr	r0, [pc, #756]	; (8020474 <ds_init+0x2fc>)

static char rf_board_id_1[] = RF_BOARD_ID;
static char rf_board_id_2[] = "RBBPDV10";  // Check for previous compatible board-id

uint32_t ds_init(void)
{
 802017e:	b083      	sub	sp, #12
#ifdef DS_USE_EEPROM
  RF_SHIELD_STATUS_t shield_status = RF_SHIELD_BOARD_NOT_CONNECTED;
  EEPROM_STATUS_t ret_status = EEPROM_STATUS_FAILURE;

  /* Read RF board ID, check if a valid board ID is written in EEPROM */
  shield_status = ds_eeprom_read_board_id(rf_board_id_1, sizeof(rf_board_id_1));
 8020180:	2109      	movs	r1, #9
 8020182:	f000 fab3 	bl	80206ec <ds_eeprom_read_board_id>
  if (shield_status == RF_SHIELD_BOARD_UNSUPPORTED)
 8020186:	2803      	cmp	r0, #3
#ifdef DS_USE_EEPROM
  RF_SHIELD_STATUS_t shield_status = RF_SHIELD_BOARD_NOT_CONNECTED;
  EEPROM_STATUS_t ret_status = EEPROM_STATUS_FAILURE;

  /* Read RF board ID, check if a valid board ID is written in EEPROM */
  shield_status = ds_eeprom_read_board_id(rf_board_id_1, sizeof(rf_board_id_1));
 8020188:	4604      	mov	r4, r0
  if (shield_status == RF_SHIELD_BOARD_UNSUPPORTED)
 802018a:	d01a      	beq.n	80201c2 <ds_init+0x4a>
	  shield_status = ds_eeprom_read_board_id(rf_board_id_2, sizeof(rf_board_id_2));
	  if (shield_status == RF_SHIELD_BOARD_SUPPORTED)
		  board_variant = 1;
  }

  if (shield_status != RF_SHIELD_BOARD_SUPPORTED)
 802018c:	2802      	cmp	r0, #2
 802018e:	d03b      	beq.n	8020208 <ds_init+0x90>
  {
	/* Unsupported RF board !!!!!! */
#if !defined(BUILD_FOR_ARDUINO)
	bsp_led_green_off();
 8020190:	f008 fdc6 	bl	8028d20 <bsp_led_green_off>
    bsp_led_blue_off();
 8020194:	f008 fdd8 	bl	8028d48 <bsp_led_blue_off>
	bsp_led_red_off();
 8020198:	f008 fdea 	bl	8028d70 <bsp_led_red_off>

	/*  TODO: Remove before the release!! */
	if (shield_status == RF_SHIELD_BOARD_NOT_PROGRAMMED)
 802019c:	2c04      	cmp	r4, #4
 802019e:	f000 818d 	beq.w	80204bc <ds_init+0x344>
      else
      {
        /* Invalid RF shield board:
    	   1- RF shield is not programmed or it contains invalid data
    	   2- Or RF shield board is not connected */
    	TIMER_SetTimeInterval(&TIMER_ERROR_TOGGLE, 100 * 1000U * 100U);
 80201a2:	49b5      	ldr	r1, [pc, #724]	; (8020478 <ds_init+0x300>)
 80201a4:	48b5      	ldr	r0, [pc, #724]	; (802047c <ds_init+0x304>)
 80201a6:	f005 fe87 	bl	8025eb8 <TIMER_SetTimeInterval>
    	bsp_timer_start(&TIMER_ERROR_TOGGLE);
 80201aa:	48b4      	ldr	r0, [pc, #720]	; (802047c <ds_init+0x304>)
 80201ac:	f009 fb4e 	bl	802984c <bsp_timer_start>

  	    device_status_set_error(FATAL_ERROR_INVALID_RF_SHIELD);
 80201b0:	f244 1001 	movw	r0, #16641	; 0x4101
 80201b4:	f000 fd12 	bl	8020bdc <device_status_set_error>
  	    return RF_SHIELD_INVALID;
 80201b8:	f243 0001 	movw	r0, #12289	; 0x3001
  memcpy(&ds_algo_settings, &ds_default_algo_settings, sizeof(algo_settings_t));
  retval += ds_algo_check_settings(&ds_algo_settings);
#endif /* DS_USE_EEPROM */
  
  return retval;
}
 80201bc:	b003      	add	sp, #12
 80201be:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  /* Read RF board ID, check if a valid board ID is written in EEPROM */
  shield_status = ds_eeprom_read_board_id(rf_board_id_1, sizeof(rf_board_id_1));
  if (shield_status == RF_SHIELD_BOARD_UNSUPPORTED)
  {
	  /* Read RF board ID, check if a valid board ID is written in EEPROM */
	  shield_status = ds_eeprom_read_board_id(rf_board_id_2, sizeof(rf_board_id_2));
 80201c2:	48af      	ldr	r0, [pc, #700]	; (8020480 <ds_init+0x308>)
 80201c4:	2109      	movs	r1, #9
 80201c6:	f000 fa91 	bl	80206ec <ds_eeprom_read_board_id>
	  if (shield_status == RF_SHIELD_BOARD_SUPPORTED)
 80201ca:	2802      	cmp	r0, #2
  /* Read RF board ID, check if a valid board ID is written in EEPROM */
  shield_status = ds_eeprom_read_board_id(rf_board_id_1, sizeof(rf_board_id_1));
  if (shield_status == RF_SHIELD_BOARD_UNSUPPORTED)
  {
	  /* Read RF board ID, check if a valid board ID is written in EEPROM */
	  shield_status = ds_eeprom_read_board_id(rf_board_id_2, sizeof(rf_board_id_2));
 80201cc:	4604      	mov	r4, r0
	  if (shield_status == RF_SHIELD_BOARD_SUPPORTED)
 80201ce:	f000 818b 	beq.w	80204e8 <ds_init+0x370>

  if (shield_status != RF_SHIELD_BOARD_SUPPORTED)
  {
	/* Unsupported RF board !!!!!! */
#if !defined(BUILD_FOR_ARDUINO)
	bsp_led_green_off();
 80201d2:	f008 fda5 	bl	8028d20 <bsp_led_green_off>
    bsp_led_blue_off();
 80201d6:	f008 fdb7 	bl	8028d48 <bsp_led_blue_off>
	bsp_led_red_off();
 80201da:	f008 fdc9 	bl	8028d70 <bsp_led_red_off>

	/*  TODO: Remove before the release!! */
	if (shield_status == RF_SHIELD_BOARD_NOT_PROGRAMMED)
 80201de:	2c04      	cmp	r4, #4
 80201e0:	f000 816c 	beq.w	80204bc <ds_init+0x344>
			bsp_timer_start(&TIMER_ERROR_TOGGLE);
	    	device_status_set_error(FATAL_ERROR_BOARD_NOT_PROGRAMMED);
			return RF_SHIELD_NOT_PROGRAMMED;
		}
	}
    else if (shield_status == RF_SHIELD_BOARD_UNSUPPORTED)
 80201e4:	2c03      	cmp	r4, #3
 80201e6:	d1dc      	bne.n	80201a2 <ds_init+0x2a>
      {
        /* RF shield board is not compatible and is not supported in the current Firmware.
    	   Shield programmed with the wrong ID, For example RBBxxxxxx */

		TIMER_SetTimeInterval(&TIMER_ERROR_TOGGLE, 400 * 1000U * 100U);
 80201e8:	49a6      	ldr	r1, [pc, #664]	; (8020484 <ds_init+0x30c>)
 80201ea:	48a4      	ldr	r0, [pc, #656]	; (802047c <ds_init+0x304>)
 80201ec:	f005 fe64 	bl	8025eb8 <TIMER_SetTimeInterval>
		bsp_timer_start(&TIMER_ERROR_TOGGLE);
 80201f0:	48a2      	ldr	r0, [pc, #648]	; (802047c <ds_init+0x304>)
 80201f2:	f009 fb2b 	bl	802984c <bsp_timer_start>
    	device_status_set_error(FATAL_ERROR_BOARD_NOT_SUPPORTED);
 80201f6:	f44f 4082 	mov.w	r0, #16640	; 0x4100
 80201fa:	f000 fcef 	bl	8020bdc <device_status_set_error>
    	return RF_SHIELD_UNSUPPORTED;
 80201fe:	f44f 5040 	mov.w	r0, #12288	; 0x3000
  memcpy(&ds_algo_settings, &ds_default_algo_settings, sizeof(algo_settings_t));
  retval += ds_algo_check_settings(&ds_algo_settings);
#endif /* DS_USE_EEPROM */
  
  return retval;
}
 8020202:	b003      	add	sp, #12
 8020204:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

uint32_t ds_init(void)
{
  /* this function could be used to pre-init the settings store, e.g. with persistent value, that are stored in some persistent memory region */
  uint32_t retval = 0;
  uint32_t board_variant = 2;
 8020208:	2702      	movs	r7, #2
//============================================================================

uint32_t calc_settings_crc(void *p_settings, uint32_t struct_size)
{
	uint32_t crc32 = 0;
	CRC_SW_CalculateCRC(&CRC_SW_EEPROM, p_settings, struct_size);
 802020a:	499f      	ldr	r1, [pc, #636]	; (8020488 <ds_init+0x310>)
 802020c:	489f      	ldr	r0, [pc, #636]	; (802048c <ds_init+0x314>)
 802020e:	2240      	movs	r2, #64	; 0x40
 8020210:	f006 fb30 	bl	8026874 <CRC_SW_CalculateCRC>
	crc32 = CRC_SW_GetCRCResult(&CRC_SW_EEPROM);
 8020214:	489d      	ldr	r0, [pc, #628]	; (802048c <ds_init+0x314>)
 8020216:	f006 fb6f 	bl	80268f8 <CRC_SW_GetCRCResult>
//============================================================================

uint32_t calc_settings_crc(void *p_settings, uint32_t struct_size)
{
	uint32_t crc32 = 0;
	CRC_SW_CalculateCRC(&CRC_SW_EEPROM, p_settings, struct_size);
 802021a:	499d      	ldr	r1, [pc, #628]	; (8020490 <ds_init+0x318>)
 802021c:	222c      	movs	r2, #44	; 0x2c
	crc32 = CRC_SW_GetCRCResult(&CRC_SW_EEPROM);
 802021e:	4604      	mov	r4, r0
//============================================================================

uint32_t calc_settings_crc(void *p_settings, uint32_t struct_size)
{
	uint32_t crc32 = 0;
	CRC_SW_CalculateCRC(&CRC_SW_EEPROM, p_settings, struct_size);
 8020220:	489a      	ldr	r0, [pc, #616]	; (802048c <ds_init+0x314>)
 8020222:	f006 fb27 	bl	8026874 <CRC_SW_CalculateCRC>
	crc32 = CRC_SW_GetCRCResult(&CRC_SW_EEPROM);
 8020226:	4899      	ldr	r0, [pc, #612]	; (802048c <ds_init+0x314>)
 8020228:	f006 fb66 	bl	80268f8 <CRC_SW_GetCRCResult>
	eep_default_settings_t eep_def_settings;

	def_dev_setting_crc = calc_settings_crc((void *)&ds_default_device_settings, sizeof(ds_default_device_settings));
	def_algo_setting_crc = calc_settings_crc((void *)&ds_default_algo_settings, sizeof(ds_default_algo_settings));

	eep_status = ds_eeprom_read_settings(&eep_def_settings, sizeof(eep_def_settings), DS_EEPROM_ADDRESS_DEFAULT_SETTING);
 802022c:	2102      	movs	r1, #2

uint32_t calc_settings_crc(void *p_settings, uint32_t struct_size)
{
	uint32_t crc32 = 0;
	CRC_SW_CalculateCRC(&CRC_SW_EEPROM, p_settings, struct_size);
	crc32 = CRC_SW_GetCRCResult(&CRC_SW_EEPROM);
 802022e:	4605      	mov	r5, r0
	eep_default_settings_t eep_def_settings;

	def_dev_setting_crc = calc_settings_crc((void *)&ds_default_device_settings, sizeof(ds_default_device_settings));
	def_algo_setting_crc = calc_settings_crc((void *)&ds_default_algo_settings, sizeof(ds_default_algo_settings));

	eep_status = ds_eeprom_read_settings(&eep_def_settings, sizeof(eep_def_settings), DS_EEPROM_ADDRESS_DEFAULT_SETTING);
 8020230:	22e0      	movs	r2, #224	; 0xe0
 8020232:	a801      	add	r0, sp, #4
 8020234:	f000 fa1e 	bl	8020674 <ds_eeprom_read_settings>

	if (eep_status == EEPROM_STATUS_SUCCESS)
 8020238:	2801      	cmp	r0, #1
 802023a:	f000 8102 	beq.w	8020442 <ds_init+0x2ca>
			eep_def_settings.def_algo_settings_crc 	= def_algo_setting_crc;
			eep_status = ds_eeprom_write_settings(&eep_def_settings, sizeof(eep_def_settings), DS_EEPROM_ADDRESS_DEFAULT_SETTING);
			retval = 1;
		}
	}
	else if (eep_status == EEPROM_STATUS_CRC_MISMATCH)
 802023e:	2806      	cmp	r0, #6
 8020240:	d024      	beq.n	802028c <ds_init+0x114>
 8020242:	f8df 8264 	ldr.w	r8, [pc, #612]	; 80204a8 <ds_init+0x330>
 8020246:	4e93      	ldr	r6, [pc, #588]	; (8020494 <ds_init+0x31c>)
	  ds_algo_para_factory_reset();
  }

  /* 2- Valid board ID, Read hardware settings from EEPROM */
  ret_status = EEPROM_STATUS_FAILURE;
  ret_status = ds_eeprom_read_settings(&ds_device_settings, sizeof(device_settings_t), DS_EEPROM_ADDRESS_HW_SETTING);
 8020248:	4c92      	ldr	r4, [pc, #584]	; (8020494 <ds_init+0x31c>)
 802024a:	2140      	movs	r1, #64	; 0x40
 802024c:	4620      	mov	r0, r4
 802024e:	2220      	movs	r2, #32
 8020250:	f000 fa10 	bl	8020674 <ds_eeprom_read_settings>

  /* 3- Check if a valid hardware settings are written in EEPROM */
  if ((ret_status != EEPROM_STATUS_SUCCESS) ||
 8020254:	2801      	cmp	r0, #1
 8020256:	d104      	bne.n	8020262 <ds_init+0xea>
 8020258:	4b8f      	ldr	r3, [pc, #572]	; (8020498 <ds_init+0x320>)
 802025a:	6862      	ldr	r2, [r4, #4]
 802025c:	429a      	cmp	r2, r3
 802025e:	f000 8104 	beq.w	802046a <ds_init+0x2f2>

/* Function to copy default hardware settings into EEPROM */
void ds_hw_para_factory_reset(void)
{
#ifdef DS_USE_EEPROM
	ds_device_settings = ds_default_device_settings;
 8020262:	4c89      	ldr	r4, [pc, #548]	; (8020488 <ds_init+0x310>)
 8020264:	4d8b      	ldr	r5, [pc, #556]	; (8020494 <ds_init+0x31c>)
 8020266:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8020268:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 802026a:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 802026c:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 802026e:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8020270:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8020272:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
 8020276:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}
	if (ds_eeprom_write_settings(&ds_default_device_settings, sizeof(device_settings_t), DS_EEPROM_ADDRESS_HW_SETTING) != EEPROM_STATUS_SUCCESS)
 802027a:	f1a4 0030 	sub.w	r0, r4, #48	; 0x30
 802027e:	2140      	movs	r1, #64	; 0x40
 8020280:	2220      	movs	r2, #32
 8020282:	f000 f9bf 	bl	8020604 <ds_eeprom_write_settings>
 8020286:	2801      	cmp	r0, #1
 8020288:	d021      	beq.n	80202ce <ds_init+0x156>
 802028a:	e7fe      	b.n	802028a <ds_init+0x112>
		 * that means also that this device has no eep_default_settings_t
		 * so we need to write initial def settings check struct to EEPROM */

		eep_def_settings.def_dev_settings_crc 	= def_dev_setting_crc;
		eep_def_settings.def_algo_settings_crc 	= def_algo_setting_crc;
		eep_status = ds_eeprom_write_settings(&eep_def_settings, sizeof(eep_def_settings), DS_EEPROM_ADDRESS_DEFAULT_SETTING);
 802028c:	a801      	add	r0, sp, #4
 802028e:	2102      	movs	r1, #2
 8020290:	22e0      	movs	r2, #224	; 0xe0
	{
		/* if we are here that means the CRC value of eep_default_settings_t mismatched,
		 * that means also that this device has no eep_default_settings_t
		 * so we need to write initial def settings check struct to EEPROM */

		eep_def_settings.def_dev_settings_crc 	= def_dev_setting_crc;
 8020292:	f88d 4004 	strb.w	r4, [sp, #4]
		eep_def_settings.def_algo_settings_crc 	= def_algo_setting_crc;
 8020296:	f88d 5005 	strb.w	r5, [sp, #5]
		eep_status = ds_eeprom_write_settings(&eep_def_settings, sizeof(eep_def_settings), DS_EEPROM_ADDRESS_DEFAULT_SETTING);
 802029a:	f000 f9b3 	bl	8020604 <ds_eeprom_write_settings>

/* Function to copy default hardware settings into EEPROM */
void ds_hw_para_factory_reset(void)
{
#ifdef DS_USE_EEPROM
	ds_device_settings = ds_default_device_settings;
 802029e:	4c7a      	ldr	r4, [pc, #488]	; (8020488 <ds_init+0x310>)
 80202a0:	4e7c      	ldr	r6, [pc, #496]	; (8020494 <ds_init+0x31c>)
 80202a2:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80202a4:	4635      	mov	r5, r6
 80202a6:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 80202a8:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80202aa:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 80202ac:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80202ae:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 80202b0:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
 80202b4:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}
	if (ds_eeprom_write_settings(&ds_default_device_settings, sizeof(device_settings_t), DS_EEPROM_ADDRESS_HW_SETTING) != EEPROM_STATUS_SUCCESS)
 80202b8:	f1a4 0030 	sub.w	r0, r4, #48	; 0x30
 80202bc:	2140      	movs	r1, #64	; 0x40
 80202be:	2220      	movs	r2, #32
 80202c0:	f000 f9a0 	bl	8020604 <ds_eeprom_write_settings>
 80202c4:	2801      	cmp	r0, #1
 80202c6:	4686      	mov	lr, r0
 80202c8:	f000 80a1 	beq.w	802040e <ds_init+0x296>
 80202cc:	e7fe      	b.n	80202cc <ds_init+0x154>

//============================================================================

void ds_set_device_parameter_changed(void)
{
	device_parameter_changed = 1;
 80202ce:	4b73      	ldr	r3, [pc, #460]	; (802049c <ds_init+0x324>)
 80202d0:	6018      	str	r0, [r3, #0]

//============================================================================

void ds_device_settings_copy_to_shadow(void)
{
  memcpy(&ds_shadow_device_settings, &ds_device_settings, sizeof(ds_shadow_device_settings));
 80202d2:	4d70      	ldr	r5, [pc, #448]	; (8020494 <ds_init+0x31c>)
 80202d4:	4c72      	ldr	r4, [pc, #456]	; (80204a0 <ds_init+0x328>)
  /* 4- Valid hardware settings: Use new settings from EEPROM */
  ds_device_settings_copy_to_shadow();

  /* 5- Check if a valid algorithm settings are written in EEPROM */
  ret_status = EEPROM_STATUS_FAILURE;
  ret_status = ds_eeprom_read_settings(&ds_algo_settings, sizeof(algo_settings_t), DS_EEPROM_ADDRESS_ALGO_SETTING);
 80202d6:	f8df 91d0 	ldr.w	r9, [pc, #464]	; 80204a8 <ds_init+0x330>
	/* 4- Invalid hardware settings : */
    /*    Copy default hardware settings in the EEPROM at this address DS_EEPROM_ADDRESS_HW_SETTING */
	ds_hw_para_factory_reset();
  }

  detected_board_variant = board_variant;
 80202da:	f8df e1dc 	ldr.w	lr, [pc, #476]	; 80204b8 <ds_init+0x340>

//============================================================================

void ds_device_settings_copy_to_shadow(void)
{
  memcpy(&ds_shadow_device_settings, &ds_device_settings, sizeof(ds_shadow_device_settings));
 80202de:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80202e0:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80202e2:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80202e4:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80202e6:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80202e8:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80202ea:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 80202ee:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
  /* 4- Valid hardware settings: Use new settings from EEPROM */
  ds_device_settings_copy_to_shadow();

  /* 5- Check if a valid algorithm settings are written in EEPROM */
  ret_status = EEPROM_STATUS_FAILURE;
  ret_status = ds_eeprom_read_settings(&ds_algo_settings, sizeof(algo_settings_t), DS_EEPROM_ADDRESS_ALGO_SETTING);
 80202f2:	4648      	mov	r0, r9
 80202f4:	212c      	movs	r1, #44	; 0x2c
 80202f6:	22a0      	movs	r2, #160	; 0xa0
	/* 4- Invalid hardware settings : */
    /*    Copy default hardware settings in the EEPROM at this address DS_EEPROM_ADDRESS_HW_SETTING */
	ds_hw_para_factory_reset();
  }

  detected_board_variant = board_variant;
 80202f8:	f8ce 7000 	str.w	r7, [lr]
  /* 4- Valid hardware settings: Use new settings from EEPROM */
  ds_device_settings_copy_to_shadow();

  /* 5- Check if a valid algorithm settings are written in EEPROM */
  ret_status = EEPROM_STATUS_FAILURE;
  ret_status = ds_eeprom_read_settings(&ds_algo_settings, sizeof(algo_settings_t), DS_EEPROM_ADDRESS_ALGO_SETTING);
 80202fc:	f000 f9ba 	bl	8020674 <ds_eeprom_read_settings>

  if ((ret_status != EEPROM_STATUS_SUCCESS) ||
 8020300:	2801      	cmp	r0, #1
 8020302:	d104      	bne.n	802030e <ds_init+0x196>
 8020304:	4b67      	ldr	r3, [pc, #412]	; (80204a4 <ds_init+0x32c>)
 8020306:	f8d9 2004 	ldr.w	r2, [r9, #4]
 802030a:	429a      	cmp	r2, r3
 802030c:	d012      	beq.n	8020334 <ds_init+0x1bc>

/* Function to copy default algorithm settings into EEPROM */
void ds_algo_para_factory_reset(void)
{
#ifdef DS_USE_EEPROM
	ds_algo_settings = ds_default_algo_settings;
 802030e:	4c60      	ldr	r4, [pc, #384]	; (8020490 <ds_init+0x318>)
 8020310:	4d65      	ldr	r5, [pc, #404]	; (80204a8 <ds_init+0x330>)
 8020312:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8020314:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8020316:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8020318:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 802031a:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
 802031e:	e885 0007 	stmia.w	r5, {r0, r1, r2}
	if (ds_eeprom_write_settings(&ds_default_algo_settings, sizeof(algo_settings_t), DS_EEPROM_ADDRESS_ALGO_SETTING) != EEPROM_STATUS_SUCCESS)
 8020322:	f1a4 0020 	sub.w	r0, r4, #32
 8020326:	212c      	movs	r1, #44	; 0x2c
 8020328:	22a0      	movs	r2, #160	; 0xa0
 802032a:	f000 f96b 	bl	8020604 <ds_eeprom_write_settings>
 802032e:	2801      	cmp	r0, #1
 8020330:	d004      	beq.n	802033c <ds_init+0x1c4>
 8020332:	e7fe      	b.n	8020332 <ds_init+0x1ba>
  /* 5- Check if a valid algorithm settings are written in EEPROM */
  ret_status = EEPROM_STATUS_FAILURE;
  ret_status = ds_eeprom_read_settings(&ds_algo_settings, sizeof(algo_settings_t), DS_EEPROM_ADDRESS_ALGO_SETTING);

  if ((ret_status != EEPROM_STATUS_SUCCESS) ||
	  (ds_algo_settings.struct_version != DS_ALGO_SETTINGS_STRUCT_VERSION) ||
 8020334:	f8d9 3000 	ldr.w	r3, [r9]
 8020338:	2b2c      	cmp	r3, #44	; 0x2c
 802033a:	d1e8      	bne.n	802030e <ds_init+0x196>
 */
uint32_t ds_algo_check_settings(algo_settings_t *ptr)
{
  uint32_t retval = 0;

  if (!((ptr->speed_detection_threshold >= BSP_MIN_SPEED_DETECTION_THRESHOLD) && (ptr->speed_detection_threshold <= BSP_MAX_SPEED_DETECTION_THRESHOLD)))
 802033c:	edd8 7a02 	vldr	s15, [r8, #8]
 8020340:	eeb7 7a00 	vmov.f32	s14, #112	; 0x70
 8020344:	eef4 7ac7 	vcmpe.f32	s15, s14
 8020348:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802034c:	db5c      	blt.n	8020408 <ds_init+0x290>
 802034e:	ed9f 7a57 	vldr	s14, [pc, #348]	; 80204ac <ds_init+0x334>
 8020352:	eef4 7ac7 	vcmpe.f32	s15, s14
 8020356:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802035a:	bf95      	itete	ls
 802035c:	2302      	movls	r3, #2
 802035e:	2303      	movhi	r3, #3
 8020360:	2400      	movls	r4, #0
 8020362:	2401      	movhi	r4, #1
  {
    retval += 1;
  }
  if (!(ptr->max_speed_kmph > ptr->min_speed_kmph) && (ptr->max_speed_kmph <= BSP_MAX_SPEED_KMPH))
 8020364:	edd8 7a04 	vldr	s15, [r8, #16]
 8020368:	ed98 7a03 	vldr	s14, [r8, #12]
 802036c:	eef4 7ac7 	vcmpe.f32	s15, s14
 8020370:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8020374:	dc07      	bgt.n	8020386 <ds_init+0x20e>
 8020376:	eddf 6a4e 	vldr	s13, [pc, #312]	; 80204b0 <ds_init+0x338>
  {
    retval += 2;
 802037a:	eef4 7a66 	vcmp.f32	s15, s13
 802037e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8020382:	bf98      	it	ls
 8020384:	461c      	movls	r4, r3
  }
  if (ptr->min_speed_kmph > ptr->max_speed_kmph)
 8020386:	eef4 7ac7 	vcmpe.f32	s15, s14
  {
    retval += 4;
  }
  if (!(ptr->motion_detection_threshold >= BSP_MIN_MOTION_DETECTION_THRESHOLD) && (ptr->motion_detection_threshold <= BSP_MAX_MOTION_DETECTION_THRESHOLD))
 802038a:	edd8 7a0a 	vldr	s15, [r8, #40]	; 0x28
 802038e:	eeb7 7a00 	vmov.f32	s14, #112	; 0x70
  }
  if (!(ptr->max_speed_kmph > ptr->min_speed_kmph) && (ptr->max_speed_kmph <= BSP_MAX_SPEED_KMPH))
  {
    retval += 2;
  }
  if (ptr->min_speed_kmph > ptr->max_speed_kmph)
 8020392:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  {
    retval += 4;
  }
  if (!(ptr->motion_detection_threshold >= BSP_MIN_MOTION_DETECTION_THRESHOLD) && (ptr->motion_detection_threshold <= BSP_MAX_MOTION_DETECTION_THRESHOLD))
 8020396:	eef4 7ac7 	vcmpe.f32	s15, s14
  {
    retval += 2;
  }
  if (ptr->min_speed_kmph > ptr->max_speed_kmph)
  {
    retval += 4;
 802039a:	bf48      	it	mi
 802039c:	3404      	addmi	r4, #4
  }
  if (!(ptr->motion_detection_threshold >= BSP_MIN_MOTION_DETECTION_THRESHOLD) && (ptr->motion_detection_threshold <= BSP_MAX_MOTION_DETECTION_THRESHOLD))
 802039e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80203a2:	da07      	bge.n	80203b4 <ds_init+0x23c>
 80203a4:	ed9f 7a41 	vldr	s14, [pc, #260]	; 80204ac <ds_init+0x334>
 80203a8:	eef4 7ac7 	vcmpe.f32	s15, s14
 80203ac:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  {
	 retval += 8;
 80203b0:	bf98      	it	ls
 80203b2:	3408      	addls	r4, #8
 */
uint32_t ds_dev_check_settings(device_settings_t *ptr)
{
  uint32_t retval = 0;

  if (!((ptr->num_sample_skip_count >= BSP_MIN_SAMPLE_SKIP_COUNT) && (ptr->num_sample_skip_count <= BSP_MAX_SAMPLE_SKIP_COUNT)))
 80203b4:	6af0      	ldr	r0, [r6, #44]	; 0x2c
  {
    retval += 1;
  }
  if (!(ptr->adc_sampling_freq_Hz >= BSP_MIN_DOPPLER_SAMPLING_FREQ_HZ && (ptr->adc_sampling_freq_Hz <= BSP_MAX_DOPPLER_SAMPLING_FREQ_HZ)))
 80203b6:	6973      	ldr	r3, [r6, #20]
  {
    retval += 2;
  }
  if (!(ptr->frame_period_usec >= bsp_calc_min_frame_interval_usec(ptr)) && (ptr->frame_period_usec*1000 <= BSP_MAX_FRAME_PERIOD_MSEC))
 80203b8:	4f36      	ldr	r7, [pc, #216]	; (8020494 <ds_init+0x31c>)
 80203ba:	f8d6 8020 	ldr.w	r8, [r6, #32]
 */
uint32_t ds_dev_check_settings(device_settings_t *ptr)
{
  uint32_t retval = 0;

  if (!((ptr->num_sample_skip_count >= BSP_MIN_SAMPLE_SKIP_COUNT) && (ptr->num_sample_skip_count <= BSP_MAX_SAMPLE_SKIP_COUNT)))
 80203be:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
  {
    retval += 1;
  }
  if (!(ptr->adc_sampling_freq_Hz >= BSP_MIN_DOPPLER_SAMPLING_FREQ_HZ && (ptr->adc_sampling_freq_Hz <= BSP_MAX_DOPPLER_SAMPLING_FREQ_HZ)))
 80203c2:	f5a3 737a 	sub.w	r3, r3, #1000	; 0x3e8
 */
uint32_t ds_dev_check_settings(device_settings_t *ptr)
{
  uint32_t retval = 0;

  if (!((ptr->num_sample_skip_count >= BSP_MIN_SAMPLE_SKIP_COUNT) && (ptr->num_sample_skip_count <= BSP_MAX_SAMPLE_SKIP_COUNT)))
 80203c6:	bf8c      	ite	hi
 80203c8:	2501      	movhi	r5, #1
 80203ca:	2500      	movls	r5, #0
  }
  if (!(ptr->adc_sampling_freq_Hz >= BSP_MIN_DOPPLER_SAMPLING_FREQ_HZ && (ptr->adc_sampling_freq_Hz <= BSP_MAX_DOPPLER_SAMPLING_FREQ_HZ)))
  {
    retval += 2;
  }
  if (!(ptr->frame_period_usec >= bsp_calc_min_frame_interval_usec(ptr)) && (ptr->frame_period_usec*1000 <= BSP_MAX_FRAME_PERIOD_MSEC))
 80203cc:	4638      	mov	r0, r7

  if (!((ptr->num_sample_skip_count >= BSP_MIN_SAMPLE_SKIP_COUNT) && (ptr->num_sample_skip_count <= BSP_MAX_SAMPLE_SKIP_COUNT)))
  {
    retval += 1;
  }
  if (!(ptr->adc_sampling_freq_Hz >= BSP_MIN_DOPPLER_SAMPLING_FREQ_HZ && (ptr->adc_sampling_freq_Hz <= BSP_MAX_DOPPLER_SAMPLING_FREQ_HZ)))
 80203ce:	f5b3 6f7a 	cmp.w	r3, #4000	; 0xfa0
  {
    retval += 2;
 80203d2:	bf88      	it	hi
 80203d4:	3502      	addhi	r5, #2
  }
  if (!(ptr->frame_period_usec >= bsp_calc_min_frame_interval_usec(ptr)) && (ptr->frame_period_usec*1000 <= BSP_MAX_FRAME_PERIOD_MSEC))
 80203d6:	f009 fe6f 	bl	802a0b8 <bsp_calc_min_frame_interval_usec>
 80203da:	4580      	cmp	r8, r0
 80203dc:	d208      	bcs.n	80203f0 <ds_init+0x278>
 80203de:	6a3a      	ldr	r2, [r7, #32]
 80203e0:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80203e4:	fb03 f302 	mul.w	r3, r3, r2
 80203e8:	f5b3 6ffa 	cmp.w	r3, #2000	; 0x7d0
  {
    retval += 4;
 80203ec:	bf98      	it	ls
 80203ee:	3504      	addls	r5, #4
  }
  if (!(ptr->num_samples_per_chirp >= BSP_MIN_NUM_SAMPLES_PER_CHIRP) && (ptr->num_samples_per_chirp <= BSP_MAX_NUM_SAMPLES_PER_CHIRP))
 80203f0:	6a73      	ldr	r3, [r6, #36]	; 0x24
 80203f2:	2b1f      	cmp	r3, #31
  {
	 retval += 8;
  }
  if (ptr->adc_resolution != 12)
 80203f4:	7e33      	ldrb	r3, [r6, #24]
  {
    retval += 4;
  }
  if (!(ptr->num_samples_per_chirp >= BSP_MIN_NUM_SAMPLES_PER_CHIRP) && (ptr->num_samples_per_chirp <= BSP_MAX_NUM_SAMPLES_PER_CHIRP))
  {
	 retval += 8;
 80203f6:	bf98      	it	ls
 80203f8:	3508      	addls	r5, #8
  }
  if (ptr->adc_resolution != 12)
 80203fa:	2b0c      	cmp	r3, #12
  {
	  retval += 16;
 80203fc:	bf18      	it	ne
 80203fe:	3510      	addne	r5, #16
	ds_algo_para_factory_reset();
  }

  /* 6- Valid algorithm settings: Use new settings from EEPROM */
  retval += ds_algo_check_settings(&ds_algo_settings);
  retval += ds_dev_check_settings(&ds_device_settings);
 8020400:	1928      	adds	r0, r5, r4
  memcpy(&ds_algo_settings, &ds_default_algo_settings, sizeof(algo_settings_t));
  retval += ds_algo_check_settings(&ds_algo_settings);
#endif /* DS_USE_EEPROM */
  
  return retval;
}
 8020402:	b003      	add	sp, #12
 8020404:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 */
uint32_t ds_algo_check_settings(algo_settings_t *ptr)
{
  uint32_t retval = 0;

  if (!((ptr->speed_detection_threshold >= BSP_MIN_SPEED_DETECTION_THRESHOLD) && (ptr->speed_detection_threshold <= BSP_MAX_SPEED_DETECTION_THRESHOLD)))
 8020408:	2303      	movs	r3, #3
  {
    retval += 1;
 802040a:	2401      	movs	r4, #1
 802040c:	e7aa      	b.n	8020364 <ds_init+0x1ec>

/* Function to copy default algorithm settings into EEPROM */
void ds_algo_para_factory_reset(void)
{
#ifdef DS_USE_EEPROM
	ds_algo_settings = ds_default_algo_settings;
 802040e:	4c20      	ldr	r4, [pc, #128]	; (8020490 <ds_init+0x318>)
 8020410:	f8df 8094 	ldr.w	r8, [pc, #148]	; 80204a8 <ds_init+0x330>

//============================================================================

void ds_set_device_parameter_changed(void)
{
	device_parameter_changed = 1;
 8020414:	f8df c084 	ldr.w	ip, [pc, #132]	; 802049c <ds_init+0x324>

/* Function to copy default algorithm settings into EEPROM */
void ds_algo_para_factory_reset(void)
{
#ifdef DS_USE_EEPROM
	ds_algo_settings = ds_default_algo_settings;
 8020418:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 802041a:	4645      	mov	r5, r8
 802041c:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 802041e:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8020420:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8020422:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
 8020426:	e885 0007 	stmia.w	r5, {r0, r1, r2}
	if (ds_eeprom_write_settings(&ds_default_algo_settings, sizeof(algo_settings_t), DS_EEPROM_ADDRESS_ALGO_SETTING) != EEPROM_STATUS_SUCCESS)
 802042a:	f1a4 0020 	sub.w	r0, r4, #32
 802042e:	212c      	movs	r1, #44	; 0x2c
 8020430:	22a0      	movs	r2, #160	; 0xa0

//============================================================================

void ds_set_device_parameter_changed(void)
{
	device_parameter_changed = 1;
 8020432:	f8cc e000 	str.w	lr, [ip]
/* Function to copy default algorithm settings into EEPROM */
void ds_algo_para_factory_reset(void)
{
#ifdef DS_USE_EEPROM
	ds_algo_settings = ds_default_algo_settings;
	if (ds_eeprom_write_settings(&ds_default_algo_settings, sizeof(algo_settings_t), DS_EEPROM_ADDRESS_ALGO_SETTING) != EEPROM_STATUS_SUCCESS)
 8020436:	f000 f8e5 	bl	8020604 <ds_eeprom_write_settings>
 802043a:	2801      	cmp	r0, #1
 802043c:	f43f af04 	beq.w	8020248 <ds_init+0xd0>
 8020440:	e7fe      	b.n	8020440 <ds_init+0x2c8>

	eep_status = ds_eeprom_read_settings(&eep_def_settings, sizeof(eep_def_settings), DS_EEPROM_ADDRESS_DEFAULT_SETTING);

	if (eep_status == EEPROM_STATUS_SUCCESS)
	{
		if (def_dev_setting_crc 	!= eep_def_settings.def_dev_settings_crc ||
 8020442:	f89d 3004 	ldrb.w	r3, [sp, #4]
 8020446:	429c      	cmp	r4, r3
 8020448:	d102      	bne.n	8020450 <ds_init+0x2d8>
 802044a:	42ac      	cmp	r4, r5
 802044c:	f43f aef9 	beq.w	8020242 <ds_init+0xca>
==============================================================================
 */

void ds_set_def_settings_changed(void)
{
	def_settings_changed = 1;
 8020450:	4b18      	ldr	r3, [pc, #96]	; (80204b4 <ds_init+0x33c>)
		{
			/* set the flag */
			ds_set_def_settings_changed();

			/* write changed def settings check struct to EEPROM */
			eep_def_settings.def_dev_settings_crc 	= def_dev_setting_crc;
 8020452:	f88d 4004 	strb.w	r4, [sp, #4]
			eep_def_settings.def_algo_settings_crc 	= def_algo_setting_crc;
			eep_status = ds_eeprom_write_settings(&eep_def_settings, sizeof(eep_def_settings), DS_EEPROM_ADDRESS_DEFAULT_SETTING);
 8020456:	a801      	add	r0, sp, #4
==============================================================================
 */

void ds_set_def_settings_changed(void)
{
	def_settings_changed = 1;
 8020458:	2401      	movs	r4, #1
			ds_set_def_settings_changed();

			/* write changed def settings check struct to EEPROM */
			eep_def_settings.def_dev_settings_crc 	= def_dev_setting_crc;
			eep_def_settings.def_algo_settings_crc 	= def_algo_setting_crc;
			eep_status = ds_eeprom_write_settings(&eep_def_settings, sizeof(eep_def_settings), DS_EEPROM_ADDRESS_DEFAULT_SETTING);
 802045a:	2102      	movs	r1, #2
 802045c:	22e0      	movs	r2, #224	; 0xe0
			/* set the flag */
			ds_set_def_settings_changed();

			/* write changed def settings check struct to EEPROM */
			eep_def_settings.def_dev_settings_crc 	= def_dev_setting_crc;
			eep_def_settings.def_algo_settings_crc 	= def_algo_setting_crc;
 802045e:	f88d 5005 	strb.w	r5, [sp, #5]
==============================================================================
 */

void ds_set_def_settings_changed(void)
{
	def_settings_changed = 1;
 8020462:	601c      	str	r4, [r3, #0]
			ds_set_def_settings_changed();

			/* write changed def settings check struct to EEPROM */
			eep_def_settings.def_dev_settings_crc 	= def_dev_setting_crc;
			eep_def_settings.def_algo_settings_crc 	= def_algo_setting_crc;
			eep_status = ds_eeprom_write_settings(&eep_def_settings, sizeof(eep_def_settings), DS_EEPROM_ADDRESS_DEFAULT_SETTING);
 8020464:	f000 f8ce 	bl	8020604 <ds_eeprom_write_settings>
 8020468:	e719      	b.n	802029e <ds_init+0x126>
  ret_status = EEPROM_STATUS_FAILURE;
  ret_status = ds_eeprom_read_settings(&ds_device_settings, sizeof(device_settings_t), DS_EEPROM_ADDRESS_HW_SETTING);

  /* 3- Check if a valid hardware settings are written in EEPROM */
  if ((ret_status != EEPROM_STATUS_SUCCESS) ||
	  (ds_device_settings.struct_version != DS_HW_SETTINGS_STRUCT_VERSION) ||
 802046a:	6823      	ldr	r3, [r4, #0]
 802046c:	2b40      	cmp	r3, #64	; 0x40
 802046e:	f47f aef8 	bne.w	8020262 <ds_init+0xea>
 8020472:	e72e      	b.n	80202d2 <ds_init+0x15a>
 8020474:	1ffe9000 	.word	0x1ffe9000
 8020478:	00989680 	.word	0x00989680
 802047c:	1ffe91e8 	.word	0x1ffe91e8
 8020480:	1ffe900c 	.word	0x1ffe900c
 8020484:	02625a00 	.word	0x02625a00
 8020488:	0802d578 	.word	0x0802d578
 802048c:	1ffe9494 	.word	0x1ffe9494
 8020490:	1ffe9050 	.word	0x1ffe9050
 8020494:	1ffe9724 	.word	0x1ffe9724
 8020498:	00030e1e 	.word	0x00030e1e
 802049c:	1ffe96b0 	.word	0x1ffe96b0
 80204a0:	1ffe96e4 	.word	0x1ffe96e4
 80204a4:	0002e9c6 	.word	0x0002e9c6
 80204a8:	1ffe96b4 	.word	0x1ffe96b4
 80204ac:	44fa0000 	.word	0x44fa0000
 80204b0:	44870000 	.word	0x44870000
 80204b4:	1ffe96e0 	.word	0x1ffe96e0
 80204b8:	1ffe96ac 	.word	0x1ffe96ac

	/*  TODO: Remove before the release!! */
	if (shield_status == RF_SHIELD_BOARD_NOT_PROGRAMMED)
	{
		//static uint8_t ds_eeprom_write_inital_board_id(void);
		if (ds_eeprom_write_inital_board_id() == EEPROM_STATUS_SUCCESS)
 80204bc:	f000 f952 	bl	8020764 <ds_eeprom_write_inital_board_id>
 80204c0:	2801      	cmp	r0, #1
 80204c2:	f47f aea1 	bne.w	8020208 <ds_init+0x90>
		{
			bsp_led_blue_on();
 80204c6:	f008 fc35 	bl	8028d34 <bsp_led_blue_on>
			
			TIMER_SetTimeInterval(&TIMER_ERROR_TOGGLE, 200 * 1000U * 100U);
 80204ca:	4908      	ldr	r1, [pc, #32]	; (80204ec <ds_init+0x374>)
 80204cc:	4808      	ldr	r0, [pc, #32]	; (80204f0 <ds_init+0x378>)
 80204ce:	f005 fcf3 	bl	8025eb8 <TIMER_SetTimeInterval>
			bsp_timer_start(&TIMER_ERROR_TOGGLE);
 80204d2:	4807      	ldr	r0, [pc, #28]	; (80204f0 <ds_init+0x378>)
 80204d4:	f009 f9ba 	bl	802984c <bsp_timer_start>
	    	device_status_set_error(FATAL_ERROR_BOARD_NOT_PROGRAMMED);
 80204d8:	f244 1002 	movw	r0, #16642	; 0x4102
 80204dc:	f000 fb7e 	bl	8020bdc <device_status_set_error>
			return RF_SHIELD_NOT_PROGRAMMED;
 80204e0:	4804      	ldr	r0, [pc, #16]	; (80204f4 <ds_init+0x37c>)
  memcpy(&ds_algo_settings, &ds_default_algo_settings, sizeof(algo_settings_t));
  retval += ds_algo_check_settings(&ds_algo_settings);
#endif /* DS_USE_EEPROM */
  
  return retval;
}
 80204e2:	b003      	add	sp, #12
 80204e4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  if (shield_status == RF_SHIELD_BOARD_UNSUPPORTED)
  {
	  /* Read RF board ID, check if a valid board ID is written in EEPROM */
	  shield_status = ds_eeprom_read_board_id(rf_board_id_2, sizeof(rf_board_id_2));
	  if (shield_status == RF_SHIELD_BOARD_SUPPORTED)
		  board_variant = 1;
 80204e8:	2701      	movs	r7, #1
 80204ea:	e68e      	b.n	802020a <ds_init+0x92>
 80204ec:	01312d00 	.word	0x01312d00
 80204f0:	1ffe91e8 	.word	0x1ffe91e8
 80204f4:	00030002 	.word	0x00030002

080204f8 <ds_get_active_acq_buf>:
//============================================================================

acq_buf_obj *ds_get_active_acq_buf(void)
{
  return &s_acq_buf;
}
 80204f8:	4800      	ldr	r0, [pc, #0]	; (80204fc <ds_get_active_acq_buf+0x4>)
 80204fa:	4770      	bx	lr
 80204fc:	1ffe9018 	.word	0x1ffe9018

08020500 <ds_set_active_acq_buf>:

//============================================================================

void ds_set_active_acq_buf(const acq_buf_obj acq_buf)
{
 8020500:	b084      	sub	sp, #16
 8020502:	b538      	push	{r3, r4, r5, lr}
  if (s_acq_buf.p_acq_buf != NULL)
 8020504:	4c0c      	ldr	r4, [pc, #48]	; (8020538 <ds_set_active_acq_buf+0x38>)
 8020506:	6ae5      	ldr	r5, [r4, #44]	; 0x2c
}

//============================================================================

void ds_set_active_acq_buf(const acq_buf_obj acq_buf)
{
 8020508:	f10d 0e10 	add.w	lr, sp, #16
 802050c:	e88e 000f 	stmia.w	lr, {r0, r1, r2, r3}
  if (s_acq_buf.p_acq_buf != NULL)
 8020510:	b115      	cbz	r5, 8020518 <ds_set_active_acq_buf+0x18>
  {
    delete_acq_buffer_obj(&s_acq_buf);
 8020512:	4620      	mov	r0, r4
 8020514:	f000 fa0c 	bl	8020930 <delete_acq_buffer_obj>
  }
  
  memcpy(&s_acq_buf, &acq_buf, sizeof(acq_buf_obj));
 8020518:	ad04      	add	r5, sp, #16
 802051a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 802051c:	4c06      	ldr	r4, [pc, #24]	; (8020538 <ds_set_active_acq_buf+0x38>)
 802051e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8020520:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8020522:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8020524:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8020526:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8020528:	e895 0003 	ldmia.w	r5, {r0, r1}
 802052c:	e884 0003 	stmia.w	r4, {r0, r1}
}
 8020530:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8020534:	b004      	add	sp, #16
 8020536:	4770      	bx	lr
 8020538:	1ffe9018 	.word	0x1ffe9018

0802053c <ds_algo_para_factory_reset>:

//============================================================================

/* Function to copy default algorithm settings into EEPROM */
void ds_algo_para_factory_reset(void)
{
 802053c:	b538      	push	{r3, r4, r5, lr}
#ifdef DS_USE_EEPROM
	ds_algo_settings = ds_default_algo_settings;
 802053e:	4c0a      	ldr	r4, [pc, #40]	; (8020568 <ds_algo_para_factory_reset+0x2c>)
 8020540:	4d0a      	ldr	r5, [pc, #40]	; (802056c <ds_algo_para_factory_reset+0x30>)
 8020542:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8020544:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8020546:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8020548:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 802054a:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
 802054e:	e885 0007 	stmia.w	r5, {r0, r1, r2}
	if (ds_eeprom_write_settings(&ds_default_algo_settings, sizeof(algo_settings_t), DS_EEPROM_ADDRESS_ALGO_SETTING) != EEPROM_STATUS_SUCCESS)
 8020552:	f1a4 0020 	sub.w	r0, r4, #32
 8020556:	212c      	movs	r1, #44	; 0x2c
 8020558:	22a0      	movs	r2, #160	; 0xa0
 802055a:	f000 f853 	bl	8020604 <ds_eeprom_write_settings>
 802055e:	2801      	cmp	r0, #1
 8020560:	d000      	beq.n	8020564 <ds_algo_para_factory_reset+0x28>
	{
		XMC_DEBUG("writing EEPROM failed!\n");
		while (1);
 8020562:	e7fe      	b.n	8020562 <ds_algo_para_factory_reset+0x26>
 8020564:	bd38      	pop	{r3, r4, r5, pc}
 8020566:	bf00      	nop
 8020568:	1ffe9050 	.word	0x1ffe9050
 802056c:	1ffe96b4 	.word	0x1ffe96b4

08020570 <ds_algo_para_store_persistent>:

//============================================================================

/* Function to copy current algorithm settings into EEPROM */
void ds_algo_para_store_persistent(void)
{
 8020570:	b508      	push	{r3, lr}
#ifdef DS_USE_EEPROM
	algo_settings_t *pDev = ds_algo_get_settings();
	if (ds_eeprom_write_settings(pDev, sizeof(algo_settings_t), DS_EEPROM_ADDRESS_ALGO_SETTING) != EEPROM_STATUS_SUCCESS)
 8020572:	4804      	ldr	r0, [pc, #16]	; (8020584 <ds_algo_para_store_persistent+0x14>)
 8020574:	212c      	movs	r1, #44	; 0x2c
 8020576:	22a0      	movs	r2, #160	; 0xa0
 8020578:	f000 f844 	bl	8020604 <ds_eeprom_write_settings>
 802057c:	2801      	cmp	r0, #1
 802057e:	d000      	beq.n	8020582 <ds_algo_para_store_persistent+0x12>
	{
		XMC_DEBUG("writing EEPROM failed!\n");
		while (1);
 8020580:	e7fe      	b.n	8020580 <ds_algo_para_store_persistent+0x10>
 8020582:	bd08      	pop	{r3, pc}
 8020584:	1ffe96b4 	.word	0x1ffe96b4

08020588 <ds_hw_para_factory_reset>:

//============================================================================

/* Function to copy default hardware settings into EEPROM */
void ds_hw_para_factory_reset(void)
{
 8020588:	b538      	push	{r3, r4, r5, lr}
#ifdef DS_USE_EEPROM
	ds_device_settings = ds_default_device_settings;
 802058a:	4c0c      	ldr	r4, [pc, #48]	; (80205bc <ds_hw_para_factory_reset+0x34>)
 802058c:	4d0c      	ldr	r5, [pc, #48]	; (80205c0 <ds_hw_para_factory_reset+0x38>)
 802058e:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8020590:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8020592:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8020594:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8020596:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8020598:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 802059a:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
 802059e:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}
	if (ds_eeprom_write_settings(&ds_default_device_settings, sizeof(device_settings_t), DS_EEPROM_ADDRESS_HW_SETTING) != EEPROM_STATUS_SUCCESS)
 80205a2:	f1a4 0030 	sub.w	r0, r4, #48	; 0x30
 80205a6:	2140      	movs	r1, #64	; 0x40
 80205a8:	2220      	movs	r2, #32
 80205aa:	f000 f82b 	bl	8020604 <ds_eeprom_write_settings>
 80205ae:	2801      	cmp	r0, #1
 80205b0:	d000      	beq.n	80205b4 <ds_hw_para_factory_reset+0x2c>
	{
		XMC_DEBUG("writing EEPROM failed!\n");
		while (1);
 80205b2:	e7fe      	b.n	80205b2 <ds_hw_para_factory_reset+0x2a>

//============================================================================

void ds_set_device_parameter_changed(void)
{
	device_parameter_changed = 1;
 80205b4:	4b03      	ldr	r3, [pc, #12]	; (80205c4 <ds_hw_para_factory_reset+0x3c>)
 80205b6:	6018      	str	r0, [r3, #0]
 80205b8:	bd38      	pop	{r3, r4, r5, pc}
 80205ba:	bf00      	nop
 80205bc:	0802d578 	.word	0x0802d578
 80205c0:	1ffe9724 	.word	0x1ffe9724
 80205c4:	1ffe96b0 	.word	0x1ffe96b0

080205c8 <ds_hw_para_store_persistent>:

//============================================================================

/* Function to copy current hardware settings into EEPROM */
void ds_hw_para_store_persistent(void)
{
 80205c8:	b508      	push	{r3, lr}
#ifdef DS_USE_EEPROM
	device_settings_t *pDev = ds_device_get_settings();
	if (ds_eeprom_write_settings(pDev, sizeof(device_settings_t), DS_EEPROM_ADDRESS_HW_SETTING) != EEPROM_STATUS_SUCCESS)
 80205ca:	4804      	ldr	r0, [pc, #16]	; (80205dc <ds_hw_para_store_persistent+0x14>)
 80205cc:	2140      	movs	r1, #64	; 0x40
 80205ce:	2220      	movs	r2, #32
 80205d0:	f000 f818 	bl	8020604 <ds_eeprom_write_settings>
 80205d4:	2801      	cmp	r0, #1
 80205d6:	d000      	beq.n	80205da <ds_hw_para_store_persistent+0x12>
	{
		XMC_DEBUG("writing EEPROM failed!\n");
		while (1);
 80205d8:	e7fe      	b.n	80205d8 <ds_hw_para_store_persistent+0x10>
 80205da:	bd08      	pop	{r3, pc}
 80205dc:	1ffe9724 	.word	0x1ffe9724

080205e0 <ds_set_device_parameter_changed>:

//============================================================================

void ds_set_device_parameter_changed(void)
{
	device_parameter_changed = 1;
 80205e0:	4b01      	ldr	r3, [pc, #4]	; (80205e8 <ds_set_device_parameter_changed+0x8>)
 80205e2:	2201      	movs	r2, #1
 80205e4:	601a      	str	r2, [r3, #0]
 80205e6:	4770      	bx	lr
 80205e8:	1ffe96b0 	.word	0x1ffe96b0

080205ec <ds_clear_device_parameter_changed>:

//============================================================================

void ds_clear_device_parameter_changed(void)
{
	device_parameter_changed = 0;
 80205ec:	4b01      	ldr	r3, [pc, #4]	; (80205f4 <ds_clear_device_parameter_changed+0x8>)
 80205ee:	2200      	movs	r2, #0
 80205f0:	601a      	str	r2, [r3, #0]
 80205f2:	4770      	bx	lr
 80205f4:	1ffe96b0 	.word	0x1ffe96b0

080205f8 <ds_is_device_parameter_changed>:

//============================================================================

uint32_t ds_is_device_parameter_changed(void)
{
	return device_parameter_changed;
 80205f8:	4b01      	ldr	r3, [pc, #4]	; (8020600 <ds_is_device_parameter_changed+0x8>)
}
 80205fa:	6818      	ldr	r0, [r3, #0]
 80205fc:	4770      	bx	lr
 80205fe:	bf00      	nop
 8020600:	1ffe96b0 	.word	0x1ffe96b0

08020604 <ds_eeprom_write_settings>:

#ifdef DS_USE_EEPROM

/* Function to write settings into EEPROM */
EEPROM_STATUS_t ds_eeprom_write_settings(const void *p_settings, uint32_t struct_size, uint16_t eeprom_address)
{
 8020604:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  uint32_t buffer[struct_size/4 + 2]; /* Plus one extra for the CRC32 */
 8020608:	088d      	lsrs	r5, r1, #2
 802060a:	1cab      	adds	r3, r5, #2
 802060c:	009b      	lsls	r3, r3, #2
 802060e:	f103 040a 	add.w	r4, r3, #10
 8020612:	f024 0407 	bic.w	r4, r4, #7

#ifdef DS_USE_EEPROM

/* Function to write settings into EEPROM */
EEPROM_STATUS_t ds_eeprom_write_settings(const void *p_settings, uint32_t struct_size, uint16_t eeprom_address)
{
 8020616:	af00      	add	r7, sp, #0
  uint32_t buffer[struct_size/4 + 2]; /* Plus one extra for the CRC32 */
 8020618:	ebad 0d04 	sub.w	sp, sp, r4
  uint32_t buffer_size = 0, crc32 = 0;

  if ((p_settings == NULL) || (struct_size <= 0))
 802061c:	b100      	cbz	r0, 8020620 <ds_eeprom_write_settings+0x1c>
 802061e:	b919      	cbnz	r1, 8020628 <ds_eeprom_write_settings+0x24>
  {
    /* Invalid input parameters */
	return EEPROM_STATUS_FAILURE;
 8020620:	2002      	movs	r0, #2
  crc32 = CRC_SW_GetCRCResult(&CRC_SW_EEPROM);
  buffer[buffer_size++] = crc32;

  /* Write hardware settings structure in the EEPROM */
  return(bsp_eeprom_24cw128x_write_data(eeprom_address, (uint8_t*)buffer, buffer_size*4));
}
 8020622:	46bd      	mov	sp, r7
 8020624:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    /* Invalid input parameters */
	return EEPROM_STATUS_FAILURE;
  }

  /* Get the buffer size for the structure */
  if ((struct_size % 4) != 0)
 8020628:	078c      	lsls	r4, r1, #30
 802062a:	4606      	mov	r6, r0
 802062c:	4691      	mov	r9, r2
 802062e:	460c      	mov	r4, r1
  {
	buffer_size = struct_size/4;
  }

  /* Clear the transmit buffer */
  memset(buffer, 0, sizeof(buffer));
 8020630:	461a      	mov	r2, r3
 8020632:	4668      	mov	r0, sp
 8020634:	f04f 0100 	mov.w	r1, #0
  }

  /* Get the buffer size for the structure */
  if ((struct_size % 4) != 0)
  {
    buffer_size = struct_size/4 + 1;
 8020638:	bf18      	it	ne
 802063a:	3501      	addne	r5, #1
  {
	buffer_size = struct_size/4;
  }

  /* Clear the transmit buffer */
  memset(buffer, 0, sizeof(buffer));
 802063c:	f00c ff8b 	bl	802d556 <memset>

  /* Copy hardware settings structure into transmit buffer */
  memcpy(buffer, p_settings, struct_size);
 8020640:	4631      	mov	r1, r6
 8020642:	4622      	mov	r2, r4
 8020644:	4668      	mov	r0, sp
 8020646:	f00c ff7b 	bl	802d540 <memcpy>

  /*  Get the CRC for all structure */
  CRC_SW_CalculateCRC(&CRC_SW_EEPROM, buffer, buffer_size);
 802064a:	4669      	mov	r1, sp
 802064c:	462a      	mov	r2, r5
 802064e:	4808      	ldr	r0, [pc, #32]	; (8020670 <ds_eeprom_write_settings+0x6c>)
 8020650:	f006 f910 	bl	8026874 <CRC_SW_CalculateCRC>
  crc32 = CRC_SW_GetCRCResult(&CRC_SW_EEPROM);
 8020654:	4806      	ldr	r0, [pc, #24]	; (8020670 <ds_eeprom_write_settings+0x6c>)
 8020656:	f006 f94f 	bl	80268f8 <CRC_SW_GetCRCResult>
  buffer[buffer_size++] = crc32;
 802065a:	1c6a      	adds	r2, r5, #1
 802065c:	f84d 0025 	str.w	r0, [sp, r5, lsl #2]

  /* Write hardware settings structure in the EEPROM */
  return(bsp_eeprom_24cw128x_write_data(eeprom_address, (uint8_t*)buffer, buffer_size*4));
 8020660:	0092      	lsls	r2, r2, #2
 8020662:	4648      	mov	r0, r9
 8020664:	4669      	mov	r1, sp
 8020666:	f008 f917 	bl	8028898 <bsp_eeprom_24cw128x_write_data>
}
 802066a:	46bd      	mov	sp, r7
 802066c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8020670:	1ffe9494 	.word	0x1ffe9494

08020674 <ds_eeprom_read_settings>:

//============================================================================

/* Function to read settings from EEPROM */
EEPROM_STATUS_t ds_eeprom_read_settings(void *p_settings, uint32_t struct_size, uint16_t eeprom_address)
{
 8020674:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  uint32_t buffer[struct_size/4 + 2]; /* Plus one extra for the CRC32 */
 8020678:	088d      	lsrs	r5, r1, #2
 802067a:	1cab      	adds	r3, r5, #2
 802067c:	009b      	lsls	r3, r3, #2
 802067e:	f103 040a 	add.w	r4, r3, #10
 8020682:	f024 0407 	bic.w	r4, r4, #7

//============================================================================

/* Function to read settings from EEPROM */
EEPROM_STATUS_t ds_eeprom_read_settings(void *p_settings, uint32_t struct_size, uint16_t eeprom_address)
{
 8020686:	af00      	add	r7, sp, #0
  uint32_t buffer[struct_size/4 + 2]; /* Plus one extra for the CRC32 */
 8020688:	ebad 0d04 	sub.w	sp, sp, r4
  uint32_t buffer_size = 0, new_crc32 = 0, old_crc32 = 0;
  EEPROM_STATUS_t ret_status = EEPROM_STATUS_FAILURE;

  if ((p_settings == NULL) || (struct_size <= 0))
 802068c:	b100      	cbz	r0, 8020690 <ds_eeprom_read_settings+0x1c>
 802068e:	b919      	cbnz	r1, 8020698 <ds_eeprom_read_settings+0x24>
  {
    /* Invalid input parameters */
	return EEPROM_STATUS_FAILURE;
 8020690:	2002      	movs	r0, #2
  }
  else
  {
	return EEPROM_STATUS_FAILURE;
  }
}
 8020692:	46bd      	mov	sp, r7
 8020694:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    /* Invalid input parameters */
	return EEPROM_STATUS_FAILURE;
  }

  /* Get the buffer size for the structure */
  if ((struct_size % 4) != 0)
 8020698:	078c      	lsls	r4, r1, #30
  {
    buffer_size = struct_size/4 + 1;
 802069a:	bf18      	it	ne
 802069c:	3501      	addne	r5, #1
 802069e:	4614      	mov	r4, r2
 80206a0:	4606      	mov	r6, r0
  {
	buffer_size = struct_size/4;
  }

  /* Clear the receive buffer */
  memset(buffer, 0, sizeof(buffer));
 80206a2:	461a      	mov	r2, r3
 80206a4:	4689      	mov	r9, r1
 80206a6:	4668      	mov	r0, sp
 80206a8:	2100      	movs	r1, #0
 80206aa:	f00c ff54 	bl	802d556 <memset>

  /* Read hardware settings structure from EEPROM */
  ret_status = bsp_eeprom_24cw128x_read_data(eeprom_address, (uint8_t*)buffer, (buffer_size + 1)*4);
 80206ae:	1c6a      	adds	r2, r5, #1
 80206b0:	4620      	mov	r0, r4
 80206b2:	0092      	lsls	r2, r2, #2
 80206b4:	4669      	mov	r1, sp
 80206b6:	f008 fa29 	bl	8028b0c <bsp_eeprom_24cw128x_read_data>

  /* Get the old CRC and compare it with the new one */
  old_crc32 = buffer[buffer_size];
  CRC_SW_CalculateCRC(&CRC_SW_EEPROM, buffer, buffer_size);
 80206ba:	4669      	mov	r1, sp
 80206bc:	462a      	mov	r2, r5

  /* Clear the receive buffer */
  memset(buffer, 0, sizeof(buffer));

  /* Read hardware settings structure from EEPROM */
  ret_status = bsp_eeprom_24cw128x_read_data(eeprom_address, (uint8_t*)buffer, (buffer_size + 1)*4);
 80206be:	4604      	mov	r4, r0

  /* Get the old CRC and compare it with the new one */
  old_crc32 = buffer[buffer_size];
  CRC_SW_CalculateCRC(&CRC_SW_EEPROM, buffer, buffer_size);
 80206c0:	4809      	ldr	r0, [pc, #36]	; (80206e8 <ds_eeprom_read_settings+0x74>)

  /* Read hardware settings structure from EEPROM */
  ret_status = bsp_eeprom_24cw128x_read_data(eeprom_address, (uint8_t*)buffer, (buffer_size + 1)*4);

  /* Get the old CRC and compare it with the new one */
  old_crc32 = buffer[buffer_size];
 80206c2:	f85d a025 	ldr.w	sl, [sp, r5, lsl #2]
  CRC_SW_CalculateCRC(&CRC_SW_EEPROM, buffer, buffer_size);
 80206c6:	f006 f8d5 	bl	8026874 <CRC_SW_CalculateCRC>
  new_crc32 = CRC_SW_GetCRCResult(&CRC_SW_EEPROM);
 80206ca:	4807      	ldr	r0, [pc, #28]	; (80206e8 <ds_eeprom_read_settings+0x74>)
 80206cc:	f006 f914 	bl	80268f8 <CRC_SW_GetCRCResult>

  /* Check for CRC error */
  if ((new_crc32 == old_crc32) && (ret_status == EEPROM_STATUS_SUCCESS))
 80206d0:	4550      	cmp	r0, sl
 80206d2:	d1dd      	bne.n	8020690 <ds_eeprom_read_settings+0x1c>
 80206d4:	2c01      	cmp	r4, #1
 80206d6:	d1db      	bne.n	8020690 <ds_eeprom_read_settings+0x1c>
  {
    /* Valid CRC: copy buffer into the HW settings structure */
	memcpy(p_settings, buffer, struct_size);
 80206d8:	4630      	mov	r0, r6
 80206da:	4669      	mov	r1, sp
 80206dc:	464a      	mov	r2, r9
 80206de:	f00c ff2f 	bl	802d540 <memcpy>

    return EEPROM_STATUS_SUCCESS;
 80206e2:	4620      	mov	r0, r4
 80206e4:	e7d5      	b.n	8020692 <ds_eeprom_read_settings+0x1e>
 80206e6:	bf00      	nop
 80206e8:	1ffe9494 	.word	0x1ffe9494

080206ec <ds_eeprom_read_board_id>:

  uint8_t buffer[32], index = 0;
  char *id = board_id;
  RF_SHIELD_STATUS_t shield_status = RF_SHIELD_BOARD_NOT_CONNECTED;

  if ((board_id == NULL) || (id_size > 32) || (id_size == 0))
 80206ec:	b110      	cbz	r0, 80206f4 <ds_eeprom_read_board_id+0x8>
 80206ee:	1e4b      	subs	r3, r1, #1
 80206f0:	2b1f      	cmp	r3, #31
 80206f2:	d901      	bls.n	80206f8 <ds_eeprom_read_board_id+0xc>
  {
	return RF_SHIELD_BOARD_INVALID_PARAM;
 80206f4:	2001      	movs	r0, #1
  {
    shield_status = RF_SHIELD_BOARD_NOT_CONNECTED;
  }

  return shield_status;
}
 80206f6:	4770      	bx	lr
//============================================================================

/* Function to read board ID from EEPROM
   !!! Only 32 bytes are reserved for the RF board ID */
RF_SHIELD_STATUS_t ds_eeprom_read_board_id(char *board_id, uint8_t id_size)
{
 80206f8:	b5f0      	push	{r4, r5, r6, r7, lr}
  {
	return RF_SHIELD_BOARD_INVALID_PARAM;
  }

  /* Clear the receive buffer */
  memset(buffer, 0, sizeof(buffer));
 80206fa:	2400      	movs	r4, #0
//============================================================================

/* Function to read board ID from EEPROM
   !!! Only 32 bytes are reserved for the RF board ID */
RF_SHIELD_STATUS_t ds_eeprom_read_board_id(char *board_id, uint8_t id_size)
{
 80206fc:	b089      	sub	sp, #36	; 0x24
 80206fe:	460f      	mov	r7, r1
 8020700:	4605      	mov	r5, r0

  /* Clear the receive buffer */
  memset(buffer, 0, sizeof(buffer));

  /*  Read RF board ID from EEPROM and check if a valid board ID is written in EEPROM */
  if (bsp_eeprom_24cw128x_read_data(eeprom_address, buffer, id_size) == EEPROM_STATUS_SUCCESS)
 8020702:	4669      	mov	r1, sp
 8020704:	4620      	mov	r0, r4
 8020706:	463a      	mov	r2, r7
  {
	return RF_SHIELD_BOARD_INVALID_PARAM;
  }

  /* Clear the receive buffer */
  memset(buffer, 0, sizeof(buffer));
 8020708:	9400      	str	r4, [sp, #0]
 802070a:	9401      	str	r4, [sp, #4]
 802070c:	9402      	str	r4, [sp, #8]
 802070e:	9403      	str	r4, [sp, #12]
 8020710:	9404      	str	r4, [sp, #16]
 8020712:	9405      	str	r4, [sp, #20]
 8020714:	9406      	str	r4, [sp, #24]
 8020716:	9407      	str	r4, [sp, #28]

  /*  Read RF board ID from EEPROM and check if a valid board ID is written in EEPROM */
  if (bsp_eeprom_24cw128x_read_data(eeprom_address, buffer, id_size) == EEPROM_STATUS_SUCCESS)
 8020718:	f008 f9f8 	bl	8028b0c <bsp_eeprom_24cw128x_read_data>
 802071c:	2801      	cmp	r0, #1
 802071e:	d002      	beq.n	8020726 <ds_eeprom_read_board_id+0x3a>
      }
    }while (index <= id_size);
  }
  else /* In case of I2C error */
  {
    shield_status = RF_SHIELD_BOARD_NOT_CONNECTED;
 8020720:	2005      	movs	r0, #5
  }

  return shield_status;
}
 8020722:	b009      	add	sp, #36	; 0x24
 8020724:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8020726:	1c79      	adds	r1, r7, #1
 8020728:	4628      	mov	r0, r5

  /* Clear the receive buffer */
  memset(buffer, 0, sizeof(buffer));

  /*  Read RF board ID from EEPROM and check if a valid board ID is written in EEPROM */
  if (bsp_eeprom_24cw128x_read_data(eeprom_address, buffer, id_size) == EEPROM_STATUS_SUCCESS)
 802072a:	4623      	mov	r3, r4
 802072c:	b2c9      	uxtb	r1, r1
 802072e:	f10d 32ff 	add.w	r2, sp, #4294967295
 8020732:	e004      	b.n	802073e <ds_eeprom_read_board_id+0x52>
      }
      else if (*id == buffer[index])
      {
        /* Go to the next char */
        id++;
        index++;
 8020734:	b2f3      	uxtb	r3, r6
    	  RF shield is not programmed or it contains invalid data */
          shield_status = RF_SHIELD_BOARD_NOT_PROGRAMMED;
    	}
        break;
      }
    }while (index <= id_size);
 8020736:	428b      	cmp	r3, r1
 8020738:	d0f2      	beq.n	8020720 <ds_eeprom_read_board_id+0x34>
  /*  Read RF board ID from EEPROM and check if a valid board ID is written in EEPROM */
  if (bsp_eeprom_24cw128x_read_data(eeprom_address, buffer, id_size) == EEPROM_STATUS_SUCCESS)
  {
    do
    {
      if ((index == id_size) && (*id == '\0'))
 802073a:	429f      	cmp	r7, r3
 802073c:	d00c      	beq.n	8020758 <ds_eeprom_read_board_id+0x6c>
      {
        /* Valid board ID */
        shield_status = RF_SHIELD_BOARD_SUPPORTED;
        break;
      }
      else if (*id == buffer[index])
 802073e:	f810 4b01 	ldrb.w	r4, [r0], #1
 8020742:	f812 5f01 	ldrb.w	r5, [r2, #1]!
 8020746:	42a5      	cmp	r5, r4
      {
        /* Go to the next char */
        id++;
        index++;
 8020748:	f103 0601 	add.w	r6, r3, #1
      {
        /* Valid board ID */
        shield_status = RF_SHIELD_BOARD_SUPPORTED;
        break;
      }
      else if (*id == buffer[index])
 802074c:	d0f2      	beq.n	8020734 <ds_eeprom_read_board_id+0x48>
    	}
    	else
    	{
    	  /* Invalid RF shield board.
    	  RF shield is not programmed or it contains invalid data */
          shield_status = RF_SHIELD_BOARD_NOT_PROGRAMMED;
 802074e:	2b02      	cmp	r3, #2
 8020750:	bf8c      	ite	hi
 8020752:	2003      	movhi	r0, #3
 8020754:	2004      	movls	r0, #4
 8020756:	e7e4      	b.n	8020722 <ds_eeprom_read_board_id+0x36>
  /*  Read RF board ID from EEPROM and check if a valid board ID is written in EEPROM */
  if (bsp_eeprom_24cw128x_read_data(eeprom_address, buffer, id_size) == EEPROM_STATUS_SUCCESS)
  {
    do
    {
      if ((index == id_size) && (*id == '\0'))
 8020758:	7804      	ldrb	r4, [r0, #0]
 802075a:	2c00      	cmp	r4, #0
 802075c:	d1ef      	bne.n	802073e <ds_eeprom_read_board_id+0x52>
      {
        /* Valid board ID */
        shield_status = RF_SHIELD_BOARD_SUPPORTED;
 802075e:	2002      	movs	r0, #2
 8020760:	e7df      	b.n	8020722 <ds_eeprom_read_board_id+0x36>
 8020762:	bf00      	nop

08020764 <ds_eeprom_write_inital_board_id>:
//============================================================================

/* TODO: remove for release! */

uint8_t ds_eeprom_write_inital_board_id(void)
{
 8020764:	b500      	push	{lr}
  uint8_t buffer[] = RF_BOARD_ID;
 8020766:	4b07      	ldr	r3, [pc, #28]	; (8020784 <ds_eeprom_write_inital_board_id+0x20>)
 8020768:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
//============================================================================

/* TODO: remove for release! */

uint8_t ds_eeprom_write_inital_board_id(void)
{
 802076c:	b085      	sub	sp, #20
  uint8_t buffer[] = RF_BOARD_ID;
 802076e:	ab01      	add	r3, sp, #4
 8020770:	c303      	stmia	r3!, {r0, r1}

  /* Read RF board ID from EEPROM */
  return bsp_eeprom_24cw128x_write_data(DS_EEPROM_ADDRESS_BOARD_ID, buffer, sizeof(buffer));
 8020772:	a901      	add	r1, sp, #4

/* TODO: remove for release! */

uint8_t ds_eeprom_write_inital_board_id(void)
{
  uint8_t buffer[] = RF_BOARD_ID;
 8020774:	701a      	strb	r2, [r3, #0]

  /* Read RF board ID from EEPROM */
  return bsp_eeprom_24cw128x_write_data(DS_EEPROM_ADDRESS_BOARD_ID, buffer, sizeof(buffer));
 8020776:	2000      	movs	r0, #0
 8020778:	2209      	movs	r2, #9
 802077a:	f008 f88d 	bl	8028898 <bsp_eeprom_24cw128x_write_data>
}
 802077e:	b005      	add	sp, #20
 8020780:	f85d fb04 	ldr.w	pc, [sp], #4
 8020784:	0802d5b8 	.word	0x0802d5b8

08020788 <ds_ep_get_device_info>:
//============================================================================

const Device_Info_t *ds_ep_get_device_info(void)
{
	return (&cg_device_info_struct);
}
 8020788:	4800      	ldr	r0, [pc, #0]	; (802078c <ds_ep_get_device_info+0x4>)
 802078a:	4770      	bx	lr
 802078c:	0802d5f0 	.word	0x0802d5f0

08020790 <ds_ep_fetch_frame_format>:

//============================================================================

void ds_ep_fetch_frame_format(Frame_Format_t *p_frame_format)
{
 8020790:	b510      	push	{r4, lr}
 8020792:	4604      	mov	r4, r0
	device_settings_t *p_dev              = ds_device_get_settings();
 8020794:	f7ff fcb2 	bl	80200fc <ds_device_get_settings>
	p_frame_format->num_samples_per_chirp = p_dev->num_samples_per_chirp;
	p_frame_format->num_chirps_per_frame  = p_dev->num_of_chirps_per_frame;
 8020798:	69c2      	ldr	r2, [r0, #28]
//============================================================================

void ds_ep_fetch_frame_format(Frame_Format_t *p_frame_format)
{
	device_settings_t *p_dev              = ds_device_get_settings();
	p_frame_format->num_samples_per_chirp = p_dev->num_samples_per_chirp;
 802079a:	6a41      	ldr	r1, [r0, #36]	; 0x24
	p_frame_format->num_chirps_per_frame  = p_dev->num_of_chirps_per_frame;
 802079c:	e884 0006 	stmia.w	r4, {r1, r2}
	p_frame_format->rx_mask               = p_dev->rx_antenna_mask;
 80207a0:	f890 2028 	ldrb.w	r2, [r0, #40]	; 0x28
 80207a4:	7222      	strb	r2, [r4, #8]
	p_frame_format->signal_part           = RADAR_SIGNAL_I_AND_Q;
 80207a6:	2302      	movs	r3, #2
 80207a8:	7263      	strb	r3, [r4, #9]
 80207aa:	bd10      	pop	{r4, pc}

080207ac <SystemCoreClockUpdate>:
  uint32_t pdiv;
  uint32_t ndiv;
  uint32_t kdiv;
  uint32_t temp;

  if (SCU_CLK->SYSCLKCR & SCU_CLK_SYSCLKCR_SYSSEL_Msk)
 80207ac:	4b1c      	ldr	r3, [pc, #112]	; (8020820 <SystemCoreClockUpdate+0x74>)
 80207ae:	68db      	ldr	r3, [r3, #12]
 80207b0:	03d9      	lsls	r1, r3, #15

  SystemCoreClockUpdate();
}

__WEAK void SystemCoreClockUpdate(void)
{
 80207b2:	b510      	push	{r4, lr}
  uint32_t pdiv;
  uint32_t ndiv;
  uint32_t kdiv;
  uint32_t temp;

  if (SCU_CLK->SYSCLKCR & SCU_CLK_SYSCLKCR_SYSSEL_Msk)
 80207b4:	d51d      	bpl.n	80207f2 <SystemCoreClockUpdate+0x46>
  {
    /* fPLL is clock source for fSYS */
    if(SCU_PLL->PLLCON2 & SCU_PLL_PLLCON2_PINSEL_Msk)
 80207b6:	4b1b      	ldr	r3, [pc, #108]	; (8020824 <SystemCoreClockUpdate+0x78>)
 80207b8:	68db      	ldr	r3, [r3, #12]
 80207ba:	07da      	lsls	r2, r3, #31
 80207bc:	d52c      	bpl.n	8020818 <SystemCoreClockUpdate+0x6c>
    {
      /* PLL input clock is the backup clock (fOFI) */
      temp = OFI_FREQUENCY;
 80207be:	481a      	ldr	r0, [pc, #104]	; (8020828 <SystemCoreClockUpdate+0x7c>)
      /* PLL input clock is the high performance osicllator (fOSCHP) */
      temp = OSCHP_GetFrequency();
    }

    /* check if PLL is locked */
    if (SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_VCOLOCK_Msk)
 80207c0:	4a18      	ldr	r2, [pc, #96]	; (8020824 <SystemCoreClockUpdate+0x78>)
 80207c2:	6813      	ldr	r3, [r2, #0]
 80207c4:	075b      	lsls	r3, r3, #29
 80207c6:	d416      	bmi.n	80207f6 <SystemCoreClockUpdate+0x4a>
    }
    else
    {
      /* PLL prescalar mode */
      /* read back divider settings */
      kdiv  = ((SCU_PLL->PLLCON1 & SCU_PLL_PLLCON1_K1DIV_Msk) >> SCU_PLL_PLLCON1_K1DIV_Pos) + 1;
 80207c8:	6893      	ldr	r3, [r2, #8]
 80207ca:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 80207ce:	3301      	adds	r3, #1
      
      temp = (temp / kdiv);
 80207d0:	fbb0 f3f3 	udiv	r3, r0, r3
  {
    /* fOFI is clock source for fSYS */    
    temp = OFI_FREQUENCY;
  }

  temp = temp / ((SCU_CLK->SYSCLKCR & SCU_CLK_SYSCLKCR_SYSDIV_Msk) + 1);
 80207d4:	4a12      	ldr	r2, [pc, #72]	; (8020820 <SystemCoreClockUpdate+0x74>)
  temp = temp / ((SCU_CLK->CPUCLKCR & SCU_CLK_CPUCLKCR_CPUDIV_Msk) + 1);

  SystemCoreClock = temp;
 80207d6:	4915      	ldr	r1, [pc, #84]	; (802082c <SystemCoreClockUpdate+0x80>)
  {
    /* fOFI is clock source for fSYS */    
    temp = OFI_FREQUENCY;
  }

  temp = temp / ((SCU_CLK->SYSCLKCR & SCU_CLK_SYSCLKCR_SYSDIV_Msk) + 1);
 80207d8:	68d0      	ldr	r0, [r2, #12]
  temp = temp / ((SCU_CLK->CPUCLKCR & SCU_CLK_CPUCLKCR_CPUDIV_Msk) + 1);
 80207da:	6912      	ldr	r2, [r2, #16]
  {
    /* fOFI is clock source for fSYS */    
    temp = OFI_FREQUENCY;
  }

  temp = temp / ((SCU_CLK->SYSCLKCR & SCU_CLK_SYSCLKCR_SYSDIV_Msk) + 1);
 80207dc:	b2c0      	uxtb	r0, r0
  temp = temp / ((SCU_CLK->CPUCLKCR & SCU_CLK_CPUCLKCR_CPUDIV_Msk) + 1);
 80207de:	f002 0201 	and.w	r2, r2, #1
  {
    /* fOFI is clock source for fSYS */    
    temp = OFI_FREQUENCY;
  }

  temp = temp / ((SCU_CLK->SYSCLKCR & SCU_CLK_SYSCLKCR_SYSDIV_Msk) + 1);
 80207e2:	3001      	adds	r0, #1
  temp = temp / ((SCU_CLK->CPUCLKCR & SCU_CLK_CPUCLKCR_CPUDIV_Msk) + 1);
 80207e4:	3201      	adds	r2, #1
  {
    /* fOFI is clock source for fSYS */    
    temp = OFI_FREQUENCY;
  }

  temp = temp / ((SCU_CLK->SYSCLKCR & SCU_CLK_SYSCLKCR_SYSDIV_Msk) + 1);
 80207e6:	fbb3 f0f0 	udiv	r0, r3, r0
  temp = temp / ((SCU_CLK->CPUCLKCR & SCU_CLK_CPUCLKCR_CPUDIV_Msk) + 1);
 80207ea:	fbb0 f0f2 	udiv	r0, r0, r2

  SystemCoreClock = temp;
 80207ee:	6008      	str	r0, [r1, #0]
 80207f0:	bd10      	pop	{r4, pc}
    }
  }
  else
  {
    /* fOFI is clock source for fSYS */    
    temp = OFI_FREQUENCY;
 80207f2:	4b0d      	ldr	r3, [pc, #52]	; (8020828 <SystemCoreClockUpdate+0x7c>)
 80207f4:	e7ee      	b.n	80207d4 <SystemCoreClockUpdate+0x28>
    /* check if PLL is locked */
    if (SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_VCOLOCK_Msk)
    {
      /* PLL normal mode */
      /* read back divider settings */
      pdiv = ((SCU_PLL->PLLCON1 & SCU_PLL_PLLCON1_PDIV_Msk) >> SCU_PLL_PLLCON1_PDIV_Pos) + 1;
 80207f6:	6891      	ldr	r1, [r2, #8]
      ndiv = ((SCU_PLL->PLLCON1 & SCU_PLL_PLLCON1_NDIV_Msk) >> SCU_PLL_PLLCON1_NDIV_Pos) + 1;
 80207f8:	6893      	ldr	r3, [r2, #8]
      kdiv = ((SCU_PLL->PLLCON1 & SCU_PLL_PLLCON1_K2DIV_Msk) >> SCU_PLL_PLLCON1_K2DIV_Pos) + 1;
 80207fa:	6894      	ldr	r4, [r2, #8]
    /* check if PLL is locked */
    if (SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_VCOLOCK_Msk)
    {
      /* PLL normal mode */
      /* read back divider settings */
      pdiv = ((SCU_PLL->PLLCON1 & SCU_PLL_PLLCON1_PDIV_Msk) >> SCU_PLL_PLLCON1_PDIV_Pos) + 1;
 80207fc:	f3c1 6203 	ubfx	r2, r1, #24, #4
 8020800:	3201      	adds	r2, #1
      ndiv = ((SCU_PLL->PLLCON1 & SCU_PLL_PLLCON1_NDIV_Msk) >> SCU_PLL_PLLCON1_NDIV_Pos) + 1;
      kdiv = ((SCU_PLL->PLLCON1 & SCU_PLL_PLLCON1_K2DIV_Msk) >> SCU_PLL_PLLCON1_K2DIV_Pos) + 1;
 8020802:	f3c4 4106 	ubfx	r1, r4, #16, #7
    if (SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_VCOLOCK_Msk)
    {
      /* PLL normal mode */
      /* read back divider settings */
      pdiv = ((SCU_PLL->PLLCON1 & SCU_PLL_PLLCON1_PDIV_Msk) >> SCU_PLL_PLLCON1_PDIV_Pos) + 1;
      ndiv = ((SCU_PLL->PLLCON1 & SCU_PLL_PLLCON1_NDIV_Msk) >> SCU_PLL_PLLCON1_NDIV_Pos) + 1;
 8020806:	f3c3 2306 	ubfx	r3, r3, #8, #7
      kdiv = ((SCU_PLL->PLLCON1 & SCU_PLL_PLLCON1_K2DIV_Msk) >> SCU_PLL_PLLCON1_K2DIV_Pos) + 1;

      temp = (temp / (pdiv * kdiv)) * ndiv;
 802080a:	fb01 2202 	mla	r2, r1, r2, r2
 802080e:	fbb0 f0f2 	udiv	r0, r0, r2
 8020812:	fb03 0300 	mla	r3, r3, r0, r0
 8020816:	e7dd      	b.n	80207d4 <SystemCoreClockUpdate+0x28>
      temp = OFI_FREQUENCY;
    }
    else
    {
      /* PLL input clock is the high performance osicllator (fOSCHP) */
      temp = OSCHP_GetFrequency();
 8020818:	f007 f93a 	bl	8027a90 <OSCHP_GetFrequency>
 802081c:	e7d0      	b.n	80207c0 <SystemCoreClockUpdate+0x14>
 802081e:	bf00      	nop
 8020820:	50004600 	.word	0x50004600
 8020824:	50004710 	.word	0x50004710
 8020828:	016e3600 	.word	0x016e3600
 802082c:	2003ffc0 	.word	0x2003ffc0

08020830 <SystemInit>:
/*******************************************************************************
 * API IMPLEMENTATION
 *******************************************************************************/

__WEAK void SystemInit(void)
{
 8020830:	b510      	push	{r4, lr}
  memcpy(g_chipid, CHIPID_LOC, 16);
 8020832:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
 8020836:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 8020838:	4c03      	ldr	r4, [pc, #12]	; (8020848 <SystemInit+0x18>)
 802083a:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
  
  SystemCoreSetup();
 802083e:	f006 f883 	bl	8026948 <SystemCoreSetup>
  SystemCoreClockSetup(); 
 8020842:	f007 f929 	bl	8027a98 <SystemCoreClockSetup>
 8020846:	bd10      	pop	{r4, pc}
 8020848:	2003ffc4 	.word	0x2003ffc4

0802084c <get_buffer_address_by_chirp>:

uint8_t *get_buffer_address_by_chirp(acq_buf_obj *p_obj, uint32_t channel_index, uint32_t chirpCnt)
{
  size_t offset = 0;
  
  if (p_obj->p_acq_buf == NULL)
 802084c:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 802084e:	b173      	cbz	r3, 802086e <get_buffer_address_by_chirp+0x22>
   6. EXPORTED FUNCTIONS
==============================================================================
 */

uint8_t *get_buffer_address_by_chirp(acq_buf_obj *p_obj, uint32_t channel_index, uint32_t chirpCnt)
{
 8020850:	b470      	push	{r4, r5, r6}
 8020852:	88c5      	ldrh	r5, [r0, #6]
  
  if (p_obj->p_acq_buf == NULL)
    return NULL;
  
  // since the chirps are interleaved, we calculate the buffer base address for a new chirp and the related channel here:
  offset = (p_obj->internals.chirp_inc * chirpCnt) + (p_obj->internals.channel_inc * channel_index);
 8020854:	6944      	ldr	r4, [r0, #20]
 8020856:	6906      	ldr	r6, [r0, #16]
 8020858:	42a9      	cmp	r1, r5
 802085a:	fb04 f001 	mul.w	r0, r4, r1
 802085e:	fb06 0202 	mla	r2, r6, r2, r0
 8020862:	d300      	bcc.n	8020866 <get_buffer_address_by_chirp+0x1a>
 8020864:	e7fe      	b.n	8020864 <get_buffer_address_by_chirp+0x18>
  
  /*TODO: Throw some error, if channel_index is larger then the internal number of channels! */
  while (channel_index >= p_obj->params.num_of_rx_values);

  return &p_obj->p_acq_buf[offset];
 8020866:	4413      	add	r3, r2
}
 8020868:	4618      	mov	r0, r3
 802086a:	bc70      	pop	{r4, r5, r6}
 802086c:	4770      	bx	lr
 802086e:	4618      	mov	r0, r3
 8020870:	4770      	bx	lr
 8020872:	bf00      	nop

08020874 <create_acq_data_buffer_obj>:

acq_buf_obj create_acq_data_buffer_obj(uint8_t *p_allocated_buffer, size_t allocated_buffer_size,
                                       uint16_t max_num_of_chirps_per_frame, uint16_t max_num_of_samples_per_chirp,
                                       uint16_t max_num_of_adc_channels, uint16_t adc_resolution,
                                       uint32_t num_sample_skip_count)
{
 8020874:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8020878:	f8bd 6020 	ldrh.w	r6, [sp, #32]
 802087c:	f8bd c018 	ldrh.w	ip, [sp, #24]
 8020880:	f8bd e01c 	ldrh.w	lr, [sp, #28]
 8020884:	9d09      	ldr	r5, [sp, #36]	; 0x24
  
  obj.status = allocation_ok;
  obj.access_lock = 0;
  obj.acq_timestime = 0;
  obj.internals.is_dynamic_allocated = 0;
  obj.internals.skip_count = num_sample_skip_count;
 8020886:	61c5      	str	r5, [r0, #28]
                                       uint16_t max_num_of_adc_channels, uint16_t adc_resolution,
                                       uint32_t num_sample_skip_count)
{
  acq_buf_obj obj;
  size_t required_size = 0;
  size_t value_size = ((adc_resolution - 1) / 8 ) + 1;
 8020888:	1e74      	subs	r4, r6, #1
 802088a:	bf48      	it	mi
 802088c:	1db4      	addmi	r4, r6, #6
 802088e:	10e4      	asrs	r4, r4, #3
  }
#endif
  
  // calculate the size of allocation buffer
  // consider that an internal acquisition buffer needs to be uint32_t bit aligned on ARM!
  required_size = obj.params.num_of_chirps_per_frame * obj.params.num_of_samples_per_chirp * obj.params.num_of_rx_values * obj.params.size_of_value_in_bytes;
 8020890:	fb0c f703 	mul.w	r7, ip, r3
                                       uint16_t max_num_of_adc_channels, uint16_t adc_resolution,
                                       uint32_t num_sample_skip_count)
{
  acq_buf_obj obj;
  size_t required_size = 0;
  size_t value_size = ((adc_resolution - 1) / 8 ) + 1;
 8020894:	3401      	adds	r4, #1
  }
#endif
  
  // calculate the size of allocation buffer
  // consider that an internal acquisition buffer needs to be uint32_t bit aligned on ARM!
  required_size = obj.params.num_of_chirps_per_frame * obj.params.num_of_samples_per_chirp * obj.params.num_of_rx_values * obj.params.size_of_value_in_bytes;
 8020896:	fb0e f707 	mul.w	r7, lr, r7
  acq_buf_obj obj;
  size_t required_size = 0;
  size_t value_size = ((adc_resolution - 1) / 8 ) + 1;
  
  obj.status = allocation_ok;
  obj.access_lock = 0;
 802089a:	2600      	movs	r6, #0
  }
#endif
  
  // calculate the size of allocation buffer
  // consider that an internal acquisition buffer needs to be uint32_t bit aligned on ARM!
  required_size = obj.params.num_of_chirps_per_frame * obj.params.num_of_samples_per_chirp * obj.params.num_of_rx_values * obj.params.size_of_value_in_bytes;
 802089c:	fb07 f704 	mul.w	r7, r7, r4
{
  acq_buf_obj obj;
  size_t required_size = 0;
  size_t value_size = ((adc_resolution - 1) / 8 ) + 1;
  
  obj.status = allocation_ok;
 80208a0:	f04f 0801 	mov.w	r8, #1
  
  obj.p_acq_buf = p_allocated_buffer;
  obj.internals.size_of_acq_buffer = allocated_buffer_size;
  obj.used_size_of_acq_buffer = required_size;
  
  if (max_num_of_adc_channels > MAX_SUPPORTED_RX_SIGNALS_INT)
 80208a4:	f1be 0f04 	cmp.w	lr, #4
  obj.internals.skip_count = num_sample_skip_count;
  
  obj.params.num_of_chirps_per_frame = max_num_of_chirps_per_frame;
  obj.params.num_of_samples_per_chirp = max_num_of_samples_per_chirp;
  obj.params.num_of_rx_values = max_num_of_adc_channels;
  obj.params.size_of_value_in_bytes = value_size;
 80208a8:	8104      	strh	r4, [r0, #8]
  obj.access_lock = 0;
  obj.acq_timestime = 0;
  obj.internals.is_dynamic_allocated = 0;
  obj.internals.skip_count = num_sample_skip_count;
  
  obj.params.num_of_chirps_per_frame = max_num_of_chirps_per_frame;
 80208aa:	8083      	strh	r3, [r0, #4]
  // consider that an internal acquisition buffer needs to be uint32_t bit aligned on ARM!
  required_size = obj.params.num_of_chirps_per_frame * obj.params.num_of_samples_per_chirp * obj.params.num_of_rx_values * obj.params.size_of_value_in_bytes;
  
  obj.p_acq_buf = p_allocated_buffer;
  obj.internals.size_of_acq_buffer = allocated_buffer_size;
  obj.used_size_of_acq_buffer = required_size;
 80208ac:	6207      	str	r7, [r0, #32]
  obj.acq_timestime = 0;
  obj.internals.is_dynamic_allocated = 0;
  obj.internals.skip_count = num_sample_skip_count;
  
  obj.params.num_of_chirps_per_frame = max_num_of_chirps_per_frame;
  obj.params.num_of_samples_per_chirp = max_num_of_samples_per_chirp;
 80208ae:	f8a0 c002 	strh.w	ip, [r0, #2]
  obj.params.num_of_rx_values = max_num_of_adc_channels;
 80208b2:	f8a0 e006 	strh.w	lr, [r0, #6]
  
  // calculate the size of allocation buffer
  // consider that an internal acquisition buffer needs to be uint32_t bit aligned on ARM!
  required_size = obj.params.num_of_chirps_per_frame * obj.params.num_of_samples_per_chirp * obj.params.num_of_rx_values * obj.params.size_of_value_in_bytes;
  
  obj.p_acq_buf = p_allocated_buffer;
 80208b6:	62c1      	str	r1, [r0, #44]	; 0x2c
  obj.internals.size_of_acq_buffer = allocated_buffer_size;
 80208b8:	60c2      	str	r2, [r0, #12]
{
  acq_buf_obj obj;
  size_t required_size = 0;
  size_t value_size = ((adc_resolution - 1) / 8 ) + 1;
  
  obj.status = allocation_ok;
 80208ba:	f880 8030 	strb.w	r8, [r0, #48]	; 0x30
  obj.access_lock = 0;
 80208be:	6286      	str	r6, [r0, #40]	; 0x28
  obj.acq_timestime = 0;
 80208c0:	6246      	str	r6, [r0, #36]	; 0x24
  obj.internals.is_dynamic_allocated = 0;
 80208c2:	6186      	str	r6, [r0, #24]
  obj.params.num_of_chirps_per_frame = max_num_of_chirps_per_frame;
  obj.params.num_of_samples_per_chirp = max_num_of_samples_per_chirp;
  obj.params.num_of_rx_values = max_num_of_adc_channels;
  obj.params.size_of_value_in_bytes = value_size;
  
  obj.data_type = data_type_unknown;
 80208c4:	7006      	strb	r6, [r0, #0]
  
  obj.p_acq_buf = p_allocated_buffer;
  obj.internals.size_of_acq_buffer = allocated_buffer_size;
  obj.used_size_of_acq_buffer = required_size;
  
  if (max_num_of_adc_channels > MAX_SUPPORTED_RX_SIGNALS_INT)
 80208c6:	d81b      	bhi.n	8020900 <create_acq_data_buffer_obj+0x8c>
    obj.internals.size_of_acq_buffer = 0;
    obj.used_size_of_acq_buffer = 0;
    return obj;
  }
  
  if (p_allocated_buffer != NULL && allocated_buffer_size == 0)
 80208c8:	b351      	cbz	r1, 8020920 <create_acq_data_buffer_obj+0xac>
 80208ca:	b18a      	cbz	r2, 80208f0 <create_acq_data_buffer_obj+0x7c>
    obj.internals.size_of_acq_buffer = 0;
    obj.used_size_of_acq_buffer = 0;
    return obj;
  }
  
  if (((obj.p_acq_buf != NULL) && (obj.internals.size_of_acq_buffer != 0)) && obj.internals.size_of_acq_buffer < required_size)
 80208cc:	4297      	cmp	r7, r2
 80208ce:	d81f      	bhi.n	8020910 <create_acq_data_buffer_obj+0x9c>
  obj.internals.channel_inc = obj.params.num_of_samples_per_chirp * obj.params.size_of_value_in_bytes;
  obj.internals.chirp_inc   = obj.internals.channel_inc * obj.params.num_of_rx_values;
  
  if (obj.p_acq_buf != NULL)
  {
    memset(obj.p_acq_buf, 0, sizeof(obj.used_size_of_acq_buffer));
 80208d0:	460b      	mov	r3, r1
    }
  }
#endif
  
  // calculated internal buffer offsets
  obj.internals.channel_inc = obj.params.num_of_samples_per_chirp * obj.params.size_of_value_in_bytes;
 80208d2:	fb0c f404 	mul.w	r4, ip, r4
  obj.internals.chirp_inc   = obj.internals.channel_inc * obj.params.num_of_rx_values;
  
  if (obj.p_acq_buf != NULL)
  {
    memset(obj.p_acq_buf, 0, sizeof(obj.used_size_of_acq_buffer));
 80208d6:	f803 6b01 	strb.w	r6, [r3], #1
 80208da:	3301      	adds	r3, #1
 80208dc:	704e      	strb	r6, [r1, #1]
 80208de:	f803 6b01 	strb.w	r6, [r3], #1
  }
#endif
  
  // calculated internal buffer offsets
  obj.internals.channel_inc = obj.params.num_of_samples_per_chirp * obj.params.size_of_value_in_bytes;
  obj.internals.chirp_inc   = obj.internals.channel_inc * obj.params.num_of_rx_values;
 80208e2:	fb0e f204 	mul.w	r2, lr, r4
  
  if (obj.p_acq_buf != NULL)
  {
    memset(obj.p_acq_buf, 0, sizeof(obj.used_size_of_acq_buffer));
 80208e6:	701e      	strb	r6, [r3, #0]
  }
#endif
  
  // calculated internal buffer offsets
  obj.internals.channel_inc = obj.params.num_of_samples_per_chirp * obj.params.size_of_value_in_bytes;
  obj.internals.chirp_inc   = obj.internals.channel_inc * obj.params.num_of_rx_values;
 80208e8:	6102      	str	r2, [r0, #16]
    }
  }
#endif
  
  // calculated internal buffer offsets
  obj.internals.channel_inc = obj.params.num_of_samples_per_chirp * obj.params.size_of_value_in_bytes;
 80208ea:	6144      	str	r4, [r0, #20]
 80208ec:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    return obj;
  }
  
  if (p_allocated_buffer != NULL && allocated_buffer_size == 0)
  {
    obj.status = allocation_size_is_zero;
 80208f0:	2304      	movs	r3, #4
    obj.p_acq_buf = NULL;
 80208f2:	62c2      	str	r2, [r0, #44]	; 0x2c
    obj.internals.size_of_acq_buffer = 0;
 80208f4:	60c2      	str	r2, [r0, #12]
    obj.used_size_of_acq_buffer = 0;
 80208f6:	6202      	str	r2, [r0, #32]
    return obj;
  }
  
  if (p_allocated_buffer != NULL && allocated_buffer_size == 0)
  {
    obj.status = allocation_size_is_zero;
 80208f8:	f880 3030 	strb.w	r3, [r0, #48]	; 0x30
    obj.p_acq_buf = NULL;
    obj.internals.size_of_acq_buffer = 0;
    obj.used_size_of_acq_buffer = 0;
    return obj;
 80208fc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  obj.internals.size_of_acq_buffer = allocated_buffer_size;
  obj.used_size_of_acq_buffer = required_size;
  
  if (max_num_of_adc_channels > MAX_SUPPORTED_RX_SIGNALS_INT)
  {
    obj.status = num_of_RX_not_supported;
 8020900:	2305      	movs	r3, #5
    obj.p_acq_buf = NULL;
 8020902:	62c6      	str	r6, [r0, #44]	; 0x2c
    obj.internals.size_of_acq_buffer = 0;
 8020904:	60c6      	str	r6, [r0, #12]
    obj.used_size_of_acq_buffer = 0;
 8020906:	6206      	str	r6, [r0, #32]
  obj.internals.size_of_acq_buffer = allocated_buffer_size;
  obj.used_size_of_acq_buffer = required_size;
  
  if (max_num_of_adc_channels > MAX_SUPPORTED_RX_SIGNALS_INT)
  {
    obj.status = num_of_RX_not_supported;
 8020908:	f880 3030 	strb.w	r3, [r0, #48]	; 0x30
    obj.p_acq_buf = NULL;
    obj.internals.size_of_acq_buffer = 0;
    obj.used_size_of_acq_buffer = 0;
    return obj;
 802090c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    return obj;
  }
  
  if (((obj.p_acq_buf != NULL) && (obj.internals.size_of_acq_buffer != 0)) && obj.internals.size_of_acq_buffer < required_size)
  {
    obj.status = allocation_buffer_too_small;
 8020910:	2303      	movs	r3, #3
    obj.p_acq_buf = NULL;
 8020912:	62c6      	str	r6, [r0, #44]	; 0x2c
    obj.internals.size_of_acq_buffer = 0;
 8020914:	60c6      	str	r6, [r0, #12]
    obj.used_size_of_acq_buffer = 0;
 8020916:	6206      	str	r6, [r0, #32]
    return obj;
  }
  
  if (((obj.p_acq_buf != NULL) && (obj.internals.size_of_acq_buffer != 0)) && obj.internals.size_of_acq_buffer < required_size)
  {
    obj.status = allocation_buffer_too_small;
 8020918:	f880 3030 	strb.w	r3, [r0, #48]	; 0x30
    obj.p_acq_buf = NULL;
    obj.internals.size_of_acq_buffer = 0;
    obj.used_size_of_acq_buffer = 0;
    return obj;
 802091c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    }
  }
#endif
  
  // calculated internal buffer offsets
  obj.internals.channel_inc = obj.params.num_of_samples_per_chirp * obj.params.size_of_value_in_bytes;
 8020920:	fb0c f404 	mul.w	r4, ip, r4
  obj.internals.chirp_inc   = obj.internals.channel_inc * obj.params.num_of_rx_values;
 8020924:	fb0e f304 	mul.w	r3, lr, r4
 8020928:	6103      	str	r3, [r0, #16]
    }
  }
#endif
  
  // calculated internal buffer offsets
  obj.internals.channel_inc = obj.params.num_of_samples_per_chirp * obj.params.size_of_value_in_bytes;
 802092a:	6144      	str	r4, [r0, #20]
  {
    memset(obj.p_acq_buf, 0, sizeof(obj.used_size_of_acq_buffer));
  }
  
  return obj;
}
 802092c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08020930 <delete_acq_buffer_obj>:

//============================================================================

void delete_acq_buffer_obj(acq_buf_obj *p_obj)
{
  p_obj->status = allocation_is_freed;
 8020930:	2206      	movs	r2, #6
  p_obj->used_size_of_acq_buffer = 0;
 8020932:	2300      	movs	r3, #0

//============================================================================

void delete_acq_buffer_obj(acq_buf_obj *p_obj)
{
  p_obj->status = allocation_is_freed;
 8020934:	f880 2030 	strb.w	r2, [r0, #48]	; 0x30
  p_obj->used_size_of_acq_buffer = 0;
 8020938:	6203      	str	r3, [r0, #32]
 802093a:	4770      	bx	lr

0802093c <radar_open_device>:
}

//============================================================================

uint16_t radar_open_device(int32_t device_number, Radar_Handle_t* device)
{
 802093c:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint16_t retval = RADAR_ERR_OK;
  int32_t status = 0;
  acq_buf_obj acq_buf = { .status = not_initialized } ;

  /* Initialize the driver instance with NULL, until it was successfully initialized */
  if (device)
 802093e:	460c      	mov	r4, r1
}

//============================================================================

uint16_t radar_open_device(int32_t device_number, Radar_Handle_t* device)
{
 8020940:	b09d      	sub	sp, #116	; 0x74
  uint16_t retval = RADAR_ERR_OK;
  int32_t status = 0;
  acq_buf_obj acq_buf = { .status = not_initialized } ;

  /* Initialize the driver instance with NULL, until it was successfully initialized */
  if (device)
 8020942:	b109      	cbz	r1, 8020948 <radar_open_device+0xc>
	  (*device = NULL);
 8020944:	2300      	movs	r3, #0
 8020946:	600b      	str	r3, [r1, #0]

  /* Initialize driver data structure */
  /* -------------------------------- */
  status = ds_init();
 8020948:	f7ff fc16 	bl	8020178 <ds_init>
  if (status > 0)
 802094c:	2800      	cmp	r0, #0
  {
    return (RADAR_ERR_INIT_ERROR);
 802094e:	bfc8      	it	gt
 8020950:	f44f 7080 	movgt.w	r0, #256	; 0x100
	  (*device = NULL);

  /* Initialize driver data structure */
  /* -------------------------------- */
  status = ds_init();
  if (status > 0)
 8020954:	dd01      	ble.n	802095a <radar_open_device+0x1e>
  retval = radar_init(device);
  
  g_adc_sampling_completed = false;

  return (retval);
}
 8020956:	b01d      	add	sp, #116	; 0x74
 8020958:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if (status > 0)
  {
    return (RADAR_ERR_INIT_ERROR);
  }

  device_settings_t *pDev = ds_device_get_settings();
 802095a:	f7ff fbcf 	bl	80200fc <ds_device_get_settings>
 802095e:	4605      	mov	r5, r0
  
  //========================================================================
  //------------------------- Frame Format configurations ------------------
  //========================================================================
  ds_ep_fetch_frame_format(&frame_format);
 8020960:	a80b      	add	r0, sp, #44	; 0x2c
 8020962:	f7ff ff15 	bl	8020790 <ds_ep_fetch_frame_format>


  //=========================================================================
  //------------------------- General configurations ------------------------
  //=========================================================================
  radar_set_data_acq_mode(RADAR_MANUAL_TRIGGER_MODE);
 8020966:	2000      	movs	r0, #0
 8020968:	f000 f92e 	bl	8020bc8 <radar_set_data_acq_mode>
  
  /* If the frame format contains a 0, this makes no sense. */
  if ((frame_format.rx_mask == 0) ||
 802096c:	f89d 3034 	ldrb.w	r3, [sp, #52]	; 0x34
 8020970:	b90b      	cbnz	r3, 8020976 <radar_open_device+0x3a>
          (frame_format.num_chirps_per_frame  > BSP_MAX_NUM_CHIRPS_PER_FRAME) ||
            (frame_format.num_samples_per_chirp > BSP_MAX_NUM_SAMPLES_PER_CHIRP) ||
			(frame_format.num_samples_per_chirp < BSP_MIN_NUM_SAMPLES_PER_CHIRP)
			)
  {
    return (RADAR_ERR_UNSUPPORTED_FRAME_FORMAT);
 8020972:	2008      	movs	r0, #8
 8020974:	e7ef      	b.n	8020956 <radar_open_device+0x1a>
  //=========================================================================
  radar_set_data_acq_mode(RADAR_MANUAL_TRIGGER_MODE);
  
  /* If the frame format contains a 0, this makes no sense. */
  if ((frame_format.rx_mask == 0) ||
      (frame_format.num_chirps_per_frame  == 0) ||
 8020976:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  //------------------------- General configurations ------------------------
  //=========================================================================
  radar_set_data_acq_mode(RADAR_MANUAL_TRIGGER_MODE);
  
  /* If the frame format contains a 0, this makes no sense. */
  if ((frame_format.rx_mask == 0) ||
 8020978:	2b00      	cmp	r3, #0
 802097a:	d0fa      	beq.n	8020972 <radar_open_device+0x36>
      (frame_format.num_chirps_per_frame  == 0) ||
        (frame_format.num_samples_per_chirp == 0) ||
 802097c:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
  //=========================================================================
  radar_set_data_acq_mode(RADAR_MANUAL_TRIGGER_MODE);
  
  /* If the frame format contains a 0, this makes no sense. */
  if ((frame_format.rx_mask == 0) ||
      (frame_format.num_chirps_per_frame  == 0) ||
 802097e:	f1a6 0220 	sub.w	r2, r6, #32
 8020982:	2ae0      	cmp	r2, #224	; 0xe0
 8020984:	d8f5      	bhi.n	8020972 <radar_open_device+0x36>
        (frame_format.num_samples_per_chirp == 0) ||
 8020986:	2b01      	cmp	r3, #1
 8020988:	d8f3      	bhi.n	8020972 <radar_open_device+0x36>
  }
  
  /* Check frame memory limits */
  /* ------------------------- */
  frame_size = frame_format.num_chirps_per_frame * frame_format.num_samples_per_chirp *
    ds_ep_get_device_info()->num_rx_antennas * 2U * sizeof(uint16_t); // complex IQ samples per antenna
 802098a:	f7ff fefd 	bl	8020788 <ds_ep_get_device_info>
    return (RADAR_ERR_UNSUPPORTED_FRAME_FORMAT);
  }
  
  /* Check frame memory limits */
  /* ------------------------- */
  frame_size = frame_format.num_chirps_per_frame * frame_format.num_samples_per_chirp *
 802098e:	7b43      	ldrb	r3, [r0, #13]
 8020990:	4a17      	ldr	r2, [pc, #92]	; (80209f0 <radar_open_device+0xb4>)
 8020992:	00b6      	lsls	r6, r6, #2
    ds_ep_get_device_info()->num_rx_antennas * 2U * sizeof(uint16_t); // complex IQ samples per antenna
 8020994:	fb03 f606 	mul.w	r6, r3, r6
  
  if (frame_size > BSP_MAX_ADC_BUFFER_SIZE_BYTES)
 8020998:	f5b6 5f80 	cmp.w	r6, #4096	; 0x1000
    return (RADAR_ERR_UNSUPPORTED_FRAME_FORMAT);
  }
  
  /* Check frame memory limits */
  /* ------------------------- */
  frame_size = frame_format.num_chirps_per_frame * frame_format.num_samples_per_chirp *
 802099c:	6016      	str	r6, [r2, #0]
    ds_ep_get_device_info()->num_rx_antennas * 2U * sizeof(uint16_t); // complex IQ samples per antenna
  
  if (frame_size > BSP_MAX_ADC_BUFFER_SIZE_BYTES)
 802099e:	d8e8      	bhi.n	8020972 <radar_open_device+0x36>
    return (RADAR_ERR_UNSUPPORTED_FRAME_FORMAT);
  }
  
  /* Initialize sensor hardware */
  /* -------------------------- */
  acq_buf = create_acq_data_buffer_obj((uint8_t*) data_fifo, BSP_MAX_ADC_BUFFER_SIZE_BYTES,
 80209a0:	f8bd 302c 	ldrh.w	r3, [sp, #44]	; 0x2c
 80209a4:	9300      	str	r3, [sp, #0]
 80209a6:	2304      	movs	r3, #4
 80209a8:	9301      	str	r3, [sp, #4]
 80209aa:	7e2b      	ldrb	r3, [r5, #24]
 80209ac:	9302      	str	r3, [sp, #8]
 80209ae:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 80209b0:	f8bd 3030 	ldrh.w	r3, [sp, #48]	; 0x30
 80209b4:	9203      	str	r2, [sp, #12]
 80209b6:	af0e      	add	r7, sp, #56	; 0x38
 80209b8:	4638      	mov	r0, r7
 80209ba:	490e      	ldr	r1, [pc, #56]	; (80209f4 <radar_open_device+0xb8>)
 80209bc:	f44f 5280 	mov.w	r2, #4096	; 0x1000
                                       frame_format.num_chirps_per_frame,
                                       frame_format.num_samples_per_chirp, BSP_MAX_NUM_ADC_CHANNELS, pDev->adc_resolution, pDev->num_sample_skip_count);
  
  ds_set_active_acq_buf(acq_buf);
 80209c0:	ae12      	add	r6, sp, #72	; 0x48
    return (RADAR_ERR_UNSUPPORTED_FRAME_FORMAT);
  }
  
  /* Initialize sensor hardware */
  /* -------------------------- */
  acq_buf = create_acq_data_buffer_obj((uint8_t*) data_fifo, BSP_MAX_ADC_BUFFER_SIZE_BYTES,
 80209c2:	f7ff ff57 	bl	8020874 <create_acq_data_buffer_obj>
                                       frame_format.num_chirps_per_frame,
                                       frame_format.num_samples_per_chirp, BSP_MAX_NUM_ADC_CHANNELS, pDev->adc_resolution, pDev->num_sample_skip_count);
  
  ds_set_active_acq_buf(acq_buf);
 80209c6:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 80209c8:	466d      	mov	r5, sp
 80209ca:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 80209cc:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 80209ce:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 80209d0:	e896 0003 	ldmia.w	r6, {r0, r1}
 80209d4:	e885 0003 	stmia.w	r5, {r0, r1}
 80209d8:	e897 000f 	ldmia.w	r7, {r0, r1, r2, r3}
 80209dc:	f7ff fd90 	bl	8020500 <ds_set_active_acq_buf>
 
  
  /* BGT, DMA, Timers initialization */
  /* -------------------------------------------------- */
  retval = radar_init(device);
 80209e0:	4620      	mov	r0, r4
 80209e2:	f000 f87d 	bl	8020ae0 <radar_init>
  
  g_adc_sampling_completed = false;
 80209e6:	4b04      	ldr	r3, [pc, #16]	; (80209f8 <radar_open_device+0xbc>)
 80209e8:	2200      	movs	r2, #0
 80209ea:	601a      	str	r2, [r3, #0]

  return (retval);
 80209ec:	e7b3      	b.n	8020956 <radar_open_device+0x1a>
 80209ee:	bf00      	nop
 80209f0:	1ffe9764 	.word	0x1ffe9764
 80209f4:	1ffef044 	.word	0x1ffef044
 80209f8:	1ffe976c 	.word	0x1ffe976c
 80209fc:	00000000 	.word	0x00000000

08020a00 <radar_set_automatic_frame_trigger>:
}

//============================================================================

uint16_t radar_set_automatic_frame_trigger(Radar_Handle_t device, uint32_t frame_interval_usec)
{
 8020a00:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  /* Stop trigger timer first  */
  /* ------------------------- */
  bsp_timer_stop_clear(&TIMER_FRAME_TRIG);
 8020a04:	4834      	ldr	r0, [pc, #208]	; (8020ad8 <radar_set_automatic_frame_trigger+0xd8>)
}

//============================================================================

uint16_t radar_set_automatic_frame_trigger(Radar_Handle_t device, uint32_t frame_interval_usec)
{
 8020a06:	460c      	mov	r4, r1
  /* Stop trigger timer first  */
  /* ------------------------- */
  bsp_timer_stop_clear(&TIMER_FRAME_TRIG);
 8020a08:	f008 ff14 	bl	8029834 <bsp_timer_stop_clear>

  radar_set_data_acq_mode(RADAR_MANUAL_TRIGGER_MODE);
 8020a0c:	2000      	movs	r0, #0
 8020a0e:	f000 f8db 	bl	8020bc8 <radar_set_data_acq_mode>

  /* Restart trigger timer */
  /* --------------------- */
  if (frame_interval_usec > 0)
 8020a12:	b914      	cbnz	r4, 8020a1a <radar_set_automatic_frame_trigger+0x1a>

      bsp_timer_start(&TIMER_FRAME_TRIG);
    }
  }

  return (RADAR_ERR_OK);
 8020a14:	2000      	movs	r0, #0
 8020a16:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

uint16_t radar_get_min_frame_interval(Radar_Handle_t device, uint32_t* min_frame_interval_usec)
{
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */

  device_settings_t *p_dev = ds_device_get_settings();
 8020a1a:	f7ff fb6f 	bl	80200fc <ds_device_get_settings>

  *min_frame_interval_usec = bsp_calc_min_frame_interval_usec(p_dev);
 8020a1e:	f009 fb4b 	bl	802a0b8 <bsp_calc_min_frame_interval_usec>
  {
    uint32_t min_frame_interval_usec;

    radar_get_min_frame_interval(device, &min_frame_interval_usec);

    if (frame_interval_usec < min_frame_interval_usec)
 8020a22:	4284      	cmp	r4, r0
{
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */

  device_settings_t *p_dev = ds_device_get_settings();

  *min_frame_interval_usec = bsp_calc_min_frame_interval_usec(p_dev);
 8020a24:	4605      	mov	r5, r0
  {
    uint32_t min_frame_interval_usec;

    radar_get_min_frame_interval(device, &min_frame_interval_usec);

    if (frame_interval_usec < min_frame_interval_usec)
 8020a26:	d202      	bcs.n	8020a2e <radar_set_automatic_frame_trigger+0x2e>

      bsp_timer_start(&TIMER_FRAME_TRIG);
    }
  }

  return (RADAR_ERR_OK);
 8020a28:	2005      	movs	r0, #5
 8020a2a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    if (frame_interval_usec < min_frame_interval_usec)
    {
      return (RADAR_ERR_UNSUPPORTED_FRAME_INTERVAL);
    }

    device_settings_t *pDev = ds_device_get_settings();
 8020a2e:	f7ff fb65 	bl	80200fc <ds_device_get_settings>

    pDev->frame_period_usec = frame_interval_usec;
 8020a32:	6204      	str	r4, [r0, #32]
    if (frame_interval_usec < min_frame_interval_usec)
    {
      return (RADAR_ERR_UNSUPPORTED_FRAME_INTERVAL);
    }

    device_settings_t *pDev = ds_device_get_settings();
 8020a34:	4606      	mov	r6, r0

    pDev->frame_period_usec = frame_interval_usec;

    /* Reset the current frame counter */
    bsp_reset_frame_counter();
 8020a36:	f009 fb19 	bl	802a06c <bsp_reset_frame_counter>

    g_adc_sampling_completed = false;

    /* Get data in continuous mode */
    if ((abs(frame_interval_usec - min_frame_interval_usec) < GUARD_FRAME_TIME_USEC))
 8020a3a:	1b63      	subs	r3, r4, r5
 8020a3c:	2b00      	cmp	r3, #0
    pDev->frame_period_usec = frame_interval_usec;

    /* Reset the current frame counter */
    bsp_reset_frame_counter();

    g_adc_sampling_completed = false;
 8020a3e:	4a27      	ldr	r2, [pc, #156]	; (8020adc <radar_set_automatic_frame_trigger+0xdc>)

    /* Get data in continuous mode */
    if ((abs(frame_interval_usec - min_frame_interval_usec) < GUARD_FRAME_TIME_USEC))
 8020a40:	bfb8      	it	lt
 8020a42:	425b      	neglt	r3, r3
    pDev->frame_period_usec = frame_interval_usec;

    /* Reset the current frame counter */
    bsp_reset_frame_counter();

    g_adc_sampling_completed = false;
 8020a44:	2700      	movs	r7, #0

    /* Get data in continuous mode */
    if ((abs(frame_interval_usec - min_frame_interval_usec) < GUARD_FRAME_TIME_USEC))
 8020a46:	f5b3 7ffa 	cmp.w	r3, #500	; 0x1f4
    pDev->frame_period_usec = frame_interval_usec;

    /* Reset the current frame counter */
    bsp_reset_frame_counter();

    g_adc_sampling_completed = false;
 8020a4a:	6017      	str	r7, [r2, #0]

    /* Get data in continuous mode */
    if ((abs(frame_interval_usec - min_frame_interval_usec) < GUARD_FRAME_TIME_USEC))
 8020a4c:	db2e      	blt.n	8020aac <radar_set_automatic_frame_trigger+0xac>
      /* Start data acquisition */
      bsp_trigger_new_frame();
    }
    else
    {
      radar_set_data_acq_mode(RADAR_AUTO_TRIGGER_MODE);
 8020a4e:	2001      	movs	r0, #1
 8020a50:	f000 f8ba 	bl	8020bc8 <radar_set_data_acq_mode>
      pDev->frame_period_usec = frame_interval_usec;

      uint32_t temp_ptat_switch = pDev->ptat_is_switched;
      uint32_t temp_ptat_delay_usec = pDev->ptat_delay_usec;
 8020a54:	f8d6 803c 	ldr.w	r8, [r6, #60]	; 0x3c
      bsp_trigger_new_frame();
    }
    else
    {
      radar_set_data_acq_mode(RADAR_AUTO_TRIGGER_MODE);
      pDev->frame_period_usec = frame_interval_usec;
 8020a58:	6234      	str	r4, [r6, #32]

      uint32_t temp_ptat_switch = pDev->ptat_is_switched;
      uint32_t temp_ptat_delay_usec = pDev->ptat_delay_usec;

      if (frame_interval_usec < min_frame_interval_usec + 2 * pDev->ptat_delay_usec)
 8020a5a:	eb05 0548 	add.w	r5, r5, r8, lsl #1
 8020a5e:	42ac      	cmp	r4, r5
    else
    {
      radar_set_data_acq_mode(RADAR_AUTO_TRIGGER_MODE);
      pDev->frame_period_usec = frame_interval_usec;

      uint32_t temp_ptat_switch = pDev->ptat_is_switched;
 8020a60:	f8d6 9038 	ldr.w	r9, [r6, #56]	; 0x38
      uint32_t temp_ptat_delay_usec = pDev->ptat_delay_usec;

      if (frame_interval_usec < min_frame_interval_usec + 2 * pDev->ptat_delay_usec)
 8020a64:	d32e      	bcc.n	8020ac4 <radar_set_automatic_frame_trigger+0xc4>
        temp_ptat_switch = 0;
      else
      {
        float sample_interval_usec = 1000000.0 / pDev->adc_sampling_freq_Hz;
 8020a66:	6970      	ldr	r0, [r6, #20]
 8020a68:	f00b ff08 	bl	802c87c <__aeabi_ui2d>
 8020a6c:	4602      	mov	r2, r0
 8020a6e:	460b      	mov	r3, r1
 8020a70:	a117      	add	r1, pc, #92	; (adr r1, 8020ad0 <radar_set_automatic_frame_trigger+0xd0>)
 8020a72:	e9d1 0100 	ldrd	r0, r1, [r1]
 8020a76:	f00c f8a1 	bl	802cbbc <__aeabi_ddiv>
 8020a7a:	f00c fa2f 	bl	802cedc <__aeabi_d2f>
        if (pDev->ptat_delay_usec > (uint32_t)sample_interval_usec)
 8020a7e:	ee07 0a90 	vmov	s15, r0
 8020a82:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8020a86:	ee17 0a90 	vmov	r0, s15
 8020a8a:	4580      	cmp	r8, r0
 8020a8c:	d91c      	bls.n	8020ac8 <radar_set_automatic_frame_trigger+0xc8>
          temp_ptat_delay_usec = pDev->ptat_delay_usec - (uint32_t)sample_interval_usec;
 8020a8e:	ebc0 0808 	rsb	r8, r0, r8
        else
          temp_ptat_delay_usec = 0;
      }

      /* Update time period of Automatic Trigger */
      if (!bsp_start_frame_intervall_timer(frame_interval_usec))
 8020a92:	4620      	mov	r0, r4
 8020a94:	f009 fb02 	bl	802a09c <bsp_start_frame_intervall_timer>
 8020a98:	2800      	cmp	r0, #0
 8020a9a:	d0c5      	beq.n	8020a28 <radar_set_automatic_frame_trigger+0x28>
      {
        return (RADAR_ERR_UNSUPPORTED_FRAME_INTERVAL);
      }

      bsp_set_ptat_switch_status(temp_ptat_switch, temp_ptat_delay_usec);
 8020a9c:	4648      	mov	r0, r9
 8020a9e:	4641      	mov	r1, r8
 8020aa0:	f009 fb1c 	bl	802a0dc <bsp_set_ptat_switch_status>

      bsp_timer_start(&TIMER_FRAME_TRIG);
 8020aa4:	480c      	ldr	r0, [pc, #48]	; (8020ad8 <radar_set_automatic_frame_trigger+0xd8>)
 8020aa6:	f008 fed1 	bl	802984c <bsp_timer_start>
 8020aaa:	e7b3      	b.n	8020a14 <radar_set_automatic_frame_trigger+0x14>

    /* Get data in continuous mode */
    if ((abs(frame_interval_usec - min_frame_interval_usec) < GUARD_FRAME_TIME_USEC))
    {
      /* Set continuous mode */
      radar_set_data_acq_mode(RADAR_DATA_CONTINUOUS_MODE);
 8020aac:	2002      	movs	r0, #2
 8020aae:	f000 f88b 	bl	8020bc8 <radar_set_data_acq_mode>

      bsp_set_ptat_switch_status(0, 0);
 8020ab2:	4638      	mov	r0, r7
 8020ab4:	4639      	mov	r1, r7
 8020ab6:	f009 fb11 	bl	802a0dc <bsp_set_ptat_switch_status>

      /* Start data acquisition */
      bsp_trigger_new_frame();
 8020aba:	f008 ff5b 	bl	8029974 <bsp_trigger_new_frame>

      bsp_timer_start(&TIMER_FRAME_TRIG);
    }
  }

  return (RADAR_ERR_OK);
 8020abe:	4638      	mov	r0, r7
 8020ac0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

      uint32_t temp_ptat_switch = pDev->ptat_is_switched;
      uint32_t temp_ptat_delay_usec = pDev->ptat_delay_usec;

      if (frame_interval_usec < min_frame_interval_usec + 2 * pDev->ptat_delay_usec)
        temp_ptat_switch = 0;
 8020ac4:	46b9      	mov	r9, r7
 8020ac6:	e7e4      	b.n	8020a92 <radar_set_automatic_frame_trigger+0x92>
      {
        float sample_interval_usec = 1000000.0 / pDev->adc_sampling_freq_Hz;
        if (pDev->ptat_delay_usec > (uint32_t)sample_interval_usec)
          temp_ptat_delay_usec = pDev->ptat_delay_usec - (uint32_t)sample_interval_usec;
        else
          temp_ptat_delay_usec = 0;
 8020ac8:	46b8      	mov	r8, r7
 8020aca:	e7e2      	b.n	8020a92 <radar_set_automatic_frame_trigger+0x92>
 8020acc:	f3af 8000 	nop.w
 8020ad0:	00000000 	.word	0x00000000
 8020ad4:	412e8480 	.word	0x412e8480
 8020ad8:	1ffe9210 	.word	0x1ffe9210
 8020adc:	1ffe976c 	.word	0x1ffe976c

08020ae0 <radar_init>:
    6. EXPORTED FUNCTIONS
==============================================================================
 */

uint16_t radar_init(Radar_Handle_t device)
{
 8020ae0:	b510      	push	{r4, lr}
  uint16_t status = RADAR_ERR_OK;

  device_settings_t *p_Dev = ds_device_get_settings();
 8020ae2:	f7ff fb0b 	bl	80200fc <ds_device_get_settings>
 8020ae6:	4604      	mov	r4, r0
  
  /* USB and DMA Setup */
  acq_buf_obj *p_acq_buf = ds_get_active_acq_buf();
 8020ae8:	f7ff fd06 	bl	80204f8 <ds_get_active_acq_buf>

  bsp_dma_set_adc_control_from_acq_buf_obj(p_acq_buf);
 8020aec:	f008 feb0 	bl	8029850 <bsp_dma_set_adc_control_from_acq_buf_obj>
  
  status |= (uint16_t) bsp_init(p_Dev);
 8020af0:	4620      	mov	r0, r4
 8020af2:	f008 fde9 	bl	80296c8 <bsp_init>
  
  status |= radar_set_sampling_freq(device, p_Dev->pll_modulation_mode, p_Dev->adc_sampling_freq_Hz);
 8020af6:	edd4 7a05 	vldr	s15, [r4, #20]
  XMC_UNUSED_ARG(modulation_type);
  XMC_UNUSED_ARG(freq_hz);

  //FIXME: Add settings freq here

  if (((uint32_t)freq_hz <= 0) || ((uint32_t)freq_hz > BSP_MAX_ADC_FREQ_HZ))
 8020afa:	4a07      	ldr	r2, [pc, #28]	; (8020b18 <radar_init+0x38>)

  bsp_dma_set_adc_control_from_acq_buf_obj(p_acq_buf);
  
  status |= (uint16_t) bsp_init(p_Dev);
  
  status |= radar_set_sampling_freq(device, p_Dev->pll_modulation_mode, p_Dev->adc_sampling_freq_Hz);
 8020afc:	eef8 7a67 	vcvt.f32.u32	s15, s15
  /* USB and DMA Setup */
  acq_buf_obj *p_acq_buf = ds_get_active_acq_buf();

  bsp_dma_set_adc_control_from_acq_buf_obj(p_acq_buf);
  
  status |= (uint16_t) bsp_init(p_Dev);
 8020b00:	b280      	uxth	r0, r0
  XMC_UNUSED_ARG(modulation_type);
  XMC_UNUSED_ARG(freq_hz);

  //FIXME: Add settings freq here

  if (((uint32_t)freq_hz <= 0) || ((uint32_t)freq_hz > BSP_MAX_ADC_FREQ_HZ))
 8020b02:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8020b06:	ee17 3a90 	vmov	r3, s15
 8020b0a:	3b01      	subs	r3, #1
  {
    return RADAR_ERR_BUSY;
  }

  return (RADAR_ERR_OK);
 8020b0c:	4293      	cmp	r3, r2
 8020b0e:	bf8c      	ite	hi
 8020b10:	2302      	movhi	r3, #2
 8020b12:	2300      	movls	r3, #0
  status |= (uint16_t) bsp_init(p_Dev);
  
  status |= radar_set_sampling_freq(device, p_Dev->pll_modulation_mode, p_Dev->adc_sampling_freq_Hz);
  
  return (status);
}
 8020b14:	4318      	orrs	r0, r3
 8020b16:	bd10      	pop	{r4, pc}
 8020b18:	0016e35f 	.word	0x0016e35f

08020b1c <radar_start_acquisition>:

//============================================================================

uint16_t radar_start_acquisition(Radar_Handle_t device)
{
 8020b1c:	b510      	push	{r4, lr}
 8020b1e:	4604      	mov	r4, r0
  uint16_t status = RADAR_ERR_BUSY;
  
  if (ds_device_get_settings()->frame_period_usec > 0)
 8020b20:	f7ff faec 	bl	80200fc <ds_device_get_settings>
 8020b24:	6a03      	ldr	r3, [r0, #32]
 8020b26:	b90b      	cbnz	r3, 8020b2c <radar_start_acquisition+0x10>
  {
    status = radar_set_automatic_frame_trigger(device, ds_device_get_settings()->frame_period_usec);
  }
  return (status);
}
 8020b28:	2002      	movs	r0, #2
 8020b2a:	bd10      	pop	{r4, pc}
{
  uint16_t status = RADAR_ERR_BUSY;
  
  if (ds_device_get_settings()->frame_period_usec > 0)
  {
    status = radar_set_automatic_frame_trigger(device, ds_device_get_settings()->frame_period_usec);
 8020b2c:	f7ff fae6 	bl	80200fc <ds_device_get_settings>
 8020b30:	6a01      	ldr	r1, [r0, #32]
 8020b32:	4620      	mov	r0, r4
  }
  return (status);
}
 8020b34:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
{
  uint16_t status = RADAR_ERR_BUSY;
  
  if (ds_device_get_settings()->frame_period_usec > 0)
  {
    status = radar_set_automatic_frame_trigger(device, ds_device_get_settings()->frame_period_usec);
 8020b38:	f7ff bf62 	b.w	8020a00 <radar_set_automatic_frame_trigger>

08020b3c <radar_register_callback>:
uint16_t radar_register_callback(Radar_Callback_ID_t cb_id, void (*pcallback)(void *parameter))
{
  uint16_t status = RADAR_ERR_OK;

  /* Check if the callback function is valid */
  if (pcallback == NULL)
 8020b3c:	b151      	cbz	r1, 8020b54 <radar_register_callback+0x18>
  {
    return (RADAR_ERR_BUSY);
  }

  /* Register user callback function based on callback ID */
  switch (cb_id)
 8020b3e:	2801      	cmp	r0, #1
}

//============================================================================

uint16_t radar_register_callback(Radar_Callback_ID_t cb_id, void (*pcallback)(void *parameter))
{
 8020b40:	b508      	push	{r3, lr}
  {
    return (RADAR_ERR_BUSY);
  }

  /* Register user callback function based on callback ID */
  switch (cb_id)
 8020b42:	d003      	beq.n	8020b4c <radar_register_callback+0x10>
 8020b44:	2802      	cmp	r0, #2
 8020b46:	d001      	beq.n	8020b4c <radar_register_callback+0x10>
    bsp_register_callback(BSP_ACQUISITION_DONE_CB_ID, pcallback);
    break;

  default:
    /* Return error status */
    status = RADAR_ERR_BUSY;
 8020b48:	2002      	movs	r0, #2
    break;
  }

  return (status);
}
 8020b4a:	bd08      	pop	{r3, pc}
    bsp_register_callback(BSP_ACQUISITION_STARTED_CB_ID, pcallback);
    break;

  case RADAR_ACQUISITION_DONE_CB_ID:
    /* Callback executed by BSP layer at the end of data acquisition process */
    bsp_register_callback(BSP_ACQUISITION_DONE_CB_ID, pcallback);
 8020b4c:	f009 fa94 	bl	802a078 <bsp_register_callback>

//============================================================================

uint16_t radar_register_callback(Radar_Callback_ID_t cb_id, void (*pcallback)(void *parameter))
{
  uint16_t status = RADAR_ERR_OK;
 8020b50:	2000      	movs	r0, #0
    break;

  case RADAR_ACQUISITION_DONE_CB_ID:
    /* Callback executed by BSP layer at the end of data acquisition process */
    bsp_register_callback(BSP_ACQUISITION_DONE_CB_ID, pcallback);
    break;
 8020b52:	bd08      	pop	{r3, pc}
  uint16_t status = RADAR_ERR_OK;

  /* Check if the callback function is valid */
  if (pcallback == NULL)
  {
    return (RADAR_ERR_BUSY);
 8020b54:	2002      	movs	r0, #2
    status = RADAR_ERR_BUSY;
    break;
  }

  return (status);
}
 8020b56:	4770      	bx	lr

08020b58 <radar_apply_hw_settings>:
}

//============================================================================

uint32_t radar_apply_hw_settings(Radar_Handle_t device, device_settings_t *p_hw_settings)
{
 8020b58:	b5f0      	push	{r4, r5, r6, r7, lr}
 8020b5a:	460c      	mov	r4, r1
 8020b5c:	b099      	sub	sp, #100	; 0x64

uint16_t radar_stop_acquisition(Radar_Handle_t device)
{
  uint16_t status = RADAR_ERR_BUSY;
  
  status = radar_set_automatic_frame_trigger(device , 0);
 8020b5e:	2100      	movs	r1, #0
 8020b60:	f7ff ff4e 	bl	8020a00 <radar_set_automatic_frame_trigger>
{
  uint32_t retval = RADAR_ERR_OK;

  radar_stop_acquisition(device);

  bsp_bgt_shut_down();
 8020b64:	f008 fe60 	bl	8029828 <bsp_bgt_shut_down>

  if (bsp_update(p_new) != 0)
 8020b68:	4620      	mov	r0, r4
 8020b6a:	f008 fb9d 	bl	80292a8 <bsp_update>
 8020b6e:	2800      	cmp	r0, #0
  {
	  // invalid settings values not changed!
	  retval = RADAR_ERR_PARAMETER_OUT_OF_RANGE;
 8020b70:	bf0c      	ite	eq
 8020b72:	2700      	moveq	r7, #0
 8020b74:	270c      	movne	r7, #12
  }

  /* recreate acq-buffer object! */
  /* the buffer is statically allocated to the max supported buffer size, so it is save to re-use it!
   * checks should have been applied earlier! */
  acq_buf_obj *p_acq_buf = ds_get_active_acq_buf();
 8020b76:	f7ff fcbf 	bl	80204f8 <ds_get_active_acq_buf>

  uint8_t *p_temp_buf = p_acq_buf->p_acq_buf;
  uint32_t reserved_size = p_acq_buf->internals.size_of_acq_buffer;


  acq_buf_obj acq_buf = create_acq_data_buffer_obj(p_temp_buf, reserved_size,
 8020b7a:	8ca6      	ldrh	r6, [r4, #36]	; 0x24
 8020b7c:	8ba3      	ldrh	r3, [r4, #28]
 8020b7e:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
 8020b80:	68c2      	ldr	r2, [r0, #12]
 8020b82:	7e25      	ldrb	r5, [r4, #24]
 8020b84:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8020b86:	9600      	str	r6, [sp, #0]
 8020b88:	2404      	movs	r4, #4
 8020b8a:	ae0a      	add	r6, sp, #40	; 0x28
 8020b8c:	9502      	str	r5, [sp, #8]
 8020b8e:	9003      	str	r0, [sp, #12]
 8020b90:	9401      	str	r4, [sp, #4]
 8020b92:	4630      	mov	r0, r6
	  											   p_new->num_of_chirps_per_frame,
												   p_new->num_samples_per_chirp, BSP_MAX_NUM_ADC_CHANNELS, p_new->adc_resolution, p_new->num_sample_skip_count);

  ds_set_active_acq_buf(acq_buf);
 8020b94:	ad0e      	add	r5, sp, #56	; 0x38

  uint8_t *p_temp_buf = p_acq_buf->p_acq_buf;
  uint32_t reserved_size = p_acq_buf->internals.size_of_acq_buffer;


  acq_buf_obj acq_buf = create_acq_data_buffer_obj(p_temp_buf, reserved_size,
 8020b96:	f7ff fe6d 	bl	8020874 <create_acq_data_buffer_obj>
	  											   p_new->num_of_chirps_per_frame,
												   p_new->num_samples_per_chirp, BSP_MAX_NUM_ADC_CHANNELS, p_new->adc_resolution, p_new->num_sample_skip_count);

  ds_set_active_acq_buf(acq_buf);
 8020b9a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8020b9c:	466c      	mov	r4, sp
 8020b9e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8020ba0:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8020ba2:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8020ba4:	e895 0003 	ldmia.w	r5, {r0, r1}
 8020ba8:	e884 0003 	stmia.w	r4, {r0, r1}
 8020bac:	e896 000f 	ldmia.w	r6, {r0, r1, r2, r3}
 8020bb0:	f7ff fca6 	bl	8020500 <ds_set_active_acq_buf>
  uint32_t retval = RADAR_ERR_OK;

  retval = radar_apply_new_hw_setting(device, p_hw_settings);
  
  return retval;
}
 8020bb4:	4638      	mov	r0, r7
 8020bb6:	b019      	add	sp, #100	; 0x64
 8020bb8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8020bba:	bf00      	nop

08020bbc <radar_get_data_acq_mode>:

//============================================================================

Radar_Data_Acq_Mode_t radar_get_data_acq_mode(void)
{
  return s_data_acq_mode;
 8020bbc:	4b01      	ldr	r3, [pc, #4]	; (8020bc4 <radar_get_data_acq_mode+0x8>)
}
 8020bbe:	7818      	ldrb	r0, [r3, #0]
 8020bc0:	4770      	bx	lr
 8020bc2:	bf00      	nop
 8020bc4:	1ffe9768 	.word	0x1ffe9768

08020bc8 <radar_set_data_acq_mode>:

//============================================================================

void radar_set_data_acq_mode(Radar_Data_Acq_Mode_t new_mode)
{
  s_data_acq_mode = new_mode;
 8020bc8:	4b01      	ldr	r3, [pc, #4]	; (8020bd0 <radar_set_data_acq_mode+0x8>)
 8020bca:	7018      	strb	r0, [r3, #0]
 8020bcc:	4770      	bx	lr
 8020bce:	bf00      	nop
 8020bd0:	1ffe9768 	.word	0x1ffe9768

08020bd4 <device_status_get_handle>:
 */

Device_Status_t* device_status_get_handle()
{
	return &device_status;
}
 8020bd4:	4800      	ldr	r0, [pc, #0]	; (8020bd8 <device_status_get_handle+0x4>)
 8020bd6:	4770      	bx	lr
 8020bd8:	1ffe9770 	.word	0x1ffe9770

08020bdc <device_status_set_error>:
 */
/*Error prioritized, keep either first or last error*/
void device_status_set_error(Device_Error_t radar_error)
{
	uint8_t new_error_type =  FIND_TYPE_OF_ERROR(radar_error);
	uint8_t latest_error_type = FIND_TYPE_OF_ERROR(device_status.latest_error);
 8020bdc:	4a14      	ldr	r2, [pc, #80]	; (8020c30 <device_status_set_error+0x54>)
 8020bde:	6853      	ldr	r3, [r2, #4]

	/* only one message is stored: guard to not overwrite for example error through a status*/
	if (latest_error_type < new_error_type)
 8020be0:	f3c3 3103 	ubfx	r1, r3, #12, #4
 * @param radar_error
 */
/*Error prioritized, keep either first or last error*/
void device_status_set_error(Device_Error_t radar_error)
{
	uint8_t new_error_type =  FIND_TYPE_OF_ERROR(radar_error);
 8020be4:	f3c0 3303 	ubfx	r3, r0, #12, #4
	uint8_t latest_error_type = FIND_TYPE_OF_ERROR(device_status.latest_error);

	/* only one message is stored: guard to not overwrite for example error through a status*/
	if (latest_error_type < new_error_type)
 8020be8:	428b      	cmp	r3, r1
	{
		device_status.latest_error = radar_error;
	}

	switch(new_error_type)
 8020bea:	f103 33ff 	add.w	r3, r3, #4294967295
	uint8_t latest_error_type = FIND_TYPE_OF_ERROR(device_status.latest_error);

	/* only one message is stored: guard to not overwrite for example error through a status*/
	if (latest_error_type < new_error_type)
	{
		device_status.latest_error = radar_error;
 8020bee:	bf88      	it	hi
 8020bf0:	6050      	strhi	r0, [r2, #4]
	}

	switch(new_error_type)
 8020bf2:	2b03      	cmp	r3, #3
 8020bf4:	d808      	bhi.n	8020c08 <device_status_set_error+0x2c>
 8020bf6:	e8df f003 	tbb	[pc, r3]
 8020bfa:	0e14      	.short	0x0e14
 8020bfc:	0208      	.short	0x0208
		device_status.error_count++;
		break;

	case STATE_FATAL_ERROR:
		device_status.state = STATE_FATAL_ERROR;
		device_status.fatal_error_count++;
 8020bfe:	7ad3      	ldrb	r3, [r2, #11]
		device_status.state = STATE_ERROR;
		device_status.error_count++;
		break;

	case STATE_FATAL_ERROR:
		device_status.state = STATE_FATAL_ERROR;
 8020c00:	2104      	movs	r1, #4
		device_status.fatal_error_count++;
 8020c02:	3301      	adds	r3, #1
 8020c04:	72d3      	strb	r3, [r2, #11]
		device_status.state = STATE_ERROR;
		device_status.error_count++;
		break;

	case STATE_FATAL_ERROR:
		device_status.state = STATE_FATAL_ERROR;
 8020c06:	7011      	strb	r1, [r2, #0]
 8020c08:	4770      	bx	lr
		device_status.warning_count++;
		break;

	case STATE_ERROR:
		device_status.state = STATE_ERROR;
		device_status.error_count++;
 8020c0a:	7a93      	ldrb	r3, [r2, #10]
		device_status.state = STATE_WARNING;
		device_status.warning_count++;
		break;

	case STATE_ERROR:
		device_status.state = STATE_ERROR;
 8020c0c:	2103      	movs	r1, #3
		device_status.error_count++;
 8020c0e:	3301      	adds	r3, #1
 8020c10:	7293      	strb	r3, [r2, #10]
		device_status.state = STATE_WARNING;
		device_status.warning_count++;
		break;

	case STATE_ERROR:
		device_status.state = STATE_ERROR;
 8020c12:	7011      	strb	r1, [r2, #0]
		device_status.error_count++;
		break;
 8020c14:	4770      	bx	lr
		device_status.info_count++;
		break;

	case STATE_WARNING:
		device_status.state = STATE_WARNING;
		device_status.warning_count++;
 8020c16:	7a53      	ldrb	r3, [r2, #9]
		device_status.state = STATE_INFO;
		device_status.info_count++;
		break;

	case STATE_WARNING:
		device_status.state = STATE_WARNING;
 8020c18:	2102      	movs	r1, #2
		device_status.warning_count++;
 8020c1a:	3301      	adds	r3, #1
 8020c1c:	7253      	strb	r3, [r2, #9]
		device_status.state = STATE_INFO;
		device_status.info_count++;
		break;

	case STATE_WARNING:
		device_status.state = STATE_WARNING;
 8020c1e:	7011      	strb	r1, [r2, #0]
		device_status.warning_count++;
		break;
 8020c20:	4770      	bx	lr

	switch(new_error_type)
	{
	case STATE_INFO:
		device_status.state = STATE_INFO;
		device_status.info_count++;
 8020c22:	7a13      	ldrb	r3, [r2, #8]
	}

	switch(new_error_type)
	{
	case STATE_INFO:
		device_status.state = STATE_INFO;
 8020c24:	2101      	movs	r1, #1
		device_status.info_count++;
 8020c26:	440b      	add	r3, r1
 8020c28:	7213      	strb	r3, [r2, #8]
	}

	switch(new_error_type)
	{
	case STATE_INFO:
		device_status.state = STATE_INFO;
 8020c2a:	7011      	strb	r1, [r2, #0]
		device_status.info_count++;
		break;
 8020c2c:	4770      	bx	lr
 8020c2e:	bf00      	nop
 8020c30:	1ffe9770 	.word	0x1ffe9770

08020c34 <device_status_get_error_description>:
	 * in case of an error, we do not need to be efficient!
	 */
	uint32_t elems = sizeof(DEVICE_ERROR_DESCRIPTION_TABLE)/sizeof(DEVICE_ERROR_DESCRIPTION_TABLE[0]);
	for (uint32_t i = 0; i< elems; i++)
	{
		if (error == DEVICE_ERROR_DESCRIPTION_TABLE[i].code)
 8020c34:	4b0d      	ldr	r3, [pc, #52]	; (8020c6c <device_status_get_error_description+0x38>)
 8020c36:	681a      	ldr	r2, [r3, #0]
 8020c38:	4282      	cmp	r2, r0
 8020c3a:	d013      	beq.n	8020c64 <device_status_get_error_description+0x30>
 8020c3c:	68da      	ldr	r2, [r3, #12]
 8020c3e:	4282      	cmp	r2, r0
 8020c40:	d012      	beq.n	8020c68 <device_status_get_error_description+0x34>
 8020c42:	699a      	ldr	r2, [r3, #24]
 8020c44:	4282      	cmp	r2, r0
 8020c46:	d006      	beq.n	8020c56 <device_status_get_error_description+0x22>
 8020c48:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8020c4a:	4282      	cmp	r2, r0
{
	/*
	 * in case of an error, we do not need to be efficient!
	 */
	uint32_t elems = sizeof(DEVICE_ERROR_DESCRIPTION_TABLE)/sizeof(DEVICE_ERROR_DESCRIPTION_TABLE[0]);
	for (uint32_t i = 0; i< elems; i++)
 8020c4c:	bf08      	it	eq
 8020c4e:	2203      	moveq	r2, #3
	{
		if (error == DEVICE_ERROR_DESCRIPTION_TABLE[i].code)
 8020c50:	d002      	beq.n	8020c58 <device_status_get_error_description+0x24>
		{
			return DEVICE_ERROR_DESCRIPTION_TABLE[i].pText;
		}
	}
	/* did not found an entry, return text with index 0! */
	return DEVICE_ERROR_DESCRIPTION_TABLE[0].pText;
 8020c52:	6858      	ldr	r0, [r3, #4]
}
 8020c54:	4770      	bx	lr
{
	/*
	 * in case of an error, we do not need to be efficient!
	 */
	uint32_t elems = sizeof(DEVICE_ERROR_DESCRIPTION_TABLE)/sizeof(DEVICE_ERROR_DESCRIPTION_TABLE[0]);
	for (uint32_t i = 0; i< elems; i++)
 8020c56:	2202      	movs	r2, #2
	{
		if (error == DEVICE_ERROR_DESCRIPTION_TABLE[i].code)
		{
			return DEVICE_ERROR_DESCRIPTION_TABLE[i].pText;
 8020c58:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 8020c5c:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 8020c60:	6858      	ldr	r0, [r3, #4]
 8020c62:	4770      	bx	lr
{
	/*
	 * in case of an error, we do not need to be efficient!
	 */
	uint32_t elems = sizeof(DEVICE_ERROR_DESCRIPTION_TABLE)/sizeof(DEVICE_ERROR_DESCRIPTION_TABLE[0]);
	for (uint32_t i = 0; i< elems; i++)
 8020c64:	2200      	movs	r2, #0
 8020c66:	e7f7      	b.n	8020c58 <device_status_get_error_description+0x24>
 8020c68:	2201      	movs	r2, #1
 8020c6a:	e7f5      	b.n	8020c58 <device_status_get_error_description+0x24>
 8020c6c:	1ffe907c 	.word	0x1ffe907c

08020c70 <device_status_check>:
 */
uint32_t device_status_check()
{
	uint32_t retval = 0;

	if (device_status.state != STATE_NO_ERROR)
 8020c70:	4b03      	ldr	r3, [pc, #12]	; (8020c80 <device_status_check+0x10>)
 8020c72:	7818      	ldrb	r0, [r3, #0]
 8020c74:	3000      	adds	r0, #0
 8020c76:	bf18      	it	ne
 8020c78:	2001      	movne	r0, #1
	{
		retval = -1;
	}
	return retval;
}
 8020c7a:	4240      	negs	r0, r0
 8020c7c:	4770      	bx	lr
 8020c7e:	bf00      	nop
 8020c80:	1ffe9770 	.word	0x1ffe9770

08020c84 <device_status_clean>:
/**
 * @brief function to clean the errors of the device status
 */
void device_status_clean()
{
	device_status.latest_error = 0x0000;
 8020c84:	4b02      	ldr	r3, [pc, #8]	; (8020c90 <device_status_clean+0xc>)
 8020c86:	2200      	movs	r2, #0
 8020c88:	605a      	str	r2, [r3, #4]
	device_status.state = STATE_NO_ERROR;
 8020c8a:	701a      	strb	r2, [r3, #0]
 8020c8c:	4770      	bx	lr
 8020c8e:	bf00      	nop
 8020c90:	1ffe9770 	.word	0x1ffe9770

08020c94 <radar_get_consumption_labels>:
==============================================================================
 */

para_consumption_def_t *radar_get_consumption_labels(void)
{
	return p_consumption_def;
 8020c94:	4b01      	ldr	r3, [pc, #4]	; (8020c9c <radar_get_consumption_labels+0x8>)
}
 8020c96:	6818      	ldr	r0, [r3, #0]
 8020c98:	4770      	bx	lr
 8020c9a:	bf00      	nop
 8020c9c:	1ffe90b8 	.word	0x1ffe90b8

08020ca0 <set_consumption_repeat_count>:

//============================================================================

void set_consumption_repeat_count(size_t count)
{
	consumption_repeat_count = count;
 8020ca0:	4b01      	ldr	r3, [pc, #4]	; (8020ca8 <set_consumption_repeat_count+0x8>)
 8020ca2:	6018      	str	r0, [r3, #0]
 8020ca4:	4770      	bx	lr
 8020ca6:	bf00      	nop
 8020ca8:	1ffe977c 	.word	0x1ffe977c

08020cac <inc_consumption_repeat_count>:

//============================================================================

void inc_consumption_repeat_count(size_t count)
{
	consumption_repeat_count += count;
 8020cac:	4a02      	ldr	r2, [pc, #8]	; (8020cb8 <inc_consumption_repeat_count+0xc>)
 8020cae:	6813      	ldr	r3, [r2, #0]
 8020cb0:	4418      	add	r0, r3
 8020cb2:	6010      	str	r0, [r2, #0]
 8020cb4:	4770      	bx	lr
 8020cb6:	bf00      	nop
 8020cb8:	1ffe977c 	.word	0x1ffe977c

08020cbc <mcu_base_updates>:
}

//============================================================================

void mcu_base_updates(void)
{
 8020cbc:	b510      	push	{r4, lr}
	if (consumption_repeat_count > 0)
 8020cbe:	4c0b      	ldr	r4, [pc, #44]	; (8020cec <mcu_base_updates+0x30>)
 8020cc0:	6823      	ldr	r3, [r4, #0]
}

//============================================================================

void mcu_base_updates(void)
{
 8020cc2:	b084      	sub	sp, #16
	if (consumption_repeat_count > 0)
 8020cc4:	b183      	cbz	r3, 8020ce8 <mcu_base_updates+0x2c>
	{
		device_settings_t *pDev = ds_device_get_settings();
 8020cc6:	f7ff fa19 	bl	80200fc <ds_device_get_settings>
		extern float calcCurrentConsumption_mA(device_settings_t *pDev);
		float consumption = calcCurrentConsumption_mA(pDev);
 8020cca:	f009 fad1 	bl	802a270 <calcCurrentConsumption_mA>
uint16_t radar_send_consumption_to_host(int8_t index, float value, char *p_unit)
{
	consumption_response_t consumption;
	consumption.index = index;
	consumption.value = value;
	consumption.p_unit = p_unit;
 8020cce:	4b08      	ldr	r3, [pc, #32]	; (8020cf0 <mcu_base_updates+0x34>)
/* so far we only have on consumption "sensor" */
uint16_t radar_send_consumption_to_host(int8_t index, float value, char *p_unit)
{
	consumption_response_t consumption;
	consumption.index = index;
	consumption.value = value;
 8020cd0:	9002      	str	r0, [sp, #8]

/* so far we only have on consumption "sensor" */
uint16_t radar_send_consumption_to_host(int8_t index, float value, char *p_unit)
{
	consumption_response_t consumption;
	consumption.index = index;
 8020cd2:	2200      	movs	r2, #0
	consumption.value = value;
	consumption.p_unit = p_unit;

	return send_consumption_response(1, &consumption);
 8020cd4:	2001      	movs	r0, #1
 8020cd6:	a901      	add	r1, sp, #4
uint16_t radar_send_consumption_to_host(int8_t index, float value, char *p_unit)
{
	consumption_response_t consumption;
	consumption.index = index;
	consumption.value = value;
	consumption.p_unit = p_unit;
 8020cd8:	9303      	str	r3, [sp, #12]

/* so far we only have on consumption "sensor" */
uint16_t radar_send_consumption_to_host(int8_t index, float value, char *p_unit)
{
	consumption_response_t consumption;
	consumption.index = index;
 8020cda:	f88d 2004 	strb.w	r2, [sp, #4]
	consumption.value = value;
	consumption.p_unit = p_unit;

	return send_consumption_response(1, &consumption);
 8020cde:	f002 feab 	bl	8023a38 <send_consumption_response>
		device_settings_t *pDev = ds_device_get_settings();
		extern float calcCurrentConsumption_mA(device_settings_t *pDev);
		float consumption = calcCurrentConsumption_mA(pDev);

		radar_send_consumption_to_host(0, consumption, "mA");
		consumption_repeat_count -= 1;
 8020ce2:	6823      	ldr	r3, [r4, #0]
 8020ce4:	3b01      	subs	r3, #1
 8020ce6:	6023      	str	r3, [r4, #0]
	}
}
 8020ce8:	b004      	add	sp, #16
 8020cea:	bd10      	pop	{r4, pc}
 8020cec:	1ffe977c 	.word	0x1ffe977c
 8020cf0:	0802d688 	.word	0x0802d688

08020cf4 <set_result_repeat_count>:

//============================================================================

void set_result_repeat_count(uint8_t endpoint, size_t count)
{
	result_repeat_count = count;
 8020cf4:	4a02      	ldr	r2, [pc, #8]	; (8020d00 <set_result_repeat_count+0xc>)
	g_endpoint = endpoint;
 8020cf6:	4b03      	ldr	r3, [pc, #12]	; (8020d04 <set_result_repeat_count+0x10>)

//============================================================================

void set_result_repeat_count(uint8_t endpoint, size_t count)
{
	result_repeat_count = count;
 8020cf8:	6011      	str	r1, [r2, #0]
	g_endpoint = endpoint;
 8020cfa:	7018      	strb	r0, [r3, #0]
 8020cfc:	4770      	bx	lr
 8020cfe:	bf00      	nop
 8020d00:	1ffe9788 	.word	0x1ffe9788
 8020d04:	1ffe9780 	.word	0x1ffe9780

08020d08 <set_raw_data_repeat_count>:

//============================================================================

void set_raw_data_repeat_count(uint8_t endpoint, size_t count)
{
	raw_data_repeat_count = count;
 8020d08:	4a02      	ldr	r2, [pc, #8]	; (8020d14 <set_raw_data_repeat_count+0xc>)
	g_endpoint = endpoint;
 8020d0a:	4b03      	ldr	r3, [pc, #12]	; (8020d18 <set_raw_data_repeat_count+0x10>)

//============================================================================

void set_raw_data_repeat_count(uint8_t endpoint, size_t count)
{
	raw_data_repeat_count = count;
 8020d0c:	6011      	str	r1, [r2, #0]
	g_endpoint = endpoint;
 8020d0e:	7018      	strb	r0, [r3, #0]
 8020d10:	4770      	bx	lr
 8020d12:	bf00      	nop
 8020d14:	1ffe9784 	.word	0x1ffe9784
 8020d18:	1ffe9780 	.word	0x1ffe9780

08020d1c <radar_pulse_raw_data>:
}

//============================================================================

void radar_pulse_raw_data(acq_buf_obj *p_acq_buf, device_settings_t *p_dev)
{
 8020d1c:	b510      	push	{r4, lr}
	if (raw_data_repeat_count > 0)
 8020d1e:	4c06      	ldr	r4, [pc, #24]	; (8020d38 <radar_pulse_raw_data+0x1c>)
 8020d20:	6823      	ldr	r3, [r4, #0]
 8020d22:	b143      	cbz	r3, 8020d36 <radar_pulse_raw_data+0x1a>
	{
		send_pulse_frame_data(g_endpoint, p_acq_buf, p_dev);
 8020d24:	4b05      	ldr	r3, [pc, #20]	; (8020d3c <radar_pulse_raw_data+0x20>)
 8020d26:	460a      	mov	r2, r1
 8020d28:	4601      	mov	r1, r0
 8020d2a:	7818      	ldrb	r0, [r3, #0]
 8020d2c:	f003 f85c 	bl	8023de8 <send_pulse_frame_data>
		raw_data_repeat_count -= 1;
 8020d30:	6823      	ldr	r3, [r4, #0]
 8020d32:	3b01      	subs	r3, #1
 8020d34:	6023      	str	r3, [r4, #0]
 8020d36:	bd10      	pop	{r4, pc}
 8020d38:	1ffe9784 	.word	0x1ffe9784
 8020d3c:	1ffe9780 	.word	0x1ffe9780

08020d40 <radar_pulse_results_updates>:
}

//============================================================================

void radar_pulse_results_updates(algo_result_t *p_algo_result)
{
 8020d40:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (result_repeat_count > 0)
 8020d42:	4c13      	ldr	r4, [pc, #76]	; (8020d90 <radar_pulse_results_updates+0x50>)
 8020d44:	6823      	ldr	r3, [r4, #0]
}

//============================================================================

void radar_pulse_results_updates(algo_result_t *p_algo_result)
{
 8020d46:	b087      	sub	sp, #28
	if (result_repeat_count > 0)
 8020d48:	b1fb      	cbz	r3, 8020d8a <radar_pulse_results_updates+0x4a>
	{
		pulse_result_response_t pulse_result;

		pulse_result.frame_count             = p_algo_result->frame_counter;
		pulse_result.velocity_mps            = p_algo_result->velocity_kmph / 3.6f;
 8020d4a:	edd0 7a00 	vldr	s15, [r0]
 8020d4e:	ed9f 7a11 	vldr	s14, [pc, #68]	; 8020d94 <radar_pulse_results_updates+0x54>
		pulse_result.target_departing_bool   = p_algo_result->target_departing;
		pulse_result.target_approaching_bool = p_algo_result->target_approaching;
		pulse_result.motion_detected_bool    = p_algo_result->motion_detected;
		pulse_result.doppler_frequency_hz    = p_algo_result->doppler_frequency_hz;

		send_result_response(g_endpoint, &pulse_result);
 8020d52:	4a11      	ldr	r2, [pc, #68]	; (8020d98 <radar_pulse_results_updates+0x58>)
	{
		pulse_result_response_t pulse_result;

		pulse_result.frame_count             = p_algo_result->frame_counter;
		pulse_result.velocity_mps            = p_algo_result->velocity_kmph / 3.6f;
		pulse_result.level_nu                = p_algo_result->level;
 8020d54:	6841      	ldr	r1, [r0, #4]
		pulse_result.target_departing_bool   = p_algo_result->target_departing;
		pulse_result.target_approaching_bool = p_algo_result->target_approaching;
		pulse_result.motion_detected_bool    = p_algo_result->motion_detected;
		pulse_result.doppler_frequency_hz    = p_algo_result->doppler_frequency_hz;
 8020d56:	6907      	ldr	r7, [r0, #16]
	{
		pulse_result_response_t pulse_result;

		pulse_result.frame_count             = p_algo_result->frame_counter;
		pulse_result.velocity_mps            = p_algo_result->velocity_kmph / 3.6f;
		pulse_result.level_nu                = p_algo_result->level;
 8020d58:	9103      	str	r1, [sp, #12]
	if (result_repeat_count > 0)
	{
		pulse_result_response_t pulse_result;

		pulse_result.frame_count             = p_algo_result->frame_counter;
		pulse_result.velocity_mps            = p_algo_result->velocity_kmph / 3.6f;
 8020d5a:	eec7 7a87 	vdiv.f32	s15, s15, s14
 8020d5e:	4603      	mov	r3, r0
		pulse_result.target_departing_bool   = p_algo_result->target_departing;
		pulse_result.target_approaching_bool = p_algo_result->target_approaching;
		pulse_result.motion_detected_bool    = p_algo_result->motion_detected;
		pulse_result.doppler_frequency_hz    = p_algo_result->doppler_frequency_hz;

		send_result_response(g_endpoint, &pulse_result);
 8020d60:	a901      	add	r1, sp, #4
{
	if (result_repeat_count > 0)
	{
		pulse_result_response_t pulse_result;

		pulse_result.frame_count             = p_algo_result->frame_counter;
 8020d62:	69de      	ldr	r6, [r3, #28]
		pulse_result.velocity_mps            = p_algo_result->velocity_kmph / 3.6f;
		pulse_result.level_nu                = p_algo_result->level;
		pulse_result.target_departing_bool   = p_algo_result->target_departing;
 8020d64:	7a1d      	ldrb	r5, [r3, #8]
		pulse_result.target_approaching_bool = p_algo_result->target_approaching;
		pulse_result.motion_detected_bool    = p_algo_result->motion_detected;
		pulse_result.doppler_frequency_hz    = p_algo_result->doppler_frequency_hz;

		send_result_response(g_endpoint, &pulse_result);
 8020d66:	7810      	ldrb	r0, [r2, #0]

		pulse_result.frame_count             = p_algo_result->frame_counter;
		pulse_result.velocity_mps            = p_algo_result->velocity_kmph / 3.6f;
		pulse_result.level_nu                = p_algo_result->level;
		pulse_result.target_departing_bool   = p_algo_result->target_departing;
		pulse_result.target_approaching_bool = p_algo_result->target_approaching;
 8020d68:	7a5a      	ldrb	r2, [r3, #9]
		pulse_result.motion_detected_bool    = p_algo_result->motion_detected;
 8020d6a:	7a9b      	ldrb	r3, [r3, #10]
 8020d6c:	f88d 3012 	strb.w	r3, [sp, #18]
		pulse_result.doppler_frequency_hz    = p_algo_result->doppler_frequency_hz;
 8020d70:	9705      	str	r7, [sp, #20]
{
	if (result_repeat_count > 0)
	{
		pulse_result_response_t pulse_result;

		pulse_result.frame_count             = p_algo_result->frame_counter;
 8020d72:	9601      	str	r6, [sp, #4]
		pulse_result.velocity_mps            = p_algo_result->velocity_kmph / 3.6f;
		pulse_result.level_nu                = p_algo_result->level;
		pulse_result.target_departing_bool   = p_algo_result->target_departing;
 8020d74:	f88d 5010 	strb.w	r5, [sp, #16]
		pulse_result.target_approaching_bool = p_algo_result->target_approaching;
 8020d78:	f88d 2011 	strb.w	r2, [sp, #17]
	if (result_repeat_count > 0)
	{
		pulse_result_response_t pulse_result;

		pulse_result.frame_count             = p_algo_result->frame_counter;
		pulse_result.velocity_mps            = p_algo_result->velocity_kmph / 3.6f;
 8020d7c:	edcd 7a02 	vstr	s15, [sp, #8]
		pulse_result.target_departing_bool   = p_algo_result->target_departing;
		pulse_result.target_approaching_bool = p_algo_result->target_approaching;
		pulse_result.motion_detected_bool    = p_algo_result->motion_detected;
		pulse_result.doppler_frequency_hz    = p_algo_result->doppler_frequency_hz;

		send_result_response(g_endpoint, &pulse_result);
 8020d80:	f002 ff8c 	bl	8023c9c <send_result_response>

		result_repeat_count -= 1;
 8020d84:	6823      	ldr	r3, [r4, #0]
 8020d86:	3b01      	subs	r3, #1
 8020d88:	6023      	str	r3, [r4, #0]
	}
}
 8020d8a:	b007      	add	sp, #28
 8020d8c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8020d8e:	bf00      	nop
 8020d90:	1ffe9788 	.word	0x1ffe9788
 8020d94:	40666666 	.word	0x40666666
 8020d98:	1ffe9780 	.word	0x1ffe9780

08020d9c <copyStore2comPara>:

//============================================================================

void copyStore2comPara(pulse_para_values_t *p_com_para)
{
 8020d9c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8020d9e:	4604      	mov	r4, r0
	algo_settings_t *p_algo = ds_algo_get_settings();
 8020da0:	f7ff f93a 	bl	8020018 <ds_algo_get_settings>
 8020da4:	4606      	mov	r6, r0
	device_settings_t *p_dev = ds_device_get_settings();
 8020da6:	f7ff f9a9 	bl	80200fc <ds_device_get_settings>

	p_com_para->max_speed_mps              = p_algo->max_speed_kmph / 3.6f;
	p_com_para->min_speed_mps              = p_algo->min_speed_kmph / 3.6f;

	p_com_para->frame_time_sec             = p_dev->frame_period_usec / 1000000.0f;
 8020daa:	edd0 7a08 	vldr	s15, [r0, #32]
void copyStore2comPara(pulse_para_values_t *p_com_para)
{
	algo_settings_t *p_algo = ds_algo_get_settings();
	device_settings_t *p_dev = ds_device_get_settings();

	p_com_para->max_speed_mps              = p_algo->max_speed_kmph / 3.6f;
 8020dae:	ed96 6a04 	vldr	s12, [r6, #16]
	p_com_para->min_speed_mps              = p_algo->min_speed_kmph / 3.6f;
 8020db2:	edd6 6a03 	vldr	s13, [r6, #12]
void copyStore2comPara(pulse_para_values_t *p_com_para)
{
	algo_settings_t *p_algo = ds_algo_get_settings();
	device_settings_t *p_dev = ds_device_get_settings();

	p_com_para->max_speed_mps              = p_algo->max_speed_kmph / 3.6f;
 8020db6:	eddf 5a18 	vldr	s11, [pc, #96]	; 8020e18 <copyStore2comPara+0x7c>
	p_com_para->min_speed_mps              = p_algo->min_speed_kmph / 3.6f;

	p_com_para->frame_time_sec             = p_dev->frame_period_usec / 1000000.0f;
 8020dba:	ed9f 5a18 	vldr	s10, [pc, #96]	; 8020e1c <copyStore2comPara+0x80>
	p_com_para->number_of_samples_nu       = (uint16_t)p_dev->num_samples_per_chirp;

	p_com_para->sampling_freq_hz           = (float)p_dev->adc_sampling_freq_Hz;
 8020dbe:	ed90 7a05 	vldr	s14, [r0, #20]
	p_com_para->doppler_sensitivity_nu     = p_algo->speed_detection_threshold;
	p_com_para->motion_sensitivity_nu      = p_algo->motion_detection_threshold;

	p_com_para->use_high_gain_doppler_bool = (uint8_t)((p_algo->use_high_gain_doppler == 0L) ? 0U : 1U);
 8020dc2:	6a73      	ldr	r3, [r6, #36]	; 0x24
	p_com_para->frame_time_sec             = p_dev->frame_period_usec / 1000000.0f;
	p_com_para->number_of_samples_nu       = (uint16_t)p_dev->num_samples_per_chirp;

	p_com_para->sampling_freq_hz           = (float)p_dev->adc_sampling_freq_Hz;
	p_com_para->doppler_sensitivity_nu     = p_algo->speed_detection_threshold;
	p_com_para->motion_sensitivity_nu      = p_algo->motion_detection_threshold;
 8020dc4:	6ab2      	ldr	r2, [r6, #40]	; 0x28

	p_com_para->frame_time_sec             = p_dev->frame_period_usec / 1000000.0f;
	p_com_para->number_of_samples_nu       = (uint16_t)p_dev->num_samples_per_chirp;

	p_com_para->sampling_freq_hz           = (float)p_dev->adc_sampling_freq_Hz;
	p_com_para->doppler_sensitivity_nu     = p_algo->speed_detection_threshold;
 8020dc6:	68b7      	ldr	r7, [r6, #8]

	p_com_para->max_speed_mps              = p_algo->max_speed_kmph / 3.6f;
	p_com_para->min_speed_mps              = p_algo->min_speed_kmph / 3.6f;

	p_com_para->frame_time_sec             = p_dev->frame_period_usec / 1000000.0f;
	p_com_para->number_of_samples_nu       = (uint16_t)p_dev->num_samples_per_chirp;
 8020dc8:	6a41      	ldr	r1, [r0, #36]	; 0x24
 8020dca:	81a1      	strh	r1, [r4, #12]
	device_settings_t *p_dev = ds_device_get_settings();

	p_com_para->max_speed_mps              = p_algo->max_speed_kmph / 3.6f;
	p_com_para->min_speed_mps              = p_algo->min_speed_kmph / 3.6f;

	p_com_para->frame_time_sec             = p_dev->frame_period_usec / 1000000.0f;
 8020dcc:	eef8 7a67 	vcvt.f32.u32	s15, s15
void copyStore2comPara(pulse_para_values_t *p_com_para)
{
	algo_settings_t *p_algo = ds_algo_get_settings();
	device_settings_t *p_dev = ds_device_get_settings();

	p_com_para->max_speed_mps              = p_algo->max_speed_kmph / 3.6f;
 8020dd0:	ee86 6a25 	vdiv.f32	s12, s12, s11

	p_com_para->sampling_freq_hz           = (float)p_dev->adc_sampling_freq_Hz;
	p_com_para->doppler_sensitivity_nu     = p_algo->speed_detection_threshold;
	p_com_para->motion_sensitivity_nu      = p_algo->motion_detection_threshold;

	p_com_para->use_high_gain_doppler_bool = (uint8_t)((p_algo->use_high_gain_doppler == 0L) ? 0U : 1U);
 8020dd4:	3300      	adds	r3, #0
 8020dd6:	bf18      	it	ne
 8020dd8:	2301      	movne	r3, #1
//============================================================================

void copyStore2comPara(pulse_para_values_t *p_com_para)
{
	algo_settings_t *p_algo = ds_algo_get_settings();
	device_settings_t *p_dev = ds_device_get_settings();
 8020dda:	4605      	mov	r5, r0

	p_com_para->sampling_freq_hz           = (float)p_dev->adc_sampling_freq_Hz;
	p_com_para->doppler_sensitivity_nu     = p_algo->speed_detection_threshold;
	p_com_para->motion_sensitivity_nu      = p_algo->motion_detection_threshold;

	p_com_para->use_high_gain_doppler_bool = (uint8_t)((p_algo->use_high_gain_doppler == 0L) ? 0U : 1U);
 8020ddc:	7723      	strb	r3, [r4, #28]
	p_com_para->frame_time_sec             = p_dev->frame_period_usec / 1000000.0f;
	p_com_para->number_of_samples_nu       = (uint16_t)p_dev->num_samples_per_chirp;

	p_com_para->sampling_freq_hz           = (float)p_dev->adc_sampling_freq_Hz;
	p_com_para->doppler_sensitivity_nu     = p_algo->speed_detection_threshold;
	p_com_para->motion_sensitivity_nu      = p_algo->motion_detection_threshold;
 8020dde:	61a2      	str	r2, [r4, #24]

	p_com_para->frame_time_sec             = p_dev->frame_period_usec / 1000000.0f;
	p_com_para->number_of_samples_nu       = (uint16_t)p_dev->num_samples_per_chirp;

	p_com_para->sampling_freq_hz           = (float)p_dev->adc_sampling_freq_Hz;
	p_com_para->doppler_sensitivity_nu     = p_algo->speed_detection_threshold;
 8020de0:	6167      	str	r7, [r4, #20]
{
	algo_settings_t *p_algo = ds_algo_get_settings();
	device_settings_t *p_dev = ds_device_get_settings();

	p_com_para->max_speed_mps              = p_algo->max_speed_kmph / 3.6f;
	p_com_para->min_speed_mps              = p_algo->min_speed_kmph / 3.6f;
 8020de2:	eec6 6aa5 	vdiv.f32	s13, s13, s11

	p_com_para->frame_time_sec             = p_dev->frame_period_usec / 1000000.0f;
 8020de6:	eec7 7a85 	vdiv.f32	s15, s15, s10
	p_com_para->number_of_samples_nu       = (uint16_t)p_dev->num_samples_per_chirp;

	p_com_para->sampling_freq_hz           = (float)p_dev->adc_sampling_freq_Hz;
 8020dea:	eeb8 7a47 	vcvt.f32.u32	s14, s14
void copyStore2comPara(pulse_para_values_t *p_com_para)
{
	algo_settings_t *p_algo = ds_algo_get_settings();
	device_settings_t *p_dev = ds_device_get_settings();

	p_com_para->max_speed_mps              = p_algo->max_speed_kmph / 3.6f;
 8020dee:	ed84 6a00 	vstr	s12, [r4]
	p_com_para->min_speed_mps              = p_algo->min_speed_kmph / 3.6f;
 8020df2:	edc4 6a01 	vstr	s13, [r4, #4]

	p_com_para->frame_time_sec             = p_dev->frame_period_usec / 1000000.0f;
 8020df6:	edc4 7a02 	vstr	s15, [r4, #8]
	p_com_para->number_of_samples_nu       = (uint16_t)p_dev->num_samples_per_chirp;

	p_com_para->sampling_freq_hz           = (float)p_dev->adc_sampling_freq_Hz;
 8020dfa:	ed84 7a04 	vstr	s14, [r4, #16]
	p_com_para->doppler_sensitivity_nu     = p_algo->speed_detection_threshold;
	p_com_para->motion_sensitivity_nu      = p_algo->motion_detection_threshold;

	p_com_para->use_high_gain_doppler_bool = (uint8_t)((p_algo->use_high_gain_doppler == 0L) ? 0U : 1U);

	uint32_t temp_frame_period_usec        = bsp_calc_min_frame_interval_usec(p_dev);
 8020dfe:	f009 f95b 	bl	802a0b8 <bsp_calc_min_frame_interval_usec>

	p_com_para->continuous_mode_bool       = (temp_frame_period_usec == p_dev->frame_period_usec) ? 1 : 0;
 8020e02:	6a2b      	ldr	r3, [r5, #32]
 8020e04:	1a18      	subs	r0, r3, r0
 8020e06:	fab0 f080 	clz	r0, r0
 8020e0a:	0940      	lsrs	r0, r0, #5
 8020e0c:	7760      	strb	r0, [r4, #29]
	p_com_para->number_of_skip_samples_nu  = (uint16_t)p_dev->num_sample_skip_count;
 8020e0e:	6aea      	ldr	r2, [r5, #44]	; 0x2c
	p_com_para->pulse_width_usec           = p_dev->pulse_width_usec;
 8020e10:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 8020e12:	6223      	str	r3, [r4, #32]
	p_com_para->use_high_gain_doppler_bool = (uint8_t)((p_algo->use_high_gain_doppler == 0L) ? 0U : 1U);

	uint32_t temp_frame_period_usec        = bsp_calc_min_frame_interval_usec(p_dev);

	p_com_para->continuous_mode_bool       = (temp_frame_period_usec == p_dev->frame_period_usec) ? 1 : 0;
	p_com_para->number_of_skip_samples_nu  = (uint16_t)p_dev->num_sample_skip_count;
 8020e14:	83e2      	strh	r2, [r4, #30]
	p_com_para->pulse_width_usec           = p_dev->pulse_width_usec;
 8020e16:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8020e18:	40666666 	.word	0x40666666
 8020e1c:	49742400 	.word	0x49742400

08020e20 <copyComPara2Store>:
}

//============================================================================

uint32_t copyComPara2Store(pulse_para_values_t *p_com_para)
{
 8020e20:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8020e24:	b09d      	sub	sp, #116	; 0x74
 8020e26:	4681      	mov	r9, r0
	algo_settings_t algo;
	device_settings_t dev;

	algo_settings_t *p_algo  = ds_algo_get_settings();
 8020e28:	f7ff f8f6 	bl	8020018 <ds_algo_get_settings>
 8020e2c:	4606      	mov	r6, r0
	device_settings_t *p_dev = ds_device_get_settings();
 8020e2e:	f7ff f965 	bl	80200fc <ds_device_get_settings>

	uint32_t error = 0;

	memcpy(&algo, p_algo, sizeof(algo));
 8020e32:	4634      	mov	r4, r6
{
	algo_settings_t algo;
	device_settings_t dev;

	algo_settings_t *p_algo  = ds_algo_get_settings();
	device_settings_t *p_dev = ds_device_get_settings();
 8020e34:	4680      	mov	r8, r0

	uint32_t error = 0;

	memcpy(&algo, p_algo, sizeof(algo));
 8020e36:	f106 0e20 	add.w	lr, r6, #32
 8020e3a:	af01      	add	r7, sp, #4
 8020e3c:	6820      	ldr	r0, [r4, #0]
 8020e3e:	6861      	ldr	r1, [r4, #4]
 8020e40:	68a2      	ldr	r2, [r4, #8]
 8020e42:	68e3      	ldr	r3, [r4, #12]
 8020e44:	463d      	mov	r5, r7
 8020e46:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8020e48:	3410      	adds	r4, #16
 8020e4a:	4574      	cmp	r4, lr
 8020e4c:	462f      	mov	r7, r5
 8020e4e:	d1f5      	bne.n	8020e3c <copyComPara2Store+0x1c>
 8020e50:	6820      	ldr	r0, [r4, #0]
 8020e52:	6861      	ldr	r1, [r4, #4]
 8020e54:	68a2      	ldr	r2, [r4, #8]
	memcpy(&dev, p_dev, sizeof(dev));
 8020e56:	f108 0e40 	add.w	lr, r8, #64	; 0x40
	algo_settings_t *p_algo  = ds_algo_get_settings();
	device_settings_t *p_dev = ds_device_get_settings();

	uint32_t error = 0;

	memcpy(&algo, p_algo, sizeof(algo));
 8020e5a:	c707      	stmia	r7!, {r0, r1, r2}
	memcpy(&dev, p_dev, sizeof(dev));
 8020e5c:	4644      	mov	r4, r8
 8020e5e:	af0c      	add	r7, sp, #48	; 0x30
 8020e60:	6820      	ldr	r0, [r4, #0]
 8020e62:	6861      	ldr	r1, [r4, #4]
 8020e64:	68a2      	ldr	r2, [r4, #8]
 8020e66:	68e3      	ldr	r3, [r4, #12]
 8020e68:	463d      	mov	r5, r7
 8020e6a:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8020e6c:	3410      	adds	r4, #16
 8020e6e:	4574      	cmp	r4, lr
 8020e70:	462f      	mov	r7, r5
 8020e72:	d1f5      	bne.n	8020e60 <copyComPara2Store+0x40>

	algo.max_speed_kmph             = p_com_para->max_speed_mps * 3.6f;
 8020e74:	ed9f 6a3d 	vldr	s12, [pc, #244]	; 8020f6c <copyComPara2Store+0x14c>
 8020e78:	edd9 6a00 	vldr	s13, [r9]
	algo.min_speed_kmph             = p_com_para->min_speed_mps * 3.6f;
 8020e7c:	ed99 7a01 	vldr	s14, [r9, #4]

	dev.num_samples_per_chirp       = (uint32_t)p_com_para->number_of_samples_nu;

	dev.adc_sampling_freq_Hz        = (uint32_t)p_com_para->sampling_freq_hz;
 8020e80:	edd9 7a04 	vldr	s15, [r9, #16]
	algo.speed_detection_threshold  = p_com_para->doppler_sensitivity_nu;
	algo.motion_detection_threshold = p_com_para->motion_sensitivity_nu;
	algo.use_high_gain_doppler      = (uint32_t)((p_com_para->use_high_gain_doppler_bool == 0L) ? 0L : 1L);
 8020e84:	f899 301c 	ldrb.w	r3, [r9, #28]
	algo.min_speed_kmph             = p_com_para->min_speed_mps * 3.6f;

	dev.num_samples_per_chirp       = (uint32_t)p_com_para->number_of_samples_nu;

	dev.adc_sampling_freq_Hz        = (uint32_t)p_com_para->sampling_freq_hz;
	algo.speed_detection_threshold  = p_com_para->doppler_sensitivity_nu;
 8020e88:	f8d9 0014 	ldr.w	r0, [r9, #20]
	algo.motion_detection_threshold = p_com_para->motion_sensitivity_nu;
	algo.use_high_gain_doppler      = (uint32_t)((p_com_para->use_high_gain_doppler_bool == 0L) ? 0L : 1L);
	dev.num_sample_skip_count       = (uint32_t)p_com_para->number_of_skip_samples_nu;
	dev.pulse_width_usec            = p_com_para->pulse_width_usec;
 8020e8c:	f8d9 2020 	ldr.w	r2, [r9, #32]

	dev.num_samples_per_chirp       = (uint32_t)p_com_para->number_of_samples_nu;

	dev.adc_sampling_freq_Hz        = (uint32_t)p_com_para->sampling_freq_hz;
	algo.speed_detection_threshold  = p_com_para->doppler_sensitivity_nu;
	algo.motion_detection_threshold = p_com_para->motion_sensitivity_nu;
 8020e90:	f8d9 5018 	ldr.w	r5, [r9, #24]
	memcpy(&dev, p_dev, sizeof(dev));

	algo.max_speed_kmph             = p_com_para->max_speed_mps * 3.6f;
	algo.min_speed_kmph             = p_com_para->min_speed_mps * 3.6f;

	dev.num_samples_per_chirp       = (uint32_t)p_com_para->number_of_samples_nu;
 8020e94:	f8b9 400c 	ldrh.w	r4, [r9, #12]

	dev.adc_sampling_freq_Hz        = (uint32_t)p_com_para->sampling_freq_hz;
	algo.speed_detection_threshold  = p_com_para->doppler_sensitivity_nu;
	algo.motion_detection_threshold = p_com_para->motion_sensitivity_nu;
	algo.use_high_gain_doppler      = (uint32_t)((p_com_para->use_high_gain_doppler_bool == 0L) ? 0L : 1L);
	dev.num_sample_skip_count       = (uint32_t)p_com_para->number_of_skip_samples_nu;
 8020e98:	f8b9 101e 	ldrh.w	r1, [r9, #30]
	algo.min_speed_kmph             = p_com_para->min_speed_mps * 3.6f;

	dev.num_samples_per_chirp       = (uint32_t)p_com_para->number_of_samples_nu;

	dev.adc_sampling_freq_Hz        = (uint32_t)p_com_para->sampling_freq_hz;
	algo.speed_detection_threshold  = p_com_para->doppler_sensitivity_nu;
 8020e9c:	9003      	str	r0, [sp, #12]
	algo.motion_detection_threshold = p_com_para->motion_sensitivity_nu;
	algo.use_high_gain_doppler      = (uint32_t)((p_com_para->use_high_gain_doppler_bool == 0L) ? 0L : 1L);
 8020e9e:	3300      	adds	r3, #0
	uint32_t error = 0;

	memcpy(&algo, p_algo, sizeof(algo));
	memcpy(&dev, p_dev, sizeof(dev));

	algo.max_speed_kmph             = p_com_para->max_speed_mps * 3.6f;
 8020ea0:	ee66 6a86 	vmul.f32	s13, s13, s12
	algo.min_speed_kmph             = p_com_para->min_speed_mps * 3.6f;
 8020ea4:	ee27 7a06 	vmul.f32	s14, s14, s12

	dev.num_samples_per_chirp       = (uint32_t)p_com_para->number_of_samples_nu;

	dev.adc_sampling_freq_Hz        = (uint32_t)p_com_para->sampling_freq_hz;
 8020ea8:	eefc 7ae7 	vcvt.u32.f32	s15, s15
	algo.speed_detection_threshold  = p_com_para->doppler_sensitivity_nu;
	algo.motion_detection_threshold = p_com_para->motion_sensitivity_nu;
	algo.use_high_gain_doppler      = (uint32_t)((p_com_para->use_high_gain_doppler_bool == 0L) ? 0L : 1L);
 8020eac:	bf18      	it	ne
 8020eae:	2301      	movne	r3, #1
	dev.num_sample_skip_count       = (uint32_t)p_com_para->number_of_skip_samples_nu;
	dev.pulse_width_usec            = p_com_para->pulse_width_usec;

	uint32_t temp_frame_period      = bsp_calc_min_frame_interval_usec(&dev);
 8020eb0:	a80c      	add	r0, sp, #48	; 0x30
	dev.num_samples_per_chirp       = (uint32_t)p_com_para->number_of_samples_nu;

	dev.adc_sampling_freq_Hz        = (uint32_t)p_com_para->sampling_freq_hz;
	algo.speed_detection_threshold  = p_com_para->doppler_sensitivity_nu;
	algo.motion_detection_threshold = p_com_para->motion_sensitivity_nu;
	algo.use_high_gain_doppler      = (uint32_t)((p_com_para->use_high_gain_doppler_bool == 0L) ? 0L : 1L);
 8020eb2:	930a      	str	r3, [sp, #40]	; 0x28
	dev.num_sample_skip_count       = (uint32_t)p_com_para->number_of_skip_samples_nu;
	dev.pulse_width_usec            = p_com_para->pulse_width_usec;
 8020eb4:	9218      	str	r2, [sp, #96]	; 0x60
	uint32_t error = 0;

	memcpy(&algo, p_algo, sizeof(algo));
	memcpy(&dev, p_dev, sizeof(dev));

	algo.max_speed_kmph             = p_com_para->max_speed_mps * 3.6f;
 8020eb6:	edcd 6a05 	vstr	s13, [sp, #20]
	algo.min_speed_kmph             = p_com_para->min_speed_mps * 3.6f;
 8020eba:	ed8d 7a04 	vstr	s14, [sp, #16]

	dev.num_samples_per_chirp       = (uint32_t)p_com_para->number_of_samples_nu;

	dev.adc_sampling_freq_Hz        = (uint32_t)p_com_para->sampling_freq_hz;
 8020ebe:	edcd 7a11 	vstr	s15, [sp, #68]	; 0x44
	algo.speed_detection_threshold  = p_com_para->doppler_sensitivity_nu;
	algo.motion_detection_threshold = p_com_para->motion_sensitivity_nu;
 8020ec2:	950b      	str	r5, [sp, #44]	; 0x2c
	memcpy(&dev, p_dev, sizeof(dev));

	algo.max_speed_kmph             = p_com_para->max_speed_mps * 3.6f;
	algo.min_speed_kmph             = p_com_para->min_speed_mps * 3.6f;

	dev.num_samples_per_chirp       = (uint32_t)p_com_para->number_of_samples_nu;
 8020ec4:	9415      	str	r4, [sp, #84]	; 0x54

	dev.adc_sampling_freq_Hz        = (uint32_t)p_com_para->sampling_freq_hz;
	algo.speed_detection_threshold  = p_com_para->doppler_sensitivity_nu;
	algo.motion_detection_threshold = p_com_para->motion_sensitivity_nu;
	algo.use_high_gain_doppler      = (uint32_t)((p_com_para->use_high_gain_doppler_bool == 0L) ? 0L : 1L);
	dev.num_sample_skip_count       = (uint32_t)p_com_para->number_of_skip_samples_nu;
 8020ec6:	9117      	str	r1, [sp, #92]	; 0x5c
	dev.pulse_width_usec            = p_com_para->pulse_width_usec;

	uint32_t temp_frame_period      = bsp_calc_min_frame_interval_usec(&dev);
 8020ec8:	f009 f8f6 	bl	802a0b8 <bsp_calc_min_frame_interval_usec>
	dev.frame_period_usec           = (uint32_t)((p_com_para->continuous_mode_bool == 1U) ? temp_frame_period : (p_com_para->frame_time_sec * 1000000.0f));
 8020ecc:	f899 201d 	ldrb.w	r2, [r9, #29]
 8020ed0:	2a01      	cmp	r2, #1
	algo.motion_detection_threshold = p_com_para->motion_sensitivity_nu;
	algo.use_high_gain_doppler      = (uint32_t)((p_com_para->use_high_gain_doppler_bool == 0L) ? 0L : 1L);
	dev.num_sample_skip_count       = (uint32_t)p_com_para->number_of_skip_samples_nu;
	dev.pulse_width_usec            = p_com_para->pulse_width_usec;

	uint32_t temp_frame_period      = bsp_calc_min_frame_interval_usec(&dev);
 8020ed2:	4603      	mov	r3, r0
	dev.frame_period_usec           = (uint32_t)((p_com_para->continuous_mode_bool == 1U) ? temp_frame_period : (p_com_para->frame_time_sec * 1000000.0f));
 8020ed4:	d040      	beq.n	8020f58 <copyComPara2Store+0x138>
 8020ed6:	edd9 7a02 	vldr	s15, [r9, #8]
 8020eda:	ed9f 7a25 	vldr	s14, [pc, #148]	; 8020f70 <copyComPara2Store+0x150>
 8020ede:	ee67 7a87 	vmul.f32	s15, s15, s14
 8020ee2:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8020ee6:	ee17 0a90 	vmov	r0, s15
 8020eea:	4298      	cmp	r0, r3
 8020eec:	bf38      	it	cc
 8020eee:	4618      	movcc	r0, r3
 8020ef0:	9014      	str	r0, [sp, #80]	; 0x50
	if (dev.frame_period_usec < temp_frame_period)
		dev.frame_period_usec = temp_frame_period;

	ds_set_device_parameter_changed();
 8020ef2:	f7ff fb75 	bl	80205e0 <ds_set_device_parameter_changed>

	error += ds_algo_check_settings(&algo);
 8020ef6:	a801      	add	r0, sp, #4
 8020ef8:	f7ff f892 	bl	8020020 <ds_algo_check_settings>
 8020efc:	4604      	mov	r4, r0
	error += ds_dev_check_settings(&dev);
 8020efe:	a80c      	add	r0, sp, #48	; 0x30
 8020f00:	f7ff f8d4 	bl	80200ac <ds_dev_check_settings>

	if (error == 0)
 8020f04:	42e0      	cmn	r0, r4
 8020f06:	d003      	beq.n	8020f10 <copyComPara2Store+0xf0>
		memcpy(p_algo, &algo, sizeof(algo));
		memcpy(p_dev, &dev, sizeof(dev));

		return 1;
	}
	return 0;
 8020f08:	2000      	movs	r0, #0
}
 8020f0a:	b01d      	add	sp, #116	; 0x74
 8020f0c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	error += ds_algo_check_settings(&algo);
	error += ds_dev_check_settings(&dev);

	if (error == 0)
	{
		memcpy(p_algo, &algo, sizeof(algo));
 8020f10:	ac01      	add	r4, sp, #4
 8020f12:	af09      	add	r7, sp, #36	; 0x24
 8020f14:	4625      	mov	r5, r4
 8020f16:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8020f18:	42bd      	cmp	r5, r7
 8020f1a:	6030      	str	r0, [r6, #0]
 8020f1c:	6071      	str	r1, [r6, #4]
 8020f1e:	60b2      	str	r2, [r6, #8]
 8020f20:	60f3      	str	r3, [r6, #12]
 8020f22:	462c      	mov	r4, r5
 8020f24:	f106 0610 	add.w	r6, r6, #16
 8020f28:	d1f4      	bne.n	8020f14 <copyComPara2Store+0xf4>
 8020f2a:	cc07      	ldmia	r4!, {r0, r1, r2}
		memcpy(p_dev, &dev, sizeof(dev));
 8020f2c:	ac0c      	add	r4, sp, #48	; 0x30
	error += ds_algo_check_settings(&algo);
	error += ds_dev_check_settings(&dev);

	if (error == 0)
	{
		memcpy(p_algo, &algo, sizeof(algo));
 8020f2e:	6030      	str	r0, [r6, #0]
 8020f30:	6071      	str	r1, [r6, #4]
 8020f32:	60b2      	str	r2, [r6, #8]
		memcpy(p_dev, &dev, sizeof(dev));
 8020f34:	ae1c      	add	r6, sp, #112	; 0x70
 8020f36:	4625      	mov	r5, r4
 8020f38:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8020f3a:	42b5      	cmp	r5, r6
 8020f3c:	f8c8 0000 	str.w	r0, [r8]
 8020f40:	f8c8 1004 	str.w	r1, [r8, #4]
 8020f44:	f8c8 2008 	str.w	r2, [r8, #8]
 8020f48:	f8c8 300c 	str.w	r3, [r8, #12]
 8020f4c:	462c      	mov	r4, r5
 8020f4e:	f108 0810 	add.w	r8, r8, #16
 8020f52:	d1f0      	bne.n	8020f36 <copyComPara2Store+0x116>

		return 1;
 8020f54:	2001      	movs	r0, #1
 8020f56:	e7d8      	b.n	8020f0a <copyComPara2Store+0xea>
	algo.use_high_gain_doppler      = (uint32_t)((p_com_para->use_high_gain_doppler_bool == 0L) ? 0L : 1L);
	dev.num_sample_skip_count       = (uint32_t)p_com_para->number_of_skip_samples_nu;
	dev.pulse_width_usec            = p_com_para->pulse_width_usec;

	uint32_t temp_frame_period      = bsp_calc_min_frame_interval_usec(&dev);
	dev.frame_period_usec           = (uint32_t)((p_com_para->continuous_mode_bool == 1U) ? temp_frame_period : (p_com_para->frame_time_sec * 1000000.0f));
 8020f58:	ee07 0a90 	vmov	s15, r0
 8020f5c:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8020f60:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8020f64:	ee17 0a90 	vmov	r0, s15
 8020f68:	e7bf      	b.n	8020eea <copyComPara2Store+0xca>
 8020f6a:	bf00      	nop
 8020f6c:	40666666 	.word	0x40666666
 8020f70:	49742400 	.word	0x49742400

08020f74 <XMC_GPIO_Init>:
/*******************************************************************************
 * API IMPLEMENTATION
 *******************************************************************************/

void XMC_GPIO_Init(XMC_GPIO_PORT_t *const port, const uint8_t pin, const XMC_GPIO_CONFIG_t *const config)
{
 8020f74:	f001 03fc 	and.w	r3, r1, #252	; 0xfc
 8020f78:	4403      	add	r3, r0
 8020f7a:	b5f0      	push	{r4, r5, r6, r7, lr}
  XMC_ASSERT("XMC_GPIO_Init: Invalid port", XMC_GPIO_CHECK_PORT(port));
  XMC_ASSERT("XMC_GPIO_Init: Invalid mode", XMC_GPIO_IsModeValid(config->mode));
 
  /* Switch to input */
  port->IOCR[pin >> 2U] &= (uint32_t)~(PORT_IOCR_PC_Msk << (PORT_IOCR_PC_Size * (pin & 0x3U)));
 8020f7c:	f001 0503 	and.w	r5, r1, #3
 8020f80:	691e      	ldr	r6, [r3, #16]
  /* HW port control is disabled */
  port->HWSEL &= ~(uint32_t)((uint32_t)PORT_HWSEL_Msk << ((uint32_t)pin << 1U));


  /* Enable digital input */
  if (XMC_GPIO_CHECK_ANALOG_PORT(port))
 8020f82:	4f1c      	ldr	r7, [pc, #112]	; (8020ff4 <XMC_GPIO_Init+0x80>)
{
  XMC_ASSERT("XMC_GPIO_Init: Invalid port", XMC_GPIO_CHECK_PORT(port));
  XMC_ASSERT("XMC_GPIO_Init: Invalid mode", XMC_GPIO_IsModeValid(config->mode));
 
  /* Switch to input */
  port->IOCR[pin >> 2U] &= (uint32_t)~(PORT_IOCR_PC_Msk << (PORT_IOCR_PC_Size * (pin & 0x3U)));
 8020f84:	00ed      	lsls	r5, r5, #3
 8020f86:	24f8      	movs	r4, #248	; 0xf8
 8020f88:	40ac      	lsls	r4, r5
 8020f8a:	ea26 0404 	bic.w	r4, r6, r4
 8020f8e:	611c      	str	r4, [r3, #16]

  /* HW port control is disabled */
  port->HWSEL &= ~(uint32_t)((uint32_t)PORT_HWSEL_Msk << ((uint32_t)pin << 1U));
 8020f90:	6f46      	ldr	r6, [r0, #116]	; 0x74
 8020f92:	ea4f 0e41 	mov.w	lr, r1, lsl #1
 8020f96:	2403      	movs	r4, #3
 8020f98:	fa04 f40e 	lsl.w	r4, r4, lr
 8020f9c:	ea26 0404 	bic.w	r4, r6, r4


  /* Enable digital input */
  if (XMC_GPIO_CHECK_ANALOG_PORT(port))
 8020fa0:	42b8      	cmp	r0, r7
 
  /* Switch to input */
  port->IOCR[pin >> 2U] &= (uint32_t)~(PORT_IOCR_PC_Msk << (PORT_IOCR_PC_Size * (pin & 0x3U)));

  /* HW port control is disabled */
  port->HWSEL &= ~(uint32_t)((uint32_t)PORT_HWSEL_Msk << ((uint32_t)pin << 1U));
 8020fa2:	6744      	str	r4, [r0, #116]	; 0x74


  /* Enable digital input */
  if (XMC_GPIO_CHECK_ANALOG_PORT(port))
 8020fa4:	d01d      	beq.n	8020fe2 <XMC_GPIO_Init+0x6e>
 8020fa6:	4c14      	ldr	r4, [pc, #80]	; (8020ff8 <XMC_GPIO_Init+0x84>)
 8020fa8:	42a0      	cmp	r0, r4
 8020faa:	d01a      	beq.n	8020fe2 <XMC_GPIO_Init+0x6e>
    port->PDISC &= ~(uint32_t)((uint32_t)0x1U << pin);
  }
  else
  {
    /* Set output level */
    port->OMR = (uint32_t)config->output_level << pin;
 8020fac:	6857      	ldr	r7, [r2, #4]

    /* Set output driver strength */
    port->PDR[pin >> 3U] &= (uint32_t)~(PORT_PDR_Msk << ((uint32_t)PORT_PDR_Size * ((uint32_t)pin & 0x7U)));
    port->PDR[pin >> 3U] |= (uint32_t)config->output_strength << ((uint32_t)PORT_PDR_Size * ((uint32_t)pin & 0x7U));
 8020fae:	7a16      	ldrb	r6, [r2, #8]
 8020fb0:	08cc      	lsrs	r4, r1, #3
 8020fb2:	eb00 0484 	add.w	r4, r0, r4, lsl #2
    port->PDISC &= ~(uint32_t)((uint32_t)0x1U << pin);
  }
  else
  {
    /* Set output level */
    port->OMR = (uint32_t)config->output_level << pin;
 8020fb6:	408f      	lsls	r7, r1
 8020fb8:	6047      	str	r7, [r0, #4]

    /* Set output driver strength */
    port->PDR[pin >> 3U] &= (uint32_t)~(PORT_PDR_Msk << ((uint32_t)PORT_PDR_Size * ((uint32_t)pin & 0x7U)));
 8020fba:	f001 0107 	and.w	r1, r1, #7
 8020fbe:	6c27      	ldr	r7, [r4, #64]	; 0x40
 8020fc0:	0089      	lsls	r1, r1, #2
 8020fc2:	2007      	movs	r0, #7
 8020fc4:	4088      	lsls	r0, r1
 8020fc6:	ea27 0000 	bic.w	r0, r7, r0
 8020fca:	6420      	str	r0, [r4, #64]	; 0x40
    port->PDR[pin >> 3U] |= (uint32_t)config->output_strength << ((uint32_t)PORT_PDR_Size * ((uint32_t)pin & 0x7U));
 8020fcc:	6c20      	ldr	r0, [r4, #64]	; 0x40
 8020fce:	fa06 f101 	lsl.w	r1, r6, r1
 8020fd2:	4301      	orrs	r1, r0
 8020fd4:	6421      	str	r1, [r4, #64]	; 0x40
  }

  /* Set mode */
  port->IOCR[pin >> 2U] |= (uint32_t)config->mode << ((uint32_t)PORT_IOCR_PC_Size * ((uint32_t)pin & 0x3U));
 8020fd6:	7812      	ldrb	r2, [r2, #0]
 8020fd8:	6919      	ldr	r1, [r3, #16]
 8020fda:	40aa      	lsls	r2, r5
 8020fdc:	430a      	orrs	r2, r1
 8020fde:	611a      	str	r2, [r3, #16]
 8020fe0:	bdf0      	pop	{r4, r5, r6, r7, pc}


  /* Enable digital input */
  if (XMC_GPIO_CHECK_ANALOG_PORT(port))
  {
    port->PDISC &= ~(uint32_t)((uint32_t)0x1U << pin);
 8020fe2:	6e04      	ldr	r4, [r0, #96]	; 0x60
 8020fe4:	2601      	movs	r6, #1
 8020fe6:	fa06 f101 	lsl.w	r1, r6, r1
 8020fea:	ea24 0101 	bic.w	r1, r4, r1
 8020fee:	6601      	str	r1, [r0, #96]	; 0x60
 8020ff0:	e7f1      	b.n	8020fd6 <XMC_GPIO_Init+0x62>
 8020ff2:	bf00      	nop
 8020ff4:	48028e00 	.word	0x48028e00
 8020ff8:	48028f00 	.word	0x48028f00

08020ffc <XMC_SCU_RESET_AssertPeripheralReset>:
}

/* API to manually assert a reset request */
void XMC_SCU_RESET_AssertPeripheralReset(const XMC_SCU_PERIPHERAL_RESET_t peripheral)
{
  uint32_t index = (uint32_t)((((uint32_t)peripheral) & 0xf0000000UL) >> 28UL);
 8020ffc:	0f03      	lsrs	r3, r0, #28
  uint32_t mask = (((uint32_t)peripheral) & ((uint32_t)~0xf0000000UL));

  *(uint32_t *)(&(SCU_RESET->PRSET0) + (index * 3U)) = (uint32_t)mask;
 8020ffe:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8021002:	4a03      	ldr	r2, [pc, #12]	; (8021010 <XMC_SCU_RESET_AssertPeripheralReset+0x14>)

/* API to manually assert a reset request */
void XMC_SCU_RESET_AssertPeripheralReset(const XMC_SCU_PERIPHERAL_RESET_t peripheral)
{
  uint32_t index = (uint32_t)((((uint32_t)peripheral) & 0xf0000000UL) >> 28UL);
  uint32_t mask = (((uint32_t)peripheral) & ((uint32_t)~0xf0000000UL));
 8021004:	f020 4070 	bic.w	r0, r0, #4026531840	; 0xf0000000

  *(uint32_t *)(&(SCU_RESET->PRSET0) + (index * 3U)) = (uint32_t)mask;
 8021008:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
 802100c:	4770      	bx	lr
 802100e:	bf00      	nop
 8021010:	50004410 	.word	0x50004410

08021014 <XMC_SCU_RESET_DeassertPeripheralReset>:
}

/* API to manually de-assert a reset request */
void XMC_SCU_RESET_DeassertPeripheralReset(const XMC_SCU_PERIPHERAL_RESET_t peripheral)
{
  uint32_t index = (uint32_t)((((uint32_t)peripheral) & 0xf0000000UL) >> 28UL);
 8021014:	0f03      	lsrs	r3, r0, #28
  uint32_t mask = (((uint32_t)peripheral) & ((uint32_t)~0xf0000000UL));

  *(uint32_t *)(&(SCU_RESET->PRCLR0) + (index * 3U)) = (uint32_t)mask;
 8021016:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 802101a:	4a03      	ldr	r2, [pc, #12]	; (8021028 <XMC_SCU_RESET_DeassertPeripheralReset+0x14>)

/* API to manually de-assert a reset request */
void XMC_SCU_RESET_DeassertPeripheralReset(const XMC_SCU_PERIPHERAL_RESET_t peripheral)
{
  uint32_t index = (uint32_t)((((uint32_t)peripheral) & 0xf0000000UL) >> 28UL);
  uint32_t mask = (((uint32_t)peripheral) & ((uint32_t)~0xf0000000UL));
 802101c:	f020 4070 	bic.w	r0, r0, #4026531840	; 0xf0000000

  *(uint32_t *)(&(SCU_RESET->PRCLR0) + (index * 3U)) = (uint32_t)mask;
 8021020:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
 8021024:	4770      	bx	lr
 8021026:	bf00      	nop
 8021028:	50004414 	.word	0x50004414

0802102c <XMC_SCU_RESET_IsPeripheralResetAsserted>:
}

/* Find out if the peripheral reset is asserted */
bool XMC_SCU_RESET_IsPeripheralResetAsserted(const XMC_SCU_PERIPHERAL_RESET_t peripheral)
{
  uint32_t index = (uint32_t)((((uint32_t)peripheral) & 0xf0000000UL) >> 28UL);
 802102c:	0f03      	lsrs	r3, r0, #28
  uint32_t mask = (((uint32_t)peripheral) & ((uint32_t)~0xf0000000UL));

  return ((*(uint32_t *)(&(SCU_RESET->PRSTAT0) + (index * 3U)) & mask) != 0U);
 802102e:	4a06      	ldr	r2, [pc, #24]	; (8021048 <XMC_SCU_RESET_IsPeripheralResetAsserted+0x1c>)
 8021030:	eb03 0343 	add.w	r3, r3, r3, lsl #1

/* Find out if the peripheral reset is asserted */
bool XMC_SCU_RESET_IsPeripheralResetAsserted(const XMC_SCU_PERIPHERAL_RESET_t peripheral)
{
  uint32_t index = (uint32_t)((((uint32_t)peripheral) & 0xf0000000UL) >> 28UL);
  uint32_t mask = (((uint32_t)peripheral) & ((uint32_t)~0xf0000000UL));
 8021034:	f020 4070 	bic.w	r0, r0, #4026531840	; 0xf0000000

  return ((*(uint32_t *)(&(SCU_RESET->PRSTAT0) + (index * 3U)) & mask) != 0U);
 8021038:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 802103c:	4218      	tst	r0, r3
}
 802103e:	bf14      	ite	ne
 8021040:	2001      	movne	r0, #1
 8021042:	2000      	moveq	r0, #0
 8021044:	4770      	bx	lr
 8021046:	bf00      	nop
 8021048:	5000440c 	.word	0x5000440c

0802104c <XMC_SCU_CLOCK_GetPeripheralClockFrequency>:
 * API to retrieve clock frequency of peripherals on the peripheral bus using a shared functional clock
 */
uint32_t XMC_SCU_CLOCK_GetPeripheralClockFrequency(void)
{
  return (uint32_t)(XMC_SCU_CLOCK_GetCpuClockFrequency() >>
         ((SCU_CLK->PBCLKCR & SCU_CLK_PBCLKCR_PBDIV_Msk) >> SCU_CLK_PBCLKCR_PBDIV_Pos));  
 802104c:	4b03      	ldr	r3, [pc, #12]	; (802105c <XMC_SCU_CLOCK_GetPeripheralClockFrequency+0x10>)
 * \par<b>Related APIs:</b><BR>
 * XMC_SCU_CLOCK_GetPeripheralClockFrequency(), XMC_SCU_CLOCK_GatePeripheralClock() \n\n\n
 */
__STATIC_INLINE uint32_t XMC_SCU_CLOCK_GetCpuClockFrequency(void)
{
  return SystemCoreClock;
 802104e:	4a04      	ldr	r2, [pc, #16]	; (8021060 <XMC_SCU_CLOCK_GetPeripheralClockFrequency+0x14>)
 8021050:	695b      	ldr	r3, [r3, #20]
/*
 * API to retrieve clock frequency of peripherals on the peripheral bus using a shared functional clock
 */
uint32_t XMC_SCU_CLOCK_GetPeripheralClockFrequency(void)
{
  return (uint32_t)(XMC_SCU_CLOCK_GetCpuClockFrequency() >>
 8021052:	6810      	ldr	r0, [r2, #0]
 8021054:	f003 0301 	and.w	r3, r3, #1
         ((SCU_CLK->PBCLKCR & SCU_CLK_PBCLKCR_PBDIV_Msk) >> SCU_CLK_PBCLKCR_PBDIV_Pos));  
}
 8021058:	40d8      	lsrs	r0, r3
 802105a:	4770      	bx	lr
 802105c:	50004600 	.word	0x50004600
 8021060:	2003ffc0 	.word	0x2003ffc0

08021064 <XMC_SCU_CLOCK_SetUsbClockSource>:
}

/* API to select fUSB */
void XMC_SCU_CLOCK_SetUsbClockSource(const XMC_SCU_CLOCK_USBCLKSRC_t source)
{
  SCU_CLK->USBCLKCR = (SCU_CLK->USBCLKCR & ((uint32_t)~SCU_CLK_USBCLKCR_USBSEL_Msk)) |
 8021064:	4a03      	ldr	r2, [pc, #12]	; (8021074 <XMC_SCU_CLOCK_SetUsbClockSource+0x10>)
 8021066:	6993      	ldr	r3, [r2, #24]
 8021068:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 802106c:	4318      	orrs	r0, r3
 802106e:	6190      	str	r0, [r2, #24]
 8021070:	4770      	bx	lr
 8021072:	bf00      	nop
 8021074:	50004600 	.word	0x50004600

08021078 <XMC_SCU_CLOCK_SetWdtClockSource>:
}

/* API to select fWDT */
void XMC_SCU_CLOCK_SetWdtClockSource(const XMC_SCU_CLOCK_WDTCLKSRC_t source)
{
  SCU_CLK->WDTCLKCR = (SCU_CLK->WDTCLKCR & ((uint32_t)~SCU_CLK_WDTCLKCR_WDTSEL_Msk)) |
 8021078:	4a03      	ldr	r2, [pc, #12]	; (8021088 <XMC_SCU_CLOCK_SetWdtClockSource+0x10>)
 802107a:	6a53      	ldr	r3, [r2, #36]	; 0x24
 802107c:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
 8021080:	4318      	orrs	r0, r3
 8021082:	6250      	str	r0, [r2, #36]	; 0x24
 8021084:	4770      	bx	lr
 8021086:	bf00      	nop
 8021088:	50004600 	.word	0x50004600

0802108c <XMC_SCU_HIB_SetRtcClockSource>:

/* API to select fRTC */
void XMC_SCU_HIB_SetRtcClockSource(const XMC_SCU_HIB_RTCCLKSRC_t source)
{ 
  /* Wait until the update of HDCR register in hibernate domain is completed */
  while((SCU_GENERAL->MIRRSTS) & SCU_GENERAL_MIRRSTS_HDCR_Msk)
 802108c:	4a05      	ldr	r2, [pc, #20]	; (80210a4 <XMC_SCU_HIB_SetRtcClockSource+0x18>)
 802108e:	f8d2 30c4 	ldr.w	r3, [r2, #196]	; 0xc4
 8021092:	071b      	lsls	r3, r3, #28
 8021094:	d4fb      	bmi.n	802108e <XMC_SCU_HIB_SetRtcClockSource+0x2>
  {
  }

  SCU_HIBERNATE->HDCR = (SCU_HIBERNATE->HDCR & ((uint32_t)~SCU_HIBERNATE_HDCR_RCS_Msk)) |
 8021096:	4a04      	ldr	r2, [pc, #16]	; (80210a8 <XMC_SCU_HIB_SetRtcClockSource+0x1c>)
 8021098:	68d3      	ldr	r3, [r2, #12]
 802109a:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 802109e:	4318      	orrs	r0, r3
 80210a0:	60d0      	str	r0, [r2, #12]
 80210a2:	4770      	bx	lr
 80210a4:	50004000 	.word	0x50004000
 80210a8:	50004300 	.word	0x50004300

080210ac <XMC_SCU_CLOCK_SetUsbClockDivider>:
void XMC_SCU_CLOCK_SetUsbClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetSdmmcClockDivider:Wrong clock divider value",
              (divider <= (SCU_CLK_USBCLKCR_USBDIV_Msk + 1UL)) );

  SCU_CLK->USBCLKCR = (SCU_CLK->USBCLKCR & ((uint32_t)~SCU_CLK_USBCLKCR_USBDIV_Msk)) |
 80210ac:	4a03      	ldr	r2, [pc, #12]	; (80210bc <XMC_SCU_CLOCK_SetUsbClockDivider+0x10>)
 80210ae:	6993      	ldr	r3, [r2, #24]
                      (uint32_t)((uint32_t)(divider - 1UL) << SCU_CLK_USBCLKCR_USBDIV_Pos); 
 80210b0:	3801      	subs	r0, #1
void XMC_SCU_CLOCK_SetUsbClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetSdmmcClockDivider:Wrong clock divider value",
              (divider <= (SCU_CLK_USBCLKCR_USBDIV_Msk + 1UL)) );

  SCU_CLK->USBCLKCR = (SCU_CLK->USBCLKCR & ((uint32_t)~SCU_CLK_USBCLKCR_USBDIV_Msk)) |
 80210b2:	f023 0307 	bic.w	r3, r3, #7
 80210b6:	4303      	orrs	r3, r0
 80210b8:	6193      	str	r3, [r2, #24]
 80210ba:	4770      	bx	lr
 80210bc:	50004600 	.word	0x50004600

080210c0 <XMC_SCU_CLOCK_SetEbuClockDivider>:
void XMC_SCU_CLOCK_SetEbuClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetEbuClockDivider:Wrong clock divider value",
              (divider <= (SCU_CLK_EBUCLKCR_EBUDIV_Msk + 1UL) ) );

  SCU_CLK->EBUCLKCR = (SCU_CLK->EBUCLKCR & ((uint32_t)~SCU_CLK_EBUCLKCR_EBUDIV_Msk)) |
 80210c0:	4a03      	ldr	r2, [pc, #12]	; (80210d0 <XMC_SCU_CLOCK_SetEbuClockDivider+0x10>)
 80210c2:	69d3      	ldr	r3, [r2, #28]
                      (uint32_t)(((uint32_t)(divider - 1UL)) << SCU_CLK_EBUCLKCR_EBUDIV_Pos);
 80210c4:	3801      	subs	r0, #1
void XMC_SCU_CLOCK_SetEbuClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetEbuClockDivider:Wrong clock divider value",
              (divider <= (SCU_CLK_EBUCLKCR_EBUDIV_Msk + 1UL) ) );

  SCU_CLK->EBUCLKCR = (SCU_CLK->EBUCLKCR & ((uint32_t)~SCU_CLK_EBUCLKCR_EBUDIV_Msk)) |
 80210c6:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 80210ca:	4303      	orrs	r3, r0
 80210cc:	61d3      	str	r3, [r2, #28]
 80210ce:	4770      	bx	lr
 80210d0:	50004600 	.word	0x50004600

080210d4 <XMC_SCU_CLOCK_SetWdtClockDivider>:
void XMC_SCU_CLOCK_SetWdtClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetWdtClockDivider:Wrong clock divider value",
              (divider <= (SCU_CLK_WDTCLKCR_WDTDIV_Msk + 1UL) ) );

  SCU_CLK->WDTCLKCR = (SCU_CLK->WDTCLKCR & ((uint32_t)~SCU_CLK_WDTCLKCR_WDTDIV_Msk)) |
 80210d4:	4a03      	ldr	r2, [pc, #12]	; (80210e4 <XMC_SCU_CLOCK_SetWdtClockDivider+0x10>)
 80210d6:	6a53      	ldr	r3, [r2, #36]	; 0x24
                      (uint32_t)(((uint32_t)(divider - 1UL)) << SCU_CLK_WDTCLKCR_WDTDIV_Pos);
 80210d8:	3801      	subs	r0, #1
void XMC_SCU_CLOCK_SetWdtClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetWdtClockDivider:Wrong clock divider value",
              (divider <= (SCU_CLK_WDTCLKCR_WDTDIV_Msk + 1UL) ) );

  SCU_CLK->WDTCLKCR = (SCU_CLK->WDTCLKCR & ((uint32_t)~SCU_CLK_WDTCLKCR_WDTDIV_Msk)) |
 80210da:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
 80210de:	4303      	orrs	r3, r0
 80210e0:	6253      	str	r3, [r2, #36]	; 0x24
 80210e2:	4770      	bx	lr
 80210e4:	50004600 	.word	0x50004600

080210e8 <XMC_SCU_CLOCK_EnableClock>:
#endif

/* API to enable a given module clock */
void XMC_SCU_CLOCK_EnableClock(const XMC_SCU_CLOCK_t clock)
{
  SCU_CLK->CLKSET = ((uint32_t)clock);
 80210e8:	4b01      	ldr	r3, [pc, #4]	; (80210f0 <XMC_SCU_CLOCK_EnableClock+0x8>)
 80210ea:	6058      	str	r0, [r3, #4]
 80210ec:	4770      	bx	lr
 80210ee:	bf00      	nop
 80210f0:	50004600 	.word	0x50004600

080210f4 <XMC_SCU_CLOCK_GatePeripheralClock>:

#if defined(CLOCK_GATING_SUPPORTED)
/* API to gate a given module clock */
void XMC_SCU_CLOCK_GatePeripheralClock(const XMC_SCU_PERIPHERAL_CLOCK_t peripheral)
{
  uint32_t index = (peripheral & 0xf0000000UL) >> 28UL;
 80210f4:	0f03      	lsrs	r3, r0, #28
  uint32_t mask = (peripheral & (uint32_t)~0xf0000000UL);

  *(uint32_t *)((&(SCU_CLK->CGATSET0)) + (index * 3U)) = (uint32_t)mask;
 80210f6:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 80210fa:	4a03      	ldr	r2, [pc, #12]	; (8021108 <XMC_SCU_CLOCK_GatePeripheralClock+0x14>)
#if defined(CLOCK_GATING_SUPPORTED)
/* API to gate a given module clock */
void XMC_SCU_CLOCK_GatePeripheralClock(const XMC_SCU_PERIPHERAL_CLOCK_t peripheral)
{
  uint32_t index = (peripheral & 0xf0000000UL) >> 28UL;
  uint32_t mask = (peripheral & (uint32_t)~0xf0000000UL);
 80210fc:	f020 4070 	bic.w	r0, r0, #4026531840	; 0xf0000000

  *(uint32_t *)((&(SCU_CLK->CGATSET0)) + (index * 3U)) = (uint32_t)mask;
 8021100:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
 8021104:	4770      	bx	lr
 8021106:	bf00      	nop
 8021108:	50004644 	.word	0x50004644

0802110c <XMC_SCU_CLOCK_UngatePeripheralClock>:
}

/* API to ungate a given module clock */
void XMC_SCU_CLOCK_UngatePeripheralClock(const XMC_SCU_PERIPHERAL_CLOCK_t peripheral)
{
  uint32_t index = (uint32_t)((peripheral & 0xf0000000UL) >> 28UL);
 802110c:	0f03      	lsrs	r3, r0, #28
  uint32_t mask = (peripheral & (uint32_t)~0xf0000000UL);

  *(uint32_t *)(&(SCU_CLK->CGATCLR0) + (index * 3U)) = (uint32_t)mask;
 802110e:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8021112:	4a03      	ldr	r2, [pc, #12]	; (8021120 <XMC_SCU_CLOCK_UngatePeripheralClock+0x14>)

/* API to ungate a given module clock */
void XMC_SCU_CLOCK_UngatePeripheralClock(const XMC_SCU_PERIPHERAL_CLOCK_t peripheral)
{
  uint32_t index = (uint32_t)((peripheral & 0xf0000000UL) >> 28UL);
  uint32_t mask = (peripheral & (uint32_t)~0xf0000000UL);
 8021114:	f020 4070 	bic.w	r0, r0, #4026531840	; 0xf0000000

  *(uint32_t *)(&(SCU_CLK->CGATCLR0) + (index * 3U)) = (uint32_t)mask;
 8021118:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
 802111c:	4770      	bx	lr
 802111e:	bf00      	nop
 8021120:	50004648 	.word	0x50004648

08021124 <XMC_SCU_CLOCK_IsPeripheralClockGated>:
}

/* API to ungate a given module clock */
bool XMC_SCU_CLOCK_IsPeripheralClockGated(const XMC_SCU_PERIPHERAL_CLOCK_t peripheral)
{
  uint32_t index = ((peripheral & 0xf0000000UL) >> 28UL);
 8021124:	0f03      	lsrs	r3, r0, #28
  uint32_t mask = (peripheral & (uint32_t)~0xf0000000UL);

  return ((*(uint32_t *)(&(SCU_CLK->CGATSTAT0) + (index * 3U)) & mask) != 0U);
 8021126:	4a06      	ldr	r2, [pc, #24]	; (8021140 <XMC_SCU_CLOCK_IsPeripheralClockGated+0x1c>)
 8021128:	eb03 0343 	add.w	r3, r3, r3, lsl #1

/* API to ungate a given module clock */
bool XMC_SCU_CLOCK_IsPeripheralClockGated(const XMC_SCU_PERIPHERAL_CLOCK_t peripheral)
{
  uint32_t index = ((peripheral & 0xf0000000UL) >> 28UL);
  uint32_t mask = (peripheral & (uint32_t)~0xf0000000UL);
 802112c:	f020 4070 	bic.w	r0, r0, #4026531840	; 0xf0000000

  return ((*(uint32_t *)(&(SCU_CLK->CGATSTAT0) + (index * 3U)) & mask) != 0U);
 8021130:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8021134:	4218      	tst	r0, r3
}
 8021136:	bf14      	ite	ne
 8021138:	2001      	movne	r0, #1
 802113a:	2000      	moveq	r0, #0
 802113c:	4770      	bx	lr
 802113e:	bf00      	nop
 8021140:	50004640 	.word	0x50004640

08021144 <XMC_SCU_CLOCK_StartUsbPll>:

/* API to configure USB PLL */
void XMC_SCU_CLOCK_StartUsbPll(uint32_t pdiv, uint32_t ndiv)
{
  /* Go to bypass the USB PLL */
  SCU_PLL->USBPLLCON |= (uint32_t)SCU_PLL_USBPLLCON_VCOBYP_Msk;
 8021144:	4b0f      	ldr	r3, [pc, #60]	; (8021184 <XMC_SCU_CLOCK_StartUsbPll+0x40>)
 8021146:	695a      	ldr	r2, [r3, #20]
 8021148:	f042 0201 	orr.w	r2, r2, #1
 802114c:	615a      	str	r2, [r3, #20]

  /* disconnect Oscillator from USB PLL */
  SCU_PLL->USBPLLCON |= (uint32_t)SCU_PLL_USBPLLCON_FINDIS_Msk;
 802114e:	695a      	ldr	r2, [r3, #20]

  /* Setup Divider settings for USB PLL */
  SCU_PLL->USBPLLCON = (uint32_t)((uint32_t)((ndiv -1U) << SCU_PLL_USBPLLCON_NDIV_Pos) |
                       (uint32_t)((pdiv - 1U) << SCU_PLL_USBPLLCON_PDIV_Pos));
 8021150:	3801      	subs	r0, #1
 8021152:	0600      	lsls	r0, r0, #24

  /* disconnect Oscillator from USB PLL */
  SCU_PLL->USBPLLCON |= (uint32_t)SCU_PLL_USBPLLCON_FINDIS_Msk;

  /* Setup Divider settings for USB PLL */
  SCU_PLL->USBPLLCON = (uint32_t)((uint32_t)((ndiv -1U) << SCU_PLL_USBPLLCON_NDIV_Pos) |
 8021154:	3901      	subs	r1, #1
{
  /* Go to bypass the USB PLL */
  SCU_PLL->USBPLLCON |= (uint32_t)SCU_PLL_USBPLLCON_VCOBYP_Msk;

  /* disconnect Oscillator from USB PLL */
  SCU_PLL->USBPLLCON |= (uint32_t)SCU_PLL_USBPLLCON_FINDIS_Msk;
 8021156:	f042 0210 	orr.w	r2, r2, #16

  /* Setup Divider settings for USB PLL */
  SCU_PLL->USBPLLCON = (uint32_t)((uint32_t)((ndiv -1U) << SCU_PLL_USBPLLCON_NDIV_Pos) |
 802115a:	ea40 2001 	orr.w	r0, r0, r1, lsl #8
{
  /* Go to bypass the USB PLL */
  SCU_PLL->USBPLLCON |= (uint32_t)SCU_PLL_USBPLLCON_VCOBYP_Msk;

  /* disconnect Oscillator from USB PLL */
  SCU_PLL->USBPLLCON |= (uint32_t)SCU_PLL_USBPLLCON_FINDIS_Msk;
 802115e:	615a      	str	r2, [r3, #20]

  /* Setup Divider settings for USB PLL */
  SCU_PLL->USBPLLCON = (uint32_t)((uint32_t)((ndiv -1U) << SCU_PLL_USBPLLCON_NDIV_Pos) |
 8021160:	6158      	str	r0, [r3, #20]
                       (uint32_t)((pdiv - 1U) << SCU_PLL_USBPLLCON_PDIV_Pos));

  /* Set OSCDISCDIS */
  SCU_PLL->USBPLLCON |= (uint32_t)SCU_PLL_USBPLLCON_OSCDISCDIS_Msk;
 8021162:	695a      	ldr	r2, [r3, #20]
 8021164:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8021168:	615a      	str	r2, [r3, #20]

  /* connect Oscillator to USB PLL */
  SCU_PLL->USBPLLCON &= (uint32_t)~SCU_PLL_USBPLLCON_FINDIS_Msk;
 802116a:	695a      	ldr	r2, [r3, #20]
 802116c:	f022 0210 	bic.w	r2, r2, #16
 8021170:	615a      	str	r2, [r3, #20]

  /* restart PLL Lock detection */
  SCU_PLL->USBPLLCON |= (uint32_t)SCU_PLL_USBPLLCON_RESLD_Msk;
 8021172:	695a      	ldr	r2, [r3, #20]
 8021174:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 8021178:	615a      	str	r2, [r3, #20]

  while ((SCU_PLL->USBPLLSTAT & SCU_PLL_USBPLLSTAT_VCOLOCK_Msk) == 0U)
 802117a:	691a      	ldr	r2, [r3, #16]
 802117c:	0752      	lsls	r2, r2, #29
 802117e:	d5fc      	bpl.n	802117a <XMC_SCU_CLOCK_StartUsbPll+0x36>
  {
    /* wait for PLL Lock */
  }

}
 8021180:	4770      	bx	lr
 8021182:	bf00      	nop
 8021184:	50004710 	.word	0x50004710

08021188 <XMC_SCU_POWER_EnableUsb>:

/* API to enable USB Phy and comparator */
void XMC_SCU_POWER_EnableUsb(void)
{
#if defined(USB_OTG_SUPPORTED)
  SCU_POWER->PWRSET = (uint32_t)(SCU_POWER_PWRSET_USBOTGEN_Msk | SCU_POWER_PWRSET_USBPHYPDQ_Msk);
 8021188:	4b02      	ldr	r3, [pc, #8]	; (8021194 <XMC_SCU_POWER_EnableUsb+0xc>)
 802118a:	f44f 3240 	mov.w	r2, #196608	; 0x30000
 802118e:	605a      	str	r2, [r3, #4]
 8021190:	4770      	bx	lr
 8021192:	bf00      	nop
 8021194:	50004200 	.word	0x50004200

08021198 <XMC_SCU_POWER_DisableUsb>:

/* API to power down USB Phy and comparator */
void XMC_SCU_POWER_DisableUsb(void)
{
#if defined(USB_OTG_SUPPORTED)
  SCU_POWER->PWRCLR = (uint32_t)(SCU_POWER_PWRCLR_USBOTGEN_Msk | SCU_POWER_PWRSET_USBPHYPDQ_Msk);
 8021198:	4b02      	ldr	r3, [pc, #8]	; (80211a4 <XMC_SCU_POWER_DisableUsb+0xc>)
 802119a:	f44f 3240 	mov.w	r2, #196608	; 0x30000
 802119e:	609a      	str	r2, [r3, #8]
 80211a0:	4770      	bx	lr
 80211a2:	bf00      	nop
 80211a4:	50004200 	.word	0x50004200

080211a8 <XMC_SCU_CLOCK_StartSystemPll>:
void XMC_SCU_CLOCK_StartSystemPll(XMC_SCU_CLOCK_SYSPLLCLKSRC_t source,
                                  XMC_SCU_CLOCK_SYSPLL_MODE_t mode,
                                  uint32_t pdiv,
                                  uint32_t ndiv,
                                  uint32_t kdiv)
{
 80211a8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80211aa:	b083      	sub	sp, #12
void XMC_SCU_CLOCK_SetSystemPllClockSource(const XMC_SCU_CLOCK_SYSPLLCLKSRC_t source)
{
  /* Check input clock */
  if (source == XMC_SCU_CLOCK_SYSPLLCLKSRC_OSCHP) /* Select PLLClockSource */
  {
    SCU_PLL->PLLCON2 &= (uint32_t)~(SCU_PLL_PLLCON2_PINSEL_Msk | SCU_PLL_PLLCON2_K1INSEL_Msk);
 80211ac:	4c64      	ldr	r4, [pc, #400]	; (8021340 <XMC_SCU_CLOCK_StartSystemPll+0x198>)
void XMC_SCU_CLOCK_StartSystemPll(XMC_SCU_CLOCK_SYSPLLCLKSRC_t source,
                                  XMC_SCU_CLOCK_SYSPLL_MODE_t mode,
                                  uint32_t pdiv,
                                  uint32_t ndiv,
                                  uint32_t kdiv)
{
 80211ae:	9e08      	ldr	r6, [sp, #32]

/* API to select fPLL */
void XMC_SCU_CLOCK_SetSystemPllClockSource(const XMC_SCU_CLOCK_SYSPLLCLKSRC_t source)
{
  /* Check input clock */
  if (source == XMC_SCU_CLOCK_SYSPLLCLKSRC_OSCHP) /* Select PLLClockSource */
 80211b0:	b1c0      	cbz	r0, 80211e4 <XMC_SCU_CLOCK_StartSystemPll+0x3c>
  {
    SCU_PLL->PLLCON2 &= (uint32_t)~(SCU_PLL_PLLCON2_PINSEL_Msk | SCU_PLL_PLLCON2_K1INSEL_Msk);
  }
  else
  {
    SCU_PLL->PLLCON2 |= (uint32_t)(SCU_PLL_PLLCON2_PINSEL_Msk | SCU_PLL_PLLCON2_K1INSEL_Msk);
 80211b2:	68e0      	ldr	r0, [r4, #12]
 80211b4:	f440 7080 	orr.w	r0, r0, #256	; 0x100
 80211b8:	f040 0001 	orr.w	r0, r0, #1
  uint32_t vco_frequency; /* Q10.22, max VCO frequency = 520MHz */
  uint32_t kdiv_temp;

  XMC_SCU_CLOCK_SetSystemPllClockSource(source);

  if (mode == XMC_SCU_CLOCK_SYSPLL_MODE_NORMAL)
 80211bc:	2901      	cmp	r1, #1
  {
    SCU_PLL->PLLCON2 &= (uint32_t)~(SCU_PLL_PLLCON2_PINSEL_Msk | SCU_PLL_PLLCON2_K1INSEL_Msk);
  }
  else
  {
    SCU_PLL->PLLCON2 |= (uint32_t)(SCU_PLL_PLLCON2_PINSEL_Msk | SCU_PLL_PLLCON2_K1INSEL_Msk);
 80211be:	60e0      	str	r0, [r4, #12]
  uint32_t vco_frequency; /* Q10.22, max VCO frequency = 520MHz */
  uint32_t kdiv_temp;

  XMC_SCU_CLOCK_SetSystemPllClockSource(source);

  if (mode == XMC_SCU_CLOCK_SYSPLL_MODE_NORMAL)
 80211c0:	f000 8086 	beq.w	80212d0 <XMC_SCU_CLOCK_StartSystemPll+0x128>

    XMC_SCU_CLOCK_StepSystemPllFrequency(kdiv);
  }
  else
  {
    SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~SCU_PLL_PLLCON1_K1DIV_Msk) |
 80211c4:	4a5e      	ldr	r2, [pc, #376]	; (8021340 <XMC_SCU_CLOCK_StartSystemPll+0x198>)
 80211c6:	6893      	ldr	r3, [r2, #8]
                       ((kdiv -1UL) << SCU_PLL_PLLCON1_K1DIV_Pos));
 80211c8:	3e01      	subs	r6, #1

    XMC_SCU_CLOCK_StepSystemPllFrequency(kdiv);
  }
  else
  {
    SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~SCU_PLL_PLLCON1_K1DIV_Msk) |
 80211ca:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 80211ce:	431e      	orrs	r6, r3
 80211d0:	6096      	str	r6, [r2, #8]
                       ((kdiv -1UL) << SCU_PLL_PLLCON1_K1DIV_Pos));

    /* Switch to prescaler mode */
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_VCOBYP_Msk;
 80211d2:	6853      	ldr	r3, [r2, #4]
 80211d4:	f043 0301 	orr.w	r3, r3, #1
 80211d8:	6053      	str	r3, [r2, #4]

    while ((SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_VCOBYST_Msk) == 0U)
 80211da:	6813      	ldr	r3, [r2, #0]
 80211dc:	07db      	lsls	r3, r3, #31
 80211de:	d5fc      	bpl.n	80211da <XMC_SCU_CLOCK_StartSystemPll+0x32>
    {
      /* wait for prescaler mode */
    }
  }
}
 80211e0:	b003      	add	sp, #12
 80211e2:	bdf0      	pop	{r4, r5, r6, r7, pc}
void XMC_SCU_CLOCK_SetSystemPllClockSource(const XMC_SCU_CLOCK_SYSPLLCLKSRC_t source)
{
  /* Check input clock */
  if (source == XMC_SCU_CLOCK_SYSPLLCLKSRC_OSCHP) /* Select PLLClockSource */
  {
    SCU_PLL->PLLCON2 &= (uint32_t)~(SCU_PLL_PLLCON2_PINSEL_Msk | SCU_PLL_PLLCON2_K1INSEL_Msk);
 80211e4:	68e0      	ldr	r0, [r4, #12]
 80211e6:	f420 7080 	bic.w	r0, r0, #256	; 0x100
 80211ea:	f020 0001 	bic.w	r0, r0, #1
  uint32_t vco_frequency; /* Q10.22, max VCO frequency = 520MHz */
  uint32_t kdiv_temp;

  XMC_SCU_CLOCK_SetSystemPllClockSource(source);

  if (mode == XMC_SCU_CLOCK_SYSPLL_MODE_NORMAL)
 80211ee:	2901      	cmp	r1, #1
void XMC_SCU_CLOCK_SetSystemPllClockSource(const XMC_SCU_CLOCK_SYSPLLCLKSRC_t source)
{
  /* Check input clock */
  if (source == XMC_SCU_CLOCK_SYSPLLCLKSRC_OSCHP) /* Select PLLClockSource */
  {
    SCU_PLL->PLLCON2 &= (uint32_t)~(SCU_PLL_PLLCON2_PINSEL_Msk | SCU_PLL_PLLCON2_K1INSEL_Msk);
 80211f0:	60e0      	str	r0, [r4, #12]
  uint32_t vco_frequency; /* Q10.22, max VCO frequency = 520MHz */
  uint32_t kdiv_temp;

  XMC_SCU_CLOCK_SetSystemPllClockSource(source);

  if (mode == XMC_SCU_CLOCK_SYSPLL_MODE_NORMAL)
 80211f2:	d1e7      	bne.n	80211c4 <XMC_SCU_CLOCK_StartSystemPll+0x1c>
 80211f4:	e88d 000c 	stmia.w	sp, {r2, r3}
  {
    /* Calculate initial step to be close to fOFI */
    if (source == XMC_SCU_CLOCK_SYSPLLCLKSRC_OSCHP)
    {
      vco_frequency = (OSCHP_GetFrequency() / 1000000U) << 22;
 80211f8:	f006 fc4a 	bl	8027a90 <OSCHP_GetFrequency>
 80211fc:	4d51      	ldr	r5, [pc, #324]	; (8021344 <XMC_SCU_CLOCK_StartSystemPll+0x19c>)
 80211fe:	fba5 3500 	umull	r3, r5, r5, r0
 8021202:	e89d 000c 	ldmia.w	sp, {r2, r3}
 8021206:	0cad      	lsrs	r5, r5, #18
 8021208:	05ad      	lsls	r5, r5, #22
    }
    vco_frequency = ((vco_frequency * ndiv) / pdiv);
    kdiv_temp = (vco_frequency / (OFI_FREQUENCY / 1000000U)) >> 22;

    /* Switch to prescaler mode */
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_VCOBYP_Msk;
 802120a:	494d      	ldr	r1, [pc, #308]	; (8021340 <XMC_SCU_CLOCK_StartSystemPll+0x198>)
    else
    {
      vco_frequency = (OFI_FREQUENCY / 1000000U) << 22;
    }
    vco_frequency = ((vco_frequency * ndiv) / pdiv);
    kdiv_temp = (vco_frequency / (OFI_FREQUENCY / 1000000U)) >> 22;
 802120c:	4c4e      	ldr	r4, [pc, #312]	; (8021348 <XMC_SCU_CLOCK_StartSystemPll+0x1a0>)

    /* Switch to prescaler mode */
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_VCOBYP_Msk;
 802120e:	684f      	ldr	r7, [r1, #4]

    /* disconnect Oscillator from PLL */
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_FINDIS_Msk;

    /* Setup divider settings for main PLL */
    SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~(SCU_PLL_PLLCON1_NDIV_Msk | SCU_PLL_PLLCON1_K2DIV_Msk |
 8021210:	484e      	ldr	r0, [pc, #312]	; (802134c <XMC_SCU_CLOCK_StartSystemPll+0x1a4>)
    }
    vco_frequency = ((vco_frequency * ndiv) / pdiv);
    kdiv_temp = (vco_frequency / (OFI_FREQUENCY / 1000000U)) >> 22;

    /* Switch to prescaler mode */
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_VCOBYP_Msk;
 8021212:	f047 0701 	orr.w	r7, r7, #1
 8021216:	604f      	str	r7, [r1, #4]

    /* disconnect Oscillator from PLL */
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_FINDIS_Msk;
 8021218:	684f      	ldr	r7, [r1, #4]
 802121a:	f047 0710 	orr.w	r7, r7, #16
 802121e:	604f      	str	r7, [r1, #4]

    /* Setup divider settings for main PLL */
    SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~(SCU_PLL_PLLCON1_NDIV_Msk | SCU_PLL_PLLCON1_K2DIV_Msk |
 8021220:	f8d1 e008 	ldr.w	lr, [r1, #8]
    }
    else
    {
      vco_frequency = (OFI_FREQUENCY / 1000000U) << 22;
    }
    vco_frequency = ((vco_frequency * ndiv) / pdiv);
 8021224:	fb03 f505 	mul.w	r5, r3, r5

    /* Setup divider settings for main PLL */
    SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~(SCU_PLL_PLLCON1_NDIV_Msk | SCU_PLL_PLLCON1_K2DIV_Msk |
                                   SCU_PLL_PLLCON1_PDIV_Msk)) | ((ndiv - 1UL) << SCU_PLL_PLLCON1_NDIV_Pos) |
                                   ((kdiv_temp - 1UL) << SCU_PLL_PLLCON1_K2DIV_Pos) |
                                   ((pdiv - 1UL)<< SCU_PLL_PLLCON1_PDIV_Pos));
 8021228:	1e57      	subs	r7, r2, #1
    }
    else
    {
      vco_frequency = (OFI_FREQUENCY / 1000000U) << 22;
    }
    vco_frequency = ((vco_frequency * ndiv) / pdiv);
 802122a:	fbb5 f5f2 	udiv	r5, r5, r2

    /* disconnect Oscillator from PLL */
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_FINDIS_Msk;

    /* Setup divider settings for main PLL */
    SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~(SCU_PLL_PLLCON1_NDIV_Msk | SCU_PLL_PLLCON1_K2DIV_Msk |
 802122e:	ea0e 0000 	and.w	r0, lr, r0
    else
    {
      vco_frequency = (OFI_FREQUENCY / 1000000U) << 22;
    }
    vco_frequency = ((vco_frequency * ndiv) / pdiv);
    kdiv_temp = (vco_frequency / (OFI_FREQUENCY / 1000000U)) >> 22;
 8021232:	fba4 4205 	umull	r4, r2, r4, r5
 8021236:	ea40 6007 	orr.w	r0, r0, r7, lsl #24
    /* disconnect Oscillator from PLL */
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_FINDIS_Msk;

    /* Setup divider settings for main PLL */
    SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~(SCU_PLL_PLLCON1_NDIV_Msk | SCU_PLL_PLLCON1_K2DIV_Msk |
                                   SCU_PLL_PLLCON1_PDIV_Msk)) | ((ndiv - 1UL) << SCU_PLL_PLLCON1_NDIV_Pos) |
 802123a:	1e5c      	subs	r4, r3, #1
    else
    {
      vco_frequency = (OFI_FREQUENCY / 1000000U) << 22;
    }
    vco_frequency = ((vco_frequency * ndiv) / pdiv);
    kdiv_temp = (vco_frequency / (OFI_FREQUENCY / 1000000U)) >> 22;
 802123c:	0e93      	lsrs	r3, r2, #26
 802123e:	ea40 2004 	orr.w	r0, r0, r4, lsl #8
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_FINDIS_Msk;

    /* Setup divider settings for main PLL */
    SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~(SCU_PLL_PLLCON1_NDIV_Msk | SCU_PLL_PLLCON1_K2DIV_Msk |
                                   SCU_PLL_PLLCON1_PDIV_Msk)) | ((ndiv - 1UL) << SCU_PLL_PLLCON1_NDIV_Pos) |
                                   ((kdiv_temp - 1UL) << SCU_PLL_PLLCON1_K2DIV_Pos) |
 8021242:	3b01      	subs	r3, #1

    /* disconnect Oscillator from PLL */
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_FINDIS_Msk;

    /* Setup divider settings for main PLL */
    SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~(SCU_PLL_PLLCON1_NDIV_Msk | SCU_PLL_PLLCON1_K2DIV_Msk |
 8021244:	ea40 4303 	orr.w	r3, r0, r3, lsl #16
 8021248:	608b      	str	r3, [r1, #8]
                                   SCU_PLL_PLLCON1_PDIV_Msk)) | ((ndiv - 1UL) << SCU_PLL_PLLCON1_NDIV_Pos) |
                                   ((kdiv_temp - 1UL) << SCU_PLL_PLLCON1_K2DIV_Pos) |
                                   ((pdiv - 1UL)<< SCU_PLL_PLLCON1_PDIV_Pos));

    /* Set OSCDISCDIS, OSC clock remains connected to the VCO in case of loss of lock */
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_OSCDISCDIS_Msk;
 802124a:	684b      	ldr	r3, [r1, #4]
 802124c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8021250:	604b      	str	r3, [r1, #4]

    /* connect Oscillator to PLL */
    SCU_PLL->PLLCON0 &= (uint32_t)~SCU_PLL_PLLCON0_FINDIS_Msk;
 8021252:	684b      	ldr	r3, [r1, #4]
 8021254:	f023 0310 	bic.w	r3, r3, #16
 8021258:	604b      	str	r3, [r1, #4]

    /* restart PLL Lock detection */
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_RESLD_Msk;
 802125a:	684b      	ldr	r3, [r1, #4]
 802125c:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8021260:	604b      	str	r3, [r1, #4]
    while ((SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_VCOLOCK_Msk) == 0U)
 8021262:	6808      	ldr	r0, [r1, #0]
 8021264:	4b36      	ldr	r3, [pc, #216]	; (8021340 <XMC_SCU_CLOCK_StartSystemPll+0x198>)
 8021266:	0742      	lsls	r2, r0, #29
 8021268:	d5fb      	bpl.n	8021262 <XMC_SCU_CLOCK_StartSystemPll+0xba>
    {
      /* wait for PLL Lock */
    }

    /* Switch to normal mode */
    SCU_PLL->PLLCON0 &= (uint32_t)~SCU_PLL_PLLCON0_VCOBYP_Msk;
 802126a:	685a      	ldr	r2, [r3, #4]
 802126c:	f022 0201 	bic.w	r2, r2, #1
 8021270:	605a      	str	r2, [r3, #4]
    while ((SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_VCOBYST_Msk) != 0U)
 8021272:	4619      	mov	r1, r3
 8021274:	680b      	ldr	r3, [r1, #0]
 8021276:	4a32      	ldr	r2, [pc, #200]	; (8021340 <XMC_SCU_CLOCK_StartSystemPll+0x198>)
 8021278:	f013 0401 	ands.w	r4, r3, #1
 802127c:	d1fa      	bne.n	8021274 <XMC_SCU_CLOCK_StartSystemPll+0xcc>
    {
      /* wait for normal mode */
    }

    /* Ramp up PLL frequency in steps */
    kdiv_temp = (vco_frequency / 60UL) >> 22;
 802127e:	4b34      	ldr	r3, [pc, #208]	; (8021350 <XMC_SCU_CLOCK_StartSystemPll+0x1a8>)
 8021280:	fba3 1305 	umull	r1, r3, r3, r5
 8021284:	0edb      	lsrs	r3, r3, #27
    if (kdiv < kdiv_temp)
 8021286:	429e      	cmp	r6, r3
 8021288:	d33f      	bcc.n	802130a <XMC_SCU_CLOCK_StartSystemPll+0x162>
 802128a:	4f32      	ldr	r7, [pc, #200]	; (8021354 <XMC_SCU_CLOCK_StartSystemPll+0x1ac>)
    {
      XMC_SCU_CLOCK_StepSystemPllFrequency(kdiv_temp);
    }

    kdiv_temp = (vco_frequency / 90UL) >> 22;
 802128c:	4b32      	ldr	r3, [pc, #200]	; (8021358 <XMC_SCU_CLOCK_StartSystemPll+0x1b0>)
 802128e:	086d      	lsrs	r5, r5, #1
 8021290:	fba3 2305 	umull	r2, r3, r3, r5
 8021294:	0edb      	lsrs	r3, r3, #27
    if (kdiv < kdiv_temp)
 8021296:	429e      	cmp	r6, r3
 8021298:	d31d      	bcc.n	80212d6 <XMC_SCU_CLOCK_StartSystemPll+0x12e>
}

/* API to step up/down the main PLL frequency */
void XMC_SCU_CLOCK_StepSystemPllFrequency(uint32_t kdiv)
{
  SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~SCU_PLL_PLLCON1_K2DIV_Msk) |
 802129a:	4a29      	ldr	r2, [pc, #164]	; (8021340 <XMC_SCU_CLOCK_StartSystemPll+0x198>)
 802129c:	6893      	ldr	r3, [r2, #8]
                     ((kdiv - 1UL) << SCU_PLL_PLLCON1_K2DIV_Pos));
 802129e:	3e01      	subs	r6, #1
}

/* API to step up/down the main PLL frequency */
void XMC_SCU_CLOCK_StepSystemPllFrequency(uint32_t kdiv)
{
  SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~SCU_PLL_PLLCON1_K2DIV_Msk) |
 80212a0:	f423 03fe 	bic.w	r3, r3, #8323072	; 0x7f0000
 80212a4:	ea43 4606 	orr.w	r6, r3, r6, lsl #16
 80212a8:	6096      	str	r6, [r2, #8]
/* This is a local function used to generate the delay until register get updated with new configured value.  */
void XMC_SCU_lDelay(uint32_t delay)
{
  uint32_t i;

  SystemCoreClockUpdate();
 80212aa:	f7ff fa7f 	bl	80207ac <SystemCoreClockUpdate>
  delay =  delay * (uint32_t)(SystemCoreClock / FREQ_1MHZ);
 80212ae:	683b      	ldr	r3, [r7, #0]
 80212b0:	4a24      	ldr	r2, [pc, #144]	; (8021344 <XMC_SCU_CLOCK_StartSystemPll+0x19c>)
 80212b2:	fba2 3203 	umull	r3, r2, r2, r3
 80212b6:	0c92      	lsrs	r2, r2, #18
 80212b8:	2332      	movs	r3, #50	; 0x32
 80212ba:	fb03 f202 	mul.w	r2, r3, r2

  for (i = 0U; i < delay; ++i)
 80212be:	2300      	movs	r3, #0
 80212c0:	2a00      	cmp	r2, #0
 80212c2:	d08d      	beq.n	80211e0 <XMC_SCU_CLOCK_StartSystemPll+0x38>
  {
    __NOP();
 80212c4:	bf00      	nop
  uint32_t i;

  SystemCoreClockUpdate();
  delay =  delay * (uint32_t)(SystemCoreClock / FREQ_1MHZ);

  for (i = 0U; i < delay; ++i)
 80212c6:	3301      	adds	r3, #1
 80212c8:	4293      	cmp	r3, r2
 80212ca:	d1fb      	bne.n	80212c4 <XMC_SCU_CLOCK_StartSystemPll+0x11c>
    while ((SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_VCOBYST_Msk) == 0U)
    {
      /* wait for prescaler mode */
    }
  }
}
 80212cc:	b003      	add	sp, #12
 80212ce:	bdf0      	pop	{r4, r5, r6, r7, pc}
    {
      vco_frequency = (OSCHP_GetFrequency() / 1000000U) << 22;
    }
    else
    {
      vco_frequency = (OFI_FREQUENCY / 1000000U) << 22;
 80212d0:	f04f 65c0 	mov.w	r5, #100663296	; 0x6000000
 80212d4:	e799      	b.n	802120a <XMC_SCU_CLOCK_StartSystemPll+0x62>
}

/* API to step up/down the main PLL frequency */
void XMC_SCU_CLOCK_StepSystemPllFrequency(uint32_t kdiv)
{
  SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~SCU_PLL_PLLCON1_K2DIV_Msk) |
 80212d6:	491a      	ldr	r1, [pc, #104]	; (8021340 <XMC_SCU_CLOCK_StartSystemPll+0x198>)
 80212d8:	688a      	ldr	r2, [r1, #8]
                     ((kdiv - 1UL) << SCU_PLL_PLLCON1_K2DIV_Pos));
 80212da:	3b01      	subs	r3, #1
}

/* API to step up/down the main PLL frequency */
void XMC_SCU_CLOCK_StepSystemPllFrequency(uint32_t kdiv)
{
  SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~SCU_PLL_PLLCON1_K2DIV_Msk) |
 80212dc:	f422 02fe 	bic.w	r2, r2, #8323072	; 0x7f0000
 80212e0:	ea42 4303 	orr.w	r3, r2, r3, lsl #16
 80212e4:	608b      	str	r3, [r1, #8]
/* This is a local function used to generate the delay until register get updated with new configured value.  */
void XMC_SCU_lDelay(uint32_t delay)
{
  uint32_t i;

  SystemCoreClockUpdate();
 80212e6:	f7ff fa61 	bl	80207ac <SystemCoreClockUpdate>
  delay =  delay * (uint32_t)(SystemCoreClock / FREQ_1MHZ);
 80212ea:	683b      	ldr	r3, [r7, #0]
 80212ec:	4a15      	ldr	r2, [pc, #84]	; (8021344 <XMC_SCU_CLOCK_StartSystemPll+0x19c>)
 80212ee:	fba2 3203 	umull	r3, r2, r2, r3
 80212f2:	0c92      	lsrs	r2, r2, #18
 80212f4:	2332      	movs	r3, #50	; 0x32
 80212f6:	fb03 f202 	mul.w	r2, r3, r2

  for (i = 0U; i < delay; ++i)
 80212fa:	2a00      	cmp	r2, #0
 80212fc:	d0cd      	beq.n	802129a <XMC_SCU_CLOCK_StartSystemPll+0xf2>
 80212fe:	2300      	movs	r3, #0
  {
    __NOP();
 8021300:	bf00      	nop
  uint32_t i;

  SystemCoreClockUpdate();
  delay =  delay * (uint32_t)(SystemCoreClock / FREQ_1MHZ);

  for (i = 0U; i < delay; ++i)
 8021302:	3301      	adds	r3, #1
 8021304:	4293      	cmp	r3, r2
 8021306:	d1fb      	bne.n	8021300 <XMC_SCU_CLOCK_StartSystemPll+0x158>
 8021308:	e7c7      	b.n	802129a <XMC_SCU_CLOCK_StartSystemPll+0xf2>
}

/* API to step up/down the main PLL frequency */
void XMC_SCU_CLOCK_StepSystemPllFrequency(uint32_t kdiv)
{
  SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~SCU_PLL_PLLCON1_K2DIV_Msk) |
 802130a:	6891      	ldr	r1, [r2, #8]
void XMC_SCU_lDelay(uint32_t delay)
{
  uint32_t i;

  SystemCoreClockUpdate();
  delay =  delay * (uint32_t)(SystemCoreClock / FREQ_1MHZ);
 802130c:	4f11      	ldr	r7, [pc, #68]	; (8021354 <XMC_SCU_CLOCK_StartSystemPll+0x1ac>)
}

/* API to step up/down the main PLL frequency */
void XMC_SCU_CLOCK_StepSystemPllFrequency(uint32_t kdiv)
{
  SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~SCU_PLL_PLLCON1_K2DIV_Msk) |
 802130e:	f421 01fe 	bic.w	r1, r1, #8323072	; 0x7f0000
                     ((kdiv - 1UL) << SCU_PLL_PLLCON1_K2DIV_Pos));
 8021312:	3b01      	subs	r3, #1
}

/* API to step up/down the main PLL frequency */
void XMC_SCU_CLOCK_StepSystemPllFrequency(uint32_t kdiv)
{
  SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~SCU_PLL_PLLCON1_K2DIV_Msk) |
 8021314:	ea41 4303 	orr.w	r3, r1, r3, lsl #16
 8021318:	6093      	str	r3, [r2, #8]
/* This is a local function used to generate the delay until register get updated with new configured value.  */
void XMC_SCU_lDelay(uint32_t delay)
{
  uint32_t i;

  SystemCoreClockUpdate();
 802131a:	f7ff fa47 	bl	80207ac <SystemCoreClockUpdate>
  delay =  delay * (uint32_t)(SystemCoreClock / FREQ_1MHZ);
 802131e:	683b      	ldr	r3, [r7, #0]
 8021320:	4a08      	ldr	r2, [pc, #32]	; (8021344 <XMC_SCU_CLOCK_StartSystemPll+0x19c>)
 8021322:	fba2 3203 	umull	r3, r2, r2, r3
 8021326:	0c92      	lsrs	r2, r2, #18
 8021328:	2332      	movs	r3, #50	; 0x32
 802132a:	fb03 f202 	mul.w	r2, r3, r2

  for (i = 0U; i < delay; ++i)
 802132e:	2a00      	cmp	r2, #0
 8021330:	d0ac      	beq.n	802128c <XMC_SCU_CLOCK_StartSystemPll+0xe4>
 8021332:	4623      	mov	r3, r4
  {
    __NOP();
 8021334:	bf00      	nop
  uint32_t i;

  SystemCoreClockUpdate();
  delay =  delay * (uint32_t)(SystemCoreClock / FREQ_1MHZ);

  for (i = 0U; i < delay; ++i)
 8021336:	3301      	adds	r3, #1
 8021338:	4293      	cmp	r3, r2
 802133a:	d1fb      	bne.n	8021334 <XMC_SCU_CLOCK_StartSystemPll+0x18c>
 802133c:	e7a6      	b.n	802128c <XMC_SCU_CLOCK_StartSystemPll+0xe4>
 802133e:	bf00      	nop
 8021340:	50004710 	.word	0x50004710
 8021344:	431bde83 	.word	0x431bde83
 8021348:	aaaaaaab 	.word	0xaaaaaaab
 802134c:	f08080ff 	.word	0xf08080ff
 8021350:	88888889 	.word	0x88888889
 8021354:	2003ffc0 	.word	0x2003ffc0
 8021358:	b60b60b7 	.word	0xb60b60b7

0802135c <XMC_SCU_CLOCK_Init>:
}

/* API to select fSYS */
void XMC_SCU_CLOCK_SetSystemClockSource(const XMC_SCU_CLOCK_SYSCLKSRC_t source)
{
  SCU_CLK->SYSCLKCR = (SCU_CLK->SYSCLKCR & ((uint32_t)~SCU_CLK_SYSCLKCR_SYSSEL_Msk)) |
 802135c:	4977      	ldr	r1, [pc, #476]	; (802153c <XMC_SCU_CLOCK_Init+0x1e0>)

/* API to power up the hibernation domain */
void XMC_SCU_HIB_EnableHibernateDomain(void)
{
  /* Power up HIB domain if and only if it is currently powered down */
  if((SCU_POWER->PWRSTAT & SCU_POWER_PWRSTAT_HIBEN_Msk) == 0UL)
 802135e:	4a78      	ldr	r2, [pc, #480]	; (8021540 <XMC_SCU_CLOCK_Init+0x1e4>)
}

/* API to select fSYS */
void XMC_SCU_CLOCK_SetSystemClockSource(const XMC_SCU_CLOCK_SYSCLKSRC_t source)
{
  SCU_CLK->SYSCLKCR = (SCU_CLK->SYSCLKCR & ((uint32_t)~SCU_CLK_SYSCLKCR_SYSSEL_Msk)) |
 8021360:	68cb      	ldr	r3, [r1, #12]
  return (SCU_GENERAL->RMDATA);
}

/* API to initialize the clock tree */
void XMC_SCU_CLOCK_Init(const XMC_SCU_CLOCK_CONFIG_t *const config)
{
 8021362:	b5f0      	push	{r4, r5, r6, r7, lr}
}

/* API to select fSYS */
void XMC_SCU_CLOCK_SetSystemClockSource(const XMC_SCU_CLOCK_SYSCLKSRC_t source)
{
  SCU_CLK->SYSCLKCR = (SCU_CLK->SYSCLKCR & ((uint32_t)~SCU_CLK_SYSCLKCR_SYSSEL_Msk)) |
 8021364:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8021368:	60cb      	str	r3, [r1, #12]

/* API to power up the hibernation domain */
void XMC_SCU_HIB_EnableHibernateDomain(void)
{
  /* Power up HIB domain if and only if it is currently powered down */
  if((SCU_POWER->PWRSTAT & SCU_POWER_PWRSTAT_HIBEN_Msk) == 0UL)
 802136a:	6813      	ldr	r3, [r2, #0]
  return (SCU_GENERAL->RMDATA);
}

/* API to initialize the clock tree */
void XMC_SCU_CLOCK_Init(const XMC_SCU_CLOCK_CONFIG_t *const config)
{
 802136c:	4605      	mov	r5, r0

/* API to power up the hibernation domain */
void XMC_SCU_HIB_EnableHibernateDomain(void)
{
  /* Power up HIB domain if and only if it is currently powered down */
  if((SCU_POWER->PWRSTAT & SCU_POWER_PWRSTAT_HIBEN_Msk) == 0UL)
 802136e:	07d8      	lsls	r0, r3, #31
  return (SCU_GENERAL->RMDATA);
}

/* API to initialize the clock tree */
void XMC_SCU_CLOCK_Init(const XMC_SCU_CLOCK_CONFIG_t *const config)
{
 8021370:	b083      	sub	sp, #12

/* API to power up the hibernation domain */
void XMC_SCU_HIB_EnableHibernateDomain(void)
{
  /* Power up HIB domain if and only if it is currently powered down */
  if((SCU_POWER->PWRSTAT & SCU_POWER_PWRSTAT_HIBEN_Msk) == 0UL)
 8021372:	d404      	bmi.n	802137e <XMC_SCU_CLOCK_Init+0x22>
  {
    SCU_POWER->PWRSET = (uint32_t)SCU_POWER_PWRSET_HIB_Msk;
 8021374:	2301      	movs	r3, #1
 8021376:	6053      	str	r3, [r2, #4]
    
    while((SCU_POWER->PWRSTAT & SCU_POWER_PWRSTAT_HIBEN_Msk) == 0UL)
 8021378:	6813      	ldr	r3, [r2, #0]
 802137a:	07db      	lsls	r3, r3, #31
 802137c:	d5fc      	bpl.n	8021378 <XMC_SCU_CLOCK_Init+0x1c>
      /* wait until HIB domain is enabled */
    }    
  }
  
  /* Remove the reset only if HIB domain were in a state of reset */
  if((SCU_RESET->RSTSTAT) & SCU_RESET_RSTSTAT_HIBRS_Msk)
 802137e:	4a71      	ldr	r2, [pc, #452]	; (8021544 <XMC_SCU_CLOCK_Init+0x1e8>)
 8021380:	6813      	ldr	r3, [r2, #0]
 8021382:	0599      	lsls	r1, r3, #22
 8021384:	d505      	bpl.n	8021392 <XMC_SCU_CLOCK_Init+0x36>
  {
    SCU_RESET->RSTCLR = (uint32_t)SCU_RESET_RSTCLR_HIBRS_Msk;
 8021386:	f44f 7300 	mov.w	r3, #512	; 0x200
 802138a:	6093      	str	r3, [r2, #8]
    while((SCU_RESET->RSTSTAT & SCU_RESET_RSTSTAT_HIBRS_Msk) != 0UL)
 802138c:	6813      	ldr	r3, [r2, #0]
 802138e:	059f      	lsls	r7, r3, #22
 8021390:	d4fc      	bmi.n	802138c <XMC_SCU_CLOCK_Init+0x30>

  XMC_SCU_CLOCK_SetSystemClockSource(XMC_SCU_CLOCK_SYSCLKSRC_OFI);

  XMC_SCU_HIB_EnableHibernateDomain();

  if (config->enable_osculp == true)
 8021392:	79eb      	ldrb	r3, [r5, #7]
 8021394:	2b00      	cmp	r3, #0
 8021396:	f040 8091 	bne.w	80214bc <XMC_SCU_CLOCK_Init+0x160>
  {
    XMC_SCU_CLOCK_EnableLowPowerOscillator();
    while (XMC_SCU_CLOCK_IsLowPowerOscillatorStable() == false);
  }
  
  XMC_SCU_HIB_SetStandbyClockSource(config->fstdby_clksrc);  
 802139a:	7a68      	ldrb	r0, [r5, #9]
}

/* API to select fSTDBY */
void XMC_SCU_HIB_SetStandbyClockSource(const XMC_SCU_HIB_STDBYCLKSRC_t source)
{
  while((SCU_GENERAL->MIRRSTS) & SCU_GENERAL_MIRRSTS_HDCR_Msk)
 802139c:	4a6a      	ldr	r2, [pc, #424]	; (8021548 <XMC_SCU_CLOCK_Init+0x1ec>)
 802139e:	f8d2 30c4 	ldr.w	r3, [r2, #196]	; 0xc4
 80213a2:	071b      	lsls	r3, r3, #28
 80213a4:	d4fb      	bmi.n	802139e <XMC_SCU_CLOCK_Init+0x42>
  {
    /* check SCU_MIRRSTS to ensure that no transfer over serial interface is pending */
  }
  SCU_HIBERNATE->HDCR = (SCU_HIBERNATE->HDCR & ((uint32_t)~SCU_HIBERNATE_HDCR_STDBYSEL_Msk)) |
 80213a6:	4969      	ldr	r1, [pc, #420]	; (802154c <XMC_SCU_CLOCK_Init+0x1f0>)
 * is busy with executing the previous operation.\n
 * Note: There is no hibernate domain in XMC1x devices. This register is retained for legacy purpose.
 */
__STATIC_INLINE uint32_t XMC_SCU_GetMirrorStatus(void)
{
  return(SCU_GENERAL->MIRRSTS);
 80213a8:	4b67      	ldr	r3, [pc, #412]	; (8021548 <XMC_SCU_CLOCK_Init+0x1ec>)
 80213aa:	68ca      	ldr	r2, [r1, #12]
 80213ac:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 80213b0:	4302      	orrs	r2, r0
 80213b2:	60ca      	str	r2, [r1, #12]
 80213b4:	f8d3 40c4 	ldr.w	r4, [r3, #196]	; 0xc4
    XMC_SCU_CLOCK_EnableLowPowerOscillator();
    while (XMC_SCU_CLOCK_IsLowPowerOscillatorStable() == false);
  }
  
  XMC_SCU_HIB_SetStandbyClockSource(config->fstdby_clksrc);  
  while (XMC_SCU_GetMirrorStatus() != 0)
 80213b8:	2c00      	cmp	r4, #0
 80213ba:	d1fb      	bne.n	80213b4 <XMC_SCU_CLOCK_Init+0x58>

/* API to onfigure the calibration mode for internal oscillator */
void XMC_SCU_CLOCK_SetBackupClockCalibrationMode(XMC_SCU_CLOCK_FOFI_CALIBRATION_MODE_t mode)
{
  /* Enable factory calibration based trimming */
  SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_FOTR_Msk;
 80213bc:	4a64      	ldr	r2, [pc, #400]	; (8021550 <XMC_SCU_CLOCK_Init+0x1f4>)
  while (XMC_SCU_GetMirrorStatus() != 0)
  {
    /* Wait until update of the stanby clock source is done in the HIB domain */    
  }

  XMC_SCU_CLOCK_SetBackupClockCalibrationMode(config->calibration_mode);
 80213be:	7a29      	ldrb	r1, [r5, #8]

/* API to onfigure the calibration mode for internal oscillator */
void XMC_SCU_CLOCK_SetBackupClockCalibrationMode(XMC_SCU_CLOCK_FOFI_CALIBRATION_MODE_t mode)
{
  /* Enable factory calibration based trimming */
  SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_FOTR_Msk;
 80213c0:	6853      	ldr	r3, [r2, #4]

  if (mode == XMC_SCU_CLOCK_FOFI_CALIBRATION_MODE_AUTOMATIC)
 80213c2:	2901      	cmp	r1, #1

/* API to onfigure the calibration mode for internal oscillator */
void XMC_SCU_CLOCK_SetBackupClockCalibrationMode(XMC_SCU_CLOCK_FOFI_CALIBRATION_MODE_t mode)
{
  /* Enable factory calibration based trimming */
  SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_FOTR_Msk;
 80213c4:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 80213c8:	6053      	str	r3, [r2, #4]

  if (mode == XMC_SCU_CLOCK_FOFI_CALIBRATION_MODE_AUTOMATIC)
 80213ca:	f000 809d 	beq.w	8021508 <XMC_SCU_CLOCK_Init+0x1ac>
 80213ce:	4e61      	ldr	r6, [pc, #388]	; (8021554 <XMC_SCU_CLOCK_Init+0x1f8>)
/* This is a local function used to generate the delay until register get updated with new configured value.  */
void XMC_SCU_lDelay(uint32_t delay)
{
  uint32_t i;

  SystemCoreClockUpdate();
 80213d0:	f7ff f9ec 	bl	80207ac <SystemCoreClockUpdate>
  delay =  delay * (uint32_t)(SystemCoreClock / FREQ_1MHZ);
 80213d4:	6833      	ldr	r3, [r6, #0]
 80213d6:	4a60      	ldr	r2, [pc, #384]	; (8021558 <XMC_SCU_CLOCK_Init+0x1fc>)
 80213d8:	fba2 3203 	umull	r3, r2, r2, r3
 80213dc:	0c92      	lsrs	r2, r2, #18
 80213de:	2364      	movs	r3, #100	; 0x64
 80213e0:	fb03 f202 	mul.w	r2, r3, r2

  for (i = 0U; i < delay; ++i)
 80213e4:	b122      	cbz	r2, 80213f0 <XMC_SCU_CLOCK_Init+0x94>
 80213e6:	2300      	movs	r3, #0
  {
    __NOP();
 80213e8:	bf00      	nop
  uint32_t i;

  SystemCoreClockUpdate();
  delay =  delay * (uint32_t)(SystemCoreClock / FREQ_1MHZ);

  for (i = 0U; i < delay; ++i)
 80213ea:	3301      	adds	r3, #1
 80213ec:	4293      	cmp	r3, r2
 80213ee:	d1fb      	bne.n	80213e8 <XMC_SCU_CLOCK_Init+0x8c>
void XMC_SCU_CLOCK_SetSystemClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetSystemClockDivider:Wrong clock divider value",
              (divider <= (SCU_CLK_SYSCLKCR_SYSDIV_Msk + 1UL)) );

  SCU_CLK->SYSCLKCR = (SCU_CLK->SYSCLKCR & ((uint32_t)~SCU_CLK_SYSCLKCR_SYSDIV_Msk)) |
 80213f0:	4b52      	ldr	r3, [pc, #328]	; (802153c <XMC_SCU_CLOCK_Init+0x1e0>)
    /* Wait until update of the stanby clock source is done in the HIB domain */    
  }

  XMC_SCU_CLOCK_SetBackupClockCalibrationMode(config->calibration_mode);

  XMC_SCU_CLOCK_SetSystemClockDivider((uint32_t)config->fsys_clkdiv);
 80213f2:	7c2c      	ldrb	r4, [r5, #16]
void XMC_SCU_CLOCK_SetSystemClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetSystemClockDivider:Wrong clock divider value",
              (divider <= (SCU_CLK_SYSCLKCR_SYSDIV_Msk + 1UL)) );

  SCU_CLK->SYSCLKCR = (SCU_CLK->SYSCLKCR & ((uint32_t)~SCU_CLK_SYSCLKCR_SYSDIV_Msk)) |
 80213f4:	68da      	ldr	r2, [r3, #12]
  XMC_SCU_CLOCK_SetSystemClockDivider((uint32_t)config->fsys_clkdiv);
  XMC_SCU_CLOCK_SetCpuClockDivider((uint32_t)config->fcpu_clkdiv);
  XMC_SCU_CLOCK_SetCcuClockDivider((uint32_t)config->fccu_clkdiv);
  XMC_SCU_CLOCK_SetPeripheralClockDivider((uint32_t)config->fperipheral_clkdiv);

  if (config->enable_oschp == true)
 80213f6:	79a8      	ldrb	r0, [r5, #6]
void XMC_SCU_CLOCK_SetSystemClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetSystemClockDivider:Wrong clock divider value",
              (divider <= (SCU_CLK_SYSCLKCR_SYSDIV_Msk + 1UL)) );

  SCU_CLK->SYSCLKCR = (SCU_CLK->SYSCLKCR & ((uint32_t)~SCU_CLK_SYSCLKCR_SYSDIV_Msk)) |
 80213f8:	f022 01ff 	bic.w	r1, r2, #255	; 0xff
                      ((uint32_t)(((uint32_t)(divider - 1UL)) << SCU_CLK_SYSCLKCR_SYSDIV_Pos));
 80213fc:	1e62      	subs	r2, r4, #1
void XMC_SCU_CLOCK_SetSystemClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetSystemClockDivider:Wrong clock divider value",
              (divider <= (SCU_CLK_SYSCLKCR_SYSDIV_Msk + 1UL)) );

  SCU_CLK->SYSCLKCR = (SCU_CLK->SYSCLKCR & ((uint32_t)~SCU_CLK_SYSCLKCR_SYSDIV_Msk)) |
 80213fe:	430a      	orrs	r2, r1
 8021400:	60da      	str	r2, [r3, #12]
/* API to program the divider placed between fcpu and its parent */
void XMC_SCU_CLOCK_SetCpuClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetCpuClockDivider:Wrong clock divider value", (divider <= 2UL) );

  SCU_CLK->CPUCLKCR = (SCU_CLK->CPUCLKCR & ((uint32_t)~SCU_CLK_CPUCLKCR_CPUDIV_Msk)) |
 8021402:	691a      	ldr	r2, [r3, #16]
  }

  XMC_SCU_CLOCK_SetBackupClockCalibrationMode(config->calibration_mode);

  XMC_SCU_CLOCK_SetSystemClockDivider((uint32_t)config->fsys_clkdiv);
  XMC_SCU_CLOCK_SetCpuClockDivider((uint32_t)config->fcpu_clkdiv);
 8021404:	7c6c      	ldrb	r4, [r5, #17]
/* API to program the divider placed between fcpu and its parent */
void XMC_SCU_CLOCK_SetCpuClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetCpuClockDivider:Wrong clock divider value", (divider <= 2UL) );

  SCU_CLK->CPUCLKCR = (SCU_CLK->CPUCLKCR & ((uint32_t)~SCU_CLK_CPUCLKCR_CPUDIV_Msk)) |
 8021406:	f022 0101 	bic.w	r1, r2, #1
                      (uint32_t)((uint32_t)(divider - 1UL) << SCU_CLK_CPUCLKCR_CPUDIV_Pos);
 802140a:	1e62      	subs	r2, r4, #1
/* API to program the divider placed between fcpu and its parent */
void XMC_SCU_CLOCK_SetCpuClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetCpuClockDivider:Wrong clock divider value", (divider <= 2UL) );

  SCU_CLK->CPUCLKCR = (SCU_CLK->CPUCLKCR & ((uint32_t)~SCU_CLK_CPUCLKCR_CPUDIV_Msk)) |
 802140c:	430a      	orrs	r2, r1
 802140e:	611a      	str	r2, [r3, #16]
/* API to program the divider placed between fccu and its parent */
void XMC_SCU_CLOCK_SetCcuClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetCapcomClockDivider:Wrong clock divider value", (divider <= 2UL) );

  SCU_CLK->CCUCLKCR = (SCU_CLK->CCUCLKCR & ((uint32_t)~SCU_CLK_CCUCLKCR_CCUDIV_Msk)) |
 8021410:	6a1a      	ldr	r2, [r3, #32]

  XMC_SCU_CLOCK_SetBackupClockCalibrationMode(config->calibration_mode);

  XMC_SCU_CLOCK_SetSystemClockDivider((uint32_t)config->fsys_clkdiv);
  XMC_SCU_CLOCK_SetCpuClockDivider((uint32_t)config->fcpu_clkdiv);
  XMC_SCU_CLOCK_SetCcuClockDivider((uint32_t)config->fccu_clkdiv);
 8021412:	7cac      	ldrb	r4, [r5, #18]
/* API to program the divider placed between fccu and its parent */
void XMC_SCU_CLOCK_SetCcuClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetCapcomClockDivider:Wrong clock divider value", (divider <= 2UL) );

  SCU_CLK->CCUCLKCR = (SCU_CLK->CCUCLKCR & ((uint32_t)~SCU_CLK_CCUCLKCR_CCUDIV_Msk)) |
 8021414:	f022 0101 	bic.w	r1, r2, #1
                      (uint32_t)((uint32_t)(divider - 1UL) << SCU_CLK_CCUCLKCR_CCUDIV_Pos);
 8021418:	1e62      	subs	r2, r4, #1
/* API to program the divider placed between fccu and its parent */
void XMC_SCU_CLOCK_SetCcuClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetCapcomClockDivider:Wrong clock divider value", (divider <= 2UL) );

  SCU_CLK->CCUCLKCR = (SCU_CLK->CCUCLKCR & ((uint32_t)~SCU_CLK_CCUCLKCR_CCUDIV_Msk)) |
 802141a:	430a      	orrs	r2, r1
 802141c:	621a      	str	r2, [r3, #32]
/* API to program the divider placed between fperiph and its parent */
void XMC_SCU_CLOCK_SetPeripheralClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetPeripheralClockDivider:Wrong clock divider value", (divider <= 2UL) );

  SCU_CLK->PBCLKCR = (SCU_CLK->PBCLKCR & ((uint32_t)~SCU_CLK_PBCLKCR_PBDIV_Msk)) |
 802141e:	695a      	ldr	r2, [r3, #20]
  XMC_SCU_CLOCK_SetBackupClockCalibrationMode(config->calibration_mode);

  XMC_SCU_CLOCK_SetSystemClockDivider((uint32_t)config->fsys_clkdiv);
  XMC_SCU_CLOCK_SetCpuClockDivider((uint32_t)config->fcpu_clkdiv);
  XMC_SCU_CLOCK_SetCcuClockDivider((uint32_t)config->fccu_clkdiv);
  XMC_SCU_CLOCK_SetPeripheralClockDivider((uint32_t)config->fperipheral_clkdiv);
 8021420:	7cec      	ldrb	r4, [r5, #19]
/* API to program the divider placed between fperiph and its parent */
void XMC_SCU_CLOCK_SetPeripheralClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetPeripheralClockDivider:Wrong clock divider value", (divider <= 2UL) );

  SCU_CLK->PBCLKCR = (SCU_CLK->PBCLKCR & ((uint32_t)~SCU_CLK_PBCLKCR_PBDIV_Msk)) |
 8021422:	f022 0101 	bic.w	r1, r2, #1
                     ((uint32_t)((uint32_t)(divider - 1UL) << SCU_CLK_PBCLKCR_PBDIV_Pos));
 8021426:	1e62      	subs	r2, r4, #1
/* API to program the divider placed between fperiph and its parent */
void XMC_SCU_CLOCK_SetPeripheralClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetPeripheralClockDivider:Wrong clock divider value", (divider <= 2UL) );

  SCU_CLK->PBCLKCR = (SCU_CLK->PBCLKCR & ((uint32_t)~SCU_CLK_PBCLKCR_PBDIV_Msk)) |
 8021428:	430a      	orrs	r2, r1
 802142a:	615a      	str	r2, [r3, #20]
  XMC_SCU_CLOCK_SetSystemClockDivider((uint32_t)config->fsys_clkdiv);
  XMC_SCU_CLOCK_SetCpuClockDivider((uint32_t)config->fcpu_clkdiv);
  XMC_SCU_CLOCK_SetCcuClockDivider((uint32_t)config->fccu_clkdiv);
  XMC_SCU_CLOCK_SetPeripheralClockDivider((uint32_t)config->fperipheral_clkdiv);

  if (config->enable_oschp == true)
 802142c:	bb28      	cbnz	r0, 802147a <XMC_SCU_CLOCK_Init+0x11e>
  {
    XMC_SCU_CLOCK_EnableHighPerformanceOscillator();
    while(XMC_SCU_CLOCK_IsHighPerformanceOscillatorStable() == false);
  }

  if (config->syspll_config.mode == XMC_SCU_CLOCK_SYSPLL_MODE_DISABLED)
 802142e:	78e9      	ldrb	r1, [r5, #3]
 8021430:	b9a1      	cbnz	r1, 802145c <XMC_SCU_CLOCK_Init+0x100>
}

/* API to disable main PLL */
void XMC_SCU_CLOCK_DisableSystemPll(void)
{
  SCU_PLL->PLLCON0 |= (uint32_t)(SCU_PLL_PLLCON0_VCOPWD_Msk | SCU_PLL_PLLCON0_PLLPWD_Msk);
 8021432:	4a47      	ldr	r2, [pc, #284]	; (8021550 <XMC_SCU_CLOCK_Init+0x1f4>)
 8021434:	6853      	ldr	r3, [r2, #4]
 8021436:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 802143a:	f043 0302 	orr.w	r3, r3, #2
 802143e:	6053      	str	r3, [r2, #4]
                                 (uint32_t)config->syspll_config.n_div,
                                 (uint32_t)config->syspll_config.k_div);
  }

  /* use SYSPLL? */
  if (config->fsys_clksrc == XMC_SCU_CLOCK_SYSCLKSRC_PLL)
 8021440:	68eb      	ldr	r3, [r5, #12]
 8021442:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8021446:	d104      	bne.n	8021452 <XMC_SCU_CLOCK_Init+0xf6>
}

/* API to select fSYS */
void XMC_SCU_CLOCK_SetSystemClockSource(const XMC_SCU_CLOCK_SYSCLKSRC_t source)
{
  SCU_CLK->SYSCLKCR = (SCU_CLK->SYSCLKCR & ((uint32_t)~SCU_CLK_SYSCLKCR_SYSSEL_Msk)) |
 8021448:	4a3c      	ldr	r2, [pc, #240]	; (802153c <XMC_SCU_CLOCK_Init+0x1e0>)
 802144a:	68d3      	ldr	r3, [r2, #12]
 802144c:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8021450:	60d3      	str	r3, [r2, #12]
  if (config->fsys_clksrc == XMC_SCU_CLOCK_SYSCLKSRC_PLL)
  {
    XMC_SCU_CLOCK_SetSystemClockSource(XMC_SCU_CLOCK_SYSCLKSRC_PLL);    
  }
  SystemCoreClockUpdate();
}
 8021452:	b003      	add	sp, #12
 8021454:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  /* use SYSPLL? */
  if (config->fsys_clksrc == XMC_SCU_CLOCK_SYSCLKSRC_PLL)
  {
    XMC_SCU_CLOCK_SetSystemClockSource(XMC_SCU_CLOCK_SYSCLKSRC_PLL);    
  }
  SystemCoreClockUpdate();
 8021458:	f7ff b9a8 	b.w	80207ac <SystemCoreClockUpdate>
}

/* API to enable main PLL */
void XMC_SCU_CLOCK_EnableSystemPll(void)
{
  SCU_PLL->PLLCON0 &= (uint32_t)~(SCU_PLL_PLLCON0_VCOPWD_Msk | SCU_PLL_PLLCON0_PLLPWD_Msk);
 802145c:	4a3c      	ldr	r2, [pc, #240]	; (8021550 <XMC_SCU_CLOCK_Init+0x1f4>)
  }
  else
  {

    XMC_SCU_CLOCK_EnableSystemPll();
    XMC_SCU_CLOCK_StartSystemPll(config->syspll_config.clksrc,
 802145e:	88a8      	ldrh	r0, [r5, #4]
}

/* API to enable main PLL */
void XMC_SCU_CLOCK_EnableSystemPll(void)
{
  SCU_PLL->PLLCON0 &= (uint32_t)~(SCU_PLL_PLLCON0_VCOPWD_Msk | SCU_PLL_PLLCON0_PLLPWD_Msk);
 8021460:	6853      	ldr	r3, [r2, #4]
 8021462:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8021466:	f023 0302 	bic.w	r3, r3, #2
 802146a:	6053      	str	r3, [r2, #4]
  }
  else
  {

    XMC_SCU_CLOCK_EnableSystemPll();
    XMC_SCU_CLOCK_StartSystemPll(config->syspll_config.clksrc,
 802146c:	78ac      	ldrb	r4, [r5, #2]
 802146e:	786a      	ldrb	r2, [r5, #1]
 8021470:	782b      	ldrb	r3, [r5, #0]
 8021472:	9400      	str	r4, [sp, #0]
 8021474:	f7ff fe98 	bl	80211a8 <XMC_SCU_CLOCK_StartSystemPll>
 8021478:	e7e2      	b.n	8021440 <XMC_SCU_CLOCK_Init+0xe4>
}

/* API to enable High Precision High Speed oscillator */
void XMC_SCU_CLOCK_EnableHighPerformanceOscillator(void)
{
  SCU_PLL->PLLCON0 &= (uint32_t)~SCU_PLL_PLLCON0_PLLPWD_Msk;
 802147a:	4c35      	ldr	r4, [pc, #212]	; (8021550 <XMC_SCU_CLOCK_Init+0x1f4>)

  SCU_OSC->OSCHPCTRL = (uint32_t)((SCU_OSC->OSCHPCTRL & ~(SCU_OSC_OSCHPCTRL_MODE_Msk | SCU_OSC_OSCHPCTRL_OSCVAL_Msk)) |
 802147c:	4f37      	ldr	r7, [pc, #220]	; (802155c <XMC_SCU_CLOCK_Init+0x200>)
}

/* API to enable High Precision High Speed oscillator */
void XMC_SCU_CLOCK_EnableHighPerformanceOscillator(void)
{
  SCU_PLL->PLLCON0 &= (uint32_t)~SCU_PLL_PLLCON0_PLLPWD_Msk;
 802147e:	6863      	ldr	r3, [r4, #4]
 8021480:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8021484:	6063      	str	r3, [r4, #4]

  SCU_OSC->OSCHPCTRL = (uint32_t)((SCU_OSC->OSCHPCTRL & ~(SCU_OSC_OSCHPCTRL_MODE_Msk | SCU_OSC_OSCHPCTRL_OSCVAL_Msk)) |
 8021486:	687e      	ldr	r6, [r7, #4]
                                  (((OSCHP_GetFrequency() / FOSCREF) - 1UL) << SCU_OSC_OSCHPCTRL_OSCVAL_Pos));
 8021488:	f006 fb02 	bl	8027a90 <OSCHP_GetFrequency>
 802148c:	4a34      	ldr	r2, [pc, #208]	; (8021560 <XMC_SCU_CLOCK_Init+0x204>)
 802148e:	fba2 3200 	umull	r3, r2, r2, r0
 8021492:	0d12      	lsrs	r2, r2, #20
/* API to enable High Precision High Speed oscillator */
void XMC_SCU_CLOCK_EnableHighPerformanceOscillator(void)
{
  SCU_PLL->PLLCON0 &= (uint32_t)~SCU_PLL_PLLCON0_PLLPWD_Msk;

  SCU_OSC->OSCHPCTRL = (uint32_t)((SCU_OSC->OSCHPCTRL & ~(SCU_OSC_OSCHPCTRL_MODE_Msk | SCU_OSC_OSCHPCTRL_OSCVAL_Msk)) |
 8021494:	f426 2370 	bic.w	r3, r6, #983040	; 0xf0000
                                  (((OSCHP_GetFrequency() / FOSCREF) - 1UL) << SCU_OSC_OSCHPCTRL_OSCVAL_Pos));
 8021498:	3a01      	subs	r2, #1
/* API to enable High Precision High Speed oscillator */
void XMC_SCU_CLOCK_EnableHighPerformanceOscillator(void)
{
  SCU_PLL->PLLCON0 &= (uint32_t)~SCU_PLL_PLLCON0_PLLPWD_Msk;

  SCU_OSC->OSCHPCTRL = (uint32_t)((SCU_OSC->OSCHPCTRL & ~(SCU_OSC_OSCHPCTRL_MODE_Msk | SCU_OSC_OSCHPCTRL_OSCVAL_Msk)) |
 802149a:	f023 0330 	bic.w	r3, r3, #48	; 0x30
 802149e:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 80214a2:	607b      	str	r3, [r7, #4]
                                  (((OSCHP_GetFrequency() / FOSCREF) - 1UL) << SCU_OSC_OSCHPCTRL_OSCVAL_Pos));

  /* restart OSC Watchdog */
  SCU_PLL->PLLCON0 &= (uint32_t)~SCU_PLL_PLLCON0_OSCRES_Msk;
 80214a4:	6863      	ldr	r3, [r4, #4]
 80214a6:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
 80214aa:	6063      	str	r3, [r4, #4]
}

bool XMC_SCU_CLOCK_IsHighPerformanceOscillatorStable(void)
{
  return ((SCU_PLL->PLLSTAT & XMC_SCU_PLL_PLLSTAT_OSC_USABLE) == XMC_SCU_PLL_PLLSTAT_OSC_USABLE);
 80214ac:	4622      	mov	r2, r4
 80214ae:	6813      	ldr	r3, [r2, #0]
 80214b0:	f403 7360 	and.w	r3, r3, #896	; 0x380
  XMC_SCU_CLOCK_SetPeripheralClockDivider((uint32_t)config->fperipheral_clkdiv);

  if (config->enable_oschp == true)
  {
    XMC_SCU_CLOCK_EnableHighPerformanceOscillator();
    while(XMC_SCU_CLOCK_IsHighPerformanceOscillatorStable() == false);
 80214b4:	f5b3 7f60 	cmp.w	r3, #896	; 0x380
 80214b8:	d1f9      	bne.n	80214ae <XMC_SCU_CLOCK_Init+0x152>
 80214ba:	e7b8      	b.n	802142e <XMC_SCU_CLOCK_Init+0xd2>

/* API to configure the 32khz Ultra Low Power oscillator */
void XMC_SCU_CLOCK_EnableLowPowerOscillator(void)
{
  /* Enable OSC_ULP */
  while((SCU_GENERAL->MIRRSTS) & SCU_GENERAL_MIRRSTS_OSCULCTRL_Msk)
 80214bc:	4a22      	ldr	r2, [pc, #136]	; (8021548 <XMC_SCU_CLOCK_Init+0x1ec>)
 80214be:	f8d2 30c4 	ldr.w	r3, [r2, #196]	; 0xc4
 80214c2:	061e      	lsls	r6, r3, #24
 80214c4:	d4fb      	bmi.n	80214be <XMC_SCU_CLOCK_Init+0x162>
  {
    /* Wait until no pending update to OSCULCTRL register in hibernate domain */
  }
  SCU_HIBERNATE->OSCULCTRL &= ~SCU_HIBERNATE_OSCULCTRL_MODE_Msk;
 80214c6:	4921      	ldr	r1, [pc, #132]	; (802154c <XMC_SCU_CLOCK_Init+0x1f0>)

  /* Enable OSC_ULP Oscillator Watchdog*/
  while (SCU_GENERAL->MIRRSTS & SCU_GENERAL_MIRRSTS_HDCR_Msk)
 80214c8:	4a1f      	ldr	r2, [pc, #124]	; (8021548 <XMC_SCU_CLOCK_Init+0x1ec>)
  /* Enable OSC_ULP */
  while((SCU_GENERAL->MIRRSTS) & SCU_GENERAL_MIRRSTS_OSCULCTRL_Msk)
  {
    /* Wait until no pending update to OSCULCTRL register in hibernate domain */
  }
  SCU_HIBERNATE->OSCULCTRL &= ~SCU_HIBERNATE_OSCULCTRL_MODE_Msk;
 80214ca:	69cb      	ldr	r3, [r1, #28]
 80214cc:	f023 0330 	bic.w	r3, r3, #48	; 0x30
 80214d0:	61cb      	str	r3, [r1, #28]

  /* Enable OSC_ULP Oscillator Watchdog*/
  while (SCU_GENERAL->MIRRSTS & SCU_GENERAL_MIRRSTS_HDCR_Msk)
 80214d2:	f8d2 30c4 	ldr.w	r3, [r2, #196]	; 0xc4
 80214d6:	071c      	lsls	r4, r3, #28
 80214d8:	d4fb      	bmi.n	80214d2 <XMC_SCU_CLOCK_Init+0x176>
  {
    /* check SCU_MIRRSTS to ensure that no transfer over serial interface is pending */
  }
  SCU_HIBERNATE->HDCR |= (uint32_t)SCU_HIBERNATE_HDCR_ULPWDGEN_Msk;
 80214da:	491c      	ldr	r1, [pc, #112]	; (802154c <XMC_SCU_CLOCK_Init+0x1f0>)

  /* Enable OSC_ULP Oscillator Watchdog*/
  while (SCU_GENERAL->MIRRSTS & SCU_GENERAL_MIRRSTS_HDSET_Msk)
 80214dc:	4a1a      	ldr	r2, [pc, #104]	; (8021548 <XMC_SCU_CLOCK_Init+0x1ec>)
  /* Enable OSC_ULP Oscillator Watchdog*/
  while (SCU_GENERAL->MIRRSTS & SCU_GENERAL_MIRRSTS_HDCR_Msk)
  {
    /* check SCU_MIRRSTS to ensure that no transfer over serial interface is pending */
  }
  SCU_HIBERNATE->HDCR |= (uint32_t)SCU_HIBERNATE_HDCR_ULPWDGEN_Msk;
 80214de:	68cb      	ldr	r3, [r1, #12]
 80214e0:	f043 0308 	orr.w	r3, r3, #8
 80214e4:	60cb      	str	r3, [r1, #12]

  /* Enable OSC_ULP Oscillator Watchdog*/
  while (SCU_GENERAL->MIRRSTS & SCU_GENERAL_MIRRSTS_HDSET_Msk)
 80214e6:	f8d2 30c4 	ldr.w	r3, [r2, #196]	; 0xc4
 80214ea:	0758      	lsls	r0, r3, #29
 80214ec:	d4fb      	bmi.n	80214e6 <XMC_SCU_CLOCK_Init+0x18a>
  {
    /* check SCU_MIRRSTS to ensure that no transfer over serial interface is pending */
  }
  SCU_HIBERNATE->HDSET = (uint32_t)SCU_HIBERNATE_HDSET_ULPWDG_Msk;
 80214ee:	4b17      	ldr	r3, [pc, #92]	; (802154c <XMC_SCU_CLOCK_Init+0x1f0>)
 80214f0:	4a15      	ldr	r2, [pc, #84]	; (8021548 <XMC_SCU_CLOCK_Init+0x1ec>)
 80214f2:	2108      	movs	r1, #8
 80214f4:	6099      	str	r1, [r3, #8]
 80214f6:	f8d2 30c4 	ldr.w	r3, [r2, #196]	; 0xc4

  while (XMC_SCU_GetMirrorStatus() != 0)
 80214fa:	2b00      	cmp	r3, #0
 80214fc:	d1fb      	bne.n	80214f6 <XMC_SCU_CLOCK_Init+0x19a>

#endif

bool XMC_SCU_CLOCK_IsLowPowerOscillatorStable(void)
{
  return ((SCU_HIBERNATE->HDSTAT & SCU_HIBERNATE_HDSTAT_ULPWDG_Msk) == 0UL);
 80214fe:	4a13      	ldr	r2, [pc, #76]	; (802154c <XMC_SCU_CLOCK_Init+0x1f0>)
 8021500:	6813      	ldr	r3, [r2, #0]
  XMC_SCU_HIB_EnableHibernateDomain();

  if (config->enable_osculp == true)
  {
    XMC_SCU_CLOCK_EnableLowPowerOscillator();
    while (XMC_SCU_CLOCK_IsLowPowerOscillatorStable() == false);
 8021502:	0719      	lsls	r1, r3, #28
 8021504:	d4fc      	bmi.n	8021500 <XMC_SCU_CLOCK_Init+0x1a4>
 8021506:	e748      	b.n	802139a <XMC_SCU_CLOCK_Init+0x3e>
  SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_FOTR_Msk;

  if (mode == XMC_SCU_CLOCK_FOFI_CALIBRATION_MODE_AUTOMATIC)
  {
    /* Disable factory calibration based trimming */
    SCU_PLL->PLLCON0 &= (uint32_t)~SCU_PLL_PLLCON0_FOTR_Msk;
 8021508:	6853      	ldr	r3, [r2, #4]
void XMC_SCU_lDelay(uint32_t delay)
{
  uint32_t i;

  SystemCoreClockUpdate();
  delay =  delay * (uint32_t)(SystemCoreClock / FREQ_1MHZ);
 802150a:	4e12      	ldr	r6, [pc, #72]	; (8021554 <XMC_SCU_CLOCK_Init+0x1f8>)
  SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_FOTR_Msk;

  if (mode == XMC_SCU_CLOCK_FOFI_CALIBRATION_MODE_AUTOMATIC)
  {
    /* Disable factory calibration based trimming */
    SCU_PLL->PLLCON0 &= (uint32_t)~SCU_PLL_PLLCON0_FOTR_Msk;
 802150c:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
 8021510:	6053      	str	r3, [r2, #4]
/* This is a local function used to generate the delay until register get updated with new configured value.  */
void XMC_SCU_lDelay(uint32_t delay)
{
  uint32_t i;

  SystemCoreClockUpdate();
 8021512:	f7ff f94b 	bl	80207ac <SystemCoreClockUpdate>
  delay =  delay * (uint32_t)(SystemCoreClock / FREQ_1MHZ);
 8021516:	4a10      	ldr	r2, [pc, #64]	; (8021558 <XMC_SCU_CLOCK_Init+0x1fc>)
 8021518:	6833      	ldr	r3, [r6, #0]
 802151a:	fba2 2303 	umull	r2, r3, r2, r3
 802151e:	0c9a      	lsrs	r2, r3, #18
 8021520:	2364      	movs	r3, #100	; 0x64
 8021522:	fb03 f302 	mul.w	r3, r3, r2

  for (i = 0U; i < delay; ++i)
 8021526:	b11b      	cbz	r3, 8021530 <XMC_SCU_CLOCK_Init+0x1d4>
  {
    __NOP();
 8021528:	bf00      	nop
  uint32_t i;

  SystemCoreClockUpdate();
  delay =  delay * (uint32_t)(SystemCoreClock / FREQ_1MHZ);

  for (i = 0U; i < delay; ++i)
 802152a:	3401      	adds	r4, #1
 802152c:	429c      	cmp	r4, r3
 802152e:	d1fb      	bne.n	8021528 <XMC_SCU_CLOCK_Init+0x1cc>
    /* Disable factory calibration based trimming */
    SCU_PLL->PLLCON0 &= (uint32_t)~SCU_PLL_PLLCON0_FOTR_Msk;
    XMC_SCU_lDelay(100UL);

    /* Enable automatic calibration */
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_AOTREN_Msk;
 8021530:	4a07      	ldr	r2, [pc, #28]	; (8021550 <XMC_SCU_CLOCK_Init+0x1f4>)
 8021532:	6853      	ldr	r3, [r2, #4]
 8021534:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 8021538:	6053      	str	r3, [r2, #4]
 802153a:	e749      	b.n	80213d0 <XMC_SCU_CLOCK_Init+0x74>
 802153c:	50004600 	.word	0x50004600
 8021540:	50004200 	.word	0x50004200
 8021544:	50004400 	.word	0x50004400
 8021548:	50004000 	.word	0x50004000
 802154c:	50004300 	.word	0x50004300
 8021550:	50004710 	.word	0x50004710
 8021554:	2003ffc0 	.word	0x2003ffc0
 8021558:	431bde83 	.word	0x431bde83
 802155c:	50004700 	.word	0x50004700
 8021560:	6b5fca6b 	.word	0x6b5fca6b

08021564 <XMC_CCU4_Init>:
#endif
}

/* API to initialize CCU4 global resources  */
void XMC_CCU4_Init(XMC_CCU4_MODULE_t *const module, const XMC_CCU4_SLICE_MCMS_ACTION_t mcs_action)
{
 8021564:	b538      	push	{r3, r4, r5, lr}
 8021566:	4604      	mov	r4, r0
{
  XMC_ASSERT("XMC_CCU4_EnableModule:Invalid Module Pointer", XMC_CCU4_IsValidModule(module));

#if UC_FAMILY == XMC4
  /* Enable CCU4 module clock */
  XMC_SCU_CLOCK_EnableClock(XMC_SCU_CLOCK_CCU);
 8021568:	2010      	movs	r0, #16
#endif
}

/* API to initialize CCU4 global resources  */
void XMC_CCU4_Init(XMC_CCU4_MODULE_t *const module, const XMC_CCU4_SLICE_MCMS_ACTION_t mcs_action)
{
 802156a:	460d      	mov	r5, r1
{
  XMC_ASSERT("XMC_CCU4_EnableModule:Invalid Module Pointer", XMC_CCU4_IsValidModule(module));

#if UC_FAMILY == XMC4
  /* Enable CCU4 module clock */
  XMC_SCU_CLOCK_EnableClock(XMC_SCU_CLOCK_CCU);
 802156c:	f7ff fdbc 	bl	80210e8 <XMC_SCU_CLOCK_EnableClock>
  }
}

__STATIC_INLINE void XMC_CCU4_lUngateClock(const XMC_CCU4_MODULE_t *const module)
{
  if (module == CCU40)
 8021570:	4b19      	ldr	r3, [pc, #100]	; (80215d8 <XMC_CCU4_Init+0x74>)
 8021572:	429c      	cmp	r4, r3
 8021574:	d01a      	beq.n	80215ac <XMC_CCU4_Init+0x48>
  {
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_CCU40);
  }
#if defined(CCU41)
  else if (module == CCU41)
 8021576:	4b19      	ldr	r3, [pc, #100]	; (80215dc <XMC_CCU4_Init+0x78>)
 8021578:	429c      	cmp	r4, r3
 802157a:	d01e      	beq.n	80215ba <XMC_CCU4_Init+0x56>
  {
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_CCU41);
  }
#endif
#if defined(CCU42)
  else if (module == CCU42)
 802157c:	4b18      	ldr	r3, [pc, #96]	; (80215e0 <XMC_CCU4_Init+0x7c>)
 802157e:	429c      	cmp	r4, r3
 8021580:	d022      	beq.n	80215c8 <XMC_CCU4_Init+0x64>
  {
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_CCU42);
  }
#endif
#if defined(CCU43)
  else if (module == CCU43)
 8021582:	4b18      	ldr	r3, [pc, #96]	; (80215e4 <XMC_CCU4_Init+0x80>)
 8021584:	429c      	cmp	r4, r3
 8021586:	d00a      	beq.n	802159e <XMC_CCU4_Init+0x3a>
 * XMC_CCU4_StopPrescaler().
 */
__STATIC_INLINE void XMC_CCU4_StartPrescaler(XMC_CCU4_MODULE_t *const module)
{
  XMC_ASSERT("XMC_CCU4_StartPrescaler:Invalid Module Pointer", XMC_CCU4_IsValidModule(module));
  module->GIDLC |= (uint32_t) CCU4_GIDLC_SPRB_Msk;
 8021588:	68e3      	ldr	r3, [r4, #12]
 802158a:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 802158e:	60e3      	str	r3, [r4, #12]
  /* Enable CCU4 module */
  XMC_CCU4_EnableModule(module);
  /* Start the prescaler */
  XMC_CCU4_StartPrescaler(module);
  
  gctrl = module->GCTRL;
 8021590:	6821      	ldr	r1, [r4, #0]
  gctrl &= ~((uint32_t) CCU4_GCTRL_MSDE_Msk);
 8021592:	f421 4140 	bic.w	r1, r1, #49152	; 0xc000
  gctrl |= ((uint32_t) mcs_action) << CCU4_GCTRL_MSDE_Pos;
 8021596:	ea41 3185 	orr.w	r1, r1, r5, lsl #14
  
  module->GCTRL = gctrl;
 802159a:	6021      	str	r1, [r4, #0]
 802159c:	bd38      	pop	{r3, r4, r5, pc}
  }
#endif
#if defined(CCU43)
  else if (module == CCU43)
  {
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_CCU43);
 802159e:	4812      	ldr	r0, [pc, #72]	; (80215e8 <XMC_CCU4_Init+0x84>)
 80215a0:	f7ff fdb4 	bl	802110c <XMC_SCU_CLOCK_UngatePeripheralClock>
  }
#endif
#if defined(CCU43)
  else if (module == CCU43)
  {
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_CCU43);
 80215a4:	4810      	ldr	r0, [pc, #64]	; (80215e8 <XMC_CCU4_Init+0x84>)
 80215a6:	f7ff fd35 	bl	8021014 <XMC_SCU_RESET_DeassertPeripheralReset>
 80215aa:	e7ed      	b.n	8021588 <XMC_CCU4_Init+0x24>

__STATIC_INLINE void XMC_CCU4_lUngateClock(const XMC_CCU4_MODULE_t *const module)
{
  if (module == CCU40)
  {
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_CCU40);
 80215ac:	2004      	movs	r0, #4
 80215ae:	f7ff fdad 	bl	802110c <XMC_SCU_CLOCK_UngatePeripheralClock>

__STATIC_INLINE void XMC_CCU4_lDeassertReset(const XMC_CCU4_MODULE_t *const module)
{
  if (module == CCU40)
  {
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_CCU40);
 80215b2:	2004      	movs	r0, #4
 80215b4:	f7ff fd2e 	bl	8021014 <XMC_SCU_RESET_DeassertPeripheralReset>
 80215b8:	e7e6      	b.n	8021588 <XMC_CCU4_Init+0x24>
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_CCU40);
  }
#if defined(CCU41)
  else if (module == CCU41)
  {
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_CCU41);
 80215ba:	2008      	movs	r0, #8
 80215bc:	f7ff fda6 	bl	802110c <XMC_SCU_CLOCK_UngatePeripheralClock>
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_CCU40);
  }
#if defined(CCU41)
  else if (module == CCU41)
  {
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_CCU41);
 80215c0:	2008      	movs	r0, #8
 80215c2:	f7ff fd27 	bl	8021014 <XMC_SCU_RESET_DeassertPeripheralReset>
 80215c6:	e7df      	b.n	8021588 <XMC_CCU4_Init+0x24>
  }
#endif
#if defined(CCU42)
  else if (module == CCU42)
  {
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_CCU42);
 80215c8:	2010      	movs	r0, #16
 80215ca:	f7ff fd9f 	bl	802110c <XMC_SCU_CLOCK_UngatePeripheralClock>
  }
#endif
#if defined(CCU42)
  else if (module == CCU42)
  {
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_CCU42);
 80215ce:	2010      	movs	r0, #16
 80215d0:	f7ff fd20 	bl	8021014 <XMC_SCU_RESET_DeassertPeripheralReset>
 80215d4:	e7d8      	b.n	8021588 <XMC_CCU4_Init+0x24>
 80215d6:	bf00      	nop
 80215d8:	4000c000 	.word	0x4000c000
 80215dc:	40010000 	.word	0x40010000
 80215e0:	40014000 	.word	0x40014000
 80215e4:	48004000 	.word	0x48004000
 80215e8:	10000001 	.word	0x10000001

080215ec <XMC_CCU4_SLICE_CompareInit>:
}

/* API to configure CC4 Slice as Timer */
void XMC_CCU4_SLICE_CompareInit(XMC_CCU4_SLICE_t *const slice,
                                const XMC_CCU4_SLICE_COMPARE_CONFIG_t *const compare_init)
{
 80215ec:	b470      	push	{r4, r5, r6}
             (XMC_CCU4_SLICE_COMPARE_CONFIG_t *) NULL != compare_init);

  /* Program the timer mode */
  slice->TC = compare_init->tc;
  /* Enable the timer concatenation */
  slice->CMC = ((uint32_t) compare_init->timer_concatenation << CCU4_CC4_CMC_TCE_Pos);
 80215ee:	794b      	ldrb	r3, [r1, #5]
  /* Program initial prescaler divider value */
  slice->PSC = (uint32_t) compare_init->prescaler_initval;
 80215f0:	790e      	ldrb	r6, [r1, #4]
  XMC_ASSERT("XMC_CCU4_SLICE_CompareInit:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_CompareInit:Compare Init Pointer is NULL",
             (XMC_CCU4_SLICE_COMPARE_CONFIG_t *) NULL != compare_init);

  /* Program the timer mode */
  slice->TC = compare_init->tc;
 80215f2:	6809      	ldr	r1, [r1, #0]
 80215f4:	6141      	str	r1, [r0, #20]
  /* Program initial prescaler divider value */
  slice->PSC = (uint32_t) compare_init->prescaler_initval;
  /* Program the dither compare value */
  slice->DITS = (uint32_t) compare_init->dither_limit;
  /* Program timer output passive level */
  slice->PSL = (uint32_t) compare_init->passive_level;
 80215f6:	461c      	mov	r4, r3
  /* Enable the timer concatenation */
  slice->CMC = ((uint32_t) compare_init->timer_concatenation << CCU4_CC4_CMC_TCE_Pos);
  /* Program initial prescaler divider value */
  slice->PSC = (uint32_t) compare_init->prescaler_initval;
  /* Program the dither compare value */
  slice->DITS = (uint32_t) compare_init->dither_limit;
 80215f8:	461d      	mov	r5, r3
  /* Program timer output passive level */
  slice->PSL = (uint32_t) compare_init->passive_level;
  /* Program floating prescaler compare value */
  slice->FPCS = (uint32_t) compare_init->float_limit;
 80215fa:	4632      	mov	r2, r6
             (XMC_CCU4_SLICE_COMPARE_CONFIG_t *) NULL != compare_init);

  /* Program the timer mode */
  slice->TC = compare_init->tc;
  /* Enable the timer concatenation */
  slice->CMC = ((uint32_t) compare_init->timer_concatenation << CCU4_CC4_CMC_TCE_Pos);
 80215fc:	f3c3 1340 	ubfx	r3, r3, #5, #1
  /* Program initial prescaler divider value */
  slice->PSC = (uint32_t) compare_init->prescaler_initval;
 8021600:	f006 060f 	and.w	r6, r6, #15
  /* Program the dither compare value */
  slice->DITS = (uint32_t) compare_init->dither_limit;
 8021604:	f005 050f 	and.w	r5, r5, #15
  /* Program timer output passive level */
  slice->PSL = (uint32_t) compare_init->passive_level;
 8021608:	f3c4 1100 	ubfx	r1, r4, #4, #1
             (XMC_CCU4_SLICE_COMPARE_CONFIG_t *) NULL != compare_init);

  /* Program the timer mode */
  slice->TC = compare_init->tc;
  /* Enable the timer concatenation */
  slice->CMC = ((uint32_t) compare_init->timer_concatenation << CCU4_CC4_CMC_TCE_Pos);
 802160c:	051b      	lsls	r3, r3, #20
  /* Program the dither compare value */
  slice->DITS = (uint32_t) compare_init->dither_limit;
  /* Program timer output passive level */
  slice->PSL = (uint32_t) compare_init->passive_level;
  /* Program floating prescaler compare value */
  slice->FPCS = (uint32_t) compare_init->float_limit;
 802160e:	0912      	lsrs	r2, r2, #4
             (XMC_CCU4_SLICE_COMPARE_CONFIG_t *) NULL != compare_init);

  /* Program the timer mode */
  slice->TC = compare_init->tc;
  /* Enable the timer concatenation */
  slice->CMC = ((uint32_t) compare_init->timer_concatenation << CCU4_CC4_CMC_TCE_Pos);
 8021610:	6043      	str	r3, [r0, #4]
  /* Program initial prescaler divider value */
  slice->PSC = (uint32_t) compare_init->prescaler_initval;
 8021612:	6246      	str	r6, [r0, #36]	; 0x24
  /* Program the dither compare value */
  slice->DITS = (uint32_t) compare_init->dither_limit;
 8021614:	6205      	str	r5, [r0, #32]
  /* Program timer output passive level */
  slice->PSL = (uint32_t) compare_init->passive_level;
 8021616:	6181      	str	r1, [r0, #24]
  /* Program floating prescaler compare value */
  slice->FPCS = (uint32_t) compare_init->float_limit;
}
 8021618:	bc70      	pop	{r4, r5, r6}
  /* Program the dither compare value */
  slice->DITS = (uint32_t) compare_init->dither_limit;
  /* Program timer output passive level */
  slice->PSL = (uint32_t) compare_init->passive_level;
  /* Program floating prescaler compare value */
  slice->FPCS = (uint32_t) compare_init->float_limit;
 802161a:	62c2      	str	r2, [r0, #44]	; 0x2c
}
 802161c:	4770      	bx	lr
 802161e:	bf00      	nop

08021620 <XMC_CCU4_SLICE_SetPrescaler>:
{
  uint32_t fpc;
  
  XMC_ASSERT("XMC_CCU4_SLICE_SetPrescaler:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));

  fpc = slice->FPC;
 8021620:	6a83      	ldr	r3, [r0, #40]	; 0x28
  fpc &= ~((uint32_t) CCU4_CC4_FPC_PVAL_Msk);
 8021622:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
  fpc |= ((uint32_t) div_val) << CCU4_CC4_FPC_PVAL_Pos;
 8021626:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
  slice->FPC = fpc;
 802162a:	6283      	str	r3, [r0, #40]	; 0x28
  /* 
   * In any case, update the initial value of the divider which is to be loaded once the prescaler increments to the 
   * compare value.
   */
  slice->PSC = (uint32_t) div_val;
 802162c:	6241      	str	r1, [r0, #36]	; 0x24
 802162e:	4770      	bx	lr

08021630 <XMC_CCU4_SLICE_SetInterruptNode>:

/* Binds a capcom event to an NVIC node  */
void XMC_CCU4_SLICE_SetInterruptNode(XMC_CCU4_SLICE_t *const slice,
                                     const XMC_CCU4_SLICE_IRQ_ID_t event,
                                     const XMC_CCU4_SLICE_SR_ID_t sr)
{
 8021630:	2909      	cmp	r1, #9
 8021632:	b430      	push	{r4, r5}

  XMC_ASSERT("XMC_CCU4_SLICE_SetInterruptNode:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_SetInterruptNode:Invalid SR ID ", XMC_CCU4_SLICE_CHECK_SR_ID(sr));
  XMC_ASSERT("XMC_CCU4_SLICE_SetInterruptNode:Invalid event", XMC_CCU4_SLICE_CHECK_INTERRUPT(event));
  
  srs = slice->SRS;
 8021634:	f8d0 40a8 	ldr.w	r4, [r0, #168]	; 0xa8
 8021638:	d80d      	bhi.n	8021656 <XMC_CCU4_SLICE_SetInterruptNode+0x26>
 802163a:	4b09      	ldr	r3, [pc, #36]	; (8021660 <XMC_CCU4_SLICE_SetInterruptNode+0x30>)
 802163c:	4d09      	ldr	r5, [pc, #36]	; (8021664 <XMC_CCU4_SLICE_SetInterruptNode+0x34>)
 802163e:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8021642:	f855 1021 	ldr.w	r1, [r5, r1, lsl #2]
 8021646:	43db      	mvns	r3, r3
      mask = ((uint32_t) CCU4_CC4_SRS_E2SR_Msk);
      pos  = CCU4_CC4_SRS_E2SR_Pos;
      break;
  }
  
  srs &= ~mask; 
 8021648:	4023      	ands	r3, r4
  srs |= (uint32_t)sr << pos;
 802164a:	408a      	lsls	r2, r1
 802164c:	431a      	orrs	r2, r3
  slice->SRS = srs;
 802164e:	f8c0 20a8 	str.w	r2, [r0, #168]	; 0xa8
}
 8021652:	bc30      	pop	{r4, r5}
 8021654:	4770      	bx	lr

  XMC_ASSERT("XMC_CCU4_SLICE_SetInterruptNode:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_SetInterruptNode:Invalid SR ID ", XMC_CCU4_SLICE_CHECK_SR_ID(sr));
  XMC_ASSERT("XMC_CCU4_SLICE_SetInterruptNode:Invalid event", XMC_CCU4_SLICE_CHECK_INTERRUPT(event));
  
  srs = slice->SRS;
 8021656:	210c      	movs	r1, #12
 8021658:	f46f 5340 	mvn.w	r3, #12288	; 0x3000
 802165c:	e7f4      	b.n	8021648 <XMC_CCU4_SLICE_SetInterruptNode+0x18>
 802165e:	bf00      	nop
 8021660:	0802d77c 	.word	0x0802d77c
 8021664:	0802d754 	.word	0x0802d754

08021668 <XMC_CCU8_Init>:
#endif
}

/* API to initialize CCU8 global resources  */
void XMC_CCU8_Init(XMC_CCU8_MODULE_t *const module, const XMC_CCU8_SLICE_MCMS_ACTION_t mcs_action)
{
 8021668:	b538      	push	{r3, r4, r5, lr}
 802166a:	4604      	mov	r4, r0
{
  XMC_ASSERT("XMC_CCU8_EnableModule:Invalid Module Pointer", XMC_CCU8_IsValidModule(module));

#if (UC_FAMILY == XMC4)
  /* Enable CCU8 module clock */
  XMC_SCU_CLOCK_EnableClock(XMC_SCU_CLOCK_CCU);
 802166c:	2010      	movs	r0, #16
#endif
}

/* API to initialize CCU8 global resources  */
void XMC_CCU8_Init(XMC_CCU8_MODULE_t *const module, const XMC_CCU8_SLICE_MCMS_ACTION_t mcs_action)
{
 802166e:	460d      	mov	r5, r1
{
  XMC_ASSERT("XMC_CCU8_EnableModule:Invalid Module Pointer", XMC_CCU8_IsValidModule(module));

#if (UC_FAMILY == XMC4)
  /* Enable CCU8 module clock */
  XMC_SCU_CLOCK_EnableClock(XMC_SCU_CLOCK_CCU);
 8021670:	f7ff fd3a 	bl	80210e8 <XMC_SCU_CLOCK_EnableClock>
  }
}

__STATIC_INLINE void XMC_CCU8_lUngateClock(XMC_CCU8_MODULE_t *const module)
{
  if (module == CCU80)
 8021674:	4b10      	ldr	r3, [pc, #64]	; (80216b8 <XMC_CCU8_Init+0x50>)
 8021676:	429c      	cmp	r4, r3
 8021678:	d016      	beq.n	80216a8 <XMC_CCU8_Init+0x40>
  {
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_CCU80);
  }
#if defined(CCU81)
  else if (module == CCU81)
 802167a:	4b10      	ldr	r3, [pc, #64]	; (80216bc <XMC_CCU8_Init+0x54>)
 802167c:	429c      	cmp	r4, r3
 802167e:	d00a      	beq.n	8021696 <XMC_CCU8_Init+0x2e>
 *  XMC_CCU8_StopPrescaler().
 */
__STATIC_INLINE void XMC_CCU8_StartPrescaler(XMC_CCU8_MODULE_t *const module)
{
  XMC_ASSERT("XMC_CCU8_StartPrescaler:Invalid Module Pointer", XMC_CCU8_IsValidModule(module));
  module->GIDLC |= (uint32_t) CCU8_GIDLC_SPRB_Msk;
 8021680:	68e3      	ldr	r3, [r4, #12]
 8021682:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8021686:	60e3      	str	r3, [r4, #12]
  /* Enable CCU8 module */
  XMC_CCU8_EnableModule(module);
  /* Start the prescaler */
  XMC_CCU8_StartPrescaler(module);
  
  gctrl = module->GCTRL;
 8021688:	6823      	ldr	r3, [r4, #0]
  gctrl &= ~((uint32_t) CCU8_GCTRL_MSDE_Msk);
 802168a:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
  gctrl |= (uint32_t)mcs_action << CCU8_GCTRL_MSDE_Pos;
 802168e:	ea43 3185 	orr.w	r1, r3, r5, lsl #14
  
  module->GCTRL = gctrl;
 8021692:	6021      	str	r1, [r4, #0]
 8021694:	bd38      	pop	{r3, r4, r5, pc}
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_CCU80);
  }
#if defined(CCU81)
  else if (module == CCU81)
  {
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_CCU81);
 8021696:	f44f 7080 	mov.w	r0, #256	; 0x100
 802169a:	f7ff fd37 	bl	802110c <XMC_SCU_CLOCK_UngatePeripheralClock>
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_CCU80);
  }
#if defined(CCU81)
  else if (module == CCU81)
  {
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_CCU81);
 802169e:	f44f 7080 	mov.w	r0, #256	; 0x100
 80216a2:	f7ff fcb7 	bl	8021014 <XMC_SCU_RESET_DeassertPeripheralReset>
 80216a6:	e7eb      	b.n	8021680 <XMC_CCU8_Init+0x18>

__STATIC_INLINE void XMC_CCU8_lUngateClock(XMC_CCU8_MODULE_t *const module)
{
  if (module == CCU80)
  {
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_CCU80);
 80216a8:	2080      	movs	r0, #128	; 0x80
 80216aa:	f7ff fd2f 	bl	802110c <XMC_SCU_CLOCK_UngatePeripheralClock>

__STATIC_INLINE void XMC_CCU8_lDeassertReset(const XMC_CCU8_MODULE_t *const module)
{
  if (module == CCU80)
  {
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_CCU80);
 80216ae:	2080      	movs	r0, #128	; 0x80
 80216b0:	f7ff fcb0 	bl	8021014 <XMC_SCU_RESET_DeassertPeripheralReset>
 80216b4:	e7e4      	b.n	8021680 <XMC_CCU8_Init+0x18>
 80216b6:	bf00      	nop
 80216b8:	40020000 	.word	0x40020000
 80216bc:	40024000 	.word	0x40024000

080216c0 <XMC_CCU8_SLICE_CompareInit>:
  /* Stops the timer */
  XMC_CCU8_SLICE_StopTimer(slice);
  /* Program the timer mode */
  slice->TC = compare_init->tc;
  /* Enable the timer concatenation */
  slice->CMC =  (uint32_t)compare_init->timer_concatenation << CCU8_CC8_CMC_TCE_Pos;
 80216c0:	7b4b      	ldrb	r3, [r1, #13]
}

/* API to configure CC8 Slice in Compare mode */
void XMC_CCU8_SLICE_CompareInit(XMC_CCU8_SLICE_t *const slice,
                                const XMC_CCU8_SLICE_COMPARE_CONFIG_t *const compare_init)
{
 80216c2:	b470      	push	{r4, r5, r6}
  /* Program the timer mode */
  slice->TC = compare_init->tc;
  /* Enable the timer concatenation */
  slice->CMC =  (uint32_t)compare_init->timer_concatenation << CCU8_CC8_CMC_TCE_Pos;
  /* Program initial prescaler divider value */
  slice->PSC = (uint32_t) compare_init->prescaler_initval;
 80216c4:	7b0d      	ldrb	r5, [r1, #12]
 *  XMC_CCU8_SLICE_StartTimer().
 */
__STATIC_INLINE void XMC_CCU8_SLICE_StopTimer(XMC_CCU8_SLICE_t *const slice)
{
  XMC_ASSERT("XMC_CCU8_SLICE_StopTimer:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  slice->TCCLR = (uint32_t) CCU8_CC8_TCCLR_TRBC_Msk;
 80216c6:	2601      	movs	r6, #1
 80216c8:	6106      	str	r6, [r0, #16]
  /* Program floating prescaler compare value */
  slice->FPCS = (uint32_t) compare_init->float_limit;
 80216ca:	462c      	mov	r4, r5
  /* Program the dither compare value */
  slice->DITS = (uint32_t) compare_init->dither_limit;
 80216cc:	461a      	mov	r2, r3
  /* Stops the timer */
  XMC_CCU8_SLICE_StopTimer(slice);
  /* Program the timer mode */
  slice->TC = compare_init->tc;
  /* Enable the timer concatenation */
  slice->CMC =  (uint32_t)compare_init->timer_concatenation << CCU8_CC8_CMC_TCE_Pos;
 80216ce:	f3c3 1300 	ubfx	r3, r3, #4, #1
  XMC_ASSERT("XMC_CCU8_SLICE_CompareInit:Timer Init Pointer is NULL",
             (XMC_CCU8_SLICE_COMPARE_CONFIG_t *) NULL != compare_init);
  /* Stops the timer */
  XMC_CCU8_SLICE_StopTimer(slice);
  /* Program the timer mode */
  slice->TC = compare_init->tc;
 80216d2:	680e      	ldr	r6, [r1, #0]
 80216d4:	6146      	str	r6, [r0, #20]
  /* Enable the timer concatenation */
  slice->CMC =  (uint32_t)compare_init->timer_concatenation << CCU8_CC8_CMC_TCE_Pos;
 80216d6:	051b      	lsls	r3, r3, #20
  /* Program initial prescaler divider value */
  slice->PSC = (uint32_t) compare_init->prescaler_initval;
 80216d8:	f005 050f 	and.w	r5, r5, #15
  /* Program floating prescaler compare value */
  slice->FPCS = (uint32_t) compare_init->float_limit;
 80216dc:	0924      	lsrs	r4, r4, #4
  /* Program the dither compare value */
  slice->DITS = (uint32_t) compare_init->dither_limit;
 80216de:	f002 020f 	and.w	r2, r2, #15
  /* Stops the timer */
  XMC_CCU8_SLICE_StopTimer(slice);
  /* Program the timer mode */
  slice->TC = compare_init->tc;
  /* Enable the timer concatenation */
  slice->CMC =  (uint32_t)compare_init->timer_concatenation << CCU8_CC8_CMC_TCE_Pos;
 80216e2:	6043      	str	r3, [r0, #4]
  /* Program initial prescaler divider value */
  slice->PSC = (uint32_t) compare_init->prescaler_initval;
 80216e4:	6245      	str	r5, [r0, #36]	; 0x24
  /* Program floating prescaler compare value */
  slice->FPCS = (uint32_t) compare_init->float_limit;
 80216e6:	62c4      	str	r4, [r0, #44]	; 0x2c
  /* Program the dither compare value */
  slice->DITS = (uint32_t) compare_init->dither_limit;
 80216e8:	6202      	str	r2, [r0, #32]
  /* Program timer output passive level */
  slice->PSL = (uint32_t) compare_init->psl;
 80216ea:	684b      	ldr	r3, [r1, #4]
 80216ec:	6183      	str	r3, [r0, #24]
  /* Asymmetric PWM and Slice output routing configuration */
#if defined(CCU8V3) /* Defined for XMC1400 devices only */
  slice->CHC = (uint32_t) compare_init->chc;
#else
  slice->CHC = (uint32_t)((uint32_t)compare_init->chc ^ XMC_CCU8_SLICE_CHC_CONFIG_MASK);
 80216ee:	688b      	ldr	r3, [r1, #8]
 80216f0:	f083 0314 	eor.w	r3, r3, #20
 80216f4:	6483      	str	r3, [r0, #72]	; 0x48
#endif
}
 80216f6:	bc70      	pop	{r4, r5, r6}
 80216f8:	4770      	bx	lr
 80216fa:	bf00      	nop

080216fc <XMC_CCU8_SetMultiChannelShadowTransferMode>:
{
  uint32_t gctrl;

  XMC_ASSERT("XMC_CCU8_SetMultiChannelShadowTransferMode:Invalid module Pointer", XMC_CCU8_IsValidModule(module));
  
  gctrl = module->GCTRL;
 80216fc:	6802      	ldr	r2, [r0, #0]
  gctrl &= ~((uint32_t)slice_mode_msk >> 16U);
  gctrl |= ((uint32_t)slice_mode_msk & 0xFFFFU);
 80216fe:	b28b      	uxth	r3, r1
  uint32_t gctrl;

  XMC_ASSERT("XMC_CCU8_SetMultiChannelShadowTransferMode:Invalid module Pointer", XMC_CCU8_IsValidModule(module));
  
  gctrl = module->GCTRL;
  gctrl &= ~((uint32_t)slice_mode_msk >> 16U);
 8021700:	ea22 4111 	bic.w	r1, r2, r1, lsr #16
  gctrl |= ((uint32_t)slice_mode_msk & 0xFFFFU);
 8021704:	4319      	orrs	r1, r3
  module->GCTRL = gctrl;
 8021706:	6001      	str	r1, [r0, #0]
 8021708:	4770      	bx	lr
 802170a:	bf00      	nop

0802170c <XMC_CCU8_SLICE_StartConfig>:
  XMC_ASSERT("XMC_CCU8_SLICE_StartConfig:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU8_SLICE_StartConfig:Invalid Event ID", XMC_CCU8_SLICE_CHECK_EVENT_ID(event));
  XMC_ASSERT("XMC_CCU8_SLICE_StartConfig:Invalid Start Mode", 
             ((start_mode == XMC_CCU8_SLICE_START_MODE_TIMER_START) ||\
              (start_mode == XMC_CCU8_SLICE_START_MODE_TIMER_START_CLEAR)));
  cmc = slice->CMC;
 802170c:	6843      	ldr	r3, [r0, #4]

  cmc &= ~((uint32_t) CCU8_CC8_CMC_STRTS_Msk);
 802170e:	f023 0303 	bic.w	r3, r3, #3
  cmc |= ((uint32_t) event) << CCU8_CC8_CMC_STRTS_Pos;
 8021712:	4319      	orrs	r1, r3

  slice->CMC = cmc;
 8021714:	6041      	str	r1, [r0, #4]

  tc  = slice->TC;
 8021716:	6943      	ldr	r3, [r0, #20]

  if(start_mode == XMC_CCU8_SLICE_START_MODE_TIMER_START_CLEAR)
 8021718:	2a01      	cmp	r2, #1
  {
    tc |= (uint32_t) CCU8_CC8_TC_STRM_Msk;
 802171a:	bf0c      	ite	eq
 802171c:	f443 6380 	orreq.w	r3, r3, #1024	; 0x400
  }
  else
  {
    tc &= ~((uint32_t) CCU8_CC8_TC_STRM_Msk);
 8021720:	f423 6380 	bicne.w	r3, r3, #1024	; 0x400
  }

  slice->TC = tc;
 8021724:	6143      	str	r3, [r0, #20]
 8021726:	4770      	bx	lr

08021728 <XMC_CCU8_SLICE_StopConfig>:

  XMC_ASSERT("XMC_CCU8_SLICE_StopConfig:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU8_SLICE_StopConfig:Invalid Event ID", XMC_CCU8_SLICE_CHECK_EVENT_ID(event));
  XMC_ASSERT("XMC_CCU8_SLICE_StopConfig:Invalid End Mode", XMC_CCU8_SLICE_CHECK_END_MODE(end_mode));

  cmc = slice->CMC;
 8021728:	6843      	ldr	r3, [r0, #4]
  /* First, Bind the event with the stop function */
  cmc &= ~((uint32_t) CCU8_CC8_CMC_ENDS_Msk);
 802172a:	f023 030c 	bic.w	r3, r3, #12
  cmc |= ((uint32_t) event) << CCU8_CC8_CMC_ENDS_Pos;
 802172e:	ea43 0181 	orr.w	r1, r3, r1, lsl #2

  slice->CMC = cmc;
 8021732:	6041      	str	r1, [r0, #4]

  /* Configure the stop mode */
  tc = slice->TC;
 8021734:	6943      	ldr	r3, [r0, #20]
  tc &= ~((uint32_t) CCU8_CC8_TC_ENDM_Msk);
 8021736:	f423 7340 	bic.w	r3, r3, #768	; 0x300
  tc |= ((uint32_t) end_mode) << CCU8_CC8_TC_ENDM_Pos;
 802173a:	ea43 2202 	orr.w	r2, r3, r2, lsl #8

  slice->TC = tc;
 802173e:	6142      	str	r2, [r0, #20]
 8021740:	4770      	bx	lr
 8021742:	bf00      	nop

08021744 <XMC_CCU8_SLICE_LoadConfig>:
  uint32_t cmc;

  XMC_ASSERT("XMC_CCU8_SLICE_LoadConfig:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU8_SLICE_LoadConfig:Invalid Event ID", XMC_CCU8_SLICE_CHECK_EVENT_ID(event));

  cmc = slice->CMC;
 8021744:	6843      	ldr	r3, [r0, #4]

  /* First, Bind the event with the load function */
  cmc &= ~((uint32_t) CCU8_CC8_CMC_LDS_Msk);
 8021746:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
  cmc |= ((uint32_t) event) << CCU8_CC8_CMC_LDS_Pos;
 802174a:	ea43 3101 	orr.w	r1, r3, r1, lsl #12

  slice->CMC = cmc;
 802174e:	6041      	str	r1, [r0, #4]
 8021750:	4770      	bx	lr
 8021752:	bf00      	nop

08021754 <XMC_CCU8_SLICE_LoadSelector>:
  uint32_t tc;

  XMC_ASSERT("XMC_CCU8_SLICE_LoadSelector:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU8_SLICE_LoadSelector:Invalid Channel number", XMC_CCU8_SLICE_CHECK_COMP_CHANNEL(ch_num));

  tc = slice->TC;
 8021754:	6943      	ldr	r3, [r0, #20]

  /* First, Bind the event with the load function */
  tc &= ~((uint32_t) CCU8_CC8_TC_TLS_Msk);
 8021756:	f023 0380 	bic.w	r3, r3, #128	; 0x80
  tc |= (uint32_t)ch_num << CCU8_CC8_TC_TLS_Pos;
 802175a:	ea43 11c1 	orr.w	r1, r3, r1, lsl #7

  slice->TC = tc;
 802175e:	6141      	str	r1, [r0, #20]
 8021760:	4770      	bx	lr
 8021762:	bf00      	nop

08021764 <XMC_CCU8_SLICE_ModulationConfig>:
void XMC_CCU8_SLICE_ModulationConfig(XMC_CCU8_SLICE_t *const slice,
                                     const XMC_CCU8_SLICE_EVENT_t event,
                                     const XMC_CCU8_SLICE_MODULATION_MODE_t mod_mode,
                                     const XMC_CCU8_SLICE_MODULATION_CHANNEL_t channel,
                                     const bool synch_with_pwm)
{
 8021764:	b430      	push	{r4, r5}
             XMC_CCU8_SLICE_CHECK_MODULATION_CHANNEL(channel));
  XMC_ASSERT("XMC_CCU8_SLICE_ModulationConfig:Invalid Modulation Mode", 
             ((mod_mode == XMC_CCU8_SLICE_MODULATION_MODE_CLEAR_ST_OUT) ||\
              (mod_mode == XMC_CCU8_SLICE_MODULATION_MODE_CLEAR_OUT)));

  cmc = slice->CMC;
 8021766:	6844      	ldr	r4, [r0, #4]
void XMC_CCU8_SLICE_ModulationConfig(XMC_CCU8_SLICE_t *const slice,
                                     const XMC_CCU8_SLICE_EVENT_t event,
                                     const XMC_CCU8_SLICE_MODULATION_MODE_t mod_mode,
                                     const XMC_CCU8_SLICE_MODULATION_CHANNEL_t channel,
                                     const bool synch_with_pwm)
{
 8021768:	f89d 5008 	ldrb.w	r5, [sp, #8]
              (mod_mode == XMC_CCU8_SLICE_MODULATION_MODE_CLEAR_OUT)));

  cmc = slice->CMC;

  /* First, Bind the event with the modulation function */
  cmc &= ~((uint32_t) CCU8_CC8_CMC_MOS_Msk);
 802176c:	f424 2440 	bic.w	r4, r4, #786432	; 0xc0000
  cmc |= ((uint32_t) event) << CCU8_CC8_CMC_MOS_Pos;
 8021770:	ea44 4181 	orr.w	r1, r4, r1, lsl #18

  slice->CMC = cmc;
 8021774:	6041      	str	r1, [r0, #4]

  tc  = slice->TC;
 8021776:	6941      	ldr	r1, [r0, #20]

  /* Next, Modulation mode */
  if(mod_mode == XMC_CCU8_SLICE_MODULATION_MODE_CLEAR_OUT)
 8021778:	2a01      	cmp	r2, #1
  {
    tc |= (uint32_t) CCU8_CC8_TC_EMT_Msk;
 802177a:	bf0c      	ite	eq
 802177c:	f041 7180 	orreq.w	r1, r1, #16777216	; 0x1000000
  }
  else
  {
    tc &= ~((uint32_t) CCU8_CC8_TC_EMT_Msk);
 8021780:	f021 7180 	bicne.w	r1, r1, #16777216	; 0x1000000
  }

  /* Synchronization of modulation effect with PWM cycle */
  if(synch_with_pwm == true)
 8021784:	b945      	cbnz	r5, 8021798 <XMC_CCU8_SLICE_ModulationConfig+0x34>
  {
    tc |= (uint32_t) CCU8_CC8_TC_EMS_Msk;
  }
  else
  {
    tc &= ~((uint32_t) CCU8_CC8_TC_EMS_Msk);
 8021786:	f421 0100 	bic.w	r1, r1, #8388608	; 0x800000
  }
  
  /* Configure on which channel external modulation to be applied */
  tc &= ~((uint32_t) CCU8_CC8_TC_EME_Msk);
 802178a:	f021 51c0 	bic.w	r1, r1, #402653184	; 0x18000000
  tc |= (uint32_t)channel << CCU8_CC8_TC_EME_Pos;
 802178e:	ea41 63c3 	orr.w	r3, r1, r3, lsl #27

  slice->TC = tc;
 8021792:	6143      	str	r3, [r0, #20]
}
 8021794:	bc30      	pop	{r4, r5}
 8021796:	4770      	bx	lr
  }

  /* Synchronization of modulation effect with PWM cycle */
  if(synch_with_pwm == true)
  {
    tc |= (uint32_t) CCU8_CC8_TC_EMS_Msk;
 8021798:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
 802179c:	e7f5      	b.n	802178a <XMC_CCU8_SLICE_ModulationConfig+0x26>
 802179e:	bf00      	nop

080217a0 <XMC_CCU8_SLICE_CountConfig>:
  uint32_t cmc;

  XMC_ASSERT("XMC_CCU8_SLICE_CountConfig:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU8_SLICE_CountConfig:Invalid Event ID", XMC_CCU8_SLICE_CHECK_EVENT_ID(event));

  cmc = slice->CMC;
 80217a0:	6843      	ldr	r3, [r0, #4]

  /* First, Bind the event with the count function */
  cmc &= ~((uint32_t) CCU8_CC8_CMC_CNTS_Msk);
 80217a2:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
  cmc |= ((uint32_t) event) << CCU8_CC8_CMC_CNTS_Pos;
 80217a6:	ea43 3181 	orr.w	r1, r3, r1, lsl #14

  slice->CMC = cmc;
 80217aa:	6041      	str	r1, [r0, #4]
 80217ac:	4770      	bx	lr
 80217ae:	bf00      	nop

080217b0 <XMC_CCU8_SLICE_GateConfig>:
  uint32_t cmc;

  XMC_ASSERT("XMC_CCU8_SLICE_GateConfig:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU8_SLICE_GateConfig:Invalid Event ID", XMC_CCU8_SLICE_CHECK_EVENT_ID(event));

  cmc = slice->CMC;
 80217b0:	6843      	ldr	r3, [r0, #4]

  /* First, Bind the event with the gate function */
  cmc &= ~((uint32_t) CCU8_CC8_CMC_GATES_Msk);
 80217b2:	f423 7340 	bic.w	r3, r3, #768	; 0x300
  cmc |= ((uint32_t) event) << CCU8_CC8_CMC_GATES_Pos;
 80217b6:	ea43 2101 	orr.w	r1, r3, r1, lsl #8

  slice->CMC = cmc;
 80217ba:	6041      	str	r1, [r0, #4]
 80217bc:	4770      	bx	lr
 80217be:	bf00      	nop

080217c0 <XMC_CCU8_SLICE_DirectionConfig>:
  uint32_t cmc;

  XMC_ASSERT("XMC_CCU8_SLICE_DirectionConfig:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU8_SLICE_DirectionConfig:Invalid Event ID", XMC_CCU8_SLICE_CHECK_EVENT_ID(event));

  cmc = slice->CMC;
 80217c0:	6843      	ldr	r3, [r0, #4]

  /* First, Bind the event with the direction function */
  cmc &= ~((uint32_t) CCU8_CC8_CMC_UDS_Msk);
 80217c2:	f423 6340 	bic.w	r3, r3, #3072	; 0xc00
  cmc |= ((uint32_t) event) << CCU8_CC8_CMC_UDS_Pos;
 80217c6:	ea43 2181 	orr.w	r1, r3, r1, lsl #10

  slice->CMC = cmc;
 80217ca:	6041      	str	r1, [r0, #4]
 80217cc:	4770      	bx	lr
 80217ce:	bf00      	nop

080217d0 <XMC_CCU8_SLICE_StatusBitOverrideConfig>:
{
  uint32_t cmc;

  XMC_ASSERT("XMC_CCU8_SLICE_StatusBitOverrideConfig:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));

  cmc = slice->CMC;
 80217d0:	6843      	ldr	r3, [r0, #4]

  /* Map status bit trigger override to Event 1 &
         status bit value override to Event 2 */
  cmc &= ~((uint32_t) CCU8_CC8_CMC_OFS_Msk);
  cmc |= ((uint32_t) 1) << CCU8_CC8_CMC_OFS_Pos;
 80217d2:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000

  slice->CMC = cmc;
 80217d6:	6043      	str	r3, [r0, #4]
 80217d8:	4770      	bx	lr
 80217da:	bf00      	nop

080217dc <XMC_CCU8_SLICE_TrapConfig>:

  XMC_ASSERT("XMC_CCU8_SLICE_TrapConfig:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU8_SLICE_TrapConfig:Invalid Exit Mode", ((exit_mode == XMC_CCU8_SLICE_TRAP_EXIT_MODE_AUTOMATIC) ||\
                                                             (exit_mode == XMC_CCU8_SLICE_TRAP_EXIT_MODE_SW)));

  cmc = slice->CMC;
 80217dc:	6843      	ldr	r3, [r0, #4]

  /* Map trap function to Event 2 */
  cmc &= ~((uint32_t) CCU8_CC8_CMC_TS_Msk);
  cmc |= ((uint32_t) 1) << CCU8_CC8_CMC_TS_Pos;
 80217de:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000

  slice->CMC = cmc;
 80217e2:	6043      	str	r3, [r0, #4]

  tc = slice->TC;
 80217e4:	6943      	ldr	r3, [r0, #20]

  /* Configure synchronization option */
  if(synch_with_pwm == true)
 80217e6:	b14a      	cbz	r2, 80217fc <XMC_CCU8_SLICE_TrapConfig+0x20>
  {
    tc |= (uint32_t) CCU8_CC8_TC_TRPSE_Msk;
 80217e8:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
  {
    tc &= ~((uint32_t) CCU8_CC8_TC_TRPSE_Msk);
  }

  /* Configure exit mode */
  if(exit_mode == XMC_CCU8_SLICE_TRAP_EXIT_MODE_SW)
 80217ec:	2901      	cmp	r1, #1
  {
    tc |= (uint32_t) CCU8_CC8_TC_TRPSW_Msk;
 80217ee:	bf0c      	ite	eq
 80217f0:	f443 0380 	orreq.w	r3, r3, #4194304	; 0x400000
  }
  else
  {
    tc &= ~((uint32_t) CCU8_CC8_TC_TRPSW_Msk);
 80217f4:	f423 0380 	bicne.w	r3, r3, #4194304	; 0x400000
  }

  slice->TC = tc;
 80217f8:	6143      	str	r3, [r0, #20]
 80217fa:	4770      	bx	lr
  {
    tc |= (uint32_t) CCU8_CC8_TC_TRPSE_Msk;
  }
  else
  {
    tc &= ~((uint32_t) CCU8_CC8_TC_TRPSE_Msk);
 80217fc:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 8021800:	e7f4      	b.n	80217ec <XMC_CCU8_SLICE_TrapConfig+0x10>
 8021802:	bf00      	nop

08021804 <XMC_CCU8_SLICE_ConfigureStatusBitOverrideEvent>:

/* API to configure a slice Status Bit Override event */
void XMC_CCU8_SLICE_ConfigureStatusBitOverrideEvent(XMC_CCU8_SLICE_t *const slice,
                                                    const XMC_CCU8_SLICE_EVENT_CONFIG_t *const ev1_config,
                                                    const XMC_CCU8_SLICE_EVENT_CONFIG_t *const ev2_config)
{
 8021804:	b5f0      	push	{r4, r5, r6, r7, lr}
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_INPUT_CONFIG_MASK) << CCU8_CC8_INS1_EV2IS_Pos);
  ins |= ((uint32_t) ev2_config->mapped_input) << CCU8_CC8_INS1_EV2IS_Pos;

  slice->INS1 = ins;  
#else
  ins = slice->INS;
 8021806:	6803      	ldr	r3, [r0, #0]

  /* Configure the edge sensitivity for event 1 */
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_EDGE_CONFIG_MASK) << CCU8_CC8_INS_EV1EM_Pos);
  ins |= ((uint32_t) ev1_config->edge) << CCU8_CC8_INS_EV1EM_Pos;
 8021808:	784e      	ldrb	r6, [r1, #1]
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_EDGE_CONFIG_MASK) << CCU8_CC8_INS_EV2EM_Pos);
  ins |= ((uint32_t) ev2_config->edge) << CCU8_CC8_INS_EV2EM_Pos;

  /* Configure the level sensitivity for event 1 */
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_LEVEL_CONFIG_MASK) << CCU8_CC8_INS_EV1LM_Pos);
  ins |= ((uint32_t) ev1_config->level) << CCU8_CC8_INS_EV1LM_Pos;
 802180a:	f891 e002 	ldrb.w	lr, [r1, #2]
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_LEVEL_CONFIG_MASK) << CCU8_CC8_INS_EV2LM_Pos);
  ins |= ((uint32_t) ev2_config->level) << CCU8_CC8_INS_EV2LM_Pos;

  /* Configure the debounce filter for event 1 */
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_FILTER_CONFIG_MASK) << CCU8_CC8_INS_LPF1M_Pos);
  ins |= ((uint32_t) ev1_config->duration) << CCU8_CC8_INS_LPF1M_Pos;
 802180e:	78cf      	ldrb	r7, [r1, #3]
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_FILTER_CONFIG_MASK) << CCU8_CC8_INS_LPF2M_Pos);
  ins |= ((uint32_t) ev2_config->duration) << CCU8_CC8_INS_LPF2M_Pos;

  /* Next, the input for Event1 */
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_INPUT_CONFIG_MASK) << CCU8_CC8_INS_EV1IS_Pos);
  ins |= ((uint32_t) ev1_config->mapped_input) << CCU8_CC8_INS_EV1IS_Pos;
 8021810:	780d      	ldrb	r5, [r1, #0]
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_EDGE_CONFIG_MASK) << CCU8_CC8_INS_EV1EM_Pos);
  ins |= ((uint32_t) ev1_config->edge) << CCU8_CC8_INS_EV1EM_Pos;

  /* Configure the edge sensitivity for event 2 */
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_EDGE_CONFIG_MASK) << CCU8_CC8_INS_EV2EM_Pos);
  ins |= ((uint32_t) ev2_config->edge) << CCU8_CC8_INS_EV2EM_Pos;
 8021812:	7851      	ldrb	r1, [r2, #1]
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_LEVEL_CONFIG_MASK) << CCU8_CC8_INS_EV1LM_Pos);
  ins |= ((uint32_t) ev1_config->level) << CCU8_CC8_INS_EV1LM_Pos;

  /* Configure the level sensitivity for event 2 */
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_LEVEL_CONFIG_MASK) << CCU8_CC8_INS_EV2LM_Pos);
  ins |= ((uint32_t) ev2_config->level) << CCU8_CC8_INS_EV2LM_Pos;
 8021814:	f892 c002 	ldrb.w	ip, [r2, #2]
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_INPUT_CONFIG_MASK) << CCU8_CC8_INS_EV1IS_Pos);
  ins |= ((uint32_t) ev1_config->mapped_input) << CCU8_CC8_INS_EV1IS_Pos;

  /* Finally, the input for Event2 */
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_INPUT_CONFIG_MASK) << CCU8_CC8_INS_EV2IS_Pos);
  ins |= ((uint32_t) ev2_config->mapped_input) << CCU8_CC8_INS_EV2IS_Pos;
 8021818:	7814      	ldrb	r4, [r2, #0]
  slice->INS1 = ins;  
#else
  ins = slice->INS;

  /* Configure the edge sensitivity for event 1 */
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_EDGE_CONFIG_MASK) << CCU8_CC8_INS_EV1EM_Pos);
 802181a:	f423 2340 	bic.w	r3, r3, #786432	; 0xc0000
  ins |= ((uint32_t) ev1_config->edge) << CCU8_CC8_INS_EV1EM_Pos;
 802181e:	ea43 4686 	orr.w	r6, r3, r6, lsl #18

  /* Configure the edge sensitivity for event 2 */
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_EDGE_CONFIG_MASK) << CCU8_CC8_INS_EV2EM_Pos);
 8021822:	f426 1640 	bic.w	r6, r6, #3145728	; 0x300000
  ins |= ((uint32_t) ev2_config->edge) << CCU8_CC8_INS_EV2EM_Pos;
 8021826:	ea46 5101 	orr.w	r1, r6, r1, lsl #20

  /* Configure the level sensitivity for event 1 */
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_LEVEL_CONFIG_MASK) << CCU8_CC8_INS_EV1LM_Pos);
 802182a:	f421 0100 	bic.w	r1, r1, #8388608	; 0x800000
  ins |= ((uint32_t) ev1_config->level) << CCU8_CC8_INS_EV1LM_Pos;
 802182e:	ea41 51ce 	orr.w	r1, r1, lr, lsl #23

  /* Configure the level sensitivity for event 2 */
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_LEVEL_CONFIG_MASK) << CCU8_CC8_INS_EV2LM_Pos);
 8021832:	f021 7180 	bic.w	r1, r1, #16777216	; 0x1000000
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_FILTER_CONFIG_MASK) << CCU8_CC8_INS_LPF1M_Pos);
  ins |= ((uint32_t) ev1_config->duration) << CCU8_CC8_INS_LPF1M_Pos;

  /* Configure the debounce filter for event 2 */
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_FILTER_CONFIG_MASK) << CCU8_CC8_INS_LPF2M_Pos);
  ins |= ((uint32_t) ev2_config->duration) << CCU8_CC8_INS_LPF2M_Pos;
 8021836:	78d3      	ldrb	r3, [r2, #3]
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_LEVEL_CONFIG_MASK) << CCU8_CC8_INS_EV1LM_Pos);
  ins |= ((uint32_t) ev1_config->level) << CCU8_CC8_INS_EV1LM_Pos;

  /* Configure the level sensitivity for event 2 */
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_LEVEL_CONFIG_MASK) << CCU8_CC8_INS_EV2LM_Pos);
  ins |= ((uint32_t) ev2_config->level) << CCU8_CC8_INS_EV2LM_Pos;
 8021838:	ea41 620c 	orr.w	r2, r1, ip, lsl #24

  /* Configure the debounce filter for event 1 */
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_FILTER_CONFIG_MASK) << CCU8_CC8_INS_LPF1M_Pos);
 802183c:	f022 52c0 	bic.w	r2, r2, #402653184	; 0x18000000
  ins |= ((uint32_t) ev1_config->duration) << CCU8_CC8_INS_LPF1M_Pos;
 8021840:	ea42 62c7 	orr.w	r2, r2, r7, lsl #27

  /* Configure the debounce filter for event 2 */
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_FILTER_CONFIG_MASK) << CCU8_CC8_INS_LPF2M_Pos);
 8021844:	f022 42c0 	bic.w	r2, r2, #1610612736	; 0x60000000
  ins |= ((uint32_t) ev2_config->duration) << CCU8_CC8_INS_LPF2M_Pos;
 8021848:	ea42 7243 	orr.w	r2, r2, r3, lsl #29

  /* Next, the input for Event1 */
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_INPUT_CONFIG_MASK) << CCU8_CC8_INS_EV1IS_Pos);
 802184c:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
  ins |= ((uint32_t) ev1_config->mapped_input) << CCU8_CC8_INS_EV1IS_Pos;
 8021850:	ea42 1305 	orr.w	r3, r2, r5, lsl #4

  /* Finally, the input for Event2 */
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_INPUT_CONFIG_MASK) << CCU8_CC8_INS_EV2IS_Pos);
 8021854:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
  ins |= ((uint32_t) ev2_config->mapped_input) << CCU8_CC8_INS_EV2IS_Pos;
 8021858:	ea43 2304 	orr.w	r3, r3, r4, lsl #8

  slice->INS = ins;
 802185c:	6003      	str	r3, [r0, #0]
 802185e:	bdf0      	pop	{r4, r5, r6, r7, pc}

08021860 <XMC_CCU8_SLICE_ConfigureEvent>:
              (config->level == XMC_CCU8_SLICE_EVENT_LEVEL_SENSITIVITY_ACTIVE_LOW)));
  XMC_ASSERT("XMC_CCU8_SLICE_ConfigureEvent:Invalid Debounce Period",
             XMC_CCU8_SLICE_CHECK_EVENT_FILTER(config->duration));

  /* Calculate offset with reference to event */
  offset = ((uint8_t) event) - 1U;
 8021860:	1e4b      	subs	r3, r1, #1

/* API to configure a slice trigger event */
void XMC_CCU8_SLICE_ConfigureEvent(XMC_CCU8_SLICE_t *const slice,
                                   const XMC_CCU8_SLICE_EVENT_t event,
                                   const XMC_CCU8_SLICE_EVENT_CONFIG_t *const config)
{
 8021862:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
              (config->level == XMC_CCU8_SLICE_EVENT_LEVEL_SENSITIVITY_ACTIVE_LOW)));
  XMC_ASSERT("XMC_CCU8_SLICE_ConfigureEvent:Invalid Debounce Period",
             XMC_CCU8_SLICE_CHECK_EVENT_FILTER(config->duration));

  /* Calculate offset with reference to event */
  offset = ((uint8_t) event) - 1U;
 8021866:	b2db      	uxtb	r3, r3

#else
  ins = slice->INS;

  /* First, configure the edge sensitivity */
  pos = ((uint8_t) CCU8_CC8_INS_EV0EM_Pos) + (uint8_t)(offset << 1U);
 8021868:	ea4f 0843 	mov.w	r8, r3, lsl #1
 802186c:	fa5f f888 	uxtb.w	r8, r8
 8021870:	f108 0910 	add.w	r9, r8, #16
  ins |= ((uint32_t) config->mapped_input) << pos;

  slice->INS1 = ins;

#else
  ins = slice->INS;
 8021874:	6807      	ldr	r7, [r0, #0]

  /* First, configure the edge sensitivity */
  pos = ((uint8_t) CCU8_CC8_INS_EV0EM_Pos) + (uint8_t)(offset << 1U);
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_EDGE_CONFIG_MASK) << pos);
  ins |= ((uint32_t) config->edge) << pos;
 8021876:	f892 c001 	ldrb.w	ip, [r2, #1]

  /* Next, the level */
  pos = ((uint8_t) CCU8_CC8_INS_EV0LM_Pos) + offset;
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_LEVEL_CONFIG_MASK) << pos);
  ins |= ((uint32_t) (config->level)) << pos;
 802187a:	7896      	ldrb	r6, [r2, #2]

  /* Next, the debounce filter */
  pos = ((uint8_t) CCU8_CC8_INS_LPF0M_Pos) + (uint8_t)(offset << 1U);
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_FILTER_CONFIG_MASK) << pos);
  ins |= ((uint32_t) config->duration) << pos;
 802187c:	78d4      	ldrb	r4, [r2, #3]

  /* Finally the input */
  pos = ((uint8_t) CCU8_CC8_INS_EV0IS_Pos) + (uint8_t)(offset << 2U);
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_INPUT_CONFIG_MASK) << pos);
  ins |= ((uint32_t) config->mapped_input) << pos;
 802187e:	f892 e000 	ldrb.w	lr, [r2]
#else
  ins = slice->INS;

  /* First, configure the edge sensitivity */
  pos = ((uint8_t) CCU8_CC8_INS_EV0EM_Pos) + (uint8_t)(offset << 1U);
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_EDGE_CONFIG_MASK) << pos);
 8021882:	fa5f f989 	uxtb.w	r9, r9
 8021886:	2503      	movs	r5, #3
 8021888:	fa05 f209 	lsl.w	r2, r5, r9
  ins |= ((uint32_t) config->edge) << pos;

  /* Next, the level */
  pos = ((uint8_t) CCU8_CC8_INS_EV0LM_Pos) + offset;
 802188c:	3115      	adds	r1, #21
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_LEVEL_CONFIG_MASK) << pos);
 802188e:	b2c9      	uxtb	r1, r1
#else
  ins = slice->INS;

  /* First, configure the edge sensitivity */
  pos = ((uint8_t) CCU8_CC8_INS_EV0EM_Pos) + (uint8_t)(offset << 1U);
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_EDGE_CONFIG_MASK) << pos);
 8021890:	ea27 0202 	bic.w	r2, r7, r2
  ins |= ((uint32_t) config->edge) << pos;
 8021894:	fa0c fc09 	lsl.w	ip, ip, r9

  /* Next, the level */
  pos = ((uint8_t) CCU8_CC8_INS_EV0LM_Pos) + offset;
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_LEVEL_CONFIG_MASK) << pos);
 8021898:	2701      	movs	r7, #1
  ins = slice->INS;

  /* First, configure the edge sensitivity */
  pos = ((uint8_t) CCU8_CC8_INS_EV0EM_Pos) + (uint8_t)(offset << 1U);
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_EDGE_CONFIG_MASK) << pos);
  ins |= ((uint32_t) config->edge) << pos;
 802189a:	ea42 0c0c 	orr.w	ip, r2, ip

  /* Next, the level */
  pos = ((uint8_t) CCU8_CC8_INS_EV0LM_Pos) + offset;
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_LEVEL_CONFIG_MASK) << pos);
 802189e:	408f      	lsls	r7, r1
  ins |= ((uint32_t) (config->level)) << pos;

  /* Next, the debounce filter */
  pos = ((uint8_t) CCU8_CC8_INS_LPF0M_Pos) + (uint8_t)(offset << 1U);
 80218a0:	f108 0819 	add.w	r8, r8, #25
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_FILTER_CONFIG_MASK) << pos);
 80218a4:	fa5f f288 	uxtb.w	r2, r8
  ins |= ((uint32_t) config->edge) << pos;

  /* Next, the level */
  pos = ((uint8_t) CCU8_CC8_INS_EV0LM_Pos) + offset;
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_LEVEL_CONFIG_MASK) << pos);
  ins |= ((uint32_t) (config->level)) << pos;
 80218a8:	408e      	lsls	r6, r1
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_EDGE_CONFIG_MASK) << pos);
  ins |= ((uint32_t) config->edge) << pos;

  /* Next, the level */
  pos = ((uint8_t) CCU8_CC8_INS_EV0LM_Pos) + offset;
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_LEVEL_CONFIG_MASK) << pos);
 80218aa:	ea2c 0707 	bic.w	r7, ip, r7
  pos = ((uint8_t) CCU8_CC8_INS_LPF0M_Pos) + (uint8_t)(offset << 1U);
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_FILTER_CONFIG_MASK) << pos);
  ins |= ((uint32_t) config->duration) << pos;

  /* Finally the input */
  pos = ((uint8_t) CCU8_CC8_INS_EV0IS_Pos) + (uint8_t)(offset << 2U);
 80218ae:	0099      	lsls	r1, r3, #2
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_LEVEL_CONFIG_MASK) << pos);
  ins |= ((uint32_t) (config->level)) << pos;

  /* Next, the debounce filter */
  pos = ((uint8_t) CCU8_CC8_INS_LPF0M_Pos) + (uint8_t)(offset << 1U);
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_FILTER_CONFIG_MASK) << pos);
 80218b0:	4095      	lsls	r5, r2
  ins |= ((uint32_t) config->edge) << pos;

  /* Next, the level */
  pos = ((uint8_t) CCU8_CC8_INS_EV0LM_Pos) + offset;
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_LEVEL_CONFIG_MASK) << pos);
  ins |= ((uint32_t) (config->level)) << pos;
 80218b2:	433e      	orrs	r6, r7
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_FILTER_CONFIG_MASK) << pos);
  ins |= ((uint32_t) config->duration) << pos;

  /* Finally the input */
  pos = ((uint8_t) CCU8_CC8_INS_EV0IS_Pos) + (uint8_t)(offset << 2U);
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_INPUT_CONFIG_MASK) << pos);
 80218b4:	b2c9      	uxtb	r1, r1
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_LEVEL_CONFIG_MASK) << pos);
  ins |= ((uint32_t) (config->level)) << pos;

  /* Next, the debounce filter */
  pos = ((uint8_t) CCU8_CC8_INS_LPF0M_Pos) + (uint8_t)(offset << 1U);
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_FILTER_CONFIG_MASK) << pos);
 80218b6:	ea26 0505 	bic.w	r5, r6, r5
  ins |= ((uint32_t) config->duration) << pos;
 80218ba:	fa04 f202 	lsl.w	r2, r4, r2

  /* Finally the input */
  pos = ((uint8_t) CCU8_CC8_INS_EV0IS_Pos) + (uint8_t)(offset << 2U);
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_INPUT_CONFIG_MASK) << pos);
 80218be:	230f      	movs	r3, #15
  ins |= ((uint32_t) (config->level)) << pos;

  /* Next, the debounce filter */
  pos = ((uint8_t) CCU8_CC8_INS_LPF0M_Pos) + (uint8_t)(offset << 1U);
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_FILTER_CONFIG_MASK) << pos);
  ins |= ((uint32_t) config->duration) << pos;
 80218c0:	432a      	orrs	r2, r5

  /* Finally the input */
  pos = ((uint8_t) CCU8_CC8_INS_EV0IS_Pos) + (uint8_t)(offset << 2U);
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_INPUT_CONFIG_MASK) << pos);
 80218c2:	408b      	lsls	r3, r1
  ins |= ((uint32_t) config->mapped_input) << pos;
 80218c4:	fa0e fe01 	lsl.w	lr, lr, r1
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_FILTER_CONFIG_MASK) << pos);
  ins |= ((uint32_t) config->duration) << pos;

  /* Finally the input */
  pos = ((uint8_t) CCU8_CC8_INS_EV0IS_Pos) + (uint8_t)(offset << 2U);
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_INPUT_CONFIG_MASK) << pos);
 80218c8:	ea22 0303 	bic.w	r3, r2, r3
  ins |= ((uint32_t) config->mapped_input) << pos;
 80218cc:	ea43 030e 	orr.w	r3, r3, lr

  slice->INS = ins;
 80218d0:	6003      	str	r3, [r0, #0]
 80218d2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80218d6:	bf00      	nop

080218d8 <XMC_CCU8_SLICE_SetTimerPeriodMatch>:

/* Programs period match value of the timer  */
void XMC_CCU8_SLICE_SetTimerPeriodMatch(XMC_CCU8_SLICE_t *const slice, const uint16_t period_val)
{
  XMC_ASSERT("XMC_CCU8_SLICE_SetTimerPeriodMatch:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  slice->PRS = (uint32_t) period_val;
 80218d8:	6341      	str	r1, [r0, #52]	; 0x34
 80218da:	4770      	bx	lr

080218dc <XMC_CCU8_SLICE_SetTimerCompareMatch>:
                                         const uint16_t compare_val)
{
  XMC_ASSERT("XMC_CCU8_SLICE_SetTimerCompareMatch:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU8_SLICE_SetTimerCompareMatch:Invalid channel", XMC_CCU8_SLICE_CHECK_COMP_CHANNEL(channel));

  if (XMC_CCU8_SLICE_COMPARE_CHANNEL_1 == channel)
 80218dc:	b109      	cbz	r1, 80218e2 <XMC_CCU8_SLICE_SetTimerCompareMatch+0x6>
  {
    slice->CR1S = (uint32_t) compare_val;
  }
  else
  {
    slice->CR2S = (uint32_t) compare_val;
 80218de:	6442      	str	r2, [r0, #68]	; 0x44
 80218e0:	4770      	bx	lr
  XMC_ASSERT("XMC_CCU8_SLICE_SetTimerCompareMatch:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU8_SLICE_SetTimerCompareMatch:Invalid channel", XMC_CCU8_SLICE_CHECK_COMP_CHANNEL(channel));

  if (XMC_CCU8_SLICE_COMPARE_CHANNEL_1 == channel)
  {
    slice->CR1S = (uint32_t) compare_val;
 80218e2:	63c2      	str	r2, [r0, #60]	; 0x3c
 80218e4:	4770      	bx	lr
 80218e6:	bf00      	nop

080218e8 <XMC_CCU8_SLICE_SetInterruptNode>:

/* Binds a capcom event to an NVIC node  */
void XMC_CCU8_SLICE_SetInterruptNode(XMC_CCU8_SLICE_t *const slice,
                                     const XMC_CCU8_SLICE_IRQ_ID_t event,
                                     const XMC_CCU8_SLICE_SR_ID_t sr)
{
 80218e8:	2909      	cmp	r1, #9
 80218ea:	b430      	push	{r4, r5}

  XMC_ASSERT("XMC_CCU8_SLICE_SetInterruptNode:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU8_SLICE_SetInterruptNode:Invalid SR ID ", XMC_CCU8_SLICE_CHECK_SR_ID(sr));
  XMC_ASSERT("XMC_CCU8_SLICE_SetInterruptNode:Invalid event", XMC_CCU8_SLICE_CHECK_INTERRUPT(event));

  srs = slice->SRS;
 80218ec:	f8d0 40a8 	ldr.w	r4, [r0, #168]	; 0xa8
 80218f0:	d80d      	bhi.n	802190e <XMC_CCU8_SLICE_SetInterruptNode+0x26>
 80218f2:	4b09      	ldr	r3, [pc, #36]	; (8021918 <XMC_CCU8_SLICE_SetInterruptNode+0x30>)
 80218f4:	4d09      	ldr	r5, [pc, #36]	; (802191c <XMC_CCU8_SLICE_SetInterruptNode+0x34>)
 80218f6:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 80218fa:	f855 1021 	ldr.w	r1, [r5, r1, lsl #2]
 80218fe:	43db      	mvns	r3, r3
      mask = ((uint32_t) CCU8_CC8_SRS_E2SR_Msk);
      pos  = CCU8_CC8_SRS_E2SR_Pos;
      break;
  }
  
  srs &= ~mask;
 8021900:	4023      	ands	r3, r4
  srs |= (uint32_t)sr << pos;
 8021902:	408a      	lsls	r2, r1
 8021904:	431a      	orrs	r2, r3
  
  slice->SRS = srs;
 8021906:	f8c0 20a8 	str.w	r2, [r0, #168]	; 0xa8
}
 802190a:	bc30      	pop	{r4, r5}
 802190c:	4770      	bx	lr

  XMC_ASSERT("XMC_CCU8_SLICE_SetInterruptNode:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU8_SLICE_SetInterruptNode:Invalid SR ID ", XMC_CCU8_SLICE_CHECK_SR_ID(sr));
  XMC_ASSERT("XMC_CCU8_SLICE_SetInterruptNode:Invalid event", XMC_CCU8_SLICE_CHECK_INTERRUPT(event));

  srs = slice->SRS;
 802190e:	210c      	movs	r1, #12
 8021910:	f46f 5340 	mvn.w	r3, #12288	; 0x3000
 8021914:	e7f4      	b.n	8021900 <XMC_CCU8_SLICE_SetInterruptNode+0x18>
 8021916:	bf00      	nop
 8021918:	0802d7a4 	.word	0x0802d7a4
 802191c:	0802d7cc 	.word	0x0802d7cc

08021920 <XMC_CCU8_SLICE_DeadTimeInit>:
                                 const XMC_CCU8_SLICE_DEAD_TIME_CONFIG_t *const config)
{
  XMC_ASSERT("XMC_CCU8_SLICE_ConfigureDeadTime:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));

  /* Program dead time value for channel 1 */
  slice->DC1R = config->dc1r;
 8021920:	684b      	ldr	r3, [r1, #4]
 8021922:	6503      	str	r3, [r0, #80]	; 0x50
  /* Program dead time value for channel 2 */
  slice->DC2R = config->dc2r;
 8021924:	688b      	ldr	r3, [r1, #8]
 8021926:	6543      	str	r3, [r0, #84]	; 0x54
  /* Program dead time control configuration */
  slice->DTC = config->dtc;
 8021928:	680b      	ldr	r3, [r1, #0]
 802192a:	64c3      	str	r3, [r0, #76]	; 0x4c
 802192c:	4770      	bx	lr
 802192e:	bf00      	nop

08021930 <XMC_DMA_Init>:

/* Enable GPDMA module */
void XMC_DMA_Enable(XMC_DMA_t *const dma)
{
#if defined(GPDMA1)
  if (dma == XMC_DMA0)
 8021930:	4b0c      	ldr	r3, [pc, #48]	; (8021964 <XMC_DMA_Init+0x34>)
 8021932:	4298      	cmp	r0, r3
 * API IMPLEMENTATION
 *******************************************************************************/

/* Initialize GPDMA */
void XMC_DMA_Init(XMC_DMA_t *const dma)
{
 8021934:	b510      	push	{r4, lr}
 8021936:	4604      	mov	r4, r0

/* Enable GPDMA module */
void XMC_DMA_Enable(XMC_DMA_t *const dma)
{
#if defined(GPDMA1)
  if (dma == XMC_DMA0)
 8021938:	d009      	beq.n	802194e <XMC_DMA_Init+0x1e>
#if defined(GPDMA1)
  }
  else
  {
#if defined(CLOCK_GATING_SUPPORTED)
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_GPDMA1);
 802193a:	480b      	ldr	r0, [pc, #44]	; (8021968 <XMC_DMA_Init+0x38>)
 802193c:	f7ff fbe6 	bl	802110c <XMC_SCU_CLOCK_UngatePeripheralClock>
#endif
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_GPDMA1);
 8021940:	4809      	ldr	r0, [pc, #36]	; (8021968 <XMC_DMA_Init+0x38>)
 8021942:	f7ff fb67 	bl	8021014 <XMC_SCU_RESET_DeassertPeripheralReset>
  }
#endif

  dma->DMACFGREG = 0x1U;
 8021946:	2301      	movs	r3, #1
 8021948:	f8c4 3398 	str.w	r3, [r4, #920]	; 0x398
 802194c:	bd10      	pop	{r4, pc}
#if defined(GPDMA1)
  if (dma == XMC_DMA0)
  {
#endif
#if defined(CLOCK_GATING_SUPPORTED)
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_GPDMA0);
 802194e:	4807      	ldr	r0, [pc, #28]	; (802196c <XMC_DMA_Init+0x3c>)
 8021950:	f7ff fbdc 	bl	802110c <XMC_SCU_CLOCK_UngatePeripheralClock>
#endif
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_GPDMA0);
 8021954:	4805      	ldr	r0, [pc, #20]	; (802196c <XMC_DMA_Init+0x3c>)
 8021956:	f7ff fb5d 	bl	8021014 <XMC_SCU_RESET_DeassertPeripheralReset>
#endif
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_GPDMA1);
  }
#endif

  dma->DMACFGREG = 0x1U;
 802195a:	2301      	movs	r3, #1
 802195c:	f8c4 3398 	str.w	r3, [r4, #920]	; 0x398
 8021960:	bd10      	pop	{r4, pc}
 8021962:	bf00      	nop
 8021964:	50014000 	.word	0x50014000
 8021968:	20000020 	.word	0x20000020
 802196c:	20000010 	.word	0x20000010

08021970 <XMC_DMA_CH_Disable>:
}

/* Disable DMA channel */
void XMC_DMA_CH_Disable(XMC_DMA_t *const dma, const uint8_t channel)
{
  dma->CHENREG = (uint32_t)(0x100UL << channel);
 8021970:	f44f 7380 	mov.w	r3, #256	; 0x100
 8021974:	408b      	lsls	r3, r1
 8021976:	2201      	movs	r2, #1
 8021978:	f8c0 33a0 	str.w	r3, [r0, #928]	; 0x3a0
 802197c:	408a      	lsls	r2, r1
  while((dma->CHENREG & (uint32_t)(0x1UL << channel)) != 0U)
 802197e:	f8d0 33a0 	ldr.w	r3, [r0, #928]	; 0x3a0
 8021982:	421a      	tst	r2, r3
 8021984:	d1fb      	bne.n	802197e <XMC_DMA_CH_Disable+0xe>
  {
    /* wait until channel is disabled */
  }
}
 8021986:	4770      	bx	lr

08021988 <XMC_DMA_CH_Init>:
  return (bool)(dma->CHENREG & ((uint32_t)1U << channel));
}

/* Initialize DMA channel */
XMC_DMA_CH_STATUS_t XMC_DMA_CH_Init(XMC_DMA_t *const dma, const uint8_t channel, const XMC_DMA_CH_CONFIG_t *const config)
{
 8021988:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
bool XMC_DMA_IsEnabled(const XMC_DMA_t *const dma)
{
  bool status;

#if defined(GPDMA1)
  if (dma == XMC_DMA0)
 802198a:	4ba1      	ldr	r3, [pc, #644]	; (8021c10 <XMC_DMA_CH_Init+0x288>)
 802198c:	4298      	cmp	r0, r3
  return (bool)(dma->CHENREG & ((uint32_t)1U << channel));
}

/* Initialize DMA channel */
XMC_DMA_CH_STATUS_t XMC_DMA_CH_Init(XMC_DMA_t *const dma, const uint8_t channel, const XMC_DMA_CH_CONFIG_t *const config)
{
 802198e:	4604      	mov	r4, r0
 8021990:	460e      	mov	r6, r1
 8021992:	4615      	mov	r5, r2
bool XMC_DMA_IsEnabled(const XMC_DMA_t *const dma)
{
  bool status;

#if defined(GPDMA1)
  if (dma == XMC_DMA0)
 8021994:	d053      	beq.n	8021a3e <XMC_DMA_CH_Init+0xb6>
#endif
#if defined(GPDMA1)
  }
  else
  {
    status = !XMC_SCU_RESET_IsPeripheralResetAsserted(XMC_SCU_PERIPHERAL_RESET_GPDMA1);
 8021996:	489f      	ldr	r0, [pc, #636]	; (8021c14 <XMC_DMA_CH_Init+0x28c>)
 8021998:	f7ff fb48 	bl	802102c <XMC_SCU_RESET_IsPeripheralResetAsserted>
#if defined(CLOCK_GATING_SUPPORTED)
    status = status && !XMC_SCU_CLOCK_IsPeripheralClockGated(XMC_SCU_PERIPHERAL_CLOCK_GPDMA1);
 802199c:	b108      	cbz	r0, 80219a2 <XMC_DMA_CH_Init+0x1a>
      status = XMC_DMA_CH_STATUS_BUSY;
    }
  }
  else 
  {
    status = XMC_DMA_CH_STATUS_ERROR;
 802199e:	2001      	movs	r0, #1
 80219a0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  }
  else
  {
    status = !XMC_SCU_RESET_IsPeripheralResetAsserted(XMC_SCU_PERIPHERAL_RESET_GPDMA1);
#if defined(CLOCK_GATING_SUPPORTED)
    status = status && !XMC_SCU_CLOCK_IsPeripheralClockGated(XMC_SCU_PERIPHERAL_CLOCK_GPDMA1);
 80219a2:	489c      	ldr	r0, [pc, #624]	; (8021c14 <XMC_DMA_CH_Init+0x28c>)
 80219a4:	f7ff fbbe 	bl	8021124 <XMC_SCU_CLOCK_IsPeripheralClockGated>
 80219a8:	f080 0001 	eor.w	r0, r0, #1
 80219ac:	b2c0      	uxtb	r0, r0
#endif
  }
#endif

  /* DMA reset is not asserted and peripheral clock is not gated */
  if (status == true)
 80219ae:	2800      	cmp	r0, #0
 80219b0:	d0f5      	beq.n	802199e <XMC_DMA_CH_Init+0x16>
  {
    status = status && (dma->DMACFGREG != 0U);
 80219b2:	f8d4 3398 	ldr.w	r3, [r4, #920]	; 0x398
{
  XMC_DMA_CH_STATUS_t status;
  uint8_t line;
  uint8_t peripheral;

  if (XMC_DMA_IsEnabled(dma) == true)
 80219b6:	2b00      	cmp	r3, #0
 80219b8:	d0f1      	beq.n	802199e <XMC_DMA_CH_Init+0x16>
}

/* Check if a DMA channel is enabled */
bool XMC_DMA_CH_IsEnabled(XMC_DMA_t *const dma, const uint8_t channel)
{
  return (bool)(dma->CHENREG & ((uint32_t)1U << channel));
 80219ba:	f8d4 33a0 	ldr.w	r3, [r4, #928]	; 0x3a0
 80219be:	40f3      	lsrs	r3, r6
  uint8_t line;
  uint8_t peripheral;

  if (XMC_DMA_IsEnabled(dma) == true)
  {
    if (XMC_DMA_CH_IsEnabled(dma, channel) == false)
 80219c0:	07db      	lsls	r3, r3, #31
 80219c2:	d501      	bpl.n	80219c8 <XMC_DMA_CH_Init+0x40>
      status = XMC_DMA_CH_STATUS_OK;

    }
    else
    {
      status = XMC_DMA_CH_STATUS_BUSY;
 80219c4:	2002      	movs	r0, #2
 80219c6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

  if (XMC_DMA_IsEnabled(dma) == true)
  {
    if (XMC_DMA_CH_IsEnabled(dma, channel) == false)
    {
      dma->CH[channel].SAR = config->src_addr;
 80219c8:	2258      	movs	r2, #88	; 0x58
 80219ca:	fb02 f206 	mul.w	r2, r2, r6
 80219ce:	6869      	ldr	r1, [r5, #4]
 80219d0:	50a1      	str	r1, [r4, r2]
 80219d2:	18a3      	adds	r3, r4, r2
      dma->CH[channel].DAR = config->dst_addr;
 80219d4:	68a9      	ldr	r1, [r5, #8]
      dma->CH[channel].LLP = (uint32_t)config->linked_list_pointer;
      dma->CH[channel].CTLH = (uint32_t)config->block_size;
      dma->CH[channel].CTLL = config->control;

      dma->CH[channel].CFGL = (uint32_t)((uint32_t)config->priority |
 80219d6:	7eea      	ldrb	r2, [r5, #27]
  {
    if (XMC_DMA_CH_IsEnabled(dma, channel) == false)
    {
      dma->CH[channel].SAR = config->src_addr;
      dma->CH[channel].DAR = config->dst_addr;
      dma->CH[channel].LLP = (uint32_t)config->linked_list_pointer;
 80219d8:	f8d5 e00c 	ldr.w	lr, [r5, #12]
      dma->CH[channel].CTLH = (uint32_t)config->block_size;
 80219dc:	8b2f      	ldrh	r7, [r5, #24]
  if (XMC_DMA_IsEnabled(dma) == true)
  {
    if (XMC_DMA_CH_IsEnabled(dma, channel) == false)
    {
      dma->CH[channel].SAR = config->src_addr;
      dma->CH[channel].DAR = config->dst_addr;
 80219de:	6099      	str	r1, [r3, #8]

      dma->CH[channel].CFGL = (uint32_t)((uint32_t)config->priority |
                                         (uint32_t)GPDMA0_CH_CFGL_HS_SEL_SRC_Msk |
                                         (uint32_t)GPDMA0_CH_CFGL_HS_SEL_DST_Msk);

      if ((dma == XMC_DMA0) && (channel < (uint8_t)2))
 80219e0:	498b      	ldr	r1, [pc, #556]	; (8021c10 <XMC_DMA_CH_Init+0x288>)
  {
    if (XMC_DMA_CH_IsEnabled(dma, channel) == false)
    {
      dma->CH[channel].SAR = config->src_addr;
      dma->CH[channel].DAR = config->dst_addr;
      dma->CH[channel].LLP = (uint32_t)config->linked_list_pointer;
 80219e2:	f8c3 e010 	str.w	lr, [r3, #16]
      dma->CH[channel].CTLH = (uint32_t)config->block_size;
 80219e6:	61df      	str	r7, [r3, #28]
      dma->CH[channel].CTLL = config->control;
 80219e8:	6828      	ldr	r0, [r5, #0]
 80219ea:	6198      	str	r0, [r3, #24]

      dma->CH[channel].CFGL = (uint32_t)((uint32_t)config->priority |
 80219ec:	f442 6240 	orr.w	r2, r2, #3072	; 0xc00
                                         (uint32_t)GPDMA0_CH_CFGL_HS_SEL_SRC_Msk |
                                         (uint32_t)GPDMA0_CH_CFGL_HS_SEL_DST_Msk);

      if ((dma == XMC_DMA0) && (channel < (uint8_t)2))
 80219f0:	428c      	cmp	r4, r1
      dma->CH[channel].DAR = config->dst_addr;
      dma->CH[channel].LLP = (uint32_t)config->linked_list_pointer;
      dma->CH[channel].CTLH = (uint32_t)config->block_size;
      dma->CH[channel].CTLL = config->control;

      dma->CH[channel].CFGL = (uint32_t)((uint32_t)config->priority |
 80219f2:	641a      	str	r2, [r3, #64]	; 0x40
                                         (uint32_t)GPDMA0_CH_CFGL_HS_SEL_SRC_Msk |
                                         (uint32_t)GPDMA0_CH_CFGL_HS_SEL_DST_Msk);

      if ((dma == XMC_DMA0) && (channel < (uint8_t)2))
 80219f4:	d02f      	beq.n	8021a56 <XMC_DMA_CH_Init+0xce>
        /* Configure scatter and gather */
        dma->CH[channel].SGR = config->src_gather_control;
        dma->CH[channel].DSR = config->dst_scatter_control;
      }

      if (config->dst_handshaking == XMC_DMA_CH_DST_HANDSHAKING_HARDWARE)
 80219f6:	8c2b      	ldrh	r3, [r5, #32]
 80219f8:	b923      	cbnz	r3, 8021a04 <XMC_DMA_CH_Init+0x7c>
      {
        /* Hardware handshaking interface configuration */
        if ((config->transfer_flow == (uint32_t)XMC_DMA_CH_TRANSFER_FLOW_M2P_DMA) ||
 80219fa:	78ab      	ldrb	r3, [r5, #2]
 80219fc:	f003 0350 	and.w	r3, r3, #80	; 0x50
 8021a00:	2b10      	cmp	r3, #16
 8021a02:	d02f      	beq.n	8021a64 <XMC_DMA_CH_Init+0xdc>
          dma->CH[channel].CFGL &= (uint32_t)~GPDMA0_CH_CFGL_HS_SEL_DST_Msk;
        }
      }


      if (config->src_handshaking == XMC_DMA_CH_SRC_HANDSHAKING_HARDWARE)
 8021a04:	8bab      	ldrh	r3, [r5, #28]
 8021a06:	b923      	cbnz	r3, 8021a12 <XMC_DMA_CH_Init+0x8a>
      {
        if ((config->transfer_flow == (uint32_t)XMC_DMA_CH_TRANSFER_FLOW_P2M_DMA) ||
 8021a08:	78ab      	ldrb	r3, [r5, #2]
 8021a0a:	f003 0360 	and.w	r3, r3, #96	; 0x60
 8021a0e:	2b20      	cmp	r3, #32
 8021a10:	d053      	beq.n	8021aba <XMC_DMA_CH_Init+0x132>
                                                           (uint32_t)XMC_DMA_CH_EVENT_BLOCK_TRANSFER_COMPLETE |
                                                           (uint32_t)XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE |
                                                           (uint32_t)XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE |
                                                           (uint32_t)XMC_DMA_CH_EVENT_ERROR));

      switch (config->transfer_type)
 8021a12:	7eaa      	ldrb	r2, [r5, #26]

  for(event_idx = 0UL; event_idx < DMA_EVENT_MAX; ++event_idx)
  {
    if (event & (uint32_t)((uint32_t)0x1UL << event_idx))
    {
      dma->CLEARCHEV[event_idx * 2UL] = ((uint32_t)0x1UL << channel);
 8021a14:	2301      	movs	r3, #1
 8021a16:	40b3      	lsls	r3, r6
                                                           (uint32_t)XMC_DMA_CH_EVENT_BLOCK_TRANSFER_COMPLETE |
                                                           (uint32_t)XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE |
                                                           (uint32_t)XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE |
                                                           (uint32_t)XMC_DMA_CH_EVENT_ERROR));

      switch (config->transfer_type)
 8021a18:	3a01      	subs	r2, #1

  for(event_idx = 0UL; event_idx < DMA_EVENT_MAX; ++event_idx)
  {
    if (event & (uint32_t)((uint32_t)0x1UL << event_idx))
    {
      dma->CLEARCHEV[event_idx * 2UL] = ((uint32_t)0x1UL << channel);
 8021a1a:	f8c4 3338 	str.w	r3, [r4, #824]	; 0x338
 8021a1e:	f8c4 3340 	str.w	r3, [r4, #832]	; 0x340
 8021a22:	f8c4 3348 	str.w	r3, [r4, #840]	; 0x348
 8021a26:	f8c4 3350 	str.w	r3, [r4, #848]	; 0x350
 8021a2a:	f8c4 3358 	str.w	r3, [r4, #856]	; 0x358
                                                           (uint32_t)XMC_DMA_CH_EVENT_BLOCK_TRANSFER_COMPLETE |
                                                           (uint32_t)XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE |
                                                           (uint32_t)XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE |
                                                           (uint32_t)XMC_DMA_CH_EVENT_ERROR));

      switch (config->transfer_type)
 8021a2e:	2a07      	cmp	r2, #7
 8021a30:	d86c      	bhi.n	8021b0c <XMC_DMA_CH_Init+0x184>
 8021a32:	e8df f002 	tbb	[pc, r2]
 8021a36:	9e95      	.short	0x9e95
 8021a38:	8c7f766d 	.word	0x8c7f766d
 8021a3c:	b4a7      	.short	0xb4a7

#if defined(GPDMA1)
  if (dma == XMC_DMA0)
  {
#endif
    status = !XMC_SCU_RESET_IsPeripheralResetAsserted(XMC_SCU_PERIPHERAL_RESET_GPDMA0);
 8021a3e:	4876      	ldr	r0, [pc, #472]	; (8021c18 <XMC_DMA_CH_Init+0x290>)
 8021a40:	f7ff faf4 	bl	802102c <XMC_SCU_RESET_IsPeripheralResetAsserted>
#if defined(CLOCK_GATING_SUPPORTED)
    status = status && !XMC_SCU_CLOCK_IsPeripheralClockGated(XMC_SCU_PERIPHERAL_CLOCK_GPDMA0);
 8021a44:	2800      	cmp	r0, #0
 8021a46:	d1aa      	bne.n	802199e <XMC_DMA_CH_Init+0x16>
 8021a48:	4873      	ldr	r0, [pc, #460]	; (8021c18 <XMC_DMA_CH_Init+0x290>)
 8021a4a:	f7ff fb6b 	bl	8021124 <XMC_SCU_CLOCK_IsPeripheralClockGated>
 8021a4e:	f080 0001 	eor.w	r0, r0, #1
 8021a52:	b2c0      	uxtb	r0, r0
 8021a54:	e7ab      	b.n	80219ae <XMC_DMA_CH_Init+0x26>

      dma->CH[channel].CFGL = (uint32_t)((uint32_t)config->priority |
                                         (uint32_t)GPDMA0_CH_CFGL_HS_SEL_SRC_Msk |
                                         (uint32_t)GPDMA0_CH_CFGL_HS_SEL_DST_Msk);

      if ((dma == XMC_DMA0) && (channel < (uint8_t)2))
 8021a56:	2e01      	cmp	r6, #1
 8021a58:	d8cd      	bhi.n	80219f6 <XMC_DMA_CH_Init+0x6e>
      {
        /* Configure scatter and gather */
        dma->CH[channel].SGR = config->src_gather_control;
 8021a5a:	692a      	ldr	r2, [r5, #16]
 8021a5c:	649a      	str	r2, [r3, #72]	; 0x48
        dma->CH[channel].DSR = config->dst_scatter_control;
 8021a5e:	696a      	ldr	r2, [r5, #20]
 8021a60:	651a      	str	r2, [r3, #80]	; 0x50
 8021a62:	e7c8      	b.n	80219f6 <XMC_DMA_CH_Init+0x6e>
        /* Hardware handshaking interface configuration */
        if ((config->transfer_flow == (uint32_t)XMC_DMA_CH_TRANSFER_FLOW_M2P_DMA) ||
            (config->transfer_flow == (uint32_t)XMC_DMA_CH_TRANSFER_FLOW_P2P_DMA))
        {
#if defined(GPDMA1)
          if (dma == XMC_DMA0)
 8021a64:	4b6a      	ldr	r3, [pc, #424]	; (8021c10 <XMC_DMA_CH_Init+0x288>)
{
#if defined(GPDMA1)
  if (dma == XMC_DMA0)
  {
#endif
    DLR->SRSEL0 = ((DLR->SRSEL0 & (uint32_t)~(DLR_SRSEL_RS_MSK << (line * DLR_SRSEL_RS_BITSIZE))) |
 8021a66:	496d      	ldr	r1, [pc, #436]	; (8021c1c <XMC_DMA_CH_Init+0x294>)
            line = config->dst_peripheral_request & GPDMA1_CH_CFGH_PER_Msk;
          }
#endif
          peripheral = config->dst_peripheral_request >> GPDMA_CH_CFGH_PER_BITSIZE;

          dma->CH[channel].CFGH |= (uint32_t)((uint32_t)line << GPDMA0_CH_CFGH_DEST_PER_Pos);
 8021a68:	2258      	movs	r2, #88	; 0x58
 8021a6a:	fb02 4206 	mla	r2, r2, r6, r4
        /* Hardware handshaking interface configuration */
        if ((config->transfer_flow == (uint32_t)XMC_DMA_CH_TRANSFER_FLOW_M2P_DMA) ||
            (config->transfer_flow == (uint32_t)XMC_DMA_CH_TRANSFER_FLOW_P2P_DMA))
        {
#if defined(GPDMA1)
          if (dma == XMC_DMA0)
 8021a6e:	429c      	cmp	r4, r3
            line = config->dst_peripheral_request & GPDMA1_CH_CFGH_PER_Msk;
          }
#endif
          peripheral = config->dst_peripheral_request >> GPDMA_CH_CFGH_PER_BITSIZE;

          dma->CH[channel].CFGH |= (uint32_t)((uint32_t)line << GPDMA0_CH_CFGH_DEST_PER_Pos);
 8021a70:	6c57      	ldr	r7, [r2, #68]	; 0x44
        {
#if defined(GPDMA1)
          if (dma == XMC_DMA0)
          {
#endif
            line = config->dst_peripheral_request & GPDMA0_CH_CFGH_PER_Msk;
 8021a72:	f895 3022 	ldrb.w	r3, [r5, #34]	; 0x22
        /* Hardware handshaking interface configuration */
        if ((config->transfer_flow == (uint32_t)XMC_DMA_CH_TRANSFER_FLOW_M2P_DMA) ||
            (config->transfer_flow == (uint32_t)XMC_DMA_CH_TRANSFER_FLOW_P2P_DMA))
        {
#if defined(GPDMA1)
          if (dma == XMC_DMA0)
 8021a76:	f000 80b3 	beq.w	8021be0 <XMC_DMA_CH_Init+0x258>
            line = config->dst_peripheral_request & GPDMA0_CH_CFGH_PER_Msk;
#if defined(GPDMA1)
          }
          else
          {
            line = config->dst_peripheral_request & GPDMA1_CH_CFGH_PER_Msk;
 8021a7a:	f003 0003 	and.w	r0, r3, #3
          }
#endif
          peripheral = config->dst_peripheral_request >> GPDMA_CH_CFGH_PER_BITSIZE;

          dma->CH[channel].CFGH |= (uint32_t)((uint32_t)line << GPDMA0_CH_CFGH_DEST_PER_Pos);
 8021a7e:	ea47 27c0 	orr.w	r7, r7, r0, lsl #11
 8021a82:	6457      	str	r7, [r2, #68]	; 0x44
    DLR->LNEN |= (0x1UL << (line & GPDMA0_CH_CFGH_PER_Msk));
#if defined(GPDMA1)
  }
  else
  {
    DLR->SRSEL1 = ((DLR->SRSEL1 & (uint32_t)~(DLR_SRSEL_RS_MSK << (line * DLR_SRSEL_RS_BITSIZE))) |
 8021a84:	68cf      	ldr	r7, [r1, #12]
 8021a86:	ea4f 0e80 	mov.w	lr, r0, lsl #2
 8021a8a:	220f      	movs	r2, #15
                   ((uint32_t)peripheral << (line * DLR_SRSEL_RS_BITSIZE)));
 8021a8c:	091b      	lsrs	r3, r3, #4
    DLR->LNEN |= (0x1UL << (line & GPDMA0_CH_CFGH_PER_Msk));
#if defined(GPDMA1)
  }
  else
  {
    DLR->SRSEL1 = ((DLR->SRSEL1 & (uint32_t)~(DLR_SRSEL_RS_MSK << (line * DLR_SRSEL_RS_BITSIZE))) |
 8021a8e:	fa02 f20e 	lsl.w	r2, r2, lr
 8021a92:	ea27 0202 	bic.w	r2, r7, r2
                   ((uint32_t)peripheral << (line * DLR_SRSEL_RS_BITSIZE)));
 8021a96:	fa03 f30e 	lsl.w	r3, r3, lr
    DLR->LNEN |= (0x1UL << (line & GPDMA0_CH_CFGH_PER_Msk));
#if defined(GPDMA1)
  }
  else
  {
    DLR->SRSEL1 = ((DLR->SRSEL1 & (uint32_t)~(DLR_SRSEL_RS_MSK << (line * DLR_SRSEL_RS_BITSIZE))) |
 8021a9a:	4313      	orrs	r3, r2
 8021a9c:	60cb      	str	r3, [r1, #12]
                   ((uint32_t)peripheral << (line * DLR_SRSEL_RS_BITSIZE)));
    DLR->LNEN |= (0x100UL << line);
 8021a9e:	690a      	ldr	r2, [r1, #16]
 8021aa0:	f44f 7380 	mov.w	r3, #256	; 0x100
 8021aa4:	4083      	lsls	r3, r0
 8021aa6:	4313      	orrs	r3, r2
 8021aa8:	610b      	str	r3, [r1, #16]
#endif
          peripheral = config->dst_peripheral_request >> GPDMA_CH_CFGH_PER_BITSIZE;

          dma->CH[channel].CFGH |= (uint32_t)((uint32_t)line << GPDMA0_CH_CFGH_DEST_PER_Pos);
          XMC_DMA_EnableRequestLine(dma, line, peripheral);
          dma->CH[channel].CFGL &= (uint32_t)~GPDMA0_CH_CFGL_HS_SEL_DST_Msk;
 8021aaa:	2358      	movs	r3, #88	; 0x58
 8021aac:	fb03 4306 	mla	r3, r3, r6, r4
 8021ab0:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8021ab2:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8021ab6:	641a      	str	r2, [r3, #64]	; 0x40
 8021ab8:	e7a4      	b.n	8021a04 <XMC_DMA_CH_Init+0x7c>
      {
        if ((config->transfer_flow == (uint32_t)XMC_DMA_CH_TRANSFER_FLOW_P2M_DMA) ||
            (config->transfer_flow == (uint32_t)XMC_DMA_CH_TRANSFER_FLOW_P2P_DMA))
        {
#if defined(GPDMA1)
          if (dma == XMC_DMA0)
 8021aba:	4b55      	ldr	r3, [pc, #340]	; (8021c10 <XMC_DMA_CH_Init+0x288>)
{
#if defined(GPDMA1)
  if (dma == XMC_DMA0)
  {
#endif
    DLR->SRSEL0 = ((DLR->SRSEL0 & (uint32_t)~(DLR_SRSEL_RS_MSK << (line * DLR_SRSEL_RS_BITSIZE))) |
 8021abc:	4957      	ldr	r1, [pc, #348]	; (8021c1c <XMC_DMA_CH_Init+0x294>)
            line = config->src_peripheral_request & GPDMA1_CH_CFGH_PER_Msk;
          }
#endif
          peripheral = config->src_peripheral_request >> GPDMA_CH_CFGH_PER_BITSIZE;

          dma->CH[channel].CFGH |= (uint32_t)((uint32_t)line << GPDMA0_CH_CFGH_SRC_PER_Pos);
 8021abe:	2258      	movs	r2, #88	; 0x58
 8021ac0:	fb02 4206 	mla	r2, r2, r6, r4
      {
        if ((config->transfer_flow == (uint32_t)XMC_DMA_CH_TRANSFER_FLOW_P2M_DMA) ||
            (config->transfer_flow == (uint32_t)XMC_DMA_CH_TRANSFER_FLOW_P2P_DMA))
        {
#if defined(GPDMA1)
          if (dma == XMC_DMA0)
 8021ac4:	429c      	cmp	r4, r3
            line = config->src_peripheral_request & GPDMA1_CH_CFGH_PER_Msk;
          }
#endif
          peripheral = config->src_peripheral_request >> GPDMA_CH_CFGH_PER_BITSIZE;

          dma->CH[channel].CFGH |= (uint32_t)((uint32_t)line << GPDMA0_CH_CFGH_SRC_PER_Pos);
 8021ac6:	6c57      	ldr	r7, [r2, #68]	; 0x44
        {
#if defined(GPDMA1)
          if (dma == XMC_DMA0)
          {
#endif
            line = config->src_peripheral_request & GPDMA0_CH_CFGH_PER_Msk;
 8021ac8:	7fab      	ldrb	r3, [r5, #30]
      {
        if ((config->transfer_flow == (uint32_t)XMC_DMA_CH_TRANSFER_FLOW_P2M_DMA) ||
            (config->transfer_flow == (uint32_t)XMC_DMA_CH_TRANSFER_FLOW_P2P_DMA))
        {
#if defined(GPDMA1)
          if (dma == XMC_DMA0)
 8021aca:	d071      	beq.n	8021bb0 <XMC_DMA_CH_Init+0x228>
            line = config->src_peripheral_request & GPDMA0_CH_CFGH_PER_Msk;
#if defined(GPDMA1)
          }
          else
          {
            line = config->src_peripheral_request & GPDMA1_CH_CFGH_PER_Msk;
 8021acc:	f003 0003 	and.w	r0, r3, #3
          }
#endif
          peripheral = config->src_peripheral_request >> GPDMA_CH_CFGH_PER_BITSIZE;

          dma->CH[channel].CFGH |= (uint32_t)((uint32_t)line << GPDMA0_CH_CFGH_SRC_PER_Pos);
 8021ad0:	ea47 17c0 	orr.w	r7, r7, r0, lsl #7
 8021ad4:	6457      	str	r7, [r2, #68]	; 0x44
    DLR->LNEN |= (0x1UL << (line & GPDMA0_CH_CFGH_PER_Msk));
#if defined(GPDMA1)
  }
  else
  {
    DLR->SRSEL1 = ((DLR->SRSEL1 & (uint32_t)~(DLR_SRSEL_RS_MSK << (line * DLR_SRSEL_RS_BITSIZE))) |
 8021ad6:	68cf      	ldr	r7, [r1, #12]
 8021ad8:	ea4f 0e80 	mov.w	lr, r0, lsl #2
 8021adc:	220f      	movs	r2, #15
                   ((uint32_t)peripheral << (line * DLR_SRSEL_RS_BITSIZE)));
 8021ade:	091b      	lsrs	r3, r3, #4
    DLR->LNEN |= (0x1UL << (line & GPDMA0_CH_CFGH_PER_Msk));
#if defined(GPDMA1)
  }
  else
  {
    DLR->SRSEL1 = ((DLR->SRSEL1 & (uint32_t)~(DLR_SRSEL_RS_MSK << (line * DLR_SRSEL_RS_BITSIZE))) |
 8021ae0:	fa02 f20e 	lsl.w	r2, r2, lr
 8021ae4:	ea27 0202 	bic.w	r2, r7, r2
                   ((uint32_t)peripheral << (line * DLR_SRSEL_RS_BITSIZE)));
 8021ae8:	fa03 f30e 	lsl.w	r3, r3, lr
    DLR->LNEN |= (0x1UL << (line & GPDMA0_CH_CFGH_PER_Msk));
#if defined(GPDMA1)
  }
  else
  {
    DLR->SRSEL1 = ((DLR->SRSEL1 & (uint32_t)~(DLR_SRSEL_RS_MSK << (line * DLR_SRSEL_RS_BITSIZE))) |
 8021aec:	4313      	orrs	r3, r2
 8021aee:	60cb      	str	r3, [r1, #12]
                   ((uint32_t)peripheral << (line * DLR_SRSEL_RS_BITSIZE)));
    DLR->LNEN |= (0x100UL << line);
 8021af0:	690a      	ldr	r2, [r1, #16]
 8021af2:	f44f 7380 	mov.w	r3, #256	; 0x100
 8021af6:	4083      	lsls	r3, r0
 8021af8:	4313      	orrs	r3, r2
 8021afa:	610b      	str	r3, [r1, #16]
#endif
          peripheral = config->src_peripheral_request >> GPDMA_CH_CFGH_PER_BITSIZE;

          dma->CH[channel].CFGH |= (uint32_t)((uint32_t)line << GPDMA0_CH_CFGH_SRC_PER_Pos);
          XMC_DMA_EnableRequestLine(dma, line, peripheral);
          dma->CH[channel].CFGL &= (uint32_t)~GPDMA0_CH_CFGL_HS_SEL_SRC_Msk;
 8021afc:	2358      	movs	r3, #88	; 0x58
 8021afe:	fb03 4306 	mla	r3, r3, r6, r4
 8021b02:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8021b04:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 8021b08:	641a      	str	r2, [r3, #64]	; 0x40
 8021b0a:	e782      	b.n	8021a12 <XMC_DMA_CH_Init+0x8a>

        default:
          break;
      }

      status = XMC_DMA_CH_STATUS_OK;
 8021b0c:	2000      	movs	r0, #0
 8021b0e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_RELOAD_DSTADR_CONTIGUOUS:
          dma->CH[channel].CFGL |= (uint32_t)GPDMA0_CH_CFGL_RELOAD_SRC_Msk;
          break;

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_RELOAD_DSTADR_RELOAD:
          dma->CH[channel].CFGL |= (uint32_t)((uint32_t)GPDMA0_CH_CFGL_RELOAD_DST_Msk |
 8021b10:	2158      	movs	r1, #88	; 0x58
 8021b12:	fb01 4406 	mla	r4, r1, r6, r4

        default:
          break;
      }

      status = XMC_DMA_CH_STATUS_OK;
 8021b16:	2000      	movs	r0, #0
        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_RELOAD_DSTADR_CONTIGUOUS:
          dma->CH[channel].CFGL |= (uint32_t)GPDMA0_CH_CFGL_RELOAD_SRC_Msk;
          break;

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_RELOAD_DSTADR_RELOAD:
          dma->CH[channel].CFGL |= (uint32_t)((uint32_t)GPDMA0_CH_CFGL_RELOAD_DST_Msk |
 8021b18:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8021b1a:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
 8021b1e:	6423      	str	r3, [r4, #64]	; 0x40
                                              (uint32_t)GPDMA0_CH_CFGL_RELOAD_SRC_Msk);
          break;
 8021b20:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_CONTIGUOUS_DSTADR_LINKED:
          dma->CH[channel].CTLL |= (uint32_t)GPDMA0_CH_CTLL_LLP_DST_EN_Msk;
 8021b22:	2158      	movs	r1, #88	; 0x58
 8021b24:	fb01 4406 	mla	r4, r1, r6, r4

        default:
          break;
      }

      status = XMC_DMA_CH_STATUS_OK;
 8021b28:	2000      	movs	r0, #0
          dma->CH[channel].CFGL |= (uint32_t)((uint32_t)GPDMA0_CH_CFGL_RELOAD_DST_Msk |
                                              (uint32_t)GPDMA0_CH_CFGL_RELOAD_SRC_Msk);
          break;

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_CONTIGUOUS_DSTADR_LINKED:
          dma->CH[channel].CTLL |= (uint32_t)GPDMA0_CH_CTLL_LLP_DST_EN_Msk;
 8021b2a:	69a3      	ldr	r3, [r4, #24]
 8021b2c:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 8021b30:	61a3      	str	r3, [r4, #24]
          break;
 8021b32:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_RELOAD_DSTADR_LINKED:
          dma->CH[channel].CFGL |= (uint32_t)GPDMA0_CH_CFGL_RELOAD_SRC_Msk;
 8021b34:	2158      	movs	r1, #88	; 0x58
 8021b36:	fb01 4406 	mla	r4, r1, r6, r4

        default:
          break;
      }

      status = XMC_DMA_CH_STATUS_OK;
 8021b3a:	2000      	movs	r0, #0
        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_CONTIGUOUS_DSTADR_LINKED:
          dma->CH[channel].CTLL |= (uint32_t)GPDMA0_CH_CTLL_LLP_DST_EN_Msk;
          break;

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_RELOAD_DSTADR_LINKED:
          dma->CH[channel].CFGL |= (uint32_t)GPDMA0_CH_CFGL_RELOAD_SRC_Msk;
 8021b3c:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8021b3e:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 8021b42:	6423      	str	r3, [r4, #64]	; 0x40
          dma->CH[channel].CTLL |= (uint32_t)GPDMA0_CH_CTLL_LLP_DST_EN_Msk;
 8021b44:	69a3      	ldr	r3, [r4, #24]
 8021b46:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 8021b4a:	61a3      	str	r3, [r4, #24]
          break;
 8021b4c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_LINKED_DSTADR_CONTIGUOUS:
          dma->CH[channel].CTLL |= (uint32_t)GPDMA0_CH_CTLL_LLP_SRC_EN_Msk;
 8021b4e:	2158      	movs	r1, #88	; 0x58
 8021b50:	fb01 4406 	mla	r4, r1, r6, r4

        default:
          break;
      }

      status = XMC_DMA_CH_STATUS_OK;
 8021b54:	2000      	movs	r0, #0
          dma->CH[channel].CFGL |= (uint32_t)GPDMA0_CH_CFGL_RELOAD_SRC_Msk;
          dma->CH[channel].CTLL |= (uint32_t)GPDMA0_CH_CTLL_LLP_DST_EN_Msk;
          break;

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_LINKED_DSTADR_CONTIGUOUS:
          dma->CH[channel].CTLL |= (uint32_t)GPDMA0_CH_CTLL_LLP_SRC_EN_Msk;
 8021b56:	69a3      	ldr	r3, [r4, #24]
 8021b58:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8021b5c:	61a3      	str	r3, [r4, #24]
          break;
 8021b5e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      {
        case XMC_DMA_CH_TRANSFER_TYPE_SINGLE_BLOCK:
          break;

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_CONTIGUOUS_DSTADR_RELOAD:
          dma->CH[channel].CFGL |= (uint32_t)GPDMA0_CH_CFGL_RELOAD_DST_Msk;
 8021b60:	2158      	movs	r1, #88	; 0x58
 8021b62:	fb01 4406 	mla	r4, r1, r6, r4

        default:
          break;
      }

      status = XMC_DMA_CH_STATUS_OK;
 8021b66:	2000      	movs	r0, #0
      {
        case XMC_DMA_CH_TRANSFER_TYPE_SINGLE_BLOCK:
          break;

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_CONTIGUOUS_DSTADR_RELOAD:
          dma->CH[channel].CFGL |= (uint32_t)GPDMA0_CH_CFGL_RELOAD_DST_Msk;
 8021b68:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8021b6a:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8021b6e:	6423      	str	r3, [r4, #64]	; 0x40
          break;
 8021b70:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_RELOAD_DSTADR_CONTIGUOUS:
          dma->CH[channel].CFGL |= (uint32_t)GPDMA0_CH_CFGL_RELOAD_SRC_Msk;
 8021b72:	2158      	movs	r1, #88	; 0x58
 8021b74:	fb01 4406 	mla	r4, r1, r6, r4

        default:
          break;
      }

      status = XMC_DMA_CH_STATUS_OK;
 8021b78:	2000      	movs	r0, #0
        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_CONTIGUOUS_DSTADR_RELOAD:
          dma->CH[channel].CFGL |= (uint32_t)GPDMA0_CH_CFGL_RELOAD_DST_Msk;
          break;

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_RELOAD_DSTADR_CONTIGUOUS:
          dma->CH[channel].CFGL |= (uint32_t)GPDMA0_CH_CFGL_RELOAD_SRC_Msk;
 8021b7a:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8021b7c:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 8021b80:	6423      	str	r3, [r4, #64]	; 0x40
          break;
 8021b82:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_LINKED_DSTADR_CONTIGUOUS:
          dma->CH[channel].CTLL |= (uint32_t)GPDMA0_CH_CTLL_LLP_SRC_EN_Msk;
          break;

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_LINKED_DSTADR_RELOAD:
          dma->CH[channel].CFGL |= (uint32_t)GPDMA0_CH_CFGL_RELOAD_DST_Msk;
 8021b84:	2158      	movs	r1, #88	; 0x58
 8021b86:	fb01 4406 	mla	r4, r1, r6, r4

        default:
          break;
      }

      status = XMC_DMA_CH_STATUS_OK;
 8021b8a:	2000      	movs	r0, #0
        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_LINKED_DSTADR_CONTIGUOUS:
          dma->CH[channel].CTLL |= (uint32_t)GPDMA0_CH_CTLL_LLP_SRC_EN_Msk;
          break;

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_LINKED_DSTADR_RELOAD:
          dma->CH[channel].CFGL |= (uint32_t)GPDMA0_CH_CFGL_RELOAD_DST_Msk;
 8021b8c:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8021b8e:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8021b92:	6423      	str	r3, [r4, #64]	; 0x40
          dma->CH[channel].CTLL |= (uint32_t)GPDMA0_CH_CTLL_LLP_SRC_EN_Msk;
 8021b94:	69a3      	ldr	r3, [r4, #24]
 8021b96:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8021b9a:	61a3      	str	r3, [r4, #24]
          break;
 8021b9c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_LINKED_DSTADR_LINKED:
          dma->CH[channel].CTLL |= (uint32_t)((uint32_t)GPDMA0_CH_CTLL_LLP_SRC_EN_Msk |
 8021b9e:	2158      	movs	r1, #88	; 0x58
 8021ba0:	fb01 4406 	mla	r4, r1, r6, r4

        default:
          break;
      }

      status = XMC_DMA_CH_STATUS_OK;
 8021ba4:	2000      	movs	r0, #0
          dma->CH[channel].CFGL |= (uint32_t)GPDMA0_CH_CFGL_RELOAD_DST_Msk;
          dma->CH[channel].CTLL |= (uint32_t)GPDMA0_CH_CTLL_LLP_SRC_EN_Msk;
          break;

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_LINKED_DSTADR_LINKED:
          dma->CH[channel].CTLL |= (uint32_t)((uint32_t)GPDMA0_CH_CTLL_LLP_SRC_EN_Msk |
 8021ba6:	69a3      	ldr	r3, [r4, #24]
 8021ba8:	f043 53c0 	orr.w	r3, r3, #402653184	; 0x18000000
 8021bac:	61a3      	str	r3, [r4, #24]
                                              (uint32_t)GPDMA0_CH_CTLL_LLP_DST_EN_Msk);
          break;
 8021bae:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        {
#if defined(GPDMA1)
          if (dma == XMC_DMA0)
          {
#endif
            line = config->src_peripheral_request & GPDMA0_CH_CFGH_PER_Msk;
 8021bb0:	f003 0007 	and.w	r0, r3, #7
            line = config->src_peripheral_request & GPDMA1_CH_CFGH_PER_Msk;
          }
#endif
          peripheral = config->src_peripheral_request >> GPDMA_CH_CFGH_PER_BITSIZE;

          dma->CH[channel].CFGH |= (uint32_t)((uint32_t)line << GPDMA0_CH_CFGH_SRC_PER_Pos);
 8021bb4:	ea47 17c0 	orr.w	r7, r7, r0, lsl #7
 8021bb8:	6457      	str	r7, [r2, #68]	; 0x44
{
#if defined(GPDMA1)
  if (dma == XMC_DMA0)
  {
#endif
    DLR->SRSEL0 = ((DLR->SRSEL0 & (uint32_t)~(DLR_SRSEL_RS_MSK << (line * DLR_SRSEL_RS_BITSIZE))) |
 8021bba:	688f      	ldr	r7, [r1, #8]
 8021bbc:	ea4f 0e80 	mov.w	lr, r0, lsl #2
 8021bc0:	220f      	movs	r2, #15
                   ((uint32_t)peripheral << (line * DLR_SRSEL_RS_BITSIZE)));
 8021bc2:	091b      	lsrs	r3, r3, #4
{
#if defined(GPDMA1)
  if (dma == XMC_DMA0)
  {
#endif
    DLR->SRSEL0 = ((DLR->SRSEL0 & (uint32_t)~(DLR_SRSEL_RS_MSK << (line * DLR_SRSEL_RS_BITSIZE))) |
 8021bc4:	fa02 f20e 	lsl.w	r2, r2, lr
 8021bc8:	ea27 0202 	bic.w	r2, r7, r2
                   ((uint32_t)peripheral << (line * DLR_SRSEL_RS_BITSIZE)));
 8021bcc:	fa03 f30e 	lsl.w	r3, r3, lr
{
#if defined(GPDMA1)
  if (dma == XMC_DMA0)
  {
#endif
    DLR->SRSEL0 = ((DLR->SRSEL0 & (uint32_t)~(DLR_SRSEL_RS_MSK << (line * DLR_SRSEL_RS_BITSIZE))) |
 8021bd0:	4313      	orrs	r3, r2
 8021bd2:	608b      	str	r3, [r1, #8]
                   ((uint32_t)peripheral << (line * DLR_SRSEL_RS_BITSIZE)));
    DLR->LNEN |= (0x1UL << (line & GPDMA0_CH_CFGH_PER_Msk));
 8021bd4:	690a      	ldr	r2, [r1, #16]
 8021bd6:	2301      	movs	r3, #1
 8021bd8:	4083      	lsls	r3, r0
 8021bda:	4313      	orrs	r3, r2
 8021bdc:	610b      	str	r3, [r1, #16]
 8021bde:	e78d      	b.n	8021afc <XMC_DMA_CH_Init+0x174>
        {
#if defined(GPDMA1)
          if (dma == XMC_DMA0)
          {
#endif
            line = config->dst_peripheral_request & GPDMA0_CH_CFGH_PER_Msk;
 8021be0:	f003 0007 	and.w	r0, r3, #7
            line = config->dst_peripheral_request & GPDMA1_CH_CFGH_PER_Msk;
          }
#endif
          peripheral = config->dst_peripheral_request >> GPDMA_CH_CFGH_PER_BITSIZE;

          dma->CH[channel].CFGH |= (uint32_t)((uint32_t)line << GPDMA0_CH_CFGH_DEST_PER_Pos);
 8021be4:	ea47 27c0 	orr.w	r7, r7, r0, lsl #11
 8021be8:	6457      	str	r7, [r2, #68]	; 0x44
{
#if defined(GPDMA1)
  if (dma == XMC_DMA0)
  {
#endif
    DLR->SRSEL0 = ((DLR->SRSEL0 & (uint32_t)~(DLR_SRSEL_RS_MSK << (line * DLR_SRSEL_RS_BITSIZE))) |
 8021bea:	688f      	ldr	r7, [r1, #8]
 8021bec:	ea4f 0e80 	mov.w	lr, r0, lsl #2
 8021bf0:	220f      	movs	r2, #15
                   ((uint32_t)peripheral << (line * DLR_SRSEL_RS_BITSIZE)));
 8021bf2:	091b      	lsrs	r3, r3, #4
{
#if defined(GPDMA1)
  if (dma == XMC_DMA0)
  {
#endif
    DLR->SRSEL0 = ((DLR->SRSEL0 & (uint32_t)~(DLR_SRSEL_RS_MSK << (line * DLR_SRSEL_RS_BITSIZE))) |
 8021bf4:	fa02 f20e 	lsl.w	r2, r2, lr
 8021bf8:	ea27 0202 	bic.w	r2, r7, r2
                   ((uint32_t)peripheral << (line * DLR_SRSEL_RS_BITSIZE)));
 8021bfc:	fa03 f30e 	lsl.w	r3, r3, lr
{
#if defined(GPDMA1)
  if (dma == XMC_DMA0)
  {
#endif
    DLR->SRSEL0 = ((DLR->SRSEL0 & (uint32_t)~(DLR_SRSEL_RS_MSK << (line * DLR_SRSEL_RS_BITSIZE))) |
 8021c00:	4313      	orrs	r3, r2
 8021c02:	608b      	str	r3, [r1, #8]
                   ((uint32_t)peripheral << (line * DLR_SRSEL_RS_BITSIZE)));
    DLR->LNEN |= (0x1UL << (line & GPDMA0_CH_CFGH_PER_Msk));
 8021c04:	690a      	ldr	r2, [r1, #16]
 8021c06:	2301      	movs	r3, #1
 8021c08:	4083      	lsls	r3, r0
 8021c0a:	4313      	orrs	r3, r2
 8021c0c:	610b      	str	r3, [r1, #16]
 8021c0e:	e74c      	b.n	8021aaa <XMC_DMA_CH_Init+0x122>
 8021c10:	50014000 	.word	0x50014000
 8021c14:	20000020 	.word	0x20000020
 8021c18:	20000010 	.word	0x20000010
 8021c1c:	50004900 	.word	0x50004900

08021c20 <XMC_DMA_CH_EnableEvent>:

  for(event_idx = 0UL; event_idx < DMA_EVENT_MAX; ++event_idx)
  {
    if (event & ((uint32_t)0x1UL << event_idx))
    {
      dma->MASKCHEV[event_idx * 2UL] = ((uint32_t)0x101UL << channel);
 8021c20:	f240 1301 	movw	r3, #257	; 0x101
 8021c24:	408b      	lsls	r3, r1
{
  uint32_t event_idx;

  for(event_idx = 0UL; event_idx < DMA_EVENT_MAX; ++event_idx)
  {
    if (event & ((uint32_t)0x1UL << event_idx))
 8021c26:	07d1      	lsls	r1, r2, #31
    {
      dma->MASKCHEV[event_idx * 2UL] = ((uint32_t)0x101UL << channel);
 8021c28:	bf48      	it	mi
 8021c2a:	f8c0 3310 	strmi.w	r3, [r0, #784]	; 0x310
{
  uint32_t event_idx;

  for(event_idx = 0UL; event_idx < DMA_EVENT_MAX; ++event_idx)
  {
    if (event & ((uint32_t)0x1UL << event_idx))
 8021c2e:	0791      	lsls	r1, r2, #30
    {
      dma->MASKCHEV[event_idx * 2UL] = ((uint32_t)0x101UL << channel);
 8021c30:	bf48      	it	mi
 8021c32:	f8c0 3318 	strmi.w	r3, [r0, #792]	; 0x318
{
  uint32_t event_idx;

  for(event_idx = 0UL; event_idx < DMA_EVENT_MAX; ++event_idx)
  {
    if (event & ((uint32_t)0x1UL << event_idx))
 8021c36:	0751      	lsls	r1, r2, #29
    {
      dma->MASKCHEV[event_idx * 2UL] = ((uint32_t)0x101UL << channel);
 8021c38:	bf48      	it	mi
 8021c3a:	f8c0 3320 	strmi.w	r3, [r0, #800]	; 0x320
{
  uint32_t event_idx;

  for(event_idx = 0UL; event_idx < DMA_EVENT_MAX; ++event_idx)
  {
    if (event & ((uint32_t)0x1UL << event_idx))
 8021c3e:	0711      	lsls	r1, r2, #28
    {
      dma->MASKCHEV[event_idx * 2UL] = ((uint32_t)0x101UL << channel);
 8021c40:	bf48      	it	mi
 8021c42:	f8c0 3328 	strmi.w	r3, [r0, #808]	; 0x328
{
  uint32_t event_idx;

  for(event_idx = 0UL; event_idx < DMA_EVENT_MAX; ++event_idx)
  {
    if (event & ((uint32_t)0x1UL << event_idx))
 8021c46:	06d2      	lsls	r2, r2, #27
    {
      dma->MASKCHEV[event_idx * 2UL] = ((uint32_t)0x101UL << channel);
 8021c48:	bf48      	it	mi
 8021c4a:	f8c0 3330 	strmi.w	r3, [r0, #816]	; 0x330
 8021c4e:	4770      	bx	lr

08021c50 <XMC_DMA_CH_SetEventHandler>:

/* Set event handler */
void XMC_DMA_CH_SetEventHandler(XMC_DMA_t *const dma, const uint8_t channel, XMC_DMA_CH_EVENT_HANDLER_t event_handler)
{
#if defined(GPDMA1)
  if (dma == XMC_DMA0)
 8021c50:	4b03      	ldr	r3, [pc, #12]	; (8021c60 <XMC_DMA_CH_SetEventHandler+0x10>)
 8021c52:	4298      	cmp	r0, r3
  {
#endif
    dma0_event_handlers[channel] = event_handler;
 8021c54:	bf0c      	ite	eq
 8021c56:	4b03      	ldreq	r3, [pc, #12]	; (8021c64 <XMC_DMA_CH_SetEventHandler+0x14>)
#if defined(GPDMA1)
  }
  else
  {
    dma1_event_handlers[channel] = event_handler;
 8021c58:	4b03      	ldrne	r3, [pc, #12]	; (8021c68 <XMC_DMA_CH_SetEventHandler+0x18>)
 8021c5a:	f843 2021 	str.w	r2, [r3, r1, lsl #2]
 8021c5e:	4770      	bx	lr
 8021c60:	50014000 	.word	0x50014000
 8021c64:	1fff0044 	.word	0x1fff0044
 8021c68:	1fff0064 	.word	0x1fff0064

08021c6c <XMC_DMA_CH_ClearSourcePeripheralRequest>:
}

void XMC_DMA_CH_ClearSourcePeripheralRequest(XMC_DMA_t *const dma, uint8_t channel)
{
  uint32_t line;
  line = (dma->CH[channel].CFGH & GPDMA0_CH_CFGH_SRC_PER_Msk) >> GPDMA0_CH_CFGH_SRC_PER_Pos;
 8021c6c:	2358      	movs	r3, #88	; 0x58
 8021c6e:	fb03 0101 	mla	r1, r3, r1, r0
}

void XMC_DMA_ClearRequestLine(XMC_DMA_t *const dma, uint8_t line)
{
#if defined(GPDMA1)
  if (dma == XMC_DMA0)
 8021c72:	4a0a      	ldr	r2, [pc, #40]	; (8021c9c <XMC_DMA_CH_ClearSourcePeripheralRequest+0x30>)
}

void XMC_DMA_CH_ClearSourcePeripheralRequest(XMC_DMA_t *const dma, uint8_t channel)
{
  uint32_t line;
  line = (dma->CH[channel].CFGH & GPDMA0_CH_CFGH_SRC_PER_Msk) >> GPDMA0_CH_CFGH_SRC_PER_Pos;
 8021c74:	6c4b      	ldr	r3, [r1, #68]	; 0x44
 8021c76:	f3c3 11c3 	ubfx	r1, r3, #7, #4
{
#if defined(GPDMA1)
  if (dma == XMC_DMA0)
  {
#endif
    DLR->LNEN &= ~(0x1UL << line);
 8021c7a:	4b09      	ldr	r3, [pc, #36]	; (8021ca0 <XMC_DMA_CH_ClearSourcePeripheralRequest+0x34>)
}

void XMC_DMA_ClearRequestLine(XMC_DMA_t *const dma, uint8_t line)
{
#if defined(GPDMA1)
  if (dma == XMC_DMA0)
 8021c7c:	4290      	cmp	r0, r2
  {
#endif
    DLR->LNEN &= ~(0x1UL << line);
 8021c7e:	bf08      	it	eq
 8021c80:	2201      	moveq	r2, #1
	DLR->LNEN |= 0x1UL << line;
#if defined(GPDMA1)
  }
  else
  {
    DLR->LNEN &= ~(0x100UL << line);
 8021c82:	6918      	ldr	r0, [r3, #16]
 8021c84:	bf18      	it	ne
 8021c86:	f44f 7280 	movne.w	r2, #256	; 0x100
 8021c8a:	408a      	lsls	r2, r1
 8021c8c:	ea20 0102 	bic.w	r1, r0, r2
 8021c90:	6119      	str	r1, [r3, #16]
	DLR->LNEN |= 0x100UL << line;
 8021c92:	6919      	ldr	r1, [r3, #16]
 8021c94:	430a      	orrs	r2, r1
 8021c96:	611a      	str	r2, [r3, #16]
 8021c98:	4770      	bx	lr
 8021c9a:	bf00      	nop
 8021c9c:	50014000 	.word	0x50014000
 8021ca0:	50004900 	.word	0x50004900

08021ca4 <XMC_DMA_IRQHandler>:
    dma_event_handlers = dma0_event_handlers;
#if defined(GPDMA1)
  }
  else
  {
    dma_event_handlers = dma1_event_handlers;
 8021ca4:	4a5a      	ldr	r2, [pc, #360]	; (8021e10 <XMC_DMA_IRQHandler+0x16c>)
 8021ca6:	495b      	ldr	r1, [pc, #364]	; (8021e14 <XMC_DMA_IRQHandler+0x170>)
 * Destination transaction complete -> ::XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE <br>
 * DMA error event -> ::XMC_DMA_CH_EVENT_ERROR                                     <br>
 */
__STATIC_INLINE uint32_t XMC_DMA_GetEventStatus(XMC_DMA_t *const dma)
{
  return (dma->STATUSGLEV);
 8021ca8:	f8d0 3360 	ldr.w	r3, [r0, #864]	; 0x360
  XMC_DMA_ClearRequestLine(dma, (uint8_t)line);
}

/* Default DMA IRQ handler */
void XMC_DMA_IRQHandler(XMC_DMA_t *const dma)
{
 8021cac:	b430      	push	{r4, r5}
  uint32_t mask;
  XMC_DMA_CH_EVENT_HANDLER_t *dma_event_handlers;
  XMC_DMA_CH_EVENT_HANDLER_t event_handler;

#if defined(GPDMA1)
  if (dma == XMC_DMA0)
 8021cae:	4d5a      	ldr	r5, [pc, #360]	; (8021e18 <XMC_DMA_IRQHandler+0x174>)
    dma_event_handlers = dma0_event_handlers;
#if defined(GPDMA1)
  }
  else
  {
    dma_event_handlers = dma1_event_handlers;
 8021cb0:	42a8      	cmp	r0, r5
 8021cb2:	bf0c      	ite	eq
 8021cb4:	460d      	moveq	r5, r1
 8021cb6:	4615      	movne	r5, r2
#endif
  
  event = XMC_DMA_GetEventStatus(dma);
  channel = 0;

  if ((event & (uint32_t)XMC_DMA_CH_EVENT_ERROR) != (uint32_t)0UL)
 8021cb8:	f013 0210 	ands.w	r2, r3, #16
 8021cbc:	d01d      	beq.n	8021cfa <XMC_DMA_IRQHandler+0x56>
 * \par
 * The function returns error interrupt status. <br>
 */
__STATIC_INLINE uint32_t XMC_DMA_GetChannelsErrorStatus(XMC_DMA_t *const dma)
{
  return (dma->STATUSCHEV[8]);
 8021cbe:	f8d0 1308 	ldr.w	r1, [r0, #776]	; 0x308
  {
    event = XMC_DMA_GetChannelsErrorStatus(dma);
    while (event != 0)
 8021cc2:	b1c1      	cbz	r1, 8021cf6 <XMC_DMA_IRQHandler+0x52>
    {
      mask = (uint32_t)1U << channel;
      if ((event & mask) != 0)
 8021cc4:	07cb      	lsls	r3, r1, #31
 8021cc6:	f100 8097 	bmi.w	8021df8 <XMC_DMA_IRQHandler+0x154>
 8021cca:	2301      	movs	r3, #1
  if ((event & (uint32_t)XMC_DMA_CH_EVENT_ERROR) != (uint32_t)0UL)
  {
    event = XMC_DMA_GetChannelsErrorStatus(dma);
    while (event != 0)
    {
      mask = (uint32_t)1U << channel;
 8021ccc:	461c      	mov	r4, r3
 8021cce:	e000      	b.n	8021cd2 <XMC_DMA_IRQHandler+0x2e>
          event_handler(XMC_DMA_CH_EVENT_ERROR);
        }
       
        break;
      }
      ++channel;
 8021cd0:	3301      	adds	r3, #1
  if ((event & (uint32_t)XMC_DMA_CH_EVENT_ERROR) != (uint32_t)0UL)
  {
    event = XMC_DMA_GetChannelsErrorStatus(dma);
    while (event != 0)
    {
      mask = (uint32_t)1U << channel;
 8021cd2:	fa04 f203 	lsl.w	r2, r4, r3
      if ((event & mask) != 0)
 8021cd6:	420a      	tst	r2, r1
 8021cd8:	d0fa      	beq.n	8021cd0 <XMC_DMA_IRQHandler+0x2c>
 8021cda:	009a      	lsls	r2, r3, #2
      {
        XMC_DMA_CH_ClearEventStatus(dma, (uint8_t)channel, (uint32_t)XMC_DMA_CH_EVENT_ERROR);

        /* Call user callback to handle event */
        event_handler = dma_event_handlers[channel];
 8021cdc:	58a9      	ldr	r1, [r5, r2]

  for(event_idx = 0UL; event_idx < DMA_EVENT_MAX; ++event_idx)
  {
    if (event & (uint32_t)((uint32_t)0x1UL << event_idx))
    {
      dma->CLEARCHEV[event_idx * 2UL] = ((uint32_t)0x1UL << channel);
 8021cde:	b2db      	uxtb	r3, r3
 8021ce0:	2201      	movs	r2, #1
 8021ce2:	fa02 f303 	lsl.w	r3, r2, r3
 8021ce6:	f8c0 3358 	str.w	r3, [r0, #856]	; 0x358
      {
        XMC_DMA_CH_ClearEventStatus(dma, (uint8_t)channel, (uint32_t)XMC_DMA_CH_EVENT_ERROR);

        /* Call user callback to handle event */
        event_handler = dma_event_handlers[channel];
        if (event_handler != NULL)
 8021cea:	b121      	cbz	r1, 8021cf6 <XMC_DMA_IRQHandler+0x52>
        {
          event_handler(XMC_DMA_CH_EVENT_ERROR);
 8021cec:	2010      	movs	r0, #16
  else
  {
    /* no active interrupt was found? */
  }

}
 8021cee:	bc30      	pop	{r4, r5}

        /* Call user callback to handle event */
        event_handler = dma_event_handlers[channel];
        if (event_handler != NULL)
        {
          event_handler(XMC_DMA_CH_EVENT_ERROR);
 8021cf0:	4708      	bx	r1
        break;
      }
      ++channel;
    }
  }
  else if ((event & (uint32_t)XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE) != (uint32_t)0UL)
 8021cf2:	071a      	lsls	r2, r3, #28
 8021cf4:	d465      	bmi.n	8021dc2 <XMC_DMA_IRQHandler+0x11e>
  else
  {
    /* no active interrupt was found? */
  }

}
 8021cf6:	bc30      	pop	{r4, r5}
 8021cf8:	4770      	bx	lr
        break;
      }
      ++channel;
    }
  }
  else if ((event & (uint32_t)XMC_DMA_CH_EVENT_TRANSFER_COMPLETE) != (uint32_t)0UL)
 8021cfa:	f013 0401 	ands.w	r4, r3, #1
 8021cfe:	d020      	beq.n	8021d42 <XMC_DMA_IRQHandler+0x9e>
 * \par
 * The function returns GPDMA transfer complete interrupt status. <br>
 */
__STATIC_INLINE uint32_t XMC_DMA_GetChannelsTransferCompleteStatus(XMC_DMA_t *const dma)
{
  return (dma->STATUSCHEV[0]);
 8021d00:	f8d0 12e8 	ldr.w	r1, [r0, #744]	; 0x2e8
  {
    event = XMC_DMA_GetChannelsTransferCompleteStatus(dma);
    while (event != 0)
 8021d04:	2900      	cmp	r1, #0
 8021d06:	d0f6      	beq.n	8021cf6 <XMC_DMA_IRQHandler+0x52>
    {
      mask = (uint32_t)1U << channel;
      if (event & mask)
 8021d08:	07cc      	lsls	r4, r1, #31
 8021d0a:	d478      	bmi.n	8021dfe <XMC_DMA_IRQHandler+0x15a>
 8021d0c:	2301      	movs	r3, #1
  else if ((event & (uint32_t)XMC_DMA_CH_EVENT_TRANSFER_COMPLETE) != (uint32_t)0UL)
  {
    event = XMC_DMA_GetChannelsTransferCompleteStatus(dma);
    while (event != 0)
    {
      mask = (uint32_t)1U << channel;
 8021d0e:	461c      	mov	r4, r3
 8021d10:	e000      	b.n	8021d14 <XMC_DMA_IRQHandler+0x70>
          event_handler(XMC_DMA_CH_EVENT_TRANSFER_COMPLETE);
        }
																	  
        break;
      }
      ++channel;
 8021d12:	3301      	adds	r3, #1
  else if ((event & (uint32_t)XMC_DMA_CH_EVENT_TRANSFER_COMPLETE) != (uint32_t)0UL)
  {
    event = XMC_DMA_GetChannelsTransferCompleteStatus(dma);
    while (event != 0)
    {
      mask = (uint32_t)1U << channel;
 8021d14:	fa04 f203 	lsl.w	r2, r4, r3
      if (event & mask)
 8021d18:	420a      	tst	r2, r1
 8021d1a:	d0fa      	beq.n	8021d12 <XMC_DMA_IRQHandler+0x6e>
 8021d1c:	009a      	lsls	r2, r3, #2
                                                                      (uint32_t)XMC_DMA_CH_EVENT_BLOCK_TRANSFER_COMPLETE | 
                                                                      (uint32_t)XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE | 
                                                                      (uint32_t)XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE));

        /* Call user callback to handle event */
        event_handler = dma_event_handlers[channel];
 8021d1e:	58aa      	ldr	r2, [r5, r2]

  for(event_idx = 0UL; event_idx < DMA_EVENT_MAX; ++event_idx)
  {
    if (event & (uint32_t)((uint32_t)0x1UL << event_idx))
    {
      dma->CLEARCHEV[event_idx * 2UL] = ((uint32_t)0x1UL << channel);
 8021d20:	b2db      	uxtb	r3, r3
 8021d22:	2101      	movs	r1, #1
 8021d24:	fa01 f303 	lsl.w	r3, r1, r3
 8021d28:	f8c0 3338 	str.w	r3, [r0, #824]	; 0x338
 8021d2c:	f8c0 3340 	str.w	r3, [r0, #832]	; 0x340
 8021d30:	f8c0 3348 	str.w	r3, [r0, #840]	; 0x348
 8021d34:	f8c0 3350 	str.w	r3, [r0, #848]	; 0x350
                                                                      (uint32_t)XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE | 
                                                                      (uint32_t)XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE));

        /* Call user callback to handle event */
        event_handler = dma_event_handlers[channel];
        if (event_handler != NULL)
 8021d38:	2a00      	cmp	r2, #0
 8021d3a:	d0dc      	beq.n	8021cf6 <XMC_DMA_IRQHandler+0x52>
        {
          event_handler(XMC_DMA_CH_EVENT_TRANSFER_COMPLETE);
 8021d3c:	4608      	mov	r0, r1
  else
  {
    /* no active interrupt was found? */
  }

}
 8021d3e:	bc30      	pop	{r4, r5}

        /* Call user callback to handle event */
        event_handler = dma_event_handlers[channel];
        if (event_handler != NULL)
        {
          event_handler(XMC_DMA_CH_EVENT_TRANSFER_COMPLETE);
 8021d40:	4710      	bx	r2
        break;
      }
      ++channel;
    }
  }
  else if ((event & (uint32_t)XMC_DMA_CH_EVENT_BLOCK_TRANSFER_COMPLETE) != (uint32_t)0UL)
 8021d42:	f013 0202 	ands.w	r2, r3, #2
 8021d46:	d11d      	bne.n	8021d84 <XMC_DMA_IRQHandler+0xe0>
        break;
      }
      ++channel;
    }
  }
  else if ((event & (uint32_t)XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE) != (uint32_t)0UL)
 8021d48:	f013 0404 	ands.w	r4, r3, #4
 8021d4c:	d0d1      	beq.n	8021cf2 <XMC_DMA_IRQHandler+0x4e>
 * If the source peripheral is memory, the source transaction complete interrupt is
 * ignored.
 */
__STATIC_INLINE uint32_t XMC_DMA_GetChannelsSourceTransactionCompleteStatus(XMC_DMA_t *const dma)
{
  return (dma->STATUSCHEV[4]);
 8021d4e:	f8d0 12f8 	ldr.w	r1, [r0, #760]	; 0x2f8
  {
    event = XMC_DMA_GetChannelsSourceTransactionCompleteStatus(dma);
    while (event != 0)
 8021d52:	2900      	cmp	r1, #0
 8021d54:	d0cf      	beq.n	8021cf6 <XMC_DMA_IRQHandler+0x52>
    {
      mask = (uint32_t)1U << channel;
      if (event & mask)
 8021d56:	07cc      	lsls	r4, r1, #31
 8021d58:	d455      	bmi.n	8021e06 <XMC_DMA_IRQHandler+0x162>
 8021d5a:	2301      	movs	r3, #1
  else if ((event & (uint32_t)XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE) != (uint32_t)0UL)
  {
    event = XMC_DMA_GetChannelsSourceTransactionCompleteStatus(dma);
    while (event != 0)
    {
      mask = (uint32_t)1U << channel;
 8021d5c:	461c      	mov	r4, r3
 8021d5e:	e000      	b.n	8021d62 <XMC_DMA_IRQHandler+0xbe>
          event_handler(XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE);
        }
        
        break;
      }
      ++channel;
 8021d60:	3301      	adds	r3, #1
  else if ((event & (uint32_t)XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE) != (uint32_t)0UL)
  {
    event = XMC_DMA_GetChannelsSourceTransactionCompleteStatus(dma);
    while (event != 0)
    {
      mask = (uint32_t)1U << channel;
 8021d62:	fa04 f203 	lsl.w	r2, r4, r3
      if (event & mask)
 8021d66:	420a      	tst	r2, r1
 8021d68:	d0fa      	beq.n	8021d60 <XMC_DMA_IRQHandler+0xbc>
 8021d6a:	009a      	lsls	r2, r3, #2
      {
        XMC_DMA_CH_ClearEventStatus(dma, (uint8_t)channel, (uint32_t)XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE);

        /* Call user callback to handle event */
        event_handler = dma_event_handlers[channel];
 8021d6c:	58a9      	ldr	r1, [r5, r2]

  for(event_idx = 0UL; event_idx < DMA_EVENT_MAX; ++event_idx)
  {
    if (event & (uint32_t)((uint32_t)0x1UL << event_idx))
    {
      dma->CLEARCHEV[event_idx * 2UL] = ((uint32_t)0x1UL << channel);
 8021d6e:	b2db      	uxtb	r3, r3
 8021d70:	2201      	movs	r2, #1
 8021d72:	fa02 f303 	lsl.w	r3, r2, r3
 8021d76:	f8c0 3348 	str.w	r3, [r0, #840]	; 0x348
      {
        XMC_DMA_CH_ClearEventStatus(dma, (uint8_t)channel, (uint32_t)XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE);

        /* Call user callback to handle event */
        event_handler = dma_event_handlers[channel];
        if (event_handler != NULL)
 8021d7a:	2900      	cmp	r1, #0
 8021d7c:	d0bb      	beq.n	8021cf6 <XMC_DMA_IRQHandler+0x52>
        {
          event_handler(XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE);
 8021d7e:	2004      	movs	r0, #4
  else
  {
    /* no active interrupt was found? */
  }

}
 8021d80:	bc30      	pop	{r4, r5}

        /* Call user callback to handle event */
        event_handler = dma_event_handlers[channel];
        if (event_handler != NULL)
        {
          event_handler(XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE);
 8021d82:	4708      	bx	r1
 * \par
 * The function returns GPDMA block transfer complete interrupt status. <br>
 */
__STATIC_INLINE uint32_t XMC_DMA_GetChannelsBlockCompleteStatus(XMC_DMA_t *const dma)
{
  return (dma->STATUSCHEV[2]);
 8021d84:	f8d0 12f0 	ldr.w	r1, [r0, #752]	; 0x2f0
    }
  }
  else if ((event & (uint32_t)XMC_DMA_CH_EVENT_BLOCK_TRANSFER_COMPLETE) != (uint32_t)0UL)
  {
    event = XMC_DMA_GetChannelsBlockCompleteStatus(dma);
    while (event != 0)
 8021d88:	2900      	cmp	r1, #0
 8021d8a:	d0b4      	beq.n	8021cf6 <XMC_DMA_IRQHandler+0x52>
    {
      mask = (uint32_t)1U << channel;
      if (event & mask)
 8021d8c:	07cb      	lsls	r3, r1, #31
 8021d8e:	d438      	bmi.n	8021e02 <XMC_DMA_IRQHandler+0x15e>
 8021d90:	2301      	movs	r3, #1
  else if ((event & (uint32_t)XMC_DMA_CH_EVENT_BLOCK_TRANSFER_COMPLETE) != (uint32_t)0UL)
  {
    event = XMC_DMA_GetChannelsBlockCompleteStatus(dma);
    while (event != 0)
    {
      mask = (uint32_t)1U << channel;
 8021d92:	461c      	mov	r4, r3
 8021d94:	e000      	b.n	8021d98 <XMC_DMA_IRQHandler+0xf4>
          event_handler(XMC_DMA_CH_EVENT_BLOCK_TRANSFER_COMPLETE);
        }

        break;
      }
      ++channel;
 8021d96:	3301      	adds	r3, #1
  else if ((event & (uint32_t)XMC_DMA_CH_EVENT_BLOCK_TRANSFER_COMPLETE) != (uint32_t)0UL)
  {
    event = XMC_DMA_GetChannelsBlockCompleteStatus(dma);
    while (event != 0)
    {
      mask = (uint32_t)1U << channel;
 8021d98:	fa04 f203 	lsl.w	r2, r4, r3
      if (event & mask)
 8021d9c:	420a      	tst	r2, r1
 8021d9e:	d0fa      	beq.n	8021d96 <XMC_DMA_IRQHandler+0xf2>
 8021da0:	009c      	lsls	r4, r3, #2
        XMC_DMA_CH_ClearEventStatus(dma, (uint8_t)channel, (uint32_t)((uint32_t)XMC_DMA_CH_EVENT_BLOCK_TRANSFER_COMPLETE |
                                                                      (uint32_t)XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE | 
                                                                      (uint32_t)XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE));

        /* Call user callback to handle event */
        event_handler = dma_event_handlers[channel];
 8021da2:	5929      	ldr	r1, [r5, r4]

  for(event_idx = 0UL; event_idx < DMA_EVENT_MAX; ++event_idx)
  {
    if (event & (uint32_t)((uint32_t)0x1UL << event_idx))
    {
      dma->CLEARCHEV[event_idx * 2UL] = ((uint32_t)0x1UL << channel);
 8021da4:	b2db      	uxtb	r3, r3
 8021da6:	2201      	movs	r2, #1
 8021da8:	fa02 f303 	lsl.w	r3, r2, r3
 8021dac:	f8c0 3340 	str.w	r3, [r0, #832]	; 0x340
 8021db0:	f8c0 3348 	str.w	r3, [r0, #840]	; 0x348
 8021db4:	f8c0 3350 	str.w	r3, [r0, #848]	; 0x350
                                                                      (uint32_t)XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE | 
                                                                      (uint32_t)XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE));

        /* Call user callback to handle event */
        event_handler = dma_event_handlers[channel];
        if (event_handler != NULL)
 8021db8:	2900      	cmp	r1, #0
 8021dba:	d09c      	beq.n	8021cf6 <XMC_DMA_IRQHandler+0x52>
        {
          event_handler(XMC_DMA_CH_EVENT_BLOCK_TRANSFER_COMPLETE);
 8021dbc:	2002      	movs	r0, #2
  else
  {
    /* no active interrupt was found? */
  }

}
 8021dbe:	bc30      	pop	{r4, r5}

        /* Call user callback to handle event */
        event_handler = dma_event_handlers[channel];
        if (event_handler != NULL)
        {
          event_handler(XMC_DMA_CH_EVENT_BLOCK_TRANSFER_COMPLETE);
 8021dc0:	4708      	bx	r1
 * If the destination peripheral is memory, the destination transaction complete
 * interrupt is ignored.
 */
__STATIC_INLINE uint32_t XMC_DMA_GetChannelsDestinationTransactionCompleteStatus(XMC_DMA_t *const dma)
{
  return (dma->STATUSCHEV[6]);
 8021dc2:	f8d0 1300 	ldr.w	r1, [r0, #768]	; 0x300
    }
  }
  else if ((event & (uint32_t)XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE) != (uint32_t)0UL)
  {
    event = XMC_DMA_GetChannelsDestinationTransactionCompleteStatus(dma);
    while (event != 0)
 8021dc6:	2900      	cmp	r1, #0
 8021dc8:	d095      	beq.n	8021cf6 <XMC_DMA_IRQHandler+0x52>
    {
      mask = (uint32_t)1U << channel;
      if (event & mask)
 8021dca:	07cb      	lsls	r3, r1, #31
 8021dcc:	d41d      	bmi.n	8021e0a <XMC_DMA_IRQHandler+0x166>
 8021dce:	2301      	movs	r3, #1
  else if ((event & (uint32_t)XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE) != (uint32_t)0UL)
  {
    event = XMC_DMA_GetChannelsDestinationTransactionCompleteStatus(dma);
    while (event != 0)
    {
      mask = (uint32_t)1U << channel;
 8021dd0:	461c      	mov	r4, r3
 8021dd2:	e000      	b.n	8021dd6 <XMC_DMA_IRQHandler+0x132>
          event_handler(XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE);
        }      

        break;
      }
      ++channel;
 8021dd4:	3301      	adds	r3, #1
  else if ((event & (uint32_t)XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE) != (uint32_t)0UL)
  {
    event = XMC_DMA_GetChannelsDestinationTransactionCompleteStatus(dma);
    while (event != 0)
    {
      mask = (uint32_t)1U << channel;
 8021dd6:	fa04 f203 	lsl.w	r2, r4, r3
      if (event & mask)
 8021dda:	420a      	tst	r2, r1
 8021ddc:	d0fa      	beq.n	8021dd4 <XMC_DMA_IRQHandler+0x130>
 8021dde:	009c      	lsls	r4, r3, #2

  for(event_idx = 0UL; event_idx < DMA_EVENT_MAX; ++event_idx)
  {
    if (event & (uint32_t)((uint32_t)0x1UL << event_idx))
    {
      dma->CLEARCHEV[event_idx * 2UL] = ((uint32_t)0x1UL << channel);
 8021de0:	b2db      	uxtb	r3, r3
      if (event & mask)
      {
        XMC_DMA_CH_ClearEventStatus(dma, (uint8_t)channel, (uint32_t)XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE);

        /* Call user callback to handle event */
        event_handler = dma_event_handlers[channel];
 8021de2:	5929      	ldr	r1, [r5, r4]

  for(event_idx = 0UL; event_idx < DMA_EVENT_MAX; ++event_idx)
  {
    if (event & (uint32_t)((uint32_t)0x1UL << event_idx))
    {
      dma->CLEARCHEV[event_idx * 2UL] = ((uint32_t)0x1UL << channel);
 8021de4:	2201      	movs	r2, #1
 8021de6:	fa02 f303 	lsl.w	r3, r2, r3
 8021dea:	f8c0 3350 	str.w	r3, [r0, #848]	; 0x350
      {
        XMC_DMA_CH_ClearEventStatus(dma, (uint8_t)channel, (uint32_t)XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE);

        /* Call user callback to handle event */
        event_handler = dma_event_handlers[channel];
        if (event_handler != NULL)
 8021dee:	2900      	cmp	r1, #0
 8021df0:	d081      	beq.n	8021cf6 <XMC_DMA_IRQHandler+0x52>
        {
          event_handler(XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE);
 8021df2:	2008      	movs	r0, #8
  else
  {
    /* no active interrupt was found? */
  }

}
 8021df4:	bc30      	pop	{r4, r5}

        /* Call user callback to handle event */
        event_handler = dma_event_handlers[channel];
        if (event_handler != NULL)
        {
          event_handler(XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE);
 8021df6:	4708      	bx	r1
  {
    event = XMC_DMA_GetChannelsErrorStatus(dma);
    while (event != 0)
    {
      mask = (uint32_t)1U << channel;
      if ((event & mask) != 0)
 8021df8:	2200      	movs	r2, #0
    dma_event_handlers = dma1_event_handlers;
  }
#endif
  
  event = XMC_DMA_GetEventStatus(dma);
  channel = 0;
 8021dfa:	4613      	mov	r3, r2
 8021dfc:	e76e      	b.n	8021cdc <XMC_DMA_IRQHandler+0x38>
 8021dfe:	4613      	mov	r3, r2
 8021e00:	e78d      	b.n	8021d1e <XMC_DMA_IRQHandler+0x7a>
 8021e02:	4623      	mov	r3, r4
 8021e04:	e7cd      	b.n	8021da2 <XMC_DMA_IRQHandler+0xfe>
 8021e06:	4613      	mov	r3, r2
 8021e08:	e7b0      	b.n	8021d6c <XMC_DMA_IRQHandler+0xc8>
 8021e0a:	4623      	mov	r3, r4
 8021e0c:	e7e8      	b.n	8021de0 <XMC_DMA_IRQHandler+0x13c>
 8021e0e:	bf00      	nop
 8021e10:	1fff0064 	.word	0x1fff0064
 8021e14:	1fff0044 	.word	0x1fff0044
 8021e18:	50014000 	.word	0x50014000

08021e1c <XMC_GPIO_SetMode>:
/*******************************************************************************
 * API IMPLEMENTATION
 *******************************************************************************/

void XMC_GPIO_SetMode(XMC_GPIO_PORT_t *const port, const uint8_t pin, const XMC_GPIO_MODE_t mode)
{
 8021e1c:	f001 03fc 	and.w	r3, r1, #252	; 0xfc
 8021e20:	4418      	add	r0, r3
  XMC_ASSERT("XMC_GPIO_SetMode: Invalid port", XMC_GPIO_CHECK_PORT(port));
  XMC_ASSERT("XMC_GPIO_SetMode: Invalid mode", XMC_GPIO_IsModeValid(mode));

  port->IOCR[(uint32_t)pin >> 2U] &= ~(uint32_t)((uint32_t)PORT_IOCR_PC_Msk << ((uint32_t)PORT_IOCR_PC_Size * ((uint32_t)pin & 0x3U)));
 8021e22:	f001 0103 	and.w	r1, r1, #3
/*******************************************************************************
 * API IMPLEMENTATION
 *******************************************************************************/

void XMC_GPIO_SetMode(XMC_GPIO_PORT_t *const port, const uint8_t pin, const XMC_GPIO_MODE_t mode)
{
 8021e26:	b410      	push	{r4}
  XMC_ASSERT("XMC_GPIO_SetMode: Invalid port", XMC_GPIO_CHECK_PORT(port));
  XMC_ASSERT("XMC_GPIO_SetMode: Invalid mode", XMC_GPIO_IsModeValid(mode));

  port->IOCR[(uint32_t)pin >> 2U] &= ~(uint32_t)((uint32_t)PORT_IOCR_PC_Msk << ((uint32_t)PORT_IOCR_PC_Size * ((uint32_t)pin & 0x3U)));
 8021e28:	00c9      	lsls	r1, r1, #3
 8021e2a:	6904      	ldr	r4, [r0, #16]
 8021e2c:	23f8      	movs	r3, #248	; 0xf8
 8021e2e:	408b      	lsls	r3, r1
 8021e30:	ea24 0303 	bic.w	r3, r4, r3
 8021e34:	6103      	str	r3, [r0, #16]
  port->IOCR[(uint32_t)pin >> 2U] |= (uint32_t)mode << ((uint32_t)PORT_IOCR_PC_Size * ((uint32_t)pin & 0x3U));
 8021e36:	6903      	ldr	r3, [r0, #16]
}
 8021e38:	f85d 4b04 	ldr.w	r4, [sp], #4
{
  XMC_ASSERT("XMC_GPIO_SetMode: Invalid port", XMC_GPIO_CHECK_PORT(port));
  XMC_ASSERT("XMC_GPIO_SetMode: Invalid mode", XMC_GPIO_IsModeValid(mode));

  port->IOCR[(uint32_t)pin >> 2U] &= ~(uint32_t)((uint32_t)PORT_IOCR_PC_Msk << ((uint32_t)PORT_IOCR_PC_Size * ((uint32_t)pin & 0x3U)));
  port->IOCR[(uint32_t)pin >> 2U] |= (uint32_t)mode << ((uint32_t)PORT_IOCR_PC_Size * ((uint32_t)pin & 0x3U));
 8021e3c:	408a      	lsls	r2, r1
 8021e3e:	4313      	orrs	r3, r2
 8021e40:	6103      	str	r3, [r0, #16]
}
 8021e42:	4770      	bx	lr

08021e44 <XMC_GPIO_SetHardwareControl>:

void XMC_GPIO_SetHardwareControl(XMC_GPIO_PORT_t *const port, const uint8_t pin, const XMC_GPIO_HWCTRL_t hwctrl)
{
 8021e44:	b410      	push	{r4}
  XMC_ASSERT("XMC_GPIO_SetHardwareControl: Invalid port", XMC_GPIO_CHECK_PORT(port));
  XMC_ASSERT("XMC_GPIO_SetHardwareControl: Invalid hwctrl", XMC_GPIO_CHECK_HWCTRL(hwctrl));

  port->HWSEL &= ~(uint32_t)((uint32_t)PORT_HWSEL_Msk << ((uint32_t)pin << 1U));
 8021e46:	0049      	lsls	r1, r1, #1
 8021e48:	6f44      	ldr	r4, [r0, #116]	; 0x74
 8021e4a:	2303      	movs	r3, #3
 8021e4c:	408b      	lsls	r3, r1
 8021e4e:	ea24 0303 	bic.w	r3, r4, r3
 8021e52:	6743      	str	r3, [r0, #116]	; 0x74
  port->HWSEL |= (uint32_t)hwctrl << ((uint32_t)pin << 1U);
 8021e54:	6f43      	ldr	r3, [r0, #116]	; 0x74
}
 8021e56:	f85d 4b04 	ldr.w	r4, [sp], #4
{
  XMC_ASSERT("XMC_GPIO_SetHardwareControl: Invalid port", XMC_GPIO_CHECK_PORT(port));
  XMC_ASSERT("XMC_GPIO_SetHardwareControl: Invalid hwctrl", XMC_GPIO_CHECK_HWCTRL(hwctrl));

  port->HWSEL &= ~(uint32_t)((uint32_t)PORT_HWSEL_Msk << ((uint32_t)pin << 1U));
  port->HWSEL |= (uint32_t)hwctrl << ((uint32_t)pin << 1U);
 8021e5a:	408a      	lsls	r2, r1
 8021e5c:	4313      	orrs	r3, r2
 8021e5e:	6743      	str	r3, [r0, #116]	; 0x74
}
 8021e60:	4770      	bx	lr
 8021e62:	bf00      	nop

08021e64 <XMC_I2C_CH_Init>:
/*********************************************************************************************************************
 * API IMPLEMENTATION
 *********************************************************************************************************************/
/* Initializes the USIC channel by setting the data format, slave address, baudrate, transfer buffer */
void XMC_I2C_CH_Init(XMC_USIC_CH_t *const channel, const XMC_I2C_CH_CONFIG_t *const config)
{
 8021e64:	b538      	push	{r3, r4, r5, lr}
 8021e66:	460d      	mov	r5, r1
 8021e68:	4604      	mov	r4, r0
  XMC_USIC_CH_Enable(channel);
 8021e6a:	f001 fa43 	bl	80232f4 <XMC_USIC_CH_Enable>
                  ((uint32_t)WORDLENGTH << (uint32_t)USIC_CH_SCTR_WLE_Pos) | /* 8 data bits */
                  USIC_CH_SCTR_FLE_Msk |           /* unlimited data flow */
                  USIC_CH_SCTR_SDIR_Msk |          /* MSB shifted first */
                  USIC_CH_SCTR_PDL_Msk;            /* Passive Data Level */

  XMC_I2C_CH_SetSlaveAddress(channel, config->address);
 8021e6e:	88ab      	ldrh	r3, [r5, #4]
void XMC_I2C_CH_Init(XMC_USIC_CH_t *const channel, const XMC_I2C_CH_CONFIG_t *const config)
{
  XMC_USIC_CH_Enable(channel);
  
  /* Data format configuration */
  channel->SCTR = ((uint32_t)TRANSMISSION_MODE << (uint32_t)USIC_CH_SCTR_TRM_Pos) | /* Transmision mode */
 8021e70:	4a18      	ldr	r2, [pc, #96]	; (8021ed4 <XMC_I2C_CH_Init+0x70>)
 8021e72:	6362      	str	r2, [r4, #52]	; 0x34
  channel->CCR = 0x0U;
}
/* Sets the slave address */
void XMC_I2C_CH_SetSlaveAddress(XMC_USIC_CH_t *const channel, const uint16_t address)
{
  if ((address & XMC_I2C_10BIT_ADDR_MASK) == XMC_I2C_10BIT_ADDR_GROUP)
 8021e74:	f403 42f8 	and.w	r2, r3, #31744	; 0x7c00
 8021e78:	f5b2 4ff0 	cmp.w	r2, #30720	; 0x7800
 8021e7c:	d023      	beq.n	8021ec6 <XMC_I2C_CH_Init+0x62>
  {
    channel->PCR_IICMode = (address & 0xffU) | ((address << 1) & 0xfe00U);
  }
  else
  {
    channel->PCR_IICMode = ((uint32_t)address) << XMC_I2C_7BIT_ADDR_Pos;
 8021e7e:	021b      	lsls	r3, r3, #8
 8021e80:	63e3      	str	r3, [r4, #60]	; 0x3c
                  USIC_CH_SCTR_FLE_Msk |           /* unlimited data flow */
                  USIC_CH_SCTR_SDIR_Msk |          /* MSB shifted first */
                  USIC_CH_SCTR_PDL_Msk;            /* Passive Data Level */

  XMC_I2C_CH_SetSlaveAddress(channel, config->address);
  (void)XMC_I2C_CH_SetBaudrate(channel, config->baudrate);
 8021e82:	6829      	ldr	r1, [r5, #0]
{
  XMC_I2C_CH_STATUS_t status;
  
  status = XMC_I2C_CH_STATUS_ERROR;
  
  if (rate <= (uint32_t)XMC_I2C_CH_MAX_SPEED_STANDARD)
 8021e84:	4b14      	ldr	r3, [pc, #80]	; (8021ed8 <XMC_I2C_CH_Init+0x74>)
 8021e86:	4299      	cmp	r1, r3
 8021e88:	d914      	bls.n	8021eb4 <XMC_I2C_CH_Init+0x50>
    if (XMC_USIC_CH_SetBaudrate(channel, rate, (uint32_t)XMC_I2C_CH_CLOCK_OVERSAMPLING_STANDARD) == XMC_USIC_CH_STATUS_OK)
    {
      status = XMC_I2C_CH_STATUS_OK;
    }
  }
  else if (rate <= (uint32_t)XMC_I2C_CH_MAX_SPEED_FAST)
 8021e8a:	4b14      	ldr	r3, [pc, #80]	; (8021edc <XMC_I2C_CH_Init+0x78>)
 8021e8c:	4299      	cmp	r1, r3
 8021e8e:	d908      	bls.n	8021ea2 <XMC_I2C_CH_Init+0x3e>

  XMC_I2C_CH_SetSlaveAddress(channel, config->address);
  (void)XMC_I2C_CH_SetBaudrate(channel, config->baudrate);
    
  /* Enable transfer buffer */
  channel->TCSR = ((uint32_t)SET_TDV << (uint32_t)USIC_CH_TCSR_TDEN_Pos) | USIC_CH_TCSR_TDSSM_Msk;
 8021e90:	f44f 61a0 	mov.w	r1, #1280	; 0x500

  /* Clear status flags */
  channel->PSCR = 0xFFFFFFFFU;
 8021e94:	f04f 32ff 	mov.w	r2, #4294967295

  /* Disable parity generation */
  channel->CCR = 0x0U;
 8021e98:	2300      	movs	r3, #0

  XMC_I2C_CH_SetSlaveAddress(channel, config->address);
  (void)XMC_I2C_CH_SetBaudrate(channel, config->baudrate);
    
  /* Enable transfer buffer */
  channel->TCSR = ((uint32_t)SET_TDV << (uint32_t)USIC_CH_TCSR_TDEN_Pos) | USIC_CH_TCSR_TDSSM_Msk;
 8021e9a:	63a1      	str	r1, [r4, #56]	; 0x38

  /* Clear status flags */
  channel->PSCR = 0xFFFFFFFFU;
 8021e9c:	64e2      	str	r2, [r4, #76]	; 0x4c

  /* Disable parity generation */
  channel->CCR = 0x0U;
 8021e9e:	6423      	str	r3, [r4, #64]	; 0x40
 8021ea0:	bd38      	pop	{r3, r4, r5, pc}
      status = XMC_I2C_CH_STATUS_OK;
    }
  }
  else if (rate <= (uint32_t)XMC_I2C_CH_MAX_SPEED_FAST)
  {
    channel->PCR_IICMode |= (uint32_t)USIC_CH_PCR_IICMode_STIM_Msk;
 8021ea2:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8021ea4:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8021ea8:	63e3      	str	r3, [r4, #60]	; 0x3c
    if (XMC_USIC_CH_SetBaudrate(channel, rate, (uint32_t)XMC_I2C_CH_CLOCK_OVERSAMPLING_FAST) == XMC_USIC_CH_STATUS_OK)
 8021eaa:	4620      	mov	r0, r4
 8021eac:	2219      	movs	r2, #25
 8021eae:	f001 fa63 	bl	8023378 <XMC_USIC_CH_SetBaudrate>
 8021eb2:	e7ed      	b.n	8021e90 <XMC_I2C_CH_Init+0x2c>
  
  status = XMC_I2C_CH_STATUS_ERROR;
  
  if (rate <= (uint32_t)XMC_I2C_CH_MAX_SPEED_STANDARD)
  {
		channel->PCR_IICMode &= (uint32_t)~USIC_CH_PCR_IICMode_STIM_Msk;
 8021eb4:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8021eb6:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
 8021eba:	63e3      	str	r3, [r4, #60]	; 0x3c
    if (XMC_USIC_CH_SetBaudrate(channel, rate, (uint32_t)XMC_I2C_CH_CLOCK_OVERSAMPLING_STANDARD) == XMC_USIC_CH_STATUS_OK)
 8021ebc:	4620      	mov	r0, r4
 8021ebe:	220a      	movs	r2, #10
 8021ec0:	f001 fa5a 	bl	8023378 <XMC_USIC_CH_SetBaudrate>
 8021ec4:	e7e4      	b.n	8021e90 <XMC_I2C_CH_Init+0x2c>
/* Sets the slave address */
void XMC_I2C_CH_SetSlaveAddress(XMC_USIC_CH_t *const channel, const uint16_t address)
{
  if ((address & XMC_I2C_10BIT_ADDR_MASK) == XMC_I2C_10BIT_ADDR_GROUP)
  {
    channel->PCR_IICMode = (address & 0xffU) | ((address << 1) & 0xfe00U);
 8021ec6:	005a      	lsls	r2, r3, #1
 8021ec8:	f402 427e 	and.w	r2, r2, #65024	; 0xfe00
 8021ecc:	b2db      	uxtb	r3, r3
 8021ece:	4313      	orrs	r3, r2
 8021ed0:	63e3      	str	r3, [r4, #60]	; 0x3c
 8021ed2:	e7d6      	b.n	8021e82 <XMC_I2C_CH_Init+0x1e>
 8021ed4:	073f0303 	.word	0x073f0303
 8021ed8:	000186a0 	.word	0x000186a0
 8021edc:	00061a80 	.word	0x00061a80

08021ee0 <XMC_I2C_CH_MasterStart>:
  {
    temp |= 0x1U;
  }

  /* Check FIFO size */
  if ((channel->TBCTR & USIC_CH_TBCTR_SIZE_Msk) == 0U)
 8021ee0:	f8d0 3108 	ldr.w	r3, [r0, #264]	; 0x108
void XMC_I2C_CH_MasterStart(XMC_USIC_CH_t *const channel, const uint16_t addr, const XMC_I2C_CH_CMD_t command)
{
  uint32_t temp;
  
  temp = addr | (uint32_t)XMC_I2C_CH_TDF_MASTER_START;
  if (command == XMC_I2C_CH_CMD_READ)
 8021ee4:	2a01      	cmp	r2, #1
  {
    temp |= 0x1U;
 8021ee6:	f441 6180 	orr.w	r1, r1, #1024	; 0x400
 8021eea:	bf08      	it	eq
 8021eec:	f041 0101 	orreq.w	r1, r1, #1
  }

  /* Check FIFO size */
  if ((channel->TBCTR & USIC_CH_TBCTR_SIZE_Msk) == 0U)
 8021ef0:	f013 6fe0 	tst.w	r3, #117440512	; 0x7000000
 8021ef4:	d002      	beq.n	8021efc <XMC_I2C_CH_MasterStart+0x1c>

    channel->TBUF[0] = temp;
  }
  else
  {
    channel->IN[0U] = temp;
 8021ef6:	f8c0 1180 	str.w	r1, [r0, #384]	; 0x180
 8021efa:	4770      	bx	lr
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_SetDataOutputMode() \n\n\n
 */
__STATIC_INLINE XMC_USIC_CH_TBUF_STATUS_t XMC_USIC_CH_GetTransmitBufferStatus(XMC_USIC_CH_t *const channel)
{
  return (XMC_USIC_CH_TBUF_STATUS_t)(channel->TCSR & USIC_CH_TCSR_TDV_Msk);
 8021efc:	6b83      	ldr	r3, [r0, #56]	; 0x38
  }

  /* Check FIFO size */
  if ((channel->TBCTR & USIC_CH_TBCTR_SIZE_Msk) == 0U)
  {
    while (XMC_USIC_CH_GetTransmitBufferStatus(channel) == XMC_USIC_CH_TBUF_STATUS_BUSY)
 8021efe:	061b      	lsls	r3, r3, #24
 8021f00:	d4fc      	bmi.n	8021efc <XMC_I2C_CH_MasterStart+0x1c>
 * \par<b>Related APIs:</b><br>
 * XMC_I2C_CH_GetStatusFlag()\n\n
 */
__STATIC_INLINE void XMC_I2C_CH_ClearStatusFlag(XMC_USIC_CH_t *const channel, uint32_t flag)
{
  channel->PSCR |= flag;
 8021f02:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 8021f04:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8021f08:	64c3      	str	r3, [r0, #76]	; 0x4c
    }

    /* clear PSR_TBIF */
    XMC_I2C_CH_ClearStatusFlag(channel, (uint32_t)XMC_I2C_CH_STATUS_FLAG_TRANSMIT_BUFFER_INDICATION);

    channel->TBUF[0] = temp;
 8021f0a:	f8c0 1080 	str.w	r1, [r0, #128]	; 0x80
 8021f0e:	4770      	bx	lr

08021f10 <XMC_I2C_CH_MasterRepeatedStart>:
  {
    tmp |= 0x1U;
  }

  /* Check FIFO size */
  if ((channel->TBCTR & USIC_CH_TBCTR_SIZE_Msk) == 0U)
 8021f10:	f8d0 3108 	ldr.w	r3, [r0, #264]	; 0x108
/* Sends master repeated start condition along with read/write command to IN/TBUF register based on FIFO/non-FIFO modes. */
void XMC_I2C_CH_MasterRepeatedStart(XMC_USIC_CH_t *const channel, const uint16_t addr, const XMC_I2C_CH_CMD_t command)
{
  uint32_t tmp;
  tmp = addr | (uint32_t)XMC_I2C_CH_TDF_MASTER_RESTART;
  if (command == XMC_I2C_CH_CMD_READ)
 8021f14:	2a01      	cmp	r2, #1
  {
    tmp |= 0x1U;
 8021f16:	f441 61a0 	orr.w	r1, r1, #1280	; 0x500
 8021f1a:	bf08      	it	eq
 8021f1c:	f041 0101 	orreq.w	r1, r1, #1
  }

  /* Check FIFO size */
  if ((channel->TBCTR & USIC_CH_TBCTR_SIZE_Msk) == 0U)
 8021f20:	f013 6fe0 	tst.w	r3, #117440512	; 0x7000000
 8021f24:	d002      	beq.n	8021f2c <XMC_I2C_CH_MasterRepeatedStart+0x1c>

    channel->TBUF[0] = tmp;
  }
  else
  {
    channel->IN[0U] = tmp;
 8021f26:	f8c0 1180 	str.w	r1, [r0, #384]	; 0x180
 8021f2a:	4770      	bx	lr
 8021f2c:	6b83      	ldr	r3, [r0, #56]	; 0x38
  }

  /* Check FIFO size */
  if ((channel->TBCTR & USIC_CH_TBCTR_SIZE_Msk) == 0U)
  {  
    while (XMC_USIC_CH_GetTransmitBufferStatus(channel) == XMC_USIC_CH_TBUF_STATUS_BUSY)
 8021f2e:	061b      	lsls	r3, r3, #24
 8021f30:	d4fc      	bmi.n	8021f2c <XMC_I2C_CH_MasterRepeatedStart+0x1c>
 8021f32:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 8021f34:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8021f38:	64c3      	str	r3, [r0, #76]	; 0x4c
    }

    /* clear PSR_TBIF */
    XMC_I2C_CH_ClearStatusFlag(channel, (uint32_t)XMC_I2C_CH_STATUS_FLAG_TRANSMIT_BUFFER_INDICATION);

    channel->TBUF[0] = tmp;
 8021f3a:	f8c0 1080 	str.w	r1, [r0, #128]	; 0x80
 8021f3e:	4770      	bx	lr

08021f40 <XMC_I2C_CH_MasterStop>:

/* Sends master stop command to IN/TBUF register based on FIFO/non-FIFO modes. */
void XMC_I2C_CH_MasterStop(XMC_USIC_CH_t *const channel)
{
  /* Check FIFO size */
  if ((channel->TBCTR & USIC_CH_TBCTR_SIZE_Msk) == 0U)
 8021f40:	f8d0 3108 	ldr.w	r3, [r0, #264]	; 0x108
 8021f44:	f013 6fe0 	tst.w	r3, #117440512	; 0x7000000
 8021f48:	d004      	beq.n	8021f54 <XMC_I2C_CH_MasterStop+0x14>

    channel->TBUF[0] = (uint32_t)XMC_I2C_CH_TDF_MASTER_STOP;
  }
  else
  {
    channel->IN[0U] = (uint32_t)XMC_I2C_CH_TDF_MASTER_STOP;
 8021f4a:	f44f 63c0 	mov.w	r3, #1536	; 0x600
 8021f4e:	f8c0 3180 	str.w	r3, [r0, #384]	; 0x180
 8021f52:	4770      	bx	lr
 8021f54:	6b83      	ldr	r3, [r0, #56]	; 0x38
void XMC_I2C_CH_MasterStop(XMC_USIC_CH_t *const channel)
{
  /* Check FIFO size */
  if ((channel->TBCTR & USIC_CH_TBCTR_SIZE_Msk) == 0U)
  {
    while (XMC_USIC_CH_GetTransmitBufferStatus(channel) == XMC_USIC_CH_TBUF_STATUS_BUSY)
 8021f56:	061b      	lsls	r3, r3, #24
 8021f58:	d4fc      	bmi.n	8021f54 <XMC_I2C_CH_MasterStop+0x14>
 8021f5a:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
    }

    /* clear PSR_TBIF */
    XMC_I2C_CH_ClearStatusFlag(channel, (uint32_t)XMC_I2C_CH_STATUS_FLAG_TRANSMIT_BUFFER_INDICATION);

    channel->TBUF[0] = (uint32_t)XMC_I2C_CH_TDF_MASTER_STOP;
 8021f5c:	f44f 62c0 	mov.w	r2, #1536	; 0x600
 8021f60:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8021f64:	64c3      	str	r3, [r0, #76]	; 0x4c
 8021f66:	f8c0 2080 	str.w	r2, [r0, #128]	; 0x80
 8021f6a:	4770      	bx	lr

08021f6c <XMC_I2C_CH_MasterTransmit>:

/* Sends master send command along with data to IN/TBUF register based on FIFO/non-FIFO modes. */
void XMC_I2C_CH_MasterTransmit(XMC_USIC_CH_t *const channel, const uint8_t data)
{
  /* Check FIFO size */
  if ((channel->TBCTR & USIC_CH_TBCTR_SIZE_Msk) == 0U)
 8021f6c:	f8d0 3108 	ldr.w	r3, [r0, #264]	; 0x108
 8021f70:	f013 6fe0 	tst.w	r3, #117440512	; 0x7000000
 8021f74:	d002      	beq.n	8021f7c <XMC_I2C_CH_MasterTransmit+0x10>

    channel->TBUF[0] = (uint32_t)XMC_I2C_CH_TDF_MASTER_SEND | data;
  }
  else
  {
    channel->IN[0] = (uint32_t)XMC_I2C_CH_TDF_MASTER_SEND | data;
 8021f76:	f8c0 1180 	str.w	r1, [r0, #384]	; 0x180
 8021f7a:	4770      	bx	lr
 8021f7c:	6b83      	ldr	r3, [r0, #56]	; 0x38
void XMC_I2C_CH_MasterTransmit(XMC_USIC_CH_t *const channel, const uint8_t data)
{
  /* Check FIFO size */
  if ((channel->TBCTR & USIC_CH_TBCTR_SIZE_Msk) == 0U)
  {    
    while (XMC_USIC_CH_GetTransmitBufferStatus(channel) == XMC_USIC_CH_TBUF_STATUS_BUSY)
 8021f7e:	061b      	lsls	r3, r3, #24
 8021f80:	d4fc      	bmi.n	8021f7c <XMC_I2C_CH_MasterTransmit+0x10>
 8021f82:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 8021f84:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8021f88:	64c3      	str	r3, [r0, #76]	; 0x4c
    }

    /* clear PSR_TBIF */
    XMC_I2C_CH_ClearStatusFlag(channel, (uint32_t)XMC_I2C_CH_STATUS_FLAG_TRANSMIT_BUFFER_INDICATION);

    channel->TBUF[0] = (uint32_t)XMC_I2C_CH_TDF_MASTER_SEND | data;
 8021f8a:	f8c0 1080 	str.w	r1, [r0, #128]	; 0x80
 8021f8e:	4770      	bx	lr

08021f90 <XMC_I2C_CH_MasterReceiveAck>:

/* Sends master receive ack command to IN/TBUF register based on FIFO/non-FIFO modes. */
void XMC_I2C_CH_MasterReceiveAck(XMC_USIC_CH_t *const channel)
{
/* Check FIFO size */
  if ((channel->TBCTR & USIC_CH_TBCTR_SIZE_Msk) == 0U)
 8021f90:	f8d0 3108 	ldr.w	r3, [r0, #264]	; 0x108
 8021f94:	f013 6fe0 	tst.w	r3, #117440512	; 0x7000000
 8021f98:	d004      	beq.n	8021fa4 <XMC_I2C_CH_MasterReceiveAck+0x14>

    channel->TBUF[0] = (uint32_t)XMC_I2C_CH_TDF_MASTER_RECEIVE_ACK;
  }
  else
  {
    channel->IN[0] = (uint32_t)XMC_I2C_CH_TDF_MASTER_RECEIVE_ACK;
 8021f9a:	f44f 7300 	mov.w	r3, #512	; 0x200
 8021f9e:	f8c0 3180 	str.w	r3, [r0, #384]	; 0x180
 8021fa2:	4770      	bx	lr
 8021fa4:	6b83      	ldr	r3, [r0, #56]	; 0x38
void XMC_I2C_CH_MasterReceiveAck(XMC_USIC_CH_t *const channel)
{
/* Check FIFO size */
  if ((channel->TBCTR & USIC_CH_TBCTR_SIZE_Msk) == 0U)
  {    
    while(XMC_USIC_CH_GetTransmitBufferStatus(channel) == XMC_USIC_CH_TBUF_STATUS_BUSY)
 8021fa6:	061b      	lsls	r3, r3, #24
 8021fa8:	d4fc      	bmi.n	8021fa4 <XMC_I2C_CH_MasterReceiveAck+0x14>
 8021faa:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
    }

    /* clear PSR_TBIF */
    XMC_I2C_CH_ClearStatusFlag(channel, (uint32_t)XMC_I2C_CH_STATUS_FLAG_TRANSMIT_BUFFER_INDICATION);

    channel->TBUF[0] = (uint32_t)XMC_I2C_CH_TDF_MASTER_RECEIVE_ACK;
 8021fac:	f44f 7200 	mov.w	r2, #512	; 0x200
 8021fb0:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8021fb4:	64c3      	str	r3, [r0, #76]	; 0x4c
 8021fb6:	f8c0 2080 	str.w	r2, [r0, #128]	; 0x80
 8021fba:	4770      	bx	lr

08021fbc <XMC_I2C_CH_MasterReceiveNack>:

/* Sends master receive nack command to IN/TBUF register based on FIFO/non-FIFO modes. */
void XMC_I2C_CH_MasterReceiveNack(XMC_USIC_CH_t *const channel)
{
  /* Check FIFO size */
  if ((channel->TBCTR & USIC_CH_TBCTR_SIZE_Msk) == 0U)
 8021fbc:	f8d0 3108 	ldr.w	r3, [r0, #264]	; 0x108
 8021fc0:	f013 6fe0 	tst.w	r3, #117440512	; 0x7000000
 8021fc4:	d004      	beq.n	8021fd0 <XMC_I2C_CH_MasterReceiveNack+0x14>

    channel->TBUF[0] = (uint32_t)XMC_I2C_CH_TDF_MASTER_RECEIVE_NACK;
  }
  else 
  {
    channel->IN[0] = (uint32_t)XMC_I2C_CH_TDF_MASTER_RECEIVE_NACK;
 8021fc6:	f44f 7340 	mov.w	r3, #768	; 0x300
 8021fca:	f8c0 3180 	str.w	r3, [r0, #384]	; 0x180
 8021fce:	4770      	bx	lr
 8021fd0:	6b83      	ldr	r3, [r0, #56]	; 0x38
void XMC_I2C_CH_MasterReceiveNack(XMC_USIC_CH_t *const channel)
{
  /* Check FIFO size */
  if ((channel->TBCTR & USIC_CH_TBCTR_SIZE_Msk) == 0U)
  {    
    while(XMC_USIC_CH_GetTransmitBufferStatus(channel) == XMC_USIC_CH_TBUF_STATUS_BUSY)
 8021fd2:	061b      	lsls	r3, r3, #24
 8021fd4:	d4fc      	bmi.n	8021fd0 <XMC_I2C_CH_MasterReceiveNack+0x14>
 8021fd6:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
    }

    /* clear PSR_TBIF */
    XMC_I2C_CH_ClearStatusFlag(channel, (uint32_t)XMC_I2C_CH_STATUS_FLAG_TRANSMIT_BUFFER_INDICATION);

    channel->TBUF[0] = (uint32_t)XMC_I2C_CH_TDF_MASTER_RECEIVE_NACK;
 8021fd8:	f44f 7240 	mov.w	r2, #768	; 0x300
 8021fdc:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8021fe0:	64c3      	str	r3, [r0, #76]	; 0x4c
 8021fe2:	f8c0 2080 	str.w	r2, [r0, #128]	; 0x80
 8021fe6:	4770      	bx	lr

08021fe8 <XMC_I2C_CH_GetReceivedData>:
uint8_t XMC_I2C_CH_GetReceivedData(const XMC_USIC_CH_t *const channel)
{
  uint8_t retval;

  /* Check FIFO size */
  if ((channel->RBCTR & USIC_CH_RBCTR_SIZE_Msk) == 0U)
 8021fe8:	f8d0 310c 	ldr.w	r3, [r0, #268]	; 0x10c
 8021fec:	f013 6fe0 	tst.w	r3, #117440512	; 0x7000000
  {
    retval = (uint8_t)channel->RBUF;
 8021ff0:	bf0c      	ite	eq
 8021ff2:	6d40      	ldreq	r0, [r0, #84]	; 0x54
  }
  else
  {
    retval = (uint8_t)channel->OUTR;
 8021ff4:	f8d0 011c 	ldrne.w	r0, [r0, #284]	; 0x11c
 8021ff8:	b2c0      	uxtb	r0, r0
  }

  return retval;
}
 8021ffa:	4770      	bx	lr

08021ffc <XMC_USBD_GetCapabilities>:
  cap.event_remote_wakeup = 1U;
  cap.event_reset = 1U;
  cap.event_resume = 1U;
  cap.event_suspend = 1U;
  cap.reserved = 0U;
  return cap;
 8021ffc:	2000      	movs	r0, #0
 8021ffe:	f36f 0000 	bfc	r0, #0, #1
 8022002:	f36f 0041 	bfc	r0, #1, #1
 8022006:	f040 001c 	orr.w	r0, r0, #28
 802200a:	f36f 1045 	bfc	r0, #5, #1
 802200e:	f440 70e0 	orr.w	r0, r0, #448	; 0x1c0
}
 8022012:	f3c0 0008 	ubfx	r0, r0, #0, #9
 8022016:	4770      	bx	lr

08022018 <XMC_USBD_DeviceConnect>:
 **/
XMC_USBD_STATUS_t XMC_USBD_DeviceConnect() 
{
  /* Just disable softdisconnect */
  dctl_data_t dctl;
	dctl.d32 = xmc_device.device_register->dctl;
 8022018:	4b04      	ldr	r3, [pc, #16]	; (802202c <XMC_USBD_DeviceConnect+0x14>)
 802201a:	f8d3 21a4 	ldr.w	r2, [r3, #420]	; 0x1a4
 802201e:	6853      	ldr	r3, [r2, #4]
  dctl.b.sftdiscon = 0U;
 8022020:	f36f 0341 	bfc	r3, #1, #1
  xmc_device.device_register->dctl = dctl.d32;
 8022024:	6053      	str	r3, [r2, #4]
  return XMC_USBD_STATUS_OK;
}
 8022026:	2000      	movs	r0, #0
 8022028:	4770      	bx	lr
 802202a:	bf00      	nop
 802202c:	1fff0078 	.word	0x1fff0078

08022030 <XMC_USBD_DeviceDisconnect>:
 * Disconnects the USB device from host
 **/
XMC_USBD_STATUS_t XMC_USBD_DeviceDisconnect() 
{
  dctl_data_t dctl;
	dctl.d32 = xmc_device.device_register->dctl;
 8022030:	4b04      	ldr	r3, [pc, #16]	; (8022044 <XMC_USBD_DeviceDisconnect+0x14>)
 8022032:	f8d3 21a4 	ldr.w	r2, [r3, #420]	; 0x1a4
 8022036:	6853      	ldr	r3, [r2, #4]
  dctl.b.sftdiscon = 1U;
 8022038:	f043 0302 	orr.w	r3, r3, #2
  xmc_device.device_register->dctl = dctl.d32;
 802203c:	6053      	str	r3, [r2, #4]
  return XMC_USBD_STATUS_OK;
}
 802203e:	2000      	movs	r0, #0
 8022040:	4770      	bx	lr
 8022042:	bf00      	nop
 8022044:	1fff0078 	.word	0x1fff0078

08022048 <XMC_USBD_DeviceGetState>:
 **/
XMC_USBD_STATE_t XMC_USBD_DeviceGetState(const XMC_USBD_t *const obj) 
{
  XMC_USBD_STATE_t state={0U};
  state.speed = XMC_USBD_SPEED_FULL;
  state.connected = xmc_device.IsConnected;
 8022048:	4a44      	ldr	r2, [pc, #272]	; (802215c <XMC_USBD_DeviceGetState+0x114>)
 */
uint8_t XMC_USBD_lDeviceActive(const XMC_USBD_t *const obj) 
{
  uint8_t i;
  uint8_t result = 0U;
  for (i = 0U; i < (uint8_t)obj->usbd_max_num_eps; i++)
 802204a:	7b01      	ldrb	r1, [r0, #12]

/**
 * Gets the USB device state.
 **/
XMC_USBD_STATE_t XMC_USBD_DeviceGetState(const XMC_USBD_t *const obj) 
{
 802204c:	b470      	push	{r4, r5, r6}
  XMC_USBD_STATE_t state={0U};
  state.speed = XMC_USBD_SPEED_FULL;
  state.connected = xmc_device.IsConnected;
 802204e:	f892 41fe 	ldrb.w	r4, [r2, #510]	; 0x1fe
/**
 * Gets the USB device state.
 **/
XMC_USBD_STATE_t XMC_USBD_DeviceGetState(const XMC_USBD_t *const obj) 
{
  XMC_USBD_STATE_t state={0U};
 8022052:	2000      	movs	r0, #0
  state.speed = XMC_USBD_SPEED_FULL;
  state.connected = xmc_device.IsConnected;
 8022054:	f004 0401 	and.w	r4, r4, #1
 */
uint8_t XMC_USBD_lDeviceActive(const XMC_USBD_t *const obj) 
{
  uint8_t i;
  uint8_t result = 0U;
  for (i = 0U; i < (uint8_t)obj->usbd_max_num_eps; i++)
 8022058:	2900      	cmp	r1, #0
 802205a:	d07c      	beq.n	8022156 <XMC_USBD_DeviceGetState+0x10e>
  {
    if (xmc_device.ep[i].inInUse || xmc_device.ep[i].outInUse)
 802205c:	6853      	ldr	r3, [r2, #4]
 802205e:	071e      	lsls	r6, r3, #28
 8022060:	bf56      	itet	pl
 8022062:	6853      	ldrpl	r3, [r2, #4]
    {
      result = 1U;
 8022064:	2301      	movmi	r3, #1
{
  uint8_t i;
  uint8_t result = 0U;
  for (i = 0U; i < (uint8_t)obj->usbd_max_num_eps; i++)
  {
    if (xmc_device.ep[i].inInUse || xmc_device.ep[i].outInUse)
 8022066:	f3c3 1300 	ubfxpl	r3, r3, #4, #1
 */
uint8_t XMC_USBD_lDeviceActive(const XMC_USBD_t *const obj) 
{
  uint8_t i;
  uint8_t result = 0U;
  for (i = 0U; i < (uint8_t)obj->usbd_max_num_eps; i++)
 802206a:	2901      	cmp	r1, #1
 802206c:	d954      	bls.n	8022118 <XMC_USBD_DeviceGetState+0xd0>
  {
    if (xmc_device.ep[i].inInUse || xmc_device.ep[i].outInUse)
 802206e:	6b95      	ldr	r5, [r2, #56]	; 0x38
 8022070:	4e3a      	ldr	r6, [pc, #232]	; (802215c <XMC_USBD_DeviceGetState+0x114>)
 8022072:	072d      	lsls	r5, r5, #28
 8022074:	d461      	bmi.n	802213a <XMC_USBD_DeviceGetState+0xf2>
 8022076:	6bb5      	ldr	r5, [r6, #56]	; 0x38
    {
      result = 1U;
 8022078:	f015 0f10 	tst.w	r5, #16
 802207c:	bf18      	it	ne
 802207e:	2301      	movne	r3, #1
 */
uint8_t XMC_USBD_lDeviceActive(const XMC_USBD_t *const obj) 
{
  uint8_t i;
  uint8_t result = 0U;
  for (i = 0U; i < (uint8_t)obj->usbd_max_num_eps; i++)
 8022080:	2902      	cmp	r1, #2
 8022082:	d049      	beq.n	8022118 <XMC_USBD_DeviceGetState+0xd0>
  {
    if (xmc_device.ep[i].inInUse || xmc_device.ep[i].outInUse)
 8022084:	6ed5      	ldr	r5, [r2, #108]	; 0x6c
 8022086:	4e35      	ldr	r6, [pc, #212]	; (802215c <XMC_USBD_DeviceGetState+0x114>)
 8022088:	072d      	lsls	r5, r5, #28
 802208a:	d462      	bmi.n	8022152 <XMC_USBD_DeviceGetState+0x10a>
 802208c:	6ef5      	ldr	r5, [r6, #108]	; 0x6c
    {
      result = 1U;
 802208e:	f015 0f10 	tst.w	r5, #16
 8022092:	bf18      	it	ne
 8022094:	2301      	movne	r3, #1
 */
uint8_t XMC_USBD_lDeviceActive(const XMC_USBD_t *const obj) 
{
  uint8_t i;
  uint8_t result = 0U;
  for (i = 0U; i < (uint8_t)obj->usbd_max_num_eps; i++)
 8022096:	2903      	cmp	r1, #3
 8022098:	d03e      	beq.n	8022118 <XMC_USBD_DeviceGetState+0xd0>
  {
    if (xmc_device.ep[i].inInUse || xmc_device.ep[i].outInUse)
 802209a:	f8d2 50a0 	ldr.w	r5, [r2, #160]	; 0xa0
 802209e:	4e2f      	ldr	r6, [pc, #188]	; (802215c <XMC_USBD_DeviceGetState+0x114>)
 80220a0:	072d      	lsls	r5, r5, #28
 80220a2:	d454      	bmi.n	802214e <XMC_USBD_DeviceGetState+0x106>
 80220a4:	f8d6 50a0 	ldr.w	r5, [r6, #160]	; 0xa0
    {
      result = 1U;
 80220a8:	f015 0f10 	tst.w	r5, #16
 80220ac:	bf18      	it	ne
 80220ae:	2301      	movne	r3, #1
 */
uint8_t XMC_USBD_lDeviceActive(const XMC_USBD_t *const obj) 
{
  uint8_t i;
  uint8_t result = 0U;
  for (i = 0U; i < (uint8_t)obj->usbd_max_num_eps; i++)
 80220b0:	2904      	cmp	r1, #4
 80220b2:	d031      	beq.n	8022118 <XMC_USBD_DeviceGetState+0xd0>
  {
    if (xmc_device.ep[i].inInUse || xmc_device.ep[i].outInUse)
 80220b4:	f8d2 50d4 	ldr.w	r5, [r2, #212]	; 0xd4
 80220b8:	4e28      	ldr	r6, [pc, #160]	; (802215c <XMC_USBD_DeviceGetState+0x114>)
 80220ba:	072d      	lsls	r5, r5, #28
 80220bc:	d445      	bmi.n	802214a <XMC_USBD_DeviceGetState+0x102>
 80220be:	f8d6 50d4 	ldr.w	r5, [r6, #212]	; 0xd4
    {
      result = 1U;
 80220c2:	f015 0f10 	tst.w	r5, #16
 80220c6:	bf18      	it	ne
 80220c8:	2301      	movne	r3, #1
 */
uint8_t XMC_USBD_lDeviceActive(const XMC_USBD_t *const obj) 
{
  uint8_t i;
  uint8_t result = 0U;
  for (i = 0U; i < (uint8_t)obj->usbd_max_num_eps; i++)
 80220ca:	2905      	cmp	r1, #5
 80220cc:	d024      	beq.n	8022118 <XMC_USBD_DeviceGetState+0xd0>
  {
    if (xmc_device.ep[i].inInUse || xmc_device.ep[i].outInUse)
 80220ce:	f8d2 5108 	ldr.w	r5, [r2, #264]	; 0x108
 80220d2:	4e22      	ldr	r6, [pc, #136]	; (802215c <XMC_USBD_DeviceGetState+0x114>)
 80220d4:	072d      	lsls	r5, r5, #28
 80220d6:	d436      	bmi.n	8022146 <XMC_USBD_DeviceGetState+0xfe>
 80220d8:	f8d6 5108 	ldr.w	r5, [r6, #264]	; 0x108
    {
      result = 1U;
 80220dc:	f015 0f10 	tst.w	r5, #16
 80220e0:	bf18      	it	ne
 80220e2:	2301      	movne	r3, #1
 */
uint8_t XMC_USBD_lDeviceActive(const XMC_USBD_t *const obj) 
{
  uint8_t i;
  uint8_t result = 0U;
  for (i = 0U; i < (uint8_t)obj->usbd_max_num_eps; i++)
 80220e4:	2906      	cmp	r1, #6
 80220e6:	d017      	beq.n	8022118 <XMC_USBD_DeviceGetState+0xd0>
  {
    if (xmc_device.ep[i].inInUse || xmc_device.ep[i].outInUse)
 80220e8:	f8d2 513c 	ldr.w	r5, [r2, #316]	; 0x13c
 80220ec:	4e1b      	ldr	r6, [pc, #108]	; (802215c <XMC_USBD_DeviceGetState+0x114>)
 80220ee:	072d      	lsls	r5, r5, #28
 80220f0:	d427      	bmi.n	8022142 <XMC_USBD_DeviceGetState+0xfa>
 80220f2:	f8d6 513c 	ldr.w	r5, [r6, #316]	; 0x13c
    {
      result = 1U;
 80220f6:	f015 0f10 	tst.w	r5, #16
 80220fa:	bf18      	it	ne
 80220fc:	2301      	movne	r3, #1
 */
uint8_t XMC_USBD_lDeviceActive(const XMC_USBD_t *const obj) 
{
  uint8_t i;
  uint8_t result = 0U;
  for (i = 0U; i < (uint8_t)obj->usbd_max_num_eps; i++)
 80220fe:	2907      	cmp	r1, #7
 8022100:	d00a      	beq.n	8022118 <XMC_USBD_DeviceGetState+0xd0>
  {
    if (xmc_device.ep[i].inInUse || xmc_device.ep[i].outInUse)
 8022102:	f8d2 1170 	ldr.w	r1, [r2, #368]	; 0x170
 8022106:	4d15      	ldr	r5, [pc, #84]	; (802215c <XMC_USBD_DeviceGetState+0x114>)
 8022108:	0709      	lsls	r1, r1, #28
 802210a:	d418      	bmi.n	802213e <XMC_USBD_DeviceGetState+0xf6>
 802210c:	f8d5 1170 	ldr.w	r1, [r5, #368]	; 0x170
    {
      result = 1U;
 8022110:	f011 0f10 	tst.w	r1, #16
 8022114:	bf18      	it	ne
 8022116:	2301      	movne	r3, #1
 8022118:	f003 0301 	and.w	r3, r3, #1
{
  XMC_USBD_STATE_t state={0U};
  state.speed = XMC_USBD_SPEED_FULL;
  state.connected = xmc_device.IsConnected;
  state.active = XMC_USBD_lDeviceActive(obj);
  state.powered = xmc_device.IsPowered;
 802211c:	f892 21fe 	ldrb.w	r2, [r2, #510]	; 0x1fe
  return state;
 8022120:	f3c2 0280 	ubfx	r2, r2, #2, #1
 8022124:	f362 0000 	bfi	r0, r2, #0, #1
 8022128:	f364 0041 	bfi	r0, r4, #1, #1
 802212c:	f363 0082 	bfi	r0, r3, #2, #1
 8022130:	2301      	movs	r3, #1
 8022132:	f363 00c4 	bfi	r0, r3, #3, #2
}
 8022136:	bc70      	pop	{r4, r5, r6}
 8022138:	4770      	bx	lr
  uint8_t result = 0U;
  for (i = 0U; i < (uint8_t)obj->usbd_max_num_eps; i++)
  {
    if (xmc_device.ep[i].inInUse || xmc_device.ep[i].outInUse)
    {
      result = 1U;
 802213a:	2301      	movs	r3, #1
 802213c:	e7a0      	b.n	8022080 <XMC_USBD_DeviceGetState+0x38>
 802213e:	2301      	movs	r3, #1
 8022140:	e7ea      	b.n	8022118 <XMC_USBD_DeviceGetState+0xd0>
 8022142:	2301      	movs	r3, #1
 8022144:	e7db      	b.n	80220fe <XMC_USBD_DeviceGetState+0xb6>
 8022146:	2301      	movs	r3, #1
 8022148:	e7cc      	b.n	80220e4 <XMC_USBD_DeviceGetState+0x9c>
 802214a:	2301      	movs	r3, #1
 802214c:	e7bd      	b.n	80220ca <XMC_USBD_DeviceGetState+0x82>
 802214e:	2301      	movs	r3, #1
 8022150:	e7ae      	b.n	80220b0 <XMC_USBD_DeviceGetState+0x68>
 8022152:	2301      	movs	r3, #1
 8022154:	e79f      	b.n	8022096 <XMC_USBD_DeviceGetState+0x4e>
 */
uint8_t XMC_USBD_lDeviceActive(const XMC_USBD_t *const obj) 
{
  uint8_t i;
  uint8_t result = 0U;
  for (i = 0U; i < (uint8_t)obj->usbd_max_num_eps; i++)
 8022156:	4603      	mov	r3, r0
 8022158:	e7e0      	b.n	802211c <XMC_USBD_DeviceGetState+0xd4>
 802215a:	bf00      	nop
 802215c:	1fff0078 	.word	0x1fff0078

08022160 <XMC_USBD_DeviceSetAddress>:
 * Sets the USB device address.
 **/
XMC_USBD_STATUS_t XMC_USBD_DeviceSetAddress(const uint8_t address,const XMC_USBD_SET_ADDRESS_STAGE_t stage) 
{
  dcfg_data_t data;
  data.d32 = xmc_device.device_register->dcfg;
 8022160:	4b04      	ldr	r3, [pc, #16]	; (8022174 <XMC_USBD_DeviceSetAddress+0x14>)
 8022162:	f8d3 31a4 	ldr.w	r3, [r3, #420]	; 0x1a4
 8022166:	681a      	ldr	r2, [r3, #0]
  if (stage == XMC_USBD_SET_ADDRESS_STAGE_SETUP)
 8022168:	b911      	cbnz	r1, 8022170 <XMC_USBD_DeviceSetAddress+0x10>
  {
    data.b.devaddr = address;
 802216a:	f360 120a 	bfi	r2, r0, #4, #7
    xmc_device.device_register->dcfg = data.d32;
 802216e:	601a      	str	r2, [r3, #0]
  }
	return XMC_USBD_STATUS_OK;
}
 8022170:	2000      	movs	r0, #0
 8022172:	4770      	bx	lr
 8022174:	1fff0078 	.word	0x1fff0078

08022178 <XMC_USBD_EndpointStall>:
 * Set/clear stall on the selected endpoint.
 **/
XMC_USBD_STATUS_t XMC_USBD_EndpointStall(const uint8_t ep_addr, const bool stall) 
{
  depctl_data_t data;
  XMC_USBD_EP_t *ep = &xmc_device.ep[(ep_addr & (uint8_t)XMC_USBD_EP_NUM_MASK)];
 8022178:	f000 020f 	and.w	r2, r0, #15
  if (stall)
 802217c:	b1e9      	cbz	r1, 80221ba <XMC_USBD_EndpointStall+0x42>
  {
    if (ep_addr & (uint8_t)XMC_USBD_ENDPOINT_DIRECTION_MASK)
    {
      /*set stall bit */
      data.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl;
 802217e:	2334      	movs	r3, #52	; 0x34
{
  depctl_data_t data;
  XMC_USBD_EP_t *ep = &xmc_device.ep[(ep_addr & (uint8_t)XMC_USBD_EP_NUM_MASK)];
  if (stall)
  {
    if (ep_addr & (uint8_t)XMC_USBD_ENDPOINT_DIRECTION_MASK)
 8022180:	f010 0f80 	tst.w	r0, #128	; 0x80
    {
      /*set stall bit */
      data.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl;
 8022184:	fb03 f302 	mul.w	r3, r3, r2
 8022188:	481d      	ldr	r0, [pc, #116]	; (8022200 <XMC_USBD_EndpointStall+0x88>)
 802218a:	5cc3      	ldrb	r3, [r0, r3]
 802218c:	f003 030f 	and.w	r3, r3, #15
      xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = data.d32;
    }
    else
    {
      /*set stall bit */
      data.d32 = xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl;
 8022190:	bf0b      	itete	eq
 8022192:	eb00 0383 	addeq.w	r3, r0, r3, lsl #2
  if (stall)
  {
    if (ep_addr & (uint8_t)XMC_USBD_ENDPOINT_DIRECTION_MASK)
    {
      /*set stall bit */
      data.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl;
 8022196:	336a      	addne	r3, #106	; 0x6a
      xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = data.d32;
    }
    else
    {
      /*set stall bit */
      data.d32 = xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl;
 8022198:	f8d3 11c4 	ldreq.w	r1, [r3, #452]	; 0x1c4
  if (stall)
  {
    if (ep_addr & (uint8_t)XMC_USBD_ENDPOINT_DIRECTION_MASK)
    {
      /*set stall bit */
      data.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl;
 802219c:	f850 1023 	ldrne.w	r1, [r0, r3, lsl #2]
      xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = data.d32;
    }
    else
    {
      /*set stall bit */
      data.d32 = xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl;
 80221a0:	680b      	ldr	r3, [r1, #0]
      data.b.stall = 1U;
 80221a2:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
      xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl = data.d32;
 80221a6:	600b      	str	r3, [r1, #0]
    }
    ep->isStalled = 1U;
 80221a8:	2334      	movs	r3, #52	; 0x34
 80221aa:	fb03 0202 	mla	r2, r3, r2, r0
			xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl = data.d32;
		}
		ep->isStalled = 0U;
	}
	return XMC_USBD_STATUS_OK;
}
 80221ae:	2000      	movs	r0, #0
      /*set stall bit */
      data.d32 = xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl;
      data.b.stall = 1U;
      xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl = data.d32;
    }
    ep->isStalled = 1U;
 80221b0:	7913      	ldrb	r3, [r2, #4]
 80221b2:	f043 0320 	orr.w	r3, r3, #32
 80221b6:	7113      	strb	r3, [r2, #4]
			xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl = data.d32;
		}
		ep->isStalled = 0U;
	}
	return XMC_USBD_STATUS_OK;
}
 80221b8:	4770      	bx	lr

/**
 * Set/clear stall on the selected endpoint.
 **/
XMC_USBD_STATUS_t XMC_USBD_EndpointStall(const uint8_t ep_addr, const bool stall) 
{
 80221ba:	b410      	push	{r4}
  else
  {
    /* just clear stall bit */
		if (ep_addr & (uint8_t)XMC_USBD_ENDPOINT_DIRECTION_MASK)
		{
			data.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl;
 80221bc:	2334      	movs	r3, #52	; 0x34
    ep->isStalled = 1U;
  }
  else
  {
    /* just clear stall bit */
		if (ep_addr & (uint8_t)XMC_USBD_ENDPOINT_DIRECTION_MASK)
 80221be:	f010 0f80 	tst.w	r0, #128	; 0x80
		{
			data.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl;
 80221c2:	fb03 f302 	mul.w	r3, r3, r2
 80221c6:	480e      	ldr	r0, [pc, #56]	; (8022200 <XMC_USBD_EndpointStall+0x88>)
 80221c8:	5cc3      	ldrb	r3, [r0, r3]
 80221ca:	f003 030f 	and.w	r3, r3, #15
			data.b.setd0pid = 1U; /* reset pid to 0 */
			xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = data.d32;
		}
		else
		{
			data.d32 = xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl;
 80221ce:	bf0b      	itete	eq
 80221d0:	eb00 0383 	addeq.w	r3, r0, r3, lsl #2
  else
  {
    /* just clear stall bit */
		if (ep_addr & (uint8_t)XMC_USBD_ENDPOINT_DIRECTION_MASK)
		{
			data.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl;
 80221d4:	336a      	addne	r3, #106	; 0x6a
			data.b.setd0pid = 1U; /* reset pid to 0 */
			xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = data.d32;
		}
		else
		{
			data.d32 = xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl;
 80221d6:	f8d3 41c4 	ldreq.w	r4, [r3, #452]	; 0x1c4
  else
  {
    /* just clear stall bit */
		if (ep_addr & (uint8_t)XMC_USBD_ENDPOINT_DIRECTION_MASK)
		{
			data.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl;
 80221da:	f850 4023 	ldrne.w	r4, [r0, r3, lsl #2]
			data.b.setd0pid = 1U; /* reset pid to 0 */
			xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = data.d32;
		}
		else
		{
			data.d32 = xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl;
 80221de:	6823      	ldr	r3, [r4, #0]
			data.b.stall = 0U;
 80221e0:	f361 5355 	bfi	r3, r1, #21, #1
			data.b.setd0pid = 1U; /* reset pid to 0 */
 80221e4:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
			xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl = data.d32;
 80221e8:	6023      	str	r3, [r4, #0]
		}
		ep->isStalled = 0U;
 80221ea:	2334      	movs	r3, #52	; 0x34
 80221ec:	fb03 0202 	mla	r2, r3, r2, r0
	}
	return XMC_USBD_STATUS_OK;
}
 80221f0:	f85d 4b04 	ldr.w	r4, [sp], #4
			data.d32 = xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl;
			data.b.stall = 0U;
			data.b.setd0pid = 1U; /* reset pid to 0 */
			xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl = data.d32;
		}
		ep->isStalled = 0U;
 80221f4:	7913      	ldrb	r3, [r2, #4]
 80221f6:	f36f 1345 	bfc	r3, #5, #1
	}
	return XMC_USBD_STATUS_OK;
}
 80221fa:	2000      	movs	r0, #0
			data.d32 = xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl;
			data.b.stall = 0U;
			data.b.setd0pid = 1U; /* reset pid to 0 */
			xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl = data.d32;
		}
		ep->isStalled = 0U;
 80221fc:	7113      	strb	r3, [r2, #4]
	}
	return XMC_USBD_STATUS_OK;
}
 80221fe:	4770      	bx	lr
 8022200:	1fff0078 	.word	0x1fff0078

08022204 <XMC_USBD_EndpointAbort>:

/**
 * Aborts the data transfer on the selected endpoint
 **/
XMC_USBD_STATUS_t XMC_USBD_EndpointAbort(const uint8_t ep_addr) {
  XMC_USBD_EP_t *ep = &xmc_device.ep[ep_addr & (uint8_t)XMC_USBD_ENDPOINT_NUMBER_MASK];
 8022204:	f000 000f 	and.w	r0, r0, #15
  if (ep->address_u.address_st.direction)
 8022208:	2234      	movs	r2, #52	; 0x34
 802220a:	fb02 f200 	mul.w	r2, r2, r0
 802220e:	4b0d      	ldr	r3, [pc, #52]	; (8022244 <XMC_USBD_EndpointAbort+0x40>)
 8022210:	5c99      	ldrb	r1, [r3, r2]
 8022212:	441a      	add	r2, r3
 8022214:	f011 0f80 	tst.w	r1, #128	; 0x80
  {
    ep->inInUse = 0U;
 8022218:	6851      	ldr	r1, [r2, #4]
  }
  if (!ep->address_u.address_st.direction)
  {
    ep->outInUse = 0U;
 802221a:	bf0c      	ite	eq
 802221c:	f021 0110 	biceq.w	r1, r1, #16
 **/
XMC_USBD_STATUS_t XMC_USBD_EndpointAbort(const uint8_t ep_addr) {
  XMC_USBD_EP_t *ep = &xmc_device.ep[ep_addr & (uint8_t)XMC_USBD_ENDPOINT_NUMBER_MASK];
  if (ep->address_u.address_st.direction)
  {
    ep->inInUse = 0U;
 8022220:	f021 0108 	bicne.w	r1, r1, #8
 8022224:	6051      	str	r1, [r2, #4]
  }
  if (!ep->address_u.address_st.direction)
  {
    ep->outInUse = 0U;
  }
  ep->isStalled = 0U;
 8022226:	2234      	movs	r2, #52	; 0x34
 8022228:	fb02 3300 	mla	r3, r2, r0, r3
  ep->outBytesAvailable = 0U;
 802222c:	2000      	movs	r0, #0
  }
  if (!ep->address_u.address_st.direction)
  {
    ep->outInUse = 0U;
  }
  ep->isStalled = 0U;
 802222e:	791a      	ldrb	r2, [r3, #4]
  ep->outBytesAvailable = 0U;
  ep->outOffset = 0U;
  ep->xferLength = 0U;
  ep->xferCount = 0U;
 8022230:	62d8      	str	r0, [r3, #44]	; 0x2c
  }
  if (!ep->address_u.address_st.direction)
  {
    ep->outInUse = 0U;
  }
  ep->isStalled = 0U;
 8022232:	f36f 1245 	bfc	r2, #5, #1
 8022236:	711a      	strb	r2, [r3, #4]
  ep->outBytesAvailable = 0U;
 8022238:	6118      	str	r0, [r3, #16]
  ep->outOffset = 0U;
 802223a:	6198      	str	r0, [r3, #24]
  ep->xferLength = 0U;
 802223c:	6298      	str	r0, [r3, #40]	; 0x28
  ep->xferCount = 0U;
  ep->xferTotal = 0U;
 802223e:	6318      	str	r0, [r3, #48]	; 0x30

  return XMC_USBD_STATUS_OK;
}
 8022240:	4770      	bx	lr
 8022242:	bf00      	nop
 8022244:	1fff0078 	.word	0x1fff0078

08022248 <XMC_USBD_EndpointUnconfigure>:

/**
 * Unconfigure the selected endpoint.
 **/
XMC_USBD_STATUS_t XMC_USBD_EndpointUnconfigure(const uint8_t ep_addr) 
{
 8022248:	b5f0      	push	{r4, r5, r6, r7, lr}
  depctl_data_t data;
	daint_data_t daintmsk;
	XMC_USBD_STATUS_t result;
	uint32_t number_temp;
  data.d32 = 0U;  
  daintmsk.d32 = xmc_device.device_register->daintmsk;  
 802224a:	4b3d      	ldr	r3, [pc, #244]	; (8022340 <XMC_USBD_EndpointUnconfigure+0xf8>)
/**
 * Unconfigure the selected endpoint.
 **/
XMC_USBD_STATUS_t XMC_USBD_EndpointUnconfigure(const uint8_t ep_addr) 
{
  XMC_USBD_EP_t *ep = &xmc_device.ep[ep_addr & (uint8_t)XMC_USBD_ENDPOINT_NUMBER_MASK];
 802224c:	f000 000f 	and.w	r0, r0, #15
	daint_data_t daintmsk;
	XMC_USBD_STATUS_t result;
	uint32_t number_temp;
  data.d32 = 0U;  
  daintmsk.d32 = xmc_device.device_register->daintmsk;  
  number_temp = (uint32_t)((uint32_t)1U << (uint8_t)ep->address_u.address_st.number);
 8022250:	2134      	movs	r1, #52	; 0x34
 8022252:	fb01 f100 	mul.w	r1, r1, r0
 8022256:	185a      	adds	r2, r3, r1
 8022258:	f813 e001 	ldrb.w	lr, [r3, r1]
  /* if not configured return an error */
  if (!ep->isConfigured)
 802225c:	7914      	ldrb	r4, [r2, #4]
  depctl_data_t data;
	daint_data_t daintmsk;
	XMC_USBD_STATUS_t result;
	uint32_t number_temp;
  data.d32 = 0U;  
  daintmsk.d32 = xmc_device.device_register->daintmsk;  
 802225e:	f8d3 71a4 	ldr.w	r7, [r3, #420]	; 0x1a4
  number_temp = (uint32_t)((uint32_t)1U << (uint8_t)ep->address_u.address_st.number);
  /* if not configured return an error */
  if (!ep->isConfigured)
 8022262:	f014 0f04 	tst.w	r4, #4
	daint_data_t daintmsk;
	XMC_USBD_STATUS_t result;
	uint32_t number_temp;
  data.d32 = 0U;  
  daintmsk.d32 = xmc_device.device_register->daintmsk;  
  number_temp = (uint32_t)((uint32_t)1U << (uint8_t)ep->address_u.address_st.number);
 8022266:	f00e 060f 	and.w	r6, lr, #15
  depctl_data_t data;
	daint_data_t daintmsk;
	XMC_USBD_STATUS_t result;
	uint32_t number_temp;
  data.d32 = 0U;  
  daintmsk.d32 = xmc_device.device_register->daintmsk;  
 802226a:	69fd      	ldr	r5, [r7, #28]
  XMC_USBD_EP_t *ep = &xmc_device.ep[ep_addr & (uint8_t)XMC_USBD_ENDPOINT_NUMBER_MASK];
  depctl_data_t data;
	daint_data_t daintmsk;
	XMC_USBD_STATUS_t result;
	uint32_t number_temp;
  data.d32 = 0U;  
 802226c:	f04f 0100 	mov.w	r1, #0
  daintmsk.d32 = xmc_device.device_register->daintmsk;  
  number_temp = (uint32_t)((uint32_t)1U << (uint8_t)ep->address_u.address_st.number);
  /* if not configured return an error */
  if (!ep->isConfigured)
 8022270:	d05a      	beq.n	8022328 <XMC_USBD_EndpointUnconfigure+0xe0>
    data.b.usbactep = 0U;
    data.b.epdis =  1U;
    data.b.snak =  1U;
    data.b.stall =  0U;
    ep->isConfigured =  0U;
    ep->isStalled =  0U;
 8022272:	f004 04fb 	and.w	r4, r4, #251	; 0xfb
 8022276:	f36f 1445 	bfc	r4, #5, #1
 802227a:	7114      	strb	r4, [r2, #4]
    ep->outInUse =  0U;
 802227c:	6854      	ldr	r4, [r2, #4]
 802227e:	f024 0410 	bic.w	r4, r4, #16
 8022282:	6054      	str	r4, [r2, #4]
    ep->inInUse =  0U;
 8022284:	6854      	ldr	r4, [r2, #4]
     result = XMC_USBD_STATUS_ERROR;
  }
  else
  {
    /* disable the endpoint, deactivate it and only send naks */
    data.b.usbactep = 0U;
 8022286:	f361 31cf 	bfi	r1, r1, #15, #1
    data.b.epdis =  1U;
    data.b.snak =  1U;
 802228a:	f041 4190 	orr.w	r1, r1, #1207959552	; 0x48000000
    data.b.stall =  0U;
    ep->isConfigured =  0U;
    ep->isStalled =  0U;
    ep->outInUse =  0U;
    ep->inInUse =  0U;
 802228e:	f024 0408 	bic.w	r4, r4, #8
	daint_data_t daintmsk;
	XMC_USBD_STATUS_t result;
	uint32_t number_temp;
  data.d32 = 0U;  
  daintmsk.d32 = xmc_device.device_register->daintmsk;  
  number_temp = (uint32_t)((uint32_t)1U << (uint8_t)ep->address_u.address_st.number);
 8022292:	f04f 0c01 	mov.w	ip, #1
    ep->isConfigured =  0U;
    ep->isStalled =  0U;
    ep->outInUse =  0U;
    ep->inInUse =  0U;
    /* chose register based on the direction. Control Endpoint need both */
    if ((ep->address_u.address_st.direction == 1U) || (ep->type == (uint8_t)XMC_USBD_ENDPOINT_TYPE_CONTROL))
 8022296:	f01e 0f80 	tst.w	lr, #128	; 0x80
  {
    /* disable the endpoint, deactivate it and only send naks */
    data.b.usbactep = 0U;
    data.b.epdis =  1U;
    data.b.snak =  1U;
    data.b.stall =  0U;
 802229a:	f36f 5155 	bfc	r1, #21, #1
    ep->isConfigured =  0U;
    ep->isStalled =  0U;
    ep->outInUse =  0U;
    ep->inInUse =  0U;
 802229e:	6054      	str	r4, [r2, #4]
	daint_data_t daintmsk;
	XMC_USBD_STATUS_t result;
	uint32_t number_temp;
  data.d32 = 0U;  
  daintmsk.d32 = xmc_device.device_register->daintmsk;  
  number_temp = (uint32_t)((uint32_t)1U << (uint8_t)ep->address_u.address_st.number);
 80222a0:	fa0c fc06 	lsl.w	ip, ip, r6
    ep->isConfigured =  0U;
    ep->isStalled =  0U;
    ep->outInUse =  0U;
    ep->inInUse =  0U;
    /* chose register based on the direction. Control Endpoint need both */
    if ((ep->address_u.address_st.direction == 1U) || (ep->type == (uint8_t)XMC_USBD_ENDPOINT_TYPE_CONTROL))
 80222a4:	d02f      	beq.n	8022306 <XMC_USBD_EndpointUnconfigure+0xbe>
    {
      /* disable endpoint configuration */
      xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = data.d32;
 80222a6:	f106 0e6a 	add.w	lr, r6, #106	; 0x6a
      /* disable interrupts */
      daintmsk.ep.in = (uint16_t)((uint32_t)daintmsk.ep.in & (~(uint32_t)number_temp));
 80222aa:	ea6f 040c 	mvn.w	r4, ip
    ep->inInUse =  0U;
    /* chose register based on the direction. Control Endpoint need both */
    if ((ep->address_u.address_st.direction == 1U) || (ep->type == (uint8_t)XMC_USBD_ENDPOINT_TYPE_CONTROL))
    {
      /* disable endpoint configuration */
      xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = data.d32;
 80222ae:	f853 e02e 	ldr.w	lr, [r3, lr, lsl #2]
 80222b2:	f8ce 1000 	str.w	r1, [lr]
      /* disable interrupts */
      daintmsk.ep.in = (uint16_t)((uint32_t)daintmsk.ep.in & (~(uint32_t)number_temp));
    }
    if ((ep->address_u.address_st.direction == 0U) || (ep->type == (uint8_t)XMC_USBD_ENDPOINT_TYPE_CONTROL))
 80222b6:	7912      	ldrb	r2, [r2, #4]
    if ((ep->address_u.address_st.direction == 1U) || (ep->type == (uint8_t)XMC_USBD_ENDPOINT_TYPE_CONTROL))
    {
      /* disable endpoint configuration */
      xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = data.d32;
      /* disable interrupts */
      daintmsk.ep.in = (uint16_t)((uint32_t)daintmsk.ep.in & (~(uint32_t)number_temp));
 80222b8:	fa1f fe84 	uxth.w	lr, r4
 80222bc:	ea0e 0c05 	and.w	ip, lr, r5
    }
    if ((ep->address_u.address_st.direction == 0U) || (ep->type == (uint8_t)XMC_USBD_ENDPOINT_TYPE_CONTROL))
 80222c0:	0792      	lsls	r2, r2, #30
    if ((ep->address_u.address_st.direction == 1U) || (ep->type == (uint8_t)XMC_USBD_ENDPOINT_TYPE_CONTROL))
    {
      /* disable endpoint configuration */
      xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = data.d32;
      /* disable interrupts */
      daintmsk.ep.in = (uint16_t)((uint32_t)daintmsk.ep.in & (~(uint32_t)number_temp));
 80222c2:	f36c 050f 	bfi	r5, ip, #0, #16
    }
    if ((ep->address_u.address_st.direction == 0U) || (ep->type == (uint8_t)XMC_USBD_ENDPOINT_TYPE_CONTROL))
 80222c6:	d10d      	bne.n	80222e4 <XMC_USBD_EndpointUnconfigure+0x9c>
    {
      xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl = data.d32;
      daintmsk.ep.out = (uint16_t)((uint32_t)daintmsk.ep.out & (~(uint32_t)number_temp));
      if(usbd_init->usbd_transfer_mode == XMC_USBD_USE_FIFO)
 80222c8:	4a1e      	ldr	r2, [pc, #120]	; (8022344 <XMC_USBD_EndpointUnconfigure+0xfc>)
 80222ca:	6812      	ldr	r2, [r2, #0]
      /* disable interrupts */
      daintmsk.ep.in = (uint16_t)((uint32_t)daintmsk.ep.in & (~(uint32_t)number_temp));
    }
    if ((ep->address_u.address_st.direction == 0U) || (ep->type == (uint8_t)XMC_USBD_ENDPOINT_TYPE_CONTROL))
    {
      xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl = data.d32;
 80222cc:	eb03 0686 	add.w	r6, r3, r6, lsl #2
      daintmsk.ep.out = (uint16_t)((uint32_t)daintmsk.ep.out & (~(uint32_t)number_temp));
      if(usbd_init->usbd_transfer_mode == XMC_USBD_USE_FIFO)
 80222d0:	7b52      	ldrb	r2, [r2, #13]
      /* disable interrupts */
      daintmsk.ep.in = (uint16_t)((uint32_t)daintmsk.ep.in & (~(uint32_t)number_temp));
    }
    if ((ep->address_u.address_st.direction == 0U) || (ep->type == (uint8_t)XMC_USBD_ENDPOINT_TYPE_CONTROL))
    {
      xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl = data.d32;
 80222d2:	f8d6 61c4 	ldr.w	r6, [r6, #452]	; 0x1c4
      daintmsk.ep.out = (uint16_t)((uint32_t)daintmsk.ep.out & (~(uint32_t)number_temp));
 80222d6:	ea0e 4e15 	and.w	lr, lr, r5, lsr #16
      if(usbd_init->usbd_transfer_mode == XMC_USBD_USE_FIFO)
 80222da:	2a01      	cmp	r2, #1
      /* disable interrupts */
      daintmsk.ep.in = (uint16_t)((uint32_t)daintmsk.ep.in & (~(uint32_t)number_temp));
    }
    if ((ep->address_u.address_st.direction == 0U) || (ep->type == (uint8_t)XMC_USBD_ENDPOINT_TYPE_CONTROL))
    {
      xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl = data.d32;
 80222dc:	6031      	str	r1, [r6, #0]
      daintmsk.ep.out = (uint16_t)((uint32_t)daintmsk.ep.out & (~(uint32_t)number_temp));
 80222de:	f36e 451f 	bfi	r5, lr, #16, #16
      if(usbd_init->usbd_transfer_mode == XMC_USBD_USE_FIFO)
 80222e2:	d028      	beq.n	8022336 <XMC_USBD_EndpointUnconfigure+0xee>
      {
        xmc_device.device_register->dtknqr4_fifoemptymsk &= ~number_temp;
      }
    }
    xmc_device.device_register->daintmsk = daintmsk.d32;
    XMC_USBD_lUnassignFifo(ep->txFifoNum); /* free fifo */
 80222e4:	2234      	movs	r2, #52	; 0x34
 80222e6:	fb02 3000 	mla	r0, r2, r0, r3
      if(usbd_init->usbd_transfer_mode == XMC_USBD_USE_FIFO)
      {
        xmc_device.device_register->dtknqr4_fifoemptymsk &= ~number_temp;
      }
    }
    xmc_device.device_register->daintmsk = daintmsk.d32;
 80222ea:	61fd      	str	r5, [r7, #28]
    XMC_USBD_lUnassignFifo(ep->txFifoNum); /* free fifo */
 80222ec:	8880      	ldrh	r0, [r0, #4]
 * Mark an used tx fifo as free.
 * @param[in] fifo_nr Fifo number to free
 */
static void XMC_USBD_lUnassignFifo(const uint8_t fifo_nr) 
{
  xmc_device.txfifomsk = (uint16_t)((uint32_t)xmc_device.txfifomsk & (uint32_t)(~((uint32_t)((uint32_t)1U << fifo_nr))));
 80222ee:	f8b3 11fc 	ldrh.w	r1, [r3, #508]	; 0x1fc
 80222f2:	f3c0 1083 	ubfx	r0, r0, #6, #4
 80222f6:	2201      	movs	r2, #1
 80222f8:	4082      	lsls	r2, r0
 80222fa:	ea21 0202 	bic.w	r2, r1, r2
 80222fe:	f8a3 21fc 	strh.w	r2, [r3, #508]	; 0x1fc
        xmc_device.device_register->dtknqr4_fifoemptymsk &= ~number_temp;
      }
    }
    xmc_device.device_register->daintmsk = daintmsk.d32;
    XMC_USBD_lUnassignFifo(ep->txFifoNum); /* free fifo */
    result = XMC_USBD_STATUS_OK;
 8022302:	2000      	movs	r0, #0
 8022304:	bdf0      	pop	{r4, r5, r6, r7, pc}
    ep->isConfigured =  0U;
    ep->isStalled =  0U;
    ep->outInUse =  0U;
    ep->inInUse =  0U;
    /* chose register based on the direction. Control Endpoint need both */
    if ((ep->address_u.address_st.direction == 1U) || (ep->type == (uint8_t)XMC_USBD_ENDPOINT_TYPE_CONTROL))
 8022306:	7912      	ldrb	r2, [r2, #4]
 8022308:	0794      	lsls	r4, r2, #30
 802230a:	d10f      	bne.n	802232c <XMC_USBD_EndpointUnconfigure+0xe4>
    {
      /* disable endpoint configuration */
      xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = data.d32;
 802230c:	f106 026a 	add.w	r2, r6, #106	; 0x6a
      /* disable interrupts */
      daintmsk.ep.in = (uint16_t)((uint32_t)daintmsk.ep.in & (~(uint32_t)number_temp));
 8022310:	ea6f 040c 	mvn.w	r4, ip
 8022314:	fa1f fe84 	uxth.w	lr, r4
    ep->inInUse =  0U;
    /* chose register based on the direction. Control Endpoint need both */
    if ((ep->address_u.address_st.direction == 1U) || (ep->type == (uint8_t)XMC_USBD_ENDPOINT_TYPE_CONTROL))
    {
      /* disable endpoint configuration */
      xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = data.d32;
 8022318:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
      /* disable interrupts */
      daintmsk.ep.in = (uint16_t)((uint32_t)daintmsk.ep.in & (~(uint32_t)number_temp));
 802231c:	ea0e 0c05 	and.w	ip, lr, r5
 8022320:	f36c 050f 	bfi	r5, ip, #0, #16
    ep->inInUse =  0U;
    /* chose register based on the direction. Control Endpoint need both */
    if ((ep->address_u.address_st.direction == 1U) || (ep->type == (uint8_t)XMC_USBD_ENDPOINT_TYPE_CONTROL))
    {
      /* disable endpoint configuration */
      xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = data.d32;
 8022324:	6011      	str	r1, [r2, #0]
 8022326:	e7cf      	b.n	80222c8 <XMC_USBD_EndpointUnconfigure+0x80>
  daintmsk.d32 = xmc_device.device_register->daintmsk;  
  number_temp = (uint32_t)((uint32_t)1U << (uint8_t)ep->address_u.address_st.number);
  /* if not configured return an error */
  if (!ep->isConfigured)
  {
     result = XMC_USBD_STATUS_ERROR;
 8022328:	2001      	movs	r0, #1
 802232a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 802232c:	ea6f 040c 	mvn.w	r4, ip
 8022330:	fa1f fe84 	uxth.w	lr, r4
 8022334:	e7c8      	b.n	80222c8 <XMC_USBD_EndpointUnconfigure+0x80>
    {
      xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl = data.d32;
      daintmsk.ep.out = (uint16_t)((uint32_t)daintmsk.ep.out & (~(uint32_t)number_temp));
      if(usbd_init->usbd_transfer_mode == XMC_USBD_USE_FIFO)
      {
        xmc_device.device_register->dtknqr4_fifoemptymsk &= ~number_temp;
 8022336:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8022338:	4014      	ands	r4, r2
 802233a:	637c      	str	r4, [r7, #52]	; 0x34
 802233c:	e7d2      	b.n	80222e4 <XMC_USBD_EndpointUnconfigure+0x9c>
 802233e:	bf00      	nop
 8022340:	1fff0078 	.word	0x1fff0078
 8022344:	1fff0074 	.word	0x1fff0074

08022348 <XMC_USBD_GetFrameNumber>:
 **/
uint16_t XMC_USBD_GetFrameNumber(void) 
{
  uint16_t result;
  dsts_data_t dsts;
  dsts.d32 = xmc_device.device_register->dsts;
 8022348:	4b03      	ldr	r3, [pc, #12]	; (8022358 <XMC_USBD_GetFrameNumber+0x10>)
 802234a:	f8d3 31a4 	ldr.w	r3, [r3, #420]	; 0x1a4
 802234e:	6898      	ldr	r0, [r3, #8]
  result = (uint16_t)dsts.b.soffn;
  return result;
}
 8022350:	f3c0 200d 	ubfx	r0, r0, #8, #14
 8022354:	4770      	bx	lr
 8022356:	bf00      	nop
 8022358:	1fff0078 	.word	0x1fff0078

0802235c <XMC_USBD_IsEnumDone>:
 * This should not be used for the actual USB enumeration completion status. For the actual USB enumeration status,
 * the application layer should check for the completion of USB standard request Set configuration.
 **/
uint32_t XMC_USBD_IsEnumDone(void)
{
  return (uint32_t)((uint8_t)xmc_device.IsConnected && (uint8_t)xmc_device.IsPowered);
 802235c:	4b05      	ldr	r3, [pc, #20]	; (8022374 <XMC_USBD_IsEnumDone+0x18>)
 802235e:	f893 01fe 	ldrb.w	r0, [r3, #510]	; 0x1fe
 8022362:	f000 0005 	and.w	r0, r0, #5
}
 8022366:	f1a0 0005 	sub.w	r0, r0, #5
 802236a:	fab0 f080 	clz	r0, r0
 802236e:	0940      	lsrs	r0, r0, #5
 8022370:	4770      	bx	lr
 8022372:	bf00      	nop
 8022374:	1fff0078 	.word	0x1fff0078

08022378 <XMC_USBD_Uninitialize>:
 **/
XMC_USBD_STATUS_t XMC_USBD_Uninitialize() 
{
  /* Disconnect the device */
  dctl_data_t dctl;
	dctl.d32 = xmc_device.device_register->dctl;
 8022378:	4807      	ldr	r0, [pc, #28]	; (8022398 <XMC_USBD_Uninitialize+0x20>)
 802237a:	f8d0 21a4 	ldr.w	r2, [r0, #420]	; 0x1a4

/**
 * Uninitializes the USB device
 **/
XMC_USBD_STATUS_t XMC_USBD_Uninitialize() 
{
 802237e:	b508      	push	{r3, lr}
  /* Disconnect the device */
  dctl_data_t dctl;
	dctl.d32 = xmc_device.device_register->dctl;
 8022380:	6853      	ldr	r3, [r2, #4]
  dctl.b.sftdiscon = 1U;
 8022382:	f043 0302 	orr.w	r3, r3, #2
  xmc_device.device_register->dctl = dctl.d32;
 8022386:	6053      	str	r3, [r2, #4]
  /* clean up */
  memset((void*)&xmc_device,0U,sizeof(xmc_device));
 8022388:	2100      	movs	r1, #0
 802238a:	f44f 7202 	mov.w	r2, #520	; 0x208
 802238e:	f00b f8e2 	bl	802d556 <memset>
  return XMC_USBD_STATUS_OK;
}
 8022392:	2000      	movs	r0, #0
 8022394:	bd08      	pop	{r3, pc}
 8022396:	bf00      	nop
 8022398:	1fff0078 	.word	0x1fff0078

0802239c <XMC_USBD_EndpointConfigure>:
 * Configures the given endpoint
 **/
XMC_USBD_STATUS_t XMC_USBD_EndpointConfigure(const uint8_t ep_addr,
		                                     const XMC_USBD_ENDPOINT_TYPE_t ep_type,
		                                     const uint16_t ep_max_packet_size) 
{
 802239c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  daint_data_t daintmsk;
  XMC_USBD_EP_t *ep;
  daintmsk.d32 = xmc_device.device_register->daintmsk;  
 80223a0:	4d9a      	ldr	r5, [pc, #616]	; (802260c <XMC_USBD_EndpointConfigure+0x270>)
  else
  {
    ep->maxTransferSize = (uint32_t)XMC_USBD_MAX_TRANSFER_SIZE_EP0;
  }
  /* transfer buffer */
  ep->inBuffer = XMC_USBD_EP_IN_BUFFER[ep->address_u.address_st.number];
 80223a2:	f8df 826c 	ldr.w	r8, [pc, #620]	; 8022610 <XMC_USBD_EndpointConfigure+0x274>
		                                     const XMC_USBD_ENDPOINT_TYPE_t ep_type,
		                                     const uint16_t ep_max_packet_size) 
{
  daint_data_t daintmsk;
  XMC_USBD_EP_t *ep;
  daintmsk.d32 = xmc_device.device_register->daintmsk;  
 80223a6:	f8d5 31a4 	ldr.w	r3, [r5, #420]	; 0x1a4
  }
  /* transfer buffer */
  ep->inBuffer = XMC_USBD_EP_IN_BUFFER[ep->address_u.address_st.number];
  ep->outBuffer = XMC_USBD_EP_OUT_BUFFER[ep->address_u.address_st.number];
  /* buffer size*/
  ep->inBufferSize = XMC_USBD_EP_IN_BUFFERSIZE[ep->address_u.address_st.number];
 80223aa:	f8df a268 	ldr.w	sl, [pc, #616]	; 8022614 <XMC_USBD_EndpointConfigure+0x278>
		                                     const XMC_USBD_ENDPOINT_TYPE_t ep_type,
		                                     const uint16_t ep_max_packet_size) 
{
  daint_data_t daintmsk;
  XMC_USBD_EP_t *ep;
  daintmsk.d32 = xmc_device.device_register->daintmsk;  
 80223ae:	f8d3 e01c 	ldr.w	lr, [r3, #28]
  /* transfer buffer */
  ep->inBuffer = XMC_USBD_EP_IN_BUFFER[ep->address_u.address_st.number];
  ep->outBuffer = XMC_USBD_EP_OUT_BUFFER[ep->address_u.address_st.number];
  /* buffer size*/
  ep->inBufferSize = XMC_USBD_EP_IN_BUFFERSIZE[ep->address_u.address_st.number];
  ep->outBufferSize = XMC_USBD_EP_OUT_BUFFERSIZE[ep->address_u.address_st.number];
 80223b2:	f8df 9264 	ldr.w	r9, [pc, #612]	; 8022618 <XMC_USBD_EndpointConfigure+0x27c>
		                                     const uint16_t ep_max_packet_size) 
{
  daint_data_t daintmsk;
  XMC_USBD_EP_t *ep;
  daintmsk.d32 = xmc_device.device_register->daintmsk;  
  ep =&xmc_device.ep[ep_addr & (uint32_t)XMC_USBD_ENDPOINT_NUMBER_MASK];
 80223b6:	f000 0c0f 	and.w	ip, r0, #15
  memset((void*)ep,0x0U,sizeof(XMC_USBD_EP_t)); /* clear endpoint structure */
 80223ba:	2734      	movs	r7, #52	; 0x34
 80223bc:	fb07 f70c 	mul.w	r7, r7, ip
 80223c0:	19ee      	adds	r6, r5, r7
 80223c2:	f106 0308 	add.w	r3, r6, #8
 80223c6:	2400      	movs	r4, #0
 80223c8:	51ec      	str	r4, [r5, r7]
 80223ca:	6074      	str	r4, [r6, #4]
 80223cc:	f843 4b04 	str.w	r4, [r3], #4
 80223d0:	f843 4b04 	str.w	r4, [r3], #4
 80223d4:	f843 4b04 	str.w	r4, [r3], #4
 80223d8:	f843 4b04 	str.w	r4, [r3], #4
 80223dc:	f843 4b04 	str.w	r4, [r3], #4
 80223e0:	f843 4b04 	str.w	r4, [r3], #4
 80223e4:	f843 4b04 	str.w	r4, [r3], #4
 80223e8:	f843 4b04 	str.w	r4, [r3], #4
 80223ec:	f843 4b04 	str.w	r4, [r3], #4
 80223f0:	f843 4b04 	str.w	r4, [r3], #4
 80223f4:	601c      	str	r4, [r3, #0]
  /* do ep configuration */
  ep->address_u.address = ep_addr;
  ep->isConfigured = 1U;
 80223f6:	7933      	ldrb	r3, [r6, #4]
  XMC_USBD_EP_t *ep;
  daintmsk.d32 = xmc_device.device_register->daintmsk;  
  ep =&xmc_device.ep[ep_addr & (uint32_t)XMC_USBD_ENDPOINT_NUMBER_MASK];
  memset((void*)ep,0x0U,sizeof(XMC_USBD_EP_t)); /* clear endpoint structure */
  /* do ep configuration */
  ep->address_u.address = ep_addr;
 80223f8:	55e8      	strb	r0, [r5, r7]
  ep->isConfigured = 1U;
 80223fa:	f043 0304 	orr.w	r3, r3, #4
 80223fe:	7133      	strb	r3, [r6, #4]
  ep->maxPacketSize = (uint8_t)ep_max_packet_size;
 8022400:	6874      	ldr	r4, [r6, #4]
 8022402:	4633      	mov	r3, r6
 8022404:	f362 24d1 	bfi	r4, r2, #11, #7
 8022408:	f843 4f04 	str.w	r4, [r3, #4]!
  {
    ep->maxTransferSize = (uint32_t)XMC_USBD_MAX_TRANSFER_SIZE;
  }
  else
  {
    ep->maxTransferSize = (uint32_t)XMC_USBD_MAX_TRANSFER_SIZE_EP0;
 802240c:	2800      	cmp	r0, #0
 802240e:	685c      	ldr	r4, [r3, #4]
 8022410:	f64f 70c0 	movw	r0, #65472	; 0xffc0
 8022414:	bf08      	it	eq
 8022416:	2040      	moveq	r0, #64	; 0x40
 8022418:	f360 0412 	bfi	r4, r0, #0, #19
 802241c:	605c      	str	r4, [r3, #4]
  }
  /* transfer buffer */
  ep->inBuffer = XMC_USBD_EP_IN_BUFFER[ep->address_u.address_st.number];
 802241e:	5deb      	ldrb	r3, [r5, r7]
 8022420:	f003 030f 	and.w	r3, r3, #15
 8022424:	0218      	lsls	r0, r3, #8
  ep->outBuffer = XMC_USBD_EP_OUT_BUFFER[ep->address_u.address_st.number];
 8022426:	f508 6be0 	add.w	fp, r8, #1792	; 0x700
  else
  {
    ep->maxTransferSize = (uint32_t)XMC_USBD_MAX_TRANSFER_SIZE_EP0;
  }
  /* transfer buffer */
  ep->inBuffer = XMC_USBD_EP_IN_BUFFER[ep->address_u.address_st.number];
 802242a:	eb08 0400 	add.w	r4, r8, r0
  ep->outBuffer = XMC_USBD_EP_OUT_BUFFER[ep->address_u.address_st.number];
 802242e:	eb00 080b 	add.w	r8, r0, fp
  /* buffer size*/
  ep->inBufferSize = XMC_USBD_EP_IN_BUFFERSIZE[ep->address_u.address_st.number];
 8022432:	f85a 0023 	ldr.w	r0, [sl, r3, lsl #2]
 8022436:	6230      	str	r0, [r6, #32]
  ep->outBufferSize = XMC_USBD_EP_OUT_BUFFERSIZE[ep->address_u.address_st.number];
 8022438:	f859 0023 	ldr.w	r0, [r9, r3, lsl #2]
 802243c:	6170      	str	r0, [r6, #20]
  else
  {
    ep->maxTransferSize = (uint32_t)XMC_USBD_MAX_TRANSFER_SIZE_EP0;
  }
  /* transfer buffer */
  ep->inBuffer = XMC_USBD_EP_IN_BUFFER[ep->address_u.address_st.number];
 802243e:	61f4      	str	r4, [r6, #28]
  ep->outBuffer = XMC_USBD_EP_OUT_BUFFER[ep->address_u.address_st.number];
 8022440:	f8c6 800c 	str.w	r8, [r6, #12]
  /* buffer size*/
  ep->inBufferSize = XMC_USBD_EP_IN_BUFFERSIZE[ep->address_u.address_st.number];
  ep->outBufferSize = XMC_USBD_EP_OUT_BUFFERSIZE[ep->address_u.address_st.number];
  /* is in */
  if ((ep->address_u.address_st.direction == 1U) || (ep_type == XMC_USBD_ENDPOINT_TYPE_CONTROL))
 8022444:	5de8      	ldrb	r0, [r5, r7]
 8022446:	0600      	lsls	r0, r0, #24
 8022448:	d41f      	bmi.n	802248a <XMC_USBD_EndpointConfigure+0xee>
 802244a:	2900      	cmp	r1, #0
 802244c:	d07f      	beq.n	802254e <XMC_USBD_EndpointConfigure+0x1b2>
  }
  if ((ep->address_u.address_st.direction == 0U) || (ep_type == XMC_USBD_ENDPOINT_TYPE_CONTROL))
  {
    /* is out */
		depctl_data_t data;
		data.d32 = xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl;
 802244e:	eb05 0483 	add.w	r4, r5, r3, lsl #2
 8022452:	2001      	movs	r0, #1
 8022454:	f8d4 61c4 	ldr.w	r6, [r4, #452]	; 0x1c4
 8022458:	6834      	ldr	r4, [r6, #0]
 802245a:	4098      	lsls	r0, r3
		/*enable endpoint */
		data.b.usbactep = 1U;
 802245c:	f444 4400 	orr.w	r4, r4, #32768	; 0x8000
		/* set ep type */
		data.b.eptype = (uint8_t)ep_type;
 8022460:	f361 4493 	bfi	r4, r1, #18, #2
 8022464:	b280      	uxth	r0, r0
					break;
			}
		}
		else
		{
			data.b.mps = ep_max_packet_size;
 8022466:	f362 040a 	bfi	r4, r2, #0, #11
		}
		/* set first data0 pid */
		data.b.setd0pid = 1U;
 802246a:	f044 5480 	orr.w	r4, r4, #268435456	; 0x10000000
		/* clear stall */
		data.b.stall =(uint8_t) 0U;
 802246e:	f36f 5455 	bfc	r4, #21, #1
		xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl = data.d32; /* configure endpoint */
		daintmsk.ep.out |=(uint16_t) ((uint16_t)1U << (uint8_t)ep->address_u.address_st.number); /* enable interrupts */
 8022472:	ea40 401e 	orr.w	r0, r0, lr, lsr #16
		}
		/* set first data0 pid */
		data.b.setd0pid = 1U;
		/* clear stall */
		data.b.stall =(uint8_t) 0U;
		xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl = data.d32; /* configure endpoint */
 8022476:	6034      	str	r4, [r6, #0]
		daintmsk.ep.out |=(uint16_t) ((uint16_t)1U << (uint8_t)ep->address_u.address_st.number); /* enable interrupts */
 8022478:	f360 4e1f 	bfi	lr, r0, #16, #16
  }
  xmc_device.device_register->daintmsk = daintmsk.d32;
 802247c:	f8d5 31a4 	ldr.w	r3, [r5, #420]	; 0x1a4
  return XMC_USBD_STATUS_OK;
}
 8022480:	2000      	movs	r0, #0
		/* clear stall */
		data.b.stall =(uint8_t) 0U;
		xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl = data.d32; /* configure endpoint */
		daintmsk.ep.out |=(uint16_t) ((uint16_t)1U << (uint8_t)ep->address_u.address_st.number); /* enable interrupts */
  }
  xmc_device.device_register->daintmsk = daintmsk.d32;
 8022482:	f8c3 e01c 	str.w	lr, [r3, #28]
  return XMC_USBD_STATUS_OK;
}
 8022486:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  ep->outBufferSize = XMC_USBD_EP_OUT_BUFFERSIZE[ep->address_u.address_st.number];
  /* is in */
  if ((ep->address_u.address_st.direction == 1U) || (ep_type == XMC_USBD_ENDPOINT_TYPE_CONTROL))
  {
    depctl_data_t data;
    data.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl;
 802248a:	f103 006a 	add.w	r0, r3, #106	; 0x6a
 802248e:	f855 6020 	ldr.w	r6, [r5, r0, lsl #2]
 8022492:	6834      	ldr	r4, [r6, #0]
		/*enable endpoint */
		data.b.usbactep = 1U;
 8022494:	f444 4400 	orr.w	r4, r4, #32768	; 0x8000
		/* set ep type */
		data.b.eptype = (uint8_t)ep_type;
 8022498:	f361 4493 	bfi	r4, r1, #18, #2
		/* set mps */
    if (ep_type == XMC_USBD_ENDPOINT_TYPE_CONTROL)
 802249c:	2900      	cmp	r1, #0
 802249e:	d05f      	beq.n	8022560 <XMC_USBD_EndpointConfigure+0x1c4>
				break;
			}
		}
		else
		{
			data.b.mps = ep_max_packet_size;
 80224a0:	f362 040a 	bfi	r4, r2, #0, #11
 80224a4:	f8b5 01fc 	ldrh.w	r0, [r5, #508]	; 0x1fc
		}
		/* set first data0 pid */
		data.b.setd0pid = 1U;
 80224a8:	f044 5480 	orr.w	r4, r4, #268435456	; 0x10000000
static uint8_t XMC_USBD_lAssignTXFifo(void) 
{
  uint16_t mask = 1U;
  uint8_t i = 0U;
  uint8_t result = 0U;
  while( (i < (uint8_t)XMC_USBD_NUM_TX_FIFOS)&&((xmc_device.txfifomsk & mask) != 0U))
 80224ac:	f010 0701 	ands.w	r7, r0, #1
			data.b.mps = ep_max_packet_size;
		}
		/* set first data0 pid */
		data.b.setd0pid = 1U;
		/* clear stall */
		data.b.stall = 0U;
 80224b0:	f36f 5455 	bfc	r4, #21, #1
static uint8_t XMC_USBD_lAssignTXFifo(void) 
{
  uint16_t mask = 1U;
  uint8_t i = 0U;
  uint8_t result = 0U;
  while( (i < (uint8_t)XMC_USBD_NUM_TX_FIFOS)&&((xmc_device.txfifomsk & mask) != 0U))
 80224b4:	f000 808e 	beq.w	80225d4 <XMC_USBD_EndpointConfigure+0x238>
 80224b8:	0787      	lsls	r7, r0, #30
 80224ba:	f140 808e 	bpl.w	80225da <XMC_USBD_EndpointConfigure+0x23e>
 80224be:	0747      	lsls	r7, r0, #29
 80224c0:	f140 808f 	bpl.w	80225e2 <XMC_USBD_EndpointConfigure+0x246>
 80224c4:	0707      	lsls	r7, r0, #28
 80224c6:	f140 8090 	bpl.w	80225ea <XMC_USBD_EndpointConfigure+0x24e>
 80224ca:	06c7      	lsls	r7, r0, #27
 80224cc:	f140 8091 	bpl.w	80225f2 <XMC_USBD_EndpointConfigure+0x256>
 80224d0:	0687      	lsls	r7, r0, #26
 80224d2:	f140 8092 	bpl.w	80225fa <XMC_USBD_EndpointConfigure+0x25e>
 80224d6:	0647      	lsls	r7, r0, #25
 80224d8:	f140 8093 	bpl.w	8022602 <XMC_USBD_EndpointConfigure+0x266>
  {
    mask = (uint16_t)(mask << 1U);
    i++;
  }
  if ((xmc_device.txfifomsk & mask) == 0U)
 80224dc:	0607      	lsls	r7, r0, #24
 80224de:	d449      	bmi.n	8022574 <XMC_USBD_EndpointConfigure+0x1d8>
 80224e0:	2707      	movs	r7, #7
  uint16_t mask = 1U;
  uint8_t i = 0U;
  uint8_t result = 0U;
  while( (i < (uint8_t)XMC_USBD_NUM_TX_FIFOS)&&((xmc_device.txfifomsk & mask) != 0U))
  {
    mask = (uint16_t)(mask << 1U);
 80224e2:	f04f 0880 	mov.w	r8, #128	; 0x80
    i++;
  }
  if ((xmc_device.txfifomsk & mask) == 0U)
  {
    xmc_device.txfifomsk |= mask;
 80224e6:	ea48 0000 	orr.w	r0, r8, r0
 80224ea:	f8a5 01fc 	strh.w	r0, [r5, #508]	; 0x1fc
		/* set first data0 pid */
		data.b.setd0pid = 1U;
		/* clear stall */
		data.b.stall = 0U;
		/* set tx fifo */
		ep->txFifoNum = XMC_USBD_lAssignTXFifo(); /* get tx fifo */
 80224ee:	2034      	movs	r0, #52	; 0x34
 80224f0:	fb00 fc0c 	mul.w	ip, r0, ip
 80224f4:	eb05 090c 	add.w	r9, r5, ip
		data.b.txfnum = ep->txFifoNum;
 80224f8:	f367 5499 	bfi	r4, r7, #22, #4
		/* set first data0 pid */
		data.b.setd0pid = 1U;
		/* clear stall */
		data.b.stall = 0U;
		/* set tx fifo */
		ep->txFifoNum = XMC_USBD_lAssignTXFifo(); /* get tx fifo */
 80224fc:	f8b9 a004 	ldrh.w	sl, [r9, #4]
 8022500:	f8df 8108 	ldr.w	r8, [pc, #264]	; 802260c <XMC_USBD_EndpointConfigure+0x270>
 8022504:	f367 1a89 	bfi	sl, r7, #6, #4
 8022508:	f8a9 a004 	strh.w	sl, [r9, #4]
		data.b.txfnum = ep->txFifoNum;
		xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = data.d32; /* configure endpoint */
		daintmsk.ep.in |= (uint16_t)((uint16_t)1U << (uint8_t)ep->address_u.address_st.number); /* enable interrupts for endpoint */
 802250c:	2001      	movs	r0, #1
		/* clear stall */
		data.b.stall = 0U;
		/* set tx fifo */
		ep->txFifoNum = XMC_USBD_lAssignTXFifo(); /* get tx fifo */
		data.b.txfnum = ep->txFifoNum;
		xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = data.d32; /* configure endpoint */
 802250e:	6034      	str	r4, [r6, #0]
		daintmsk.ep.in |= (uint16_t)((uint16_t)1U << (uint8_t)ep->address_u.address_st.number); /* enable interrupts for endpoint */
 8022510:	4098      	lsls	r0, r3
  }
  if ((ep->address_u.address_st.direction == 0U) || (ep_type == XMC_USBD_ENDPOINT_TYPE_CONTROL))
 8022512:	f815 400c 	ldrb.w	r4, [r5, ip]
		data.b.stall = 0U;
		/* set tx fifo */
		ep->txFifoNum = XMC_USBD_lAssignTXFifo(); /* get tx fifo */
		data.b.txfnum = ep->txFifoNum;
		xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = data.d32; /* configure endpoint */
		daintmsk.ep.in |= (uint16_t)((uint16_t)1U << (uint8_t)ep->address_u.address_st.number); /* enable interrupts for endpoint */
 8022516:	b280      	uxth	r0, r0
 8022518:	ea40 060e 	orr.w	r6, r0, lr
  }
  if ((ep->address_u.address_st.direction == 0U) || (ep_type == XMC_USBD_ENDPOINT_TYPE_CONTROL))
 802251c:	0624      	lsls	r4, r4, #24
		data.b.stall = 0U;
		/* set tx fifo */
		ep->txFifoNum = XMC_USBD_lAssignTXFifo(); /* get tx fifo */
		data.b.txfnum = ep->txFifoNum;
		xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = data.d32; /* configure endpoint */
		daintmsk.ep.in |= (uint16_t)((uint16_t)1U << (uint8_t)ep->address_u.address_st.number); /* enable interrupts for endpoint */
 802251e:	f366 0e0f 	bfi	lr, r6, #0, #16
  }
  if ((ep->address_u.address_st.direction == 0U) || (ep_type == XMC_USBD_ENDPOINT_TYPE_CONTROL))
 8022522:	d529      	bpl.n	8022578 <XMC_USBD_EndpointConfigure+0x1dc>
 8022524:	2900      	cmp	r1, #0
 8022526:	d1a9      	bne.n	802247c <XMC_USBD_EndpointConfigure+0xe0>
  {
    /* is out */
		depctl_data_t data;
		data.d32 = xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl;
 8022528:	eb08 0383 	add.w	r3, r8, r3, lsl #2
 802252c:	f8d3 61c4 	ldr.w	r6, [r3, #452]	; 0x1c4
 8022530:	6834      	ldr	r4, [r6, #0]
		/*enable endpoint */
		data.b.usbactep = 1U;
 8022532:	f444 4400 	orr.w	r4, r4, #32768	; 0x8000
		/* set ep type */
		data.b.eptype = (uint8_t)ep_type;
 8022536:	f361 4493 	bfi	r4, r1, #18, #2
    /* set mps */
    if (ep_type == XMC_USBD_ENDPOINT_TYPE_CONTROL)
		{
			switch(ep_max_packet_size)
 802253a:	2a10      	cmp	r2, #16
 802253c:	d03c      	beq.n	80225b8 <XMC_USBD_EndpointConfigure+0x21c>
 802253e:	d934      	bls.n	80225aa <XMC_USBD_EndpointConfigure+0x20e>
 8022540:	2a20      	cmp	r2, #32
 8022542:	d02e      	beq.n	80225a2 <XMC_USBD_EndpointConfigure+0x206>
 8022544:	2a40      	cmp	r2, #64	; 0x40
 8022546:	d190      	bne.n	802246a <XMC_USBD_EndpointConfigure+0xce>
			{
				case (64U):
					data.b.mps = 0x0U;
 8022548:	f36f 040a 	bfc	r4, #0, #11
					break;
 802254c:	e78d      	b.n	802246a <XMC_USBD_EndpointConfigure+0xce>
  ep->outBufferSize = XMC_USBD_EP_OUT_BUFFERSIZE[ep->address_u.address_st.number];
  /* is in */
  if ((ep->address_u.address_st.direction == 1U) || (ep_type == XMC_USBD_ENDPOINT_TYPE_CONTROL))
  {
    depctl_data_t data;
    data.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl;
 802254e:	f103 006a 	add.w	r0, r3, #106	; 0x6a
 8022552:	f855 6020 	ldr.w	r6, [r5, r0, lsl #2]
 8022556:	6834      	ldr	r4, [r6, #0]
		/*enable endpoint */
		data.b.usbactep = 1U;
 8022558:	f444 4400 	orr.w	r4, r4, #32768	; 0x8000
		/* set ep type */
		data.b.eptype = (uint8_t)ep_type;
 802255c:	f361 4493 	bfi	r4, r1, #18, #2
		/* set mps */
    if (ep_type == XMC_USBD_ENDPOINT_TYPE_CONTROL)
    {
			switch(ep_max_packet_size)
 8022560:	2a10      	cmp	r2, #16
 8022562:	d031      	beq.n	80225c8 <XMC_USBD_EndpointConfigure+0x22c>
 8022564:	d915      	bls.n	8022592 <XMC_USBD_EndpointConfigure+0x1f6>
 8022566:	2a20      	cmp	r2, #32
 8022568:	d02a      	beq.n	80225c0 <XMC_USBD_EndpointConfigure+0x224>
 802256a:	2a40      	cmp	r2, #64	; 0x40
 802256c:	d19a      	bne.n	80224a4 <XMC_USBD_EndpointConfigure+0x108>
			{
				case (64U):
				data.b.mps = 0x0U;
 802256e:	f36f 040a 	bfc	r4, #0, #11
				break;
 8022572:	e797      	b.n	80224a4 <XMC_USBD_EndpointConfigure+0x108>
  while( (i < (uint8_t)XMC_USBD_NUM_TX_FIFOS)&&((xmc_device.txfifomsk & mask) != 0U))
  {
    mask = (uint16_t)(mask << 1U);
    i++;
  }
  if ((xmc_device.txfifomsk & mask) == 0U)
 8022574:	2700      	movs	r7, #0
 8022576:	e7ba      	b.n	80224ee <XMC_USBD_EndpointConfigure+0x152>
  }
  if ((ep->address_u.address_st.direction == 0U) || (ep_type == XMC_USBD_ENDPOINT_TYPE_CONTROL))
  {
    /* is out */
		depctl_data_t data;
		data.d32 = xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl;
 8022578:	eb08 0383 	add.w	r3, r8, r3, lsl #2
 802257c:	f8d3 61c4 	ldr.w	r6, [r3, #452]	; 0x1c4
 8022580:	6834      	ldr	r4, [r6, #0]
		/*enable endpoint */
		data.b.usbactep = 1U;
 8022582:	f444 4400 	orr.w	r4, r4, #32768	; 0x8000
		/* set ep type */
		data.b.eptype = (uint8_t)ep_type;
 8022586:	f361 4493 	bfi	r4, r1, #18, #2
    /* set mps */
    if (ep_type == XMC_USBD_ENDPOINT_TYPE_CONTROL)
 802258a:	2900      	cmp	r1, #0
 802258c:	f47f af6b 	bne.w	8022466 <XMC_USBD_EndpointConfigure+0xca>
 8022590:	e7d3      	b.n	802253a <XMC_USBD_EndpointConfigure+0x19e>
		/* set ep type */
		data.b.eptype = (uint8_t)ep_type;
		/* set mps */
    if (ep_type == XMC_USBD_ENDPOINT_TYPE_CONTROL)
    {
			switch(ep_max_packet_size)
 8022592:	2a08      	cmp	r2, #8
 8022594:	d186      	bne.n	80224a4 <XMC_USBD_EndpointConfigure+0x108>
				break;
				case (16U):
				data.b.mps = 0x2U;
				break;
				case (8U):
				data.b.mps = 0x3U;
 8022596:	2703      	movs	r7, #3
 8022598:	f855 6020 	ldr.w	r6, [r5, r0, lsl #2]
 802259c:	f367 040a 	bfi	r4, r7, #0, #11
				break;
 80225a0:	e780      	b.n	80224a4 <XMC_USBD_EndpointConfigure+0x108>
			{
				case (64U):
					data.b.mps = 0x0U;
					break;
				case (32U):
					data.b.mps = 0x1U;
 80225a2:	2301      	movs	r3, #1
 80225a4:	f363 040a 	bfi	r4, r3, #0, #11
					break;
 80225a8:	e75f      	b.n	802246a <XMC_USBD_EndpointConfigure+0xce>
		/* set ep type */
		data.b.eptype = (uint8_t)ep_type;
    /* set mps */
    if (ep_type == XMC_USBD_ENDPOINT_TYPE_CONTROL)
		{
			switch(ep_max_packet_size)
 80225aa:	2a08      	cmp	r2, #8
 80225ac:	f47f af5d 	bne.w	802246a <XMC_USBD_EndpointConfigure+0xce>
					break;
				case (16U):
					data.b.mps = 0x2U;
					break;
				case (8U):
					data.b.mps = 0x3U;
 80225b0:	2303      	movs	r3, #3
 80225b2:	f363 040a 	bfi	r4, r3, #0, #11
					break;
 80225b6:	e758      	b.n	802246a <XMC_USBD_EndpointConfigure+0xce>
					break;
				case (32U):
					data.b.mps = 0x1U;
					break;
				case (16U):
					data.b.mps = 0x2U;
 80225b8:	2302      	movs	r3, #2
 80225ba:	f363 040a 	bfi	r4, r3, #0, #11
					break;
 80225be:	e754      	b.n	802246a <XMC_USBD_EndpointConfigure+0xce>
			{
				case (64U):
				data.b.mps = 0x0U;
				break;
				case (32U):
				data.b.mps = 0x1U;
 80225c0:	2001      	movs	r0, #1
 80225c2:	f360 040a 	bfi	r4, r0, #0, #11
				break;
 80225c6:	e76d      	b.n	80224a4 <XMC_USBD_EndpointConfigure+0x108>
				case (16U):
				data.b.mps = 0x2U;
 80225c8:	2702      	movs	r7, #2
 80225ca:	f855 6020 	ldr.w	r6, [r5, r0, lsl #2]
 80225ce:	f367 040a 	bfi	r4, r7, #0, #11
				break;
 80225d2:	e767      	b.n	80224a4 <XMC_USBD_EndpointConfigure+0x108>
 *
 * @return Fifo number for a free fifo
 */
static uint8_t XMC_USBD_lAssignTXFifo(void) 
{
  uint16_t mask = 1U;
 80225d4:	f04f 0801 	mov.w	r8, #1
 80225d8:	e785      	b.n	80224e6 <XMC_USBD_EndpointConfigure+0x14a>
  uint8_t i = 0U;
  uint8_t result = 0U;
  while( (i < (uint8_t)XMC_USBD_NUM_TX_FIFOS)&&((xmc_device.txfifomsk & mask) != 0U))
  {
    mask = (uint16_t)(mask << 1U);
    i++;
 80225da:	2701      	movs	r7, #1
  uint16_t mask = 1U;
  uint8_t i = 0U;
  uint8_t result = 0U;
  while( (i < (uint8_t)XMC_USBD_NUM_TX_FIFOS)&&((xmc_device.txfifomsk & mask) != 0U))
  {
    mask = (uint16_t)(mask << 1U);
 80225dc:	f04f 0802 	mov.w	r8, #2
 80225e0:	e781      	b.n	80224e6 <XMC_USBD_EndpointConfigure+0x14a>
    i++;
 80225e2:	2702      	movs	r7, #2
  uint16_t mask = 1U;
  uint8_t i = 0U;
  uint8_t result = 0U;
  while( (i < (uint8_t)XMC_USBD_NUM_TX_FIFOS)&&((xmc_device.txfifomsk & mask) != 0U))
  {
    mask = (uint16_t)(mask << 1U);
 80225e4:	f04f 0804 	mov.w	r8, #4
 80225e8:	e77d      	b.n	80224e6 <XMC_USBD_EndpointConfigure+0x14a>
    i++;
 80225ea:	2703      	movs	r7, #3
  uint16_t mask = 1U;
  uint8_t i = 0U;
  uint8_t result = 0U;
  while( (i < (uint8_t)XMC_USBD_NUM_TX_FIFOS)&&((xmc_device.txfifomsk & mask) != 0U))
  {
    mask = (uint16_t)(mask << 1U);
 80225ec:	f04f 0808 	mov.w	r8, #8
 80225f0:	e779      	b.n	80224e6 <XMC_USBD_EndpointConfigure+0x14a>
    i++;
 80225f2:	2704      	movs	r7, #4
  uint16_t mask = 1U;
  uint8_t i = 0U;
  uint8_t result = 0U;
  while( (i < (uint8_t)XMC_USBD_NUM_TX_FIFOS)&&((xmc_device.txfifomsk & mask) != 0U))
  {
    mask = (uint16_t)(mask << 1U);
 80225f4:	f04f 0810 	mov.w	r8, #16
 80225f8:	e775      	b.n	80224e6 <XMC_USBD_EndpointConfigure+0x14a>
    i++;
 80225fa:	2705      	movs	r7, #5
  uint16_t mask = 1U;
  uint8_t i = 0U;
  uint8_t result = 0U;
  while( (i < (uint8_t)XMC_USBD_NUM_TX_FIFOS)&&((xmc_device.txfifomsk & mask) != 0U))
  {
    mask = (uint16_t)(mask << 1U);
 80225fc:	f04f 0820 	mov.w	r8, #32
 8022600:	e771      	b.n	80224e6 <XMC_USBD_EndpointConfigure+0x14a>
    i++;
 8022602:	2706      	movs	r7, #6
  uint16_t mask = 1U;
  uint8_t i = 0U;
  uint8_t result = 0U;
  while( (i < (uint8_t)XMC_USBD_NUM_TX_FIFOS)&&((xmc_device.txfifomsk & mask) != 0U))
  {
    mask = (uint16_t)(mask << 1U);
 8022604:	f04f 0840 	mov.w	r8, #64	; 0x40
 8022608:	e76d      	b.n	80224e6 <XMC_USBD_EndpointConfigure+0x14a>
 802260a:	bf00      	nop
 802260c:	1fff0078 	.word	0x1fff0078
 8022610:	20000000 	.word	0x20000000
 8022614:	1ffe97a8 	.word	0x1ffe97a8
 8022618:	1ffe978c 	.word	0x1ffe978c

0802261c <XMC_USBD_EndpointRead>:

/**
 * Reads the number of bytes from the USB OUT endpoint
 **/
int32_t XMC_USBD_EndpointRead(const uint8_t ep_num,uint8_t * buffer,uint32_t length) 
{
 802261c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  XMC_USBD_EP_t *ep = &xmc_device.ep[ep_num];
  if (length > ep->outBytesAvailable)
 802261e:	4f0e      	ldr	r7, [pc, #56]	; (8022658 <XMC_USBD_EndpointRead+0x3c>)
 8022620:	2434      	movs	r4, #52	; 0x34
 8022622:	fb04 7400 	mla	r4, r4, r0, r7

/**
 * Reads the number of bytes from the USB OUT endpoint
 **/
int32_t XMC_USBD_EndpointRead(const uint8_t ep_num,uint8_t * buffer,uint32_t length) 
{
 8022626:	4606      	mov	r6, r0
  XMC_USBD_EP_t *ep = &xmc_device.ep[ep_num];
  if (length > ep->outBytesAvailable)
 8022628:	6925      	ldr	r5, [r4, #16]
  {
    length = ep->outBytesAvailable;
  }
  memcpy(buffer,&ep->outBuffer[ep->outOffset],length);
 802262a:	69a3      	ldr	r3, [r4, #24]
 802262c:	4295      	cmp	r5, r2
 802262e:	4608      	mov	r0, r1
 8022630:	68e1      	ldr	r1, [r4, #12]
 8022632:	bf28      	it	cs
 8022634:	4615      	movcs	r5, r2
 8022636:	4419      	add	r1, r3
 8022638:	462a      	mov	r2, r5
 802263a:	f00a ff81 	bl	802d540 <memcpy>
  ep->outBytesAvailable -= length;
 802263e:	6923      	ldr	r3, [r4, #16]
 8022640:	1b5b      	subs	r3, r3, r5
 8022642:	6123      	str	r3, [r4, #16]
  if (ep->outBytesAvailable)
 8022644:	b10b      	cbz	r3, 802264a <XMC_USBD_EndpointRead+0x2e>
  {
    ep->outOffset += length;
 8022646:	69a3      	ldr	r3, [r4, #24]
 8022648:	442b      	add	r3, r5
 802264a:	2234      	movs	r2, #52	; 0x34
 802264c:	fb02 7606 	mla	r6, r2, r6, r7
  else
  {
    ep->outOffset = 0U;
  }
  return (int32_t)length;
}
 8022650:	4628      	mov	r0, r5
 8022652:	61b3      	str	r3, [r6, #24]
 8022654:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8022656:	bf00      	nop
 8022658:	1fff0078 	.word	0x1fff0078

0802265c <XMC_USBD_Init>:

/**
 * Initializes the USB device
 **/
XMC_USBD_STATUS_t XMC_USBD_Init(XMC_USBD_t *obj)
{
 802265c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8022660:	4607      	mov	r7, r0
 8022662:	b083      	sub	sp, #12
 * Enables the USB0 module
 **/
void XMC_USBD_Enable(void) 
{
#if defined(CLOCK_GATING_SUPPORTED)
  XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_USB0);
 8022664:	4869      	ldr	r0, [pc, #420]	; (802280c <XMC_USBD_Init+0x1b0>)
	  XMC_USBD_EP_OUT_BUFFERSIZE[i] = XMC_USBD_EP0_BUFFER_SIZE;
	  XMC_USBD_EP_IN_BUFFERSIZE[i] 	= XMC_USBD_EP0_BUFFER_SIZE;
  }

  /* clear device status */
  memset((void*)&xmc_device,0x0U,sizeof(XMC_USBD_DEVICE_t));
 8022666:	4c6a      	ldr	r4, [pc, #424]	; (8022810 <XMC_USBD_Init+0x1b4>)
  usbd_init = obj;

  /* Filling out buffer size */
  for(i = 0U;i < (uint32_t)XMC_USBD_NUM_EPS;i++)
  {
	  XMC_USBD_EP_OUT_BUFFERSIZE[i] = XMC_USBD_EP0_BUFFER_SIZE;
 8022668:	4e6a      	ldr	r6, [pc, #424]	; (8022814 <XMC_USBD_Init+0x1b8>)
	  XMC_USBD_EP_IN_BUFFERSIZE[i] 	= XMC_USBD_EP0_BUFFER_SIZE;
 802266a:	4d6b      	ldr	r5, [pc, #428]	; (8022818 <XMC_USBD_Init+0x1bc>)
 * Enables the USB0 module
 **/
void XMC_USBD_Enable(void) 
{
#if defined(CLOCK_GATING_SUPPORTED)
  XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_USB0);
 802266c:	f7fe fd4e 	bl	802110c <XMC_SCU_CLOCK_UngatePeripheralClock>
#endif
  /* Reset and power up */
  XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_USB0);
 8022670:	4866      	ldr	r0, [pc, #408]	; (802280c <XMC_USBD_Init+0x1b0>)
 8022672:	f7fe fccf 	bl	8021014 <XMC_SCU_RESET_DeassertPeripheralReset>
  XMC_SCU_POWER_EnableUsb();
 8022676:	f7fe fd87 	bl	8021188 <XMC_SCU_POWER_EnableUsb>
  XMC_ASSERT("XMC_USBD_Init: obj.usbd_max_num_eps not of type XMC_USBD_MAX_NUM_EPS_t",
 		      XMC_USBD_CHECK_INPUT_MAX_NUM_EPS(obj->usbd_max_num_eps))
  
  XMC_USBD_Enable();
  
  usbd_init = obj;
 802267a:	4b68      	ldr	r3, [pc, #416]	; (802281c <XMC_USBD_Init+0x1c0>)
	  XMC_USBD_EP_OUT_BUFFERSIZE[i] = XMC_USBD_EP0_BUFFER_SIZE;
	  XMC_USBD_EP_IN_BUFFERSIZE[i] 	= XMC_USBD_EP0_BUFFER_SIZE;
  }

  /* clear device status */
  memset((void*)&xmc_device,0x0U,sizeof(XMC_USBD_DEVICE_t));
 802267c:	2100      	movs	r1, #0
  XMC_ASSERT("XMC_USBD_Init: obj.usbd_max_num_eps not of type XMC_USBD_MAX_NUM_EPS_t",
 		      XMC_USBD_CHECK_INPUT_MAX_NUM_EPS(obj->usbd_max_num_eps))
  
  XMC_USBD_Enable();
  
  usbd_init = obj;
 802267e:	601f      	str	r7, [r3, #0]
	  XMC_USBD_EP_OUT_BUFFERSIZE[i] = XMC_USBD_EP0_BUFFER_SIZE;
	  XMC_USBD_EP_IN_BUFFERSIZE[i] 	= XMC_USBD_EP0_BUFFER_SIZE;
  }

  /* clear device status */
  memset((void*)&xmc_device,0x0U,sizeof(XMC_USBD_DEVICE_t));
 8022680:	f44f 7202 	mov.w	r2, #520	; 0x208
  usbd_init = obj;

  /* Filling out buffer size */
  for(i = 0U;i < (uint32_t)XMC_USBD_NUM_EPS;i++)
  {
	  XMC_USBD_EP_OUT_BUFFERSIZE[i] = XMC_USBD_EP0_BUFFER_SIZE;
 8022684:	2340      	movs	r3, #64	; 0x40
	  XMC_USBD_EP_IN_BUFFERSIZE[i] 	= XMC_USBD_EP0_BUFFER_SIZE;
  }

  /* clear device status */
  memset((void*)&xmc_device,0x0U,sizeof(XMC_USBD_DEVICE_t));
 8022686:	4620      	mov	r0, r4
  usbd_init = obj;

  /* Filling out buffer size */
  for(i = 0U;i < (uint32_t)XMC_USBD_NUM_EPS;i++)
  {
	  XMC_USBD_EP_OUT_BUFFERSIZE[i] = XMC_USBD_EP0_BUFFER_SIZE;
 8022688:	6033      	str	r3, [r6, #0]
 802268a:	6073      	str	r3, [r6, #4]
 802268c:	60b3      	str	r3, [r6, #8]
 802268e:	60f3      	str	r3, [r6, #12]
 8022690:	6133      	str	r3, [r6, #16]
 8022692:	6173      	str	r3, [r6, #20]
 8022694:	61b3      	str	r3, [r6, #24]
	  XMC_USBD_EP_IN_BUFFERSIZE[i] 	= XMC_USBD_EP0_BUFFER_SIZE;
 8022696:	602b      	str	r3, [r5, #0]
 8022698:	606b      	str	r3, [r5, #4]
 802269a:	60ab      	str	r3, [r5, #8]
 802269c:	60eb      	str	r3, [r5, #12]
 802269e:	612b      	str	r3, [r5, #16]
 80226a0:	616b      	str	r3, [r5, #20]
 80226a2:	61ab      	str	r3, [r5, #24]
  }

  /* clear device status */
  memset((void*)&xmc_device,0x0U,sizeof(XMC_USBD_DEVICE_t));
 80226a4:	f00a ff57 	bl	802d556 <memset>

  /* assign callbacks */
  xmc_device.DeviceEvent_cb = obj->cb_xmc_device_event;
  xmc_device.EndpointEvent_cb = obj->cb_endpoint_event;
  XMC_USBD_BASE_ADDRESS = (uint8_t *)(obj->usbd);
 80226a8:	683b      	ldr	r3, [r7, #0]
  /* Done by driver core */
  /* configure ahb details */  
  gahbcfg.d32 = xmc_device.global_register->gahbcfg;
  gahbcfg.b.glblintrmsk = 1U; /* enable interrupts ( global mask ) */
  gahbcfg.b.nptxfemplvl_txfemplvl = 1U;
  if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
 80226aa:	7b7d      	ldrb	r5, [r7, #13]
    						(i * XMC_USBD_TX_FIFO_OFFSET));
  }
  /* obj data structure for endpoint 0 */
  /* Done by driver core */
  /* configure ahb details */  
  gahbcfg.d32 = xmc_device.global_register->gahbcfg;
 80226ac:	689a      	ldr	r2, [r3, #8]

  /* clear device status */
  memset((void*)&xmc_device,0x0U,sizeof(XMC_USBD_DEVICE_t));

  /* assign callbacks */
  xmc_device.DeviceEvent_cb = obj->cb_xmc_device_event;
 80226ae:	6878      	ldr	r0, [r7, #4]
  xmc_device.EndpointEvent_cb = obj->cb_endpoint_event;
 80226b0:	68be      	ldr	r6, [r7, #8]
  /* Done by driver core */
  /* configure ahb details */  
  gahbcfg.d32 = xmc_device.global_register->gahbcfg;
  gahbcfg.b.glblintrmsk = 1U; /* enable interrupts ( global mask ) */
  gahbcfg.b.nptxfemplvl_txfemplvl = 1U;
  if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
 80226b2:	fab5 f185 	clz	r1, r5
  xmc_device.DeviceEvent_cb = obj->cb_xmc_device_event;
  xmc_device.EndpointEvent_cb = obj->cb_endpoint_event;
  XMC_USBD_BASE_ADDRESS = (uint8_t *)(obj->usbd);
  /* assign register address */
  xmc_device.global_register = (dwc_otg_core_global_regs_t*)(obj->usbd);
  xmc_device.device_register = ((dwc_otg_device_global_regs_t*)(XMC_USBD_BASE_ADDRESS + DWC_DEV_GLOBAL_REG_OFFSET));
 80226b6:	f503 6a00 	add.w	sl, r3, #2048	; 0x800
  /* Done by driver core */
  /* configure ahb details */  
  gahbcfg.d32 = xmc_device.global_register->gahbcfg;
  gahbcfg.b.glblintrmsk = 1U; /* enable interrupts ( global mask ) */
  gahbcfg.b.nptxfemplvl_txfemplvl = 1U;
  if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
 80226ba:	0949      	lsrs	r1, r1, #5
  /* assign register address */
  xmc_device.global_register = (dwc_otg_core_global_regs_t*)(obj->usbd);
  xmc_device.device_register = ((dwc_otg_device_global_regs_t*)(XMC_USBD_BASE_ADDRESS + DWC_DEV_GLOBAL_REG_OFFSET));
  for (i = 0U;i < (uint32_t)XMC_USBD_NUM_EPS;i++)
  {
    xmc_device.endpoint_in_register[i] = (dwc_otg_dev_in_ep_regs_t*)(XMC_USBD_BASE_ADDRESS + DWC_DEV_IN_EP_REG_OFFSET +
 80226bc:	f503 6910 	add.w	r9, r3, #2304	; 0x900
  /* obj data structure for endpoint 0 */
  /* Done by driver core */
  /* configure ahb details */  
  gahbcfg.d32 = xmc_device.global_register->gahbcfg;
  gahbcfg.b.glblintrmsk = 1U; /* enable interrupts ( global mask ) */
  gahbcfg.b.nptxfemplvl_txfemplvl = 1U;
 80226c0:	f042 0281 	orr.w	r2, r2, #129	; 0x81

  /* clear device status */
  memset((void*)&xmc_device,0x0U,sizeof(XMC_USBD_DEVICE_t));

  /* assign callbacks */
  xmc_device.DeviceEvent_cb = obj->cb_xmc_device_event;
 80226c4:	f8c4 0200 	str.w	r0, [r4, #512]	; 0x200
  xmc_device.EndpointEvent_cb = obj->cb_endpoint_event;
 80226c8:	f8c4 6204 	str.w	r6, [r4, #516]	; 0x204
  XMC_USBD_BASE_ADDRESS = (uint8_t *)(obj->usbd);
  /* assign register address */
  xmc_device.global_register = (dwc_otg_core_global_regs_t*)(obj->usbd);
  xmc_device.device_register = ((dwc_otg_device_global_regs_t*)(XMC_USBD_BASE_ADDRESS + DWC_DEV_GLOBAL_REG_OFFSET));
 80226cc:	f8c4 a1a4 	str.w	sl, [r4, #420]	; 0x1a4
  for (i = 0U;i < (uint32_t)XMC_USBD_NUM_EPS;i++)
  {
    xmc_device.endpoint_in_register[i] = (dwc_otg_dev_in_ep_regs_t*)(XMC_USBD_BASE_ADDRESS + DWC_DEV_IN_EP_REG_OFFSET +
 80226d0:	f8c4 91a8 	str.w	r9, [r4, #424]	; 0x1a8
 80226d4:	f361 1245 	bfi	r2, r1, #5, #1
 80226d8:	f503 6812 	add.w	r8, r3, #2336	; 0x920
 80226dc:	f503 6c14 	add.w	ip, r3, #2368	; 0x940
 80226e0:	f503 6e16 	add.w	lr, r3, #2400	; 0x960
 80226e4:	f503 6718 	add.w	r7, r3, #2432	; 0x980
 80226e8:	f503 601a 	add.w	r0, r3, #2464	; 0x9a0
 80226ec:	f503 6b1c 	add.w	fp, r3, #2496	; 0x9c0
    ((uint32_t)DWC_EP_REG_OFFSET*i));
  }
  for (i = 0U;i < (uint32_t)XMC_USBD_NUM_EPS;i++)
  {
    xmc_device.endpoint_out_register[i] = (dwc_otg_dev_out_ep_regs_t*)(XMC_USBD_BASE_ADDRESS +
    									  DWC_DEV_OUT_EP_REG_OFFSET +
 80226f0:	f503 6130 	add.w	r1, r3, #2816	; 0xb00
 80226f4:	f503 6632 	add.w	r6, r3, #2848	; 0xb20
 80226f8:	f503 6a34 	add.w	sl, r3, #2880	; 0xb40
 80226fc:	f503 6936 	add.w	r9, r3, #2912	; 0xb60
  /* assign register address */
  xmc_device.global_register = (dwc_otg_core_global_regs_t*)(obj->usbd);
  xmc_device.device_register = ((dwc_otg_device_global_regs_t*)(XMC_USBD_BASE_ADDRESS + DWC_DEV_GLOBAL_REG_OFFSET));
  for (i = 0U;i < (uint32_t)XMC_USBD_NUM_EPS;i++)
  {
    xmc_device.endpoint_in_register[i] = (dwc_otg_dev_in_ep_regs_t*)(XMC_USBD_BASE_ADDRESS + DWC_DEV_IN_EP_REG_OFFSET +
 8022700:	f8c4 81ac 	str.w	r8, [r4, #428]	; 0x1ac
 8022704:	f8c4 c1b0 	str.w	ip, [r4, #432]	; 0x1b0
 8022708:	f8c4 e1b4 	str.w	lr, [r4, #436]	; 0x1b4
 802270c:	f8c4 71b8 	str.w	r7, [r4, #440]	; 0x1b8
 8022710:	f8c4 01bc 	str.w	r0, [r4, #444]	; 0x1bc
 8022714:	f8c4 b1c0 	str.w	fp, [r4, #448]	; 0x1c0
    ((uint32_t)DWC_EP_REG_OFFSET*i));
  }
  for (i = 0U;i < (uint32_t)XMC_USBD_NUM_EPS;i++)
  {
    xmc_device.endpoint_out_register[i] = (dwc_otg_dev_out_ep_regs_t*)(XMC_USBD_BASE_ADDRESS +
 8022718:	f8c4 11c4 	str.w	r1, [r4, #452]	; 0x1c4
 802271c:	f8c4 61c8 	str.w	r6, [r4, #456]	; 0x1c8
 8022720:	f8c4 a1cc 	str.w	sl, [r4, #460]	; 0x1cc
 8022724:	f8c4 91d0 	str.w	r9, [r4, #464]	; 0x1d0
    									  ((uint32_t)DWC_EP_REG_OFFSET*i));
  }
  for (i = 0U;i < (uint32_t)XMC_USBD_NUM_TX_FIFOS;i++)
  {
    xmc_device.fifo[i] = (uint32_t*)(XMC_USBD_BASE_ADDRESS +
    						XMC_USBD_TX_FIFO_REG_OFFSET +
 8022728:	f503 4180 	add.w	r1, r3, #16384	; 0x4000
    ((uint32_t)DWC_EP_REG_OFFSET*i));
  }
  for (i = 0U;i < (uint32_t)XMC_USBD_NUM_EPS;i++)
  {
    xmc_device.endpoint_out_register[i] = (dwc_otg_dev_out_ep_regs_t*)(XMC_USBD_BASE_ADDRESS +
    									  DWC_DEV_OUT_EP_REG_OFFSET +
 802272c:	f503 6838 	add.w	r8, r3, #2944	; 0xb80
 8022730:	f503 6c3a 	add.w	ip, r3, #2976	; 0xba0
 8022734:	f503 6e3c 	add.w	lr, r3, #3008	; 0xbc0
    									  ((uint32_t)DWC_EP_REG_OFFSET*i));
  }
  for (i = 0U;i < (uint32_t)XMC_USBD_NUM_TX_FIFOS;i++)
  {
    xmc_device.fifo[i] = (uint32_t*)(XMC_USBD_BASE_ADDRESS +
    						XMC_USBD_TX_FIFO_REG_OFFSET +
 8022738:	f503 5780 	add.w	r7, r3, #4096	; 0x1000
 802273c:	f503 5000 	add.w	r0, r3, #8192	; 0x2000
 8022740:	f503 5b40 	add.w	fp, r3, #12288	; 0x3000
 8022744:	f503 46a0 	add.w	r6, r3, #20480	; 0x5000
 8022748:	f503 4ac0 	add.w	sl, r3, #24576	; 0x6000
 802274c:	f503 49e0 	add.w	r9, r3, #28672	; 0x7000
    									  DWC_DEV_OUT_EP_REG_OFFSET +
    									  ((uint32_t)DWC_EP_REG_OFFSET*i));
  }
  for (i = 0U;i < (uint32_t)XMC_USBD_NUM_TX_FIFOS;i++)
  {
    xmc_device.fifo[i] = (uint32_t*)(XMC_USBD_BASE_ADDRESS +
 8022750:	f8c4 11ec 	str.w	r1, [r4, #492]	; 0x1ec
  /* assign callbacks */
  xmc_device.DeviceEvent_cb = obj->cb_xmc_device_event;
  xmc_device.EndpointEvent_cb = obj->cb_endpoint_event;
  XMC_USBD_BASE_ADDRESS = (uint8_t *)(obj->usbd);
  /* assign register address */
  xmc_device.global_register = (dwc_otg_core_global_regs_t*)(obj->usbd);
 8022754:	f8c4 31a0 	str.w	r3, [r4, #416]	; 0x1a0
    xmc_device.endpoint_in_register[i] = (dwc_otg_dev_in_ep_regs_t*)(XMC_USBD_BASE_ADDRESS + DWC_DEV_IN_EP_REG_OFFSET +
    ((uint32_t)DWC_EP_REG_OFFSET*i));
  }
  for (i = 0U;i < (uint32_t)XMC_USBD_NUM_EPS;i++)
  {
    xmc_device.endpoint_out_register[i] = (dwc_otg_dev_out_ep_regs_t*)(XMC_USBD_BASE_ADDRESS +
 8022758:	f8c4 81d4 	str.w	r8, [r4, #468]	; 0x1d4
 802275c:	f8c4 c1d8 	str.w	ip, [r4, #472]	; 0x1d8
 8022760:	f8c4 e1dc 	str.w	lr, [r4, #476]	; 0x1dc
    									  DWC_DEV_OUT_EP_REG_OFFSET +
    									  ((uint32_t)DWC_EP_REG_OFFSET*i));
  }
  for (i = 0U;i < (uint32_t)XMC_USBD_NUM_TX_FIFOS;i++)
  {
    xmc_device.fifo[i] = (uint32_t*)(XMC_USBD_BASE_ADDRESS +
 8022764:	f8c4 71e0 	str.w	r7, [r4, #480]	; 0x1e0
 8022768:	f8c4 01e4 	str.w	r0, [r4, #484]	; 0x1e4
 802276c:	f8c4 b1e8 	str.w	fp, [r4, #488]	; 0x1e8
 8022770:	f8c4 61f0 	str.w	r6, [r4, #496]	; 0x1f0
 8022774:	f8c4 a1f4 	str.w	sl, [r4, #500]	; 0x1f4
 8022778:	f8c4 91f8 	str.w	r9, [r4, #504]	; 0x1f8
  }
  else
  {
    gahbcfg.b.dmaenable = 0U;
  }
  xmc_device.global_register->gahbcfg = gahbcfg.d32;
 802277c:	609a      	str	r2, [r3, #8]
  /* configure usb details */  
  gusbcfg.d32= xmc_device.global_register->gusbcfg;
 802277e:	68d9      	ldr	r1, [r3, #12]
  gusbcfg.b.force_dev_mode = 1U; /* force us into device mode */
  gusbcfg.b.srpcap = 1U; /* enable session request protocoll */
 8022780:	f041 4180 	orr.w	r1, r1, #1073741824	; 0x40000000
 8022784:	f441 7180 	orr.w	r1, r1, #256	; 0x100
  xmc_device.global_register->gusbcfg = gusbcfg.d32;
 8022788:	60d9      	str	r1, [r3, #12]

  /* Device init */
  /* configure device speed */  
  dcfg.d32 = xmc_device.device_register->dcfg;
 802278a:	f8d3 2800 	ldr.w	r2, [r3, #2048]	; 0x800
  dcfg.b.devspd = XMC_USBD_DCFG_DEVSPD_FS;
 802278e:	f042 0203 	orr.w	r2, r2, #3
  dcfg.b.descdma = 0U;
 8022792:	f36f 52d7 	bfc	r2, #23, #1
  xmc_device.device_register->dcfg = dcfg.d32;
 8022796:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
  /* configure device functions */  
  dctl.d32 = xmc_device.device_register->dctl;
 802279a:	f8d3 2804 	ldr.w	r2, [r3, #2052]	; 0x804
 */
static void XMC_USBD_lFlushTXFifo(const uint8_t fifo_num) 
{
  volatile grstctl_t data;  
  uint32_t count;
  data.d32 = 0U;
 802279e:	2100      	movs	r1, #0
  dcfg.b.devspd = XMC_USBD_DCFG_DEVSPD_FS;
  dcfg.b.descdma = 0U;
  xmc_device.device_register->dcfg = dcfg.d32;
  /* configure device functions */  
  dctl.d32 = xmc_device.device_register->dctl;
  dctl.b.sftdiscon = 1U; /* disconnect the device until its connected by the user */
 80227a0:	f042 0202 	orr.w	r2, r2, #2
  /* all other config is done by default register value */
  xmc_device.device_register->dctl = dctl.d32;
 80227a4:	f8c3 2804 	str.w	r2, [r3, #2052]	; 0x804
 */
static void XMC_USBD_lFlushTXFifo(const uint8_t fifo_num) 
{
  volatile grstctl_t data;  
  uint32_t count;
  data.d32 = 0U;
 80227a8:	9100      	str	r1, [sp, #0]
  /*flush fifo */
  data.b.txfflsh = 1U;
 80227aa:	9a00      	ldr	r2, [sp, #0]
 80227ac:	f042 0220 	orr.w	r2, r2, #32
 80227b0:	9200      	str	r2, [sp, #0]
  data.b.txfnum = fifo_num;
 80227b2:	9900      	ldr	r1, [sp, #0]
 80227b4:	f421 61f8 	bic.w	r1, r1, #1984	; 0x7c0
 80227b8:	f441 6180 	orr.w	r1, r1, #1024	; 0x400
 80227bc:	9100      	str	r1, [sp, #0]
  xmc_device.global_register->grstctl = data.d32;
 80227be:	9a00      	ldr	r2, [sp, #0]
 80227c0:	611a      	str	r2, [r3, #16]
  for (count = 0U;count < 1000U; count++){}
  do
  {
   data.d32 = xmc_device.global_register->grstctl;
 80227c2:	691a      	ldr	r2, [r3, #16]
 80227c4:	9200      	str	r2, [sp, #0]
  } while (data.b.txfflsh);
 80227c6:	9a00      	ldr	r2, [sp, #0]
 80227c8:	f3c2 1240 	ubfx	r2, r2, #5, #1
 80227cc:	2a00      	cmp	r2, #0
 80227ce:	d1f8      	bne.n	80227c2 <XMC_USBD_Init+0x166>
static void XMC_USBD_lFlushRXFifo(void) 
{
  volatile grstctl_t data;  
  uint32_t count;
	
	data.d32 = 0U;
 80227d0:	9201      	str	r2, [sp, #4]
  data.b.rxfflsh = 1U;
 80227d2:	9a01      	ldr	r2, [sp, #4]
 80227d4:	f042 0210 	orr.w	r2, r2, #16
 80227d8:	9201      	str	r2, [sp, #4]
  /* flush FIFO */
  xmc_device.global_register->grstctl = data.d32;
 80227da:	9a01      	ldr	r2, [sp, #4]
 80227dc:	611a      	str	r2, [r3, #16]
  do
  {
    for (count = 0U; count < 1000U; count++){}
    data.d32 = xmc_device.global_register->grstctl;
 80227de:	691a      	ldr	r2, [r3, #16]
 80227e0:	9201      	str	r2, [sp, #4]
  } while (data.b.rxfflsh);
 80227e2:	9801      	ldr	r0, [sp, #4]
 80227e4:	f3c0 1000 	ubfx	r0, r0, #4, #1
 80227e8:	2800      	cmp	r0, #0
 80227ea:	d1f8      	bne.n	80227de <XMC_USBD_Init+0x182>
  gintmsk.b.usbsuspend = 1U;
  gintmsk.b.wkupintr = 1U;
  gintmsk.b.sofintr = 1U;
  if(obj->usbd_transfer_mode == XMC_USBD_USE_FIFO)
  {
    gintmsk.b.rxstsqlvl = 1U;
 80227ec:	490c      	ldr	r1, [pc, #48]	; (8022820 <XMC_USBD_Init+0x1c4>)
 80227ee:	4a0d      	ldr	r2, [pc, #52]	; (8022824 <XMC_USBD_Init+0x1c8>)
  /* flush the fifos for proper operation */
  XMC_USBD_lFlushTXFifo((uint8_t)0x10U); /* 0x10 == all fifos, see doc */
  XMC_USBD_lFlushRXFifo();
  /* Enable Global Interrupts */
  /* clear interrupt status bits prior to unmasking */
  xmc_device.global_register->gintmsk = 0U; /* disable all interrupts */
 80227f0:	6198      	str	r0, [r3, #24]
  gintmsk.b.usbsuspend = 1U;
  gintmsk.b.wkupintr = 1U;
  gintmsk.b.sofintr = 1U;
  if(obj->usbd_transfer_mode == XMC_USBD_USE_FIFO)
  {
    gintmsk.b.rxstsqlvl = 1U;
 80227f2:	2d01      	cmp	r5, #1
 80227f4:	bf18      	it	ne
 80227f6:	460a      	movne	r2, r1
  }
  gintmsk.b.outepintr = 1U;
  gintmsk.b.inepintr = 1U;
 80227f8:	f442 2240 	orr.w	r2, r2, #786432	; 0xc0000
  XMC_USBD_lFlushTXFifo((uint8_t)0x10U); /* 0x10 == all fifos, see doc */
  XMC_USBD_lFlushRXFifo();
  /* Enable Global Interrupts */
  /* clear interrupt status bits prior to unmasking */
  xmc_device.global_register->gintmsk = 0U; /* disable all interrupts */
  xmc_device.global_register->gintsts = 0xFFFFFFFFU; /* clear all interrupts */
 80227fc:	f04f 31ff 	mov.w	r1, #4294967295
 8022800:	6159      	str	r1, [r3, #20]
  {
    gintmsk.b.rxstsqlvl = 1U;
  }
  gintmsk.b.outepintr = 1U;
  gintmsk.b.inepintr = 1U;
  xmc_device.global_register->gintmsk = gintmsk.d32;
 8022802:	619a      	str	r2, [r3, #24]
  return XMC_USBD_STATUS_OK;
}
 8022804:	b003      	add	sp, #12
 8022806:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802280a:	bf00      	nop
 802280c:	20000080 	.word	0x20000080
 8022810:	1fff0078 	.word	0x1fff0078
 8022814:	1ffe978c 	.word	0x1ffe978c
 8022818:	1ffe97a8 	.word	0x1ffe97a8
 802281c:	1fff0074 	.word	0x1fff0074
 8022820:	c0003c0e 	.word	0xc0003c0e
 8022824:	c0003c1e 	.word	0xc0003c1e

08022828 <XMC_USBD_EndpointReadStart>:

/**
 * Prepares the endpoint to read next OUT packet
 **/
XMC_USBD_STATUS_t XMC_USBD_EndpointReadStart(const uint8_t ep_addr, uint32_t size) 
{
 8022828:	b4f0      	push	{r4, r5, r6, r7}
  XMC_USBD_EP_t *ep = &xmc_device.ep[ep_addr & (uint8_t)XMC_USBD_EP_NUM_MASK];
 802282a:	f000 000f 	and.w	r0, r0, #15
  XMC_USBD_STATUS_t result;
	
  if (ep->outInUse || !ep->isConfigured)
 802282e:	2434      	movs	r4, #52	; 0x34
 8022830:	4e33      	ldr	r6, [pc, #204]	; (8022900 <XMC_USBD_EndpointReadStart+0xd8>)
 8022832:	fb04 f400 	mul.w	r4, r4, r0
 8022836:	1932      	adds	r2, r6, r4

/**
 * Prepares the endpoint to read next OUT packet
 **/
XMC_USBD_STATUS_t XMC_USBD_EndpointReadStart(const uint8_t ep_addr, uint32_t size) 
{
 8022838:	b082      	sub	sp, #8
  XMC_USBD_EP_t *ep = &xmc_device.ep[ep_addr & (uint8_t)XMC_USBD_EP_NUM_MASK];
  XMC_USBD_STATUS_t result;
	
  if (ep->outInUse || !ep->isConfigured)
 802283a:	6853      	ldr	r3, [r2, #4]
 802283c:	f3c3 1300 	ubfx	r3, r3, #4, #1
 8022840:	2b00      	cmp	r3, #0
 8022842:	d136      	bne.n	80228b2 <XMC_USBD_EndpointReadStart+0x8a>
 8022844:	7915      	ldrb	r5, [r2, #4]
 8022846:	076d      	lsls	r5, r5, #29
 8022848:	d533      	bpl.n	80228b2 <XMC_USBD_EndpointReadStart+0x8a>
{
  deptsiz_data_t data;
  depctl_data_t epctl;
	
  data.d32 =  0U;
  if ((ep->xferTotal - ep->xferLength) > ep->maxTransferSize)
 802284a:	6895      	ldr	r5, [r2, #8]
 802284c:	9501      	str	r5, [sp, #4]
 802284e:	6955      	ldr	r5, [r2, #20]
    }
    /* set ep values */
    ep->xferTotal = size;
    ep->xferCount = 0U;
    ep->xferLength = 0U;
    ep->xferBuffer = ep->outBuffer;
 8022850:	68d7      	ldr	r7, [r2, #12]
    {
      size = ep->outBufferSize;
    }
    /* set ep values */
    ep->xferTotal = size;
    ep->xferCount = 0U;
 8022852:	62d3      	str	r3, [r2, #44]	; 0x2c
 8022854:	42a9      	cmp	r1, r5
 8022856:	bf28      	it	cs
 8022858:	4629      	movcs	r1, r5
{
  deptsiz_data_t data;
  depctl_data_t epctl;
	
  data.d32 =  0U;
  if ((ep->xferTotal - ep->xferLength) > ep->maxTransferSize)
 802285a:	9d01      	ldr	r5, [sp, #4]
    /* set ep values */
    ep->xferTotal = size;
    ep->xferCount = 0U;
    ep->xferLength = 0U;
    ep->xferBuffer = ep->outBuffer;
    ep->outBytesAvailable = 0U;
 802285c:	6113      	str	r3, [r2, #16]
{
  deptsiz_data_t data;
  depctl_data_t epctl;
	
  data.d32 =  0U;
  if ((ep->xferTotal - ep->xferLength) > ep->maxTransferSize)
 802285e:	f3c5 0512 	ubfx	r5, r5, #0, #19
 8022862:	428d      	cmp	r5, r1
 8022864:	bf28      	it	cs
 8022866:	460d      	movcs	r5, r1
    if (size > ep->outBufferSize)
    {
      size = ep->outBufferSize;
    }
    /* set ep values */
    ep->xferTotal = size;
 8022868:	6311      	str	r1, [r2, #48]	; 0x30
 802286a:	6295      	str	r5, [r2, #40]	; 0x28
    ep->xferCount = 0U;
    ep->xferLength = 0U;
    ep->xferBuffer = ep->outBuffer;
 802286c:	6257      	str	r7, [r2, #36]	; 0x24
  }
  else
  {
    ep->xferLength = ep->xferTotal;
  }
  if (ep->address_u.address_st.number == 0U)
 802286e:	5d34      	ldrb	r4, [r6, r4]
 8022870:	0724      	lsls	r4, r4, #28
 8022872:	d022      	beq.n	80228ba <XMC_USBD_EndpointReadStart+0x92>
    ep0_data->b.xfersize = (uint8_t)ep->xferTotal;
  }
  else
  {
    /* If requested length is zero, just receive one zero length packet */
    if (ep->xferLength == 0U)
 8022874:	2d00      	cmp	r5, #0
 8022876:	d137      	bne.n	80228e8 <XMC_USBD_EndpointReadStart+0xc0>
    {
      data.b.xfersize = 0U;
      data.b.pktcnt = 1U;
 8022878:	2201      	movs	r2, #1
 802287a:	f362 43dc 	bfi	r3, r2, #19, #10
      /* setup endpoint to recive a amount of packages by given size */
      data.b.pktcnt = (uint16_t)(((ep->xferLength - ep->xferCount) + (ep->maxPacketSize -(uint32_t)1U))/ep->maxPacketSize);
      data.b.xfersize =(uint32_t)(ep->xferLength - ep->xferCount);
    }
  }
  if(usbd_init->usbd_transfer_mode == XMC_USBD_USE_DMA)
 802287e:	4a21      	ldr	r2, [pc, #132]	; (8022904 <XMC_USBD_EndpointReadStart+0xdc>)
 8022880:	6812      	ldr	r2, [r2, #0]
 8022882:	7b52      	ldrb	r2, [r2, #13]
 8022884:	bb2a      	cbnz	r2, 80228d2 <XMC_USBD_EndpointReadStart+0xaa>
  {
    /* Programm dma address if needed */
    xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepdma = (uint32_t)(ep->xferBuffer);
 8022886:	2234      	movs	r2, #52	; 0x34
 8022888:	fb02 f000 	mul.w	r0, r2, r0
 802288c:	1831      	adds	r1, r6, r0
 802288e:	5c32      	ldrb	r2, [r6, r0]
 8022890:	6a49      	ldr	r1, [r1, #36]	; 0x24
 8022892:	f002 020f 	and.w	r2, r2, #15
 8022896:	eb06 0282 	add.w	r2, r6, r2, lsl #2
 802289a:	f8d2 21c4 	ldr.w	r2, [r2, #452]	; 0x1c4
 802289e:	6151      	str	r1, [r2, #20]
  }
  /* setup endpoint size and enable endpoint */
  xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doeptsiz = data.d32;
 80228a0:	6113      	str	r3, [r2, #16]
 
  epctl.d32 = xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl;
 80228a2:	6813      	ldr	r3, [r2, #0]
    ep->xferCount = 0U;
    ep->xferLength = 0U;
    ep->xferBuffer = ep->outBuffer;
    ep->outBytesAvailable = 0U;
    XMC_USBD_lStartReadXfer(ep);
    result= XMC_USBD_STATUS_OK;
 80228a4:	2000      	movs	r0, #0
  /* setup endpoint size and enable endpoint */
  xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doeptsiz = data.d32;
 
  epctl.d32 = xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl;
  epctl.b.cnak = 1U;
  epctl.b.epena = 1U;
 80228a6:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
  xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl = epctl.d32;
 80228aa:	6013      	str	r3, [r2, #0]
    ep->outBytesAvailable = 0U;
    XMC_USBD_lStartReadXfer(ep);
    result= XMC_USBD_STATUS_OK;
  }
  return result;
}
 80228ac:	b002      	add	sp, #8
 80228ae:	bcf0      	pop	{r4, r5, r6, r7}
 80228b0:	4770      	bx	lr
  XMC_USBD_EP_t *ep = &xmc_device.ep[ep_addr & (uint8_t)XMC_USBD_EP_NUM_MASK];
  XMC_USBD_STATUS_t result;
	
  if (ep->outInUse || !ep->isConfigured)
  {
    result = XMC_USBD_STATUS_ERROR;
 80228b2:	2001      	movs	r0, #1
    ep->outBytesAvailable = 0U;
    XMC_USBD_lStartReadXfer(ep);
    result= XMC_USBD_STATUS_OK;
  }
  return result;
}
 80228b4:	b002      	add	sp, #8
 80228b6:	bcf0      	pop	{r4, r5, r6, r7}
 80228b8:	4770      	bx	lr
  if (ep->address_u.address_st.number == 0U)
  {
	/* Setup the endpoint to receive 3 setup packages and one normal package.*/
	/* Cast the data pointer to use only one variable */
    deptsiz0_data_t *ep0_data = (deptsiz0_data_t*)&data;
    ep0_data->b.pktcnt = 0x1U;
 80228ba:	2201      	movs	r2, #1
 80228bc:	f362 43d4 	bfi	r3, r2, #19, #2
      /* setup endpoint to recive a amount of packages by given size */
      data.b.pktcnt = (uint16_t)(((ep->xferLength - ep->xferCount) + (ep->maxPacketSize -(uint32_t)1U))/ep->maxPacketSize);
      data.b.xfersize =(uint32_t)(ep->xferLength - ep->xferCount);
    }
  }
  if(usbd_init->usbd_transfer_mode == XMC_USBD_USE_DMA)
 80228c0:	4a10      	ldr	r2, [pc, #64]	; (8022904 <XMC_USBD_EndpointReadStart+0xdc>)
 80228c2:	6812      	ldr	r2, [r2, #0]
 80228c4:	7b52      	ldrb	r2, [r2, #13]
  {
	/* Setup the endpoint to receive 3 setup packages and one normal package.*/
	/* Cast the data pointer to use only one variable */
    deptsiz0_data_t *ep0_data = (deptsiz0_data_t*)&data;
    ep0_data->b.pktcnt = 0x1U;
    ep0_data->b.supcnt = 0x3U;
 80228c6:	f043 43c0 	orr.w	r3, r3, #1610612736	; 0x60000000
    ep0_data->b.xfersize = (uint8_t)ep->xferTotal;
 80228ca:	f361 0306 	bfi	r3, r1, #0, #7
      /* setup endpoint to recive a amount of packages by given size */
      data.b.pktcnt = (uint16_t)(((ep->xferLength - ep->xferCount) + (ep->maxPacketSize -(uint32_t)1U))/ep->maxPacketSize);
      data.b.xfersize =(uint32_t)(ep->xferLength - ep->xferCount);
    }
  }
  if(usbd_init->usbd_transfer_mode == XMC_USBD_USE_DMA)
 80228ce:	2a00      	cmp	r2, #0
 80228d0:	d0d9      	beq.n	8022886 <XMC_USBD_EndpointReadStart+0x5e>
 80228d2:	2234      	movs	r2, #52	; 0x34
 80228d4:	fb02 f000 	mul.w	r0, r2, r0
 80228d8:	5c32      	ldrb	r2, [r6, r0]
 80228da:	f002 020f 	and.w	r2, r2, #15
 80228de:	eb06 0282 	add.w	r2, r6, r2, lsl #2
 80228e2:	f8d2 21c4 	ldr.w	r2, [r2, #452]	; 0x1c4
 80228e6:	e7db      	b.n	80228a0 <XMC_USBD_EndpointReadStart+0x78>
      data.b.pktcnt = 1U;
    }
    else
    {
      /* setup endpoint to recive a amount of packages by given size */
      data.b.pktcnt = (uint16_t)(((ep->xferLength - ep->xferCount) + (ep->maxPacketSize -(uint32_t)1U))/ep->maxPacketSize);
 80228e8:	6852      	ldr	r2, [r2, #4]
 80228ea:	f3c2 21c6 	ubfx	r1, r2, #11, #7
 80228ee:	1e4a      	subs	r2, r1, #1
 80228f0:	442a      	add	r2, r5
 80228f2:	fbb2 f2f1 	udiv	r2, r2, r1
 80228f6:	f362 43dc 	bfi	r3, r2, #19, #10
      data.b.xfersize =(uint32_t)(ep->xferLength - ep->xferCount);
 80228fa:	f365 0312 	bfi	r3, r5, #0, #19
 80228fe:	e7be      	b.n	802287e <XMC_USBD_EndpointReadStart+0x56>
 8022900:	1fff0078 	.word	0x1fff0078
 8022904:	1fff0074 	.word	0x1fff0074

08022908 <XMC_USBD_EndpointWrite>:

/**
 * Writes number of bytes in to the USB IN endpoint.
 **/
int32_t XMC_USBD_EndpointWrite(const uint8_t ep_num,const uint8_t * buffer,uint32_t length) 
{
 8022908:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  XMC_USBD_EP_t * ep = &xmc_device.ep[ep_num & (uint8_t)XMC_USBD_EP_NUM_MASK];
 802290c:	f000 070f 	and.w	r7, r0, #15
  int32_t result;
  if (!ep->isConfigured)
 8022910:	2634      	movs	r6, #52	; 0x34
 8022912:	4d39      	ldr	r5, [pc, #228]	; (80229f8 <XMC_USBD_EndpointWrite+0xf0>)
 8022914:	fb06 f607 	mul.w	r6, r6, r7
 8022918:	19ac      	adds	r4, r5, r6
 802291a:	7923      	ldrb	r3, [r4, #4]
 802291c:	075b      	lsls	r3, r3, #29
 802291e:	d553      	bpl.n	80229c8 <XMC_USBD_EndpointWrite+0xc0>
  {
    result = (int32_t)XMC_USBD_STATUS_ERROR;
  }
  else if (ep->inInUse == 1U)
 8022920:	6863      	ldr	r3, [r4, #4]
 8022922:	0718      	lsls	r0, r3, #28
 8022924:	d457      	bmi.n	80229d6 <XMC_USBD_EndpointWrite+0xce>
  {
    result=(int32_t)0;
  }
  else
  {
    if (length > ep->inBufferSize)
 8022926:	6a23      	ldr	r3, [r4, #32]
    {
      length = ep->inBufferSize;
    }
    /* copy data into input buffer for DMA and FIFO mode */
		memcpy(ep->inBuffer,(const void *)buffer,length);
 8022928:	69e0      	ldr	r0, [r4, #28]
 802292a:	429a      	cmp	r2, r3
 802292c:	bf28      	it	cs
 802292e:	461a      	movcs	r2, r3
 8022930:	4691      	mov	r9, r2
 8022932:	f00a fe05 	bl	802d540 <memcpy>
		ep->xferBuffer = ep->inBuffer;
    ep->xferTotal = length;
    /* set transfer values */
    ep->xferLength = 0U;
    ep->xferCount = 0U;
    ep->inInUse = 1U;
 8022936:	6863      	ldr	r3, [r4, #4]
    {
      length = ep->inBufferSize;
    }
    /* copy data into input buffer for DMA and FIFO mode */
		memcpy(ep->inBuffer,(const void *)buffer,length);
		ep->xferBuffer = ep->inBuffer;
 8022938:	f8d4 c01c 	ldr.w	ip, [r4, #28]
 802293c:	f8c4 c024 	str.w	ip, [r4, #36]	; 0x24
    ep->xferTotal = length;
    /* set transfer values */
    ep->xferLength = 0U;
    ep->xferCount = 0U;
    ep->inInUse = 1U;
 8022940:	f043 0308 	orr.w	r3, r3, #8
		memcpy(ep->inBuffer,(const void *)buffer,length);
		ep->xferBuffer = ep->inBuffer;
    ep->xferTotal = length;
    /* set transfer values */
    ep->xferLength = 0U;
    ep->xferCount = 0U;
 8022944:	2100      	movs	r1, #0
    ep->inInUse = 1U;
 8022946:	6063      	str	r3, [r4, #4]
		memcpy(ep->inBuffer,(const void *)buffer,length);
		ep->xferBuffer = ep->inBuffer;
    ep->xferTotal = length;
    /* set transfer values */
    ep->xferLength = 0U;
    ep->xferCount = 0U;
 8022948:	62e1      	str	r1, [r4, #44]	; 0x2c
      length = ep->inBufferSize;
    }
    /* copy data into input buffer for DMA and FIFO mode */
		memcpy(ep->inBuffer,(const void *)buffer,length);
		ep->xferBuffer = ep->inBuffer;
    ep->xferTotal = length;
 802294a:	f8c4 9030 	str.w	r9, [r4, #48]	; 0x30
{
  deptsiz_data_t size;
  depctl_data_t ctl;
	
  size.d32 = 0U;  
  ctl.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl;
 802294e:	5da8      	ldrb	r0, [r5, r6]

  if ((ep->xferTotal - ep->xferLength)  < ep->maxTransferSize)
 8022950:	68a3      	ldr	r3, [r4, #8]
{
  deptsiz_data_t size;
  depctl_data_t ctl;
	
  size.d32 = 0U;  
  ctl.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl;
 8022952:	f000 000f 	and.w	r0, r0, #15
 8022956:	f100 0e6a 	add.w	lr, r0, #106	; 0x6a

  if ((ep->xferTotal - ep->xferLength)  < ep->maxTransferSize)
 802295a:	f3c3 0212 	ubfx	r2, r3, #0, #19
{
  deptsiz_data_t size;
  depctl_data_t ctl;
	
  size.d32 = 0U;  
  ctl.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl;
 802295e:	f855 802e 	ldr.w	r8, [r5, lr, lsl #2]
 8022962:	454a      	cmp	r2, r9
 8022964:	bf28      	it	cs
 8022966:	464a      	movcs	r2, r9
 8022968:	f8d8 e000 	ldr.w	lr, [r8]
 802296c:	62a2      	str	r2, [r4, #40]	; 0x28
  }
  else
  {
    ep->xferLength += ep->maxTransferSize;
  }
  if (ep->xferLength == 0U)
 802296e:	b3aa      	cbz	r2, 80229dc <XMC_USBD_EndpointWrite+0xd4>
    size.b.xfersize = 0U;
    size.b.pktcnt = 1U;
  }
  else
  {
    if (ep->address_u.address_st.number == 0U)
 8022970:	5dab      	ldrb	r3, [r5, r6]
 8022972:	071b      	lsls	r3, r3, #28
 8022974:	d02b      	beq.n	80229ce <XMC_USBD_EndpointWrite+0xc6>
      size.b.xfersize = (uint32_t)(ep->xferLength - ep->xferCount);
    }
    else
    {
      size.b.xfersize =(uint32_t)(ep->xferLength - ep->xferCount);
      size.b.pktcnt = (uint16_t)(((uint16_t)(ep->xferLength - ep->xferCount) + (uint16_t)((uint16_t)ep->maxPacketSize - 1U))/
 8022976:	6863      	ldr	r3, [r4, #4]
 8022978:	f3c3 24c6 	ubfx	r4, r3, #11, #7
 802297c:	1e63      	subs	r3, r4, #1
 802297e:	b29b      	uxth	r3, r3
 8022980:	fa13 f382 	uxtah	r3, r3, r2
      /* ep->maxXferSize equals maxPacketSize */
      size.b.xfersize = (uint32_t)(ep->xferLength - ep->xferCount);
    }
    else
    {
      size.b.xfersize =(uint32_t)(ep->xferLength - ep->xferCount);
 8022984:	f3c2 0212 	ubfx	r2, r2, #0, #19
      size.b.pktcnt = (uint16_t)(((uint16_t)(ep->xferLength - ep->xferCount) + (uint16_t)((uint16_t)ep->maxPacketSize - 1U))/
 8022988:	fb93 f3f4 	sdiv	r3, r3, r4
 802298c:	f3c3 0309 	ubfx	r3, r3, #0, #10
    		 ep->maxPacketSize);
    }
    if(usbd_init->usbd_transfer_mode == XMC_USBD_USE_DMA)
 8022990:	4c1a      	ldr	r4, [pc, #104]	; (80229fc <XMC_USBD_EndpointWrite+0xf4>)
 8022992:	6824      	ldr	r4, [r4, #0]
 8022994:	7b64      	ldrb	r4, [r4, #13]
 8022996:	f362 0112 	bfi	r1, r2, #0, #19
 802299a:	f363 41dc 	bfi	r1, r3, #19, #10
 802299e:	bb0c      	cbnz	r4, 80229e4 <XMC_USBD_EndpointWrite+0xdc>
    {
      /* Program dma*/
      xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepdma = (uint32_t)ep->xferBuffer;
 80229a0:	f8c8 c014 	str.w	ip, [r8, #20]
			xmc_device.device_register->dtknqr4_fifoemptymsk |= (uint32_t)((uint32_t)1U << (uint8_t)ep->address_u.address_st.number);
    }
  }

  /* Program size of transfer and enable endpoint */
  xmc_device.endpoint_in_register[ep->address_u.address_st.number]->dieptsiz = size.d32;
 80229a4:	2334      	movs	r3, #52	; 0x34
 80229a6:	fb03 f707 	mul.w	r7, r3, r7
 80229aa:	19ea      	adds	r2, r5, r7
 80229ac:	5deb      	ldrb	r3, [r5, r7]
    ep->xferLength = 0U;
    ep->xferCount = 0U;
    ep->inInUse = 1U;
    /* start the transfer */
    XMC_USBD_lStartWriteXfer(ep);
    result=(int32_t)ep->xferTotal;
 80229ae:	6b10      	ldr	r0, [r2, #48]	; 0x30
			xmc_device.device_register->dtknqr4_fifoemptymsk |= (uint32_t)((uint32_t)1U << (uint8_t)ep->address_u.address_st.number);
    }
  }

  /* Program size of transfer and enable endpoint */
  xmc_device.endpoint_in_register[ep->address_u.address_st.number]->dieptsiz = size.d32;
 80229b0:	f003 030f 	and.w	r3, r3, #15
 80229b4:	336a      	adds	r3, #106	; 0x6a
  ctl.b.epena = 1U;
  ctl.b.cnak = 1U;
 80229b6:	f04e 4e04 	orr.w	lr, lr, #2214592512	; 0x84000000
			xmc_device.device_register->dtknqr4_fifoemptymsk |= (uint32_t)((uint32_t)1U << (uint8_t)ep->address_u.address_st.number);
    }
  }

  /* Program size of transfer and enable endpoint */
  xmc_device.endpoint_in_register[ep->address_u.address_st.number]->dieptsiz = size.d32;
 80229ba:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
 80229be:	6119      	str	r1, [r3, #16]
  ctl.b.epena = 1U;
  ctl.b.cnak = 1U;
  xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = ctl.d32;
 80229c0:	f8c3 e000 	str.w	lr, [r3]
 80229c4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
{
  XMC_USBD_EP_t * ep = &xmc_device.ep[ep_num & (uint8_t)XMC_USBD_EP_NUM_MASK];
  int32_t result;
  if (!ep->isConfigured)
  {
    result = (int32_t)XMC_USBD_STATUS_ERROR;
 80229c8:	2001      	movs	r0, #1
 80229ca:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  {
    if (ep->address_u.address_st.number == 0U)
    {
      size.b.pktcnt = 1U;
      /* ep->maxXferSize equals maxPacketSize */
      size.b.xfersize = (uint32_t)(ep->xferLength - ep->xferCount);
 80229ce:	f3c2 0212 	ubfx	r2, r2, #0, #19
  }
  else
  {
    if (ep->address_u.address_st.number == 0U)
    {
      size.b.pktcnt = 1U;
 80229d2:	2301      	movs	r3, #1
 80229d4:	e7dc      	b.n	8022990 <XMC_USBD_EndpointWrite+0x88>
  {
    result = (int32_t)XMC_USBD_STATUS_ERROR;
  }
  else if (ep->inInUse == 1U)
  {
    result=(int32_t)0;
 80229d6:	2000      	movs	r0, #0
    /* start the transfer */
    XMC_USBD_lStartWriteXfer(ep);
    result=(int32_t)ep->xferTotal;
  }
  return result;
}
 80229d8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    ep->xferLength += ep->maxTransferSize;
  }
  if (ep->xferLength == 0U)
  {
    size.b.xfersize = 0U;
    size.b.pktcnt = 1U;
 80229dc:	2301      	movs	r3, #1
 80229de:	f363 41dc 	bfi	r1, r3, #19, #10
 80229e2:	e7df      	b.n	80229a4 <XMC_USBD_EndpointWrite+0x9c>
    if(usbd_init->usbd_transfer_mode == XMC_USBD_USE_DMA)
    {
      /* Program dma*/
      xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepdma = (uint32_t)ep->xferBuffer;
    }
    if(usbd_init->usbd_transfer_mode == XMC_USBD_USE_FIFO)
 80229e4:	2c01      	cmp	r4, #1
 80229e6:	d1dd      	bne.n	80229a4 <XMC_USBD_EndpointWrite+0x9c>
    {
      /* enable fifo empty interrupt */
			xmc_device.device_register->dtknqr4_fifoemptymsk |= (uint32_t)((uint32_t)1U << (uint8_t)ep->address_u.address_st.number);
 80229e8:	f8d5 21a4 	ldr.w	r2, [r5, #420]	; 0x1a4
 80229ec:	6b53      	ldr	r3, [r2, #52]	; 0x34
 80229ee:	4084      	lsls	r4, r0
 80229f0:	431c      	orrs	r4, r3
 80229f2:	6354      	str	r4, [r2, #52]	; 0x34
 80229f4:	e7d6      	b.n	80229a4 <XMC_USBD_EndpointWrite+0x9c>
 80229f6:	bf00      	nop
 80229f8:	1fff0078 	.word	0x1fff0078
 80229fc:	1fff0074 	.word	0x1fff0074

08022a00 <XMC_USBD_IRQHandler>:
 *
 * The handler first checks, which global interrupt has caused the interrupt
 * and then dispatches interrupt to the corresponding sub-handler.
 */
void XMC_USBD_IRQHandler(const XMC_USBD_t *const obj) 
{
 8022a00:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  gintmsk_data_t gintmsk;
  gintsts_data_t data;
	
  gintmsk.d32 = xmc_device.global_register->gintmsk;
 8022a04:	4cb9      	ldr	r4, [pc, #740]	; (8022cec <XMC_USBD_IRQHandler+0x2ec>)
 8022a06:	f8d4 31a0 	ldr.w	r3, [r4, #416]	; 0x1a0
 8022a0a:	699d      	ldr	r5, [r3, #24]
  data.d32 = xmc_device.global_register->gintsts & gintmsk.d32;
 8022a0c:	695a      	ldr	r2, [r3, #20]
 *
 * The handler first checks, which global interrupt has caused the interrupt
 * and then dispatches interrupt to the corresponding sub-handler.
 */
void XMC_USBD_IRQHandler(const XMC_USBD_t *const obj) 
{
 8022a0e:	b08f      	sub	sp, #60	; 0x3c
  gintmsk_data_t gintmsk;
  gintsts_data_t data;
	
  gintmsk.d32 = xmc_device.global_register->gintmsk;
  data.d32 = xmc_device.global_register->gintsts & gintmsk.d32;
 8022a10:	ea02 0a05 	and.w	sl, r2, r5
	
  if (data.b.sofintr)
 8022a14:	fa5f f68a 	uxtb.w	r6, sl
 *
 * The handler first checks, which global interrupt has caused the interrupt
 * and then dispatches interrupt to the corresponding sub-handler.
 */
void XMC_USBD_IRQHandler(const XMC_USBD_t *const obj) 
{
 8022a18:	9001      	str	r0, [sp, #4]
  gintsts_data_t data;
	
  gintmsk.d32 = xmc_device.global_register->gintmsk;
  data.d32 = xmc_device.global_register->gintsts & gintmsk.d32;
	
  if (data.b.sofintr)
 8022a1a:	0730      	lsls	r0, r6, #28
 8022a1c:	f100 82eb 	bmi.w	8022ff6 <XMC_USBD_IRQHandler+0x5f6>
  {
    xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_SOF);
    XMC_USBD_ClearEvent(XMC_USBD_EVENT_SOF);
  }
  if(obj->usbd_transfer_mode == XMC_USBD_USE_FIFO)
 8022a20:	9a01      	ldr	r2, [sp, #4]
 8022a22:	7b52      	ldrb	r2, [r2, #13]
 8022a24:	2a01      	cmp	r2, #1
 8022a26:	f000 82f3 	beq.w	8023010 <XMC_USBD_IRQHandler+0x610>
      XMC_USBD_lHandleRxFLvl(); /* handle the interrupt */
      gintmsk.b.rxstsqlvl = 1U;
      xmc_device.global_register->gintmsk = gintmsk.d32;
    }
  }
  if (data.b.erlysuspend)
 8022a2a:	f3ca 2507 	ubfx	r5, sl, #8, #8
 8022a2e:	0769      	lsls	r1, r5, #29
	  break;
    case (XMC_USBD_EVENT_SOF):
	  clear.b.sofintr = 1U;
	  break;
    case (XMC_USBD_EVENT_EARLYSUSPEND):
	  clear.b.erlysuspend = 1U;
 8022a30:	bf44      	itt	mi
 8022a32:	f44f 6280 	movmi.w	r2, #1024	; 0x400
	  clear.b.outepintr = 1U;
	  break;
		default:
		break;
	}
	xmc_device.global_register->gintsts = clear.d32;
 8022a36:	615a      	strmi	r2, [r3, #20]
  }
  if (data.b.erlysuspend)
  {
    XMC_USBD_ClearEvent(XMC_USBD_EVENT_EARLYSUSPEND);
  }
  if (data.b.usbsuspend)
 8022a38:	072a      	lsls	r2, r5, #28
 8022a3a:	f100 82d2 	bmi.w	8022fe2 <XMC_USBD_IRQHandler+0x5e2>
  {
    xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_SUSPEND);
    XMC_USBD_ClearEvent(XMC_USBD_EVENT_SUSPEND);
  }
  if (data.b.wkupintr)
 8022a3e:	ea4f 661a 	mov.w	r6, sl, lsr #24
 8022a42:	0637      	lsls	r7, r6, #24
 8022a44:	f100 82c3 	bmi.w	8022fce <XMC_USBD_IRQHandler+0x5ce>
  {
    xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_REMOTE_WAKEUP);
    XMC_USBD_ClearEvent(XMC_USBD_EVENT_REMOTE_WAKEUP);
  }
  if (data.b.sessreqintr)
 8022a48:	0670      	lsls	r0, r6, #25
 8022a4a:	f100 82b0 	bmi.w	8022fae <XMC_USBD_IRQHandler+0x5ae>
  {
    xmc_device.IsPowered = 1U;
    xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_POWER_ON);
    XMC_USBD_ClearEvent(XMC_USBD_EVENT_POWER_ON);
  }
  if (data.b.usbreset)
 8022a4e:	06e9      	lsls	r1, r5, #27
 8022a50:	f100 81f1 	bmi.w	8022e36 <XMC_USBD_IRQHandler+0x436>
  {
    XMC_USBD_lHandleUSBReset(obj);
  }
  if (data.b.enumdone)
 8022a54:	06aa      	lsls	r2, r5, #26
 8022a56:	f100 81d3 	bmi.w	8022e00 <XMC_USBD_IRQHandler+0x400>
  {
    XMC_USBD_lHandleEnumDone();
  }
  if (data.b.inepint)
 8022a5a:	f41a 2f80 	tst.w	sl, #262144	; 0x40000
 8022a5e:	f040 8105 	bne.w	8022c6c <XMC_USBD_IRQHandler+0x26c>
  {
    XMC_USBD_lHandleIEPInt(obj);
  }
  if (data.b.outepintr)
 8022a62:	f41a 2f00 	tst.w	sl, #524288	; 0x80000
 8022a66:	d118      	bne.n	8022a9a <XMC_USBD_IRQHandler+0x9a>
  {
		XMC_USBD_lHandleOEPInt(obj);
  }
	if (data.b.otgintr)
 8022a68:	f01a 0f04 	tst.w	sl, #4
 8022a6c:	d102      	bne.n	8022a74 <XMC_USBD_IRQHandler+0x74>
  {
	  XMC_USBD_lHandleOTGInt();
  }

}
 8022a6e:	b00f      	add	sp, #60	; 0x3c
 8022a70:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
* It detects especially connect and disconnect events.
*/
static void XMC_USBD_lHandleOTGInt(void) 
{
  gotgint_data_t data;
  data.d32 = xmc_device.global_register->gotgint;
 8022a74:	685d      	ldr	r5, [r3, #4]
  if (data.b.sesenddet)
 8022a76:	0768      	lsls	r0, r5, #29
 8022a78:	d50b      	bpl.n	8022a92 <XMC_USBD_IRQHandler+0x92>
  {
		xmc_device.IsPowered = 0U;
 8022a7a:	f894 31fe 	ldrb.w	r3, [r4, #510]	; 0x1fe
		xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_POWER_OFF);
 8022a7e:	f8d4 2200 	ldr.w	r2, [r4, #512]	; 0x200
{
  gotgint_data_t data;
  data.d32 = xmc_device.global_register->gotgint;
  if (data.b.sesenddet)
  {
		xmc_device.IsPowered = 0U;
 8022a82:	f36f 0382 	bfc	r3, #2, #1
 8022a86:	f884 31fe 	strb.w	r3, [r4, #510]	; 0x1fe
		xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_POWER_OFF);
 8022a8a:	2001      	movs	r0, #1
 8022a8c:	4790      	blx	r2
 8022a8e:	f8d4 31a0 	ldr.w	r3, [r4, #416]	; 0x1a0
 **/
static void XMC_USBD_lClearEventOTG(uint32_t event)
{
  gotgint_data_t clear = { .d32 = 0U};
  clear.d32 = event;
  xmc_device.global_register->gotgint = clear.d32;
 8022a92:	605d      	str	r5, [r3, #4]
	if (data.b.otgintr)
  {
	  XMC_USBD_lHandleOTGInt();
  }

}
 8022a94:	b00f      	add	sp, #60	; 0x3c
 8022a96:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  uint16_t temp;
  uint16_t temp1;
  uint16_t mask;
  uint8_t ep_num;
	
  daint.d32 = xmc_device.device_register->daint;
 8022a9a:	f8d4 21a4 	ldr.w	r2, [r4, #420]	; 0x1a4
 8022a9e:	6993      	ldr	r3, [r2, #24]
  
  daintmsk.d32 = xmc_device.device_register->daintmsk;
 8022aa0:	69d7      	ldr	r7, [r2, #28]
  
  doepmsk.d32 = xmc_device.device_register->doepmsk;  
 8022aa2:	6952      	ldr	r2, [r2, #20]
 8022aa4:	9202      	str	r2, [sp, #8]
  
  mask = daint.ep.out & daintmsk.ep.out;
 8022aa6:	f3c3 430f 	ubfx	r3, r3, #16, #16
  ep_num = 0U;
  doeptsiz.d32 = 0U;
 8022aaa:	2200      	movs	r2, #0
 
  while ((uint16_t)mask >> ep_num)
 8022aac:	ea13 4717 	ands.w	r7, r3, r7, lsr #16
  
  doepmsk.d32 = xmc_device.device_register->doepmsk;  
  
  mask = daint.ep.out & daintmsk.ep.out;
  ep_num = 0U;
  doeptsiz.d32 = 0U;
 8022ab0:	9203      	str	r2, [sp, #12]
 
  while ((uint16_t)mask >> ep_num)
 8022ab2:	f000 8097 	beq.w	8022be4 <XMC_USBD_IRQHandler+0x1e4>
      }
	  /* Setup Phase Complete */
      if (doepint.b.setup)
      {
        /* ep0 not stalled any more */
        ep->isStalled = 0U;
 8022ab6:	f8dd b004 	ldr.w	fp, [sp, #4]
 8022aba:	f8cd a010 	str.w	sl, [sp, #16]
 8022abe:	4616      	mov	r6, r2
  
  mask = daint.ep.out & daintmsk.ep.out;
  ep_num = 0U;
  doeptsiz.d32 = 0U;
 
  while ((uint16_t)mask >> ep_num)
 8022ac0:	463b      	mov	r3, r7
 8022ac2:	4615      	mov	r5, r2
      }
	  /* Setup Phase Complete */
      if (doepint.b.setup)
      {
        /* ep0 not stalled any more */
        ep->isStalled = 0U;
 8022ac4:	f04f 0c34 	mov.w	ip, #52	; 0x34
 8022ac8:	46b8      	mov	r8, r7
 
  while ((uint16_t)mask >> ep_num)
  {
    temp1 = (mask >> (uint16_t)ep_num);
    temp = temp1 & 0x1U;
    if (temp)
 8022aca:	07df      	lsls	r7, r3, #31
 8022acc:	f140 8081 	bpl.w	8022bd2 <XMC_USBD_IRQHandler+0x1d2>
    {
      /* load register data for endpoint */
      ep = &xmc_device.ep[ep_num];
      doepint.d32 = xmc_device.endpoint_out_register[ep_num]->doepint & doepmsk.d32;
 8022ad0:	f106 0970 	add.w	r9, r6, #112	; 0x70
 8022ad4:	eb04 0289 	add.w	r2, r4, r9, lsl #2
 8022ad8:	9902      	ldr	r1, [sp, #8]
 8022ada:	6852      	ldr	r2, [r2, #4]
      if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
 8022adc:	f89b 300d 	ldrb.w	r3, [fp, #13]
    temp = temp1 & 0x1U;
    if (temp)
    {
      /* load register data for endpoint */
      ep = &xmc_device.ep[ep_num];
      doepint.d32 = xmc_device.endpoint_out_register[ep_num]->doepint & doepmsk.d32;
 8022ae0:	6897      	ldr	r7, [r2, #8]
 8022ae2:	400f      	ands	r7, r1
      if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
      {
        doeptsiz.d32 = xmc_device.endpoint_out_register[ep_num]->doeptsiz;
      }
	  /* Setup Phase Complete */
      if (doepint.b.setup)
 8022ae4:	fa5f fa87 	uxtb.w	sl, r7
    if (temp)
    {
      /* load register data for endpoint */
      ep = &xmc_device.ep[ep_num];
      doepint.d32 = xmc_device.endpoint_out_register[ep_num]->doepint & doepmsk.d32;
      if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
 8022ae8:	2b00      	cmp	r3, #0
 8022aea:	f040 8081 	bne.w	8022bf0 <XMC_USBD_IRQHandler+0x1f0>
      {
        doeptsiz.d32 = xmc_device.endpoint_out_register[ep_num]->doeptsiz;
 8022aee:	6911      	ldr	r1, [r2, #16]
 8022af0:	9103      	str	r1, [sp, #12]
      }
	  /* Setup Phase Complete */
      if (doepint.b.setup)
 8022af2:	f01a 0f08 	tst.w	sl, #8
 8022af6:	d021      	beq.n	8022b3c <XMC_USBD_IRQHandler+0x13c>
      {
        /* ep0 not stalled any more */
        ep->isStalled = 0U;
 8022af8:	4a7c      	ldr	r2, [pc, #496]	; (8022cec <XMC_USBD_IRQHandler+0x2ec>)
 8022afa:	fb0c 2006 	mla	r0, ip, r6, r2
        if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
        {
          /* calculate size for setup packet */
		  ep->outBytesAvailable = (uint32_t)(((uint32_t)XMC_USBD_SETUP_COUNT -
		  (uint32_t)((deptsiz0_data_t*)&doeptsiz)->b.supcnt)*(uint32_t)XMC_USBD_SETUP_SIZE);
 8022afe:	9a03      	ldr	r2, [sp, #12]
      }
	  /* Setup Phase Complete */
      if (doepint.b.setup)
      {
        /* ep0 not stalled any more */
        ep->isStalled = 0U;
 8022b00:	7901      	ldrb	r1, [r0, #4]
        if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
        {
          /* calculate size for setup packet */
		  ep->outBytesAvailable = (uint32_t)(((uint32_t)XMC_USBD_SETUP_COUNT -
		  (uint32_t)((deptsiz0_data_t*)&doeptsiz)->b.supcnt)*(uint32_t)XMC_USBD_SETUP_SIZE);
 8022b02:	f3c2 7241 	ubfx	r2, r2, #29, #2
        /* ep0 not stalled any more */
        ep->isStalled = 0U;
        if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
        {
          /* calculate size for setup packet */
		  ep->outBytesAvailable = (uint32_t)(((uint32_t)XMC_USBD_SETUP_COUNT -
 8022b06:	00d2      	lsls	r2, r2, #3
      }
	  /* Setup Phase Complete */
      if (doepint.b.setup)
      {
        /* ep0 not stalled any more */
        ep->isStalled = 0U;
 8022b08:	f363 1145 	bfi	r1, r3, #5, #1
        if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
        {
          /* calculate size for setup packet */
		  ep->outBytesAvailable = (uint32_t)(((uint32_t)XMC_USBD_SETUP_COUNT -
 8022b0c:	f1c2 0218 	rsb	r2, r2, #24
      }
	  /* Setup Phase Complete */
      if (doepint.b.setup)
      {
        /* ep0 not stalled any more */
        ep->isStalled = 0U;
 8022b10:	7101      	strb	r1, [r0, #4]
        if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
        {
          /* calculate size for setup packet */
		  ep->outBytesAvailable = (uint32_t)(((uint32_t)XMC_USBD_SETUP_COUNT -
 8022b12:	6102      	str	r2, [r0, #16]
        }
		if(obj->usbd_transfer_mode == XMC_USBD_USE_FIFO)
		{
			ep->outBytesAvailable += ep->xferCount;
		}
		ep->outInUse = 0U;
 8022b14:	fb0c 4306 	mla	r3, ip, r6, r4
 8022b18:	f8cd c004 	str.w	ip, [sp, #4]
 8022b1c:	685a      	ldr	r2, [r3, #4]
 8022b1e:	f022 0210 	bic.w	r2, r2, #16
 8022b22:	605a      	str	r2, [r3, #4]
		xmc_device.EndpointEvent_cb(0U,XMC_USBD_EP_EVENT_SETUP); /* signal endpoint event */
 8022b24:	2000      	movs	r0, #0
 8022b26:	f8d4 3204 	ldr.w	r3, [r4, #516]	; 0x204
 8022b2a:	4601      	mov	r1, r0
 8022b2c:	4798      	blx	r3
 **/
void XMC_USBD_ClearEventOUTEP(uint32_t event,const uint8_t ep_num)
{
  doepint_data_t clear;
  clear.d32 = event;
  xmc_device.endpoint_out_register[ep_num]->doepint = clear.d32;
 8022b2e:	eb04 0389 	add.w	r3, r4, r9, lsl #2
 8022b32:	2108      	movs	r1, #8
 8022b34:	685a      	ldr	r2, [r3, #4]
 8022b36:	f8dd c004 	ldr.w	ip, [sp, #4]
 8022b3a:	6091      	str	r1, [r2, #8]
		ep->outInUse = 0U;
		xmc_device.EndpointEvent_cb(0U,XMC_USBD_EP_EVENT_SETUP); /* signal endpoint event */
				/* clear the interrupt */
		XMC_USBD_ClearEventOUTEP((uint32_t)XMC_USBD_EVENT_OUT_EP_SETUP,ep_num);
      }
      if (doepint.b.xfercompl)
 8022b3c:	f01a 0f01 	tst.w	sl, #1
 8022b40:	d046      	beq.n	8022bd0 <XMC_USBD_IRQHandler+0x1d0>
      {
        if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
 8022b42:	f89b 300d 	ldrb.w	r3, [fp, #13]
 8022b46:	2b00      	cmp	r3, #0
 8022b48:	d063      	beq.n	8022c12 <XMC_USBD_IRQHandler+0x212>
 8022b4a:	fb0c 4306 	mla	r3, ip, r6, r4
 8022b4e:	6a99      	ldr	r1, [r3, #40]	; 0x28
        {
          uint32_t bytes = (ep->xferLength - ep->xferCount) - doeptsiz.b.xfersize;
          ep->xferCount += bytes;
          ep->xferBuffer += bytes;
				}
        if (ep->xferTotal == ep->xferLength)
 8022b50:	fb0c 4306 	mla	r3, ip, r6, r4
 8022b54:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8022b56:	428a      	cmp	r2, r1
 8022b58:	d072      	beq.n	8022c40 <XMC_USBD_IRQHandler+0x240>
{
  deptsiz_data_t data;
  depctl_data_t epctl;
	
  data.d32 =  0U;
  if ((ep->xferTotal - ep->xferLength) > ep->maxTransferSize)
 8022b5a:	6898      	ldr	r0, [r3, #8]
 8022b5c:	ebc1 0e02 	rsb	lr, r1, r2
 8022b60:	f3c0 0012 	ubfx	r0, r0, #0, #19
 8022b64:	4586      	cmp	lr, r0
 8022b66:	fb0c fe06 	mul.w	lr, ip, r6
  {
    ep->xferLength += ep->maxTransferSize;
 8022b6a:	bf88      	it	hi
 8022b6c:	1809      	addhi	r1, r1, r0
 8022b6e:	eb04 000e 	add.w	r0, r4, lr
{
  deptsiz_data_t data;
  depctl_data_t epctl;
	
  data.d32 =  0U;
  if ((ep->xferTotal - ep->xferLength) > ep->maxTransferSize)
 8022b72:	bf98      	it	ls
 8022b74:	4611      	movls	r1, r2
 8022b76:	6281      	str	r1, [r0, #40]	; 0x28
  }
  else
  {
    ep->xferLength = ep->xferTotal;
  }
  if (ep->address_u.address_st.number == 0U)
 8022b78:	f814 e00e 	ldrb.w	lr, [r4, lr]
 8022b7c:	f01e 0f0f 	tst.w	lr, #15
static void XMC_USBD_lStartReadXfer(XMC_USBD_EP_t *const ep) 
{
  deptsiz_data_t data;
  depctl_data_t epctl;
	
  data.d32 =  0U;
 8022b80:	f04f 0300 	mov.w	r3, #0
 8022b84:	f100 0a28 	add.w	sl, r0, #40	; 0x28
  }
  else
  {
    ep->xferLength = ep->xferTotal;
  }
  if (ep->address_u.address_st.number == 0U)
 8022b88:	f040 82ae 	bne.w	80230e8 <XMC_USBD_IRQHandler+0x6e8>
  {
	/* Setup the endpoint to receive 3 setup packages and one normal package.*/
	/* Cast the data pointer to use only one variable */
    deptsiz0_data_t *ep0_data = (deptsiz0_data_t*)&data;
    ep0_data->b.pktcnt = 0x1U;
 8022b8c:	2101      	movs	r1, #1
 8022b8e:	f361 43d4 	bfi	r3, r1, #19, #2
    ep0_data->b.supcnt = 0x3U;
 8022b92:	f043 43c0 	orr.w	r3, r3, #1610612736	; 0x60000000
    ep0_data->b.xfersize = (uint8_t)ep->xferTotal;
 8022b96:	f362 0306 	bfi	r3, r2, #0, #7
      /* setup endpoint to recive a amount of packages by given size */
      data.b.pktcnt = (uint16_t)(((ep->xferLength - ep->xferCount) + (ep->maxPacketSize -(uint32_t)1U))/ep->maxPacketSize);
      data.b.xfersize =(uint32_t)(ep->xferLength - ep->xferCount);
    }
  }
  if(usbd_init->usbd_transfer_mode == XMC_USBD_USE_DMA)
 8022b9a:	4a55      	ldr	r2, [pc, #340]	; (8022cf0 <XMC_USBD_IRQHandler+0x2f0>)
 8022b9c:	6812      	ldr	r2, [r2, #0]
 8022b9e:	7b52      	ldrb	r2, [r2, #13]
  {
    /* Programm dma address if needed */
    xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepdma = (uint32_t)(ep->xferBuffer);
 8022ba0:	fb0c f606 	mul.w	r6, ip, r6
      /* setup endpoint to recive a amount of packages by given size */
      data.b.pktcnt = (uint16_t)(((ep->xferLength - ep->xferCount) + (ep->maxPacketSize -(uint32_t)1U))/ep->maxPacketSize);
      data.b.xfersize =(uint32_t)(ep->xferLength - ep->xferCount);
    }
  }
  if(usbd_init->usbd_transfer_mode == XMC_USBD_USE_DMA)
 8022ba4:	2a00      	cmp	r2, #0
 8022ba6:	f040 82a6 	bne.w	80230f6 <XMC_USBD_IRQHandler+0x6f6>
  {
    /* Programm dma address if needed */
    xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepdma = (uint32_t)(ep->xferBuffer);
 8022baa:	5da2      	ldrb	r2, [r4, r6]
 8022bac:	f002 020f 	and.w	r2, r2, #15
 8022bb0:	19a1      	adds	r1, r4, r6
 8022bb2:	eb04 0282 	add.w	r2, r4, r2, lsl #2
 8022bb6:	6a48      	ldr	r0, [r1, #36]	; 0x24
 8022bb8:	f8d2 11c4 	ldr.w	r1, [r2, #452]	; 0x1c4
 8022bbc:	6148      	str	r0, [r1, #20]
  }
  /* setup endpoint size and enable endpoint */
  xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doeptsiz = data.d32;
 8022bbe:	610b      	str	r3, [r1, #16]
 
  epctl.d32 = xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl;
 8022bc0:	680b      	ldr	r3, [r1, #0]
 8022bc2:	eb04 0989 	add.w	r9, r4, r9, lsl #2
  epctl.b.cnak = 1U;
  epctl.b.epena = 1U;
 8022bc6:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
 8022bca:	f8d9 2004 	ldr.w	r2, [r9, #4]
  xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl = epctl.d32;
 8022bce:	600b      	str	r3, [r1, #0]
 **/
void XMC_USBD_ClearEventOUTEP(uint32_t event,const uint8_t ep_num)
{
  doepint_data_t clear;
  clear.d32 = event;
  xmc_device.endpoint_out_register[ep_num]->doepint = clear.d32;
 8022bd0:	6097      	str	r7, [r2, #8]

      }

      XMC_USBD_ClearEventOUTEP(doepint.d32,ep_num);
    }
    ep_num++;
 8022bd2:	3501      	adds	r5, #1
 8022bd4:	b2ed      	uxtb	r5, r5
  
  mask = daint.ep.out & daintmsk.ep.out;
  ep_num = 0U;
  doeptsiz.d32 = 0U;
 
  while ((uint16_t)mask >> ep_num)
 8022bd6:	fa58 f305 	asrs.w	r3, r8, r5
 8022bda:	462e      	mov	r6, r5
 8022bdc:	f47f af75 	bne.w	8022aca <XMC_USBD_IRQHandler+0xca>
 8022be0:	f8dd a010 	ldr.w	sl, [sp, #16]
	  clear.b.outepintr = 1U;
	  break;
		default:
		break;
	}
	xmc_device.global_register->gintsts = clear.d32;
 8022be4:	f8d4 31a0 	ldr.w	r3, [r4, #416]	; 0x1a0
	  break;
    case (XMC_USBD_EVENT_ENUMDONE):
	  clear.b.enumdone = 1U;
	  break;
    case (XMC_USBD_EVENT_OUTEP):
	  clear.b.outepintr = 1U;
 8022be8:	f44f 2200 	mov.w	r2, #524288	; 0x80000
	  break;
		default:
		break;
	}
	xmc_device.global_register->gintsts = clear.d32;
 8022bec:	615a      	str	r2, [r3, #20]
 8022bee:	e73b      	b.n	8022a68 <XMC_USBD_IRQHandler+0x68>
      if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
      {
        doeptsiz.d32 = xmc_device.endpoint_out_register[ep_num]->doeptsiz;
      }
	  /* Setup Phase Complete */
      if (doepint.b.setup)
 8022bf0:	f01a 0f08 	tst.w	sl, #8
 8022bf4:	d0a2      	beq.n	8022b3c <XMC_USBD_IRQHandler+0x13c>
      {
        /* ep0 not stalled any more */
        ep->isStalled = 0U;
 8022bf6:	4a3d      	ldr	r2, [pc, #244]	; (8022cec <XMC_USBD_IRQHandler+0x2ec>)
 8022bf8:	fb0c 2106 	mla	r1, ip, r6, r2
        {
          /* calculate size for setup packet */
		  ep->outBytesAvailable = (uint32_t)(((uint32_t)XMC_USBD_SETUP_COUNT -
		  (uint32_t)((deptsiz0_data_t*)&doeptsiz)->b.supcnt)*(uint32_t)XMC_USBD_SETUP_SIZE);
        }
		if(obj->usbd_transfer_mode == XMC_USBD_USE_FIFO)
 8022bfc:	2b01      	cmp	r3, #1
      }
	  /* Setup Phase Complete */
      if (doepint.b.setup)
      {
        /* ep0 not stalled any more */
        ep->isStalled = 0U;
 8022bfe:	790a      	ldrb	r2, [r1, #4]
 8022c00:	f36f 1245 	bfc	r2, #5, #1
 8022c04:	710a      	strb	r2, [r1, #4]
        {
          /* calculate size for setup packet */
		  ep->outBytesAvailable = (uint32_t)(((uint32_t)XMC_USBD_SETUP_COUNT -
		  (uint32_t)((deptsiz0_data_t*)&doeptsiz)->b.supcnt)*(uint32_t)XMC_USBD_SETUP_SIZE);
        }
		if(obj->usbd_transfer_mode == XMC_USBD_USE_FIFO)
 8022c06:	d185      	bne.n	8022b14 <XMC_USBD_IRQHandler+0x114>
		{
			ep->outBytesAvailable += ep->xferCount;
 8022c08:	690b      	ldr	r3, [r1, #16]
 8022c0a:	6aca      	ldr	r2, [r1, #44]	; 0x2c
 8022c0c:	4413      	add	r3, r2
 8022c0e:	610b      	str	r3, [r1, #16]
 8022c10:	e780      	b.n	8022b14 <XMC_USBD_IRQHandler+0x114>
      }
      if (doepint.b.xfercompl)
      {
        if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
        {
          uint32_t bytes = (ep->xferLength - ep->xferCount) - doeptsiz.b.xfersize;
 8022c12:	fb0c 4006 	mla	r0, ip, r6, r4
 8022c16:	9b03      	ldr	r3, [sp, #12]
 8022c18:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 8022c1a:	6a81      	ldr	r1, [r0, #40]	; 0x28
 8022c1c:	f3c3 0312 	ubfx	r3, r3, #0, #19
 8022c20:	ebc2 0e01 	rsb	lr, r2, r1
 8022c24:	ebc3 030e 	rsb	r3, r3, lr
          ep->xferCount += bytes;
 8022c28:	eb02 0e03 	add.w	lr, r2, r3
          ep->xferBuffer += bytes;
 8022c2c:	6a42      	ldr	r2, [r0, #36]	; 0x24
      if (doepint.b.xfercompl)
      {
        if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
        {
          uint32_t bytes = (ep->xferLength - ep->xferCount) - doeptsiz.b.xfersize;
          ep->xferCount += bytes;
 8022c2e:	f8c0 e02c 	str.w	lr, [r0, #44]	; 0x2c
          ep->xferBuffer += bytes;
 8022c32:	4413      	add	r3, r2
 8022c34:	6243      	str	r3, [r0, #36]	; 0x24
				}
        if (ep->xferTotal == ep->xferLength)
 8022c36:	fb0c 4306 	mla	r3, ip, r6, r4
 8022c3a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8022c3c:	428a      	cmp	r2, r1
 8022c3e:	d18c      	bne.n	8022b5a <XMC_USBD_IRQHandler+0x15a>
 8022c40:	f8cd c004 	str.w	ip, [sp, #4]
        {
          ep->outBytesAvailable = ep->xferCount;
          ep->outInUse = 0U;
 8022c44:	685a      	ldr	r2, [r3, #4]
          ep->xferCount += bytes;
          ep->xferBuffer += bytes;
				}
        if (ep->xferTotal == ep->xferLength)
        {
          ep->outBytesAvailable = ep->xferCount;
 8022c46:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 8022c48:	6119      	str	r1, [r3, #16]
          ep->outInUse = 0U;
 8022c4a:	f022 0210 	bic.w	r2, r2, #16
 8022c4e:	605a      	str	r2, [r3, #4]
          xmc_device.EndpointEvent_cb(ep_num,XMC_USBD_EP_EVENT_OUT);
 8022c50:	4b26      	ldr	r3, [pc, #152]	; (8022cec <XMC_USBD_IRQHandler+0x2ec>)
 8022c52:	4628      	mov	r0, r5
 8022c54:	f8d3 3204 	ldr.w	r3, [r3, #516]	; 0x204
 8022c58:	2101      	movs	r1, #1
 8022c5a:	4798      	blx	r3
 8022c5c:	4b23      	ldr	r3, [pc, #140]	; (8022cec <XMC_USBD_IRQHandler+0x2ec>)
 8022c5e:	f8dd c004 	ldr.w	ip, [sp, #4]
 8022c62:	eb03 0989 	add.w	r9, r3, r9, lsl #2
 8022c66:	f8d9 2004 	ldr.w	r2, [r9, #4]
 8022c6a:	e7b1      	b.n	8022bd0 <XMC_USBD_IRQHandler+0x1d0>
  uint16_t temp1;
  uint16_t mask;
  uint8_t ep_num;
  uint32_t inepint;
	
  daint.d32 = xmc_device.device_register->daint;
 8022c6c:	f8d4 31a4 	ldr.w	r3, [r4, #420]	; 0x1a4
 8022c70:	699a      	ldr	r2, [r3, #24]
  
  diepmsk.d32 = xmc_device.device_register->diepmsk;
 8022c72:	691b      	ldr	r3, [r3, #16]
 8022c74:	9303      	str	r3, [sp, #12]
  
  dieptsiz.d32 = 0U;
  mask = daint.ep.in;
  ep_num = 0U;
  
  while ((uint16_t)mask >> ep_num)
 8022c76:	b297      	uxth	r7, r2
 8022c78:	2f00      	cmp	r7, #0
 8022c7a:	d061      	beq.n	8022d40 <XMC_USBD_IRQHandler+0x340>
 8022c7c:	2600      	movs	r6, #0
 8022c7e:	46b6      	mov	lr, r6
 8022c80:	463b      	mov	r3, r7
    if ((uint16_t)temp)
    {
      ep = &xmc_device.ep[ep_num];
			inepint = (uint32_t)xmc_device.endpoint_in_register[ep_num]->diepint;
      diepint.d32 = inepint &
      ((((uint32_t)((uint32_t)xmc_device.device_register->dtknqr4_fifoemptymsk >> ep->address_u.address_st.number) &
 8022c82:	f04f 0b34 	mov.w	fp, #52	; 0x34
 8022c86:	f8cd a010 	str.w	sl, [sp, #16]
 8022c8a:	46b9      	mov	r9, r7
  
  while ((uint16_t)mask >> ep_num)
  {
    temp1 = ((uint16_t)mask >> (uint16_t)ep_num);
    temp = (uint16_t)temp1 & (uint16_t)0x1U;
    if ((uint16_t)temp)
 8022c8c:	07db      	lsls	r3, r3, #31
 8022c8e:	d54f      	bpl.n	8022d30 <XMC_USBD_IRQHandler+0x330>
    {
      ep = &xmc_device.ep[ep_num];
			inepint = (uint32_t)xmc_device.endpoint_in_register[ep_num]->diepint;
 8022c90:	f10e 036a 	add.w	r3, lr, #106	; 0x6a
      diepint.d32 = inepint &
      ((((uint32_t)((uint32_t)xmc_device.device_register->dtknqr4_fifoemptymsk >> ep->address_u.address_st.number) &
 8022c94:	fb0b f00e 	mul.w	r0, fp, lr
    temp1 = ((uint16_t)mask >> (uint16_t)ep_num);
    temp = (uint16_t)temp1 & (uint16_t)0x1U;
    if ((uint16_t)temp)
    {
      ep = &xmc_device.ep[ep_num];
			inepint = (uint32_t)xmc_device.endpoint_in_register[ep_num]->diepint;
 8022c98:	9302      	str	r3, [sp, #8]
      diepint.d32 = inepint &
      ((((uint32_t)((uint32_t)xmc_device.device_register->dtknqr4_fifoemptymsk >> ep->address_u.address_st.number) &
 8022c9a:	f8d4 a1a4 	ldr.w	sl, [r4, #420]	; 0x1a4
    temp1 = ((uint16_t)mask >> (uint16_t)ep_num);
    temp = (uint16_t)temp1 & (uint16_t)0x1U;
    if ((uint16_t)temp)
    {
      ep = &xmc_device.ep[ep_num];
			inepint = (uint32_t)xmc_device.endpoint_in_register[ep_num]->diepint;
 8022c9e:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
      diepint.d32 = inepint &
      ((((uint32_t)((uint32_t)xmc_device.device_register->dtknqr4_fifoemptymsk >> ep->address_u.address_st.number) &
 8022ca2:	f814 8000 	ldrb.w	r8, [r4, r0]
    temp1 = ((uint16_t)mask >> (uint16_t)ep_num);
    temp = (uint16_t)temp1 & (uint16_t)0x1U;
    if ((uint16_t)temp)
    {
      ep = &xmc_device.ep[ep_num];
			inepint = (uint32_t)xmc_device.endpoint_in_register[ep_num]->diepint;
 8022ca6:	689d      	ldr	r5, [r3, #8]
      diepint.d32 = inepint &
      ((((uint32_t)((uint32_t)xmc_device.device_register->dtknqr4_fifoemptymsk >> ep->address_u.address_st.number) &
 8022ca8:	f8da 1034 	ldr.w	r1, [sl, #52]	; 0x34
                     0x1U) << 7U) | (uint32_t)diepmsk.d32);
      if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
 8022cac:	9a01      	ldr	r2, [sp, #4]
    {
      ep = &xmc_device.ep[ep_num];
			inepint = (uint32_t)xmc_device.endpoint_in_register[ep_num]->diepint;
      diepint.d32 = inepint &
      ((((uint32_t)((uint32_t)xmc_device.device_register->dtknqr4_fifoemptymsk >> ep->address_u.address_st.number) &
                     0x1U) << 7U) | (uint32_t)diepmsk.d32);
 8022cae:	9f03      	ldr	r7, [sp, #12]
      if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
 8022cb0:	7b52      	ldrb	r2, [r2, #13]
    if ((uint16_t)temp)
    {
      ep = &xmc_device.ep[ep_num];
			inepint = (uint32_t)xmc_device.endpoint_in_register[ep_num]->diepint;
      diepint.d32 = inepint &
      ((((uint32_t)((uint32_t)xmc_device.device_register->dtknqr4_fifoemptymsk >> ep->address_u.address_st.number) &
 8022cb2:	f008 0c0f 	and.w	ip, r8, #15
 8022cb6:	fa21 f10c 	lsr.w	r1, r1, ip
                     0x1U) << 7U) | (uint32_t)diepmsk.d32);
 8022cba:	01c9      	lsls	r1, r1, #7
 8022cbc:	b2c9      	uxtb	r1, r1
 8022cbe:	4339      	orrs	r1, r7
    if ((uint16_t)temp)
    {
      ep = &xmc_device.ep[ep_num];
			inepint = (uint32_t)xmc_device.endpoint_in_register[ep_num]->diepint;
      diepint.d32 = inepint &
      ((((uint32_t)((uint32_t)xmc_device.device_register->dtknqr4_fifoemptymsk >> ep->address_u.address_st.number) &
 8022cc0:	4420      	add	r0, r4
    temp = (uint16_t)temp1 & (uint16_t)0x1U;
    if ((uint16_t)temp)
    {
      ep = &xmc_device.ep[ep_num];
			inepint = (uint32_t)xmc_device.endpoint_in_register[ep_num]->diepint;
      diepint.d32 = inepint &
 8022cc2:	400d      	ands	r5, r1
      ((((uint32_t)((uint32_t)xmc_device.device_register->dtknqr4_fifoemptymsk >> ep->address_u.address_st.number) &
                     0x1U) << 7U) | (uint32_t)diepmsk.d32);
      if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
 8022cc4:	b9b2      	cbnz	r2, 8022cf4 <XMC_USBD_IRQHandler+0x2f4>
          bytes = XMC_USBD_lWriteFifo(ep);
          ep->xferCount += bytes;
          ep->xferBuffer += bytes;
        }
      }
      if (diepint.b.xfercompl)
 8022cc6:	07ef      	lsls	r7, r5, #31
      diepint.d32 = inepint &
      ((((uint32_t)((uint32_t)xmc_device.device_register->dtknqr4_fifoemptymsk >> ep->address_u.address_st.number) &
                     0x1U) << 7U) | (uint32_t)diepmsk.d32);
      if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
      {
        dieptsiz.d32 = xmc_device.endpoint_in_register[ep_num]->dieptsiz;
 8022cc8:	691a      	ldr	r2, [r3, #16]
          bytes = XMC_USBD_lWriteFifo(ep);
          ep->xferCount += bytes;
          ep->xferBuffer += bytes;
        }
      }
      if (diepint.b.xfercompl)
 8022cca:	d530      	bpl.n	8022d2e <XMC_USBD_IRQHandler+0x32e>
      {
        if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
        {
          /* update xfer values */
          if ((dieptsiz.b.pktcnt == 0U) && (dieptsiz.b.xfersize == 0U))
 8022ccc:	f022 4260 	bic.w	r2, r2, #3758096384	; 0xe0000000
 8022cd0:	2a00      	cmp	r2, #0
 8022cd2:	f000 8218 	beq.w	8023106 <XMC_USBD_IRQHandler+0x706>
 8022cd6:	6a81      	ldr	r1, [r0, #40]	; 0x28
            uint32_t Bytes = ep->xferLength - ep->xferCount;
            ep->xferCount += Bytes;
            ep->xferBuffer += Bytes;
          }
        }
        if (ep->xferTotal==ep->xferLength)
 8022cd8:	fb0b 420e 	mla	r2, fp, lr, r4
 8022cdc:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8022cde:	428b      	cmp	r3, r1
 8022ce0:	d133      	bne.n	8022d4a <XMC_USBD_IRQHandler+0x34a>
        {
          ep->inInUse = 0U;
 8022ce2:	6853      	ldr	r3, [r2, #4]
 8022ce4:	f023 0308 	bic.w	r3, r3, #8
 8022ce8:	6053      	str	r3, [r2, #4]
 8022cea:	e017      	b.n	8022d1c <XMC_USBD_IRQHandler+0x31c>
 8022cec:	1fff0078 	.word	0x1fff0078
 8022cf0:	1fff0074 	.word	0x1fff0074
                     0x1U) << 7U) | (uint32_t)diepmsk.d32);
      if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
      {
        dieptsiz.d32 = xmc_device.endpoint_in_register[ep_num]->dieptsiz;
      }
      if(obj->usbd_transfer_mode == XMC_USBD_USE_FIFO)
 8022cf4:	2a01      	cmp	r2, #1
 8022cf6:	d102      	bne.n	8022cfe <XMC_USBD_IRQHandler+0x2fe>
      {
        if (diepint.b.emptyintr)
 8022cf8:	0629      	lsls	r1, r5, #24
 8022cfa:	f100 822a 	bmi.w	8023152 <XMC_USBD_IRQHandler+0x752>
          bytes = XMC_USBD_lWriteFifo(ep);
          ep->xferCount += bytes;
          ep->xferBuffer += bytes;
        }
      }
      if (diepint.b.xfercompl)
 8022cfe:	07e9      	lsls	r1, r5, #31
 8022d00:	d515      	bpl.n	8022d2e <XMC_USBD_IRQHandler+0x32e>
            uint32_t Bytes = ep->xferLength - ep->xferCount;
            ep->xferCount += Bytes;
            ep->xferBuffer += Bytes;
          }
        }
        if (ep->xferTotal==ep->xferLength)
 8022d02:	fb0b 400e 	mla	r0, fp, lr, r4
 8022d06:	6b03      	ldr	r3, [r0, #48]	; 0x30
 8022d08:	6a81      	ldr	r1, [r0, #40]	; 0x28
 8022d0a:	428b      	cmp	r3, r1
 8022d0c:	d11d      	bne.n	8022d4a <XMC_USBD_IRQHandler+0x34a>
        {
          ep->inInUse = 0U;
 8022d0e:	6843      	ldr	r3, [r0, #4]
          if(obj->usbd_transfer_mode == XMC_USBD_USE_FIFO)
 8022d10:	2a01      	cmp	r2, #1
            ep->xferBuffer += Bytes;
          }
        }
        if (ep->xferTotal==ep->xferLength)
        {
          ep->inInUse = 0U;
 8022d12:	f023 0308 	bic.w	r3, r3, #8
 8022d16:	6043      	str	r3, [r0, #4]
          if(obj->usbd_transfer_mode == XMC_USBD_USE_FIFO)
 8022d18:	f000 8273 	beq.w	8023202 <XMC_USBD_IRQHandler+0x802>
          {
            /* mask fifo empty interrupt */
            xmc_device.device_register->dtknqr4_fifoemptymsk =
            (uint32_t)(xmc_device.device_register->dtknqr4_fifoemptymsk & ~(((uint32_t)1U << ep_num)));
          }
          xmc_device.EndpointEvent_cb(0x80U | ep_num,XMC_USBD_EP_EVENT_IN);
 8022d1c:	f8d4 3204 	ldr.w	r3, [r4, #516]	; 0x204
 8022d20:	f046 0080 	orr.w	r0, r6, #128	; 0x80
 8022d24:	2102      	movs	r1, #2
 8022d26:	4798      	blx	r3
 8022d28:	9b02      	ldr	r3, [sp, #8]
 8022d2a:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 **/
void XMC_USBD_ClearEventINEP(uint32_t event,const uint8_t ep_num)
{
  diepint_data_t clear;
  clear.d32 = event;
  xmc_device.endpoint_in_register[ep_num]->diepint = clear.d32;
 8022d2e:	609d      	str	r5, [r3, #8]

      }

      XMC_USBD_ClearEventINEP((uint32_t)diepint.d32,ep_num);
    }
    ep_num++;
 8022d30:	3601      	adds	r6, #1
 8022d32:	b2f6      	uxtb	r6, r6
  
  dieptsiz.d32 = 0U;
  mask = daint.ep.in;
  ep_num = 0U;
  
  while ((uint16_t)mask >> ep_num)
 8022d34:	fa59 f306 	asrs.w	r3, r9, r6
 8022d38:	46b6      	mov	lr, r6
 8022d3a:	d1a7      	bne.n	8022c8c <XMC_USBD_IRQHandler+0x28c>
 8022d3c:	f8dd a010 	ldr.w	sl, [sp, #16]
	  clear.b.outepintr = 1U;
	  break;
		default:
		break;
	}
	xmc_device.global_register->gintsts = clear.d32;
 8022d40:	f8d4 31a0 	ldr.w	r3, [r4, #416]	; 0x1a0
 8022d44:	2200      	movs	r2, #0
 8022d46:	615a      	str	r2, [r3, #20]
 8022d48:	e68b      	b.n	8022a62 <XMC_USBD_IRQHandler+0x62>
{
  deptsiz_data_t size;
  depctl_data_t ctl;
	
  size.d32 = 0U;  
  ctl.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl;
 8022d4a:	fb0b f20e 	mul.w	r2, fp, lr
 8022d4e:	18a0      	adds	r0, r4, r2
 8022d50:	5ca2      	ldrb	r2, [r4, r2]

  if ((ep->xferTotal - ep->xferLength)  < ep->maxTransferSize)
 8022d52:	6880      	ldr	r0, [r0, #8]
 8022d54:	ebc1 0803 	rsb	r8, r1, r3
 8022d58:	f3c0 0c12 	ubfx	ip, r0, #0, #19
{
  deptsiz_data_t size;
  depctl_data_t ctl;
	
  size.d32 = 0U;  
  ctl.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl;
 8022d5c:	f002 020f 	and.w	r2, r2, #15

  if ((ep->xferTotal - ep->xferLength)  < ep->maxTransferSize)
 8022d60:	45e0      	cmp	r8, ip
{
  deptsiz_data_t size;
  depctl_data_t ctl;
	
  size.d32 = 0U;  
  ctl.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl;
 8022d62:	9206      	str	r2, [sp, #24]
 8022d64:	f102 026a 	add.w	r2, r2, #106	; 0x6a
  {
    ep->xferLength = ep->xferTotal;
  }
  else
  {
    ep->xferLength += ep->maxTransferSize;
 8022d68:	bf28      	it	cs
 8022d6a:	eb01 030c 	addcs.w	r3, r1, ip
 8022d6e:	fb0b fc0e 	mul.w	ip, fp, lr
{
  deptsiz_data_t size;
  depctl_data_t ctl;
	
  size.d32 = 0U;  
  ctl.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl;
 8022d72:	f854 2022 	ldr.w	r2, [r4, r2, lsl #2]
 8022d76:	9205      	str	r2, [sp, #20]
 8022d78:	eb04 010c 	add.w	r1, r4, ip
 8022d7c:	6812      	ldr	r2, [r2, #0]
 8022d7e:	628b      	str	r3, [r1, #40]	; 0x28
static void XMC_USBD_lStartWriteXfer(XMC_USBD_EP_t *const ep) 
{
  deptsiz_data_t size;
  depctl_data_t ctl;
	
  size.d32 = 0U;  
 8022d80:	2000      	movs	r0, #0
 8022d82:	f101 0828 	add.w	r8, r1, #40	; 0x28
  }
  else
  {
    ep->xferLength += ep->maxTransferSize;
  }
  if (ep->xferLength == 0U)
 8022d86:	2b00      	cmp	r3, #0
 8022d88:	f000 81dd 	beq.w	8023146 <XMC_USBD_IRQHandler+0x746>
    size.b.xfersize = 0U;
    size.b.pktcnt = 1U;
  }
  else
  {
    if (ep->address_u.address_st.number == 0U)
 8022d8c:	f814 c00c 	ldrb.w	ip, [r4, ip]
 8022d90:	f01c 0f0f 	tst.w	ip, #15
 8022d94:	f000 81cf 	beq.w	8023136 <XMC_USBD_IRQHandler+0x736>
      size.b.xfersize = (uint32_t)(ep->xferLength - ep->xferCount);
    }
    else
    {
      size.b.xfersize =(uint32_t)(ep->xferLength - ep->xferCount);
      size.b.pktcnt = (uint16_t)(((uint16_t)(ep->xferLength - ep->xferCount) + (uint16_t)((uint16_t)ep->maxPacketSize - 1U))/
 8022d98:	6849      	ldr	r1, [r1, #4]
      /* ep->maxXferSize equals maxPacketSize */
      size.b.xfersize = (uint32_t)(ep->xferLength - ep->xferCount);
    }
    else
    {
      size.b.xfersize =(uint32_t)(ep->xferLength - ep->xferCount);
 8022d9a:	f8d8 7004 	ldr.w	r7, [r8, #4]
      size.b.pktcnt = (uint16_t)(((uint16_t)(ep->xferLength - ep->xferCount) + (uint16_t)((uint16_t)ep->maxPacketSize - 1U))/
 8022d9e:	f3c1 2cc6 	ubfx	ip, r1, #11, #7
 8022da2:	f10c 38ff 	add.w	r8, ip, #4294967295
 8022da6:	1bd9      	subs	r1, r3, r7
      /* ep->maxXferSize equals maxPacketSize */
      size.b.xfersize = (uint32_t)(ep->xferLength - ep->xferCount);
    }
    else
    {
      size.b.xfersize =(uint32_t)(ep->xferLength - ep->xferCount);
 8022da8:	460b      	mov	r3, r1
      size.b.pktcnt = (uint16_t)(((uint16_t)(ep->xferLength - ep->xferCount) + (uint16_t)((uint16_t)ep->maxPacketSize - 1U))/
 8022daa:	fa1f f888 	uxth.w	r8, r8
 8022dae:	fa18 f181 	uxtah	r1, r8, r1
      /* ep->maxXferSize equals maxPacketSize */
      size.b.xfersize = (uint32_t)(ep->xferLength - ep->xferCount);
    }
    else
    {
      size.b.xfersize =(uint32_t)(ep->xferLength - ep->xferCount);
 8022db2:	f3c3 0312 	ubfx	r3, r3, #0, #19
      size.b.pktcnt = (uint16_t)(((uint16_t)(ep->xferLength - ep->xferCount) + (uint16_t)((uint16_t)ep->maxPacketSize - 1U))/
 8022db6:	fb91 fcfc 	sdiv	ip, r1, ip
 8022dba:	f3cc 0c09 	ubfx	ip, ip, #0, #10
    		 ep->maxPacketSize);
    }
    if(usbd_init->usbd_transfer_mode == XMC_USBD_USE_DMA)
 8022dbe:	49c2      	ldr	r1, [pc, #776]	; (80230c8 <XMC_USBD_IRQHandler+0x6c8>)
 8022dc0:	6809      	ldr	r1, [r1, #0]
 8022dc2:	7b49      	ldrb	r1, [r1, #13]
 8022dc4:	f363 0012 	bfi	r0, r3, #0, #19
 8022dc8:	f36c 40dc 	bfi	r0, ip, #19, #10
 8022dcc:	2900      	cmp	r1, #0
 8022dce:	f040 820d 	bne.w	80231ec <XMC_USBD_IRQHandler+0x7ec>
    {
      /* Program dma*/
      xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepdma = (uint32_t)ep->xferBuffer;
 8022dd2:	fb0b 430e 	mla	r3, fp, lr, r4
 8022dd6:	9905      	ldr	r1, [sp, #20]
 8022dd8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8022dda:	614b      	str	r3, [r1, #20]
			xmc_device.device_register->dtknqr4_fifoemptymsk |= (uint32_t)((uint32_t)1U << (uint8_t)ep->address_u.address_st.number);
    }
  }

  /* Program size of transfer and enable endpoint */
  xmc_device.endpoint_in_register[ep->address_u.address_st.number]->dieptsiz = size.d32;
 8022ddc:	fb0b fe0e 	mul.w	lr, fp, lr
 8022de0:	9b02      	ldr	r3, [sp, #8]
 8022de2:	f814 100e 	ldrb.w	r1, [r4, lr]
 8022de6:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 8022dea:	f001 010f 	and.w	r1, r1, #15
 8022dee:	316a      	adds	r1, #106	; 0x6a
  ctl.b.epena = 1U;
  ctl.b.cnak = 1U;
 8022df0:	f042 4204 	orr.w	r2, r2, #2214592512	; 0x84000000
			xmc_device.device_register->dtknqr4_fifoemptymsk |= (uint32_t)((uint32_t)1U << (uint8_t)ep->address_u.address_st.number);
    }
  }

  /* Program size of transfer and enable endpoint */
  xmc_device.endpoint_in_register[ep->address_u.address_st.number]->dieptsiz = size.d32;
 8022df4:	f854 1021 	ldr.w	r1, [r4, r1, lsl #2]
 8022df8:	6108      	str	r0, [r1, #16]
  ctl.b.epena = 1U;
  ctl.b.cnak = 1U;
  xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = ctl.d32;
 8022dfa:	600a      	str	r2, [r1, #0]
 **/
void XMC_USBD_ClearEventINEP(uint32_t event,const uint8_t ep_num)
{
  diepint_data_t clear;
  clear.d32 = event;
  xmc_device.endpoint_in_register[ep_num]->diepint = clear.d32;
 8022dfc:	609d      	str	r5, [r3, #8]
 8022dfe:	e797      	b.n	8022d30 <XMC_USBD_IRQHandler+0x330>
  /* Normaly we need to check dctl
   * We are always fullspeed, so max it up. */
  depctl_data_t epctl;
  gusbcfg_data_t gusbcfg;
	
  epctl.d32=xmc_device.endpoint_in_register[0U]->diepctl;
 8022e00:	f8d4 11a8 	ldr.w	r1, [r4, #424]	; 0x1a8
  epctl.b.mps = 0x00U; /* 64 Byte, this is also automatically set for out ep */
  xmc_device.endpoint_in_register[0U]->diepctl = epctl.d32;

  /* update device connected flag */
  xmc_device.IsConnected = 1U;
 8022e04:	f894 21fe 	ldrb.w	r2, [r4, #510]	; 0x1fe
  /* Normaly we need to check dctl
   * We are always fullspeed, so max it up. */
  depctl_data_t epctl;
  gusbcfg_data_t gusbcfg;
	
  epctl.d32=xmc_device.endpoint_in_register[0U]->diepctl;
 8022e08:	680b      	ldr	r3, [r1, #0]

  /* update device connected flag */
  xmc_device.IsConnected = 1U;
  xmc_device.IsPowered = 1U;

  xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_CONNECT);
 8022e0a:	f8d4 5200 	ldr.w	r5, [r4, #512]	; 0x200
   * We are always fullspeed, so max it up. */
  depctl_data_t epctl;
  gusbcfg_data_t gusbcfg;
	
  epctl.d32=xmc_device.endpoint_in_register[0U]->diepctl;
  epctl.b.mps = 0x00U; /* 64 Byte, this is also automatically set for out ep */
 8022e0e:	f36f 030a 	bfc	r3, #0, #11
  xmc_device.endpoint_in_register[0U]->diepctl = epctl.d32;

  /* update device connected flag */
  xmc_device.IsConnected = 1U;
  xmc_device.IsPowered = 1U;
 8022e12:	f042 0205 	orr.w	r2, r2, #5
  depctl_data_t epctl;
  gusbcfg_data_t gusbcfg;
	
  epctl.d32=xmc_device.endpoint_in_register[0U]->diepctl;
  epctl.b.mps = 0x00U; /* 64 Byte, this is also automatically set for out ep */
  xmc_device.endpoint_in_register[0U]->diepctl = epctl.d32;
 8022e16:	600b      	str	r3, [r1, #0]

  /* update device connected flag */
  xmc_device.IsConnected = 1U;
  xmc_device.IsPowered = 1U;

  xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_CONNECT);
 8022e18:	2002      	movs	r0, #2
  epctl.b.mps = 0x00U; /* 64 Byte, this is also automatically set for out ep */
  xmc_device.endpoint_in_register[0U]->diepctl = epctl.d32;

  /* update device connected flag */
  xmc_device.IsConnected = 1U;
  xmc_device.IsPowered = 1U;
 8022e1a:	f884 21fe 	strb.w	r2, [r4, #510]	; 0x1fe

  xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_CONNECT);
 8022e1e:	47a8      	blx	r5

  /* Set Trim */  
  gusbcfg.d32 = xmc_device.global_register->gusbcfg;
 8022e20:	f8d4 31a0 	ldr.w	r3, [r4, #416]	; 0x1a0
 8022e24:	68da      	ldr	r2, [r3, #12]
  gusbcfg.b.usbtrdtim = 9U; /* default value for LS/FS */
 8022e26:	2109      	movs	r1, #9
 8022e28:	f361 228d 	bfi	r2, r1, #10, #4
	  break;
    case (XMC_USBD_EVENT_EARLYSUSPEND):
	  clear.b.erlysuspend = 1U;
	  break;
    case (XMC_USBD_EVENT_ENUMDONE):
	  clear.b.enumdone = 1U;
 8022e2c:	f44f 5100 	mov.w	r1, #8192	; 0x2000
  xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_CONNECT);

  /* Set Trim */  
  gusbcfg.d32 = xmc_device.global_register->gusbcfg;
  gusbcfg.b.usbtrdtim = 9U; /* default value for LS/FS */
  xmc_device.global_register->gusbcfg = gusbcfg.d32;
 8022e30:	60da      	str	r2, [r3, #12]
	  clear.b.outepintr = 1U;
	  break;
		default:
		break;
	}
	xmc_device.global_register->gintsts = clear.d32;
 8022e32:	6159      	str	r1, [r3, #20]
 8022e34:	e611      	b.n	8022a5a <XMC_USBD_IRQHandler+0x5a>
  fifosize_data_t gnptxfsiz;
  daint_data_t daint;
  dcfg_data_t dcfg;
	
  /* Clear the Remote Wakeup Signaling */
  dctl.d32 = xmc_device.device_register->dctl;
 8022e36:	f8d4 11a4 	ldr.w	r1, [r4, #420]	; 0x1a4
  xmc_device.device_register->dctl = dctl.d32;

  /* enable naks for all eps */
  for (i = 0U;i < (uint8_t)XMC_USBD_NUM_EPS;i++)
  {
    epctl.d32 = xmc_device.endpoint_out_register[i]->doepctl;
 8022e3a:	f8d4 91c4 	ldr.w	r9, [r4, #452]	; 0x1c4
  fifosize_data_t gnptxfsiz;
  daint_data_t daint;
  dcfg_data_t dcfg;
	
  /* Clear the Remote Wakeup Signaling */
  dctl.d32 = xmc_device.device_register->dctl;
 8022e3e:	684a      	ldr	r2, [r1, #4]
  xmc_device.device_register->dctl = dctl.d32;

  /* enable naks for all eps */
  for (i = 0U;i < (uint8_t)XMC_USBD_NUM_EPS;i++)
  {
    epctl.d32 = xmc_device.endpoint_out_register[i]->doepctl;
 8022e40:	f8d4 71d4 	ldr.w	r7, [r4, #468]	; 0x1d4
 8022e44:	f8d4 61d8 	ldr.w	r6, [r4, #472]	; 0x1d8
 8022e48:	f8d4 01dc 	ldr.w	r0, [r4, #476]	; 0x1dc
  daint_data_t daint;
  dcfg_data_t dcfg;
	
  /* Clear the Remote Wakeup Signaling */
  dctl.d32 = xmc_device.device_register->dctl;
  dctl.b.rmtwkupsig = 1U;
 8022e4c:	f042 0201 	orr.w	r2, r2, #1
  xmc_device.device_register->dctl = dctl.d32;

  /* enable naks for all eps */
  for (i = 0U;i < (uint8_t)XMC_USBD_NUM_EPS;i++)
  {
    epctl.d32 = xmc_device.endpoint_out_register[i]->doepctl;
 8022e50:	f504 78e4 	add.w	r8, r4, #456	; 0x1c8
 8022e54:	e898 5100 	ldmia.w	r8, {r8, ip, lr}
  dcfg_data_t dcfg;
	
  /* Clear the Remote Wakeup Signaling */
  dctl.d32 = xmc_device.device_register->dctl;
  dctl.b.rmtwkupsig = 1U;
  xmc_device.device_register->dctl = dctl.d32;
 8022e58:	604a      	str	r2, [r1, #4]

  /* enable naks for all eps */
  for (i = 0U;i < (uint8_t)XMC_USBD_NUM_EPS;i++)
  {
    epctl.d32 = xmc_device.endpoint_out_register[i]->doepctl;
 8022e5a:	f8d9 2000 	ldr.w	r2, [r9]
		epctl.b.snak = 1U;
 8022e5e:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
		epctl.b.stall = 0U;
 8022e62:	f36f 5255 	bfc	r2, #21, #1
		xmc_device.endpoint_out_register[i]->doepctl = epctl.d32;
 8022e66:	f8c9 2000 	str.w	r2, [r9]
  xmc_device.device_register->dctl = dctl.d32;

  /* enable naks for all eps */
  for (i = 0U;i < (uint8_t)XMC_USBD_NUM_EPS;i++)
  {
    epctl.d32 = xmc_device.endpoint_out_register[i]->doepctl;
 8022e6a:	f8d8 2000 	ldr.w	r2, [r8]
  gnptxfsiz.b.startaddr = 64U;
  xmc_device.global_register->gnptxfsiz = gnptxfsiz.d32;
  /* calculate the size for the rest */
  for (i = 1U;i < (uint8_t)XMC_USBD_NUM_TX_FIFOS;i++)
  {
    xmc_device.global_register->dtxfsiz[i- 1U] = (uint32_t)(((256U + (i*(64U)))/4U) | ((uint32_t)16U << 16U));
 8022e6e:	f8df 9268 	ldr.w	r9, [pc, #616]	; 80230d8 <XMC_USBD_IRQHandler+0x6d8>

  /* enable naks for all eps */
  for (i = 0U;i < (uint8_t)XMC_USBD_NUM_EPS;i++)
  {
    epctl.d32 = xmc_device.endpoint_out_register[i]->doepctl;
		epctl.b.snak = 1U;
 8022e72:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
		epctl.b.stall = 0U;
 8022e76:	f36f 5255 	bfc	r2, #21, #1
		xmc_device.endpoint_out_register[i]->doepctl = epctl.d32;
 8022e7a:	f8c8 2000 	str.w	r2, [r8]
  xmc_device.device_register->dctl = dctl.d32;

  /* enable naks for all eps */
  for (i = 0U;i < (uint8_t)XMC_USBD_NUM_EPS;i++)
  {
    epctl.d32 = xmc_device.endpoint_out_register[i]->doepctl;
 8022e7e:	f8dc 2000 	ldr.w	r2, [ip]
  gnptxfsiz.b.startaddr = 64U;
  xmc_device.global_register->gnptxfsiz = gnptxfsiz.d32;
  /* calculate the size for the rest */
  for (i = 1U;i < (uint8_t)XMC_USBD_NUM_TX_FIFOS;i++)
  {
    xmc_device.global_register->dtxfsiz[i- 1U] = (uint32_t)(((256U + (i*(64U)))/4U) | ((uint32_t)16U << 16U));
 8022e82:	f8df 8258 	ldr.w	r8, [pc, #600]	; 80230dc <XMC_USBD_IRQHandler+0x6dc>

  /* enable naks for all eps */
  for (i = 0U;i < (uint8_t)XMC_USBD_NUM_EPS;i++)
  {
    epctl.d32 = xmc_device.endpoint_out_register[i]->doepctl;
		epctl.b.snak = 1U;
 8022e86:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
		epctl.b.stall = 0U;
 8022e8a:	f36f 5255 	bfc	r2, #21, #1
		xmc_device.endpoint_out_register[i]->doepctl = epctl.d32;
 8022e8e:	f8cc 2000 	str.w	r2, [ip]
  xmc_device.device_register->dctl = dctl.d32;

  /* enable naks for all eps */
  for (i = 0U;i < (uint8_t)XMC_USBD_NUM_EPS;i++)
  {
    epctl.d32 = xmc_device.endpoint_out_register[i]->doepctl;
 8022e92:	f8de 2000 	ldr.w	r2, [lr]
  gnptxfsiz.b.startaddr = 64U;
  xmc_device.global_register->gnptxfsiz = gnptxfsiz.d32;
  /* calculate the size for the rest */
  for (i = 1U;i < (uint8_t)XMC_USBD_NUM_TX_FIFOS;i++)
  {
    xmc_device.global_register->dtxfsiz[i- 1U] = (uint32_t)(((256U + (i*(64U)))/4U) | ((uint32_t)16U << 16U));
 8022e96:	f8df c248 	ldr.w	ip, [pc, #584]	; 80230e0 <XMC_USBD_IRQHandler+0x6e0>

  /* enable naks for all eps */
  for (i = 0U;i < (uint8_t)XMC_USBD_NUM_EPS;i++)
  {
    epctl.d32 = xmc_device.endpoint_out_register[i]->doepctl;
		epctl.b.snak = 1U;
 8022e9a:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
		epctl.b.stall = 0U;
 8022e9e:	f36f 5255 	bfc	r2, #21, #1
		xmc_device.endpoint_out_register[i]->doepctl = epctl.d32;
 8022ea2:	f8ce 2000 	str.w	r2, [lr]
  xmc_device.device_register->dctl = dctl.d32;

  /* enable naks for all eps */
  for (i = 0U;i < (uint8_t)XMC_USBD_NUM_EPS;i++)
  {
    epctl.d32 = xmc_device.endpoint_out_register[i]->doepctl;
 8022ea6:	683a      	ldr	r2, [r7, #0]
  gnptxfsiz.b.startaddr = 64U;
  xmc_device.global_register->gnptxfsiz = gnptxfsiz.d32;
  /* calculate the size for the rest */
  for (i = 1U;i < (uint8_t)XMC_USBD_NUM_TX_FIFOS;i++)
  {
    xmc_device.global_register->dtxfsiz[i- 1U] = (uint32_t)(((256U + (i*(64U)))/4U) | ((uint32_t)16U << 16U));
 8022ea8:	f8df e238 	ldr.w	lr, [pc, #568]	; 80230e4 <XMC_USBD_IRQHandler+0x6e4>

  /* enable naks for all eps */
  for (i = 0U;i < (uint8_t)XMC_USBD_NUM_EPS;i++)
  {
    epctl.d32 = xmc_device.endpoint_out_register[i]->doepctl;
		epctl.b.snak = 1U;
 8022eac:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
		epctl.b.stall = 0U;
 8022eb0:	f36f 5255 	bfc	r2, #21, #1
		xmc_device.endpoint_out_register[i]->doepctl = epctl.d32;
 8022eb4:	603a      	str	r2, [r7, #0]
  xmc_device.device_register->dctl = dctl.d32;

  /* enable naks for all eps */
  for (i = 0U;i < (uint8_t)XMC_USBD_NUM_EPS;i++)
  {
    epctl.d32 = xmc_device.endpoint_out_register[i]->doepctl;
 8022eb6:	6832      	ldr	r2, [r6, #0]
  gnptxfsiz.b.startaddr = 64U;
  xmc_device.global_register->gnptxfsiz = gnptxfsiz.d32;
  /* calculate the size for the rest */
  for (i = 1U;i < (uint8_t)XMC_USBD_NUM_TX_FIFOS;i++)
  {
    xmc_device.global_register->dtxfsiz[i- 1U] = (uint32_t)(((256U + (i*(64U)))/4U) | ((uint32_t)16U << 16U));
 8022eb8:	4f84      	ldr	r7, [pc, #528]	; (80230cc <XMC_USBD_IRQHandler+0x6cc>)

  /* enable naks for all eps */
  for (i = 0U;i < (uint8_t)XMC_USBD_NUM_EPS;i++)
  {
    epctl.d32 = xmc_device.endpoint_out_register[i]->doepctl;
		epctl.b.snak = 1U;
 8022eba:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
		epctl.b.stall = 0U;
 8022ebe:	f36f 5255 	bfc	r2, #21, #1
		xmc_device.endpoint_out_register[i]->doepctl = epctl.d32;
 8022ec2:	6032      	str	r2, [r6, #0]
  xmc_device.device_register->dctl = dctl.d32;

  /* enable naks for all eps */
  for (i = 0U;i < (uint8_t)XMC_USBD_NUM_EPS;i++)
  {
    epctl.d32 = xmc_device.endpoint_out_register[i]->doepctl;
 8022ec4:	6802      	ldr	r2, [r0, #0]
  gnptxfsiz.b.startaddr = 64U;
  xmc_device.global_register->gnptxfsiz = gnptxfsiz.d32;
  /* calculate the size for the rest */
  for (i = 1U;i < (uint8_t)XMC_USBD_NUM_TX_FIFOS;i++)
  {
    xmc_device.global_register->dtxfsiz[i- 1U] = (uint32_t)(((256U + (i*(64U)))/4U) | ((uint32_t)16U << 16U));
 8022ec6:	4e82      	ldr	r6, [pc, #520]	; (80230d0 <XMC_USBD_IRQHandler+0x6d0>)

  /* enable naks for all eps */
  for (i = 0U;i < (uint8_t)XMC_USBD_NUM_EPS;i++)
  {
    epctl.d32 = xmc_device.endpoint_out_register[i]->doepctl;
		epctl.b.snak = 1U;
 8022ec8:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
		epctl.b.stall = 0U;
 8022ecc:	f36f 5255 	bfc	r2, #21, #1
		xmc_device.endpoint_out_register[i]->doepctl = epctl.d32;
 8022ed0:	6002      	str	r2, [r0, #0]
  }

  /* Configure fifos */
  /* Calculate the size of the rx fifo */
  xmc_device.global_register->grxfsiz = 64U;
 8022ed2:	2040      	movs	r0, #64	; 0x40
  /* Calculate the size of the tx fifo for ep 0 */  
  gnptxfsiz.d32 = 0U;
  gnptxfsiz.b.depth = 16U;
 8022ed4:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
		xmc_device.endpoint_out_register[i]->doepctl = epctl.d32;
  }

  /* Configure fifos */
  /* Calculate the size of the rx fifo */
  xmc_device.global_register->grxfsiz = 64U;
 8022ed8:	6258      	str	r0, [r3, #36]	; 0x24
  /* Calculate the size of the tx fifo for ep 0 */  
  gnptxfsiz.d32 = 0U;
  gnptxfsiz.b.depth = 16U;
  gnptxfsiz.b.startaddr = 64U;
 8022eda:	f360 020f 	bfi	r2, r0, #0, #16
 */
static void XMC_USBD_lFlushTXFifo(const uint8_t fifo_num) 
{
  volatile grstctl_t data;  
  uint32_t count;
  data.d32 = 0U;
 8022ede:	2000      	movs	r0, #0
  xmc_device.global_register->grxfsiz = 64U;
  /* Calculate the size of the tx fifo for ep 0 */  
  gnptxfsiz.d32 = 0U;
  gnptxfsiz.b.depth = 16U;
  gnptxfsiz.b.startaddr = 64U;
  xmc_device.global_register->gnptxfsiz = gnptxfsiz.d32;
 8022ee0:	629a      	str	r2, [r3, #40]	; 0x28
  /* calculate the size for the rest */
  for (i = 1U;i < (uint8_t)XMC_USBD_NUM_TX_FIFOS;i++)
  {
    xmc_device.global_register->dtxfsiz[i- 1U] = (uint32_t)(((256U + (i*(64U)))/4U) | ((uint32_t)16U << 16U));
 8022ee2:	f8c3 9104 	str.w	r9, [r3, #260]	; 0x104
 8022ee6:	f8c3 8108 	str.w	r8, [r3, #264]	; 0x108
 8022eea:	f8c3 c10c 	str.w	ip, [r3, #268]	; 0x10c
 8022eee:	f8c3 e110 	str.w	lr, [r3, #272]	; 0x110
 8022ef2:	f8c3 7114 	str.w	r7, [r3, #276]	; 0x114
 8022ef6:	f8c3 6118 	str.w	r6, [r3, #280]	; 0x118
 */
static void XMC_USBD_lFlushTXFifo(const uint8_t fifo_num) 
{
  volatile grstctl_t data;  
  uint32_t count;
  data.d32 = 0U;
 8022efa:	900d      	str	r0, [sp, #52]	; 0x34
  /*flush fifo */
  data.b.txfflsh = 1U;
 8022efc:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8022efe:	f042 0220 	orr.w	r2, r2, #32
 8022f02:	920d      	str	r2, [sp, #52]	; 0x34
  data.b.txfnum = fifo_num;
 8022f04:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8022f06:	f422 62f8 	bic.w	r2, r2, #1984	; 0x7c0
 8022f0a:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8022f0e:	920d      	str	r2, [sp, #52]	; 0x34
  xmc_device.global_register->grstctl = data.d32;
 8022f10:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8022f12:	611a      	str	r2, [r3, #16]
  for (count = 0U;count < 1000U; count++){}
  do
  {
   data.d32 = xmc_device.global_register->grstctl;
 8022f14:	691a      	ldr	r2, [r3, #16]
 8022f16:	920d      	str	r2, [sp, #52]	; 0x34
  } while (data.b.txfflsh);
 8022f18:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8022f1a:	f3c2 1240 	ubfx	r2, r2, #5, #1
 8022f1e:	2a00      	cmp	r2, #0
 8022f20:	d1f8      	bne.n	8022f14 <XMC_USBD_IRQHandler+0x514>
 */
static void XMC_USBD_lFlushTXFifo(const uint8_t fifo_num) 
{
  volatile grstctl_t data;  
  uint32_t count;
  data.d32 = 0U;
 8022f22:	920c      	str	r2, [sp, #48]	; 0x30
  /*flush fifo */
  data.b.txfflsh = 1U;
 8022f24:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8022f26:	f042 0220 	orr.w	r2, r2, #32
 8022f2a:	920c      	str	r2, [sp, #48]	; 0x30
  data.b.txfnum = fifo_num;
 8022f2c:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8022f2e:	f422 62f8 	bic.w	r2, r2, #1984	; 0x7c0
 8022f32:	920c      	str	r2, [sp, #48]	; 0x30
  xmc_device.global_register->grstctl = data.d32;
 8022f34:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8022f36:	611a      	str	r2, [r3, #16]
  for (count = 0U;count < 1000U; count++){}
  do
  {
   data.d32 = xmc_device.global_register->grstctl;
 8022f38:	691a      	ldr	r2, [r3, #16]
 8022f3a:	920c      	str	r2, [sp, #48]	; 0x30
  } while (data.b.txfflsh);
 8022f3c:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8022f3e:	f3c2 1240 	ubfx	r2, r2, #5, #1
 8022f42:	2a00      	cmp	r2, #0
 8022f44:	d1f8      	bne.n	8022f38 <XMC_USBD_IRQHandler+0x538>
static void XMC_USBD_lFlushRXFifo(void) 
{
  volatile grstctl_t data;  
  uint32_t count;
	
	data.d32 = 0U;
 8022f46:	920b      	str	r2, [sp, #44]	; 0x2c
  data.b.rxfflsh = 1U;
 8022f48:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8022f4a:	f042 0210 	orr.w	r2, r2, #16
 8022f4e:	920b      	str	r2, [sp, #44]	; 0x2c
  /* flush FIFO */
  xmc_device.global_register->grstctl = data.d32;
 8022f50:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8022f52:	611a      	str	r2, [r3, #16]
  do
  {
    for (count = 0U; count < 1000U; count++){}
    data.d32 = xmc_device.global_register->grstctl;
 8022f54:	691a      	ldr	r2, [r3, #16]
 8022f56:	920b      	str	r2, [sp, #44]	; 0x2c
  } while (data.b.rxfflsh);
 8022f58:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8022f5a:	f3c2 1200 	ubfx	r2, r2, #4, #1
 8022f5e:	2a00      	cmp	r2, #0
 8022f60:	d1f8      	bne.n	8022f54 <XMC_USBD_IRQHandler+0x554>
  XMC_USBD_lFlushRXFifo();
  /* Flush learning queue not needed due to fifo config */
  /* enable ep0 interrupts */  
  daint.d32 = 0U;
  daint.b.inep0 = 1U;
  daint.b.outep0 = 1U;
 8022f62:	f04f 1301 	mov.w	r3, #65537	; 0x10001
  xmc_device.device_register->daintmsk = daint.d32;
 8022f66:	61cb      	str	r3, [r1, #28]
 **/
void XMC_USBD_EnableEventOUTEP(uint32_t event)
{
	doepint_data_t doepint;
	doepint.d32 = event;
	xmc_device.device_register->doepmsk |= doepint.d32;
 8022f68:	694b      	ldr	r3, [r1, #20]
  /* Clear device Address */  
  dcfg.d32 = xmc_device.device_register->dcfg;
  dcfg.b.devaddr = 0U;
  xmc_device.device_register->dcfg = dcfg.d32;

  if(obj->usbd_transfer_mode == XMC_USBD_USE_FIFO)
 8022f6a:	9801      	ldr	r0, [sp, #4]
 **/
void XMC_USBD_EnableEventOUTEP(uint32_t event)
{
	doepint_data_t doepint;
	doepint.d32 = event;
	xmc_device.device_register->doepmsk |= doepint.d32;
 8022f6c:	f043 030f 	orr.w	r3, r3, #15
  /* Clear device Address */  
  dcfg.d32 = xmc_device.device_register->dcfg;
  dcfg.b.devaddr = 0U;
  xmc_device.device_register->dcfg = dcfg.d32;

  if(obj->usbd_transfer_mode == XMC_USBD_USE_FIFO)
 8022f70:	7b40      	ldrb	r0, [r0, #13]
 **/
void XMC_USBD_EnableEventOUTEP(uint32_t event)
{
	doepint_data_t doepint;
	doepint.d32 = event;
	xmc_device.device_register->doepmsk |= doepint.d32;
 8022f72:	614b      	str	r3, [r1, #20]
 **/
void XMC_USBD_EnableEventINEP(uint32_t event)
{
	diepint_data_t diepint;
	diepint.d32 = event;
	xmc_device.device_register->diepmsk |= diepint.d32;
 8022f74:	690b      	ldr	r3, [r1, #16]
 8022f76:	f043 030f 	orr.w	r3, r3, #15
 8022f7a:	610b      	str	r3, [r1, #16]
  XMC_USBD_EnableEventINEP(((uint32_t)XMC_USBD_EVENT_IN_EP_TX_COMPLET | (uint32_t)XMC_USBD_EVENT_IN_EP_DISABLED |
		  (uint32_t)XMC_USBD_EVENT_IN_EP_AHB_ERROR | (uint32_t)XMC_USBD_EVENT_IN_EP_TIMEOUT));


  /* Clear device Address */  
  dcfg.d32 = xmc_device.device_register->dcfg;
 8022f7c:	680b      	ldr	r3, [r1, #0]
  dcfg.b.devaddr = 0U;
  xmc_device.device_register->dcfg = dcfg.d32;

  if(obj->usbd_transfer_mode == XMC_USBD_USE_FIFO)
 8022f7e:	2801      	cmp	r0, #1
		  (uint32_t)XMC_USBD_EVENT_IN_EP_AHB_ERROR | (uint32_t)XMC_USBD_EVENT_IN_EP_TIMEOUT));


  /* Clear device Address */  
  dcfg.d32 = xmc_device.device_register->dcfg;
  dcfg.b.devaddr = 0U;
 8022f80:	f362 130a 	bfi	r3, r2, #4, #7
  xmc_device.device_register->dcfg = dcfg.d32;
 8022f84:	600b      	str	r3, [r1, #0]

  if(obj->usbd_transfer_mode == XMC_USBD_USE_FIFO)
  {
    /* Clear Empty interrupt */
    xmc_device.device_register->dtknqr4_fifoemptymsk = 0U;
 8022f86:	bf08      	it	eq
 8022f88:	634a      	streq	r2, [r1, #52]	; 0x34
  }

  xmc_device.ep[0U].outInUse = 0U;
 8022f8a:	6863      	ldr	r3, [r4, #4]
  xmc_device.ep[0U].inInUse = 0U;

  xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_RESET);
 8022f8c:	f8d4 2200 	ldr.w	r2, [r4, #512]	; 0x200
  {
    /* Clear Empty interrupt */
    xmc_device.device_register->dtknqr4_fifoemptymsk = 0U;
  }

  xmc_device.ep[0U].outInUse = 0U;
 8022f90:	f023 0310 	bic.w	r3, r3, #16
 8022f94:	6063      	str	r3, [r4, #4]
  xmc_device.ep[0U].inInUse = 0U;
 8022f96:	6863      	ldr	r3, [r4, #4]
 8022f98:	f023 0308 	bic.w	r3, r3, #8
 8022f9c:	6063      	str	r3, [r4, #4]

  xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_RESET);
 8022f9e:	2004      	movs	r0, #4
 8022fa0:	4790      	blx	r2
	  clear.b.outepintr = 1U;
	  break;
		default:
		break;
	}
	xmc_device.global_register->gintsts = clear.d32;
 8022fa2:	f8d4 31a0 	ldr.w	r3, [r4, #416]	; 0x1a0
  {
    case (XMC_USBD_EVENT_POWER_ON):
	  clear.b.sessreqintr = 1U;
	  break;
    case (XMC_USBD_EVENT_RESET):
	  clear.b.usbreset = 1U;
 8022fa6:	f44f 5280 	mov.w	r2, #4096	; 0x1000
	  clear.b.outepintr = 1U;
	  break;
		default:
		break;
	}
	xmc_device.global_register->gintsts = clear.d32;
 8022faa:	615a      	str	r2, [r3, #20]
 8022fac:	e552      	b.n	8022a54 <XMC_USBD_IRQHandler+0x54>
    xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_REMOTE_WAKEUP);
    XMC_USBD_ClearEvent(XMC_USBD_EVENT_REMOTE_WAKEUP);
  }
  if (data.b.sessreqintr)
  {
    xmc_device.IsPowered = 1U;
 8022fae:	f894 31fe 	ldrb.w	r3, [r4, #510]	; 0x1fe
    xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_POWER_ON);
 8022fb2:	f8d4 2200 	ldr.w	r2, [r4, #512]	; 0x200
    xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_REMOTE_WAKEUP);
    XMC_USBD_ClearEvent(XMC_USBD_EVENT_REMOTE_WAKEUP);
  }
  if (data.b.sessreqintr)
  {
    xmc_device.IsPowered = 1U;
 8022fb6:	f043 0304 	orr.w	r3, r3, #4
 8022fba:	f884 31fe 	strb.w	r3, [r4, #510]	; 0x1fe
    xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_POWER_ON);
 8022fbe:	2000      	movs	r0, #0
 8022fc0:	4790      	blx	r2
	  clear.b.outepintr = 1U;
	  break;
		default:
		break;
	}
	xmc_device.global_register->gintsts = clear.d32;
 8022fc2:	f8d4 31a0 	ldr.w	r3, [r4, #416]	; 0x1a0
  gintsts_data_t clear;
  clear.d32 = 0U;
  switch(event)
  {
    case (XMC_USBD_EVENT_POWER_ON):
	  clear.b.sessreqintr = 1U;
 8022fc6:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
	  clear.b.outepintr = 1U;
	  break;
		default:
		break;
	}
	xmc_device.global_register->gintsts = clear.d32;
 8022fca:	615a      	str	r2, [r3, #20]
 8022fcc:	e53f      	b.n	8022a4e <XMC_USBD_IRQHandler+0x4e>
    xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_SUSPEND);
    XMC_USBD_ClearEvent(XMC_USBD_EVENT_SUSPEND);
  }
  if (data.b.wkupintr)
  {
    xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_REMOTE_WAKEUP);
 8022fce:	f8d4 3200 	ldr.w	r3, [r4, #512]	; 0x200
 8022fd2:	2008      	movs	r0, #8
 8022fd4:	4798      	blx	r3
	  clear.b.outepintr = 1U;
	  break;
		default:
		break;
	}
	xmc_device.global_register->gintsts = clear.d32;
 8022fd6:	f8d4 31a0 	ldr.w	r3, [r4, #416]	; 0x1a0
	  break;
    case (XMC_USBD_EVENT_RESUME):
	  clear.b.wkupintr = 1U;
	  break;
    case (XMC_USBD_EVENT_REMOTE_WAKEUP):
	  clear.b.wkupintr = 1U;
 8022fda:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
	  clear.b.outepintr = 1U;
	  break;
		default:
		break;
	}
	xmc_device.global_register->gintsts = clear.d32;
 8022fde:	615a      	str	r2, [r3, #20]
 8022fe0:	e532      	b.n	8022a48 <XMC_USBD_IRQHandler+0x48>
  {
    XMC_USBD_ClearEvent(XMC_USBD_EVENT_EARLYSUSPEND);
  }
  if (data.b.usbsuspend)
  {
    xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_SUSPEND);
 8022fe2:	f8d4 3200 	ldr.w	r3, [r4, #512]	; 0x200
 8022fe6:	2006      	movs	r0, #6
 8022fe8:	4798      	blx	r3
	  clear.b.outepintr = 1U;
	  break;
		default:
		break;
	}
	xmc_device.global_register->gintsts = clear.d32;
 8022fea:	f8d4 31a0 	ldr.w	r3, [r4, #416]	; 0x1a0
	  break;
    case (XMC_USBD_EVENT_RESET):
	  clear.b.usbreset = 1U;
	  break;
    case (XMC_USBD_EVENT_SUSPEND):
	  clear.b.usbsuspend = 1U;
 8022fee:	f44f 6200 	mov.w	r2, #2048	; 0x800
	  clear.b.outepintr = 1U;
	  break;
		default:
		break;
	}
	xmc_device.global_register->gintsts = clear.d32;
 8022ff2:	615a      	str	r2, [r3, #20]
 8022ff4:	e523      	b.n	8022a3e <XMC_USBD_IRQHandler+0x3e>
  gintmsk.d32 = xmc_device.global_register->gintmsk;
  data.d32 = xmc_device.global_register->gintsts & gintmsk.d32;
	
  if (data.b.sofintr)
  {
    xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_SOF);
 8022ff6:	f8d4 3200 	ldr.w	r3, [r4, #512]	; 0x200
 8022ffa:	2009      	movs	r0, #9
 8022ffc:	4798      	blx	r3
	  clear.b.outepintr = 1U;
	  break;
		default:
		break;
	}
	xmc_device.global_register->gintsts = clear.d32;
 8022ffe:	f8d4 31a0 	ldr.w	r3, [r4, #416]	; 0x1a0
	  break;
    case (XMC_USBD_EVENT_REMOTE_WAKEUP):
	  clear.b.wkupintr = 1U;
	  break;
    case (XMC_USBD_EVENT_SOF):
	  clear.b.sofintr = 1U;
 8023002:	2208      	movs	r2, #8
	  clear.b.outepintr = 1U;
	  break;
		default:
		break;
	}
	xmc_device.global_register->gintsts = clear.d32;
 8023004:	615a      	str	r2, [r3, #20]
  if (data.b.sofintr)
  {
    xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_SOF);
    XMC_USBD_ClearEvent(XMC_USBD_EVENT_SOF);
  }
  if(obj->usbd_transfer_mode == XMC_USBD_USE_FIFO)
 8023006:	9a01      	ldr	r2, [sp, #4]
 8023008:	7b52      	ldrb	r2, [r2, #13]
 802300a:	2a01      	cmp	r2, #1
 802300c:	f47f ad0d 	bne.w	8022a2a <XMC_USBD_IRQHandler+0x2a>
  {
    if (data.b.rxstsqlvl)
 8023010:	06f1      	lsls	r1, r6, #27
 8023012:	f57f ad0a 	bpl.w	8022a2a <XMC_USBD_IRQHandler+0x2a>
    {
      /* Masked that interrupt so its only done once */
      gintmsk.b.rxstsqlvl = 0U;
 8023016:	f36f 1504 	bfc	r5, #4, #1
      xmc_device.global_register->gintmsk = gintmsk.d32;
 802301a:	619d      	str	r5, [r3, #24]
 * This function handles the interrupt, when the rx fifo is not empty anymore.
 */
static void XMC_USBD_lHandleRxFLvl(void) 
{
  device_grxsts_data_t data;	
  data.d32 = xmc_device.global_register->grxstsp;
 802301c:	6a1a      	ldr	r2, [r3, #32]

  switch (data.b.pktsts)
 802301e:	f3c2 4143 	ubfx	r1, r2, #17, #4
 8023022:	2902      	cmp	r1, #2
 8023024:	f000 80ff 	beq.w	8023226 <XMC_USBD_IRQHandler+0x826>
 8023028:	2906      	cmp	r1, #6
 802302a:	d149      	bne.n	80230c0 <XMC_USBD_IRQHandler+0x6c0>
      break;
    case XMC_USBD_GRXSTS_PKTSTS_OUTDATA:
      XMC_USBD_lReadFifo((uint32_t)data.b.epnum,(uint32_t)data.b.bcnt);
      break;
    case XMC_USBD_GRXSTS_PKTSTS_SETUP:
      XMC_USBD_lReadFifo((uint32_t)data.b.epnum,(uint32_t)data.b.bcnt);
 802302c:	f002 070f 	and.w	r7, r2, #15
  uint32_t temp_data;
  uint32_t temp_word_count;
  volatile uint32_t *fifo = xmc_device.fifo[0U];
  uint32_t i;
  depctl_data_t data;
  data.d32 = xmc_device.endpoint_out_register[ep_num]->doepctl;
 8023030:	eb04 0187 	add.w	r1, r4, r7, lsl #2
      break;
    case XMC_USBD_GRXSTS_PKTSTS_OUTDATA:
      XMC_USBD_lReadFifo((uint32_t)data.b.epnum,(uint32_t)data.b.bcnt);
      break;
    case XMC_USBD_GRXSTS_PKTSTS_SETUP:
      XMC_USBD_lReadFifo((uint32_t)data.b.epnum,(uint32_t)data.b.bcnt);
 8023034:	f3c2 120a 	ubfx	r2, r2, #4, #11
  uint32_t temp_data;
  uint32_t temp_word_count;
  volatile uint32_t *fifo = xmc_device.fifo[0U];
  uint32_t i;
  depctl_data_t data;
  data.d32 = xmc_device.endpoint_out_register[ep_num]->doepctl;
 8023038:	f8d1 11c4 	ldr.w	r1, [r1, #452]	; 0x1c4
{
  XMC_USBD_EP_t * ep = &xmc_device.ep[ep_num];
  uint32_t word_count;
  uint32_t temp_data;
  uint32_t temp_word_count;
  volatile uint32_t *fifo = xmc_device.fifo[0U];
 802303c:	4825      	ldr	r0, [pc, #148]	; (80230d4 <XMC_USBD_IRQHandler+0x6d4>)
  uint32_t i;
  depctl_data_t data;
  data.d32 = xmc_device.endpoint_out_register[ep_num]->doepctl;
 802303e:	6809      	ldr	r1, [r1, #0]
{
  XMC_USBD_EP_t * ep = &xmc_device.ep[ep_num];
  uint32_t word_count;
  uint32_t temp_data;
  uint32_t temp_word_count;
  volatile uint32_t *fifo = xmc_device.fifo[0U];
 8023040:	f8d4 81e0 	ldr.w	r8, [r4, #480]	; 0x1e0
  depctl_data_t data;
  data.d32 = xmc_device.endpoint_out_register[ep_num]->doepctl;
  word_count = (byte_count >> 2U );
  temp_word_count = (word_count << 2U);
  /* Check if ep is enabled and has buffer */
  if (!data.b.usbactep)
 8023044:	040e      	lsls	r6, r1, #16
 8023046:	d53b      	bpl.n	80230c0 <XMC_USBD_IRQHandler+0x6c0>
  {
    /*Do Nothing*/
  }
  else if (ep->xferBuffer == NULL)
 8023048:	2134      	movs	r1, #52	; 0x34
 802304a:	fb01 0e07 	mla	lr, r1, r7, r0
 802304e:	f8de 0024 	ldr.w	r0, [lr, #36]	; 0x24
 8023052:	b3a8      	cbz	r0, 80230c0 <XMC_USBD_IRQHandler+0x6c0>
	/*Do Nothing*/
  }
  else
  {
    /* store the data */
    for (i = 0U;i < word_count; i++)
 8023054:	ea5f 0c92 	movs.w	ip, r2, lsr #2
 8023058:	d00b      	beq.n	8023072 <XMC_USBD_IRQHandler+0x672>
 802305a:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
 802305e:	2100      	movs	r1, #0
 8023060:	e001      	b.n	8023066 <XMC_USBD_IRQHandler+0x666>
 8023062:	f8de 0024 	ldr.w	r0, [lr, #36]	; 0x24
    {
      *(((uint32_t*)ep->xferBuffer)+i) = *fifo;
 8023066:	f8d8 6000 	ldr.w	r6, [r8]
 802306a:	5046      	str	r6, [r0, r1]
 802306c:	3104      	adds	r1, #4
	/*Do Nothing*/
  }
  else
  {
    /* store the data */
    for (i = 0U;i < word_count; i++)
 802306e:	4561      	cmp	r1, ip
 8023070:	d1f7      	bne.n	8023062 <XMC_USBD_IRQHandler+0x662>
    {
      *(((uint32_t*)ep->xferBuffer)+i) = *fifo;
    }
    /* space is not devidable by 4 */
    if (byte_count!=temp_word_count)
 8023072:	4562      	cmp	r2, ip
 8023074:	d01b      	beq.n	80230ae <XMC_USBD_IRQHandler+0x6ae>
    {
      temp_data = *fifo;
 8023076:	f8d8 8000 	ldr.w	r8, [r8]
      for (i = 0U;(temp_word_count + i) < byte_count;i++)
 802307a:	d918      	bls.n	80230ae <XMC_USBD_IRQHandler+0x6ae>
      {
        ep->xferBuffer[(word_count << 2)+i] = (uint8_t)((temp_data & ((uint32_t)0xFFU << (i * 8U))) >> (i * 8U));
 802307c:	f04f 0e34 	mov.w	lr, #52	; 0x34
    }
    /* space is not devidable by 4 */
    if (byte_count!=temp_word_count)
    {
      temp_data = *fifo;
      for (i = 0U;(temp_word_count + i) < byte_count;i++)
 8023080:	4663      	mov	r3, ip
      {
        ep->xferBuffer[(word_count << 2)+i] = (uint8_t)((temp_data & ((uint32_t)0xFFU << (i * 8U))) >> (i * 8U));
 8023082:	fb0e 4e07 	mla	lr, lr, r7, r4
    }
    /* space is not devidable by 4 */
    if (byte_count!=temp_word_count)
    {
      temp_data = *fifo;
      for (i = 0U;(temp_word_count + i) < byte_count;i++)
 8023086:	2600      	movs	r6, #0
      {
        ep->xferBuffer[(word_count << 2)+i] = (uint8_t)((temp_data & ((uint32_t)0xFFU << (i * 8U))) >> (i * 8U));
 8023088:	f04f 09ff 	mov.w	r9, #255	; 0xff
 802308c:	fa09 f106 	lsl.w	r1, r9, r6
 8023090:	ea01 0108 	and.w	r1, r1, r8
 8023094:	f8de 0024 	ldr.w	r0, [lr, #36]	; 0x24
 8023098:	f8df c038 	ldr.w	ip, [pc, #56]	; 80230d4 <XMC_USBD_IRQHandler+0x6d4>
 802309c:	40f1      	lsrs	r1, r6
 802309e:	54c1      	strb	r1, [r0, r3]
    }
    /* space is not devidable by 4 */
    if (byte_count!=temp_word_count)
    {
      temp_data = *fifo;
      for (i = 0U;(temp_word_count + i) < byte_count;i++)
 80230a0:	3301      	adds	r3, #1
 80230a2:	429a      	cmp	r2, r3
 80230a4:	f106 0608 	add.w	r6, r6, #8
 80230a8:	d1f0      	bne.n	802308c <XMC_USBD_IRQHandler+0x68c>
 80230aa:	f8dc 31a0 	ldr.w	r3, [ip, #416]	; 0x1a0
        ep->xferBuffer[(word_count << 2)+i] = (uint8_t)((temp_data & ((uint32_t)0xFFU << (i * 8U))) >> (i * 8U));
      }
    }

    /* save the amount of data */
    ep->xferCount += byte_count;
 80230ae:	2634      	movs	r6, #52	; 0x34
 80230b0:	fb06 4607 	mla	r6, r6, r7, r4
 80230b4:	6af1      	ldr	r1, [r6, #44]	; 0x2c
    ep->xferBuffer += byte_count;
 80230b6:	6a70      	ldr	r0, [r6, #36]	; 0x24
        ep->xferBuffer[(word_count << 2)+i] = (uint8_t)((temp_data & ((uint32_t)0xFFU << (i * 8U))) >> (i * 8U));
      }
    }

    /* save the amount of data */
    ep->xferCount += byte_count;
 80230b8:	4411      	add	r1, r2
    ep->xferBuffer += byte_count;
 80230ba:	4402      	add	r2, r0
        ep->xferBuffer[(word_count << 2)+i] = (uint8_t)((temp_data & ((uint32_t)0xFFU << (i * 8U))) >> (i * 8U));
      }
    }

    /* save the amount of data */
    ep->xferCount += byte_count;
 80230bc:	62f1      	str	r1, [r6, #44]	; 0x2c
    ep->xferBuffer += byte_count;
 80230be:	6272      	str	r2, [r6, #36]	; 0x24
    {
      /* Masked that interrupt so its only done once */
      gintmsk.b.rxstsqlvl = 0U;
      xmc_device.global_register->gintmsk = gintmsk.d32;
      XMC_USBD_lHandleRxFLvl(); /* handle the interrupt */
      gintmsk.b.rxstsqlvl = 1U;
 80230c0:	f045 0510 	orr.w	r5, r5, #16
      xmc_device.global_register->gintmsk = gintmsk.d32;
 80230c4:	619d      	str	r5, [r3, #24]
 80230c6:	e4b0      	b.n	8022a2a <XMC_USBD_IRQHandler+0x2a>
 80230c8:	1fff0074 	.word	0x1fff0074
 80230cc:	00100090 	.word	0x00100090
 80230d0:	001000a0 	.word	0x001000a0
 80230d4:	1fff0078 	.word	0x1fff0078
 80230d8:	00100050 	.word	0x00100050
 80230dc:	00100060 	.word	0x00100060
 80230e0:	00100070 	.word	0x00100070
 80230e4:	00100080 	.word	0x00100080
    ep0_data->b.xfersize = (uint8_t)ep->xferTotal;
  }
  else
  {
    /* If requested length is zero, just receive one zero length packet */
    if (ep->xferLength == 0U)
 80230e8:	b9a9      	cbnz	r1, 8023116 <XMC_USBD_IRQHandler+0x716>
    {
      data.b.xfersize = 0U;
 80230ea:	f361 0312 	bfi	r3, r1, #0, #19
      data.b.pktcnt = 1U;
 80230ee:	2201      	movs	r2, #1
 80230f0:	f362 43dc 	bfi	r3, r2, #19, #10
 80230f4:	e551      	b.n	8022b9a <XMC_USBD_IRQHandler+0x19a>
 80230f6:	5da2      	ldrb	r2, [r4, r6]
 80230f8:	f002 020f 	and.w	r2, r2, #15
 80230fc:	eb04 0282 	add.w	r2, r4, r2, lsl #2
 8023100:	f8d2 11c4 	ldr.w	r1, [r2, #452]	; 0x1c4
 8023104:	e55b      	b.n	8022bbe <XMC_USBD_IRQHandler+0x1be>
        if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
        {
          /* update xfer values */
          if ((dieptsiz.b.pktcnt == 0U) && (dieptsiz.b.xfersize == 0U))
          {
            uint32_t Bytes = ep->xferLength - ep->xferCount;
 8023106:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 8023108:	6a81      	ldr	r1, [r0, #40]	; 0x28
            ep->xferCount += Bytes;
            ep->xferBuffer += Bytes;
 802310a:	6a43      	ldr	r3, [r0, #36]	; 0x24
        {
          /* update xfer values */
          if ((dieptsiz.b.pktcnt == 0U) && (dieptsiz.b.xfersize == 0U))
          {
            uint32_t Bytes = ep->xferLength - ep->xferCount;
            ep->xferCount += Bytes;
 802310c:	62c1      	str	r1, [r0, #44]	; 0x2c
        if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
        {
          /* update xfer values */
          if ((dieptsiz.b.pktcnt == 0U) && (dieptsiz.b.xfersize == 0U))
          {
            uint32_t Bytes = ep->xferLength - ep->xferCount;
 802310e:	1a8a      	subs	r2, r1, r2
            ep->xferCount += Bytes;
            ep->xferBuffer += Bytes;
 8023110:	441a      	add	r2, r3
 8023112:	6242      	str	r2, [r0, #36]	; 0x24
 8023114:	e5e0      	b.n	8022cd8 <XMC_USBD_IRQHandler+0x2d8>
      data.b.pktcnt = 1U;
    }
    else
    {
      /* setup endpoint to recive a amount of packages by given size */
      data.b.pktcnt = (uint16_t)(((ep->xferLength - ep->xferCount) + (ep->maxPacketSize -(uint32_t)1U))/ep->maxPacketSize);
 8023116:	6842      	ldr	r2, [r0, #4]
 8023118:	f8da 0004 	ldr.w	r0, [sl, #4]
 802311c:	f3c2 22c6 	ubfx	r2, r2, #11, #7
 8023120:	1a09      	subs	r1, r1, r0
 8023122:	f102 3eff 	add.w	lr, r2, #4294967295
 8023126:	448e      	add	lr, r1
 8023128:	fbbe f2f2 	udiv	r2, lr, r2
 802312c:	f362 43dc 	bfi	r3, r2, #19, #10
      data.b.xfersize =(uint32_t)(ep->xferLength - ep->xferCount);
 8023130:	f361 0312 	bfi	r3, r1, #0, #19
 8023134:	e531      	b.n	8022b9a <XMC_USBD_IRQHandler+0x19a>
  {
    if (ep->address_u.address_st.number == 0U)
    {
      size.b.pktcnt = 1U;
      /* ep->maxXferSize equals maxPacketSize */
      size.b.xfersize = (uint32_t)(ep->xferLength - ep->xferCount);
 8023136:	f8d8 1004 	ldr.w	r1, [r8, #4]
 802313a:	1a5b      	subs	r3, r3, r1
 802313c:	f3c3 0312 	ubfx	r3, r3, #0, #19
  }
  else
  {
    if (ep->address_u.address_st.number == 0U)
    {
      size.b.pktcnt = 1U;
 8023140:	f04f 0c01 	mov.w	ip, #1
 8023144:	e63b      	b.n	8022dbe <XMC_USBD_IRQHandler+0x3be>
  {
    ep->xferLength += ep->maxTransferSize;
  }
  if (ep->xferLength == 0U)
  {
    size.b.xfersize = 0U;
 8023146:	f363 0012 	bfi	r0, r3, #0, #19
    size.b.pktcnt = 1U;
 802314a:	2301      	movs	r3, #1
 802314c:	f363 40dc 	bfi	r0, r3, #19, #10
 8023150:	e644      	b.n	8022ddc <XMC_USBD_IRQHandler+0x3dc>
  volatile uint32_t *fifo;
  uint32_t byte_count;
  uint32_t word_count;
  uint32_t result;
  uint32_t i;
  fifo = xmc_device.fifo[ep->address_u.address_st.number]; /* fifo */
 8023152:	f008 080f 	and.w	r8, r8, #15
  freeSpace.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->dtxfsts;
 8023156:	f108 016a 	add.w	r1, r8, #106	; 0x6a
 802315a:	4f5e      	ldr	r7, [pc, #376]	; (80232d4 <XMC_USBD_IRQHandler+0x8d4>)
 802315c:	f857 1021 	ldr.w	r1, [r7, r1, lsl #2]
  /* calculate the length and the amount of dwords to copy based on the fifo status */
  byte_count = ep->xferLength - ep->xferCount;
 8023160:	6ac7      	ldr	r7, [r0, #44]	; 0x2c
  uint32_t byte_count;
  uint32_t word_count;
  uint32_t result;
  uint32_t i;
  fifo = xmc_device.fifo[ep->address_u.address_st.number]; /* fifo */
  freeSpace.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->dtxfsts;
 8023162:	f8d1 c018 	ldr.w	ip, [r1, #24]
  volatile uint32_t *fifo;
  uint32_t byte_count;
  uint32_t word_count;
  uint32_t result;
  uint32_t i;
  fifo = xmc_device.fifo[ep->address_u.address_st.number]; /* fifo */
 8023166:	495b      	ldr	r1, [pc, #364]	; (80232d4 <XMC_USBD_IRQHandler+0x8d4>)
  freeSpace.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->dtxfsts;
  /* calculate the length and the amount of dwords to copy based on the fifo status */
  byte_count = ep->xferLength - ep->xferCount;
 8023168:	9706      	str	r7, [sp, #24]
  volatile uint32_t *fifo;
  uint32_t byte_count;
  uint32_t word_count;
  uint32_t result;
  uint32_t i;
  fifo = xmc_device.fifo[ep->address_u.address_st.number]; /* fifo */
 802316a:	f108 0878 	add.w	r8, r8, #120	; 0x78
 802316e:	f851 1028 	ldr.w	r1, [r1, r8, lsl #2]
 8023172:	9107      	str	r1, [sp, #28]
  freeSpace.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->dtxfsts;
  /* calculate the length and the amount of dwords to copy based on the fifo status */
  byte_count = ep->xferLength - ep->xferCount;
  if (!byte_count)
 8023174:	6a81      	ldr	r1, [r0, #40]	; 0x28
 8023176:	1bc9      	subs	r1, r1, r7
 8023178:	9105      	str	r1, [sp, #20]
 802317a:	d051      	beq.n	8023220 <XMC_USBD_IRQHandler+0x820>
    result = 0U;
  }
  else
  {
    /* add the unaligned bytes to the word count to compare with the fifo space */
    word_count = ((uint32_t)byte_count + 3U) >> 2U;
 802317c:	f101 0803 	add.w	r8, r1, #3
    if (word_count > (uint32_t)freeSpace.b.txfspcavail )
 8023180:	fa1f fc8c 	uxth.w	ip, ip
    result = 0U;
  }
  else
  {
    /* add the unaligned bytes to the word count to compare with the fifo space */
    word_count = ((uint32_t)byte_count + 3U) >> 2U;
 8023184:	ea4f 0898 	mov.w	r8, r8, lsr #2
    if (word_count > (uint32_t)freeSpace.b.txfspcavail )
 8023188:	45e0      	cmp	r8, ip
 802318a:	d844      	bhi.n	8023216 <XMC_USBD_IRQHandler+0x816>
 802318c:	fb0b 410e 	mla	r1, fp, lr, r4
      word_count = (uint32_t)freeSpace.b.txfspcavail;
      byte_count = (uint32_t)word_count << (uint32_t)2U;
    }

    /* copy data dword wise */
    for (i = 0U; i < word_count;ep->xferBuffer+= 4U)
 8023190:	f1b8 0f00 	cmp.w	r8, #0
 8023194:	f000 809b 	beq.w	80232ce <XMC_USBD_IRQHandler+0x8ce>
 8023198:	9106      	str	r1, [sp, #24]
 802319a:	f8cd 9024 	str.w	r9, [sp, #36]	; 0x24
 802319e:	6a49      	ldr	r1, [r1, #36]	; 0x24
 80231a0:	f8dd c01c 	ldr.w	ip, [sp, #28]
 80231a4:	9f02      	ldr	r7, [sp, #8]
 80231a6:	f8dd 9018 	ldr.w	r9, [sp, #24]
 80231aa:	f8cd e020 	str.w	lr, [sp, #32]
 80231ae:	2000      	movs	r0, #0
    {
      *fifo = *(uint32_t*)ep->xferBuffer;
 80231b0:	6809      	ldr	r1, [r1, #0]
 80231b2:	f8cc 1000 	str.w	r1, [ip]
      word_count = (uint32_t)freeSpace.b.txfspcavail;
      byte_count = (uint32_t)word_count << (uint32_t)2U;
    }

    /* copy data dword wise */
    for (i = 0U; i < word_count;ep->xferBuffer+= 4U)
 80231b6:	f8d9 1024 	ldr.w	r1, [r9, #36]	; 0x24
    {
      *fifo = *(uint32_t*)ep->xferBuffer;
      i++;
 80231ba:	3001      	adds	r0, #1
      word_count = (uint32_t)freeSpace.b.txfspcavail;
      byte_count = (uint32_t)word_count << (uint32_t)2U;
    }

    /* copy data dword wise */
    for (i = 0U; i < word_count;ep->xferBuffer+= 4U)
 80231bc:	3104      	adds	r1, #4
 80231be:	4540      	cmp	r0, r8
 80231c0:	f8c9 1024 	str.w	r1, [r9, #36]	; 0x24
 80231c4:	d1f4      	bne.n	80231b0 <XMC_USBD_IRQHandler+0x7b0>
 80231c6:	9806      	ldr	r0, [sp, #24]
 80231c8:	f8dd e020 	ldr.w	lr, [sp, #32]
 80231cc:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
 80231ce:	f8dd 9024 	ldr.w	r9, [sp, #36]	; 0x24
 80231d2:	9702      	str	r7, [sp, #8]
 80231d4:	9006      	str	r0, [sp, #24]
 80231d6:	4607      	mov	r7, r0
      {
        if (diepint.b.emptyintr)
        {
          uint32_t bytes;
          bytes = XMC_USBD_lWriteFifo(ep);
          ep->xferCount += bytes;
 80231d8:	46bc      	mov	ip, r7
 80231da:	9f05      	ldr	r7, [sp, #20]
 80231dc:	fb0b 400e 	mla	r0, fp, lr, r4
 80231e0:	44bc      	add	ip, r7
          ep->xferBuffer += bytes;
 80231e2:	4439      	add	r1, r7
      {
        if (diepint.b.emptyintr)
        {
          uint32_t bytes;
          bytes = XMC_USBD_lWriteFifo(ep);
          ep->xferCount += bytes;
 80231e4:	f8c0 c02c 	str.w	ip, [r0, #44]	; 0x2c
          ep->xferBuffer += bytes;
 80231e8:	6241      	str	r1, [r0, #36]	; 0x24
 80231ea:	e588      	b.n	8022cfe <XMC_USBD_IRQHandler+0x2fe>
    if(usbd_init->usbd_transfer_mode == XMC_USBD_USE_DMA)
    {
      /* Program dma*/
      xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepdma = (uint32_t)ep->xferBuffer;
    }
    if(usbd_init->usbd_transfer_mode == XMC_USBD_USE_FIFO)
 80231ec:	2901      	cmp	r1, #1
 80231ee:	f47f adf5 	bne.w	8022ddc <XMC_USBD_IRQHandler+0x3dc>
    {
      /* enable fifo empty interrupt */
			xmc_device.device_register->dtknqr4_fifoemptymsk |= (uint32_t)((uint32_t)1U << (uint8_t)ep->address_u.address_st.number);
 80231f2:	9f06      	ldr	r7, [sp, #24]
 80231f4:	f8da 3034 	ldr.w	r3, [sl, #52]	; 0x34
 80231f8:	40b9      	lsls	r1, r7
 80231fa:	4319      	orrs	r1, r3
 80231fc:	f8ca 1034 	str.w	r1, [sl, #52]	; 0x34
 8023200:	e5ec      	b.n	8022ddc <XMC_USBD_IRQHandler+0x3dc>
          ep->inInUse = 0U;
          if(obj->usbd_transfer_mode == XMC_USBD_USE_FIFO)
          {
            /* mask fifo empty interrupt */
            xmc_device.device_register->dtknqr4_fifoemptymsk =
            (uint32_t)(xmc_device.device_register->dtknqr4_fifoemptymsk & ~(((uint32_t)1U << ep_num)));
 8023202:	4b34      	ldr	r3, [pc, #208]	; (80232d4 <XMC_USBD_IRQHandler+0x8d4>)
 8023204:	f8d3 11a4 	ldr.w	r1, [r3, #420]	; 0x1a4
 8023208:	6b4b      	ldr	r3, [r1, #52]	; 0x34
 802320a:	fa02 f20e 	lsl.w	r2, r2, lr
 802320e:	ea23 0202 	bic.w	r2, r3, r2
        {
          ep->inInUse = 0U;
          if(obj->usbd_transfer_mode == XMC_USBD_USE_FIFO)
          {
            /* mask fifo empty interrupt */
            xmc_device.device_register->dtknqr4_fifoemptymsk =
 8023212:	634a      	str	r2, [r1, #52]	; 0x34
 8023214:	e582      	b.n	8022d1c <XMC_USBD_IRQHandler+0x31c>
    /* add the unaligned bytes to the word count to compare with the fifo space */
    word_count = ((uint32_t)byte_count + 3U) >> 2U;
    if (word_count > (uint32_t)freeSpace.b.txfspcavail )
    {
      word_count = (uint32_t)freeSpace.b.txfspcavail;
      byte_count = (uint32_t)word_count << (uint32_t)2U;
 8023216:	ea4f 018c 	mov.w	r1, ip, lsl #2
 802321a:	9105      	str	r1, [sp, #20]
 802321c:	46e0      	mov	r8, ip
 802321e:	e7b5      	b.n	802318c <XMC_USBD_IRQHandler+0x78c>
 8023220:	6a41      	ldr	r1, [r0, #36]	; 0x24
 8023222:	9f06      	ldr	r7, [sp, #24]
 8023224:	e7d8      	b.n	80231d8 <XMC_USBD_IRQHandler+0x7d8>
    case XMC_USBD_GRXSTS_PKTSTS_GOUTNAK:
      break;
    case XMC_USBD_GRXSTS_PKTSTS_OUTCMPL:
      break;
    case XMC_USBD_GRXSTS_PKTSTS_OUTDATA:
      XMC_USBD_lReadFifo((uint32_t)data.b.epnum,(uint32_t)data.b.bcnt);
 8023226:	f002 070f 	and.w	r7, r2, #15
  uint32_t temp_data;
  uint32_t temp_word_count;
  volatile uint32_t *fifo = xmc_device.fifo[0U];
  uint32_t i;
  depctl_data_t data;
  data.d32 = xmc_device.endpoint_out_register[ep_num]->doepctl;
 802322a:	eb04 0187 	add.w	r1, r4, r7, lsl #2
    case XMC_USBD_GRXSTS_PKTSTS_GOUTNAK:
      break;
    case XMC_USBD_GRXSTS_PKTSTS_OUTCMPL:
      break;
    case XMC_USBD_GRXSTS_PKTSTS_OUTDATA:
      XMC_USBD_lReadFifo((uint32_t)data.b.epnum,(uint32_t)data.b.bcnt);
 802322e:	f3c2 100a 	ubfx	r0, r2, #4, #11
  uint32_t temp_data;
  uint32_t temp_word_count;
  volatile uint32_t *fifo = xmc_device.fifo[0U];
  uint32_t i;
  depctl_data_t data;
  data.d32 = xmc_device.endpoint_out_register[ep_num]->doepctl;
 8023232:	f8d1 21c4 	ldr.w	r2, [r1, #452]	; 0x1c4
{
  XMC_USBD_EP_t * ep = &xmc_device.ep[ep_num];
  uint32_t word_count;
  uint32_t temp_data;
  uint32_t temp_word_count;
  volatile uint32_t *fifo = xmc_device.fifo[0U];
 8023236:	f8d4 c1e0 	ldr.w	ip, [r4, #480]	; 0x1e0
  uint32_t i;
  depctl_data_t data;
  data.d32 = xmc_device.endpoint_out_register[ep_num]->doepctl;
 802323a:	6812      	ldr	r2, [r2, #0]
{
  XMC_USBD_EP_t * ep = &xmc_device.ep[ep_num];
  uint32_t word_count;
  uint32_t temp_data;
  uint32_t temp_word_count;
  volatile uint32_t *fifo = xmc_device.fifo[0U];
 802323c:	4925      	ldr	r1, [pc, #148]	; (80232d4 <XMC_USBD_IRQHandler+0x8d4>)
  depctl_data_t data;
  data.d32 = xmc_device.endpoint_out_register[ep_num]->doepctl;
  word_count = (byte_count >> 2U );
  temp_word_count = (word_count << 2U);
  /* Check if ep is enabled and has buffer */
  if (!data.b.usbactep)
 802323e:	0412      	lsls	r2, r2, #16
 8023240:	f57f af3e 	bpl.w	80230c0 <XMC_USBD_IRQHandler+0x6c0>
  {
    /*Do Nothing*/
  }
  else if (ep->xferBuffer == NULL)
 8023244:	2234      	movs	r2, #52	; 0x34
 8023246:	fb02 1e07 	mla	lr, r2, r7, r1
 802324a:	f8de 1024 	ldr.w	r1, [lr, #36]	; 0x24
 802324e:	2900      	cmp	r1, #0
 8023250:	f43f af36 	beq.w	80230c0 <XMC_USBD_IRQHandler+0x6c0>
	/*Do Nothing*/
  }
  else
  {
    /* store the data */
    for (i = 0U;i < word_count; i++)
 8023254:	ea5f 0890 	movs.w	r8, r0, lsr #2
 8023258:	d00f      	beq.n	802327a <XMC_USBD_IRQHandler+0x87a>
 802325a:	ea4f 0888 	mov.w	r8, r8, lsl #2
 802325e:	2200      	movs	r2, #0
 8023260:	e001      	b.n	8023266 <XMC_USBD_IRQHandler+0x866>
 8023262:	f8de 1024 	ldr.w	r1, [lr, #36]	; 0x24
    {
      *(((uint32_t*)ep->xferBuffer)+i) = *fifo;
 8023266:	f8dc 6000 	ldr.w	r6, [ip]
 802326a:	508e      	str	r6, [r1, r2]
 802326c:	3204      	adds	r2, #4
	/*Do Nothing*/
  }
  else
  {
    /* store the data */
    for (i = 0U;i < word_count; i++)
 802326e:	4542      	cmp	r2, r8
 8023270:	d1f7      	bne.n	8023262 <XMC_USBD_IRQHandler+0x862>
 8023272:	2234      	movs	r2, #52	; 0x34
 8023274:	fb02 4207 	mla	r2, r2, r7, r4
 8023278:	6a51      	ldr	r1, [r2, #36]	; 0x24
    {
      *(((uint32_t*)ep->xferBuffer)+i) = *fifo;
    }
    /* space is not devidable by 4 */
    if (byte_count!=temp_word_count)
 802327a:	4540      	cmp	r0, r8
 802327c:	d01e      	beq.n	80232bc <XMC_USBD_IRQHandler+0x8bc>
    {
      temp_data = *fifo;
 802327e:	f8dc c000 	ldr.w	ip, [ip]
      for (i = 0U;(temp_word_count + i) < byte_count;i++)
 8023282:	d91b      	bls.n	80232bc <XMC_USBD_IRQHandler+0x8bc>
 8023284:	f04f 0e34 	mov.w	lr, #52	; 0x34
 8023288:	4643      	mov	r3, r8
 802328a:	fb0e 4e07 	mla	lr, lr, r7, r4
 802328e:	2600      	movs	r6, #0
      {
        ep->xferBuffer[(word_count << 2)+i] = (uint8_t)((temp_data & ((uint32_t)0xFFU << (i * 8U))) >> (i * 8U));
 8023290:	f04f 08ff 	mov.w	r8, #255	; 0xff
 8023294:	e001      	b.n	802329a <XMC_USBD_IRQHandler+0x89a>
 8023296:	f8de 1024 	ldr.w	r1, [lr, #36]	; 0x24
 802329a:	fa08 f206 	lsl.w	r2, r8, r6
 802329e:	ea02 020c 	and.w	r2, r2, ip
 80232a2:	40f2      	lsrs	r2, r6
 80232a4:	54ca      	strb	r2, [r1, r3]
    }
    /* space is not devidable by 4 */
    if (byte_count!=temp_word_count)
    {
      temp_data = *fifo;
      for (i = 0U;(temp_word_count + i) < byte_count;i++)
 80232a6:	3301      	adds	r3, #1
 80232a8:	4298      	cmp	r0, r3
 80232aa:	f106 0608 	add.w	r6, r6, #8
 80232ae:	d1f2      	bne.n	8023296 <XMC_USBD_IRQHandler+0x896>
 80232b0:	2234      	movs	r2, #52	; 0x34
 80232b2:	fb02 4207 	mla	r2, r2, r7, r4
 80232b6:	f8d4 31a0 	ldr.w	r3, [r4, #416]	; 0x1a0
 80232ba:	6a51      	ldr	r1, [r2, #36]	; 0x24
        ep->xferBuffer[(word_count << 2)+i] = (uint8_t)((temp_data & ((uint32_t)0xFFU << (i * 8U))) >> (i * 8U));
      }
    }

    /* save the amount of data */
    ep->xferCount += byte_count;
 80232bc:	2234      	movs	r2, #52	; 0x34
 80232be:	fb02 4707 	mla	r7, r2, r7, r4
    ep->xferBuffer += byte_count;
 80232c2:	4401      	add	r1, r0
        ep->xferBuffer[(word_count << 2)+i] = (uint8_t)((temp_data & ((uint32_t)0xFFU << (i * 8U))) >> (i * 8U));
      }
    }

    /* save the amount of data */
    ep->xferCount += byte_count;
 80232c4:	6afa      	ldr	r2, [r7, #44]	; 0x2c
    ep->xferBuffer += byte_count;
 80232c6:	6279      	str	r1, [r7, #36]	; 0x24
        ep->xferBuffer[(word_count << 2)+i] = (uint8_t)((temp_data & ((uint32_t)0xFFU << (i * 8U))) >> (i * 8U));
      }
    }

    /* save the amount of data */
    ep->xferCount += byte_count;
 80232c8:	4402      	add	r2, r0
 80232ca:	62fa      	str	r2, [r7, #44]	; 0x2c
 80232cc:	e6f8      	b.n	80230c0 <XMC_USBD_IRQHandler+0x6c0>
 80232ce:	6a49      	ldr	r1, [r1, #36]	; 0x24
 80232d0:	9f06      	ldr	r7, [sp, #24]
 80232d2:	e781      	b.n	80231d8 <XMC_USBD_IRQHandler+0x7d8>
 80232d4:	1fff0078 	.word	0x1fff0078

080232d8 <XMC_USBD_Disable>:

/**
 * Disables the USB0 module
 **/
void XMC_USBD_Disable(void) 
{
 80232d8:	b510      	push	{r4, lr}
  /* Clear Reset and power up */
  XMC_SCU_RESET_AssertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_USB0);
 80232da:	4c05      	ldr	r4, [pc, #20]	; (80232f0 <XMC_USBD_Disable+0x18>)
 80232dc:	4620      	mov	r0, r4
 80232de:	f7fd fe8d 	bl	8020ffc <XMC_SCU_RESET_AssertPeripheralReset>
#if defined(CLOCK_GATING_SUPPORTED)
  XMC_SCU_CLOCK_GatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_USB0);
 80232e2:	4620      	mov	r0, r4
 80232e4:	f7fd ff06 	bl	80210f4 <XMC_SCU_CLOCK_GatePeripheralClock>
#endif
  XMC_SCU_POWER_DisableUsb();
}
 80232e8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  /* Clear Reset and power up */
  XMC_SCU_RESET_AssertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_USB0);
#if defined(CLOCK_GATING_SUPPORTED)
  XMC_SCU_CLOCK_GatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_USB0);
#endif
  XMC_SCU_POWER_DisableUsb();
 80232ec:	f7fd bf54 	b.w	8021198 <XMC_SCU_POWER_DisableUsb>
 80232f0:	20000080 	.word	0x20000080

080232f4 <XMC_USIC_CH_Enable>:

void XMC_USIC_CH_Enable(XMC_USIC_CH_t *const channel)
{
  XMC_ASSERT("XMC_USIC_CH_Enable: channel not valid", XMC_USIC_IsChannelValid(channel));

  if ((channel == XMC_USIC0_CH0) || (channel == XMC_USIC0_CH1))
 80232f4:	4b1b      	ldr	r3, [pc, #108]	; (8023364 <XMC_USIC_CH_Enable+0x70>)
 80232f6:	4298      	cmp	r0, r3
/*******************************************************************************
 * API IMPLEMENTATION
 *******************************************************************************/

void XMC_USIC_CH_Enable(XMC_USIC_CH_t *const channel)
{
 80232f8:	b510      	push	{r4, lr}
 80232fa:	4604      	mov	r4, r0
  XMC_ASSERT("XMC_USIC_CH_Enable: channel not valid", XMC_USIC_IsChannelValid(channel));

  if ((channel == XMC_USIC0_CH0) || (channel == XMC_USIC0_CH1))
 80232fc:	d01b      	beq.n	8023336 <XMC_USIC_CH_Enable+0x42>
 80232fe:	f503 7300 	add.w	r3, r3, #512	; 0x200
 8023302:	4298      	cmp	r0, r3
 8023304:	d017      	beq.n	8023336 <XMC_USIC_CH_Enable+0x42>
  {
    XMC_USIC_Enable(XMC_USIC0);
  }
#if defined(USIC1)
  else if((channel == XMC_USIC1_CH0) || (channel == XMC_USIC1_CH1))
 8023306:	4b18      	ldr	r3, [pc, #96]	; (8023368 <XMC_USIC_CH_Enable+0x74>)
 8023308:	4298      	cmp	r0, r3
 802330a:	d024      	beq.n	8023356 <XMC_USIC_CH_Enable+0x62>
 802330c:	f503 7300 	add.w	r3, r3, #512	; 0x200
 8023310:	4298      	cmp	r0, r3
 8023312:	d020      	beq.n	8023356 <XMC_USIC_CH_Enable+0x62>
  {
    XMC_USIC_Enable(XMC_USIC1);
  }
#endif
#if defined(USIC2)
  else if((channel == XMC_USIC2_CH0) || (channel == XMC_USIC2_CH1))
 8023314:	4b15      	ldr	r3, [pc, #84]	; (802336c <XMC_USIC_CH_Enable+0x78>)
 8023316:	4298      	cmp	r0, r3
 8023318:	d016      	beq.n	8023348 <XMC_USIC_CH_Enable+0x54>
 802331a:	f503 7300 	add.w	r3, r3, #512	; 0x200
 802331e:	4298      	cmp	r0, r3
 8023320:	d012      	beq.n	8023348 <XMC_USIC_CH_Enable+0x54>
  {
    XMC_ASSERT("USIC module not available", 0U/*Always*/);
  }

  /* USIC channel switched on*/
  channel->KSCFG = (USIC_CH_KSCFG_MODEN_Msk | USIC_CH_KSCFG_BPMODEN_Msk);
 8023322:	2303      	movs	r3, #3
 8023324:	60e3      	str	r3, [r4, #12]
  while ((channel->KSCFG & USIC_CH_KSCFG_MODEN_Msk) == 0U)
 8023326:	68e3      	ldr	r3, [r4, #12]
 8023328:	07db      	lsls	r3, r3, #31
 802332a:	d5fc      	bpl.n	8023326 <XMC_USIC_CH_Enable+0x32>
  {
    /* Wait till the channel is enabled */
  }

  /* Set USIC channel in IDLE mode */
  channel->CCR &= (uint32_t)~USIC_CH_CCR_MODE_Msk;
 802332c:	6c23      	ldr	r3, [r4, #64]	; 0x40
 802332e:	f023 030f 	bic.w	r3, r3, #15
 8023332:	6423      	str	r3, [r4, #64]	; 0x40
 8023334:	bd10      	pop	{r4, pc}
void XMC_USIC_Enable(XMC_USIC_t *const usic)
{
  if (usic == USIC0)
  {
#if defined(CLOCK_GATING_SUPPORTED)
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_USIC0);
 8023336:	f44f 6000 	mov.w	r0, #2048	; 0x800
 802333a:	f7fd fee7 	bl	802110c <XMC_SCU_CLOCK_UngatePeripheralClock>
#endif
#if defined(PERIPHERAL_RESET_SUPPORTED)
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_USIC0);
 802333e:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8023342:	f7fd fe67 	bl	8021014 <XMC_SCU_RESET_DeassertPeripheralReset>
 8023346:	e7ec      	b.n	8023322 <XMC_USIC_CH_Enable+0x2e>
#endif  
#if defined(USIC2)  
  else if (usic == USIC2)
  {
#if defined(CLOCK_GATING_SUPPORTED) 
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_USIC2);
 8023348:	4809      	ldr	r0, [pc, #36]	; (8023370 <XMC_USIC_CH_Enable+0x7c>)
 802334a:	f7fd fedf 	bl	802110c <XMC_SCU_CLOCK_UngatePeripheralClock>
#endif
#if defined(PERIPHERAL_RESET_SUPPORTED)
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_USIC2);
 802334e:	4808      	ldr	r0, [pc, #32]	; (8023370 <XMC_USIC_CH_Enable+0x7c>)
 8023350:	f7fd fe60 	bl	8021014 <XMC_SCU_RESET_DeassertPeripheralReset>
 8023354:	e7e5      	b.n	8023322 <XMC_USIC_CH_Enable+0x2e>
  }
#if defined(USIC1)  
  else if (usic == USIC1)
  {
#if defined(CLOCK_GATING_SUPPORTED)
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_USIC1);
 8023356:	4807      	ldr	r0, [pc, #28]	; (8023374 <XMC_USIC_CH_Enable+0x80>)
 8023358:	f7fd fed8 	bl	802110c <XMC_SCU_CLOCK_UngatePeripheralClock>
#endif	
#if defined(PERIPHERAL_RESET_SUPPORTED)
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_USIC1);
 802335c:	4805      	ldr	r0, [pc, #20]	; (8023374 <XMC_USIC_CH_Enable+0x80>)
 802335e:	f7fd fe59 	bl	8021014 <XMC_SCU_RESET_DeassertPeripheralReset>
 8023362:	e7de      	b.n	8023322 <XMC_USIC_CH_Enable+0x2e>
 8023364:	40030000 	.word	0x40030000
 8023368:	48020000 	.word	0x48020000
 802336c:	48024000 	.word	0x48024000
 8023370:	10000100 	.word	0x10000100
 8023374:	10000080 	.word	0x10000080

08023378 <XMC_USIC_CH_SetBaudrate>:
  
  uint32_t pdiv_frac;
  uint32_t pdiv_frac_min;

  /* The rate and peripheral clock are divided by 100 to be able to use only 32bit arithmetic */
  if ((rate >= 100U) && (oversampling != 0U))
 8023378:	2963      	cmp	r1, #99	; 0x63
 802337a:	d900      	bls.n	802337e <XMC_USIC_CH_SetBaudrate+0x6>
 802337c:	b90a      	cbnz	r2, 8023382 <XMC_USIC_CH_SetBaudrate+0xa>
                    
    status = XMC_USIC_CH_STATUS_OK;
  }
  else 
  {
    status = XMC_USIC_CH_STATUS_ERROR;
 802337e:	2001      	movs	r0, #1
 8023380:	4770      	bx	lr
{
  channel->KSCFG = (uint32_t)((channel->KSCFG & (~USIC_CH_KSCFG_MODEN_Msk)) | USIC_CH_KSCFG_BPMODEN_Msk);
}

XMC_USIC_CH_STATUS_t XMC_USIC_CH_SetBaudrate(XMC_USIC_CH_t *const channel, uint32_t rate, uint32_t oversampling)
{
 8023382:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8023386:	4617      	mov	r7, r2
 8023388:	460c      	mov	r4, r1
 802338a:	4606      	mov	r6, r0
  uint32_t pdiv_frac_min;

  /* The rate and peripheral clock are divided by 100 to be able to use only 32bit arithmetic */
  if ((rate >= 100U) && (oversampling != 0U))
  {
    peripheral_clock = XMC_SCU_CLOCK_GetPeripheralClockFrequency() / 100U;
 802338c:	f7fd fe5e 	bl	802104c <XMC_SCU_CLOCK_GetPeripheralClockFrequency>
 8023390:	4d18      	ldr	r5, [pc, #96]	; (80233f4 <XMC_USIC_CH_SetBaudrate+0x7c>)
 8023392:	fba5 3200 	umull	r3, r2, r5, r0
    rate = rate / 100U;
 8023396:	fba5 3504 	umull	r3, r5, r5, r4
  uint32_t pdiv_frac_min;

  /* The rate and peripheral clock are divided by 100 to be able to use only 32bit arithmetic */
  if ((rate >= 100U) && (oversampling != 0U))
  {
    peripheral_clock = XMC_SCU_CLOCK_GetPeripheralClockFrequency() / 100U;
 802339a:	0952      	lsrs	r2, r2, #5
    rate = rate / 100U;
 802339c:	096d      	lsrs	r5, r5, #5

    clock_divider_min = 1U;
    pdiv_int_min = 1U;
    pdiv_frac_min = 0x3ffU;
 802339e:	f240 3eff 	movw	lr, #1023	; 0x3ff
  {
    peripheral_clock = XMC_SCU_CLOCK_GetPeripheralClockFrequency() / 100U;
    rate = rate / 100U;

    clock_divider_min = 1U;
    pdiv_int_min = 1U;
 80233a2:	f04f 0c01 	mov.w	ip, #1
 80233a6:	fb07 f505 	mul.w	r5, r7, r5
 80233aa:	ebc2 2182 	rsb	r1, r2, r2, lsl #10
    pdiv_frac_min = 0x3ffU;

    for(clock_divider = 1023U; clock_divider > 0U; --clock_divider)
 80233ae:	4670      	mov	r0, lr
  if ((rate >= 100U) && (oversampling != 0U))
  {
    peripheral_clock = XMC_SCU_CLOCK_GetPeripheralClockFrequency() / 100U;
    rate = rate / 100U;

    clock_divider_min = 1U;
 80233b0:	46e0      	mov	r8, ip
    pdiv_int_min = 1U;
    pdiv_frac_min = 0x3ffU;

    for(clock_divider = 1023U; clock_divider > 0U; --clock_divider)
    {
      pdiv = ((peripheral_clock * clock_divider) / (rate * oversampling));
 80233b2:	fbb1 f3f5 	udiv	r3, r1, r5
      pdiv_int = pdiv >> 10U;
 80233b6:	0a9c      	lsrs	r4, r3, #10
      pdiv_frac = pdiv & 0x3ffU;

      if ((pdiv_int < 1024U) && (pdiv_frac < pdiv_frac_min))
 80233b8:	f5b4 6f80 	cmp.w	r4, #1024	; 0x400

    for(clock_divider = 1023U; clock_divider > 0U; --clock_divider)
    {
      pdiv = ((peripheral_clock * clock_divider) / (rate * oversampling));
      pdiv_int = pdiv >> 10U;
      pdiv_frac = pdiv & 0x3ffU;
 80233bc:	f3c3 0309 	ubfx	r3, r3, #0, #10
 80233c0:	eba1 0102 	sub.w	r1, r1, r2

      if ((pdiv_int < 1024U) && (pdiv_frac < pdiv_frac_min))
 80233c4:	d204      	bcs.n	80233d0 <XMC_USIC_CH_SetBaudrate+0x58>
 80233c6:	4573      	cmp	r3, lr
 80233c8:	d202      	bcs.n	80233d0 <XMC_USIC_CH_SetBaudrate+0x58>
 80233ca:	469e      	mov	lr, r3
 80233cc:	46a4      	mov	ip, r4
 80233ce:	4680      	mov	r8, r0

    clock_divider_min = 1U;
    pdiv_int_min = 1U;
    pdiv_frac_min = 0x3ffU;

    for(clock_divider = 1023U; clock_divider > 0U; --clock_divider)
 80233d0:	3801      	subs	r0, #1
 80233d2:	d1ee      	bne.n	80233b2 <XMC_USIC_CH_SetBaudrate+0x3a>
        pdiv_int_min = pdiv_int;
        clock_divider_min = clock_divider;
      }
    }

    channel->FDR = XMC_USIC_CH_BRG_CLOCK_DIVIDER_MODE_FRACTIONAL |
 80233d4:	f448 4300 	orr.w	r3, r8, #32768	; 0x8000
 80233d8:	6133      	str	r3, [r6, #16]
                   (clock_divider_min << USIC_CH_FDR_STEP_Pos);

    channel->BRG = (channel->BRG & ~(USIC_CH_BRG_DCTQ_Msk |
 80233da:	6972      	ldr	r2, [r6, #20]
 80233dc:	4b06      	ldr	r3, [pc, #24]	; (80233f8 <XMC_USIC_CH_SetBaudrate+0x80>)
                                     USIC_CH_BRG_PDIV_Msk |
                                     USIC_CH_BRG_PCTQ_Msk |
                                     USIC_CH_BRG_PPPEN_Msk)) |
                   ((oversampling - 1U) << USIC_CH_BRG_DCTQ_Pos) |
 80233de:	3f01      	subs	r7, #1
    }

    channel->FDR = XMC_USIC_CH_BRG_CLOCK_DIVIDER_MODE_FRACTIONAL |
                   (clock_divider_min << USIC_CH_FDR_STEP_Pos);

    channel->BRG = (channel->BRG & ~(USIC_CH_BRG_DCTQ_Msk |
 80233e0:	4013      	ands	r3, r2
                                     USIC_CH_BRG_PDIV_Msk |
                                     USIC_CH_BRG_PCTQ_Msk |
                                     USIC_CH_BRG_PPPEN_Msk)) |
                   ((oversampling - 1U) << USIC_CH_BRG_DCTQ_Pos) |
                   ((pdiv_int_min - 1U) << USIC_CH_BRG_PDIV_Pos);
 80233e2:	f10c 3cff 	add.w	ip, ip, #4294967295
                   (clock_divider_min << USIC_CH_FDR_STEP_Pos);

    channel->BRG = (channel->BRG & ~(USIC_CH_BRG_DCTQ_Msk |
                                     USIC_CH_BRG_PDIV_Msk |
                                     USIC_CH_BRG_PCTQ_Msk |
                                     USIC_CH_BRG_PPPEN_Msk)) |
 80233e6:	ea43 2387 	orr.w	r3, r3, r7, lsl #10
                   ((oversampling - 1U) << USIC_CH_BRG_DCTQ_Pos) |
 80233ea:	ea43 430c 	orr.w	r3, r3, ip, lsl #16
    }

    channel->FDR = XMC_USIC_CH_BRG_CLOCK_DIVIDER_MODE_FRACTIONAL |
                   (clock_divider_min << USIC_CH_FDR_STEP_Pos);

    channel->BRG = (channel->BRG & ~(USIC_CH_BRG_DCTQ_Msk |
 80233ee:	6173      	str	r3, [r6, #20]
                                     USIC_CH_BRG_PCTQ_Msk |
                                     USIC_CH_BRG_PPPEN_Msk)) |
                   ((oversampling - 1U) << USIC_CH_BRG_DCTQ_Pos) |
                   ((pdiv_int_min - 1U) << USIC_CH_BRG_PDIV_Pos);
                    
    status = XMC_USIC_CH_STATUS_OK;
 80233f0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80233f4:	51eb851f 	.word	0x51eb851f
 80233f8:	fc0080ef 	.word	0xfc0080ef

080233fc <XMC_VADC_GLOBAL_Init>:
}


/* API to initialize global resources */
void XMC_VADC_GLOBAL_Init(XMC_VADC_GLOBAL_t *const global_ptr, const XMC_VADC_GLOBAL_CONFIG_t *config)
{
 80233fc:	b538      	push	{r3, r4, r5, lr}
 80233fe:	460d      	mov	r5, r1
 8023400:	4604      	mov	r4, r0
#if defined (COMPARATOR)
  COMPARATOR->ORCCTRL = (uint32_t)0xFF;
#endif

#if defined(CLOCK_GATING_SUPPORTED)
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_VADC);
 8023402:	2001      	movs	r0, #1
 8023404:	f7fd fe82 	bl	802110c <XMC_SCU_CLOCK_UngatePeripheralClock>
#endif

#if defined(PERIPHERAL_RESET_SUPPORTED)
  /* Reset the Hardware */
  XMC_SCU_RESET_DeassertPeripheralReset((XMC_SCU_PERIPHERAL_RESET_t)XMC_SCU_PERIPHERAL_RESET_VADC );
 8023408:	2001      	movs	r0, #1
 802340a:	f7fd fe03 	bl	8021014 <XMC_SCU_RESET_DeassertPeripheralReset>
  XMC_ASSERT("XMC_VADC_GLOBAL_Init:Wrong Module Pointer", (global_ptr == VADC))

  /* Enable the VADC module*/
  XMC_VADC_GLOBAL_EnableModule();

  global_ptr->CLC = (uint32_t)(config->clc);
 802340e:	696b      	ldr	r3, [r5, #20]
 8023410:	6023      	str	r3, [r4, #0]

  /* Clock configuration */

#if (XMC_VADC_GROUP_AVAILABLE == 1U)
  global_ptr->GLOBCFG  = (uint32_t)(config->clock_config.globcfg | (uint32_t)(VADC_GLOBCFG_DIVWC_Msk));
 8023412:	686b      	ldr	r3, [r5, #4]
 8023414:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8023418:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
#endif

  /* ICLASS-0 configuration */
  global_ptr->GLOBICLASS[0] = (uint32_t)(config->class0.globiclass);
 802341c:	68ab      	ldr	r3, [r5, #8]
 802341e:	f8c4 30a0 	str.w	r3, [r4, #160]	; 0xa0

  /* ICLASS-1 configuration */
  global_ptr->GLOBICLASS[1] = (uint32_t)(config->class1.globiclass);
 8023422:	68eb      	ldr	r3, [r5, #12]
 8023424:	f8c4 30a4 	str.w	r3, [r4, #164]	; 0xa4


  /*Result generation related configuration */
  global_ptr->GLOBRCR = (uint32_t)(config->globrcr);
 8023428:	692b      	ldr	r3, [r5, #16]
 802342a:	f8c4 3280 	str.w	r3, [r4, #640]	; 0x280

#if (XMC_VADC_BOUNDARY_AVAILABLE == 1U)

  /* Boundaries */
  global_ptr->GLOBBOUND = (uint32_t)(config->globbound);
 802342e:	682b      	ldr	r3, [r5, #0]
 8023430:	f8c4 30b8 	str.w	r3, [r4, #184]	; 0xb8
 8023434:	bd38      	pop	{r3, r4, r5, pc}
 8023436:	bf00      	nop

08023438 <XMC_VADC_GLOBAL_InputClassInit>:
  XMC_ASSERT("XMC_VADC_GLOBAL_InputClassInit:Wrong Module Pointer", (global_ptr == VADC))
  XMC_ASSERT("XMC_VADC_GLOBAL_InputClassInit:Wrong Conversion Type", ((conv_type) <= XMC_VADC_GROUP_CONV_EMUX))
  XMC_ASSERT("XMC_VADC_GLOBAL_InputClassInit:Wrong ICLASS set number", (set_num < XMC_VADC_MAX_ICLASS_SET))

#if(XMC_VADC_EMUX_AVAILABLE == 1U)
  if (conv_type == XMC_VADC_GROUP_CONV_STD )
 8023438:	b12a      	cbz	r2, 8023446 <XMC_VADC_GLOBAL_InputClassInit+0xe>
                                      (uint32_t)(VADC_GLOBICLASS_CMS_Msk | VADC_GLOBICLASS_STCS_Msk);
#if(XMC_VADC_EMUX_AVAILABLE == 1U)
  }
  else
  {
    global_ptr->GLOBICLASS[set_num] = config.globiclass & (uint32_t)(VADC_GLOBICLASS_CME_Msk | VADC_GLOBICLASS_STCE_Msk);
 802343a:	4a06      	ldr	r2, [pc, #24]	; (8023454 <XMC_VADC_GLOBAL_InputClassInit+0x1c>)
 802343c:	3328      	adds	r3, #40	; 0x28
 802343e:	400a      	ands	r2, r1
 8023440:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
 8023444:	4770      	bx	lr

#if(XMC_VADC_EMUX_AVAILABLE == 1U)
  if (conv_type == XMC_VADC_GROUP_CONV_STD )
  {
#endif
    global_ptr->GLOBICLASS[set_num] = config.globiclass &
 8023446:	3328      	adds	r3, #40	; 0x28
 8023448:	f240 721f 	movw	r2, #1823	; 0x71f
 802344c:	400a      	ands	r2, r1
 802344e:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
 8023452:	4770      	bx	lr
 8023454:	071f0000 	.word	0x071f0000

08023458 <XMC_VADC_GLOBAL_StartupCalibration>:
  VADC_G_TypeDef *group_ptr;
#endif
  
  XMC_ASSERT("XMC_VADC_GLOBAL_StartupCalibration:Wrong Module Pointer", (global_ptr == VADC))

  global_ptr->GLOBCFG |= (uint32_t)VADC_GLOBCFG_SUCAL_Msk;
 8023458:	f8d0 3080 	ldr.w	r3, [r0, #128]	; 0x80
 802345c:	490c      	ldr	r1, [pc, #48]	; (8023490 <XMC_VADC_GLOBAL_StartupCalibration+0x38>)
 802345e:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8023462:	f8c0 3080 	str.w	r3, [r0, #128]	; 0x80
 8023466:	f101 0010 	add.w	r0, r1, #16

#if (XMC_VADC_GROUP_AVAILABLE == 1U)
  /* Loop until all active groups finish calibration */
  for(i=0U; i<XMC_VADC_MAXIMUM_NUM_GROUPS; i++)
  {
    group_ptr = g_xmc_vadc_group_array[i];
 802346a:	f851 2b04 	ldr.w	r2, [r1], #4
    if ( (group_ptr->ARBCFG) & (uint32_t)VADC_G_ARBCFG_ANONS_Msk)
 802346e:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
 8023472:	f413 3f40 	tst.w	r3, #196608	; 0x30000
 8023476:	d102      	bne.n	802347e <XMC_VADC_GLOBAL_StartupCalibration+0x26>

  global_ptr->GLOBCFG |= (uint32_t)VADC_GLOBCFG_SUCAL_Msk;

#if (XMC_VADC_GROUP_AVAILABLE == 1U)
  /* Loop until all active groups finish calibration */
  for(i=0U; i<XMC_VADC_MAXIMUM_NUM_GROUPS; i++)
 8023478:	4281      	cmp	r1, r0
 802347a:	d1f6      	bne.n	802346a <XMC_VADC_GLOBAL_StartupCalibration+0x12>
         XMC_VADC_SHS_START_UP_CAL_ACTIVE )
  {
    /* NOP */
  }
#endif
}
 802347c:	4770      	bx	lr
  {
    group_ptr = g_xmc_vadc_group_array[i];
    if ( (group_ptr->ARBCFG) & (uint32_t)VADC_G_ARBCFG_ANONS_Msk)
    {
      /* This group is active. Loop until it finishes calibration */
      while((group_ptr->ARBCFG) & (uint32_t)VADC_G_ARBCFG_CAL_Msk)
 802347e:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
 8023482:	00db      	lsls	r3, r3, #3
 8023484:	d5f8      	bpl.n	8023478 <XMC_VADC_GLOBAL_StartupCalibration+0x20>
 8023486:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
 802348a:	00db      	lsls	r3, r3, #3
 802348c:	d4f7      	bmi.n	802347e <XMC_VADC_GLOBAL_StartupCalibration+0x26>
 802348e:	e7f3      	b.n	8023478 <XMC_VADC_GLOBAL_StartupCalibration+0x20>
 8023490:	0802d834 	.word	0x0802d834

08023494 <XMC_VADC_GROUP_Init>:
}

/* API to initialize an instance of group of VADC hardware */
#if (XMC_VADC_GROUP_AVAILABLE == 1U)  
void XMC_VADC_GROUP_Init( XMC_VADC_GROUP_t *const group_ptr, const XMC_VADC_GROUP_CONFIG_t *config)
{
 8023494:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8023498:	794b      	ldrb	r3, [r1, #5]
    sample_time      = (uint32_t) config.sampling_phase_emux_channel;
    conv_mode        = (XMC_VADC_CONVMODE_t)config.conversion_mode_emux;
  }

  /* Determine the class */
  conv_class  = group_ptr->ICLASS[set_num];
 802349a:	f8d0 50a0 	ldr.w	r5, [r0, #160]	; 0xa0
 802349e:	f891 a004 	ldrb.w	sl, [r1, #4]
 80234a2:	78ce      	ldrb	r6, [r1, #3]
 80234a4:	7acc      	ldrb	r4, [r1, #11]
 80234a6:	f891 b007 	ldrb.w	fp, [r1, #7]
 80234aa:	f891 9006 	ldrb.w	r9, [r1, #6]
 80234ae:	f891 8009 	ldrb.w	r8, [r1, #9]
 80234b2:	7a0a      	ldrb	r2, [r1, #8]
 80234b4:	f891 c00a 	ldrb.w	ip, [r1, #10]
 80234b8:	f8b1 e002 	ldrh.w	lr, [r1, #2]
 80234bc:	780f      	ldrb	r7, [r1, #0]

  /* Program the class register */
  conv_class &= ~(conv_mode_mask);
 80234be:	f425 65e0 	bic.w	r5, r5, #1792	; 0x700
  conv_class |= (uint32_t)((uint32_t) conv_mode << conv_mode_pos);
 80234c2:	f003 0307 	and.w	r3, r3, #7
 80234c6:	ea45 2303 	orr.w	r3, r5, r3, lsl #8
  conv_class &= ~(sample_time_mask);
 80234ca:	f023 031f 	bic.w	r3, r3, #31
  {
    conv_mode_pos    = (uint32_t) VADC_G_ICLASS_CMS_Pos;
    conv_mode_mask   = (uint32_t) VADC_G_ICLASS_CMS_Msk;
    sample_time_pos  = (uint32_t) VADC_G_ICLASS_STCS_Pos;
    sample_time_mask = (uint32_t) VADC_G_ICLASS_STCS_Msk;
    sample_time      = (uint32_t) config.sample_time_std_conv;
 80234ce:	f00a 0a1f 	and.w	sl, sl, #31

  /* Program the class register */
  conv_class &= ~(conv_mode_mask);
  conv_class |= (uint32_t)((uint32_t) conv_mode << conv_mode_pos);
  conv_class &= ~(sample_time_mask);
  conv_class |= (uint32_t)(sample_time <<  sample_time_pos);
 80234d2:	ea43 050a 	orr.w	r5, r3, sl
  group_ptr->ICLASS[set_num] = conv_class;
 80234d6:	f8c0 50a0 	str.w	r5, [r0, #160]	; 0xa0
    sample_time      = (uint32_t) config.sampling_phase_emux_channel;
    conv_mode        = (XMC_VADC_CONVMODE_t)config.conversion_mode_emux;
  }

  /* Determine the class */
  conv_class  = group_ptr->ICLASS[set_num];
 80234da:	f8d0 30a0 	ldr.w	r3, [r0, #160]	; 0xa0

  /* Program the class register */
  conv_class &= ~(conv_mode_mask);
  conv_class |= (uint32_t)((uint32_t) conv_mode << conv_mode_pos);
 80234de:	f00b 0b07 	and.w	fp, fp, #7

  /* Determine the class */
  conv_class  = group_ptr->ICLASS[set_num];

  /* Program the class register */
  conv_class &= ~(conv_mode_mask);
 80234e2:	f023 63e0 	bic.w	r3, r3, #117440512	; 0x7000000
  conv_class |= (uint32_t)((uint32_t) conv_mode << conv_mode_pos);
 80234e6:	ea43 630b 	orr.w	r3, r3, fp, lsl #24
  conv_class &= ~(sample_time_mask);
 80234ea:	f423 13f8 	bic.w	r3, r3, #2031616	; 0x1f0000
  {
    conv_mode_pos    = (uint32_t) VADC_G_ICLASS_CME_Pos;
    conv_mode_mask   = (uint32_t) VADC_G_ICLASS_CME_Msk;
    sample_time_pos  = (uint32_t) VADC_G_ICLASS_STCE_Pos;
    sample_time_mask = (uint32_t) VADC_G_ICLASS_STCE_Msk;
    sample_time      = (uint32_t) config.sampling_phase_emux_channel;
 80234ee:	f009 051f 	and.w	r5, r9, #31

  /* Program the class register */
  conv_class &= ~(conv_mode_mask);
  conv_class |= (uint32_t)((uint32_t) conv_mode << conv_mode_pos);
  conv_class &= ~(sample_time_mask);
  conv_class |= (uint32_t)(sample_time <<  sample_time_pos);
 80234f2:	ea43 4505 	orr.w	r5, r3, r5, lsl #16
  group_ptr->ICLASS[set_num] = conv_class;
 80234f6:	f8c0 50a0 	str.w	r5, [r0, #160]	; 0xa0
    sample_time      = (uint32_t) config.sampling_phase_emux_channel;
    conv_mode        = (XMC_VADC_CONVMODE_t)config.conversion_mode_emux;
  }

  /* Determine the class */
  conv_class  = group_ptr->ICLASS[set_num];
 80234fa:	f8d0 30a4 	ldr.w	r3, [r0, #164]	; 0xa4

  /* Program the class register */
  conv_class &= ~(conv_mode_mask);
  conv_class |= (uint32_t)((uint32_t) conv_mode << conv_mode_pos);
 80234fe:	f008 0807 	and.w	r8, r8, #7

  /* Determine the class */
  conv_class  = group_ptr->ICLASS[set_num];

  /* Program the class register */
  conv_class &= ~(conv_mode_mask);
 8023502:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
  conv_class |= (uint32_t)((uint32_t) conv_mode << conv_mode_pos);
 8023506:	ea43 2308 	orr.w	r3, r3, r8, lsl #8
  {
    conv_mode_pos    = (uint32_t) VADC_G_ICLASS_CMS_Pos;
    conv_mode_mask   = (uint32_t) VADC_G_ICLASS_CMS_Msk;
    sample_time_pos  = (uint32_t) VADC_G_ICLASS_STCS_Pos;
    sample_time_mask = (uint32_t) VADC_G_ICLASS_STCS_Msk;
    sample_time      = (uint32_t) config.sample_time_std_conv;
 802350a:	f002 021f 	and.w	r2, r2, #31
  conv_class  = group_ptr->ICLASS[set_num];

  /* Program the class register */
  conv_class &= ~(conv_mode_mask);
  conv_class |= (uint32_t)((uint32_t) conv_mode << conv_mode_pos);
  conv_class &= ~(sample_time_mask);
 802350e:	f023 031f 	bic.w	r3, r3, #31
  conv_class |= (uint32_t)(sample_time <<  sample_time_pos);
 8023512:	4313      	orrs	r3, r2
  group_ptr->ICLASS[set_num] = conv_class;
 8023514:	f8c0 30a4 	str.w	r3, [r0, #164]	; 0xa4
    sample_time      = (uint32_t) config.sampling_phase_emux_channel;
    conv_mode        = (XMC_VADC_CONVMODE_t)config.conversion_mode_emux;
  }

  /* Determine the class */
  conv_class  = group_ptr->ICLASS[set_num];
 8023518:	f8d0 50a4 	ldr.w	r5, [r0, #164]	; 0xa4

  /* Program the class register */
  conv_class &= ~(conv_mode_mask);
  conv_class |= (uint32_t)((uint32_t) conv_mode << conv_mode_pos);
 802351c:	f004 0207 	and.w	r2, r4, #7

  /* Determine the class */
  conv_class  = group_ptr->ICLASS[set_num];

  /* Program the class register */
  conv_class &= ~(conv_mode_mask);
 8023520:	f025 64e0 	bic.w	r4, r5, #117440512	; 0x7000000
  conv_class |= (uint32_t)((uint32_t) conv_mode << conv_mode_pos);
 8023524:	ea44 6402 	orr.w	r4, r4, r2, lsl #24
  conv_class &= ~(sample_time_mask);
 8023528:	f424 14f8 	bic.w	r4, r4, #2031616	; 0x1f0000
  {
    conv_mode_pos    = (uint32_t) VADC_G_ICLASS_CME_Pos;
    conv_mode_mask   = (uint32_t) VADC_G_ICLASS_CME_Msk;
    sample_time_pos  = (uint32_t) VADC_G_ICLASS_STCE_Pos;
    sample_time_mask = (uint32_t) VADC_G_ICLASS_STCE_Msk;
    sample_time      = (uint32_t) config.sampling_phase_emux_channel;
 802352c:	f00c 021f 	and.w	r2, ip, #31

  /* Program the class register */
  conv_class &= ~(conv_mode_mask);
  conv_class |= (uint32_t)((uint32_t) conv_mode << conv_mode_pos);
  conv_class &= ~(sample_time_mask);
  conv_class |= (uint32_t)(sample_time <<  sample_time_pos);
 8023530:	ea44 4202 	orr.w	r2, r4, r2, lsl #16
  group_ptr->ICLASS[set_num] = conv_class;
 8023534:	f8c0 20a4 	str.w	r2, [r0, #164]	; 0xa4
  XMC_VADC_GROUP_InputClassInit(group_ptr, config->class0, XMC_VADC_GROUP_CONV_STD, 0U);
  XMC_VADC_GROUP_InputClassInit(group_ptr, config->class0, XMC_VADC_GROUP_CONV_EMUX, 0U);
  XMC_VADC_GROUP_InputClassInit(group_ptr, config->class1, XMC_VADC_GROUP_CONV_STD, 1U);
  XMC_VADC_GROUP_InputClassInit(group_ptr, config->class1, XMC_VADC_GROUP_CONV_EMUX, 1U);

  group_ptr->ARBCFG = config->g_arbcfg;
 8023538:	690b      	ldr	r3, [r1, #16]
 802353a:	f8c0 3080 	str.w	r3, [r0, #128]	; 0x80
  uint32_t   emux_config;

  XMC_ASSERT("XMC_VADC_GROUP_ExternalMuxControlInit:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))

  emux_config = ((uint32_t)emux_cfg.starting_external_channel << (uint32_t)VADC_G_EMUXCTR_EMUXSET_Pos) |
              ((uint32_t)emux_cfg.connected_channel << (uint32_t)VADC_G_EMUXCTR_EMUXCH_Pos);
 802353e:	f3ce 0e09 	ubfx	lr, lr, #0, #10
{
  uint32_t   emux_config;

  XMC_ASSERT("XMC_VADC_GROUP_ExternalMuxControlInit:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))

  emux_config = ((uint32_t)emux_cfg.starting_external_channel << (uint32_t)VADC_G_EMUXCTR_EMUXSET_Pos) |
 8023542:	f007 0707 	and.w	r7, r7, #7

  group_ptr->BOUND = config->g_bound;
 8023546:	68cb      	ldr	r3, [r1, #12]
 8023548:	f8c0 30b8 	str.w	r3, [r0, #184]	; 0xb8
 802354c:	ea47 470e 	orr.w	r7, r7, lr, lsl #16
              ((uint32_t)emux_cfg.connected_channel << (uint32_t)VADC_G_EMUXCTR_EMUXCH_Pos);

  group_ptr->EMUXCTR  = emux_config;
 8023550:	f8c0 71f0 	str.w	r7, [r0, #496]	; 0x1f0
                ((uint32_t)emux_cfg.stce_usage << (uint32_t)VADC_G_EMUXCTR_EMXST_Pos);

#if (XMC_VADC_EMUX_CH_SEL_STYLE == 1U)
  emux_config |= ((uint32_t)emux_cfg.emux_channel_select_style << (uint32_t)VADC_G_EMUXCTR_EMXCSS_Pos);
#endif
  group_ptr->EMUXCTR  |= (emux_config | ((uint32_t)VADC_G_EMUXCTR_EMXWC_Msk)) ;
 8023554:	f8d0 21f0 	ldr.w	r2, [r0, #496]	; 0x1f0
 8023558:	f3c6 1300 	ubfx	r3, r6, #4, #1
 802355c:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
 8023560:	ea42 7203 	orr.w	r2, r2, r3, lsl #28
 8023564:	f3c6 0381 	ubfx	r3, r6, #2, #2
 8023568:	ea42 6283 	orr.w	r2, r2, r3, lsl #26
 802356c:	f3c6 1340 	ubfx	r3, r6, #5, #1
 8023570:	ea42 7243 	orr.w	r2, r2, r3, lsl #29
 8023574:	f3c6 1380 	ubfx	r3, r6, #6, #1
 8023578:	ea42 7383 	orr.w	r3, r2, r3, lsl #30
 802357c:	f8c0 31f0 	str.w	r3, [r0, #496]	; 0x1f0
 8023580:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08023584 <XMC_VADC_GROUP_InputClassInit>:
}

/* API to program conversion characteristics */
void XMC_VADC_GROUP_InputClassInit(XMC_VADC_GROUP_t *const group_ptr, const XMC_VADC_GROUP_CLASS_t config,
                                          const XMC_VADC_GROUP_CONV_t conv_type, const uint32_t set_num)
{
 8023584:	b4f0      	push	{r4, r5, r6, r7}

  /* 
   * Obtain the mask and position macros of the parameters based on what is being requested - Standard channels vs
   * external mux channels.
   */
  if (XMC_VADC_GROUP_CONV_STD == conv_type)
 8023586:	b1ba      	cbz	r2, 80235b8 <XMC_VADC_GROUP_InputClassInit+0x34>
  {
    conv_mode_pos    = (uint32_t) VADC_G_ICLASS_CME_Pos;
    conv_mode_mask   = (uint32_t) VADC_G_ICLASS_CME_Msk;
    sample_time_pos  = (uint32_t) VADC_G_ICLASS_STCE_Pos;
    sample_time_mask = (uint32_t) VADC_G_ICLASS_STCE_Msk;
    sample_time      = (uint32_t) config.sampling_phase_emux_channel;
 8023588:	f3c1 4204 	ubfx	r2, r1, #16, #5
    conv_mode        = (XMC_VADC_CONVMODE_t)config.conversion_mode_emux;
 802358c:	2510      	movs	r5, #16
 802358e:	f3c1 6102 	ubfx	r1, r1, #24, #3
 8023592:	f46f 16f8 	mvn.w	r6, #2031616	; 0x1f0000
 8023596:	2418      	movs	r4, #24
 8023598:	f06f 67e0 	mvn.w	r7, #117440512	; 0x7000000
 802359c:	eb00 0383 	add.w	r3, r0, r3, lsl #2
  /* Determine the class */
  conv_class  = group_ptr->ICLASS[set_num];

  /* Program the class register */
  conv_class &= ~(conv_mode_mask);
  conv_class |= (uint32_t)((uint32_t) conv_mode << conv_mode_pos);
 80235a0:	40a1      	lsls	r1, r4
    sample_time      = (uint32_t) config.sampling_phase_emux_channel;
    conv_mode        = (XMC_VADC_CONVMODE_t)config.conversion_mode_emux;
  }

  /* Determine the class */
  conv_class  = group_ptr->ICLASS[set_num];
 80235a2:	f8d3 40a0 	ldr.w	r4, [r3, #160]	; 0xa0

  /* Program the class register */
  conv_class &= ~(conv_mode_mask);
 80235a6:	403c      	ands	r4, r7
  conv_class |= (uint32_t)((uint32_t) conv_mode << conv_mode_pos);
 80235a8:	4321      	orrs	r1, r4
  conv_class &= ~(sample_time_mask);
  conv_class |= (uint32_t)(sample_time <<  sample_time_pos);
 80235aa:	40aa      	lsls	r2, r5
  conv_class  = group_ptr->ICLASS[set_num];

  /* Program the class register */
  conv_class &= ~(conv_mode_mask);
  conv_class |= (uint32_t)((uint32_t) conv_mode << conv_mode_pos);
  conv_class &= ~(sample_time_mask);
 80235ac:	4031      	ands	r1, r6
  conv_class |= (uint32_t)(sample_time <<  sample_time_pos);
 80235ae:	4311      	orrs	r1, r2
  group_ptr->ICLASS[set_num] = conv_class;
 80235b0:	f8c3 10a0 	str.w	r1, [r3, #160]	; 0xa0
}
 80235b4:	bcf0      	pop	{r4, r5, r6, r7}
 80235b6:	4770      	bx	lr
 80235b8:	4615      	mov	r5, r2
 80235ba:	f06f 061f 	mvn.w	r6, #31
  {
    conv_mode_pos    = (uint32_t) VADC_G_ICLASS_CMS_Pos;
    conv_mode_mask   = (uint32_t) VADC_G_ICLASS_CMS_Msk;
    sample_time_pos  = (uint32_t) VADC_G_ICLASS_STCS_Pos;
    sample_time_mask = (uint32_t) VADC_G_ICLASS_STCS_Msk;
    sample_time      = (uint32_t) config.sample_time_std_conv;
 80235be:	f001 021f 	and.w	r2, r1, #31
 80235c2:	2408      	movs	r4, #8
    conv_mode        = (XMC_VADC_CONVMODE_t)config.conversion_mode_standard;
 80235c4:	f3c1 2102 	ubfx	r1, r1, #8, #3
 80235c8:	f46f 67e0 	mvn.w	r7, #1792	; 0x700
 80235cc:	e7e6      	b.n	802359c <XMC_VADC_GROUP_InputClassInit+0x18>
 80235ce:	bf00      	nop

080235d0 <XMC_VADC_GROUP_SetPowerMode>:
  uint32_t arbcfg;

  XMC_ASSERT("XMC_VADC_GROUP_SetPowerMode:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  XMC_ASSERT("XMC_VADC_GROUP_SetPowerMode:Wrong Power Mode", (power_mode <= XMC_VADC_GROUP_POWERMODE_NORMAL))

  arbcfg = group_ptr->ARBCFG;
 80235d0:	f8d0 3080 	ldr.w	r3, [r0, #128]	; 0x80

  arbcfg &= ~((uint32_t)VADC_G_ARBCFG_ANONC_Msk);
 80235d4:	f023 0303 	bic.w	r3, r3, #3
  arbcfg |= (uint32_t)power_mode;
 80235d8:	4319      	orrs	r1, r3

  group_ptr->ARBCFG = arbcfg;
 80235da:	f8c0 1080 	str.w	r1, [r0, #128]	; 0x80
 80235de:	4770      	bx	lr

080235e0 <XMC_VADC_GROUP_SetSyncSlave>:
    master_grp = master_grp + 1U;
  }
  #endif
  
  /* Program SYNCTR */
  synctr = group_ptr->SYNCTR;
 80235e0:	f8d0 30c0 	ldr.w	r3, [r0, #192]	; 0xc0
  XMC_ASSERT("XMC_VADC_GROUP_SetSyncSlave:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  
  #if (XMC_VADC_MULTIPLE_SLAVEGROUPS == 1U )

  /* Determine the coding of SYNCTR */
  if (slave_grp > master_grp)
 80235e4:	428a      	cmp	r2, r1
  {
    master_grp = master_grp + 1U;
 80235e6:	bf88      	it	hi
 80235e8:	3101      	addhi	r1, #1
  }
  #endif
  
  /* Program SYNCTR */
  synctr = group_ptr->SYNCTR;
  synctr   &= ~((uint32_t)VADC_G_SYNCTR_STSEL_Msk);
 80235ea:	f023 0303 	bic.w	r3, r3, #3
  synctr   |= master_grp;
 80235ee:	4319      	orrs	r1, r3
  group_ptr->SYNCTR = synctr;
 80235f0:	f8c0 10c0 	str.w	r1, [r0, #192]	; 0xc0
 80235f4:	4770      	bx	lr
 80235f6:	bf00      	nop

080235f8 <XMC_VADC_GROUP_SetSyncMaster>:
{
  uint32_t synctr;

  XMC_ASSERT("XMC_VADC_GROUP_SetSyncMaster:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))

  synctr = group_ptr->SYNCTR;
 80235f8:	f8d0 30c0 	ldr.w	r3, [r0, #192]	; 0xc0
  synctr   &= ~((uint32_t)VADC_G_SYNCTR_STSEL_Msk);
 80235fc:	f023 0303 	bic.w	r3, r3, #3
  group_ptr->SYNCTR = synctr;
 8023600:	f8c0 30c0 	str.w	r3, [r0, #192]	; 0xc0
 8023604:	4770      	bx	lr
 8023606:	bf00      	nop

08023608 <XMC_VADC_GROUP_CheckSlaveReadiness>:
  XMC_ASSERT("XMC_VADC_GROUP_CheckSlaveReadiness:Wrong Slave group", ((slave_group >= 0) && (slave_group <= (XMC_VADC_MAXIMUM_NUM_GROUPS - 1))))

  master_grp_num =0;
  for(i=0; i<XMC_VADC_MAXIMUM_NUM_GROUPS; i++)
  {
    if(g_xmc_vadc_group_array[i] == group_ptr)
 8023608:	4b0e      	ldr	r3, [pc, #56]	; (8023644 <XMC_VADC_GROUP_CheckSlaveReadiness+0x3c>)
 802360a:	4298      	cmp	r0, r3
 802360c:	d010      	beq.n	8023630 <XMC_VADC_GROUP_CheckSlaveReadiness+0x28>
 802360e:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8023612:	4298      	cmp	r0, r3
 8023614:	d011      	beq.n	802363a <XMC_VADC_GROUP_CheckSlaveReadiness+0x32>
 8023616:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 802361a:	4298      	cmp	r0, r3
 802361c:	d00f      	beq.n	802363e <XMC_VADC_GROUP_CheckSlaveReadiness+0x36>

  if(slave_group < master_grp_num)
  {
    slave_group++;
  }
  group_ptr->SYNCTR |= (1U << (slave_group + XMC_VADC_SYNCTR_START_LOCATION));
 802361e:	f8d0 20c0 	ldr.w	r2, [r0, #192]	; 0xc0
 8023622:	3103      	adds	r1, #3
 8023624:	2301      	movs	r3, #1
 8023626:	408b      	lsls	r3, r1
 8023628:	4313      	orrs	r3, r2
 802362a:	f8c0 30c0 	str.w	r3, [r0, #192]	; 0xc0
 802362e:	4770      	bx	lr
  uint32_t i,master_grp_num;
  XMC_ASSERT("XMC_VADC_GROUP_CheckSlaveReadiness:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  XMC_ASSERT("XMC_VADC_GROUP_CheckSlaveReadiness:Wrong Slave group", ((slave_group >= 0) && (slave_group <= (XMC_VADC_MAXIMUM_NUM_GROUPS - 1))))

  master_grp_num =0;
  for(i=0; i<XMC_VADC_MAXIMUM_NUM_GROUPS; i++)
 8023630:	2301      	movs	r3, #1
      master_grp_num = i;
    }
  }


  if(slave_group < master_grp_num)
 8023632:	4299      	cmp	r1, r3
  {
    slave_group++;
 8023634:	bf38      	it	cc
 8023636:	3101      	addcc	r1, #1
 8023638:	e7f1      	b.n	802361e <XMC_VADC_GROUP_CheckSlaveReadiness+0x16>
  uint32_t i,master_grp_num;
  XMC_ASSERT("XMC_VADC_GROUP_CheckSlaveReadiness:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  XMC_ASSERT("XMC_VADC_GROUP_CheckSlaveReadiness:Wrong Slave group", ((slave_group >= 0) && (slave_group <= (XMC_VADC_MAXIMUM_NUM_GROUPS - 1))))

  master_grp_num =0;
  for(i=0; i<XMC_VADC_MAXIMUM_NUM_GROUPS; i++)
 802363a:	2302      	movs	r3, #2
 802363c:	e7f9      	b.n	8023632 <XMC_VADC_GROUP_CheckSlaveReadiness+0x2a>
 802363e:	2303      	movs	r3, #3
 8023640:	e7f7      	b.n	8023632 <XMC_VADC_GROUP_CheckSlaveReadiness+0x2a>
 8023642:	bf00      	nop
 8023644:	40004800 	.word	0x40004800

08023648 <XMC_VADC_GROUP_SetSyncSlaveReadySignal>:
                                            uint32_t eval_origin_group)
{
  XMC_ASSERT("XMC_VADC_GROUP_SetSyncSlaveReadySignal:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  XMC_ASSERT("XMC_VADC_GROUP_SetSyncSlaveReadySignal:Wrong Group numbers", (eval_waiting_group == eval_origin_group ))

  if(eval_origin_group < eval_waiting_group)
 8023648:	428a      	cmp	r2, r1
  {
	  eval_origin_group++;
 802364a:	bf38      	it	cc
 802364c:	3201      	addcc	r2, #1
  }
  group_ptr->SYNCTR |= (1U << (eval_origin_group + XMC_VADC_SYNCTR_START_LOCATION));
 802364e:	f8d0 10c0 	ldr.w	r1, [r0, #192]	; 0xc0
 8023652:	3203      	adds	r2, #3
 8023654:	2301      	movs	r3, #1
 8023656:	4093      	lsls	r3, r2
 8023658:	430b      	orrs	r3, r1
 802365a:	f8c0 30c0 	str.w	r3, [r0, #192]	; 0xc0
 802365e:	4770      	bx	lr

08023660 <XMC_VADC_GROUP_ScanInit>:
 *  XMC_VADC_GROUP_ScanEnableArbitrationSlot()<BR>
 */
__STATIC_INLINE void XMC_VADC_GROUP_ScanDisableArbitrationSlot(XMC_VADC_GROUP_t *const group_ptr)
{
  XMC_ASSERT("XMC_VADC_GROUP_ScanDisableArbitrationSlot:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  group_ptr->ARBPR &= ~((uint32_t)VADC_G_ARBPR_ASEN1_Msk);
 8023660:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
  /* Read in the existing contents of arbitration priority register */
  reg = group_ptr->ARBPR;

  /* Program the priority of the request source */
  reg &= ~(uint32_t)VADC_G_ARBPR_PRIO1_Msk;
  reg |= (uint32_t)((uint32_t)config->req_src_priority << VADC_G_ARBPR_PRIO1_Pos);
 8023664:	780a      	ldrb	r2, [r1, #0]
 8023666:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
 802366a:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84

  /* All configurations have to be performed with the arbitration slot disabled */
  XMC_VADC_GROUP_ScanDisableArbitrationSlot(group_ptr);
  
  /* Read in the existing contents of arbitration priority register */
  reg = group_ptr->ARBPR;
 802366e:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
#endif

#if (XMC_VADC_GSCAN_AVAILABLE == 1U)   
/* API to initialize the group scan hardware of a kernel */
void XMC_VADC_GROUP_ScanInit(XMC_VADC_GROUP_t *const group_ptr, const XMC_VADC_SCAN_CONFIG_t *config)
{
 8023672:	b410      	push	{r4}
  
  /* Read in the existing contents of arbitration priority register */
  reg = group_ptr->ARBPR;

  /* Program the priority of the request source */
  reg &= ~(uint32_t)VADC_G_ARBPR_PRIO1_Msk;
 8023674:	f023 0330 	bic.w	r3, r3, #48	; 0x30
  reg |= (uint32_t)((uint32_t)config->req_src_priority << VADC_G_ARBPR_PRIO1_Pos);
 8023678:	f3c2 0481 	ubfx	r4, r2, #2, #2
  
  /* Program the start mode */
  if (XMC_VADC_STARTMODE_WFS != (XMC_VADC_STARTMODE_t)(config->conv_start_mode))
 802367c:	f012 0203 	ands.w	r2, r2, #3
  /* Read in the existing contents of arbitration priority register */
  reg = group_ptr->ARBPR;

  /* Program the priority of the request source */
  reg &= ~(uint32_t)VADC_G_ARBPR_PRIO1_Msk;
  reg |= (uint32_t)((uint32_t)config->req_src_priority << VADC_G_ARBPR_PRIO1_Pos);
 8023680:	ea43 1304 	orr.w	r3, r3, r4, lsl #4
  
  /* Program the start mode */
  if (XMC_VADC_STARTMODE_WFS != (XMC_VADC_STARTMODE_t)(config->conv_start_mode))
 8023684:	d020      	beq.n	80236c8 <XMC_VADC_GROUP_ScanInit+0x68>
  {
    reg |= (uint32_t)(VADC_G_ARBPR_CSM1_Msk);
 8023686:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  }

  group_ptr->ARBPR = reg;
 802368a:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84

  group_ptr->ASCTRL = (uint32_t)(config->asctrl |(VADC_G_ASCTRL_XTWC_Msk) |(VADC_G_ASCTRL_GTWC_Msk) |
 802368e:	684b      	ldr	r3, [r1, #4]
 8023690:	f043 2380 	orr.w	r3, r3, #2147516416	; 0x80008000
 8023694:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 8023698:	f8c0 3120 	str.w	r3, [r0, #288]	; 0x120
                                                 (VADC_G_ASCTRL_TMWC_Msk));

  group_ptr->ASMR  = (uint32_t)((config->asmr)| (uint32_t)((uint32_t)XMC_VADC_GATEMODE_IGNORE << VADC_G_ASMR_ENGT_Pos));
 802369c:	688b      	ldr	r3, [r1, #8]
  
  if (XMC_VADC_STARTMODE_CNR == (XMC_VADC_STARTMODE_t)(config->conv_start_mode))
 802369e:	2a02      	cmp	r2, #2
  group_ptr->ARBPR = reg;

  group_ptr->ASCTRL = (uint32_t)(config->asctrl |(VADC_G_ASCTRL_XTWC_Msk) |(VADC_G_ASCTRL_GTWC_Msk) |
                                                 (VADC_G_ASCTRL_TMWC_Msk));

  group_ptr->ASMR  = (uint32_t)((config->asmr)| (uint32_t)((uint32_t)XMC_VADC_GATEMODE_IGNORE << VADC_G_ASMR_ENGT_Pos));
 80236a0:	f043 0301 	orr.w	r3, r3, #1
 80236a4:	f8c0 3124 	str.w	r3, [r0, #292]	; 0x124
  
  if (XMC_VADC_STARTMODE_CNR == (XMC_VADC_STARTMODE_t)(config->conv_start_mode))
 80236a8:	d105      	bne.n	80236b6 <XMC_VADC_GROUP_ScanInit+0x56>
  {
    group_ptr->ASMR |= (uint32_t)VADC_G_ASMR_RPTDIS_Msk;
 80236aa:	f8d0 3124 	ldr.w	r3, [r0, #292]	; 0x124
 80236ae:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80236b2:	f8c0 3124 	str.w	r3, [r0, #292]	; 0x124
 *  XMC_VADC_GROUP_ScanDisableArbitrationSlot()<BR>
 */
__STATIC_INLINE void XMC_VADC_GROUP_ScanEnableArbitrationSlot(XMC_VADC_GROUP_t *const group_ptr)
{
  XMC_ASSERT("XMC_VADC_GROUP_ScanEnableArbitrationSlot:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  group_ptr->ARBPR |= (uint32_t)VADC_G_ARBPR_ASEN1_Msk;
 80236b6:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
  }
  
  /* Enable arbitration slot now */
  XMC_VADC_GROUP_ScanEnableArbitrationSlot(group_ptr);
  
}
 80236ba:	f85d 4b04 	ldr.w	r4, [sp], #4
 80236be:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 80236c2:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
 80236c6:	4770      	bx	lr
  if (XMC_VADC_STARTMODE_WFS != (XMC_VADC_STARTMODE_t)(config->conv_start_mode))
  {
    reg |= (uint32_t)(VADC_G_ARBPR_CSM1_Msk);
  }

  group_ptr->ARBPR = reg;
 80236c8:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84

  group_ptr->ASCTRL = (uint32_t)(config->asctrl |(VADC_G_ASCTRL_XTWC_Msk) |(VADC_G_ASCTRL_GTWC_Msk) |
 80236cc:	684b      	ldr	r3, [r1, #4]
 80236ce:	f043 2380 	orr.w	r3, r3, #2147516416	; 0x80008000
 80236d2:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 80236d6:	f8c0 3120 	str.w	r3, [r0, #288]	; 0x120
                                                 (VADC_G_ASCTRL_TMWC_Msk));

  group_ptr->ASMR  = (uint32_t)((config->asmr)| (uint32_t)((uint32_t)XMC_VADC_GATEMODE_IGNORE << VADC_G_ASMR_ENGT_Pos));
 80236da:	688b      	ldr	r3, [r1, #8]
 80236dc:	f043 0301 	orr.w	r3, r3, #1
 80236e0:	f8c0 3124 	str.w	r3, [r0, #292]	; 0x124
 80236e4:	e7e7      	b.n	80236b6 <XMC_VADC_GROUP_ScanInit+0x56>
 80236e6:	bf00      	nop

080236e8 <XMC_VADC_GROUP_ScanSetReqSrcEventInterruptNode>:

/* API to select a service request line (NVIC Node) for request source event */
void XMC_VADC_GROUP_ScanSetReqSrcEventInterruptNode(XMC_VADC_GROUP_t *const group_ptr, const XMC_VADC_SR_t sr)
{
  uint32_t sevnp;
  sevnp = group_ptr->SEVNP;
 80236e8:	f8d0 31c0 	ldr.w	r3, [r0, #448]	; 0x1c0

  XMC_ASSERT("XMC_VADC_GROUP_ScanSetReqSrcEventInterruptNode:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  XMC_ASSERT("XMC_VADC_GROUP_ScanSetReqSrcEventInterruptNode:Wrong Service Request", ((sr)  <= XMC_VADC_SR_SHARED_SR3))

  sevnp &= ~((uint32_t)VADC_G_SEVNP_SEV1NP_Msk);
 80236ec:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
  sevnp |= (uint32_t)((uint32_t)sr << VADC_G_SEVNP_SEV1NP_Pos);
 80236f0:	ea43 1101 	orr.w	r1, r3, r1, lsl #4

  group_ptr->SEVNP = sevnp;
 80236f4:	f8c0 11c0 	str.w	r1, [r0, #448]	; 0x1c0
 80236f8:	4770      	bx	lr
 80236fa:	bf00      	nop

080236fc <XMC_VADC_GROUP_QueueInit>:
 *  XMC_VADC_GROUP_QueueEnableArbitrationSlot()<BR>
 */
__STATIC_INLINE void XMC_VADC_GROUP_QueueDisableArbitrationSlot(XMC_VADC_GROUP_t *const group_ptr)
{
  XMC_ASSERT("XMC_VADC_GROUP_QueueDisableArbitrationSlot:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr));
  group_ptr->ARBPR &= ~((uint32_t)VADC_G_ARBPR_ASEN0_Msk);
 80236fc:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
  
  reg = group_ptr->ARBPR;

  /* Request Source priority */
  reg &= ~((uint32_t)VADC_G_ARBPR_PRIO0_Msk);
  reg |= (uint32_t) ((uint32_t)config->req_src_priority << VADC_G_ARBPR_PRIO0_Pos);
 8023700:	780a      	ldrb	r2, [r1, #0]
 8023702:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 8023706:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
  XMC_ASSERT("XMC_VADC_GROUP_QueueInit:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))

  /* Disable arbitration slot of the queue request source */
  XMC_VADC_GROUP_QueueDisableArbitrationSlot(group_ptr);
  
  reg = group_ptr->ARBPR;
 802370a:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
}

#if (XMC_VADC_QUEUE_AVAILABLE == 1U)  
/* API to initialize queue request source */
void XMC_VADC_GROUP_QueueInit(XMC_VADC_GROUP_t *const group_ptr, const XMC_VADC_QUEUE_CONFIG_t *config)
{
 802370e:	b410      	push	{r4}
  XMC_VADC_GROUP_QueueDisableArbitrationSlot(group_ptr);
  
  reg = group_ptr->ARBPR;

  /* Request Source priority */
  reg &= ~((uint32_t)VADC_G_ARBPR_PRIO0_Msk);
 8023710:	f023 0303 	bic.w	r3, r3, #3
  reg |= (uint32_t) ((uint32_t)config->req_src_priority << VADC_G_ARBPR_PRIO0_Pos);
 8023714:	f3c2 0481 	ubfx	r4, r2, #2, #2

  /* Conversion Start mode */
  if (XMC_VADC_STARTMODE_WFS != (XMC_VADC_STARTMODE_t)config->conv_start_mode)
 8023718:	f012 0203 	ands.w	r2, r2, #3
  
  reg = group_ptr->ARBPR;

  /* Request Source priority */
  reg &= ~((uint32_t)VADC_G_ARBPR_PRIO0_Msk);
  reg |= (uint32_t) ((uint32_t)config->req_src_priority << VADC_G_ARBPR_PRIO0_Pos);
 802371c:	ea43 0304 	orr.w	r3, r3, r4

  /* Conversion Start mode */
  if (XMC_VADC_STARTMODE_WFS != (XMC_VADC_STARTMODE_t)config->conv_start_mode)
 8023720:	d020      	beq.n	8023764 <XMC_VADC_GROUP_QueueInit+0x68>
  {
    reg |= (uint32_t)(VADC_G_ARBPR_CSM0_Msk);
 8023722:	f043 0308 	orr.w	r3, r3, #8
  }

  group_ptr->ARBPR = reg;
 8023726:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84


  group_ptr->QCTRL0 = (uint32_t)((config->qctrl0)|(uint32_t)(VADC_G_QCTRL0_XTWC_Msk)|
 802372a:	684b      	ldr	r3, [r1, #4]
 802372c:	f043 2380 	orr.w	r3, r3, #2147516416	; 0x80008000
 8023730:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 8023734:	f8c0 3100 	str.w	r3, [r0, #256]	; 0x100
                                                    (uint32_t)(VADC_G_QCTRL0_TMWC_Msk)|
                                                    (uint32_t)(VADC_G_QCTRL0_GTWC_Msk));

  /* Gating mode */
  group_ptr->QMR0 = ((uint32_t)(config->qmr0) | (uint32_t)((uint32_t)XMC_VADC_GATEMODE_IGNORE << VADC_G_QMR0_ENGT_Pos));
 8023738:	688b      	ldr	r3, [r1, #8]

  if (XMC_VADC_STARTMODE_CNR == (XMC_VADC_STARTMODE_t)(config->conv_start_mode) )
 802373a:	2a02      	cmp	r2, #2
  group_ptr->QCTRL0 = (uint32_t)((config->qctrl0)|(uint32_t)(VADC_G_QCTRL0_XTWC_Msk)|
                                                    (uint32_t)(VADC_G_QCTRL0_TMWC_Msk)|
                                                    (uint32_t)(VADC_G_QCTRL0_GTWC_Msk));

  /* Gating mode */
  group_ptr->QMR0 = ((uint32_t)(config->qmr0) | (uint32_t)((uint32_t)XMC_VADC_GATEMODE_IGNORE << VADC_G_QMR0_ENGT_Pos));
 802373c:	f043 0301 	orr.w	r3, r3, #1
 8023740:	f8c0 3104 	str.w	r3, [r0, #260]	; 0x104

  if (XMC_VADC_STARTMODE_CNR == (XMC_VADC_STARTMODE_t)(config->conv_start_mode) )
 8023744:	d105      	bne.n	8023752 <XMC_VADC_GROUP_QueueInit+0x56>
  {
    group_ptr->QMR0 |= (uint32_t)((uint32_t)1 << VADC_G_QMR0_RPTDIS_Pos);
 8023746:	f8d0 3104 	ldr.w	r3, [r0, #260]	; 0x104
 802374a:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 802374e:	f8c0 3104 	str.w	r3, [r0, #260]	; 0x104
 *  XMC_VADC_GROUP_QueueDisableArbitrationSlot()<BR>
 */
__STATIC_INLINE void XMC_VADC_GROUP_QueueEnableArbitrationSlot(XMC_VADC_GROUP_t *const group_ptr)
{
  XMC_ASSERT("XMC_VADC_GROUP_QueueEnableArbitrationSlot:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr));
  group_ptr->ARBPR |= (uint32_t)((uint32_t)1 << VADC_G_ARBPR_ASEN0_Pos);
 8023752:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
  }
  /* Enable arbitration slot for the queue request source */
  XMC_VADC_GROUP_QueueEnableArbitrationSlot(group_ptr);

}
 8023756:	f85d 4b04 	ldr.w	r4, [sp], #4
 802375a:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 802375e:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
 8023762:	4770      	bx	lr
  if (XMC_VADC_STARTMODE_WFS != (XMC_VADC_STARTMODE_t)config->conv_start_mode)
  {
    reg |= (uint32_t)(VADC_G_ARBPR_CSM0_Msk);
  }

  group_ptr->ARBPR = reg;
 8023764:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84


  group_ptr->QCTRL0 = (uint32_t)((config->qctrl0)|(uint32_t)(VADC_G_QCTRL0_XTWC_Msk)|
 8023768:	684b      	ldr	r3, [r1, #4]
 802376a:	f043 2380 	orr.w	r3, r3, #2147516416	; 0x80008000
 802376e:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 8023772:	f8c0 3100 	str.w	r3, [r0, #256]	; 0x100
                                                    (uint32_t)(VADC_G_QCTRL0_TMWC_Msk)|
                                                    (uint32_t)(VADC_G_QCTRL0_GTWC_Msk));

  /* Gating mode */
  group_ptr->QMR0 = ((uint32_t)(config->qmr0) | (uint32_t)((uint32_t)XMC_VADC_GATEMODE_IGNORE << VADC_G_QMR0_ENGT_Pos));
 8023776:	688b      	ldr	r3, [r1, #8]
 8023778:	f043 0301 	orr.w	r3, r3, #1
 802377c:	f8c0 3104 	str.w	r3, [r0, #260]	; 0x104
 8023780:	e7e7      	b.n	8023752 <XMC_VADC_GROUP_QueueInit+0x56>
 8023782:	bf00      	nop

08023784 <XMC_VADC_GROUP_QueueSetReqSrcEventInterruptNode>:
  uint32_t sevnp;

  XMC_ASSERT("XMC_VADC_GROUP_QueueSetReqSrcEventInterruptNode:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  XMC_ASSERT("XMC_VADC_GROUP_QueueSetReqSrcEventInterruptNode:Wrong Service Request", ((sr)  <= XMC_VADC_SR_SHARED_SR3))

  sevnp = group_ptr->SEVNP;
 8023784:	f8d0 31c0 	ldr.w	r3, [r0, #448]	; 0x1c0

  sevnp &= ~((uint32_t)VADC_G_SEVNP_SEV0NP_Msk);
 8023788:	f023 030f 	bic.w	r3, r3, #15
  sevnp |= (uint32_t)((uint32_t)sr << VADC_G_SEVNP_SEV0NP_Pos);
 802378c:	4319      	orrs	r1, r3

  group_ptr->SEVNP = sevnp;
 802378e:	f8c0 11c0 	str.w	r1, [r0, #448]	; 0x1c0
 8023792:	4770      	bx	lr

08023794 <XMC_VADC_GROUP_ChannelInit>:

#if (XMC_VADC_GROUP_AVAILABLE ==1U)
/* API to initialize a channel unit */
void XMC_VADC_GROUP_ChannelInit(XMC_VADC_GROUP_t *const group_ptr, const uint32_t ch_num,
                                        const XMC_VADC_CHANNEL_CONFIG_t *config)
{
 8023794:	b430      	push	{r4, r5}


  XMC_ASSERT("XMC_VADC_GROUP_ChannelInit:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  XMC_ASSERT("XMC_VADC_GROUP_ChannelInit:Wrong Channel Number", ((ch_num) < XMC_VADC_NUM_CHANNELS_PER_GROUP))
  
  prio  = (uint32_t)config->channel_priority;
 8023796:	7b13      	ldrb	r3, [r2, #12]

  /* Priority channel */
  ch_assign  = group_ptr->CHASS;
 8023798:	f8d0 5088 	ldr.w	r5, [r0, #136]	; 0x88
  ch_assign &= ~((uint32_t)((uint32_t)1 << ch_num));
 802379c:	2401      	movs	r4, #1
 802379e:	408c      	lsls	r4, r1
 80237a0:	ea25 0404 	bic.w	r4, r5, r4
  ch_assign |= (uint32_t)(prio << ch_num);
 80237a4:	408b      	lsls	r3, r1
 80237a6:	4323      	orrs	r3, r4
  group_ptr->CHASS = ch_assign;
 80237a8:	f8c0 3088 	str.w	r3, [r0, #136]	; 0x88

  /* Alias channel */
  if (config->alias_channel >= (int32_t)0)
 80237ac:	7b53      	ldrb	r3, [r2, #13]
 80237ae:	061c      	lsls	r4, r3, #24
 80237b0:	d40a      	bmi.n	80237c8 <XMC_VADC_GROUP_ChannelInit+0x34>
  {
    mask = (uint32_t)0;
    if ((uint32_t)1 == ch_num)
 80237b2:	2901      	cmp	r1, #1
 80237b4:	d023      	beq.n	80237fe <XMC_VADC_GROUP_ChannelInit+0x6a>
    {
      mask = VADC_G_ALIAS_ALIAS1_Pos;
      group_ptr->ALIAS &= ~(uint32_t)(VADC_G_ALIAS_ALIAS1_Msk);
    }
    else if ((uint32_t)0 == ch_num)
 80237b6:	b1c9      	cbz	r1, 80237ec <XMC_VADC_GROUP_ChannelInit+0x58>
 80237b8:	2500      	movs	r5, #0
    {
      mask = VADC_G_ALIAS_ALIAS0_Pos;
      group_ptr->ALIAS &= ~(uint32_t)(VADC_G_ALIAS_ALIAS0_Msk);
    }

    group_ptr->ALIAS |= (uint32_t)(config->alias_channel << mask);
 80237ba:	f8d0 40b0 	ldr.w	r4, [r0, #176]	; 0xb0
 80237be:	b25b      	sxtb	r3, r3
 80237c0:	40ab      	lsls	r3, r5
 80237c2:	4323      	orrs	r3, r4
 80237c4:	f8c0 30b0 	str.w	r3, [r0, #176]	; 0xb0
  }

  group_ptr->BFL |= config->bfl;
 80237c8:	f8d0 40c8 	ldr.w	r4, [r0, #200]	; 0xc8
 80237cc:	6853      	ldr	r3, [r2, #4]
 80237ce:	4323      	orrs	r3, r4
 80237d0:	f8c0 30c8 	str.w	r3, [r0, #200]	; 0xc8

#if (XMC_VADC_BOUNDARY_FLAG_SELECT == 1U)
  group_ptr->BFLC |= config->bflc;
 80237d4:	f8d0 40d0 	ldr.w	r4, [r0, #208]	; 0xd0
 80237d8:	6893      	ldr	r3, [r2, #8]
 80237da:	4323      	orrs	r3, r4
 80237dc:	f8c0 30d0 	str.w	r3, [r0, #208]	; 0xd0
#endif
  /* Program the CHCTR register */
  group_ptr->CHCTR[ch_num] = config->chctr;
 80237e0:	3180      	adds	r1, #128	; 0x80
 80237e2:	6813      	ldr	r3, [r2, #0]
 80237e4:	f840 3021 	str.w	r3, [r0, r1, lsl #2]

}
 80237e8:	bc30      	pop	{r4, r5}
 80237ea:	4770      	bx	lr
      group_ptr->ALIAS &= ~(uint32_t)(VADC_G_ALIAS_ALIAS1_Msk);
    }
    else if ((uint32_t)0 == ch_num)
    {
      mask = VADC_G_ALIAS_ALIAS0_Pos;
      group_ptr->ALIAS &= ~(uint32_t)(VADC_G_ALIAS_ALIAS0_Msk);
 80237ec:	f8d0 30b0 	ldr.w	r3, [r0, #176]	; 0xb0
 80237f0:	f023 031f 	bic.w	r3, r3, #31
 80237f4:	f8c0 30b0 	str.w	r3, [r0, #176]	; 0xb0
 80237f8:	7b53      	ldrb	r3, [r2, #13]
 80237fa:	460d      	mov	r5, r1
 80237fc:	e7dd      	b.n	80237ba <XMC_VADC_GROUP_ChannelInit+0x26>
  {
    mask = (uint32_t)0;
    if ((uint32_t)1 == ch_num)
    {
      mask = VADC_G_ALIAS_ALIAS1_Pos;
      group_ptr->ALIAS &= ~(uint32_t)(VADC_G_ALIAS_ALIAS1_Msk);
 80237fe:	f8d0 30b0 	ldr.w	r3, [r0, #176]	; 0xb0
 8023802:	f423 53f8 	bic.w	r3, r3, #7936	; 0x1f00
 8023806:	f8c0 30b0 	str.w	r3, [r0, #176]	; 0xb0
 802380a:	7b53      	ldrb	r3, [r2, #13]
 802380c:	2508      	movs	r5, #8
 802380e:	e7d4      	b.n	80237ba <XMC_VADC_GROUP_ChannelInit+0x26>

08023810 <XMC_VADC_GROUP_SetResultInterruptNode>:

  XMC_ASSERT("XMC_VADC_GROUP_SetResultInterruptNode:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  XMC_ASSERT("XMC_VADC_GROUP_SetResultInterruptNode:Wrong Result Register", ((res_reg) < XMC_VADC_NUM_RESULT_REGISTERS))
  XMC_ASSERT("XMC_VADC_GROUP_SetResultInterruptNode:Wrong Service Request", ((sr)  <= XMC_VADC_SR_SHARED_SR3))

  if (res_reg <= 7U)
 8023810:	2907      	cmp	r1, #7

/* API to select a service request line (NVIC Node) for result event of specified unit of result hardware */
void XMC_VADC_GROUP_SetResultInterruptNode(XMC_VADC_GROUP_t *const group_ptr,
                                           const uint32_t res_reg,
                                           const XMC_VADC_SR_t sr)
{
 8023812:	b410      	push	{r4}

  XMC_ASSERT("XMC_VADC_GROUP_SetResultInterruptNode:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  XMC_ASSERT("XMC_VADC_GROUP_SetResultInterruptNode:Wrong Result Register", ((res_reg) < XMC_VADC_NUM_RESULT_REGISTERS))
  XMC_ASSERT("XMC_VADC_GROUP_SetResultInterruptNode:Wrong Service Request", ((sr)  <= XMC_VADC_SR_SHARED_SR3))

  if (res_reg <= 7U)
 8023814:	d910      	bls.n	8023838 <XMC_VADC_GROUP_SetResultInterruptNode+0x28>
    group_ptr->REVNP0 = route_mask;
  }
  else
  {
    route_mask = group_ptr->REVNP1;
    route_mask &= ~((uint32_t)((uint32_t)15 << (( res_reg - (uint32_t)8) * (uint32_t)4) ));
 8023816:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
 802381a:	3908      	subs	r1, #8
    route_mask |= (uint32_t)((uint32_t)sr << (res_reg * (uint32_t)4));
    group_ptr->REVNP0 = route_mask;
  }
  else
  {
    route_mask = group_ptr->REVNP1;
 802381c:	f8d0 41b4 	ldr.w	r4, [r0, #436]	; 0x1b4
    route_mask &= ~((uint32_t)((uint32_t)15 << (( res_reg - (uint32_t)8) * (uint32_t)4) ));
 8023820:	0089      	lsls	r1, r1, #2
 8023822:	230f      	movs	r3, #15
 8023824:	408b      	lsls	r3, r1
 8023826:	ea24 0303 	bic.w	r3, r4, r3
    route_mask |= (uint32_t)((uint32_t)sr << ((res_reg - (uint32_t)8) * (uint32_t)4));
 802382a:	408a      	lsls	r2, r1
 802382c:	431a      	orrs	r2, r3
    group_ptr->REVNP1 = route_mask;
 802382e:	f8c0 21b4 	str.w	r2, [r0, #436]	; 0x1b4
  }
}
 8023832:	f85d 4b04 	ldr.w	r4, [sp], #4
 8023836:	4770      	bx	lr
  XMC_ASSERT("XMC_VADC_GROUP_SetResultInterruptNode:Wrong Result Register", ((res_reg) < XMC_VADC_NUM_RESULT_REGISTERS))
  XMC_ASSERT("XMC_VADC_GROUP_SetResultInterruptNode:Wrong Service Request", ((sr)  <= XMC_VADC_SR_SHARED_SR3))

  if (res_reg <= 7U)
  {
    route_mask  = group_ptr->REVNP0;
 8023838:	f8d0 41b0 	ldr.w	r4, [r0, #432]	; 0x1b0
    route_mask &= ~((uint32_t)((uint32_t)15 << (res_reg * (uint32_t)4) ));
 802383c:	0089      	lsls	r1, r1, #2
 802383e:	230f      	movs	r3, #15
 8023840:	408b      	lsls	r3, r1
 8023842:	ea24 0303 	bic.w	r3, r4, r3
    route_mask |= (uint32_t)((uint32_t)sr << (res_reg * (uint32_t)4));
 8023846:	408a      	lsls	r2, r1
 8023848:	431a      	orrs	r2, r3
    group_ptr->REVNP0 = route_mask;
 802384a:	f8c0 21b0 	str.w	r2, [r0, #432]	; 0x1b0
    route_mask = group_ptr->REVNP1;
    route_mask &= ~((uint32_t)((uint32_t)15 << (( res_reg - (uint32_t)8) * (uint32_t)4) ));
    route_mask |= (uint32_t)((uint32_t)sr << ((res_reg - (uint32_t)8) * (uint32_t)4));
    group_ptr->REVNP1 = route_mask;
  }
}
 802384e:	f85d 4b04 	ldr.w	r4, [sp], #4
 8023852:	4770      	bx	lr

08023854 <send_device_status_response.part.0>:
==============================================================================
   6. EXPORTED FUNCTIONS
==============================================================================
 */

uint16_t send_device_status_response()
 8023854:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
static uint8_t device_status_endpoint = 0;

static void fill_status_response(device_status_response_t *p_status_response)
{
	Device_Status_t *device_status = NULL;
	device_status = device_status_get_handle(device_status);
 8023858:	2000      	movs	r0, #0
 802385a:	f7fd f9bb 	bl	8020bd4 <device_status_get_handle>

	p_status_response->error_code = (uint16_t) device_status->latest_error;
 802385e:	f8d0 9004 	ldr.w	r9, [r0, #4]
	p_status_response->error_type = (uint8_t) device_status->state,
 8023862:	7806      	ldrb	r6, [r0, #0]
static void fill_status_response(device_status_response_t *p_status_response)
{
	Device_Status_t *device_status = NULL;
	device_status = device_status_get_handle(device_status);

	p_status_response->error_code = (uint16_t) device_status->latest_error;
 8023864:	fa1f f889 	uxth.w	r8, r9
	p_status_response->error_type = (uint8_t) device_status->state,
	p_status_response->frame_count = 0;
	if (device_status->state != STATE_NO_ERROR)
 8023868:	2e00      	cmp	r6, #0
 802386a:	f040 8091 	bne.w	8023990 <send_device_status_response.part.0+0x13c>

		/* fetch device info an fill status response */
		fill_status_response(&status_response);

		static uint8_t message[512];  // allocate statically, rather then on the call stack!
		memset(message, 0, sizeof(message));
 802386e:	4d5e      	ldr	r5, [pc, #376]	; (80239e8 <send_device_status_response.part.0+0x194>)
		p_status_response->error_msg = device_status_get_error_description(device_status->latest_error);
		p_status_response->error_msg_size = strlen(p_status_response->error_msg) + 1;  // include the leading zero!
	}
	else
	{
		p_status_response->error_msg = "No Error";
 8023870:	4f5e      	ldr	r7, [pc, #376]	; (80239ec <send_device_status_response.part.0+0x198>)

		/* fetch device info an fill status response */
		fill_status_response(&status_response);

		static uint8_t message[512];  // allocate statically, rather then on the call stack!
		memset(message, 0, sizeof(message));
 8023872:	4628      	mov	r0, r5
 8023874:	4631      	mov	r1, r6
 8023876:	f44f 7200 	mov.w	r2, #512	; 0x200
 802387a:	f009 fe6c 	bl	802d556 <memset>
}

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 802387e:	ea4f 2818 	mov.w	r8, r8, lsr #8
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8023882:	234a      	movs	r3, #74	; 0x4a

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 8023884:	2409      	movs	r4, #9
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8023886:	706e      	strb	r6, [r5, #1]

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 8023888:	f885 9002 	strb.w	r9, [r5, #2]
}

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 802388c:	726e      	strb	r6, [r5, #9]
 802388e:	f885 8003 	strb.w	r8, [r5, #3]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8023892:	702b      	strb	r3, [r5, #0]

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 8023894:	722c      	strb	r4, [r5, #8]
 8023896:	4a56      	ldr	r2, [pc, #344]	; (80239f0 <send_device_status_response.part.0+0x19c>)
 8023898:	f107 0308 	add.w	r3, r7, #8
 802389c:	f102 0108 	add.w	r1, r2, #8
 80238a0:	42b9      	cmp	r1, r7
 80238a2:	bf88      	it	hi
 80238a4:	4293      	cmphi	r3, r2
 80238a6:	bf94      	ite	ls
 80238a8:	2301      	movls	r3, #1
 80238aa:	2300      	movhi	r3, #0
 80238ac:	2c0a      	cmp	r4, #10
 80238ae:	bf94      	ite	ls
 80238b0:	2300      	movls	r3, #0
 80238b2:	f003 0301 	andhi.w	r3, r3, #1
 80238b6:	2b00      	cmp	r3, #0
 80238b8:	f000 808a 	beq.w	80239d0 <send_device_status_response.part.0+0x17c>
 80238bc:	ea47 0302 	orr.w	r3, r7, r2
 80238c0:	075b      	lsls	r3, r3, #29
 80238c2:	f040 8085 	bne.w	80239d0 <send_device_status_response.part.0+0x17c>
 80238c6:	f1a4 0e08 	sub.w	lr, r4, #8
 80238ca:	f3ce 0ecc 	ubfx	lr, lr, #3, #13
 80238ce:	f10e 0e01 	add.w	lr, lr, #1
 80238d2:	ea4f 03ce 	mov.w	r3, lr, lsl #3
 80238d6:	b29b      	uxth	r3, r3
 80238d8:	f1a7 0808 	sub.w	r8, r7, #8
		p_status_response->error_msg = device_status_get_error_description(device_status->latest_error);
		p_status_response->error_msg_size = strlen(p_status_response->error_msg) + 1;  // include the leading zero!
	}
	else
	{
		p_status_response->error_msg = "No Error";
 80238dc:	f04f 0c00 	mov.w	ip, #0
		offset += wr_payload_u32(message, offset, status_response.frame_count);		/*frame count*/
		offset += wr_payload_u16(message, offset, status_response.error_msg_size);		/*frame count*/

		for(uint16_t i=0; i<status_response.error_msg_size; i++ )
		{
			offset += wr_payload_u8(message, offset, status_response.error_msg[i]);
 80238e0:	e9f8 0102 	ldrd	r0, r1, [r8, #8]!
 80238e4:	f10c 0c01 	add.w	ip, ip, #1
 80238e8:	fa1f f98c 	uxth.w	r9, ip
 80238ec:	45ce      	cmp	lr, r9
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 80238ee:	e8e2 0102 	strd	r0, r1, [r2], #8
 80238f2:	d8f5      	bhi.n	80238e0 <send_device_status_response.part.0+0x8c>
 80238f4:	429c      	cmp	r4, r3
 80238f6:	f103 000a 	add.w	r0, r3, #10
 80238fa:	d047      	beq.n	802398c <send_device_status_response.part.0+0x138>
		offset += wr_payload_u8(message, offset, status_response.error_type);		/*error type*/
		offset += wr_payload_u16(message, offset, status_response.error_code);		/*error code*/
		offset += wr_payload_u32(message, offset, status_response.frame_count);		/*frame count*/
		offset += wr_payload_u16(message, offset, status_response.error_msg_size);		/*frame count*/

		for(uint16_t i=0; i<status_response.error_msg_size; i++ )
 80238fc:	1c59      	adds	r1, r3, #1
 80238fe:	b289      	uxth	r1, r1
		{
			offset += wr_payload_u8(message, offset, status_response.error_msg[i]);
 8023900:	5cfa      	ldrb	r2, [r7, r3]
 8023902:	542a      	strb	r2, [r5, r0]
		offset += wr_payload_u8(message, offset, status_response.error_type);		/*error type*/
		offset += wr_payload_u16(message, offset, status_response.error_code);		/*error code*/
		offset += wr_payload_u32(message, offset, status_response.frame_count);		/*frame count*/
		offset += wr_payload_u16(message, offset, status_response.error_msg_size);		/*frame count*/

		for(uint16_t i=0; i<status_response.error_msg_size; i++ )
 8023904:	42a1      	cmp	r1, r4
 8023906:	4a38      	ldr	r2, [pc, #224]	; (80239e8 <send_device_status_response.part.0+0x194>)
		{
			offset += wr_payload_u8(message, offset, status_response.error_msg[i]);
 8023908:	f103 050b 	add.w	r5, r3, #11
		offset += wr_payload_u8(message, offset, status_response.error_type);		/*error type*/
		offset += wr_payload_u16(message, offset, status_response.error_code);		/*error code*/
		offset += wr_payload_u32(message, offset, status_response.frame_count);		/*frame count*/
		offset += wr_payload_u16(message, offset, status_response.error_msg_size);		/*frame count*/

		for(uint16_t i=0; i<status_response.error_msg_size; i++ )
 802390c:	d23e      	bcs.n	802398c <send_device_status_response.part.0+0x138>
 802390e:	1c98      	adds	r0, r3, #2
 8023910:	b280      	uxth	r0, r0
		{
			offset += wr_payload_u8(message, offset, status_response.error_msg[i]);
 8023912:	5c79      	ldrb	r1, [r7, r1]
 8023914:	5551      	strb	r1, [r2, r5]
		offset += wr_payload_u8(message, offset, status_response.error_type);		/*error type*/
		offset += wr_payload_u16(message, offset, status_response.error_code);		/*error code*/
		offset += wr_payload_u32(message, offset, status_response.frame_count);		/*frame count*/
		offset += wr_payload_u16(message, offset, status_response.error_msg_size);		/*frame count*/

		for(uint16_t i=0; i<status_response.error_msg_size; i++ )
 8023916:	4284      	cmp	r4, r0
		{
			offset += wr_payload_u8(message, offset, status_response.error_msg[i]);
 8023918:	f103 050c 	add.w	r5, r3, #12
		offset += wr_payload_u8(message, offset, status_response.error_type);		/*error type*/
		offset += wr_payload_u16(message, offset, status_response.error_code);		/*error code*/
		offset += wr_payload_u32(message, offset, status_response.frame_count);		/*frame count*/
		offset += wr_payload_u16(message, offset, status_response.error_msg_size);		/*frame count*/

		for(uint16_t i=0; i<status_response.error_msg_size; i++ )
 802391c:	d936      	bls.n	802398c <send_device_status_response.part.0+0x138>
 802391e:	1cd9      	adds	r1, r3, #3
 8023920:	b289      	uxth	r1, r1
		{
			offset += wr_payload_u8(message, offset, status_response.error_msg[i]);
 8023922:	5c38      	ldrb	r0, [r7, r0]
 8023924:	5550      	strb	r0, [r2, r5]
		offset += wr_payload_u8(message, offset, status_response.error_type);		/*error type*/
		offset += wr_payload_u16(message, offset, status_response.error_code);		/*error code*/
		offset += wr_payload_u32(message, offset, status_response.frame_count);		/*frame count*/
		offset += wr_payload_u16(message, offset, status_response.error_msg_size);		/*frame count*/

		for(uint16_t i=0; i<status_response.error_msg_size; i++ )
 8023926:	428c      	cmp	r4, r1
		{
			offset += wr_payload_u8(message, offset, status_response.error_msg[i]);
 8023928:	f103 050d 	add.w	r5, r3, #13
		offset += wr_payload_u8(message, offset, status_response.error_type);		/*error type*/
		offset += wr_payload_u16(message, offset, status_response.error_code);		/*error code*/
		offset += wr_payload_u32(message, offset, status_response.frame_count);		/*frame count*/
		offset += wr_payload_u16(message, offset, status_response.error_msg_size);		/*frame count*/

		for(uint16_t i=0; i<status_response.error_msg_size; i++ )
 802392c:	d92e      	bls.n	802398c <send_device_status_response.part.0+0x138>
 802392e:	1d18      	adds	r0, r3, #4
 8023930:	b280      	uxth	r0, r0
		{
			offset += wr_payload_u8(message, offset, status_response.error_msg[i]);
 8023932:	5c79      	ldrb	r1, [r7, r1]
 8023934:	5551      	strb	r1, [r2, r5]
		offset += wr_payload_u8(message, offset, status_response.error_type);		/*error type*/
		offset += wr_payload_u16(message, offset, status_response.error_code);		/*error code*/
		offset += wr_payload_u32(message, offset, status_response.frame_count);		/*frame count*/
		offset += wr_payload_u16(message, offset, status_response.error_msg_size);		/*frame count*/

		for(uint16_t i=0; i<status_response.error_msg_size; i++ )
 8023936:	4284      	cmp	r4, r0
		{
			offset += wr_payload_u8(message, offset, status_response.error_msg[i]);
 8023938:	f103 050e 	add.w	r5, r3, #14
		offset += wr_payload_u8(message, offset, status_response.error_type);		/*error type*/
		offset += wr_payload_u16(message, offset, status_response.error_code);		/*error code*/
		offset += wr_payload_u32(message, offset, status_response.frame_count);		/*frame count*/
		offset += wr_payload_u16(message, offset, status_response.error_msg_size);		/*frame count*/

		for(uint16_t i=0; i<status_response.error_msg_size; i++ )
 802393c:	d926      	bls.n	802398c <send_device_status_response.part.0+0x138>
 802393e:	1d59      	adds	r1, r3, #5
 8023940:	b289      	uxth	r1, r1
		{
			offset += wr_payload_u8(message, offset, status_response.error_msg[i]);
 8023942:	5c38      	ldrb	r0, [r7, r0]
 8023944:	5550      	strb	r0, [r2, r5]
		offset += wr_payload_u8(message, offset, status_response.error_type);		/*error type*/
		offset += wr_payload_u16(message, offset, status_response.error_code);		/*error code*/
		offset += wr_payload_u32(message, offset, status_response.frame_count);		/*frame count*/
		offset += wr_payload_u16(message, offset, status_response.error_msg_size);		/*frame count*/

		for(uint16_t i=0; i<status_response.error_msg_size; i++ )
 8023946:	428c      	cmp	r4, r1
		{
			offset += wr_payload_u8(message, offset, status_response.error_msg[i]);
 8023948:	f103 050f 	add.w	r5, r3, #15
		offset += wr_payload_u8(message, offset, status_response.error_type);		/*error type*/
		offset += wr_payload_u16(message, offset, status_response.error_code);		/*error code*/
		offset += wr_payload_u32(message, offset, status_response.frame_count);		/*frame count*/
		offset += wr_payload_u16(message, offset, status_response.error_msg_size);		/*frame count*/

		for(uint16_t i=0; i<status_response.error_msg_size; i++ )
 802394c:	d91e      	bls.n	802398c <send_device_status_response.part.0+0x138>
 802394e:	1d98      	adds	r0, r3, #6
		{
			offset += wr_payload_u8(message, offset, status_response.error_msg[i]);
 8023950:	5c79      	ldrb	r1, [r7, r1]
 8023952:	5551      	strb	r1, [r2, r5]
		offset += wr_payload_u8(message, offset, status_response.error_type);		/*error type*/
		offset += wr_payload_u16(message, offset, status_response.error_code);		/*error code*/
		offset += wr_payload_u32(message, offset, status_response.frame_count);		/*frame count*/
		offset += wr_payload_u16(message, offset, status_response.error_msg_size);		/*frame count*/

		for(uint16_t i=0; i<status_response.error_msg_size; i++ )
 8023954:	b281      	uxth	r1, r0
 8023956:	428c      	cmp	r4, r1
		{
			offset += wr_payload_u8(message, offset, status_response.error_msg[i]);
 8023958:	f103 0310 	add.w	r3, r3, #16
		offset += wr_payload_u8(message, offset, status_response.error_type);		/*error type*/
		offset += wr_payload_u16(message, offset, status_response.error_code);		/*error code*/
		offset += wr_payload_u32(message, offset, status_response.frame_count);		/*frame count*/
		offset += wr_payload_u16(message, offset, status_response.error_msg_size);		/*frame count*/

		for(uint16_t i=0; i<status_response.error_msg_size; i++ )
 802395c:	d916      	bls.n	802398c <send_device_status_response.part.0+0x138>
		{
			offset += wr_payload_u8(message, offset, status_response.error_msg[i]);
 802395e:	5c79      	ldrb	r1, [r7, r1]
 8023960:	54d1      	strb	r1, [r2, r3]
 8023962:	3c01      	subs	r4, #1
 8023964:	340b      	adds	r4, #11
 8023966:	b2a4      	uxth	r4, r4
		}

		/* send message */
		protocol_send_header(device_status_endpoint, offset);
 8023968:	4b22      	ldr	r3, [pc, #136]	; (80239f4 <send_device_status_response.part.0+0x1a0>)
 802396a:	4621      	mov	r1, r4
 802396c:	7818      	ldrb	r0, [r3, #0]
 802396e:	f000 ff2f 	bl	80247d0 <protocol_send_header>
		protocol_send_payload(message, offset);
 8023972:	4621      	mov	r1, r4
 8023974:	481c      	ldr	r0, [pc, #112]	; (80239e8 <send_device_status_response.part.0+0x194>)
 8023976:	f000 ff3f 	bl	80247f8 <protocol_send_payload>
		protocol_send_tail();
 802397a:	f000 ff3f 	bl	80247fc <protocol_send_tail>

		/* clean error, if not fatal */
		if (status_response.error_type != 4)
 802397e:	2e04      	cmp	r6, #4
 8023980:	d001      	beq.n	8023986 <send_device_status_response.part.0+0x132>
			device_status_clean();
 8023982:	f7fd f97f 	bl	8020c84 <device_status_clean>
	}
	return RADAR_ERR_OK;
}
 8023986:	2000      	movs	r0, #0
 8023988:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 802398c:	3c01      	subs	r4, #1
 802398e:	e7e9      	b.n	8023964 <send_device_status_response.part.0+0x110>
	p_status_response->error_code = (uint16_t) device_status->latest_error;
	p_status_response->error_type = (uint8_t) device_status->state,
	p_status_response->frame_count = 0;
	if (device_status->state != STATE_NO_ERROR)
	{
		p_status_response->error_msg = device_status_get_error_description(device_status->latest_error);
 8023990:	4648      	mov	r0, r9
 8023992:	f7fd f94f 	bl	8020c34 <device_status_get_error_description>
 8023996:	4607      	mov	r7, r0
		p_status_response->error_msg_size = strlen(p_status_response->error_msg) + 1;  // include the leading zero!
 8023998:	f009 fde5 	bl	802d566 <strlen>

		/* fetch device info an fill status response */
		fill_status_response(&status_response);

		static uint8_t message[512];  // allocate statically, rather then on the call stack!
		memset(message, 0, sizeof(message));
 802399c:	4d12      	ldr	r5, [pc, #72]	; (80239e8 <send_device_status_response.part.0+0x194>)
	p_status_response->error_type = (uint8_t) device_status->state,
	p_status_response->frame_count = 0;
	if (device_status->state != STATE_NO_ERROR)
	{
		p_status_response->error_msg = device_status_get_error_description(device_status->latest_error);
		p_status_response->error_msg_size = strlen(p_status_response->error_msg) + 1;  // include the leading zero!
 802399e:	3001      	adds	r0, #1
 80239a0:	b284      	uxth	r4, r0

		/* fetch device info an fill status response */
		fill_status_response(&status_response);

		static uint8_t message[512];  // allocate statically, rather then on the call stack!
		memset(message, 0, sizeof(message));
 80239a2:	f44f 7200 	mov.w	r2, #512	; 0x200
 80239a6:	4628      	mov	r0, r5
 80239a8:	2100      	movs	r1, #0
 80239aa:	f009 fdd4 	bl	802d556 <memset>
}

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 80239ae:	ea4f 2818 	mov.w	r8, r8, lsr #8
 80239b2:	0a22      	lsrs	r2, r4, #8
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 80239b4:	234a      	movs	r3, #74	; 0x4a
 80239b6:	722c      	strb	r4, [r5, #8]
 80239b8:	706e      	strb	r6, [r5, #1]

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 80239ba:	f885 9002 	strb.w	r9, [r5, #2]
}

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 80239be:	f885 8003 	strb.w	r8, [r5, #3]
 80239c2:	726a      	strb	r2, [r5, #9]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 80239c4:	702b      	strb	r3, [r5, #0]
		offset += wr_payload_u8(message, offset, status_response.error_type);		/*error type*/
		offset += wr_payload_u16(message, offset, status_response.error_code);		/*error code*/
		offset += wr_payload_u32(message, offset, status_response.frame_count);		/*frame count*/
		offset += wr_payload_u16(message, offset, status_response.error_msg_size);		/*frame count*/

		for(uint16_t i=0; i<status_response.error_msg_size; i++ )
 80239c6:	2c00      	cmp	r4, #0
 80239c8:	f47f af65 	bne.w	8023896 <send_device_status_response.part.0+0x42>
 80239cc:	240a      	movs	r4, #10
 80239ce:	e7cb      	b.n	8023968 <send_device_status_response.part.0+0x114>
 80239d0:	3c01      	subs	r4, #1
 80239d2:	4b09      	ldr	r3, [pc, #36]	; (80239f8 <send_device_status_response.part.0+0x1a4>)
 80239d4:	fa17 f184 	uxtah	r1, r7, r4
 80239d8:	3f01      	subs	r7, #1
		{
			offset += wr_payload_u8(message, offset, status_response.error_msg[i]);
 80239da:	f817 2f01 	ldrb.w	r2, [r7, #1]!
 80239de:	f803 2f01 	strb.w	r2, [r3, #1]!
		offset += wr_payload_u8(message, offset, status_response.error_type);		/*error type*/
		offset += wr_payload_u16(message, offset, status_response.error_code);		/*error code*/
		offset += wr_payload_u32(message, offset, status_response.frame_count);		/*frame count*/
		offset += wr_payload_u16(message, offset, status_response.error_msg_size);		/*frame count*/

		for(uint16_t i=0; i<status_response.error_msg_size; i++ )
 80239e2:	428f      	cmp	r7, r1
 80239e4:	d1f9      	bne.n	80239da <send_device_status_response.part.0+0x186>
 80239e6:	e7bd      	b.n	8023964 <send_device_status_response.part.0+0x110>
 80239e8:	1ffe97c8 	.word	0x1ffe97c8
 80239ec:	0802d844 	.word	0x0802d844
 80239f0:	1ffe97d2 	.word	0x1ffe97d2
 80239f4:	1ffe97c4 	.word	0x1ffe97c4
 80239f8:	1ffe97d1 	.word	0x1ffe97d1

080239fc <send_device_status_response>:
   6. EXPORTED FUNCTIONS
==============================================================================
 */

uint16_t send_device_status_response()
{
 80239fc:	b508      	push	{r3, lr}
	if (device_status_endpoint != 0)
 80239fe:	4b03      	ldr	r3, [pc, #12]	; (8023a0c <send_device_status_response+0x10>)
 8023a00:	781b      	ldrb	r3, [r3, #0]
 8023a02:	b10b      	cbz	r3, 8023a08 <send_device_status_response+0xc>
 8023a04:	f7ff ff26 	bl	8023854 <send_device_status_response.part.0>
		/* clean error, if not fatal */
		if (status_response.error_type != 4)
			device_status_clean();
	}
	return RADAR_ERR_OK;
}
 8023a08:	2000      	movs	r0, #0
 8023a0a:	bd08      	pop	{r3, pc}
 8023a0c:	1ffe97c4 	.word	0x1ffe97c4

08023a10 <ep_device_status_handle_message>:

uint16_t ep_device_status_handle_message(uint8_t endpoint, uint8_t *message_data,
											uint16_t num_bytes,	void* context)
{
 8023a10:	b508      	push	{r3, lr}
	/*store endpoint information*/

	device_status_endpoint = endpoint;

    switch (message_data[0])
 8023a12:	780b      	ldrb	r3, [r1, #0]
uint16_t ep_device_status_handle_message(uint8_t endpoint, uint8_t *message_data,
											uint16_t num_bytes,	void* context)
{
	/*store endpoint information*/

	device_status_endpoint = endpoint;
 8023a14:	4a06      	ldr	r2, [pc, #24]	; (8023a30 <ep_device_status_handle_message+0x20>)

    switch (message_data[0])
 8023a16:	2b4b      	cmp	r3, #75	; 0x4b
uint16_t ep_device_status_handle_message(uint8_t endpoint, uint8_t *message_data,
											uint16_t num_bytes,	void* context)
{
	/*store endpoint information*/

	device_status_endpoint = endpoint;
 8023a18:	7010      	strb	r0, [r2, #0]

    switch (message_data[0])
 8023a1a:	d002      	beq.n	8023a22 <ep_device_status_handle_message+0x12>
		return RADAR_ERR_OK;
	default:
		break;
    }

    return PROTOCOL_STATUS_INVALID_PAYLOAD;
 8023a1c:	f64f 70ff 	movw	r0, #65535	; 0xffff
}
 8023a20:	bd08      	pop	{r3, pc}
==============================================================================
 */

uint16_t send_device_status_response()
{
	if (device_status_endpoint != 0)
 8023a22:	2800      	cmp	r0, #0
 8023a24:	d0fc      	beq.n	8023a20 <ep_device_status_handle_message+0x10>
 8023a26:	f7ff ff15 	bl	8023854 <send_device_status_response.part.0>

    switch (message_data[0])
    {
	case MSG_STATUS_REQ_IND:
		send_device_status_response();
		return RADAR_ERR_OK;
 8023a2a:	2000      	movs	r0, #0
 8023a2c:	bd08      	pop	{r3, pc}
 8023a2e:	bf00      	nop
 8023a30:	1ffe97c4 	.word	0x1ffe97c4

08023a34 <ep_device_status_handle_change>:

    return PROTOCOL_STATUS_INVALID_PAYLOAD;
}

void ep_device_status_handle_change(uint8_t endpoint, void* context, uint32_t what)
{
 8023a34:	4770      	bx	lr
 8023a36:	bf00      	nop

08023a38 <send_consumption_response>:
/** @} */

/*  helper */

uint16_t send_consumption_response(uint8_t entries, consumption_response_t *pData )
{
 8023a38:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	uint8_t message[256];
	int16_t offset = 0;
	uint8_t endpoint = mcu_base_endpoint;
 8023a3c:	4b2f      	ldr	r3, [pc, #188]	; (8023afc <send_consumption_response+0xc4>)
/** @} */

/*  helper */

uint16_t send_consumption_response(uint8_t entries, consumption_response_t *pData )
{
 8023a3e:	b0c1      	sub	sp, #260	; 0x104
 8023a40:	22d3      	movs	r2, #211	; 0xd3
 8023a42:	4605      	mov	r5, r0
 8023a44:	f88d 0003 	strb.w	r0, [sp, #3]
 8023a48:	f88d 2000 	strb.w	r2, [sp]
	uint8_t message[256];
	int16_t offset = 0;
	uint8_t endpoint = mcu_base_endpoint;
 8023a4c:	781e      	ldrb	r6, [r3, #0]

	offset += wr_payload_u8(message, offset, MSG_CONSUMPTION_RES);
	offset += sizeof(uint16_t); // reserve space for the total message size and write it later
	offset += wr_payload_u8(message, offset, entries);
	for(int i = 0; i < entries; i++) {
 8023a4e:	2800      	cmp	r0, #0
 8023a50:	d050      	beq.n	8023af4 <send_consumption_response+0xbc>
 8023a52:	460f      	mov	r7, r1
 8023a54:	f04f 0800 	mov.w	r8, #0
 8023a58:	2304      	movs	r3, #4
		offset += wr_payload_u8(message, offset, pData[i].index);
 8023a5a:	f103 0901 	add.w	r9, r3, #1
 8023a5e:	b21b      	sxth	r3, r3
 8023a60:	fa1f f989 	uxth.w	r9, r9
 8023a64:	7839      	ldrb	r1, [r7, #0]
 8023a66:	f80d 1003 	strb.w	r1, [sp, r3]
		offset += wr_payload_float(message, offset, pData[i].value);
 8023a6a:	687a      	ldr	r2, [r7, #4]
 8023a6c:	fa0f f189 	sxth.w	r1, r9
 8023a70:	4668      	mov	r0, sp
 8023a72:	f000 ff07 	bl	8024884 <wr_payload_float>

		uint8_t len = (uint8_t) strlen(pData[i].p_unit);
 8023a76:	68bc      	ldr	r4, [r7, #8]
	offset += wr_payload_u8(message, offset, MSG_CONSUMPTION_RES);
	offset += sizeof(uint16_t); // reserve space for the total message size and write it later
	offset += wr_payload_u8(message, offset, entries);
	for(int i = 0; i < entries; i++) {
		offset += wr_payload_u8(message, offset, pData[i].index);
		offset += wr_payload_float(message, offset, pData[i].value);
 8023a78:	4448      	add	r0, r9
 8023a7a:	fa1f f980 	uxth.w	r9, r0

		uint8_t len = (uint8_t) strlen(pData[i].p_unit);
 8023a7e:	4620      	mov	r0, r4
 8023a80:	f009 fd71 	bl	802d566 <strlen>
		offset += wr_payload_u8(message, offset, len);
 8023a84:	f109 0e01 	add.w	lr, r9, #1
 8023a88:	fa0f f989 	sxth.w	r9, r9
 8023a8c:	fa1f fe8e 	uxth.w	lr, lr
		for(int k = 0; k < len; k++)
 8023a90:	f010 0cff 	ands.w	ip, r0, #255	; 0xff
	offset += wr_payload_u8(message, offset, entries);
	for(int i = 0; i < entries; i++) {
		offset += wr_payload_u8(message, offset, pData[i].index);
		offset += wr_payload_float(message, offset, pData[i].value);

		uint8_t len = (uint8_t) strlen(pData[i].p_unit);
 8023a94:	f80d 0009 	strb.w	r0, [sp, r9]
		offset += wr_payload_u8(message, offset, len);
 8023a98:	fa1f f38e 	uxth.w	r3, lr
		for(int k = 0; k < len; k++)
 8023a9c:	d00f      	beq.n	8023abe <send_consumption_response+0x86>
 8023a9e:	4620      	mov	r0, r4
 8023aa0:	eb04 010c 	add.w	r1, r4, ip
		{
			offset += wr_payload_u8(message, offset, pData[i].p_unit[k]);
 8023aa4:	f810 4b01 	ldrb.w	r4, [r0], #1
 8023aa8:	b21a      	sxth	r2, r3
		offset += wr_payload_u8(message, offset, pData[i].index);
		offset += wr_payload_float(message, offset, pData[i].value);

		uint8_t len = (uint8_t) strlen(pData[i].p_unit);
		offset += wr_payload_u8(message, offset, len);
		for(int k = 0; k < len; k++)
 8023aaa:	4288      	cmp	r0, r1
 8023aac:	f103 0301 	add.w	r3, r3, #1
 8023ab0:	f80d 4002 	strb.w	r4, [sp, r2]
 8023ab4:	b29b      	uxth	r3, r3
 8023ab6:	d1f5      	bne.n	8023aa4 <send_consumption_response+0x6c>
 8023ab8:	eb0e 000c 	add.w	r0, lr, ip
 8023abc:	b283      	uxth	r3, r0
	uint8_t endpoint = mcu_base_endpoint;

	offset += wr_payload_u8(message, offset, MSG_CONSUMPTION_RES);
	offset += sizeof(uint16_t); // reserve space for the total message size and write it later
	offset += wr_payload_u8(message, offset, entries);
	for(int i = 0; i < entries; i++) {
 8023abe:	f108 0801 	add.w	r8, r8, #1
 8023ac2:	45a8      	cmp	r8, r5
 8023ac4:	f107 070c 	add.w	r7, r7, #12
 8023ac8:	d1c7      	bne.n	8023a5a <send_consumption_response+0x22>
 8023aca:	b29c      	uxth	r4, r3
 8023acc:	0a25      	lsrs	r5, r4, #8
 8023ace:	b2db      	uxtb	r3, r3
		}
	}
	wr_payload_u16(message,1,offset);

	/* send message */
	protocol_send_header(endpoint, offset);
 8023ad0:	4630      	mov	r0, r6
 8023ad2:	4621      	mov	r1, r4

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 8023ad4:	f88d 3001 	strb.w	r3, [sp, #1]
}

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 8023ad8:	f88d 5002 	strb.w	r5, [sp, #2]
 8023adc:	f000 fe78 	bl	80247d0 <protocol_send_header>
	protocol_send_payload(message, offset);
 8023ae0:	4668      	mov	r0, sp
 8023ae2:	4621      	mov	r1, r4
 8023ae4:	f000 fe88 	bl	80247f8 <protocol_send_payload>
	protocol_send_tail();
 8023ae8:	f000 fe88 	bl	80247fc <protocol_send_tail>

	return RADAR_ERR_OK;
}
 8023aec:	2000      	movs	r0, #0
 8023aee:	b041      	add	sp, #260	; 0x104
 8023af0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	uint8_t endpoint = mcu_base_endpoint;

	offset += wr_payload_u8(message, offset, MSG_CONSUMPTION_RES);
	offset += sizeof(uint16_t); // reserve space for the total message size and write it later
	offset += wr_payload_u8(message, offset, entries);
	for(int i = 0; i < entries; i++) {
 8023af4:	2304      	movs	r3, #4
 8023af6:	461c      	mov	r4, r3
 8023af8:	e7ea      	b.n	8023ad0 <send_consumption_response+0x98>
 8023afa:	bf00      	nop
 8023afc:	1ffe99c8 	.word	0x1ffe99c8

08023b00 <ep_radar_mcu_base_handle_message>:

uint32_t g_detected_rf_shield_id = 0;

uint16_t ep_radar_mcu_base_handle_message(uint8_t endpoint, uint8_t *message_data,
											uint16_t num_bytes,	void* context)
{
 8023b00:	b5f0      	push	{r4, r5, r6, r7, lr}
	mcu_base_endpoint = endpoint;

	switch (message_data[0])
 8023b02:	780b      	ldrb	r3, [r1, #0]
uint32_t g_detected_rf_shield_id = 0;

uint16_t ep_radar_mcu_base_handle_message(uint8_t endpoint, uint8_t *message_data,
											uint16_t num_bytes,	void* context)
{
	mcu_base_endpoint = endpoint;
 8023b04:	4c58      	ldr	r4, [pc, #352]	; (8023c68 <ep_radar_mcu_base_handle_message+0x168>)

	switch (message_data[0])
 8023b06:	3bd0      	subs	r3, #208	; 0xd0

uint32_t g_detected_rf_shield_id = 0;

uint16_t ep_radar_mcu_base_handle_message(uint8_t endpoint, uint8_t *message_data,
											uint16_t num_bytes,	void* context)
{
 8023b08:	b085      	sub	sp, #20
 8023b0a:	4605      	mov	r5, r0
	mcu_base_endpoint = endpoint;
 8023b0c:	7020      	strb	r0, [r4, #0]

	switch (message_data[0])
 8023b0e:	2b14      	cmp	r3, #20
 8023b10:	d80f      	bhi.n	8023b32 <ep_radar_mcu_base_handle_message+0x32>
 8023b12:	e8df f003 	tbb	[pc, r3]
 8023b16:	0e12      	.short	0x0e12
 8023b18:	0e0e0e39 	.word	0x0e0e0e39
 8023b1c:	0e0e0e0e 	.word	0x0e0e0e0e
 8023b20:	0e0e0e0e 	.word	0x0e0e0e0e
 8023b24:	0e490e0e 	.word	0x0e490e0e
 8023b28:	0e7b      	.short	0x0e7b
 8023b2a:	0b          	.byte	0x0b
 8023b2b:	00          	.byte	0x00
			return RADAR_ERR_OK;
		}
		break;

	case MSG_PARA_FACTORY_RESET_IND:
		if (num_bytes == 1)
 8023b2c:	2a01      	cmp	r2, #1
 8023b2e:	f000 8089 	beq.w	8023c44 <ep_radar_mcu_base_handle_message+0x144>

	default:
		break;
	}

	return PROTOCOL_STATUS_INVALID_PAYLOAD;
 8023b32:	f64f 70ff 	movw	r0, #65535	; 0xffff
}
 8023b36:	b005      	add	sp, #20
 8023b38:	bdf0      	pop	{r4, r5, r6, r7, pc}

	switch (message_data[0])
	{

	case MSG_CONSUMPTION_DEF_IND:
		if (num_bytes == 1)
 8023b3a:	2a01      	cmp	r2, #1
 8023b3c:	d1f9      	bne.n	8023b32 <ep_radar_mcu_base_handle_message+0x32>
		{
			static uint8_t message[512]; // allocate statically, rather then on the call stack!
			memset(message, 0, sizeof(message));
 8023b3e:	2100      	movs	r1, #0
 8023b40:	f44f 7200 	mov.w	r2, #512	; 0x200
 8023b44:	4849      	ldr	r0, [pc, #292]	; (8023c6c <ep_radar_mcu_base_handle_message+0x16c>)
 8023b46:	f009 fd06 	bl	802d556 <memset>

			uint32_t offset = 0;
			para_consumption_def_t *p_consumption_def_list = radar_get_consumption_labels();
 8023b4a:	f7fd f8a3 	bl	8020c94 <radar_get_consumption_labels>
			if (p_consumption_def_list == NULL)
 8023b4e:	2800      	cmp	r0, #0
 8023b50:	f000 8088 	beq.w	8023c64 <ep_radar_mcu_base_handle_message+0x164>
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8023b54:	4c45      	ldr	r4, [pc, #276]	; (8023c6c <ep_radar_mcu_base_handle_message+0x16c>)
			}

			offset += wr_payload_u8(message, 0, MSG_CONSUMPTION_DEF_RES);
			offset += sizeof(uint16_t); // size if uint16

			offset += wr_payload_helper_string_list(message, offset, p_consumption_def_list->num_labels, p_consumption_def_list->p_consumption_labels);
 8023b56:	6843      	ldr	r3, [r0, #4]
 8023b58:	22d1      	movs	r2, #209	; 0xd1
 8023b5a:	7022      	strb	r2, [r4, #0]
 8023b5c:	6802      	ldr	r2, [r0, #0]
 8023b5e:	2103      	movs	r1, #3
 8023b60:	4620      	mov	r0, r4
 8023b62:	f000 feff 	bl	8024964 <wr_payload_helper_string_list>
 8023b66:	1cc3      	adds	r3, r0, #3

			// write size values of the message!
			wr_payload_u16(message, 1, (uint16_t)offset);
 8023b68:	b29e      	uxth	r6, r3
}

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 8023b6a:	0a32      	lsrs	r2, r6, #8
    payload[offset    ] =  value        & 0xFF;
 8023b6c:	7063      	strb	r3, [r4, #1]
}

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 8023b6e:	70a2      	strb	r2, [r4, #2]

			/* send message */
			protocol_send_header(endpoint, offset);
 8023b70:	4628      	mov	r0, r5
 8023b72:	4631      	mov	r1, r6
 8023b74:	f000 fe2c 	bl	80247d0 <protocol_send_header>
			protocol_send_payload(message, offset);
 8023b78:	4620      	mov	r0, r4
 8023b7a:	4631      	mov	r1, r6
 8023b7c:	f000 fe3c 	bl	80247f8 <protocol_send_payload>
			protocol_send_tail();
 8023b80:	f000 fe3c 	bl	80247fc <protocol_send_tail>

			return RADAR_ERR_OK;
 8023b84:	2000      	movs	r0, #0
 8023b86:	e7d6      	b.n	8023b36 <ep_radar_mcu_base_handle_message+0x36>
		}
		break;
	case MSG_CONSUMPTION_IND:
		if (num_bytes == 5)
 8023b88:	2a05      	cmp	r2, #5
 8023b8a:	d1d2      	bne.n	8023b32 <ep_radar_mcu_base_handle_message+0x32>
}

static inline uint32_t rd_payload_u32(const uint8_t* payload, size_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
 8023b8c:	78cb      	ldrb	r3, [r1, #3]
                      ((uint32_t)payload[offset    ]));
}

static inline uint32_t rd_payload_u32(const uint8_t* payload, size_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
 8023b8e:	790c      	ldrb	r4, [r1, #4]
           (((uint32_t)payload[offset + 2]) << 16) |
           (((uint32_t)payload[offset + 1]) <<  8) |
            ((uint32_t)payload[offset    ]);
 8023b90:	784a      	ldrb	r2, [r1, #1]

static inline uint32_t rd_payload_u32(const uint8_t* payload, size_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
           (((uint32_t)payload[offset + 1]) <<  8) |
 8023b92:	7888      	ldrb	r0, [r1, #2]
}

static inline uint32_t rd_payload_u32(const uint8_t* payload, size_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
 8023b94:	041b      	lsls	r3, r3, #16
                      ((uint32_t)payload[offset    ]));
}

static inline uint32_t rd_payload_u32(const uint8_t* payload, size_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
 8023b96:	ea43 6304 	orr.w	r3, r3, r4, lsl #24
 8023b9a:	4313      	orrs	r3, r2
		{
			uint16_t in_offset = 1;
			uint32_t repeat_count = rd_payload_u32(message_data, in_offset);
			set_consumption_repeat_count(repeat_count);
 8023b9c:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
 8023ba0:	f7fd f87e 	bl	8020ca0 <set_consumption_repeat_count>
			return RADAR_ERR_OK;
 8023ba4:	2000      	movs	r0, #0
 8023ba6:	e7c6      	b.n	8023b36 <ep_radar_mcu_base_handle_message+0x36>
		}
		break;

	case MSG_RF_SHIELD_ID_IND:
		if (num_bytes == 1)
 8023ba8:	2a01      	cmp	r2, #1
 8023baa:	d1c2      	bne.n	8023b32 <ep_radar_mcu_base_handle_message+0x32>
		{
			/* we received a request to provide the detected RF shield id */

			static uint8_t message[200]; // allocate statically, rather then on the call stack!
			memset(message, 0, sizeof(message));
 8023bac:	4830      	ldr	r0, [pc, #192]	; (8023c70 <ep_radar_mcu_base_handle_message+0x170>)
 8023bae:	2100      	movs	r1, #0
 8023bb0:	22c8      	movs	r2, #200	; 0xc8
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8023bb2:	4607      	mov	r7, r0
 8023bb4:	f009 fccf 	bl	802d556 <memset>

			/* get rf board id variant */
			uint32_t index = ds_get_board_variant();
 8023bb8:	f7fc fa22 	bl	8020000 <ds_get_board_variant>

			if (index == 0 || index > sizeof(rf_shield_info) / sizeof(rf_shield_info[0]) + 1 )
 8023bbc:	3801      	subs	r0, #1
 8023bbe:	2803      	cmp	r0, #3
 8023bc0:	bf28      	it	cs
 8023bc2:	2000      	movcs	r0, #0

			uint32_t offset = 0;
			offset += wr_payload_u8(message, offset, MSG_RF_SHIELD_ID_RES);
			offset += wr_payload_u8(message, offset, p_board_info->major_version);
			offset += wr_payload_u8(message, offset, p_board_info->minor_version);
			offset += wr_payload_string(message, offset, p_info->rf_shield_board_id);
 8023bc4:	4b2b      	ldr	r3, [pc, #172]	; (8023c74 <ep_radar_mcu_base_handle_message+0x174>)
 8023bc6:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8023bca:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 8023bce:	23e1      	movs	r3, #225	; 0xe1
 8023bd0:	703b      	strb	r3, [r7, #0]
 8023bd2:	2400      	movs	r4, #0
 8023bd4:	2302      	movs	r3, #2
 8023bd6:	707b      	strb	r3, [r7, #1]
 8023bd8:	6882      	ldr	r2, [r0, #8]
 8023bda:	70bc      	strb	r4, [r7, #2]
 8023bdc:	2103      	movs	r1, #3
 8023bde:	4638      	mov	r0, r7
 8023be0:	f000 fe5e 	bl	80248a0 <wr_payload_string>
 8023be4:	1cc6      	adds	r6, r0, #3
			offset += wr_payload_string(message, offset, p_board_info->description);
 8023be6:	4a24      	ldr	r2, [pc, #144]	; (8023c78 <ep_radar_mcu_base_handle_message+0x178>)
 8023be8:	4631      	mov	r1, r6
 8023bea:	4638      	mov	r0, r7
 8023bec:	f000 fe58 	bl	80248a0 <wr_payload_string>
 8023bf0:	4430      	add	r0, r6

			/* send message */
			protocol_send_header(endpoint, offset);
 8023bf2:	b286      	uxth	r6, r0
 8023bf4:	4631      	mov	r1, r6
 8023bf6:	4628      	mov	r0, r5
 8023bf8:	f000 fdea 	bl	80247d0 <protocol_send_header>
			protocol_send_payload(message, offset);
 8023bfc:	4638      	mov	r0, r7
 8023bfe:	4631      	mov	r1, r6
 8023c00:	f000 fdfa 	bl	80247f8 <protocol_send_payload>
			protocol_send_tail();
 8023c04:	f000 fdfa 	bl	80247fc <protocol_send_tail>
			return RADAR_ERR_OK;
 8023c08:	4620      	mov	r0, r4
 8023c0a:	e794      	b.n	8023b36 <ep_radar_mcu_base_handle_message+0x36>
		}
		break;

	case MSG_STORE_PARAMETER_IND:
		if (num_bytes == 1)
 8023c0c:	2a01      	cmp	r2, #1
 8023c0e:	d190      	bne.n	8023b32 <ep_radar_mcu_base_handle_message+0x32>
		{
			/* we received a request to store the Parameter persistent */
			static uint8_t message[10]; // allocate statically, rather then on the call stack!
			memset(message, 0, sizeof(message));
 8023c10:	4e1a      	ldr	r6, [pc, #104]	; (8023c7c <ep_radar_mcu_base_handle_message+0x17c>)
 8023c12:	9201      	str	r2, [sp, #4]
 8023c14:	2400      	movs	r4, #0
 8023c16:	8134      	strh	r4, [r6, #8]
 8023c18:	6034      	str	r4, [r6, #0]
 8023c1a:	6074      	str	r4, [r6, #4]

			/* store the parameters persistent */
			ds_hw_para_store_persistent();
 8023c1c:	f7fc fcd4 	bl	80205c8 <ds_hw_para_store_persistent>
			ds_algo_para_store_persistent();
 8023c20:	f7fc fca6 	bl	8020570 <ds_algo_para_store_persistent>

			uint16_t offset = 0;
			offset += wr_payload_u8(message, 0, MSG_STORE_PARAMETER_RES);

			/* send message */
			protocol_send_header(endpoint, offset);
 8023c24:	9a01      	ldr	r2, [sp, #4]
 8023c26:	23e3      	movs	r3, #227	; 0xe3
 8023c28:	4628      	mov	r0, r5
 8023c2a:	4611      	mov	r1, r2
 8023c2c:	7033      	strb	r3, [r6, #0]
			/* restore parameter from factory settings! */
			ds_hw_para_factory_reset();
			ds_algo_para_factory_reset();

			/* send message */
			protocol_send_header(endpoint, offset);
 8023c2e:	f000 fdcf 	bl	80247d0 <protocol_send_header>
			protocol_send_payload(message, offset);
 8023c32:	9a01      	ldr	r2, [sp, #4]
 8023c34:	4630      	mov	r0, r6
 8023c36:	4611      	mov	r1, r2
 8023c38:	f000 fdde 	bl	80247f8 <protocol_send_payload>
			protocol_send_tail();
 8023c3c:	f000 fdde 	bl	80247fc <protocol_send_tail>
			return RADAR_ERR_OK;
 8023c40:	4620      	mov	r0, r4
 8023c42:	e778      	b.n	8023b36 <ep_radar_mcu_base_handle_message+0x36>
	case MSG_PARA_FACTORY_RESET_IND:
		if (num_bytes == 1)
		{
			/* we received a request to store the Parameter persistent */
			static uint8_t message[10]; // allocate statically, rather then on the call stack!
			memset(message, 0, sizeof(message));
 8023c44:	4e0e      	ldr	r6, [pc, #56]	; (8023c80 <ep_radar_mcu_base_handle_message+0x180>)
 8023c46:	9201      	str	r2, [sp, #4]
 8023c48:	21e5      	movs	r1, #229	; 0xe5
 8023c4a:	2400      	movs	r4, #0
 8023c4c:	6034      	str	r4, [r6, #0]
 8023c4e:	6074      	str	r4, [r6, #4]
 8023c50:	7031      	strb	r1, [r6, #0]
 8023c52:	8134      	strh	r4, [r6, #8]

			uint16_t offset = 0;
			offset += wr_payload_u8(message, 0, MSG_PARA_FACTORY_RESET_RES);

			/* restore parameter from factory settings! */
			ds_hw_para_factory_reset();
 8023c54:	f7fc fc98 	bl	8020588 <ds_hw_para_factory_reset>
			ds_algo_para_factory_reset();
 8023c58:	f7fc fc70 	bl	802053c <ds_algo_para_factory_reset>

			/* send message */
			protocol_send_header(endpoint, offset);
 8023c5c:	9a01      	ldr	r2, [sp, #4]
 8023c5e:	4628      	mov	r0, r5
 8023c60:	4611      	mov	r1, r2
 8023c62:	e7e4      	b.n	8023c2e <ep_radar_mcu_base_handle_message+0x12e>
			uint32_t offset = 0;
			para_consumption_def_t *p_consumption_def_list = radar_get_consumption_labels();
			if (p_consumption_def_list == NULL)
			{
				para_consumption_def_t empty_def = {.num_labels = 0};
				p_consumption_def_list = &empty_def;
 8023c64:	a802      	add	r0, sp, #8
 8023c66:	e775      	b.n	8023b54 <ep_radar_mcu_base_handle_message+0x54>
 8023c68:	1ffe99c8 	.word	0x1ffe99c8
 8023c6c:	1ffe99cc 	.word	0x1ffe99cc
 8023c70:	1ffe9bcc 	.word	0x1ffe9bcc
 8023c74:	1ffe90bc 	.word	0x1ffe90bc
 8023c78:	0802d850 	.word	0x0802d850
 8023c7c:	1ffe9c94 	.word	0x1ffe9c94
 8023c80:	1ffe9ca0 	.word	0x1ffe9ca0

08023c84 <ep_radar_mcu_base_handle_change>:
{
	Radar_Handle_t radar_driver = (Radar_Handle_t)context;

	(void)radar_driver; /* Suppress compiler warnings of unused variable */

	switch (what)
 8023c84:	2a14      	cmp	r2, #20
 8023c86:	d000      	beq.n	8023c8a <ep_radar_mcu_base_handle_change+0x6>
 8023c88:	4770      	bx	lr
}

//============================================================================

void ep_radar_mcu_base_handle_change(uint8_t endpoint, void* context, uint32_t what)
{
 8023c8a:	b508      	push	{r3, lr}

	switch (what)
	{

	case EP_RADAR_CHNG_CURRENT_CONSUMPTION:
		inc_consumption_repeat_count(1);
 8023c8c:	2001      	movs	r0, #1
 8023c8e:	f7fd f80d 	bl	8020cac <inc_consumption_repeat_count>
		mcu_base_updates();
		break;
	default:
		break;
	}
}
 8023c92:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	switch (what)
	{

	case EP_RADAR_CHNG_CURRENT_CONSUMPTION:
		inc_consumption_repeat_count(1);
		mcu_base_updates();
 8023c96:	f7fd b811 	b.w	8020cbc <mcu_base_updates>
 8023c9a:	bf00      	nop

08023c9c <send_result_response>:
   6. EXPORTED FUNCTIONS
==============================================================================
 */

void send_result_response(uint8_t endpoint, pulse_result_response_t *p_pulse_result)
{
 8023c9c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	static uint32_t result_cnt = 0; // zero init at startup!
	static uint8_t message[sizeof(pulse_result_response_t)+20];
	int16_t offset = 0;

	offset += wr_payload_u8(message, offset, MSG_RESULT_RES);
	offset += wr_payload_u32(message, offset, result_cnt);
 8023ca0:	4e26      	ldr	r6, [pc, #152]	; (8023d3c <send_result_response+0xa0>)
 8023ca2:	4d27      	ldr	r5, [pc, #156]	; (8023d40 <send_result_response+0xa4>)
 8023ca4:	6833      	ldr	r3, [r6, #0]
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 8023ca6:	706b      	strb	r3, [r5, #1]
   6. EXPORTED FUNCTIONS
==============================================================================
 */

void send_result_response(uint8_t endpoint, pulse_result_response_t *p_pulse_result)
{
 8023ca8:	4688      	mov	r8, r1
}

static inline size_t wr_payload_u32(uint8_t* payload, size_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8023caa:	0e1c      	lsrs	r4, r3, #24
    payload[offset + 2] = (value >> 16) & 0xFF;
 8023cac:	0c1a      	lsrs	r2, r3, #16
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8023cae:	2136      	movs	r1, #54	; 0x36
static inline size_t wr_payload_u32(uint8_t* payload, size_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
 8023cb0:	0a1b      	lsrs	r3, r3, #8
}

static inline size_t wr_payload_u32(uint8_t* payload, size_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8023cb2:	712c      	strb	r4, [r5, #4]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8023cb4:	7029      	strb	r1, [r5, #0]

static inline size_t wr_payload_u32(uint8_t* payload, size_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
 8023cb6:	70ea      	strb	r2, [r5, #3]
    payload[offset + 1] = (value >>  8) & 0xFF;
 8023cb8:	70ab      	strb	r3, [r5, #2]
	static uint8_t message[sizeof(pulse_result_response_t)+20];
	int16_t offset = 0;

	offset += wr_payload_u8(message, offset, MSG_RESULT_RES);
	offset += wr_payload_u32(message, offset, result_cnt);
	offset += wr_payload_u32(message, offset, p_pulse_result->frame_count);
 8023cba:	f8d8 3000 	ldr.w	r3, [r8]
    payload[offset    ] =  value        & 0xFF;
 8023cbe:	716b      	strb	r3, [r5, #5]
}

static inline size_t wr_payload_u32(uint8_t* payload, size_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8023cc0:	0e19      	lsrs	r1, r3, #24
    payload[offset + 2] = (value >> 16) & 0xFF;
 8023cc2:	0c1a      	lsrs	r2, r3, #16
    payload[offset + 1] = (value >>  8) & 0xFF;
 8023cc4:	0a1b      	lsrs	r3, r3, #8
 8023cc6:	71ab      	strb	r3, [r5, #6]
}

static inline size_t wr_payload_u32(uint8_t* payload, size_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8023cc8:	7229      	strb	r1, [r5, #8]
    payload[offset + 2] = (value >> 16) & 0xFF;
 8023cca:	71ea      	strb	r2, [r5, #7]
   6. EXPORTED FUNCTIONS
==============================================================================
 */

void send_result_response(uint8_t endpoint, pulse_result_response_t *p_pulse_result)
{
 8023ccc:	4607      	mov	r7, r0
	int16_t offset = 0;

	offset += wr_payload_u8(message, offset, MSG_RESULT_RES);
	offset += wr_payload_u32(message, offset, result_cnt);
	offset += wr_payload_u32(message, offset, p_pulse_result->frame_count);
	offset += wr_payload_float(message, offset, p_pulse_result->velocity_mps);
 8023cce:	f8d8 2004 	ldr.w	r2, [r8, #4]
 8023cd2:	2109      	movs	r1, #9
 8023cd4:	4628      	mov	r0, r5
 8023cd6:	f000 fdd5 	bl	8024884 <wr_payload_float>
 8023cda:	3009      	adds	r0, #9
 8023cdc:	b284      	uxth	r4, r0
	offset += wr_payload_float(message, offset, p_pulse_result->level_nu);
 8023cde:	b221      	sxth	r1, r4
 8023ce0:	f8d8 2008 	ldr.w	r2, [r8, #8]
 8023ce4:	4628      	mov	r0, r5
 8023ce6:	f000 fdcd 	bl	8024884 <wr_payload_float>
 8023cea:	4420      	add	r0, r4
 8023cec:	b280      	uxth	r0, r0
	offset += wr_payload_u8(message, offset, p_pulse_result->target_departing_bool);
 8023cee:	b203      	sxth	r3, r0
 8023cf0:	f898 200c 	ldrb.w	r2, [r8, #12]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8023cf4:	54ea      	strb	r2, [r5, r3]
 8023cf6:	1c43      	adds	r3, r0, #1
	offset += wr_payload_u8(message, offset, p_pulse_result->target_approaching_bool);
 8023cf8:	b21b      	sxth	r3, r3
 8023cfa:	f898 200d 	ldrb.w	r2, [r8, #13]
 8023cfe:	54ea      	strb	r2, [r5, r3]
 8023d00:	1c83      	adds	r3, r0, #2
	offset += wr_payload_u8(message, offset, p_pulse_result->motion_detected_bool);
 8023d02:	b21b      	sxth	r3, r3
 8023d04:	f898 200e 	ldrb.w	r2, [r8, #14]
 8023d08:	54ea      	strb	r2, [r5, r3]
 8023d0a:	3003      	adds	r0, #3
 8023d0c:	b284      	uxth	r4, r0
	offset += wr_payload_float(message, offset, p_pulse_result->doppler_frequency_hz);
 8023d0e:	f8d8 2010 	ldr.w	r2, [r8, #16]
 8023d12:	b221      	sxth	r1, r4
 8023d14:	4628      	mov	r0, r5
 8023d16:	f000 fdb5 	bl	8024884 <wr_payload_float>
 8023d1a:	4420      	add	r0, r4
 8023d1c:	b284      	uxth	r4, r0

	/* send message */
	protocol_send_header(endpoint, offset);
 8023d1e:	4621      	mov	r1, r4
 8023d20:	4638      	mov	r0, r7
 8023d22:	f000 fd55 	bl	80247d0 <protocol_send_header>
	protocol_send_payload(message, offset);
 8023d26:	4628      	mov	r0, r5
 8023d28:	4621      	mov	r1, r4
 8023d2a:	f000 fd65 	bl	80247f8 <protocol_send_payload>
	protocol_send_tail();
 8023d2e:	f000 fd65 	bl	80247fc <protocol_send_tail>

	result_cnt += 1;
 8023d32:	6833      	ldr	r3, [r6, #0]
 8023d34:	3301      	adds	r3, #1
 8023d36:	6033      	str	r3, [r6, #0]
 8023d38:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8023d3c:	1ffeb1d4 	.word	0x1ffeb1d4
 8023d40:	1ffe9eac 	.word	0x1ffe9eac

08023d44 <send_parameter_values>:

//============================================================================


void send_parameter_values(uint8_t endpoint, pulse_para_values_t *p_para)
{
 8023d44:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8023d46:	4d27      	ldr	r5, [pc, #156]	; (8023de4 <send_parameter_values+0xa0>)
 8023d48:	2331      	movs	r3, #49	; 0x31
 8023d4a:	702b      	strb	r3, [r5, #0]
 8023d4c:	460f      	mov	r7, r1
 8023d4e:	4606      	mov	r6, r0
	size_t offset = 0;
	static uint8_t message[256];

	offset += wr_payload_u8(message,    offset, MSG_PARA_VALUES_RES);
	offset += wr_payload_float(message, offset, p_para->max_speed_mps);
 8023d50:	680a      	ldr	r2, [r1, #0]
 8023d52:	4628      	mov	r0, r5
 8023d54:	2101      	movs	r1, #1
 8023d56:	f000 fd95 	bl	8024884 <wr_payload_float>
 8023d5a:	1c44      	adds	r4, r0, #1
	offset += wr_payload_float(message, offset, p_para->min_speed_mps);
 8023d5c:	4621      	mov	r1, r4
 8023d5e:	687a      	ldr	r2, [r7, #4]
 8023d60:	4628      	mov	r0, r5
 8023d62:	f000 fd8f 	bl	8024884 <wr_payload_float>
 8023d66:	4404      	add	r4, r0
	offset += wr_payload_float(message, offset, p_para->frame_time_sec);
 8023d68:	4621      	mov	r1, r4
 8023d6a:	68ba      	ldr	r2, [r7, #8]
 8023d6c:	4628      	mov	r0, r5
 8023d6e:	f000 fd89 	bl	8024884 <wr_payload_float>

	offset += wr_payload_u16(message,   offset, p_para->number_of_samples_nu);
 8023d72:	89bb      	ldrh	r3, [r7, #12]
	static uint8_t message[256];

	offset += wr_payload_u8(message,    offset, MSG_PARA_VALUES_RES);
	offset += wr_payload_float(message, offset, p_para->max_speed_mps);
	offset += wr_payload_float(message, offset, p_para->min_speed_mps);
	offset += wr_payload_float(message, offset, p_para->frame_time_sec);
 8023d74:	4420      	add	r0, r4
}

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 8023d76:	182a      	adds	r2, r5, r0
 8023d78:	0a19      	lsrs	r1, r3, #8
 8023d7a:	7051      	strb	r1, [r2, #1]

	offset += wr_payload_u16(message,   offset, p_para->number_of_samples_nu);
 8023d7c:	1c84      	adds	r4, r0, #2
    payload[offset    ] =  value        & 0xFF;
 8023d7e:	542b      	strb	r3, [r5, r0]
	offset += wr_payload_float(message, offset, p_para->sampling_freq_hz);
 8023d80:	693a      	ldr	r2, [r7, #16]
 8023d82:	4621      	mov	r1, r4
 8023d84:	4628      	mov	r0, r5
 8023d86:	f000 fd7d 	bl	8024884 <wr_payload_float>
 8023d8a:	4404      	add	r4, r0
	offset += wr_payload_float(message, offset, p_para->doppler_sensitivity_nu);
 8023d8c:	4621      	mov	r1, r4
 8023d8e:	697a      	ldr	r2, [r7, #20]
 8023d90:	4628      	mov	r0, r5
 8023d92:	f000 fd77 	bl	8024884 <wr_payload_float>
 8023d96:	4404      	add	r4, r0
	offset += wr_payload_float(message, offset, p_para->motion_sensitivity_nu);
 8023d98:	4621      	mov	r1, r4
 8023d9a:	69ba      	ldr	r2, [r7, #24]
 8023d9c:	4628      	mov	r0, r5
 8023d9e:	f000 fd71 	bl	8024884 <wr_payload_float>
 8023da2:	4420      	add	r0, r4

	offset += wr_payload_u8(message,    offset, p_para->use_high_gain_doppler_bool);
 8023da4:	7f3b      	ldrb	r3, [r7, #28]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8023da6:	542b      	strb	r3, [r5, r0]
 8023da8:	182b      	adds	r3, r5, r0
	offset += wr_payload_u8(message,    offset, p_para->continuous_mode_bool);
 8023daa:	7f7a      	ldrb	r2, [r7, #29]
 8023dac:	705a      	strb	r2, [r3, #1]
	offset += wr_payload_u16(message,   offset, p_para->number_of_skip_samples_nu);
 8023dae:	8bfa      	ldrh	r2, [r7, #30]

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 8023db0:	709a      	strb	r2, [r3, #2]
}

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 8023db2:	0a12      	lsrs	r2, r2, #8
 8023db4:	70da      	strb	r2, [r3, #3]
	offset += wr_payload_u32(message,   offset, p_para->pulse_width_usec);
 8023db6:	6a3a      	ldr	r2, [r7, #32]
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 8023db8:	711a      	strb	r2, [r3, #4]
 8023dba:	3008      	adds	r0, #8

	/* send message */
	protocol_send_header(endpoint, offset);
 8023dbc:	b284      	uxth	r4, r0
}

static inline size_t wr_payload_u32(uint8_t* payload, size_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8023dbe:	0e17      	lsrs	r7, r2, #24
 8023dc0:	4630      	mov	r0, r6
    payload[offset + 2] = (value >> 16) & 0xFF;
 8023dc2:	0c16      	lsrs	r6, r2, #16
    payload[offset + 1] = (value >>  8) & 0xFF;
 8023dc4:	0a12      	lsrs	r2, r2, #8
 8023dc6:	4621      	mov	r1, r4
}

static inline size_t wr_payload_u32(uint8_t* payload, size_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8023dc8:	71df      	strb	r7, [r3, #7]
    payload[offset + 2] = (value >> 16) & 0xFF;
 8023dca:	719e      	strb	r6, [r3, #6]
    payload[offset + 1] = (value >>  8) & 0xFF;
 8023dcc:	715a      	strb	r2, [r3, #5]
 8023dce:	f000 fcff 	bl	80247d0 <protocol_send_header>
	protocol_send_payload(message, offset);
 8023dd2:	4628      	mov	r0, r5
 8023dd4:	4621      	mov	r1, r4
 8023dd6:	f000 fd0f 	bl	80247f8 <protocol_send_payload>
	protocol_send_tail();
}
 8023dda:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	offset += wr_payload_u32(message,   offset, p_para->pulse_width_usec);

	/* send message */
	protocol_send_header(endpoint, offset);
	protocol_send_payload(message, offset);
	protocol_send_tail();
 8023dde:	f000 bd0d 	b.w	80247fc <protocol_send_tail>
 8023de2:	bf00      	nop
 8023de4:	1ffea0d4 	.word	0x1ffea0d4

08023de8 <send_pulse_frame_data>:
}

//============================================================================

void send_pulse_frame_data(uint8_t endpoint, acq_buf_obj *p_acq_buf, device_settings_t *p_dev)
{
 8023de8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8023dec:	b091      	sub	sp, #68	; 0x44

	Frame_Info_t frame_info;

	frame_info.num_rx_antennas       = BSP_NUM_RX_ANTENNAS;
	frame_info.num_chirps            = p_acq_buf->params.num_of_chirps_per_frame;
	frame_info.rx_mask               = p_dev->rx_antenna_mask;
 8023dee:	f892 3028 	ldrb.w	r3, [r2, #40]	; 0x28
	static uint8_t transport_buffer[BSP_MAX_ADC_BUFFER_SIZE_BYTES];

	Frame_Info_t frame_info;

	frame_info.num_rx_antennas       = BSP_NUM_RX_ANTENNAS;
	frame_info.num_chirps            = p_acq_buf->params.num_of_chirps_per_frame;
 8023df2:	888a      	ldrh	r2, [r1, #4]
 8023df4:	9205      	str	r2, [sp, #20]
	frame_info.rx_mask               = p_dev->rx_antenna_mask;
	frame_info.adc_resolution        = 12;
	frame_info.interleaved_rx        = 0;
	frame_info.frame_number          = p_acq_buf->frame_counter;
	frame_info.data_format           = RADAR_RX_DATA_COMPLEX;
	frame_info.num_samples_per_chirp = p_acq_buf->params.num_of_samples_per_chirp;
 8023df6:	884a      	ldrh	r2, [r1, #2]
 8023df8:	9208      	str	r2, [sp, #32]
	frame_info.num_rx_antennas       = BSP_NUM_RX_ANTENNAS;
	frame_info.num_chirps            = p_acq_buf->params.num_of_chirps_per_frame;
	frame_info.rx_mask               = p_dev->rx_antenna_mask;
	frame_info.adc_resolution        = 12;
	frame_info.interleaved_rx        = 0;
	frame_info.frame_number          = p_acq_buf->frame_counter;
 8023dfa:	6b4d      	ldr	r5, [r1, #52]	; 0x34
 8023dfc:	9a05      	ldr	r2, [sp, #20]

	Frame_Info_t frame_info;

	frame_info.num_rx_antennas       = BSP_NUM_RX_ANTENNAS;
	frame_info.num_chirps            = p_acq_buf->params.num_of_chirps_per_frame;
	frame_info.rx_mask               = p_dev->rx_antenna_mask;
 8023dfe:	9301      	str	r3, [sp, #4]
}

//============================================================================

void send_pulse_frame_data(uint8_t endpoint, acq_buf_obj *p_acq_buf, device_settings_t *p_dev)
{
 8023e00:	460c      	mov	r4, r1
 8023e02:	9908      	ldr	r1, [sp, #32]
    payload[offset    ] =  value        & 0xFF;
 8023e04:	f88d 502d 	strb.w	r5, [sp, #45]	; 0x2d
	frame_info.frame_number          = p_acq_buf->frame_counter;
	frame_info.data_format           = RADAR_RX_DATA_COMPLEX;
	frame_info.num_samples_per_chirp = p_acq_buf->params.num_of_samples_per_chirp;

	/* Selection of Antenna to output is currently only supported for 12 Bit ADC resolution! */
	if (frame_info.rx_mask == 1)
 8023e08:	3b01      	subs	r3, #1
 8023e0a:	fb01 f202 	mul.w	r2, r1, r2
 8023e0e:	2b01      	cmp	r3, #1
 8023e10:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 8023e14:	bf94      	ite	ls
 8023e16:	2701      	movls	r7, #1
 8023e18:	2702      	movhi	r7, #2
 8023e1a:	00d1      	lsls	r1, r2, #3
	num_samples = frame_info.num_chirps *
				  frame_info.num_samples_per_chirp *
				  num_used_ant *
				  (frame_info.data_format == RADAR_RX_DATA_REAL ? 1 : 2);

	data_size = num_samples * frame_info.adc_resolution;
 8023e1c:	fb07 f101 	mul.w	r1, r7, r1
static inline size_t wr_payload_u32(uint8_t* payload, size_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
 8023e20:	0a2a      	lsrs	r2, r5, #8
}

static inline size_t wr_payload_u32(uint8_t* payload, size_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8023e22:	ea4f 6c15 	mov.w	ip, r5, lsr #24
    payload[offset + 2] = (value >> 16) & 0xFF;
 8023e26:	ea4f 4e15 	mov.w	lr, r5, lsr #16
    payload[offset + 1] = (value >>  8) & 0xFF;
 8023e2a:	9b05      	ldr	r3, [sp, #20]
 8023e2c:	9d08      	ldr	r5, [sp, #32]
    payload[offset    ] =  value        & 0xFF;
 8023e2e:	f8dd 8020 	ldr.w	r8, [sp, #32]
 8023e32:	f8dd a014 	ldr.w	sl, [sp, #20]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8023e36:	f88d 7035 	strb.w	r7, [sp, #53]	; 0x35
	data_size = (data_size >> 3) + ((data_size & 0x07) ? 1 : 0);
 8023e3a:	08c9      	lsrs	r1, r1, #3
 8023e3c:	f04f 0947 	mov.w	r9, #71	; 0x47

	/* send message header */
	protocol_send_header(endpoint, data_size + sizeof(message_header));
 8023e40:	3112      	adds	r1, #18
}

static inline size_t wr_payload_u32(uint8_t* payload, size_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8023e42:	2600      	movs	r6, #0
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
 8023e44:	0a1b      	lsrs	r3, r3, #8
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8023e46:	2701      	movs	r7, #1
 8023e48:	b289      	uxth	r1, r1
 8023e4a:	f89d b004 	ldrb.w	fp, [sp, #4]
 8023e4e:	f88d 902c 	strb.w	r9, [sp, #44]	; 0x2c
static inline size_t wr_payload_u32(uint8_t* payload, size_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
 8023e52:	0a2d      	lsrs	r5, r5, #8
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8023e54:	f04f 090c 	mov.w	r9, #12
static inline size_t wr_payload_u32(uint8_t* payload, size_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
 8023e58:	f88d 202e 	strb.w	r2, [sp, #46]	; 0x2e
 8023e5c:	f88d 3032 	strb.w	r3, [sp, #50]	; 0x32
}

static inline size_t wr_payload_u32(uint8_t* payload, size_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8023e60:	f88d c030 	strb.w	ip, [sp, #48]	; 0x30
    payload[offset + 2] = (value >> 16) & 0xFF;
 8023e64:	f88d e02f 	strb.w	lr, [sp, #47]	; 0x2f
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8023e68:	f88d 703b 	strb.w	r7, [sp, #59]	; 0x3b
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 8023e6c:	f88d a031 	strb.w	sl, [sp, #49]	; 0x31
 8023e70:	f88d 8036 	strb.w	r8, [sp, #54]	; 0x36
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8023e74:	f88d b03a 	strb.w	fp, [sp, #58]	; 0x3a
}

static inline size_t wr_payload_u32(uint8_t* payload, size_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8023e78:	f88d 6034 	strb.w	r6, [sp, #52]	; 0x34
    payload[offset + 2] = (value >> 16) & 0xFF;
 8023e7c:	f88d 6033 	strb.w	r6, [sp, #51]	; 0x33
}

static inline size_t wr_payload_u32(uint8_t* payload, size_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8023e80:	f88d 6039 	strb.w	r6, [sp, #57]	; 0x39
    payload[offset + 2] = (value >> 16) & 0xFF;
 8023e84:	f88d 6038 	strb.w	r6, [sp, #56]	; 0x38
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8023e88:	f88d 603d 	strb.w	r6, [sp, #61]	; 0x3d
static inline size_t wr_payload_u32(uint8_t* payload, size_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
 8023e8c:	f88d 5037 	strb.w	r5, [sp, #55]	; 0x37
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8023e90:	f88d 903c 	strb.w	r9, [sp, #60]	; 0x3c
 8023e94:	f000 fc9c 	bl	80247d0 <protocol_send_header>
	protocol_send_payload(message_header, sizeof(message_header));
 8023e98:	2112      	movs	r1, #18
 8023e9a:	a80b      	add	r0, sp, #44	; 0x2c
 8023e9c:	f000 fcac 	bl	80247f8 <protocol_send_payload>

	uint8_t *destPtr = &transport_buffer[0];
	uint8_t *srcPtr = p_acq_buf->p_acq_buf;

	uint32_t channel_inc = frame_info.num_samples_per_chirp * sizeof(uint16_t);
 8023ea0:	fa08 f107 	lsl.w	r1, r8, r7
 8023ea4:	4643      	mov	r3, r8
 8023ea6:	9103      	str	r1, [sp, #12]
	uint32_t chirp_inc = channel_inc * frame_info.num_rx_antennas * (frame_info.data_format == RADAR_RX_DATA_REAL ? 1 : 2);

	uint32_t processed_out_bytes = 0;

	for (uint32_t chirp = 0; chirp < frame_info.num_chirps; chirp++)
 8023ea8:	4652      	mov	r2, sl

	uint8_t *destPtr = &transport_buffer[0];
	uint8_t *srcPtr = p_acq_buf->p_acq_buf;

	uint32_t channel_inc = frame_info.num_samples_per_chirp * sizeof(uint16_t);
	uint32_t chirp_inc = channel_inc * frame_info.num_rx_antennas * (frame_info.data_format == RADAR_RX_DATA_REAL ? 1 : 2);
 8023eaa:	00d9      	lsls	r1, r3, #3
	/* send message header */
	protocol_send_header(endpoint, data_size + sizeof(message_header));
	protocol_send_payload(message_header, sizeof(message_header));

	uint8_t *destPtr = &transport_buffer[0];
	uint8_t *srcPtr = p_acq_buf->p_acq_buf;
 8023eac:	6ae7      	ldr	r7, [r4, #44]	; 0x2c

	uint32_t channel_inc = frame_info.num_samples_per_chirp * sizeof(uint16_t);
	uint32_t chirp_inc = channel_inc * frame_info.num_rx_antennas * (frame_info.data_format == RADAR_RX_DATA_REAL ? 1 : 2);
 8023eae:	9107      	str	r1, [sp, #28]

	uint32_t processed_out_bytes = 0;

	for (uint32_t chirp = 0; chirp < frame_info.num_chirps; chirp++)
 8023eb0:	2a00      	cmp	r2, #0
 8023eb2:	d057      	beq.n	8023f64 <send_pulse_frame_data+0x17c>
 8023eb4:	f1a8 0302 	sub.w	r3, r8, #2
 8023eb8:	085b      	lsrs	r3, r3, #1
 8023eba:	3301      	adds	r3, #1
 8023ebc:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8023ec0:	9306      	str	r3, [sp, #24]
 8023ec2:	b29b      	uxth	r3, r3
 8023ec4:	4641      	mov	r1, r8
 8023ec6:	9309      	str	r3, [sp, #36]	; 0x24
 8023ec8:	f008 0301 	and.w	r3, r8, #1
 8023ecc:	9302      	str	r3, [sp, #8]
 8023ece:	4c2b      	ldr	r4, [pc, #172]	; (8023f7c <send_pulse_frame_data+0x194>)
 8023ed0:	008b      	lsls	r3, r1, #2
 8023ed2:	3704      	adds	r7, #4
 8023ed4:	9304      	str	r3, [sp, #16]
 8023ed6:	46b9      	mov	r9, r7
 8023ed8:	2500      	movs	r5, #0
	{
		for (uint32_t ant_idx = 0; ant_idx < frame_info.num_rx_antennas; ant_idx++) // max Ant mask!
		{
			uint8_t mask = (1 << ant_idx);
 8023eda:	2301      	movs	r3, #1
			if ((mask & frame_info.rx_mask) != 0)
 8023edc:	9a01      	ldr	r2, [sp, #4]

	for (uint32_t chirp = 0; chirp < frame_info.num_chirps; chirp++)
	{
		for (uint32_t ant_idx = 0; ant_idx < frame_info.num_rx_antennas; ant_idx++) // max Ant mask!
		{
			uint8_t mask = (1 << ant_idx);
 8023ede:	40ab      	lsls	r3, r5
			if ((mask & frame_info.rx_mask) != 0)
 8023ee0:	421a      	tst	r2, r3
 8023ee2:	d036      	beq.n	8023f52 <send_pulse_frame_data+0x16a>
 */

static size_t packing_helper_12Bit(uint8_t *p_dest, uint16_t *p_src, size_t numSamples)
{
	/* numBytes needs to be divided by 2 */
	if ((numSamples & 1) != 0)
 8023ee4:	9b02      	ldr	r3, [sp, #8]
 8023ee6:	46c8      	mov	r8, r9
 8023ee8:	f04f 0a02 	mov.w	sl, #2
 8023eec:	b18b      	cbz	r3, 8023f12 <send_pulse_frame_data+0x12a>
 8023eee:	f64f 71ff 	movw	r1, #65535	; 0xffff
		return -1;
 8023ef2:	f04f 3bff 	mov.w	fp, #4294967295
 8023ef6:	9b03      	ldr	r3, [sp, #12]
				for (uint32_t ch_idx = 0; ch_idx < num_chan_per_ant; ch_idx++)
				{
					uint32_t in_offset = (chirp_inc * chirp) + (channel_inc * (ant_idx * num_chan_per_ant + ch_idx));
					size_t out_offset = packing_helper_12Bit(destPtr, (uint16_t *)&srcPtr[in_offset], frame_info.num_samples_per_chirp);

					protocol_send_payload((uint8_t*)destPtr, out_offset);
 8023ef8:	4620      	mov	r0, r4
 8023efa:	4498      	add	r8, r3
 8023efc:	f000 fc7c 	bl	80247f8 <protocol_send_payload>
		{
			uint8_t mask = (1 << ant_idx);
			if ((mask & frame_info.rx_mask) != 0)
			{
				uint32_t num_chan_per_ant = (frame_info.data_format == RADAR_RX_DATA_REAL ? 1 : 2);
				for (uint32_t ch_idx = 0; ch_idx < num_chan_per_ant; ch_idx++)
 8023f00:	f1ba 0f01 	cmp.w	sl, #1
					uint32_t in_offset = (chirp_inc * chirp) + (channel_inc * (ant_idx * num_chan_per_ant + ch_idx));
					size_t out_offset = packing_helper_12Bit(destPtr, (uint16_t *)&srcPtr[in_offset], frame_info.num_samples_per_chirp);

					protocol_send_payload((uint8_t*)destPtr, out_offset);

					destPtr += out_offset;
 8023f04:	445c      	add	r4, fp
		{
			uint8_t mask = (1 << ant_idx);
			if ((mask & frame_info.rx_mask) != 0)
			{
				uint32_t num_chan_per_ant = (frame_info.data_format == RADAR_RX_DATA_REAL ? 1 : 2);
				for (uint32_t ch_idx = 0; ch_idx < num_chan_per_ant; ch_idx++)
 8023f06:	d024      	beq.n	8023f52 <send_pulse_frame_data+0x16a>
 */

static size_t packing_helper_12Bit(uint8_t *p_dest, uint16_t *p_src, size_t numSamples)
{
	/* numBytes needs to be divided by 2 */
	if ((numSamples & 1) != 0)
 8023f08:	9b02      	ldr	r3, [sp, #8]
 8023f0a:	f04f 0a01 	mov.w	sl, #1
 8023f0e:	2b00      	cmp	r3, #0
 8023f10:	d1ed      	bne.n	8023eee <send_pulse_frame_data+0x106>
		return -1;

	size_t   processed_output_bytes = 0;

	while (numSamples >= 2)
 8023f12:	9b08      	ldr	r3, [sp, #32]
 8023f14:	2b01      	cmp	r3, #1
 8023f16:	d92c      	bls.n	8023f72 <send_pulse_frame_data+0x18a>
 8023f18:	9b06      	ldr	r3, [sp, #24]
 8023f1a:	4641      	mov	r1, r8
 8023f1c:	eb04 0c03 	add.w	ip, r4, r3
 8023f20:	4622      	mov	r2, r4
	{
		/* pack two samples into one 32 bit word */
		uint32_t packed_word;
		packed_word  = *p_src++;
		packed_word |= *p_src++ << 12;
 8023f22:	f831 0c02 	ldrh.w	r0, [r1, #-2]

	while (numSamples >= 2)
	{
		/* pack two samples into one 32 bit word */
		uint32_t packed_word;
		packed_word  = *p_src++;
 8023f26:	f831 3c04 	ldrh.w	r3, [r1, #-4]
		packed_word |= *p_src++ << 12;
 8023f2a:	ea43 3300 	orr.w	r3, r3, r0, lsl #12
}

static inline size_t wr_payload_u32(uint8_t* payload, size_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8023f2e:	0e18      	lsrs	r0, r3, #24
 8023f30:	70d0      	strb	r0, [r2, #3]
    payload[offset + 2] = (value >> 16) & 0xFF;
 8023f32:	ea4f 4e13 	mov.w	lr, r3, lsr #16
    payload[offset + 1] = (value >>  8) & 0xFF;
 8023f36:	0a18      	lsrs	r0, r3, #8

static inline size_t wr_payload_u32(uint8_t* payload, size_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
 8023f38:	f882 e002 	strb.w	lr, [r2, #2]
    payload[offset + 1] = (value >>  8) & 0xFF;
 8023f3c:	7050      	strb	r0, [r2, #1]
    payload[offset    ] =  value        & 0xFF;
 8023f3e:	f802 3b03 	strb.w	r3, [r2], #3
	if ((numSamples & 1) != 0)
		return -1;

	size_t   processed_output_bytes = 0;

	while (numSamples >= 2)
 8023f42:	4562      	cmp	r2, ip
 8023f44:	f101 0104 	add.w	r1, r1, #4
 8023f48:	d1eb      	bne.n	8023f22 <send_pulse_frame_data+0x13a>
		/* write packed word into buffer */
		wr_payload_u32(p_dest, 0, packed_word);
		p_dest += 3;

		numSamples -= 2;
		processed_output_bytes += 3;
 8023f4a:	9b06      	ldr	r3, [sp, #24]
	if ((numSamples & 1) != 0)
		return -1;

	size_t   processed_output_bytes = 0;

	while (numSamples >= 2)
 8023f4c:	9909      	ldr	r1, [sp, #36]	; 0x24

		numSamples -= 2;
		processed_output_bytes += 3;
	}

	return processed_output_bytes;
 8023f4e:	469b      	mov	fp, r3
 8023f50:	e7d1      	b.n	8023ef6 <send_pulse_frame_data+0x10e>
 8023f52:	9b04      	ldr	r3, [sp, #16]
 8023f54:	4499      	add	r9, r3

	uint32_t processed_out_bytes = 0;

	for (uint32_t chirp = 0; chirp < frame_info.num_chirps; chirp++)
	{
		for (uint32_t ant_idx = 0; ant_idx < frame_info.num_rx_antennas; ant_idx++) // max Ant mask!
 8023f56:	b155      	cbz	r5, 8023f6e <send_pulse_frame_data+0x186>
 8023f58:	9b07      	ldr	r3, [sp, #28]
 8023f5a:	441f      	add	r7, r3
	uint32_t channel_inc = frame_info.num_samples_per_chirp * sizeof(uint16_t);
	uint32_t chirp_inc = channel_inc * frame_info.num_rx_antennas * (frame_info.data_format == RADAR_RX_DATA_REAL ? 1 : 2);

	uint32_t processed_out_bytes = 0;

	for (uint32_t chirp = 0; chirp < frame_info.num_chirps; chirp++)
 8023f5c:	9b05      	ldr	r3, [sp, #20]
 8023f5e:	3601      	adds	r6, #1
 8023f60:	42b3      	cmp	r3, r6
 8023f62:	d1b8      	bne.n	8023ed6 <send_pulse_frame_data+0xee>
				}
			}
		}
	}

	protocol_send_tail();
 8023f64:	f000 fc4a 	bl	80247fc <protocol_send_tail>
}
 8023f68:	b011      	add	sp, #68	; 0x44
 8023f6a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8023f6e:	2501      	movs	r5, #1
 8023f70:	e7b3      	b.n	8023eda <send_pulse_frame_data+0xf2>
	if ((numSamples & 1) != 0)
		return -1;

	size_t   processed_output_bytes = 0;

	while (numSamples >= 2)
 8023f72:	9b02      	ldr	r3, [sp, #8]
 8023f74:	4619      	mov	r1, r3

		numSamples -= 2;
		processed_output_bytes += 3;
	}

	return processed_output_bytes;
 8023f76:	469b      	mov	fp, r3
 8023f78:	e7bd      	b.n	8023ef6 <send_pulse_frame_data+0x10e>
 8023f7a:	bf00      	nop
 8023f7c:	1ffea1d4 	.word	0x1ffea1d4

08023f80 <ep_radar_s2glpulse_handle_message>:

//============================================================================

uint16_t ep_radar_s2glpulse_handle_message(uint8_t endpoint, uint8_t *message_data,
										   uint16_t num_bytes, void* context)
{
 8023f80:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8023f84:	4604      	mov	r4, r0
	switch (message_data[0])
 8023f86:	7808      	ldrb	r0, [r1, #0]
 8023f88:	3830      	subs	r0, #48	; 0x30

//============================================================================

uint16_t ep_radar_s2glpulse_handle_message(uint8_t endpoint, uint8_t *message_data,
										   uint16_t num_bytes, void* context)
{
 8023f8a:	b089      	sub	sp, #36	; 0x24
	switch (message_data[0])
 8023f8c:	2816      	cmp	r0, #22
 8023f8e:	d81b      	bhi.n	8023fc8 <ep_radar_s2glpulse_handle_message+0x48>
 8023f90:	e8df f010 	tbh	[pc, r0, lsl #1]
 8023f94:	001a001f 	.word	0x001a001f
 8023f98:	001a002a 	.word	0x001a002a
 8023f9c:	018100f3 	.word	0x018100f3
 8023fa0:	001a001a 	.word	0x001a001a
 8023fa4:	001a001a 	.word	0x001a001a
 8023fa8:	001a001a 	.word	0x001a001a
 8023fac:	001a001a 	.word	0x001a001a
 8023fb0:	001a001a 	.word	0x001a001a
 8023fb4:	001a019a 	.word	0x001a019a
 8023fb8:	001a001a 	.word	0x001a001a
 8023fbc:	001a001a 	.word	0x001a001a
 8023fc0:	0017      	.short	0x0017
			return RADAR_ERR_OK;
		}
		break;

	case MSG_GET_RAW_DATA_IND:
		if (num_bytes == 5)
 8023fc2:	2a05      	cmp	r2, #5
 8023fc4:	f000 81cc 	beq.w	8024360 <ep_radar_s2glpulse_handle_message+0x3e0>
		break;

	default:
		break;
	}
	return PROTOCOL_STATUS_INVALID_PAYLOAD;
 8023fc8:	f64f 70ff 	movw	r0, #65535	; 0xffff
}
 8023fcc:	b009      	add	sp, #36	; 0x24
 8023fce:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
										   uint16_t num_bytes, void* context)
{
	switch (message_data[0])
	{
	case MSG_PARA_VALUES_IND:
		if (num_bytes == 1)
 8023fd2:	2a01      	cmp	r2, #1
 8023fd4:	d1f8      	bne.n	8023fc8 <ep_radar_s2glpulse_handle_message+0x48>
		{
			copyStore2comPara(&g_parameter_pulse);
 8023fd6:	48b9      	ldr	r0, [pc, #740]	; (80242bc <ep_radar_s2glpulse_handle_message+0x33c>)
 8023fd8:	f7fc fee0 	bl	8020d9c <copyStore2comPara>
			send_parameter_values(endpoint, &g_parameter_pulse);
 8023fdc:	4620      	mov	r0, r4
 8023fde:	49b7      	ldr	r1, [pc, #732]	; (80242bc <ep_radar_s2glpulse_handle_message+0x33c>)
 8023fe0:	f7ff feb0 	bl	8023d44 <send_parameter_values>

			return RADAR_ERR_OK;
 8023fe4:	2000      	movs	r0, #0
 8023fe6:	e7f1      	b.n	8023fcc <ep_radar_s2glpulse_handle_message+0x4c>
		}
		break;

	case MSG_PARA_VALUES_DEF_IND:
		if (num_bytes == 1)
 8023fe8:	2a01      	cmp	r2, #1
 8023fea:	d1ed      	bne.n	8023fc8 <ep_radar_s2glpulse_handle_message+0x48>
		{
			static uint8_t message[512]; // allocate statically, rather then on the call stack!
			memset(message, 0, sizeof(message));
 8023fec:	4db4      	ldr	r5, [pc, #720]	; (80242c0 <ep_radar_s2glpulse_handle_message+0x340>)
			size_t offset = 0;

			offset += wr_payload_u8(message, 0, MSG_PARA_VALUES_DEF_RES);
			offset += sizeof(uint16_t); // size if uint16

			offset += wr_payload_float(message, offset, c_para_value_def_list.max_speed_mps_lower_boundary);
 8023fee:	4fb5      	ldr	r7, [pc, #724]	; (80242c4 <ep_radar_s2glpulse_handle_message+0x344>)

	case MSG_PARA_VALUES_DEF_IND:
		if (num_bytes == 1)
		{
			static uint8_t message[512]; // allocate statically, rather then on the call stack!
			memset(message, 0, sizeof(message));
 8023ff0:	2100      	movs	r1, #0
 8023ff2:	f44f 7200 	mov.w	r2, #512	; 0x200
 8023ff6:	4628      	mov	r0, r5
 8023ff8:	f009 faad 	bl	802d556 <memset>
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8023ffc:	2333      	movs	r3, #51	; 0x33
 8023ffe:	702b      	strb	r3, [r5, #0]
			size_t offset = 0;

			offset += wr_payload_u8(message, 0, MSG_PARA_VALUES_DEF_RES);
			offset += sizeof(uint16_t); // size if uint16

			offset += wr_payload_float(message, offset, c_para_value_def_list.max_speed_mps_lower_boundary);
 8024000:	683a      	ldr	r2, [r7, #0]
 8024002:	2103      	movs	r1, #3
 8024004:	4628      	mov	r0, r5
 8024006:	f000 fc3d 	bl	8024884 <wr_payload_float>
 802400a:	1cc6      	adds	r6, r0, #3
			offset += wr_payload_float(message, offset, c_para_value_def_list.max_speed_mps_upper_boundary);
 802400c:	4631      	mov	r1, r6
 802400e:	687a      	ldr	r2, [r7, #4]
 8024010:	4628      	mov	r0, r5
 8024012:	f000 fc37 	bl	8024884 <wr_payload_float>
 8024016:	4406      	add	r6, r0
			offset += wr_payload_float(message, offset, c_para_value_def_list.min_speed_mps_lower_boundary);
 8024018:	4631      	mov	r1, r6
 802401a:	68ba      	ldr	r2, [r7, #8]
 802401c:	4628      	mov	r0, r5
 802401e:	f000 fc31 	bl	8024884 <wr_payload_float>
 8024022:	4406      	add	r6, r0
			offset += wr_payload_float(message, offset, c_para_value_def_list.min_speed_mps_upper_boundary);
 8024024:	4631      	mov	r1, r6
 8024026:	68fa      	ldr	r2, [r7, #12]
 8024028:	4628      	mov	r0, r5
 802402a:	f000 fc2b 	bl	8024884 <wr_payload_float>
 802402e:	4406      	add	r6, r0
			offset += wr_payload_float(message, offset, c_para_value_def_list.frame_time_sec_lower_boundary);
 8024030:	4631      	mov	r1, r6
 8024032:	693a      	ldr	r2, [r7, #16]
 8024034:	4628      	mov	r0, r5
 8024036:	f000 fc25 	bl	8024884 <wr_payload_float>
 802403a:	4406      	add	r6, r0
			offset += wr_payload_float(message, offset, c_para_value_def_list.frame_time_sec_upper_boundary);
 802403c:	4631      	mov	r1, r6
 802403e:	697a      	ldr	r2, [r7, #20]
 8024040:	4628      	mov	r0, r5
 8024042:	f000 fc1f 	bl	8024884 <wr_payload_float>

			uint8_t size_elems = sizeof(c_para_value_def_list.sample_list) / sizeof(uint16_t);
			offset += wr_payload_u8(message, offset, size_elems);
			for (int n = 0; n < size_elems; n++)
			{
				offset += wr_payload_u16(message, offset, c_para_value_def_list.sample_list[n]);
 8024046:	f8b7 c01c 	ldrh.w	ip, [r7, #28]
 802404a:	f8b7 e01e 	ldrh.w	lr, [r7, #30]
 802404e:	8b39      	ldrh	r1, [r7, #24]
 8024050:	f8b7 801a 	ldrh.w	r8, [r7, #26]
			}

			offset += wr_payload_float(message, offset, c_para_value_def_list.sampling_freq_hz_lower_boundary);
 8024054:	6a3a      	ldr	r2, [r7, #32]
			offset += wr_payload_float(message, offset, c_para_value_def_list.max_speed_mps_lower_boundary);
			offset += wr_payload_float(message, offset, c_para_value_def_list.max_speed_mps_upper_boundary);
			offset += wr_payload_float(message, offset, c_para_value_def_list.min_speed_mps_lower_boundary);
			offset += wr_payload_float(message, offset, c_para_value_def_list.min_speed_mps_upper_boundary);
			offset += wr_payload_float(message, offset, c_para_value_def_list.frame_time_sec_lower_boundary);
			offset += wr_payload_float(message, offset, c_para_value_def_list.frame_time_sec_upper_boundary);
 8024056:	4430      	add	r0, r6
}

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024058:	182b      	adds	r3, r5, r0
 802405a:	f100 0609 	add.w	r6, r0, #9
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 802405e:	f04f 0904 	mov.w	r9, #4
 8024062:	f805 9000 	strb.w	r9, [r5, r0]
}

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024066:	ea4f 2a1c 	mov.w	sl, ip, lsr #8
 802406a:	ea4f 291e 	mov.w	r9, lr, lsr #8
 802406e:	9601      	str	r6, [sp, #4]
 8024070:	ea4f 2b11 	mov.w	fp, r1, lsr #8
 8024074:	ea4f 2618 	mov.w	r6, r8, lsr #8
    payload[offset    ] =  value        & 0xFF;
 8024078:	f883 c005 	strb.w	ip, [r3, #5]
 802407c:	f883 e007 	strb.w	lr, [r3, #7]
 8024080:	7059      	strb	r1, [r3, #1]
}

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024082:	f883 b002 	strb.w	fp, [r3, #2]
    payload[offset    ] =  value        & 0xFF;
 8024086:	f883 8003 	strb.w	r8, [r3, #3]
}

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 802408a:	711e      	strb	r6, [r3, #4]
 802408c:	f883 a006 	strb.w	sl, [r3, #6]
 8024090:	f883 9008 	strb.w	r9, [r3, #8]
			for (int n = 0; n < size_elems; n++)
			{
				offset += wr_payload_u16(message, offset, c_para_value_def_list.sample_list[n]);
			}

			offset += wr_payload_float(message, offset, c_para_value_def_list.sampling_freq_hz_lower_boundary);
 8024094:	9901      	ldr	r1, [sp, #4]
 8024096:	4628      	mov	r0, r5
 8024098:	f000 fbf4 	bl	8024884 <wr_payload_float>
 802409c:	9b01      	ldr	r3, [sp, #4]
			offset += wr_payload_float(message, offset, c_para_value_def_list.sampling_freq_hz_upper_boundary);
 802409e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
			for (int n = 0; n < size_elems; n++)
			{
				offset += wr_payload_u16(message, offset, c_para_value_def_list.sample_list[n]);
			}

			offset += wr_payload_float(message, offset, c_para_value_def_list.sampling_freq_hz_lower_boundary);
 80240a0:	4403      	add	r3, r0
			offset += wr_payload_float(message, offset, c_para_value_def_list.sampling_freq_hz_upper_boundary);
 80240a2:	4619      	mov	r1, r3
 80240a4:	4628      	mov	r0, r5
			for (int n = 0; n < size_elems; n++)
			{
				offset += wr_payload_u16(message, offset, c_para_value_def_list.sample_list[n]);
			}

			offset += wr_payload_float(message, offset, c_para_value_def_list.sampling_freq_hz_lower_boundary);
 80240a6:	461e      	mov	r6, r3
			offset += wr_payload_float(message, offset, c_para_value_def_list.sampling_freq_hz_upper_boundary);
 80240a8:	f000 fbec 	bl	8024884 <wr_payload_float>
 80240ac:	4406      	add	r6, r0
			offset += wr_payload_float(message, offset, c_para_value_def_list.doppler_sensitivity_nu_lower_boundary);
 80240ae:	4631      	mov	r1, r6
 80240b0:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80240b2:	4628      	mov	r0, r5
 80240b4:	f000 fbe6 	bl	8024884 <wr_payload_float>
 80240b8:	4406      	add	r6, r0
			offset += wr_payload_float(message, offset, c_para_value_def_list.doppler_sensitivity_nu_upper_boundary);
 80240ba:	4631      	mov	r1, r6
 80240bc:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 80240be:	4628      	mov	r0, r5
 80240c0:	f000 fbe0 	bl	8024884 <wr_payload_float>
 80240c4:	4406      	add	r6, r0
			offset += wr_payload_float(message, offset, c_para_value_def_list.motion_sensitivity_nu_lower_boundary);
 80240c6:	4631      	mov	r1, r6
 80240c8:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 80240ca:	4628      	mov	r0, r5
 80240cc:	f000 fbda 	bl	8024884 <wr_payload_float>
 80240d0:	4406      	add	r6, r0
			offset += wr_payload_float(message, offset, c_para_value_def_list.motion_sensitivity_nu_upper_boundary);
 80240d2:	4631      	mov	r1, r6
 80240d4:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80240d6:	4628      	mov	r0, r5
 80240d8:	f000 fbd4 	bl	8024884 <wr_payload_float>

			offset += wr_payload_u32(message, offset, c_para_value_def_list.number_of_skip_samples_nu_lower_boundary);
 80240dc:	f8d7 c038 	ldr.w	ip, [r7, #56]	; 0x38
			offset += wr_payload_u32(message, offset, c_para_value_def_list.number_of_skip_samples_nu_upper_boundary);
 80240e0:	f8d7 e03c 	ldr.w	lr, [r7, #60]	; 0x3c

			offset += wr_payload_u32(message, offset, c_para_value_def_list.pulse_width_usec_lower_boundary);
 80240e4:	6c39      	ldr	r1, [r7, #64]	; 0x40
			offset += wr_payload_float(message, offset, c_para_value_def_list.sampling_freq_hz_lower_boundary);
			offset += wr_payload_float(message, offset, c_para_value_def_list.sampling_freq_hz_upper_boundary);
			offset += wr_payload_float(message, offset, c_para_value_def_list.doppler_sensitivity_nu_lower_boundary);
			offset += wr_payload_float(message, offset, c_para_value_def_list.doppler_sensitivity_nu_upper_boundary);
			offset += wr_payload_float(message, offset, c_para_value_def_list.motion_sensitivity_nu_lower_boundary);
			offset += wr_payload_float(message, offset, c_para_value_def_list.motion_sensitivity_nu_upper_boundary);
 80240e6:	1833      	adds	r3, r6, r0
}

static inline size_t wr_payload_u32(uint8_t* payload, size_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 80240e8:	18ea      	adds	r2, r5, r3

			offset += wr_payload_u32(message, offset, c_para_value_def_list.number_of_skip_samples_nu_lower_boundary);
			offset += wr_payload_u32(message, offset, c_para_value_def_list.number_of_skip_samples_nu_upper_boundary);

			offset += wr_payload_u32(message, offset, c_para_value_def_list.pulse_width_usec_lower_boundary);
			offset += wr_payload_u32(message, offset, c_para_value_def_list.pulse_width_usec_upper_boundary);
 80240ea:	6c7e      	ldr	r6, [r7, #68]	; 0x44
 80240ec:	f103 0810 	add.w	r8, r3, #16
 80240f0:	ea4f 6a1c 	mov.w	sl, ip, lsr #24
    payload[offset + 2] = (value >> 16) & 0xFF;
 80240f4:	ea4f 491c 	mov.w	r9, ip, lsr #16
}

static inline size_t wr_payload_u32(uint8_t* payload, size_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 80240f8:	f882 a003 	strb.w	sl, [r2, #3]
    payload[offset + 2] = (value >> 16) & 0xFF;
 80240fc:	f882 9002 	strb.w	r9, [r2, #2]

			// write size values of the message!
			wr_payload_u16(message, 1, (uint16_t)offset);
 8024100:	fa1f f788 	uxth.w	r7, r8

			/* send message */
			protocol_send_header(endpoint, offset);
 8024104:	4620      	mov	r0, r4
}

static inline size_t wr_payload_u32(uint8_t* payload, size_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8024106:	ea4f 6b1e 	mov.w	fp, lr, lsr #24
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
 802410a:	ea4f 241c 	mov.w	r4, ip, lsr #8

static inline size_t wr_payload_u32(uint8_t* payload, size_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
 802410e:	ea4f 4a1e 	mov.w	sl, lr, lsr #16
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024112:	ea4f 291e 	mov.w	r9, lr, lsr #8
 8024116:	7054      	strb	r4, [r2, #1]
    payload[offset    ] =  value        & 0xFF;
 8024118:	f805 c003 	strb.w	ip, [r5, r3]
}

static inline size_t wr_payload_u32(uint8_t* payload, size_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 802411c:	0e0c      	lsrs	r4, r1, #24
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 802411e:	f882 e004 	strb.w	lr, [r2, #4]
}

static inline size_t wr_payload_u32(uint8_t* payload, size_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8024122:	f882 b007 	strb.w	fp, [r2, #7]
    payload[offset + 2] = (value >> 16) & 0xFF;
 8024126:	f882 a006 	strb.w	sl, [r2, #6]
    payload[offset + 1] = (value >>  8) & 0xFF;
 802412a:	f882 9005 	strb.w	r9, [r2, #5]

static inline size_t wr_payload_u32(uint8_t* payload, size_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
 802412e:	0c0b      	lsrs	r3, r1, #16
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024130:	ea4f 2c11 	mov.w	ip, r1, lsr #8
}

static inline size_t wr_payload_u32(uint8_t* payload, size_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8024134:	ea4f 6e16 	mov.w	lr, r6, lsr #24
    payload[offset + 2] = (value >> 16) & 0xFF;
 8024138:	ea4f 4b16 	mov.w	fp, r6, lsr #16
    payload[offset + 1] = (value >>  8) & 0xFF;
 802413c:	ea4f 2a16 	mov.w	sl, r6, lsr #8
}

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024140:	ea4f 2917 	mov.w	r9, r7, lsr #8
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 8024144:	7211      	strb	r1, [r2, #8]
 8024146:	7316      	strb	r6, [r2, #12]
}

static inline size_t wr_payload_u32(uint8_t* payload, size_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8024148:	72d4      	strb	r4, [r2, #11]
    payload[offset + 2] = (value >> 16) & 0xFF;
 802414a:	7293      	strb	r3, [r2, #10]
    payload[offset + 1] = (value >>  8) & 0xFF;
 802414c:	f882 c009 	strb.w	ip, [r2, #9]
}

static inline size_t wr_payload_u32(uint8_t* payload, size_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8024150:	f882 e00f 	strb.w	lr, [r2, #15]
    payload[offset + 2] = (value >> 16) & 0xFF;
 8024154:	f882 b00e 	strb.w	fp, [r2, #14]
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024158:	f882 a00d 	strb.w	sl, [r2, #13]
 802415c:	4639      	mov	r1, r7

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 802415e:	f885 8001 	strb.w	r8, [r5, #1]
}

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024162:	f885 9002 	strb.w	r9, [r5, #2]
 8024166:	f000 fb33 	bl	80247d0 <protocol_send_header>
			protocol_send_payload(message, offset);
 802416a:	4628      	mov	r0, r5
 802416c:	4639      	mov	r1, r7
 802416e:	f000 fb43 	bl	80247f8 <protocol_send_payload>
			protocol_send_tail();
 8024172:	f000 fb43 	bl	80247fc <protocol_send_tail>

			return RADAR_ERR_OK;
 8024176:	2000      	movs	r0, #0
 8024178:	e728      	b.n	8023fcc <ep_radar_s2glpulse_handle_message+0x4c>
		}
		break;

	case MSG_PARA_SET_VALUES_IND:
		if (num_bytes == 35)
 802417a:	2a23      	cmp	r2, #35	; 0x23
 802417c:	f47f af24 	bne.w	8023fc8 <ep_radar_s2glpulse_handle_message+0x48>

	temp_union data;

	data.u32_value =
    		(((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
 8024180:	7c4a      	ldrb	r2, [r1, #17]
		} temp_union;

	temp_union data;

	data.u32_value =
    		(((uint32_t)payload[offset + 3]) << 24) |
 8024182:	f891 8012 	ldrb.w	r8, [r1, #18]
           (((uint32_t)payload[offset + 2]) << 16) |
           (((uint32_t)payload[offset + 1]) <<  8) |
            ((uint32_t)payload[offset    ]);
 8024186:	7bce      	ldrb	r6, [r1, #15]
	temp_union data;

	data.u32_value =
    		(((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
           (((uint32_t)payload[offset + 1]) <<  8) |
 8024188:	7988      	ldrb	r0, [r1, #6]
 802418a:	f891 e010 	ldrb.w	lr, [r1, #16]
		{
			size_t offset = 1; // skip id

			g_parameter_pulse.max_speed_mps = rd_payload_float(message_data, offset);
 802418e:	4d4b      	ldr	r5, [pc, #300]	; (80242bc <ep_radar_s2glpulse_handle_message+0x33c>)
 8024190:	9003      	str	r0, [sp, #12]

	temp_union data;

	data.u32_value =
    		(((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
 8024192:	0412      	lsls	r2, r2, #16
		} temp_union;

	temp_union data;

	data.u32_value =
    		(((uint32_t)payload[offset + 3]) << 24) |
 8024194:	ea42 6208 	orr.w	r2, r2, r8, lsl #24
           (((uint32_t)payload[offset + 2]) << 16) |
           (((uint32_t)payload[offset + 1]) <<  8) |
 8024198:	7a88      	ldrb	r0, [r1, #10]

	temp_union data;

	data.u32_value =
    		(((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
 802419a:	f891 c015 	ldrb.w	ip, [r1, #21]
 802419e:	9307      	str	r3, [sp, #28]
 80241a0:	4332      	orrs	r2, r6
           (((uint32_t)payload[offset + 1]) <<  8) |
            ((uint32_t)payload[offset    ]);
 80241a2:	784b      	ldrb	r3, [r1, #1]
	temp_union data;

	data.u32_value =
    		(((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
           (((uint32_t)payload[offset + 1]) <<  8) |
 80241a4:	9004      	str	r0, [sp, #16]
			offset += sizeof(float);
			g_parameter_pulse.frame_time_sec = rd_payload_float(message_data, offset);
			offset += sizeof(float);
			g_parameter_pulse.number_of_samples_nu = rd_payload_u16(message_data, offset);
			offset += sizeof(uint16_t);
			g_parameter_pulse.sampling_freq_hz = rd_payload_float(message_data, offset);
 80241a6:	ea42 2e0e 	orr.w	lr, r2, lr, lsl #8
                      ((uint16_t)payload[offset    ]));
}

static inline uint16_t rd_payload_u16(const uint8_t* payload, size_t offset)
{
    return (((uint16_t)payload[offset + 1]) <<  8) |
 80241aa:	7b88      	ldrb	r0, [r1, #14]

	data.u32_value =
    		(((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
           (((uint32_t)payload[offset + 1]) <<  8) |
            ((uint32_t)payload[offset    ]);
 80241ac:	794a      	ldrb	r2, [r1, #5]
		} temp_union;

	temp_union data;

	data.u32_value =
    		(((uint32_t)payload[offset + 3]) << 24) |
 80241ae:	f891 b004 	ldrb.w	fp, [r1, #4]
           (((uint32_t)payload[offset + 2]) << 16) |
 80241b2:	78cf      	ldrb	r7, [r1, #3]
		} temp_union;

	temp_union data;

	data.u32_value =
    		(((uint32_t)payload[offset + 3]) << 24) |
 80241b4:	f891 a008 	ldrb.w	sl, [r1, #8]
           (((uint32_t)payload[offset + 2]) << 16) |
 80241b8:	79ce      	ldrb	r6, [r1, #7]
		} temp_union;

	temp_union data;

	data.u32_value =
    		(((uint32_t)payload[offset + 3]) << 24) |
 80241ba:	f891 900c 	ldrb.w	r9, [r1, #12]
           (((uint32_t)payload[offset + 2]) << 16) |
           (((uint32_t)payload[offset + 1]) <<  8) |
            ((uint32_t)payload[offset    ]);
 80241be:	f891 8009 	ldrb.w	r8, [r1, #9]
 80241c2:	9301      	str	r3, [sp, #4]
 80241c4:	9202      	str	r2, [sp, #8]
	temp_union data;

	data.u32_value =
    		(((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
           (((uint32_t)payload[offset + 1]) <<  8) |
 80241c6:	788b      	ldrb	r3, [r1, #2]

	temp_union data;

	data.u32_value =
    		(((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
 80241c8:	7aca      	ldrb	r2, [r1, #11]
                      ((uint16_t)payload[offset    ]));
}

static inline uint16_t rd_payload_u16(const uint8_t* payload, size_t offset)
{
    return (((uint16_t)payload[offset + 1]) <<  8) |
 80241ca:	9005      	str	r0, [sp, #20]
 80241cc:	7b48      	ldrb	r0, [r1, #13]
 80241ce:	f8c5 e010 	str.w	lr, [r5, #16]
		} temp_union;

	temp_union data;

	data.u32_value =
    		(((uint32_t)payload[offset + 3]) << 24) |
 80241d2:	f891 e016 	ldrb.w	lr, [r1, #22]
                      ((uint16_t)payload[offset    ]));
}

static inline uint16_t rd_payload_u16(const uint8_t* payload, size_t offset)
{
    return (((uint16_t)payload[offset + 1]) <<  8) |
 80241d6:	9006      	str	r0, [sp, #24]

	temp_union data;

	data.u32_value =
    		(((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
 80241d8:	ea4f 4c0c 	mov.w	ip, ip, lsl #16
		} temp_union;

	temp_union data;

	data.u32_value =
    		(((uint32_t)payload[offset + 3]) << 24) |
 80241dc:	ea4c 6e0e 	orr.w	lr, ip, lr, lsl #24
           (((uint32_t)payload[offset + 2]) << 16) |
           (((uint32_t)payload[offset + 1]) <<  8) |
            ((uint32_t)payload[offset    ]);
 80241e0:	f891 c013 	ldrb.w	ip, [r1, #19]
 80241e4:	ea4e 0e0c 	orr.w	lr, lr, ip
	temp_union data;

	data.u32_value =
    		(((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
           (((uint32_t)payload[offset + 1]) <<  8) |
 80241e8:	f891 c014 	ldrb.w	ip, [r1, #20]

	temp_union data;

	data.u32_value =
    		(((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
 80241ec:	0412      	lsls	r2, r2, #16
			offset += sizeof(float);
			g_parameter_pulse.doppler_sensitivity_nu = rd_payload_float(message_data, offset);
 80241ee:	ea4e 2e0c 	orr.w	lr, lr, ip, lsl #8
 80241f2:	f8c5 e014 	str.w	lr, [r5, #20]
		} temp_union;

	temp_union data;

	data.u32_value =
    		(((uint32_t)payload[offset + 3]) << 24) |
 80241f6:	ea42 6c09 	orr.w	ip, r2, r9, lsl #24
           (((uint32_t)payload[offset + 2]) << 16) |
 80241fa:	f891 e019 	ldrb.w	lr, [r1, #25]
 80241fe:	9a01      	ldr	r2, [sp, #4]
		} temp_union;

	temp_union data;

	data.u32_value =
    		(((uint32_t)payload[offset + 3]) << 24) |
 8024200:	7e88      	ldrb	r0, [r1, #26]
           (((uint32_t)payload[offset + 2]) << 16) |
 8024202:	043f      	lsls	r7, r7, #16
		} temp_union;

	temp_union data;

	data.u32_value =
    		(((uint32_t)payload[offset + 3]) << 24) |
 8024204:	ea47 670b 	orr.w	r7, r7, fp, lsl #24
           (((uint32_t)payload[offset + 2]) << 16) |
 8024208:	ea4f 4e0e 	mov.w	lr, lr, lsl #16
 802420c:	4317      	orrs	r7, r2
 802420e:	0436      	lsls	r6, r6, #16
 8024210:	9a02      	ldr	r2, [sp, #8]
		} temp_union;

	temp_union data;

	data.u32_value =
    		(((uint32_t)payload[offset + 3]) << 24) |
 8024212:	ea4e 6000 	orr.w	r0, lr, r0, lsl #24
 8024216:	ea46 660a 	orr.w	r6, r6, sl, lsl #24
           (((uint32_t)payload[offset + 2]) << 16) |
           (((uint32_t)payload[offset + 1]) <<  8) |
            ((uint32_t)payload[offset    ]);
 802421a:	f891 e017 	ldrb.w	lr, [r1, #23]
 802421e:	4316      	orrs	r6, r2
 8024220:	ea4c 0208 	orr.w	r2, ip, r8
	temp_union data;

	data.u32_value =
    		(((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
           (((uint32_t)payload[offset + 1]) <<  8) |
 8024224:	f891 c018 	ldrb.w	ip, [r1, #24]
 8024228:	ea40 000e 	orr.w	r0, r0, lr
			offset += sizeof(float);
			g_parameter_pulse.motion_sensitivity_nu = rd_payload_float(message_data, offset);
 802422c:	ea40 2c0c 	orr.w	ip, r0, ip, lsl #8
	case MSG_PARA_SET_VALUES_IND:
		if (num_bytes == 35)
		{
			size_t offset = 1; // skip id

			g_parameter_pulse.max_speed_mps = rd_payload_float(message_data, offset);
 8024230:	ea47 2703 	orr.w	r7, r7, r3, lsl #8
			offset += sizeof(float);
			g_parameter_pulse.min_speed_mps = rd_payload_float(message_data, offset);
			offset += sizeof(float);
			g_parameter_pulse.frame_time_sec = rd_payload_float(message_data, offset);
 8024234:	9804      	ldr	r0, [sp, #16]
		{
			size_t offset = 1; // skip id

			g_parameter_pulse.max_speed_mps = rd_payload_float(message_data, offset);
			offset += sizeof(float);
			g_parameter_pulse.min_speed_mps = rd_payload_float(message_data, offset);
 8024236:	9b03      	ldr	r3, [sp, #12]
			offset += sizeof(uint16_t);
			g_parameter_pulse.sampling_freq_hz = rd_payload_float(message_data, offset);
			offset += sizeof(float);
			g_parameter_pulse.doppler_sensitivity_nu = rd_payload_float(message_data, offset);
			offset += sizeof(float);
			g_parameter_pulse.motion_sensitivity_nu = rd_payload_float(message_data, offset);
 8024238:	f8c5 c018 	str.w	ip, [r5, #24]

			g_parameter_pulse.max_speed_mps = rd_payload_float(message_data, offset);
			offset += sizeof(float);
			g_parameter_pulse.min_speed_mps = rd_payload_float(message_data, offset);
			offset += sizeof(float);
			g_parameter_pulse.frame_time_sec = rd_payload_float(message_data, offset);
 802423c:	ea42 2e00 	orr.w	lr, r2, r0, lsl #8
		{
			size_t offset = 1; // skip id

			g_parameter_pulse.max_speed_mps = rd_payload_float(message_data, offset);
			offset += sizeof(float);
			g_parameter_pulse.min_speed_mps = rd_payload_float(message_data, offset);
 8024240:	ea46 2603 	orr.w	r6, r6, r3, lsl #8
                      ((uint16_t)payload[offset    ]));
}

static inline uint16_t rd_payload_u16(const uint8_t* payload, size_t offset)
{
    return (((uint16_t)payload[offset + 1]) <<  8) |
 8024244:	9805      	ldr	r0, [sp, #20]
 8024246:	9b06      	ldr	r3, [sp, #24]
 8024248:	606e      	str	r6, [r5, #4]
 802424a:	ea43 2200 	orr.w	r2, r3, r0, lsl #8
			offset += sizeof(float);
			g_parameter_pulse.frame_time_sec = rd_payload_float(message_data, offset);
			offset += sizeof(float);
			g_parameter_pulse.number_of_samples_nu = rd_payload_u16(message_data, offset);
 802424e:	81aa      	strh	r2, [r5, #12]
 *
 * \return The function returns the value read from the payload.
 */
static inline uint8_t rd_payload_u8(const uint8_t* payload, size_t offset)
{
    return payload[offset];
 8024250:	7eca      	ldrb	r2, [r1, #27]
			offset += sizeof(float);
			g_parameter_pulse.doppler_sensitivity_nu = rd_payload_float(message_data, offset);
			offset += sizeof(float);
			g_parameter_pulse.motion_sensitivity_nu = rd_payload_float(message_data, offset);
			offset += sizeof(float);
			g_parameter_pulse.use_high_gain_doppler_bool = rd_payload_u8(message_data, offset);
 8024252:	772a      	strb	r2, [r5, #28]
 8024254:	7f0a      	ldrb	r2, [r1, #28]
			offset += sizeof(uint8_t);
			g_parameter_pulse.continuous_mode_bool = rd_payload_u8(message_data, offset);
 8024256:	776a      	strb	r2, [r5, #29]
                      ((uint16_t)payload[offset    ]));
}

static inline uint16_t rd_payload_u16(const uint8_t* payload, size_t offset)
{
    return (((uint16_t)payload[offset + 1]) <<  8) |
 8024258:	7f4e      	ldrb	r6, [r1, #29]

			g_parameter_pulse.max_speed_mps = rd_payload_float(message_data, offset);
			offset += sizeof(float);
			g_parameter_pulse.min_speed_mps = rd_payload_float(message_data, offset);
			offset += sizeof(float);
			g_parameter_pulse.frame_time_sec = rd_payload_float(message_data, offset);
 802425a:	f8c5 e008 	str.w	lr, [r5, #8]
 802425e:	f891 e01e 	ldrb.w	lr, [r1, #30]
}

static inline uint32_t rd_payload_u32(const uint8_t* payload, size_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
 8024262:	f891 0021 	ldrb.w	r0, [r1, #33]	; 0x21
                      ((uint32_t)payload[offset    ]));
}

static inline uint32_t rd_payload_u32(const uint8_t* payload, size_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
 8024266:	f891 2022 	ldrb.w	r2, [r1, #34]	; 0x22
	case MSG_PARA_SET_VALUES_IND:
		if (num_bytes == 35)
		{
			size_t offset = 1; // skip id

			g_parameter_pulse.max_speed_mps = rd_payload_float(message_data, offset);
 802426a:	602f      	str	r7, [r5, #0]
                      ((uint16_t)payload[offset    ]));
}

static inline uint16_t rd_payload_u16(const uint8_t* payload, size_t offset)
{
    return (((uint16_t)payload[offset + 1]) <<  8) |
 802426c:	ea46 260e 	orr.w	r6, r6, lr, lsl #8
			offset += sizeof(float);
			g_parameter_pulse.use_high_gain_doppler_bool = rd_payload_u8(message_data, offset);
			offset += sizeof(uint8_t);
			g_parameter_pulse.continuous_mode_bool = rd_payload_u8(message_data, offset);
			offset += sizeof(uint8_t);
			g_parameter_pulse.number_of_skip_samples_nu = rd_payload_u16(message_data, offset);
 8024270:	83ee      	strh	r6, [r5, #30]

static inline uint32_t rd_payload_u32(const uint8_t* payload, size_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
           (((uint32_t)payload[offset + 1]) <<  8) |
 8024272:	f891 7020 	ldrb.w	r7, [r1, #32]
            ((uint32_t)payload[offset    ]);
 8024276:	7fc9      	ldrb	r1, [r1, #31]
}

static inline uint32_t rd_payload_u32(const uint8_t* payload, size_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
 8024278:	0400      	lsls	r0, r0, #16
                      ((uint32_t)payload[offset    ]));
}

static inline uint32_t rd_payload_u32(const uint8_t* payload, size_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
 802427a:	ea40 6202 	orr.w	r2, r0, r2, lsl #24
 802427e:	430a      	orrs	r2, r1
 8024280:	ea42 2207 	orr.w	r2, r2, r7, lsl #8
			offset += sizeof(uint16_t);
			g_parameter_pulse.pulse_width_usec = rd_payload_u32(message_data, offset);
			offset += sizeof(uint32_t);

			uint32_t status = copyComPara2Store(&g_parameter_pulse);
 8024284:	4628      	mov	r0, r5
			offset += sizeof(uint8_t);
			g_parameter_pulse.continuous_mode_bool = rd_payload_u8(message_data, offset);
			offset += sizeof(uint8_t);
			g_parameter_pulse.number_of_skip_samples_nu = rd_payload_u16(message_data, offset);
			offset += sizeof(uint16_t);
			g_parameter_pulse.pulse_width_usec = rd_payload_u32(message_data, offset);
 8024286:	622a      	str	r2, [r5, #32]
			offset += sizeof(uint32_t);

			uint32_t status = copyComPara2Store(&g_parameter_pulse);
 8024288:	f7fc fdca 	bl	8020e20 <copyComPara2Store>
			if (status)
 802428c:	9b07      	ldr	r3, [sp, #28]
 802428e:	2800      	cmp	r0, #0
 8024290:	d175      	bne.n	802437e <ep_radar_s2glpulse_handle_message+0x3fe>
				protocol_broadcast_change(radar_driver, EP_RADAR_CHNG_CURRENT_CONSUMPTION);
				return RADAR_ERR_OK;
			}
			else
			{
				return RADAR_ERR_PARAMETER_OUT_OF_RANGE;
 8024292:	200c      	movs	r0, #12
 8024294:	e69a      	b.n	8023fcc <ep_radar_s2glpulse_handle_message+0x4c>
				error("wrong message size!");
			*/
		break;

	case MSG_RESULT_IND:
		if (num_bytes == 5)
 8024296:	2a05      	cmp	r2, #5
 8024298:	f47f ae96 	bne.w	8023fc8 <ep_radar_s2glpulse_handle_message+0x48>
           (((uint32_t)payload[offset + 2]) << 16) |
 802429c:	78cb      	ldrb	r3, [r1, #3]
                      ((uint32_t)payload[offset    ]));
}

static inline uint32_t rd_payload_u32(const uint8_t* payload, size_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
 802429e:	7908      	ldrb	r0, [r1, #4]
           (((uint32_t)payload[offset + 2]) << 16) |
           (((uint32_t)payload[offset + 1]) <<  8) |
            ((uint32_t)payload[offset    ]);
 80242a0:	784a      	ldrb	r2, [r1, #1]

static inline uint32_t rd_payload_u32(const uint8_t* payload, size_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
           (((uint32_t)payload[offset + 1]) <<  8) |
 80242a2:	7889      	ldrb	r1, [r1, #2]
}

static inline uint32_t rd_payload_u32(const uint8_t* payload, size_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
 80242a4:	041b      	lsls	r3, r3, #16
                      ((uint32_t)payload[offset    ]));
}

static inline uint32_t rd_payload_u32(const uint8_t* payload, size_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
 80242a6:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
 80242aa:	4313      	orrs	r3, r2
		{
			uint16_t in_offset = 1;
			uint32_t repeat_count = rd_payload_u32(message_data, in_offset);

			set_result_repeat_count(endpoint, repeat_count);
 80242ac:	4620      	mov	r0, r4
 80242ae:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
 80242b2:	f7fc fd1f 	bl	8020cf4 <set_result_repeat_count>

			return RADAR_ERR_OK;
 80242b6:	2000      	movs	r0, #0
 80242b8:	e688      	b.n	8023fcc <ep_radar_s2glpulse_handle_message+0x4c>
 80242ba:	bf00      	nop
 80242bc:	1fff0280 	.word	0x1fff0280
 80242c0:	1ffe9cac 	.word	0x1ffe9cac
 80242c4:	0802d6a0 	.word	0x0802d6a0
		}
		break;

	case MSG_GET_SHIELD_INFO_IND:
		if (num_bytes == 1)
 80242c8:	2a01      	cmp	r2, #1
 80242ca:	f47f ae7d 	bne.w	8023fc8 <ep_radar_s2glpulse_handle_message+0x48>
		{

			static uint8_t message[512];
			uint16_t offset = 0;

			uint32_t index = ds_get_board_variant();
 80242ce:	f7fb fe97 	bl	8020000 <ds_get_board_variant>

			if (index == 0 || index > sizeof(rf_shield_info) / sizeof(rf_shield_info[0]) + 1)
 80242d2:	3801      	subs	r0, #1
 80242d4:	2803      	cmp	r0, #3
 80242d6:	bf28      	it	cs
 80242d8:	2000      	movcs	r0, #0
			}

			pulse_rf_shield_info_t *p_info = &rf_shield_info[index - 1];

			offset += wr_payload_u8(message, offset, MSG_GET_SHIELD_INFO_RES);
			offset += wr_payload_u32(message, offset, p_info->rf_frequency_khz);
 80242da:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 80242de:	0083      	lsls	r3, r0, #2
 80242e0:	4d2d      	ldr	r5, [pc, #180]	; (8024398 <ep_radar_s2glpulse_handle_message+0x418>)
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 80242e2:	4f2e      	ldr	r7, [pc, #184]	; (802439c <ep_radar_s2glpulse_handle_message+0x41c>)
 80242e4:	58ea      	ldr	r2, [r5, r3]
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 80242e6:	707a      	strb	r2, [r7, #1]
 80242e8:	441d      	add	r5, r3
}

static inline size_t wr_payload_u32(uint8_t* payload, size_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 80242ea:	0e11      	lsrs	r1, r2, #24
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
 80242ec:	0a13      	lsrs	r3, r2, #8
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 80242ee:	f895 c005 	ldrb.w	ip, [r5, #5]
 80242f2:	f895 e006 	ldrb.w	lr, [r5, #6]
 80242f6:	79ee      	ldrb	r6, [r5, #7]
 80242f8:	f895 8004 	ldrb.w	r8, [r5, #4]
static inline size_t wr_payload_u32(uint8_t* payload, size_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
 80242fc:	70bb      	strb	r3, [r7, #2]

static inline size_t wr_payload_u32(uint8_t* payload, size_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
 80242fe:	ea4f 4912 	mov.w	r9, r2, lsr #16
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024302:	f04f 0a41 	mov.w	sl, #65	; 0x41
 8024306:	f887 c006 	strb.w	ip, [r7, #6]
 802430a:	f887 e007 	strb.w	lr, [r7, #7]
			offset += wr_payload_u8(message, offset, p_info->major_rf_shield_version);
			offset += wr_payload_u8(message, offset, p_info->minor_rf_shield_version);
			offset += wr_payload_u8(message, offset, p_info->num_tx_antennas);
			offset += wr_payload_u8(message, offset, p_info->num_rx_antennas);

			offset += wr_payload_string(message, offset, p_info->rf_shield_board_id);
 802430e:	68aa      	ldr	r2, [r5, #8]
}

static inline size_t wr_payload_u32(uint8_t* payload, size_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8024310:	7139      	strb	r1, [r7, #4]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024312:	723e      	strb	r6, [r7, #8]
 8024314:	2109      	movs	r1, #9
 8024316:	4638      	mov	r0, r7
 8024318:	f887 a000 	strb.w	sl, [r7]

static inline size_t wr_payload_u32(uint8_t* payload, size_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
 802431c:	f887 9003 	strb.w	r9, [r7, #3]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024320:	f887 8005 	strb.w	r8, [r7, #5]
 8024324:	f000 fabc 	bl	80248a0 <wr_payload_string>
 8024328:	3009      	adds	r0, #9
 802432a:	b286      	uxth	r6, r0
			offset += wr_payload_string(message, offset, p_info->description);
 802432c:	4631      	mov	r1, r6
 802432e:	68ea      	ldr	r2, [r5, #12]
 8024330:	4638      	mov	r0, r7
 8024332:	f000 fab5 	bl	80248a0 <wr_payload_string>
 8024336:	4430      	add	r0, r6
 8024338:	b286      	uxth	r6, r0
			offset += wr_payload_string(message, offset, p_info->modulation);
 802433a:	692a      	ldr	r2, [r5, #16]
 802433c:	4631      	mov	r1, r6
 802433e:	4638      	mov	r0, r7
 8024340:	f000 faae 	bl	80248a0 <wr_payload_string>
 8024344:	4430      	add	r0, r6
 8024346:	b285      	uxth	r5, r0

			/* send message */
			protocol_send_header(endpoint, offset);
 8024348:	4629      	mov	r1, r5
 802434a:	4620      	mov	r0, r4
 802434c:	f000 fa40 	bl	80247d0 <protocol_send_header>
			protocol_send_payload(message, offset);
 8024350:	4638      	mov	r0, r7
 8024352:	4629      	mov	r1, r5
 8024354:	f000 fa50 	bl	80247f8 <protocol_send_payload>
			protocol_send_tail();
 8024358:	f000 fa50 	bl	80247fc <protocol_send_tail>

			return RADAR_ERR_OK;
 802435c:	2000      	movs	r0, #0
 802435e:	e635      	b.n	8023fcc <ep_radar_s2glpulse_handle_message+0x4c>
}

static inline uint32_t rd_payload_u32(const uint8_t* payload, size_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
 8024360:	78cb      	ldrb	r3, [r1, #3]
                      ((uint32_t)payload[offset    ]));
}

static inline uint32_t rd_payload_u32(const uint8_t* payload, size_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
 8024362:	7908      	ldrb	r0, [r1, #4]
           (((uint32_t)payload[offset + 2]) << 16) |
           (((uint32_t)payload[offset + 1]) <<  8) |
            ((uint32_t)payload[offset    ]);
 8024364:	784a      	ldrb	r2, [r1, #1]

static inline uint32_t rd_payload_u32(const uint8_t* payload, size_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
           (((uint32_t)payload[offset + 1]) <<  8) |
 8024366:	7889      	ldrb	r1, [r1, #2]
}

static inline uint32_t rd_payload_u32(const uint8_t* payload, size_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
 8024368:	041b      	lsls	r3, r3, #16
                      ((uint32_t)payload[offset    ]));
}

static inline uint32_t rd_payload_u32(const uint8_t* payload, size_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
 802436a:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
 802436e:	4313      	orrs	r3, r2
		if (num_bytes == 5)
		{
			uint16_t in_offset = 1;
			uint32_t repeat_count = rd_payload_u32(message_data, in_offset);

			set_raw_data_repeat_count(endpoint, repeat_count);
 8024370:	4620      	mov	r0, r4
 8024372:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
 8024376:	f7fc fcc7 	bl	8020d08 <set_raw_data_repeat_count>

			return RADAR_ERR_OK;
 802437a:	2000      	movs	r0, #0
 802437c:	e626      	b.n	8023fcc <ep_radar_s2glpulse_handle_message+0x4c>

			uint32_t status = copyComPara2Store(&g_parameter_pulse);
			if (status)
			{
				/* send message */
				send_parameter_values(endpoint, &g_parameter_pulse);
 802437e:	4620      	mov	r0, r4
 8024380:	4629      	mov	r1, r5
 8024382:	9301      	str	r3, [sp, #4]
 8024384:	f7ff fcde 	bl	8023d44 <send_parameter_values>

				/* inform other endpoints of the change */
				Radar_Handle_t radar_driver = (Radar_Handle_t)context;

				protocol_broadcast_change(radar_driver, EP_RADAR_CHNG_CURRENT_CONSUMPTION);
 8024388:	9b01      	ldr	r3, [sp, #4]
 802438a:	2114      	movs	r1, #20
 802438c:	4618      	mov	r0, r3
 802438e:	f000 fa47 	bl	8024820 <protocol_broadcast_change>
				return RADAR_ERR_OK;
 8024392:	2000      	movs	r0, #0
 8024394:	e61a      	b.n	8023fcc <ep_radar_s2glpulse_handle_message+0x4c>
 8024396:	bf00      	nop
 8024398:	1ffe90bc 	.word	0x1ffe90bc
 802439c:	1ffe9ed4 	.word	0x1ffe9ed4

080243a0 <ep_radar_s2glpulse_handle_change>:
}

//============================================================================

void ep_radar_s2glpulse_handle_change(uint8_t endpoint, void* context, uint32_t what)
{
 80243a0:	4770      	bx	lr
 80243a2:	bf00      	nop

080243a4 <receive_data>:
}

//============================================================================

static void receive_data(void)
{
 80243a4:	b530      	push	{r4, r5, lr}
    /* receive data from communication interface */
    uint16_t num_received_bytes = com_get_data(instance.receive_pointer,
 80243a6:	4c17      	ldr	r4, [pc, #92]	; (8024404 <receive_data+0x60>)
}

//============================================================================

static void receive_data(void)
{
 80243a8:	b083      	sub	sp, #12
    /* receive data from communication interface */
    uint16_t num_received_bytes = com_get_data(instance.receive_pointer,
 80243aa:	89a1      	ldrh	r1, [r4, #12]
 80243ac:	68a0      	ldr	r0, [r4, #8]
 80243ae:	f004 fcf7 	bl	8028da0 <com_get_data>
                                               instance.num_bytes_awaited);
    instance.receive_pointer += num_received_bytes;
 80243b2:	68a2      	ldr	r2, [r4, #8]
    instance.num_bytes_awaited -= num_received_bytes;
 80243b4:	89a3      	ldrh	r3, [r4, #12]

    /* check for timeout */
    if (instance.get_time != NULL)
 80243b6:	6a21      	ldr	r1, [r4, #32]
static void receive_data(void)
{
    /* receive data from communication interface */
    uint16_t num_received_bytes = com_get_data(instance.receive_pointer,
                                               instance.num_bytes_awaited);
    instance.receive_pointer += num_received_bytes;
 80243b8:	4402      	add	r2, r0
    instance.num_bytes_awaited -= num_received_bytes;
 80243ba:	1a1b      	subs	r3, r3, r0
//============================================================================

static void receive_data(void)
{
    /* receive data from communication interface */
    uint16_t num_received_bytes = com_get_data(instance.receive_pointer,
 80243bc:	4605      	mov	r5, r0
                                               instance.num_bytes_awaited);
    instance.receive_pointer += num_received_bytes;
 80243be:	60a2      	str	r2, [r4, #8]
    instance.num_bytes_awaited -= num_received_bytes;
 80243c0:	81a3      	strh	r3, [r4, #12]

    /* check for timeout */
    if (instance.get_time != NULL)
 80243c2:	b1e9      	cbz	r1, 8024400 <receive_data+0x5c>
    {
        /* get current time */
        uint32_t current_time = instance.get_time();
 80243c4:	4788      	blx	r1

        /* if no data has been received, check the time since last received
         * bytes
         */
        if (num_received_bytes == 0)
 80243c6:	b9d5      	cbnz	r5, 80243fe <receive_data+0x5a>
        {
        	if (instance.time_of_last_byte > current_time)
 80243c8:	6923      	ldr	r3, [r4, #16]
 80243ca:	4298      	cmp	r0, r3
 80243cc:	d317      	bcc.n	80243fe <receive_data+0x5a>
        		/* Handle time wrap-around */
        		instance.time_of_last_byte = current_time;
        	}
        	else {

				if ((instance.state != PROTOCOL_STATE_IDLE) &&
 80243ce:	7961      	ldrb	r1, [r4, #5]
 80243d0:	b1b1      	cbz	r1, 8024400 <receive_data+0x5c>
					(current_time >= instance.time_of_last_byte +
 80243d2:	6a62      	ldr	r2, [r4, #36]	; 0x24
 80243d4:	4413      	add	r3, r2
        		/* Handle time wrap-around */
        		instance.time_of_last_byte = current_time;
        	}
        	else {

				if ((instance.state != PROTOCOL_STATE_IDLE) &&
 80243d6:	4298      	cmp	r0, r3
 80243d8:	d312      	bcc.n	8024400 <receive_data+0x5c>
					(current_time >= instance.time_of_last_byte +
									 instance.timeout_interval))
				{
					/* a timeout has occurred, reset protocol state */
					if (instance.state != PROTOCOL_STATE_CONFUSED)
 80243da:	2904      	cmp	r1, #4
 80243dc:	d008      	beq.n	80243f0 <receive_data+0x4c>
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 80243de:	a802      	add	r0, sp, #8
 80243e0:	4b09      	ldr	r3, [pc, #36]	; (8024408 <receive_data+0x64>)
 80243e2:	f840 3d04 	str.w	r3, [r0, #-4]!
    wr_payload_u8 (status_message, 0, CNST_STARTBYTE_STATUS);
    wr_payload_u8 (status_message, 1, endpoint);
    wr_payload_u16(status_message, 2, status_code);

    /* now send message */
    com_send_data(status_message, sizeof(status_message));
 80243e6:	2104      	movs	r1, #4
 80243e8:	f004 fcd8 	bl	8028d9c <com_send_data>
    com_flush();
 80243ec:	f004 fce8 	bl	8028dc0 <com_flush>
//============================================================================

static void reset_state(void)
{
    /* set to idle state and store incoming data in message frame buffer */
    instance.state             = PROTOCOL_STATE_IDLE;
 80243f0:	2300      	movs	r3, #0
    instance.receive_pointer   = instance.message_frame;
 80243f2:	4a06      	ldr	r2, [pc, #24]	; (802440c <receive_data+0x68>)
//============================================================================

static void reset_state(void)
{
    /* set to idle state and store incoming data in message frame buffer */
    instance.state             = PROTOCOL_STATE_IDLE;
 80243f4:	7163      	strb	r3, [r4, #5]
    instance.receive_pointer   = instance.message_frame;
    instance.num_bytes_awaited = 4;
 80243f6:	2304      	movs	r3, #4

static void reset_state(void)
{
    /* set to idle state and store incoming data in message frame buffer */
    instance.state             = PROTOCOL_STATE_IDLE;
    instance.receive_pointer   = instance.message_frame;
 80243f8:	60a2      	str	r2, [r4, #8]
    instance.num_bytes_awaited = 4;
 80243fa:	81a3      	strh	r3, [r4, #12]
 80243fc:	e000      	b.n	8024400 <receive_data+0x5c>
        else
        {
            /* data has been received, so remember current time for next
             * timeout check
             */
            instance.time_of_last_byte = current_time;
 80243fe:	6120      	str	r0, [r4, #16]
        }
    }
}
 8024400:	b003      	add	sp, #12
 8024402:	bd30      	pop	{r4, r5, pc}
 8024404:	1ffeb1d8 	.word	0x1ffeb1d8
 8024408:	0001005b 	.word	0x0001005b
 802440c:	1ffeb1ec 	.word	0x1ffeb1ec

08024410 <protocol_init>:
 */

void protocol_init(Endpoint_t* endpoints, uint8_t num_endpoints,
                   uint32_t (*get_time)(void), uint32_t timeout_interval,
                   void (*do_system_reset)(void))
{
 8024410:	b538      	push	{r3, r4, r5, lr}
    /* initialize the internal state structure */
    instance.get_time = get_time;
 8024412:	4c0f      	ldr	r4, [pc, #60]	; (8024450 <protocol_init+0x40>)
 */

void protocol_init(Endpoint_t* endpoints, uint8_t num_endpoints,
                   uint32_t (*get_time)(void), uint32_t timeout_interval,
                   void (*do_system_reset)(void))
{
 8024414:	9d04      	ldr	r5, [sp, #16]
    /* initialize the internal state structure */
    instance.get_time = get_time;
    instance.timeout_interval = timeout_interval;
 8024416:	6263      	str	r3, [r4, #36]	; 0x24
    instance.do_system_reset = do_system_reset;

    instance.endpoints = endpoints;
    instance.num_endpoints = num_endpoints;

    instance.state = PROTOCOL_STATE_IDLE;
 8024418:	2300      	movs	r3, #0
void protocol_init(Endpoint_t* endpoints, uint8_t num_endpoints,
                   uint32_t (*get_time)(void), uint32_t timeout_interval,
                   void (*do_system_reset)(void))
{
    /* initialize the internal state structure */
    instance.get_time = get_time;
 802441a:	6222      	str	r2, [r4, #32]
    instance.timeout_interval = timeout_interval;
    instance.do_system_reset = do_system_reset;

    instance.endpoints = endpoints;
 802441c:	6020      	str	r0, [r4, #0]
    instance.num_endpoints = num_endpoints;
 802441e:	7121      	strb	r1, [r4, #4]
                   void (*do_system_reset)(void))
{
    /* initialize the internal state structure */
    instance.get_time = get_time;
    instance.timeout_interval = timeout_interval;
    instance.do_system_reset = do_system_reset;
 8024420:	62a5      	str	r5, [r4, #40]	; 0x28

    instance.endpoints = endpoints;
    instance.num_endpoints = num_endpoints;

    instance.state = PROTOCOL_STATE_IDLE;
 8024422:	7163      	strb	r3, [r4, #5]
    instance.receive_pointer = NULL;
 8024424:	60a3      	str	r3, [r4, #8]
    instance.num_bytes_awaited = 0;
 8024426:	81a3      	strh	r3, [r4, #12]
    instance.time_of_last_byte = (get_time != NULL) ? instance.get_time() : 0;
 8024428:	b182      	cbz	r2, 802444c <protocol_init+0x3c>
 802442a:	4790      	blx	r2
    instance.payload = data_payload;
 802442c:	4d09      	ldr	r5, [pc, #36]	; (8024454 <protocol_init+0x44>)
    instance.num_endpoints = num_endpoints;

    instance.state = PROTOCOL_STATE_IDLE;
    instance.receive_pointer = NULL;
    instance.num_bytes_awaited = 0;
    instance.time_of_last_byte = (get_time != NULL) ? instance.get_time() : 0;
 802442e:	6120      	str	r0, [r4, #16]
static void reset_state(void)
{
    /* set to idle state and store incoming data in message frame buffer */
    instance.state             = PROTOCOL_STATE_IDLE;
    instance.receive_pointer   = instance.message_frame;
    instance.num_bytes_awaited = 4;
 8024430:	2304      	movs	r3, #4

static void reset_state(void)
{
    /* set to idle state and store incoming data in message frame buffer */
    instance.state             = PROTOCOL_STATE_IDLE;
    instance.receive_pointer   = instance.message_frame;
 8024432:	4a09      	ldr	r2, [pc, #36]	; (8024458 <protocol_init+0x48>)

    instance.state = PROTOCOL_STATE_IDLE;
    instance.receive_pointer = NULL;
    instance.num_bytes_awaited = 0;
    instance.time_of_last_byte = (get_time != NULL) ? instance.get_time() : 0;
    instance.payload = data_payload;
 8024434:	61e5      	str	r5, [r4, #28]
	instance.max_payload = PROTOCOL_MAX_PAYLOAD_SIZE;
 8024436:	f44f 7000 	mov.w	r0, #512	; 0x200
//============================================================================

static void reset_state(void)
{
    /* set to idle state and store incoming data in message frame buffer */
    instance.state             = PROTOCOL_STATE_IDLE;
 802443a:	2100      	movs	r1, #0
    instance.state = PROTOCOL_STATE_IDLE;
    instance.receive_pointer = NULL;
    instance.num_bytes_awaited = 0;
    instance.time_of_last_byte = (get_time != NULL) ? instance.get_time() : 0;
    instance.payload = data_payload;
	instance.max_payload = PROTOCOL_MAX_PAYLOAD_SIZE;
 802443c:	62e0      	str	r0, [r4, #44]	; 0x2c
//============================================================================

static void reset_state(void)
{
    /* set to idle state and store incoming data in message frame buffer */
    instance.state             = PROTOCOL_STATE_IDLE;
 802443e:	7161      	strb	r1, [r4, #5]
    instance.receive_pointer   = instance.message_frame;
 8024440:	60a2      	str	r2, [r4, #8]
    instance.num_bytes_awaited = 4;
 8024442:	81a3      	strh	r3, [r4, #12]
    /* initialize state */
    reset_state();

    /* initialize communication interface */
    com_init();
}
 8024444:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}

    /* initialize state */
    reset_state();

    /* initialize communication interface */
    com_init();
 8024448:	f004 bca6 	b.w	8028d98 <com_init>
    instance.num_endpoints = num_endpoints;

    instance.state = PROTOCOL_STATE_IDLE;
    instance.receive_pointer = NULL;
    instance.num_bytes_awaited = 0;
    instance.time_of_last_byte = (get_time != NULL) ? instance.get_time() : 0;
 802444c:	4610      	mov	r0, r2
 802444e:	e7ed      	b.n	802442c <protocol_init+0x1c>
 8024450:	1ffeb1d8 	.word	0x1ffeb1d8
 8024454:	1ffeb208 	.word	0x1ffeb208
 8024458:	1ffeb1ec 	.word	0x1ffeb1ec

0802445c <protocol_run>:
}

//============================================================================

void protocol_run(void)
{
 802445c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if (instance.state != PROTOCOL_STATE_CONFUSED)
 8024460:	4ca1      	ldr	r4, [pc, #644]	; (80246e8 <protocol_run+0x28c>)
 8024462:	7963      	ldrb	r3, [r4, #5]
 8024464:	2b04      	cmp	r3, #4
}

//============================================================================

void protocol_run(void)
{
 8024466:	b092      	sub	sp, #72	; 0x48
	if (instance.state != PROTOCOL_STATE_CONFUSED)
 8024468:	d02b      	beq.n	80244c2 <protocol_run+0x66>
    {
        /* if the protocol is in a defined state, read the next bytes from the
         * input stream
         */
        receive_data();
 802446a:	f7ff ff9b 	bl	80243a4 <receive_data>
        /*
         * now process data until the end of a message has been reached
         * (note the missing brakes, the fall through is intended to proceed
         * with the message, so don't wonder)
         */
        switch (instance.state)
 802446e:	7963      	ldrb	r3, [r4, #5]
 8024470:	2b03      	cmp	r3, #3
 8024472:	d824      	bhi.n	80244be <protocol_run+0x62>
 8024474:	e8df f003 	tbb	[pc, r3]
 8024478:	70890207 	.word	0x70890207
            /* no break, fall through and continue with
             * PROTOCOL_STATE_RECEIVING_HEADER
             */

        case PROTOCOL_STATE_RECEIVING_HEADER:
            if (instance.num_bytes_awaited == 0)
 802447c:	89a3      	ldrh	r3, [r4, #12]
 802447e:	b153      	cbz	r3, 8024496 <protocol_run+0x3a>
        /*
         * The receive_data function may switch the state back to idle, if a
         * timeout occurs, this is the  only way to get out of confused state.
         */
    }
}
 8024480:	b012      	add	sp, #72	; 0x48
 8024482:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        {
        case PROTOCOL_STATE_IDLE:
            /* if at least one byte has been received, the state is not idle
             *  any more
             */
            if (instance.num_bytes_awaited < 4)
 8024486:	89a3      	ldrh	r3, [r4, #12]
 8024488:	4a97      	ldr	r2, [pc, #604]	; (80246e8 <protocol_run+0x28c>)
 802448a:	2b03      	cmp	r3, #3
 802448c:	d8f8      	bhi.n	8024480 <protocol_run+0x24>
                instance.state = PROTOCOL_STATE_RECEIVING_HEADER;
 802448e:	2101      	movs	r1, #1
 8024490:	7151      	strb	r1, [r2, #5]
            /* no break, fall through and continue with
             * PROTOCOL_STATE_RECEIVING_HEADER
             */

        case PROTOCOL_STATE_RECEIVING_HEADER:
            if (instance.num_bytes_awaited == 0)
 8024492:	2b00      	cmp	r3, #0
 8024494:	d1f4      	bne.n	8024480 <protocol_run+0x24>
                sync_byte    = rd_payload_u8 (instance.message_frame, 0);
                endpoint     = rd_payload_u8 (instance.message_frame, 1);
                payload_size = rd_payload_u16(instance.message_frame, 2);

                /* check sync bye, message must be a payload message */
                if (sync_byte != CNST_STARTBYTE_DATA)
 8024496:	7d23      	ldrb	r3, [r4, #20]
 *
 * \return The function returns the value read from the payload.
 */
static inline uint8_t rd_payload_u8(const uint8_t* payload, size_t offset)
{
    return payload[offset];
 8024498:	4e93      	ldr	r6, [pc, #588]	; (80246e8 <protocol_run+0x28c>)
 802449a:	7d60      	ldrb	r0, [r4, #21]
                      ((uint16_t)payload[offset    ]));
}

static inline uint16_t rd_payload_u16(const uint8_t* payload, size_t offset)
{
    return (((uint16_t)payload[offset + 1]) <<  8) |
 802449c:	7de1      	ldrb	r1, [r4, #23]
            ((uint16_t)payload[offset    ]);
 802449e:	7da2      	ldrb	r2, [r4, #22]
 80244a0:	2b5a      	cmp	r3, #90	; 0x5a
 80244a2:	d078      	beq.n	8024596 <protocol_run+0x13a>
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 80244a4:	4b91      	ldr	r3, [pc, #580]	; (80246ec <protocol_run+0x290>)
 80244a6:	ad12      	add	r5, sp, #72	; 0x48
 80244a8:	f845 3d40 	str.w	r3, [r5, #-64]!
                end_sequence = rd_payload_u16(instance.message_frame, 4);

                /* check end of payload sequence */
                if (end_sequence != CNST_END_OF_PAYLOAD)
                {
                    instance.state = PROTOCOL_STATE_CONFUSED;
 80244ac:	2304      	movs	r3, #4
    wr_payload_u8 (status_message, 0, CNST_STARTBYTE_STATUS);
    wr_payload_u8 (status_message, 1, endpoint);
    wr_payload_u16(status_message, 2, status_code);

    /* now send message */
    com_send_data(status_message, sizeof(status_message));
 80244ae:	4628      	mov	r0, r5
 80244b0:	4619      	mov	r1, r3
                end_sequence = rd_payload_u16(instance.message_frame, 4);

                /* check end of payload sequence */
                if (end_sequence != CNST_END_OF_PAYLOAD)
                {
                    instance.state = PROTOCOL_STATE_CONFUSED;
 80244b2:	7173      	strb	r3, [r6, #5]
    wr_payload_u8 (status_message, 0, CNST_STARTBYTE_STATUS);
    wr_payload_u8 (status_message, 1, endpoint);
    wr_payload_u16(status_message, 2, status_code);

    /* now send message */
    com_send_data(status_message, sizeof(status_message));
 80244b4:	f004 fc72 	bl	8028d9c <com_send_data>
    com_flush();
 80244b8:	f004 fc82 	bl	8028dc0 <com_flush>
 80244bc:	7973      	ldrb	r3, [r6, #5]
    }

    /* if state is confused, keep on reading into a dummy buffer, until
     * receive buffer is empty
     */
    if (instance.state == PROTOCOL_STATE_CONFUSED)
 80244be:	2b04      	cmp	r3, #4
 80244c0:	d1de      	bne.n	8024480 <protocol_run+0x24>
    {
        uint8_t dummy_buffer[64];
        do
        {
            instance.receive_pointer = dummy_buffer;
 80244c2:	4e89      	ldr	r6, [pc, #548]	; (80246e8 <protocol_run+0x28c>)
 80244c4:	ad02      	add	r5, sp, #8
            instance.num_bytes_awaited = sizeof(dummy_buffer);
 80244c6:	2740      	movs	r7, #64	; 0x40
//============================================================================

static void receive_data(void)
{
    /* receive data from communication interface */
    uint16_t num_received_bytes = com_get_data(instance.receive_pointer,
 80244c8:	2140      	movs	r1, #64	; 0x40
 80244ca:	4628      	mov	r0, r5
    if (instance.state == PROTOCOL_STATE_CONFUSED)
    {
        uint8_t dummy_buffer[64];
        do
        {
            instance.receive_pointer = dummy_buffer;
 80244cc:	60a5      	str	r5, [r4, #8]
            instance.num_bytes_awaited = sizeof(dummy_buffer);
 80244ce:	81a7      	strh	r7, [r4, #12]
//============================================================================

static void receive_data(void)
{
    /* receive data from communication interface */
    uint16_t num_received_bytes = com_get_data(instance.receive_pointer,
 80244d0:	f004 fc66 	bl	8028da0 <com_get_data>
                                               instance.num_bytes_awaited);
    instance.receive_pointer += num_received_bytes;
    instance.num_bytes_awaited -= num_received_bytes;
 80244d4:	89a3      	ldrh	r3, [r4, #12]
static void receive_data(void)
{
    /* receive data from communication interface */
    uint16_t num_received_bytes = com_get_data(instance.receive_pointer,
                                               instance.num_bytes_awaited);
    instance.receive_pointer += num_received_bytes;
 80244d6:	68a2      	ldr	r2, [r4, #8]
    instance.num_bytes_awaited -= num_received_bytes;

    /* check for timeout */
    if (instance.get_time != NULL)
 80244d8:	6a21      	ldr	r1, [r4, #32]
{
    /* receive data from communication interface */
    uint16_t num_received_bytes = com_get_data(instance.receive_pointer,
                                               instance.num_bytes_awaited);
    instance.receive_pointer += num_received_bytes;
    instance.num_bytes_awaited -= num_received_bytes;
 80244da:	1a1b      	subs	r3, r3, r0
 80244dc:	b29b      	uxth	r3, r3
static void receive_data(void)
{
    /* receive data from communication interface */
    uint16_t num_received_bytes = com_get_data(instance.receive_pointer,
                                               instance.num_bytes_awaited);
    instance.receive_pointer += num_received_bytes;
 80244de:	4402      	add	r2, r0
//============================================================================

static void receive_data(void)
{
    /* receive data from communication interface */
    uint16_t num_received_bytes = com_get_data(instance.receive_pointer,
 80244e0:	4680      	mov	r8, r0
                                               instance.num_bytes_awaited);
    instance.receive_pointer += num_received_bytes;
    instance.num_bytes_awaited -= num_received_bytes;
 80244e2:	81a3      	strh	r3, [r4, #12]
static void receive_data(void)
{
    /* receive data from communication interface */
    uint16_t num_received_bytes = com_get_data(instance.receive_pointer,
                                               instance.num_bytes_awaited);
    instance.receive_pointer += num_received_bytes;
 80244e4:	60a2      	str	r2, [r4, #8]
    instance.num_bytes_awaited -= num_received_bytes;

    /* check for timeout */
    if (instance.get_time != NULL)
 80244e6:	b311      	cbz	r1, 802452e <protocol_run+0xd2>
    {
        /* get current time */
        uint32_t current_time = instance.get_time();
 80244e8:	4788      	blx	r1

        /* if no data has been received, check the time since last received
         * bytes
         */
        if (num_received_bytes == 0)
 80244ea:	f1b8 0f00 	cmp.w	r8, #0
 80244ee:	d121      	bne.n	8024534 <protocol_run+0xd8>
        {
        	if (instance.time_of_last_byte > current_time)
 80244f0:	6933      	ldr	r3, [r6, #16]
 80244f2:	4298      	cmp	r0, r3
 80244f4:	d319      	bcc.n	802452a <protocol_run+0xce>
        		/* Handle time wrap-around */
        		instance.time_of_last_byte = current_time;
        	}
        	else {

				if ((instance.state != PROTOCOL_STATE_IDLE) &&
 80244f6:	7971      	ldrb	r1, [r6, #5]
 80244f8:	b309      	cbz	r1, 802453e <protocol_run+0xe2>
					(current_time >= instance.time_of_last_byte +
 80244fa:	6a72      	ldr	r2, [r6, #36]	; 0x24
 80244fc:	4413      	add	r3, r2
        		/* Handle time wrap-around */
        		instance.time_of_last_byte = current_time;
        	}
        	else {

				if ((instance.state != PROTOCOL_STATE_IDLE) &&
 80244fe:	4298      	cmp	r0, r3
 8024500:	d31d      	bcc.n	802453e <protocol_run+0xe2>
					(current_time >= instance.time_of_last_byte +
									 instance.timeout_interval))
				{
					/* a timeout has occurred, reset protocol state */
					if (instance.state != PROTOCOL_STATE_CONFUSED)
 8024502:	2904      	cmp	r1, #4
 8024504:	d008      	beq.n	8024518 <protocol_run+0xbc>
 8024506:	a812      	add	r0, sp, #72	; 0x48
 8024508:	4b79      	ldr	r3, [pc, #484]	; (80246f0 <protocol_run+0x294>)
 802450a:	f840 3d44 	str.w	r3, [r0, #-68]!
    wr_payload_u8 (status_message, 0, CNST_STARTBYTE_STATUS);
    wr_payload_u8 (status_message, 1, endpoint);
    wr_payload_u16(status_message, 2, status_code);

    /* now send message */
    com_send_data(status_message, sizeof(status_message));
 802450e:	2104      	movs	r1, #4
 8024510:	f004 fc44 	bl	8028d9c <com_send_data>
    com_flush();
 8024514:	f004 fc54 	bl	8028dc0 <com_flush>
//============================================================================

static void reset_state(void)
{
    /* set to idle state and store incoming data in message frame buffer */
    instance.state             = PROTOCOL_STATE_IDLE;
 8024518:	2300      	movs	r3, #0
    instance.receive_pointer   = instance.message_frame;
 802451a:	4a76      	ldr	r2, [pc, #472]	; (80246f4 <protocol_run+0x298>)
//============================================================================

static void reset_state(void)
{
    /* set to idle state and store incoming data in message frame buffer */
    instance.state             = PROTOCOL_STATE_IDLE;
 802451c:	7163      	strb	r3, [r4, #5]
    instance.receive_pointer   = instance.message_frame;
    instance.num_bytes_awaited = 4;
 802451e:	2304      	movs	r3, #4

static void reset_state(void)
{
    /* set to idle state and store incoming data in message frame buffer */
    instance.state             = PROTOCOL_STATE_IDLE;
    instance.receive_pointer   = instance.message_frame;
 8024520:	60a2      	str	r2, [r4, #8]
    instance.num_bytes_awaited = 4;
 8024522:	81a3      	strh	r3, [r4, #12]
        /*
         * The receive_data function may switch the state back to idle, if a
         * timeout occurs, this is the  only way to get out of confused state.
         */
    }
}
 8024524:	b012      	add	sp, #72	; 0x48
 8024526:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802452a:	89b3      	ldrh	r3, [r6, #12]
        if (num_received_bytes == 0)
        {
        	if (instance.time_of_last_byte > current_time)
        	{
        		/* Handle time wrap-around */
        		instance.time_of_last_byte = current_time;
 802452c:	6130      	str	r0, [r6, #16]
        do
        {
            instance.receive_pointer = dummy_buffer;
            instance.num_bytes_awaited = sizeof(dummy_buffer);
            receive_data();
        } while (instance.num_bytes_awaited == 0);
 802452e:	2b00      	cmp	r3, #0
 8024530:	d0ca      	beq.n	80244c8 <protocol_run+0x6c>
 8024532:	e7a5      	b.n	8024480 <protocol_run+0x24>
 8024534:	89b3      	ldrh	r3, [r6, #12]
        else
        {
            /* data has been received, so remember current time for next
             * timeout check
             */
            instance.time_of_last_byte = current_time;
 8024536:	6130      	str	r0, [r6, #16]
        do
        {
            instance.receive_pointer = dummy_buffer;
            instance.num_bytes_awaited = sizeof(dummy_buffer);
            receive_data();
        } while (instance.num_bytes_awaited == 0);
 8024538:	2b00      	cmp	r3, #0
 802453a:	d0c5      	beq.n	80244c8 <protocol_run+0x6c>
 802453c:	e7a0      	b.n	8024480 <protocol_run+0x24>
 802453e:	89a3      	ldrh	r3, [r4, #12]
 8024540:	2b00      	cmp	r3, #0
 8024542:	d0c1      	beq.n	80244c8 <protocol_run+0x6c>
 8024544:	e79c      	b.n	8024480 <protocol_run+0x24>

        case PROTOCOL_STATE_RECEIVING_PAYLOAD:
            if (instance.num_bytes_awaited == 0)
            {
                /* prepare for receiving message tail */
                instance.receive_pointer = instance.message_frame + 4;
 8024546:	f103 0018 	add.w	r0, r3, #24
                instance.num_bytes_awaited = 2;
 802454a:	2102      	movs	r1, #2
                instance.state = PROTOCOL_STATE_RECEIVING_TAIL;
 802454c:	2203      	movs	r2, #3

        case PROTOCOL_STATE_RECEIVING_PAYLOAD:
            if (instance.num_bytes_awaited == 0)
            {
                /* prepare for receiving message tail */
                instance.receive_pointer = instance.message_frame + 4;
 802454e:	6098      	str	r0, [r3, #8]
                instance.num_bytes_awaited = 2;
 8024550:	8199      	strh	r1, [r3, #12]
                instance.state = PROTOCOL_STATE_RECEIVING_TAIL;
 8024552:	715a      	strb	r2, [r3, #5]

                /* try to read payload */
                receive_data();
 8024554:	f7ff ff26 	bl	80243a4 <receive_data>
                 */
                break;
            }

        case PROTOCOL_STATE_RECEIVING_TAIL:
            if (instance.num_bytes_awaited == 0)
 8024558:	89a3      	ldrh	r3, [r4, #12]
 802455a:	4e63      	ldr	r6, [pc, #396]	; (80246e8 <protocol_run+0x28c>)
 802455c:	2b00      	cmp	r3, #0
 802455e:	d1ad      	bne.n	80244bc <protocol_run+0x60>
                      ((uint16_t)payload[offset    ]));
}

static inline uint16_t rd_payload_u16(const uint8_t* payload, size_t offset)
{
    return (((uint16_t)payload[offset + 1]) <<  8) |
 8024560:	7e71      	ldrb	r1, [r6, #25]
 8024562:	7e33      	ldrb	r3, [r6, #24]
 *
 * \return The function returns the value read from the payload.
 */
static inline uint8_t rd_payload_u8(const uint8_t* payload, size_t offset)
{
    return payload[offset];
 8024564:	7d77      	ldrb	r7, [r6, #21]
                      ((uint16_t)payload[offset    ]));
}

static inline uint16_t rd_payload_u16(const uint8_t* payload, size_t offset)
{
    return (((uint16_t)payload[offset + 1]) <<  8) |
 8024566:	7df0      	ldrb	r0, [r6, #23]
            ((uint16_t)payload[offset    ]);
 8024568:	7db2      	ldrb	r2, [r6, #22]
                      ((uint16_t)payload[offset    ]));
}

static inline uint16_t rd_payload_u16(const uint8_t* payload, size_t offset)
{
    return (((uint16_t)payload[offset + 1]) <<  8) |
 802456a:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
                endpoint     = rd_payload_u8 (instance.message_frame, 1);
                payload_size = rd_payload_u16(instance.message_frame, 2);
                end_sequence = rd_payload_u16(instance.message_frame, 4);

                /* check end of payload sequence */
                if (end_sequence != CNST_END_OF_PAYLOAD)
 802456e:	f24e 01db 	movw	r1, #57563	; 0xe0db
 8024572:	428b      	cmp	r3, r1
 8024574:	d01b      	beq.n	80245ae <protocol_run+0x152>
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024576:	ad12      	add	r5, sp, #72	; 0x48
 8024578:	4b5f      	ldr	r3, [pc, #380]	; (80246f8 <protocol_run+0x29c>)
 802457a:	e795      	b.n	80244a8 <protocol_run+0x4c>
                      instance.state = PROTOCOL_STATE_CONFUSED;
                      send_status_message(0, PROTOCOL_ERROR_OUT_OF_MEMORY);
                      break;
                    }

                    instance.receive_pointer = instance.payload;
 802457c:	69f1      	ldr	r1, [r6, #28]
                    instance.num_bytes_awaited = payload_size;
 802457e:	81b2      	strh	r2, [r6, #12]
                    instance.state = PROTOCOL_STATE_RECEIVING_PAYLOAD;
 8024580:	2302      	movs	r3, #2
                      instance.state = PROTOCOL_STATE_CONFUSED;
                      send_status_message(0, PROTOCOL_ERROR_OUT_OF_MEMORY);
                      break;
                    }

                    instance.receive_pointer = instance.payload;
 8024582:	60b1      	str	r1, [r6, #8]
                    instance.num_bytes_awaited = payload_size;
                    instance.state = PROTOCOL_STATE_RECEIVING_PAYLOAD;
 8024584:	7173      	strb	r3, [r6, #5]
                    send_status_message(0, PROTOCOL_ERROR_BAD_ENDPOINT_ID);
                    break;
                }

                /* try to read payload */
                receive_data();
 8024586:	f7ff ff0d 	bl	80243a4 <receive_data>
                 */
                break;
            }

        case PROTOCOL_STATE_RECEIVING_PAYLOAD:
            if (instance.num_bytes_awaited == 0)
 802458a:	89a2      	ldrh	r2, [r4, #12]
 802458c:	4b56      	ldr	r3, [pc, #344]	; (80246e8 <protocol_run+0x28c>)
 802458e:	2a00      	cmp	r2, #0
 8024590:	d0d9      	beq.n	8024546 <protocol_run+0xea>
 8024592:	795b      	ldrb	r3, [r3, #5]
 8024594:	e793      	b.n	80244be <protocol_run+0x62>
                    send_status_message(0, PROTOCOL_ERROR_BAD_MESSAGE_START);
                    break;
                }

                /* check message header for endpoint number */
                if (endpoint <= instance.num_endpoints)
 8024596:	7933      	ldrb	r3, [r6, #4]
 8024598:	4283      	cmp	r3, r0
 802459a:	d329      	bcc.n	80245f0 <protocol_run+0x194>
                {
                    /* check payload size (A message with no payload makes no
                     * sense)
                     */
                    if (payload_size == 0)
 802459c:	ea52 2201 	orrs.w	r2, r2, r1, lsl #8
 80245a0:	d04a      	beq.n	8024638 <protocol_run+0x1dc>
                        send_status_message(0, PROTOCOL_ERROR_NO_PAYLOAD);
                        break;
                    }

                    /* prepare for receiving payload */
                    if (payload_size > instance.max_payload)
 80245a2:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 80245a4:	429a      	cmp	r2, r3
 80245a6:	d9e9      	bls.n	802457c <protocol_run+0x120>
 80245a8:	ad12      	add	r5, sp, #72	; 0x48
 80245aa:	4b54      	ldr	r3, [pc, #336]	; (80246fc <protocol_run+0x2a0>)
 80245ac:	e77c      	b.n	80244a8 <protocol_run+0x4c>
                      ((uint16_t)payload[offset    ]));
}

static inline uint16_t rd_payload_u16(const uint8_t* payload, size_t offset)
{
    return (((uint16_t)payload[offset + 1]) <<  8) |
 80245ae:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
         	  /********** TIMING DEBUG - Protocol Start *************/
          	  #ifdef TIMING_DEBUG
                  	//DIGITAL_IO_SetOutputLow(&DIGITAL_IO_ARD_D9);
          	  #endif

                if (endpoint != 0)
 80245b2:	b307      	cbz	r7, 80245f6 <protocol_run+0x19a>
                    Endpoint_t* current_ep;

                    /* now send the payload package to the addressed endpoint
                     * and send the status code back
                     */
                    current_ep = &(instance.endpoints[endpoint-1]);
 80245b4:	6835      	ldr	r5, [r6, #0]
                    status_code = current_ep->handle_message(endpoint,
 80245b6:	69f1      	ldr	r1, [r6, #28]
                    Endpoint_t* current_ep;

                    /* now send the payload package to the addressed endpoint
                     * and send the status code back
                     */
                    current_ep = &(instance.endpoints[endpoint-1]);
 80245b8:	2014      	movs	r0, #20
 80245ba:	f06f 0313 	mvn.w	r3, #19
 80245be:	fb10 3307 	smlabb	r3, r0, r7, r3
 80245c2:	442b      	add	r3, r5
                    status_code = current_ep->handle_message(endpoint,
 80245c4:	4638      	mov	r0, r7
 80245c6:	689d      	ldr	r5, [r3, #8]
 80245c8:	68db      	ldr	r3, [r3, #12]
 80245ca:	47a8      	blx	r5
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 80245cc:	225b      	movs	r2, #91	; 0x5b
 80245ce:	4603      	mov	r3, r0
}

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 80245d0:	0a05      	lsrs	r5, r0, #8
    wr_payload_u8 (status_message, 0, CNST_STARTBYTE_STATUS);
    wr_payload_u8 (status_message, 1, endpoint);
    wr_payload_u16(status_message, 2, status_code);

    /* now send message */
    com_send_data(status_message, sizeof(status_message));
 80245d2:	2104      	movs	r1, #4
 80245d4:	a802      	add	r0, sp, #8
    payload[offset    ] =  value        & 0xFF;
 80245d6:	f88d 300a 	strb.w	r3, [sp, #10]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 80245da:	f88d 2008 	strb.w	r2, [sp, #8]
}

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 80245de:	f88d 500b 	strb.w	r5, [sp, #11]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 80245e2:	f88d 7009 	strb.w	r7, [sp, #9]
 80245e6:	f004 fbd9 	bl	8028d9c <com_send_data>
    com_flush();
 80245ea:	f004 fbe9 	bl	8028dc0 <com_flush>
 80245ee:	e793      	b.n	8024518 <protocol_run+0xbc>
 80245f0:	ad12      	add	r5, sp, #72	; 0x48
 80245f2:	4b43      	ldr	r3, [pc, #268]	; (8024700 <protocol_run+0x2a4>)
 80245f4:	e758      	b.n	80244a8 <protocol_run+0x4c>
 80245f6:	69f3      	ldr	r3, [r6, #28]
 80245f8:	f893 8000 	ldrb.w	r8, [r3]
//============================================================================

static uint16_t handle_message(uint8_t *message_data, uint16_t num_bytes)
{
    /* check command byte of received message */
    switch (message_data[0])
 80245fc:	f1b8 0f01 	cmp.w	r8, #1
 8024600:	f000 8082 	beq.w	8024708 <protocol_run+0x2ac>
 8024604:	d31b      	bcc.n	802463e <protocol_run+0x1e2>
 8024606:	f1b8 0f02 	cmp.w	r8, #2
 802460a:	d102      	bne.n	8024612 <protocol_run+0x1b6>
            return PROTOCOL_ERROR_OK;
        }
        break;

    case CNST_MSG_FIRMWARE_RESET:
        if (num_bytes == 1)
 802460c:	2a01      	cmp	r2, #1
 802460e:	f000 80cc 	beq.w	80247aa <protocol_run+0x34e>
        {
            /* if user did not set system reset function, this feature is not
             * supported.
             */
            if (instance.do_system_reset == NULL)
 8024612:	27ff      	movs	r7, #255	; 0xff
 8024614:	ad02      	add	r5, sp, #8
 8024616:	225b      	movs	r2, #91	; 0x5b
 8024618:	2300      	movs	r3, #0
    wr_payload_u8 (status_message, 0, CNST_STARTBYTE_STATUS);
    wr_payload_u8 (status_message, 1, endpoint);
    wr_payload_u16(status_message, 2, status_code);

    /* now send message */
    com_send_data(status_message, sizeof(status_message));
 802461a:	4628      	mov	r0, r5
 802461c:	2104      	movs	r1, #4
 802461e:	f88d 2008 	strb.w	r2, [sp, #8]
 8024622:	f88d 3009 	strb.w	r3, [sp, #9]
}

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024626:	f88d 700b 	strb.w	r7, [sp, #11]
    payload[offset    ] =  value        & 0xFF;
 802462a:	f88d 700a 	strb.w	r7, [sp, #10]
 802462e:	f004 fbb5 	bl	8028d9c <com_send_data>
    com_flush();
 8024632:	f004 fbc5 	bl	8028dc0 <com_flush>
 8024636:	e76f      	b.n	8024518 <protocol_run+0xbc>
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024638:	ad12      	add	r5, sp, #72	; 0x48
 802463a:	4b32      	ldr	r3, [pc, #200]	; (8024704 <protocol_run+0x2a8>)
 802463c:	e734      	b.n	80244a8 <protocol_run+0x4c>
{
    /* check command byte of received message */
    switch (message_data[0])
    {
    case CNST_MSG_QUERY_ENDPOINT_INFO:
        if (num_bytes == 1)
 802463e:	2a01      	cmp	r2, #1
 8024640:	d1e7      	bne.n	8024612 <protocol_run+0x1b6>
    uint8_t i;

    /* setup message start (type und number of endpoints */
    uint8_t message_header[2];
    wr_payload_u8(message_header, 0, CNST_MSG_ENDPOINT_INFO);
    wr_payload_u8(message_header, 1, instance.num_endpoints);
 8024642:	7932      	ldrb	r2, [r6, #4]
 8024644:	f88d 2005 	strb.w	r2, [sp, #5]

    /* calculate message size and send start of message */
    protocol_send_header(0, 6 * instance.num_endpoints +
 8024648:	eb02 0342 	add.w	r3, r2, r2, lsl #1
 802464c:	005b      	lsls	r3, r3, #1
 802464e:	3302      	adds	r3, #2
 8024650:	b29b      	uxth	r3, r3
    uint8_t header[4];
    wr_payload_u8 (header, 0, CNST_STARTBYTE_DATA);
    wr_payload_u8 (header, 1, endpoint);
    wr_payload_u16(header, 2, num_bytes);

    com_send_data(header, sizeof(header));
 8024652:	ad02      	add	r5, sp, #8
}

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024654:	ea4f 2c13 	mov.w	ip, r3, lsr #8
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024658:	f04f 0e5a 	mov.w	lr, #90	; 0x5a
 802465c:	4628      	mov	r0, r5
 802465e:	2104      	movs	r1, #4

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 8024660:	f88d 300a 	strb.w	r3, [sp, #10]
}

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024664:	f88d c00b 	strb.w	ip, [sp, #11]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024668:	f88d e008 	strb.w	lr, [sp, #8]
 802466c:	f88d 7004 	strb.w	r7, [sp, #4]
 8024670:	f88d 7009 	strb.w	r7, [sp, #9]
 8024674:	f004 fb92 	bl	8028d9c <com_send_data>
}

void protocol_send_payload(const uint8_t *message_data, uint16_t num_bytes)
{
    /* send the data through the communication stream interface */
    com_send_data(message_data, num_bytes);
 8024678:	a801      	add	r0, sp, #4
 802467a:	2102      	movs	r1, #2
 802467c:	f004 fb8e 	bl	8028d9c <com_send_data>
    protocol_send_header(0, 6 * instance.num_endpoints +
                            sizeof(message_header));
    protocol_send_payload(message_header, sizeof(message_header));

    /* now send type and version for each endpoint */
    for (i = 0; i < instance.num_endpoints; ++i)
 8024680:	7933      	ldrb	r3, [r6, #4]
 8024682:	b30b      	cbz	r3, 80246c8 <protocol_run+0x26c>
    {
        uint8_t ep_info[6];
        wr_payload_u32(ep_info, 0, instance.endpoints[i].endpoint_type);
 8024684:	b23a      	sxth	r2, r7
 8024686:	6821      	ldr	r1, [r4, #0]
 8024688:	eb02 0282 	add.w	r2, r2, r2, lsl #2
    protocol_send_header(0, 6 * instance.num_endpoints +
                            sizeof(message_header));
    protocol_send_payload(message_header, sizeof(message_header));

    /* now send type and version for each endpoint */
    for (i = 0; i < instance.num_endpoints; ++i)
 802468c:	3701      	adds	r7, #1
    {
        uint8_t ep_info[6];
        wr_payload_u32(ep_info, 0, instance.endpoints[i].endpoint_type);
 802468e:	f851 3022 	ldr.w	r3, [r1, r2, lsl #2]
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 8024692:	f88d 3008 	strb.w	r3, [sp, #8]
 8024696:	eb01 0282 	add.w	r2, r1, r2, lsl #2
}

static inline size_t wr_payload_u32(uint8_t* payload, size_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 802469a:	0e18      	lsrs	r0, r3, #24
    payload[offset + 2] = (value >> 16) & 0xFF;
 802469c:	0c19      	lsrs	r1, r3, #16
    payload[offset + 1] = (value >>  8) & 0xFF;
 802469e:	0a1b      	lsrs	r3, r3, #8
}

static inline size_t wr_payload_u32(uint8_t* payload, size_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 80246a0:	f88d 000b 	strb.w	r0, [sp, #11]
    payload[offset + 2] = (value >> 16) & 0xFF;
 80246a4:	f88d 100a 	strb.w	r1, [sp, #10]
    payload[offset + 1] = (value >>  8) & 0xFF;
 80246a8:	f88d 3009 	strb.w	r3, [sp, #9]
        wr_payload_u16(ep_info, 4, instance.endpoints[i].endpoint_version);
 80246ac:	8893      	ldrh	r3, [r2, #4]

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 80246ae:	f88d 300c 	strb.w	r3, [sp, #12]
}

void protocol_send_payload(const uint8_t *message_data, uint16_t num_bytes)
{
    /* send the data through the communication stream interface */
    com_send_data(message_data, num_bytes);
 80246b2:	4628      	mov	r0, r5
}

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 80246b4:	0a1b      	lsrs	r3, r3, #8
 80246b6:	2106      	movs	r1, #6
 80246b8:	f88d 300d 	strb.w	r3, [sp, #13]
 80246bc:	f004 fb6e 	bl	8028d9c <com_send_data>
    protocol_send_header(0, 6 * instance.num_endpoints +
                            sizeof(message_header));
    protocol_send_payload(message_header, sizeof(message_header));

    /* now send type and version for each endpoint */
    for (i = 0; i < instance.num_endpoints; ++i)
 80246c0:	7923      	ldrb	r3, [r4, #4]
 80246c2:	b2ff      	uxtb	r7, r7
 80246c4:	42bb      	cmp	r3, r7
 80246c6:	d8dd      	bhi.n	8024684 <protocol_run+0x228>
 80246c8:	22e0      	movs	r2, #224	; 0xe0
    payload[offset    ] =  value        & 0xFF;
 80246ca:	23db      	movs	r3, #219	; 0xdb
{
    /* setup message tail and send it */
    uint8_t tail[2];
    wr_payload_u16(tail, 0, CNST_END_OF_PAYLOAD);

    com_send_data(tail, sizeof(tail));
 80246cc:	4628      	mov	r0, r5
 80246ce:	2102      	movs	r1, #2
}

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 80246d0:	f88d 2009 	strb.w	r2, [sp, #9]
    payload[offset    ] =  value        & 0xFF;
 80246d4:	f88d 3008 	strb.w	r3, [sp, #8]
        if (num_bytes == 1)
        {
            send_endpoint_info();
            {
            	extern void app_reset_protocol(void);
            	app_reset_protocol();
 80246d8:	4647      	mov	r7, r8
{
    /* setup message tail and send it */
    uint8_t tail[2];
    wr_payload_u16(tail, 0, CNST_END_OF_PAYLOAD);

    com_send_data(tail, sizeof(tail));
 80246da:	f004 fb5f 	bl	8028d9c <com_send_data>
    com_flush();
 80246de:	f004 fb6f 	bl	8028dc0 <com_flush>
        if (num_bytes == 1)
        {
            send_endpoint_info();
            {
            	extern void app_reset_protocol(void);
            	app_reset_protocol();
 80246e2:	f005 fe99 	bl	802a418 <app_reset_protocol>
 80246e6:	e796      	b.n	8024616 <protocol_run+0x1ba>
 80246e8:	1ffeb1d8 	.word	0x1ffeb1d8
 80246ec:	0002005b 	.word	0x0002005b
 80246f0:	0001005b 	.word	0x0001005b
 80246f4:	1ffeb1ec 	.word	0x1ffeb1ec
 80246f8:	0007005b 	.word	0x0007005b
 80246fc:	0006005b 	.word	0x0006005b
 8024700:	0003005b 	.word	0x0003005b
 8024704:	0005005b 	.word	0x0005005b
            return PROTOCOL_ERROR_OK;
        }
        break;

    case CNST_MSG_QUERY_FW_INFO:
        if (num_bytes == 1)
 8024708:	2a01      	cmp	r2, #1
 802470a:	d182      	bne.n	8024612 <protocol_run+0x1b6>
    uint16_t string_length = 0;

    /* setup message start (type and number of endpoints */
    uint8_t message[7];
    wr_payload_u8 (message, 0, CNST_MSG_FW_INFO);
    wr_payload_u16(message, 1, firmware_information.version_major);
 802470c:	f8df 80bc 	ldr.w	r8, [pc, #188]	; 80247cc <protocol_run+0x370>
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024710:	f88d 2008 	strb.w	r2, [sp, #8]
 8024714:	f8b8 3004 	ldrh.w	r3, [r8, #4]
    wr_payload_u16(message, 3, firmware_information.version_minor);
 8024718:	f8b8 0006 	ldrh.w	r0, [r8, #6]
    wr_payload_u16(message, 5, firmware_information.version_build);
 802471c:	f8b8 1008 	ldrh.w	r1, [r8, #8]

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 8024720:	f88d 3009 	strb.w	r3, [sp, #9]
}

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024724:	0a06      	lsrs	r6, r0, #8
 8024726:	0a1b      	lsrs	r3, r3, #8

    /* count length of firmware description string */
    while (firmware_information.description[string_length] != 0)
 8024728:	f8d8 2000 	ldr.w	r2, [r8]
 802472c:	f88d 600c 	strb.w	r6, [sp, #12]
 8024730:	0a0d      	lsrs	r5, r1, #8
 8024732:	f88d 300a 	strb.w	r3, [sp, #10]
    payload[offset    ] =  value        & 0xFF;
 8024736:	f88d 000b 	strb.w	r0, [sp, #11]
 802473a:	f88d 100d 	strb.w	r1, [sp, #13]
}

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 802473e:	f88d 500e 	strb.w	r5, [sp, #14]
 8024742:	7813      	ldrb	r3, [r2, #0]
 8024744:	463e      	mov	r6, r7
 8024746:	b123      	cbz	r3, 8024752 <protocol_run+0x2f6>
        ++string_length;
 8024748:	3601      	adds	r6, #1
 802474a:	b2b6      	uxth	r6, r6
    wr_payload_u16(message, 1, firmware_information.version_major);
    wr_payload_u16(message, 3, firmware_information.version_minor);
    wr_payload_u16(message, 5, firmware_information.version_build);

    /* count length of firmware description string */
    while (firmware_information.description[string_length] != 0)
 802474c:	5d93      	ldrb	r3, [r2, r6]
 802474e:	2b00      	cmp	r3, #0
 8024750:	d1fa      	bne.n	8024748 <protocol_run+0x2ec>
        ++string_length;
    ++string_length;

    /* send message */
    protocol_send_header(0, sizeof(message) + string_length);
 8024752:	f106 0308 	add.w	r3, r6, #8
 8024756:	b29b      	uxth	r3, r3
 8024758:	ea4f 2c13 	mov.w	ip, r3, lsr #8
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 802475c:	f04f 0e5a 	mov.w	lr, #90	; 0x5a
 8024760:	2200      	movs	r2, #0
    uint8_t header[4];
    wr_payload_u8 (header, 0, CNST_STARTBYTE_DATA);
    wr_payload_u8 (header, 1, endpoint);
    wr_payload_u16(header, 2, num_bytes);

    com_send_data(header, sizeof(header));
 8024762:	a801      	add	r0, sp, #4
 8024764:	2104      	movs	r1, #4
}

void protocol_send_payload(const uint8_t *message_data, uint16_t num_bytes)
{
    /* send the data through the communication stream interface */
    com_send_data(message_data, num_bytes);
 8024766:	ad02      	add	r5, sp, #8

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 8024768:	f88d 3006 	strb.w	r3, [sp, #6]
}

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 802476c:	f88d c007 	strb.w	ip, [sp, #7]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024770:	f88d e004 	strb.w	lr, [sp, #4]
 8024774:	f88d 2005 	strb.w	r2, [sp, #5]
    uint8_t header[4];
    wr_payload_u8 (header, 0, CNST_STARTBYTE_DATA);
    wr_payload_u8 (header, 1, endpoint);
    wr_payload_u16(header, 2, num_bytes);

    com_send_data(header, sizeof(header));
 8024778:	f004 fb10 	bl	8028d9c <com_send_data>
}

void protocol_send_payload(const uint8_t *message_data, uint16_t num_bytes)
{
    /* send the data through the communication stream interface */
    com_send_data(message_data, num_bytes);
 802477c:	4628      	mov	r0, r5
 802477e:	2107      	movs	r1, #7
 8024780:	f004 fb0c 	bl	8028d9c <com_send_data>
    wr_payload_u16(message, 5, firmware_information.version_build);

    /* count length of firmware description string */
    while (firmware_information.description[string_length] != 0)
        ++string_length;
    ++string_length;
 8024784:	1c71      	adds	r1, r6, #1
}

void protocol_send_payload(const uint8_t *message_data, uint16_t num_bytes)
{
    /* send the data through the communication stream interface */
    com_send_data(message_data, num_bytes);
 8024786:	f8d8 0000 	ldr.w	r0, [r8]
 802478a:	b289      	uxth	r1, r1
 802478c:	f004 fb06 	bl	8028d9c <com_send_data>
}

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024790:	22e0      	movs	r2, #224	; 0xe0
    payload[offset    ] =  value        & 0xFF;
 8024792:	23db      	movs	r3, #219	; 0xdb
{
    /* setup message tail and send it */
    uint8_t tail[2];
    wr_payload_u16(tail, 0, CNST_END_OF_PAYLOAD);

    com_send_data(tail, sizeof(tail));
 8024794:	a801      	add	r0, sp, #4
 8024796:	2102      	movs	r1, #2
}

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024798:	f88d 2005 	strb.w	r2, [sp, #5]
    payload[offset    ] =  value        & 0xFF;
 802479c:	f88d 3004 	strb.w	r3, [sp, #4]
 80247a0:	f004 fafc 	bl	8028d9c <com_send_data>
    com_flush();
 80247a4:	f004 fb0c 	bl	8028dc0 <com_flush>
 80247a8:	e735      	b.n	8024616 <protocol_run+0x1ba>
        if (num_bytes == 1)
        {
            /* if user did not set system reset function, this feature is not
             * supported.
             */
            if (instance.do_system_reset == NULL)
 80247aa:	6ab3      	ldr	r3, [r6, #40]	; 0x28
 80247ac:	2b00      	cmp	r3, #0
 80247ae:	f43f af30 	beq.w	8024612 <protocol_run+0x1b6>
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 80247b2:	ad12      	add	r5, sp, #72	; 0x48
 80247b4:	235b      	movs	r3, #91	; 0x5b
 80247b6:	f845 3d40 	str.w	r3, [r5, #-64]!
    wr_payload_u8 (status_message, 0, CNST_STARTBYTE_STATUS);
    wr_payload_u8 (status_message, 1, endpoint);
    wr_payload_u16(status_message, 2, status_code);

    /* now send message */
    com_send_data(status_message, sizeof(status_message));
 80247ba:	2104      	movs	r1, #4
 80247bc:	4628      	mov	r0, r5
 80247be:	f004 faed 	bl	8028d9c <com_send_data>
    com_flush();
 80247c2:	f004 fafd 	bl	8028dc0 <com_flush>
             * possible.
             */
            send_status_message(0, PROTOCOL_ERROR_OK);

            /* now do the system reset */
            instance.do_system_reset();
 80247c6:	6ab3      	ldr	r3, [r6, #40]	; 0x28
 80247c8:	4798      	blx	r3
 80247ca:	e724      	b.n	8024616 <protocol_run+0x1ba>
 80247cc:	1ffe961c 	.word	0x1ffe961c

080247d0 <protocol_send_header>:
}

//============================================================================

void protocol_send_header(uint8_t endpoint, uint16_t num_bytes)
{
 80247d0:	b510      	push	{r4, lr}
 80247d2:	b082      	sub	sp, #8
 80247d4:	460b      	mov	r3, r1
}

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 80247d6:	0a0c      	lsrs	r4, r1, #8
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 80247d8:	f88d 0005 	strb.w	r0, [sp, #5]
 80247dc:	225a      	movs	r2, #90	; 0x5a
    uint8_t header[4];
    wr_payload_u8 (header, 0, CNST_STARTBYTE_DATA);
    wr_payload_u8 (header, 1, endpoint);
    wr_payload_u16(header, 2, num_bytes);

    com_send_data(header, sizeof(header));
 80247de:	a801      	add	r0, sp, #4
 80247e0:	2104      	movs	r1, #4

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 80247e2:	f88d 3006 	strb.w	r3, [sp, #6]
}

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 80247e6:	f88d 4007 	strb.w	r4, [sp, #7]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 80247ea:	f88d 2004 	strb.w	r2, [sp, #4]
 80247ee:	f004 fad5 	bl	8028d9c <com_send_data>
}
 80247f2:	b002      	add	sp, #8
 80247f4:	bd10      	pop	{r4, pc}
 80247f6:	bf00      	nop

080247f8 <protocol_send_payload>:

void protocol_send_payload(const uint8_t *message_data, uint16_t num_bytes)
{
    /* send the data through the communication stream interface */
    com_send_data(message_data, num_bytes);
 80247f8:	f004 bad0 	b.w	8028d9c <com_send_data>

080247fc <protocol_send_tail>:
}

void protocol_send_tail(void)
{
 80247fc:	b500      	push	{lr}
 80247fe:	b083      	sub	sp, #12

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 8024800:	a802      	add	r0, sp, #8
 8024802:	23db      	movs	r3, #219	; 0xdb
 8024804:	f800 3d04 	strb.w	r3, [r0, #-4]!
    /* setup message tail and send it */
    uint8_t tail[2];
    wr_payload_u16(tail, 0, CNST_END_OF_PAYLOAD);

    com_send_data(tail, sizeof(tail));
 8024808:	2102      	movs	r1, #2
}

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 802480a:	23e0      	movs	r3, #224	; 0xe0
 802480c:	f88d 3005 	strb.w	r3, [sp, #5]
 8024810:	f004 fac4 	bl	8028d9c <com_send_data>
    com_flush();
 8024814:	f004 fad4 	bl	8028dc0 <com_flush>
}
 8024818:	b003      	add	sp, #12
 802481a:	f85d fb04 	ldr.w	pc, [sp], #4
 802481e:	bf00      	nop

08024820 <protocol_broadcast_change>:

//============================================================================

void protocol_broadcast_change(void* context, uint32_t what)
{
 8024820:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    uint8_t i;

    /* broadcast change notification to all endpoints that have a
     * handle_change function
     */
    for (i = 0; i < instance.num_endpoints; ++i)
 8024824:	4d16      	ldr	r5, [pc, #88]	; (8024880 <protocol_broadcast_change+0x60>)
 8024826:	f895 e004 	ldrb.w	lr, [r5, #4]
 802482a:	f1be 0f00 	cmp.w	lr, #0
 802482e:	d01c      	beq.n	802486a <protocol_broadcast_change+0x4a>
 8024830:	4689      	mov	r9, r1
 8024832:	4606      	mov	r6, r0
 8024834:	2401      	movs	r4, #1
    {
        if ((instance.endpoints[i].handle_change) &&
 8024836:	46a8      	mov	r8, r5
 8024838:	e006      	b.n	8024848 <protocol_broadcast_change+0x28>
 802483a:	68db      	ldr	r3, [r3, #12]
 802483c:	42b3      	cmp	r3, r6
 802483e:	d016      	beq.n	802486e <protocol_broadcast_change+0x4e>
 8024840:	3401      	adds	r4, #1
    uint8_t i;

    /* broadcast change notification to all endpoints that have a
     * handle_change function
     */
    for (i = 0; i < instance.num_endpoints; ++i)
 8024842:	4572      	cmp	r2, lr
 8024844:	b2e4      	uxtb	r4, r4
 8024846:	d210      	bcs.n	802486a <protocol_broadcast_change+0x4a>
 8024848:	1e63      	subs	r3, r4, #1
    {
        if ((instance.endpoints[i].handle_change) &&
 802484a:	682a      	ldr	r2, [r5, #0]
 802484c:	b2db      	uxtb	r3, r3
 802484e:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8024852:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8024856:	4622      	mov	r2, r4
 8024858:	691f      	ldr	r7, [r3, #16]
 802485a:	2f00      	cmp	r7, #0
 802485c:	d1ed      	bne.n	802483a <protocol_broadcast_change+0x1a>
 802485e:	4622      	mov	r2, r4
    uint8_t i;

    /* broadcast change notification to all endpoints that have a
     * handle_change function
     */
    for (i = 0; i < instance.num_endpoints; ++i)
 8024860:	4572      	cmp	r2, lr
 8024862:	f104 0401 	add.w	r4, r4, #1
 8024866:	b2e4      	uxtb	r4, r4
 8024868:	d3ee      	bcc.n	8024848 <protocol_broadcast_change+0x28>
 802486a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    {
        if ((instance.endpoints[i].handle_change) &&
            (instance.endpoints[i].context == context))
        {
            instance.endpoints[i].handle_change(i + 1, context, what);
 802486e:	464a      	mov	r2, r9
 8024870:	4620      	mov	r0, r4
 8024872:	4631      	mov	r1, r6
 8024874:	47b8      	blx	r7
 8024876:	f898 e004 	ldrb.w	lr, [r8, #4]
 802487a:	4622      	mov	r2, r4
 802487c:	e7e0      	b.n	8024840 <protocol_broadcast_change+0x20>
 802487e:	bf00      	nop
 8024880:	1ffeb1d8 	.word	0x1ffeb1d8

08024884 <wr_payload_float>:
#define STATIC_ASSERT(test_for_true) _Static_assert((test_for_true), "(" #test_for_true ") failed")
#endif


size_t wr_payload_float(uint8_t* payload, size_t offset, float value)
{
 8024884:	b410      	push	{r4}
 8024886:	b083      	sub	sp, #12
		uint32_t u32_value;
		float float_value;
	} temp_union;

	temp_union data;
	data.float_value = value;
 8024888:	ab02      	add	r3, sp, #8
#define STATIC_ASSERT(test_for_true) _Static_assert((test_for_true), "(" #test_for_true ") failed")
#endif


size_t wr_payload_float(uint8_t* payload, size_t offset, float value)
{
 802488a:	4604      	mov	r4, r0
		uint32_t u32_value;
		float float_value;
	} temp_union;

	temp_union data;
	data.float_value = value;
 802488c:	f843 2d04 	str.w	r2, [r3, #-4]!

	memcpy(&payload[offset], &data.u32_value, sizeof(uint32_t));
 8024890:	6818      	ldr	r0, [r3, #0]
 8024892:	5060      	str	r0, [r4, r1]
    return sizeof(uint32_t);
}
 8024894:	2004      	movs	r0, #4
 8024896:	b003      	add	sp, #12
 8024898:	f85d 4b04 	ldr.w	r4, [sp], #4
 802489c:	4770      	bx	lr
 802489e:	bf00      	nop

080248a0 <wr_payload_string>:


size_t wr_payload_string(uint8_t *payload, size_t offset, char const *ptr)
{
 80248a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80248a2:	4606      	mov	r6, r0
 80248a4:	460d      	mov	r5, r1
	size_t increment = 0;
	if (ptr)
 80248a6:	4614      	mov	r4, r2
 80248a8:	2a00      	cmp	r2, #0
 80248aa:	d056      	beq.n	802495a <wr_payload_string+0xba>
	{
		uint8_t len = strlen(ptr);
 80248ac:	4610      	mov	r0, r2
 80248ae:	f008 fe5a 	bl	802d566 <strlen>
 80248b2:	5570      	strb	r0, [r6, r5]
		increment += wr_payload_u8(payload, offset + increment, len);  // attach the str len
		for(int k = 0; k < len; k++)
 80248b4:	f010 00ff 	ands.w	r0, r0, #255	; 0xff
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 80248b8:	eb06 0305 	add.w	r3, r6, r5
 80248bc:	d050      	beq.n	8024960 <wr_payload_string+0xc0>
 80248be:	1c6a      	adds	r2, r5, #1
 80248c0:	4432      	add	r2, r6
 80248c2:	ea44 0702 	orr.w	r7, r4, r2
 80248c6:	1d69      	adds	r1, r5, #5
 80248c8:	f017 0f03 	tst.w	r7, #3
 80248cc:	eb06 0701 	add.w	r7, r6, r1
 80248d0:	f104 0104 	add.w	r1, r4, #4
 80248d4:	bf0c      	ite	eq
 80248d6:	f04f 0e01 	moveq.w	lr, #1
 80248da:	f04f 0e00 	movne.w	lr, #0
 80248de:	42bc      	cmp	r4, r7
 80248e0:	bf38      	it	cc
 80248e2:	428a      	cmpcc	r2, r1
 80248e4:	bf2c      	ite	cs
 80248e6:	2101      	movcs	r1, #1
 80248e8:	2100      	movcc	r1, #0
 80248ea:	ea1e 0f01 	tst.w	lr, r1
 80248ee:	d029      	beq.n	8024944 <wr_payload_string+0xa4>
 80248f0:	2809      	cmp	r0, #9
 80248f2:	d927      	bls.n	8024944 <wr_payload_string+0xa4>
 80248f4:	1f03      	subs	r3, r0, #4
 80248f6:	089b      	lsrs	r3, r3, #2
 80248f8:	3301      	adds	r3, #1
 80248fa:	0099      	lsls	r1, r3, #2
 80248fc:	f1a4 0e04 	sub.w	lr, r4, #4
 8024900:	2700      	movs	r7, #0
 8024902:	3701      	adds	r7, #1
		{
			increment += wr_payload_u8(payload, offset + increment, ptr[k]);
 8024904:	f85e cf04 	ldr.w	ip, [lr, #4]!
 8024908:	f842 cb04 	str.w	ip, [r2], #4
 802490c:	42bb      	cmp	r3, r7
 802490e:	d8f8      	bhi.n	8024902 <wr_payload_string+0x62>
 8024910:	4288      	cmp	r0, r1
 8024912:	f101 0201 	add.w	r2, r1, #1
 8024916:	d013      	beq.n	8024940 <wr_payload_string+0xa0>
 8024918:	18b7      	adds	r7, r6, r2
 802491a:	f814 e023 	ldrb.w	lr, [r4, r3, lsl #2]
 802491e:	f807 e005 	strb.w	lr, [r7, r5]
	size_t increment = 0;
	if (ptr)
	{
		uint8_t len = strlen(ptr);
		increment += wr_payload_u8(payload, offset + increment, len);  // attach the str len
		for(int k = 0; k < len; k++)
 8024922:	4282      	cmp	r2, r0
		{
			increment += wr_payload_u8(payload, offset + increment, ptr[k]);
 8024924:	f101 0302 	add.w	r3, r1, #2
	size_t increment = 0;
	if (ptr)
	{
		uint8_t len = strlen(ptr);
		increment += wr_payload_u8(payload, offset + increment, len);  // attach the str len
		for(int k = 0; k < len; k++)
 8024928:	da0a      	bge.n	8024940 <wr_payload_string+0xa0>
 802492a:	4433      	add	r3, r6
		{
			increment += wr_payload_u8(payload, offset + increment, ptr[k]);
 802492c:	5ca2      	ldrb	r2, [r4, r2]
 802492e:	555a      	strb	r2, [r3, r5]
	size_t increment = 0;
	if (ptr)
	{
		uint8_t len = strlen(ptr);
		increment += wr_payload_u8(payload, offset + increment, len);  // attach the str len
		for(int k = 0; k < len; k++)
 8024930:	1c8b      	adds	r3, r1, #2
 8024932:	4298      	cmp	r0, r3
		{
			increment += wr_payload_u8(payload, offset + increment, ptr[k]);
 8024934:	f101 0103 	add.w	r1, r1, #3
	size_t increment = 0;
	if (ptr)
	{
		uint8_t len = strlen(ptr);
		increment += wr_payload_u8(payload, offset + increment, len);  // attach the str len
		for(int k = 0; k < len; k++)
 8024938:	dd02      	ble.n	8024940 <wr_payload_string+0xa0>
 802493a:	4431      	add	r1, r6
		{
			increment += wr_payload_u8(payload, offset + increment, ptr[k]);
 802493c:	5ce3      	ldrb	r3, [r4, r3]
 802493e:	554b      	strb	r3, [r1, r5]
 8024940:	3001      	adds	r0, #1
 8024942:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8024944:	4405      	add	r5, r0
 8024946:	442e      	add	r6, r5
 8024948:	3c01      	subs	r4, #1
 802494a:	f814 2f01 	ldrb.w	r2, [r4, #1]!
 802494e:	f803 2f01 	strb.w	r2, [r3, #1]!
	size_t increment = 0;
	if (ptr)
	{
		uint8_t len = strlen(ptr);
		increment += wr_payload_u8(payload, offset + increment, len);  // attach the str len
		for(int k = 0; k < len; k++)
 8024952:	42b3      	cmp	r3, r6
 8024954:	d1f9      	bne.n	802494a <wr_payload_string+0xaa>
 8024956:	3001      	adds	r0, #1
 8024958:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 802495a:	5572      	strb	r2, [r6, r5]
			increment += wr_payload_u8(payload, offset + increment, ptr[k]);
		}
	}
	else
	{
		increment += wr_payload_u8(payload, offset + increment, 0);  // attach the str len 0, to indicate empty string!!
 802495c:	2001      	movs	r0, #1
 802495e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
{
	size_t increment = 0;
	if (ptr)
	{
		uint8_t len = strlen(ptr);
		increment += wr_payload_u8(payload, offset + increment, len);  // attach the str len
 8024960:	2001      	movs	r0, #1
	else
	{
		increment += wr_payload_u8(payload, offset + increment, 0);  // attach the str len 0, to indicate empty string!!
	}
	return increment;
}
 8024962:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08024964 <wr_payload_helper_string_list>:


size_t wr_payload_helper_string_list(uint8_t* payload, size_t offset, size_t elements,  char * const *pp_str)
{
 8024964:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8024968:	4681      	mov	r9, r0
 802496a:	b083      	sub	sp, #12
 802496c:	4688      	mov	r8, r1
	size_t increment = 0;
	increment += wr_payload_u8(payload, offset, elements);
 802496e:	5442      	strb	r2, [r0, r1]
	for(int i = 0; i < elements; i++)
 8024970:	2a00      	cmp	r2, #0
 8024972:	d077      	beq.n	8024a64 <wr_payload_helper_string_list+0x100>
 8024974:	2601      	movs	r6, #1
 8024976:	469a      	mov	sl, r3
 8024978:	eb03 0782 	add.w	r7, r3, r2, lsl #2
 802497c:	198b      	adds	r3, r1, r6
 802497e:	9300      	str	r3, [sp, #0]
 8024980:	1d4b      	adds	r3, r1, #5
 8024982:	9301      	str	r3, [sp, #4]
 8024984:	e052      	b.n	8024a2c <wr_payload_helper_string_list+0xc8>
size_t wr_payload_string(uint8_t *payload, size_t offset, char const *ptr)
{
	size_t increment = 0;
	if (ptr)
	{
		uint8_t len = strlen(ptr);
 8024986:	4620      	mov	r0, r4
 8024988:	f008 fded 	bl	802d566 <strlen>
 802498c:	f809 0005 	strb.w	r0, [r9, r5]
		increment += wr_payload_u8(payload, offset + increment, len);  // attach the str len
		for(int k = 0; k < len; k++)
 8024990:	f010 00ff 	ands.w	r0, r0, #255	; 0xff
 8024994:	eb09 0305 	add.w	r3, r9, r5
 8024998:	d062      	beq.n	8024a60 <wr_payload_helper_string_list+0xfc>
 802499a:	9a00      	ldr	r2, [sp, #0]
 802499c:	9901      	ldr	r1, [sp, #4]
 802499e:	4432      	add	r2, r6
 80249a0:	444a      	add	r2, r9
 80249a2:	ea42 0c04 	orr.w	ip, r2, r4
 80249a6:	eb01 0e06 	add.w	lr, r1, r6
 80249aa:	f01c 0f03 	tst.w	ip, #3
 80249ae:	f104 0104 	add.w	r1, r4, #4
 80249b2:	44ce      	add	lr, r9
 80249b4:	bf0c      	ite	eq
 80249b6:	f04f 0c01 	moveq.w	ip, #1
 80249ba:	f04f 0c00 	movne.w	ip, #0
 80249be:	4574      	cmp	r4, lr
 80249c0:	bf38      	it	cc
 80249c2:	428a      	cmpcc	r2, r1
 80249c4:	bf2c      	ite	cs
 80249c6:	2101      	movcs	r1, #1
 80249c8:	2100      	movcc	r1, #0
 80249ca:	ea1c 0f01 	tst.w	ip, r1
 80249ce:	d03d      	beq.n	8024a4c <wr_payload_helper_string_list+0xe8>
 80249d0:	2809      	cmp	r0, #9
 80249d2:	d93b      	bls.n	8024a4c <wr_payload_helper_string_list+0xe8>
 80249d4:	1f01      	subs	r1, r0, #4
 80249d6:	0889      	lsrs	r1, r1, #2
 80249d8:	3101      	adds	r1, #1
 80249da:	008d      	lsls	r5, r1, #2
 80249dc:	f1a4 0c04 	sub.w	ip, r4, #4
 80249e0:	f04f 0e00 	mov.w	lr, #0
 80249e4:	469b      	mov	fp, r3
 80249e6:	f10e 0e01 	add.w	lr, lr, #1
		{
			increment += wr_payload_u8(payload, offset + increment, ptr[k]);
 80249ea:	f85c 3f04 	ldr.w	r3, [ip, #4]!
 80249ee:	f842 3b04 	str.w	r3, [r2], #4
 80249f2:	4571      	cmp	r1, lr
 80249f4:	d8f7      	bhi.n	80249e6 <wr_payload_helper_string_list+0x82>
 80249f6:	42a8      	cmp	r0, r5
 80249f8:	465b      	mov	r3, fp
 80249fa:	f105 0201 	add.w	r2, r5, #1
 80249fe:	d011      	beq.n	8024a24 <wr_payload_helper_string_list+0xc0>
 8024a00:	f814 1021 	ldrb.w	r1, [r4, r1, lsl #2]
 8024a04:	f80b 1002 	strb.w	r1, [fp, r2]
	size_t increment = 0;
	if (ptr)
	{
		uint8_t len = strlen(ptr);
		increment += wr_payload_u8(payload, offset + increment, len);  // attach the str len
		for(int k = 0; k < len; k++)
 8024a08:	4282      	cmp	r2, r0
		{
			increment += wr_payload_u8(payload, offset + increment, ptr[k]);
 8024a0a:	f105 0102 	add.w	r1, r5, #2
	size_t increment = 0;
	if (ptr)
	{
		uint8_t len = strlen(ptr);
		increment += wr_payload_u8(payload, offset + increment, len);  // attach the str len
		for(int k = 0; k < len; k++)
 8024a0e:	da09      	bge.n	8024a24 <wr_payload_helper_string_list+0xc0>
		{
			increment += wr_payload_u8(payload, offset + increment, ptr[k]);
 8024a10:	5ca2      	ldrb	r2, [r4, r2]
 8024a12:	f80b 2001 	strb.w	r2, [fp, r1]
	size_t increment = 0;
	if (ptr)
	{
		uint8_t len = strlen(ptr);
		increment += wr_payload_u8(payload, offset + increment, len);  // attach the str len
		for(int k = 0; k < len; k++)
 8024a16:	4288      	cmp	r0, r1
 8024a18:	460a      	mov	r2, r1
		{
			increment += wr_payload_u8(payload, offset + increment, ptr[k]);
 8024a1a:	f105 0503 	add.w	r5, r5, #3
	size_t increment = 0;
	if (ptr)
	{
		uint8_t len = strlen(ptr);
		increment += wr_payload_u8(payload, offset + increment, len);  // attach the str len
		for(int k = 0; k < len; k++)
 8024a1e:	dd01      	ble.n	8024a24 <wr_payload_helper_string_list+0xc0>
		{
			increment += wr_payload_u8(payload, offset + increment, ptr[k]);
 8024a20:	5ca2      	ldrb	r2, [r4, r2]
 8024a22:	555a      	strb	r2, [r3, r5]
 8024a24:	3001      	adds	r0, #1

size_t wr_payload_helper_string_list(uint8_t* payload, size_t offset, size_t elements,  char * const *pp_str)
{
	size_t increment = 0;
	increment += wr_payload_u8(payload, offset, elements);
	for(int i = 0; i < elements; i++)
 8024a26:	45ba      	cmp	sl, r7
	{
		const char *ptr = pp_str[i];
		increment += wr_payload_string(payload, offset + increment, ptr);
 8024a28:	4406      	add	r6, r0

size_t wr_payload_helper_string_list(uint8_t* payload, size_t offset, size_t elements,  char * const *pp_str)
{
	size_t increment = 0;
	increment += wr_payload_u8(payload, offset, elements);
	for(int i = 0; i < elements; i++)
 8024a2a:	d00b      	beq.n	8024a44 <wr_payload_helper_string_list+0xe0>
	{
		const char *ptr = pp_str[i];
 8024a2c:	f85a 4b04 	ldr.w	r4, [sl], #4
		increment += wr_payload_string(payload, offset + increment, ptr);
 8024a30:	eb06 0508 	add.w	r5, r6, r8


size_t wr_payload_string(uint8_t *payload, size_t offset, char const *ptr)
{
	size_t increment = 0;
	if (ptr)
 8024a34:	2c00      	cmp	r4, #0
 8024a36:	d1a6      	bne.n	8024986 <wr_payload_helper_string_list+0x22>
			increment += wr_payload_u8(payload, offset + increment, ptr[k]);
		}
	}
	else
	{
		increment += wr_payload_u8(payload, offset + increment, 0);  // attach the str len 0, to indicate empty string!!
 8024a38:	2001      	movs	r0, #1

size_t wr_payload_helper_string_list(uint8_t* payload, size_t offset, size_t elements,  char * const *pp_str)
{
	size_t increment = 0;
	increment += wr_payload_u8(payload, offset, elements);
	for(int i = 0; i < elements; i++)
 8024a3a:	45ba      	cmp	sl, r7
 8024a3c:	f809 4005 	strb.w	r4, [r9, r5]
	{
		const char *ptr = pp_str[i];
		increment += wr_payload_string(payload, offset + increment, ptr);
 8024a40:	4406      	add	r6, r0

size_t wr_payload_helper_string_list(uint8_t* payload, size_t offset, size_t elements,  char * const *pp_str)
{
	size_t increment = 0;
	increment += wr_payload_u8(payload, offset, elements);
	for(int i = 0; i < elements; i++)
 8024a42:	d1f3      	bne.n	8024a2c <wr_payload_helper_string_list+0xc8>
	{
		const char *ptr = pp_str[i];
		increment += wr_payload_string(payload, offset + increment, ptr);
	}
	return increment;
}
 8024a44:	4630      	mov	r0, r6
 8024a46:	b003      	add	sp, #12
 8024a48:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8024a4c:	4405      	add	r5, r0
 8024a4e:	444d      	add	r5, r9
 8024a50:	3c01      	subs	r4, #1
	{
		uint8_t len = strlen(ptr);
		increment += wr_payload_u8(payload, offset + increment, len);  // attach the str len
		for(int k = 0; k < len; k++)
		{
			increment += wr_payload_u8(payload, offset + increment, ptr[k]);
 8024a52:	f814 2f01 	ldrb.w	r2, [r4, #1]!
 8024a56:	f803 2f01 	strb.w	r2, [r3, #1]!
	size_t increment = 0;
	if (ptr)
	{
		uint8_t len = strlen(ptr);
		increment += wr_payload_u8(payload, offset + increment, len);  // attach the str len
		for(int k = 0; k < len; k++)
 8024a5a:	42ab      	cmp	r3, r5
 8024a5c:	d1f9      	bne.n	8024a52 <wr_payload_helper_string_list+0xee>
 8024a5e:	e7e1      	b.n	8024a24 <wr_payload_helper_string_list+0xc0>
{
	size_t increment = 0;
	if (ptr)
	{
		uint8_t len = strlen(ptr);
		increment += wr_payload_u8(payload, offset + increment, len);  // attach the str len
 8024a60:	2001      	movs	r0, #1
 8024a62:	e7e0      	b.n	8024a26 <wr_payload_helper_string_list+0xc2>


size_t wr_payload_helper_string_list(uint8_t* payload, size_t offset, size_t elements,  char * const *pp_str)
{
	size_t increment = 0;
	increment += wr_payload_u8(payload, offset, elements);
 8024a64:	2601      	movs	r6, #1
 8024a66:	e7ed      	b.n	8024a44 <wr_payload_helper_string_list+0xe0>

08024a68 <USBD_VCOM_Event_GetDescriptor>:
	const uint8_t  descriptor_type   = (w_value >> 8);
	const uint8_t  descriptor_number = (w_value & 0xFF);
	const void* address = NULL;
	uint16_t    size    = NO_DESCRIPTOR;

	switch (descriptor_type)
 8024a68:	0a03      	lsrs	r3, r0, #8
 8024a6a:	2b02      	cmp	r3, #2
 8024a6c:	d016      	beq.n	8024a9c <USBD_VCOM_Event_GetDescriptor+0x34>
 8024a6e:	2b03      	cmp	r3, #3
 8024a70:	d009      	beq.n	8024a86 <USBD_VCOM_Event_GetDescriptor+0x1e>
 8024a72:	2b01      	cmp	r3, #1
 8024a74:	d003      	beq.n	8024a7e <USBD_VCOM_Event_GetDescriptor+0x16>
uint16_t USBD_VCOM_Event_GetDescriptor(const uint16_t w_value,
                                    const uint16_t w_index,
                                    const void** const descriptor_address)
{
	const uint8_t  descriptor_type   = (w_value >> 8);
	const uint8_t  descriptor_number = (w_value & 0xFF);
 8024a76:	2000      	movs	r0, #0
 8024a78:	4603      	mov	r3, r0
			}
			break;
	}

	(void)w_index;
	*descriptor_address = address;
 8024a7a:	6013      	str	r3, [r2, #0]
	return size;
}
 8024a7c:	4770      	bx	lr
	uint16_t    size    = NO_DESCRIPTOR;

	switch (descriptor_type)
	{
		case DTYPE_Device:
			address = &device_descriptor;
 8024a7e:	4b09      	ldr	r3, [pc, #36]	; (8024aa4 <USBD_VCOM_Event_GetDescriptor+0x3c>)
			}
			break;
	}

	(void)w_index;
	*descriptor_address = address;
 8024a80:	6013      	str	r3, [r2, #0]

	switch (descriptor_type)
	{
		case DTYPE_Device:
			address = &device_descriptor;
			size    = sizeof(USB_Descriptor_Device_t);
 8024a82:	2012      	movs	r0, #18
	}

	(void)w_index;
	*descriptor_address = address;
	return size;
}
 8024a84:	4770      	bx	lr
uint16_t USBD_VCOM_Event_GetDescriptor(const uint16_t w_value,
                                    const uint16_t w_index,
                                    const void** const descriptor_address)
{
	const uint8_t  descriptor_type   = (w_value >> 8);
	const uint8_t  descriptor_number = (w_value & 0xFF);
 8024a86:	b2c0      	uxtb	r0, r0
 8024a88:	2802      	cmp	r0, #2
 8024a8a:	d8f4      	bhi.n	8024a76 <USBD_VCOM_Event_GetDescriptor+0xe>
 8024a8c:	4b06      	ldr	r3, [pc, #24]	; (8024aa8 <USBD_VCOM_Event_GetDescriptor+0x40>)
 8024a8e:	4907      	ldr	r1, [pc, #28]	; (8024aac <USBD_VCOM_Event_GetDescriptor+0x44>)
 8024a90:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
			}
			break;
	}

	(void)w_index;
	*descriptor_address = address;
 8024a94:	6013      	str	r3, [r2, #0]
 8024a96:	f831 0010 	ldrh.w	r0, [r1, r0, lsl #1]
	return size;
}
 8024a9a:	4770      	bx	lr
		case DTYPE_Device:
			address = &device_descriptor;
			size    = sizeof(USB_Descriptor_Device_t);
			break;
		case DTYPE_Configuration:
			address = &configuration_descriptor;
 8024a9c:	4b04      	ldr	r3, [pc, #16]	; (8024ab0 <USBD_VCOM_Event_GetDescriptor+0x48>)
			}
			break;
	}

	(void)w_index;
	*descriptor_address = address;
 8024a9e:	6013      	str	r3, [r2, #0]
			address = &device_descriptor;
			size    = sizeof(USB_Descriptor_Device_t);
			break;
		case DTYPE_Configuration:
			address = &configuration_descriptor;
			size    = sizeof(USB_Descriptor_Configuration_t);
 8024aa0:	203e      	movs	r0, #62	; 0x3e
	}

	(void)w_index;
	*descriptor_address = address;
	return size;
}
 8024aa2:	4770      	bx	lr
 8024aa4:	0802d8d8 	.word	0x0802d8d8
 8024aa8:	0802d9bc 	.word	0x0802d9bc
 8024aac:	0802d9c8 	.word	0x0802d9c8
 8024ab0:	0802d9d0 	.word	0x0802d9d0

08024ab4 <CDC_Device_ProcessControlRequest>:
	 *  packet, \c false otherwise.
	 */
	static inline bool Endpoint_IsSETUPReceived(void);
	static inline bool Endpoint_IsSETUPReceived(void)
	{
		return device.IsSetupRecieved;
 8024ab4:	4a45      	ldr	r2, [pc, #276]	; (8024bcc <CDC_Device_ProcessControlRequest+0x118>)
 8024ab6:	f892 313e 	ldrb.w	r3, [r2, #318]	; 0x13e
 * API IMPLEMENTATION
 **********************************************************************************************************************/
void CDC_Device_ProcessControlRequest(
					USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
	if ((Endpoint_IsSETUPReceived() != 0) && (USB_ControlRequest.wIndex ==
 8024aba:	079b      	lsls	r3, r3, #30
 8024abc:	d510      	bpl.n	8024ae0 <CDC_Device_ProcessControlRequest+0x2c>
/**********************************************************************************************************************
 * API IMPLEMENTATION
 **********************************************************************************************************************/
void CDC_Device_ProcessControlRequest(
					USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
 8024abe:	b570      	push	{r4, r5, r6, lr}
	if ((Endpoint_IsSETUPReceived() != 0) && (USB_ControlRequest.wIndex ==
 8024ac0:	4943      	ldr	r1, [pc, #268]	; (8024bd0 <CDC_Device_ProcessControlRequest+0x11c>)
 8024ac2:	7c84      	ldrb	r4, [r0, #18]
 8024ac4:	888b      	ldrh	r3, [r1, #4]
 8024ac6:	b29b      	uxth	r3, r3
 8024ac8:	429c      	cmp	r4, r3
 8024aca:	d000      	beq.n	8024ace <CDC_Device_ProcessControlRequest+0x1a>
 8024acc:	bd70      	pop	{r4, r5, r6, pc}
			CDCInterfaceInfo->Config.ControlInterfaceNumber))
	{

		switch (USB_ControlRequest.bRequest)
 8024ace:	784b      	ldrb	r3, [r1, #1]
 8024ad0:	3b20      	subs	r3, #32
 8024ad2:	4604      	mov	r4, r0
 8024ad4:	2b03      	cmp	r3, #3
 8024ad6:	d8f9      	bhi.n	8024acc <CDC_Device_ProcessControlRequest+0x18>
 8024ad8:	e8df f003 	tbb	[pc, r3]
 8024adc:	03633f18 	.word	0x03633f18
 8024ae0:	4770      	bx	lr

				}

				break;
			case CDC_REQ_SendBreak:
				if ((REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE) == USB_ControlRequest.bmRequestType)
 8024ae2:	780b      	ldrb	r3, [r1, #0]
 8024ae4:	493a      	ldr	r1, [pc, #232]	; (8024bd0 <CDC_Device_ProcessControlRequest+0x11c>)
 8024ae6:	2b21      	cmp	r3, #33	; 0x21
 8024ae8:	d1f0      	bne.n	8024acc <CDC_Device_ProcessControlRequest+0x18>
				{
					Endpoint_ClearSETUP();
					Endpoint_ClearStatusStage();

					if(0 != cdc_class_events.Device_BreakSent)
 8024aea:	483a      	ldr	r0, [pc, #232]	; (8024bd4 <CDC_Device_ProcessControlRequest+0x120>)
	 *  \note This is not applicable for non CONTROL type endpoints.
	 */
	static inline void Endpoint_ClearSETUP(void);
	static inline void Endpoint_ClearSETUP(void)
	{
		device.IsSetupRecieved = 0;
 8024aec:	f892 313e 	ldrb.w	r3, [r2, #318]	; 0x13e
 8024af0:	6885      	ldr	r5, [r0, #8]
 8024af2:	f023 0302 	bic.w	r3, r3, #2
 8024af6:	f882 313e 	strb.w	r3, [r2, #318]	; 0x13e
 8024afa:	2d00      	cmp	r5, #0
 8024afc:	d0e6      	beq.n	8024acc <CDC_Device_ProcessControlRequest+0x18>
					{
						cdc_class_events.Device_BreakSent(CDCInterfaceInfo,	(uint8_t)USB_ControlRequest.wValue);
 8024afe:	8849      	ldrh	r1, [r1, #2]
 8024b00:	4620      	mov	r0, r4
 8024b02:	462b      	mov	r3, r5
 8024b04:	b2c9      	uxtb	r1, r1
				}

				break;
		}
	}
}
 8024b06:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
					Endpoint_ClearSETUP();
					Endpoint_ClearStatusStage();

					if(0 != cdc_class_events.Device_BreakSent)
					{
						cdc_class_events.Device_BreakSent(CDCInterfaceInfo,	(uint8_t)USB_ControlRequest.wValue);
 8024b0a:	4718      	bx	r3
					Endpoint_ClearStatusStage();
				}

				break;
			case CDC_REQ_SetLineEncoding:
				if ((REQDIR_HOSTTODEVICE |REQTYPE_CLASS | REQREC_INTERFACE) == USB_ControlRequest.bmRequestType)
 8024b0c:	780b      	ldrb	r3, [r1, #0]
 8024b0e:	2b21      	cmp	r3, #33	; 0x21
 8024b10:	d1dc      	bne.n	8024acc <CDC_Device_ProcessControlRequest+0x18>
 8024b12:	f892 013e 	ldrb.w	r0, [r2, #318]	; 0x13e
 8024b16:	f892 313c 	ldrb.w	r3, [r2, #316]	; 0x13c
				{
					Endpoint_ClearSETUP();

					while (!(Endpoint_IsOUTReceived()))
					{
						if (USB_DeviceState == DEVICE_STATE_Unattached)
 8024b1a:	492f      	ldr	r1, [pc, #188]	; (8024bd8 <CDC_Device_ProcessControlRequest+0x124>)
 8024b1c:	f020 0002 	bic.w	r0, r0, #2
	 */
	static inline bool Endpoint_IsOUTReceived(void);
	static inline bool Endpoint_IsOUTReceived(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
		return ep->IsOutRecieved;
 8024b20:	252c      	movs	r5, #44	; 0x2c
	 *  \note This is not applicable for non CONTROL type endpoints.
	 */
	static inline void Endpoint_ClearSETUP(void);
	static inline void Endpoint_ClearSETUP(void)
	{
		device.IsSetupRecieved = 0;
 8024b22:	f882 013e 	strb.w	r0, [r2, #318]	; 0x13e
	 */
	static inline bool Endpoint_IsOUTReceived(void);
	static inline bool Endpoint_IsOUTReceived(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
		return ep->IsOutRecieved;
 8024b26:	fb05 2203 	mla	r2, r5, r3, r2
 8024b2a:	e002      	b.n	8024b32 <CDC_Device_ProcessControlRequest+0x7e>
 8024b2c:	780b      	ldrb	r3, [r1, #0]
 8024b2e:	2b00      	cmp	r3, #0
 8024b30:	d0cc      	beq.n	8024acc <CDC_Device_ProcessControlRequest+0x18>
 8024b32:	6893      	ldr	r3, [r2, #8]
			case CDC_REQ_SetLineEncoding:
				if ((REQDIR_HOSTTODEVICE |REQTYPE_CLASS | REQREC_INTERFACE) == USB_ControlRequest.bmRequestType)
				{
					Endpoint_ClearSETUP();

					while (!(Endpoint_IsOUTReceived()))
 8024b34:	069b      	lsls	r3, r3, #26
 8024b36:	d5f9      	bpl.n	8024b2c <CDC_Device_ProcessControlRequest+0x78>
					{
						if (USB_DeviceState == DEVICE_STATE_Unattached)
						  return;
					}

					CDCInterfaceInfo->State.LineEncoding.BaudRateBPS = Endpoint_Read_32_LE();
 8024b38:	f000 fc30 	bl	802539c <Endpoint_Read_32_LE>
 8024b3c:	61a0      	str	r0, [r4, #24]
					CDCInterfaceInfo->State.LineEncoding.CharFormat  = Endpoint_Read_8();
 8024b3e:	f000 fc01 	bl	8025344 <Endpoint_Read_8>
 8024b42:	7720      	strb	r0, [r4, #28]
					CDCInterfaceInfo->State.LineEncoding.ParityType  = Endpoint_Read_8();
 8024b44:	f000 fbfe 	bl	8025344 <Endpoint_Read_8>
 8024b48:	7760      	strb	r0, [r4, #29]
					CDCInterfaceInfo->State.LineEncoding.DataBits    = Endpoint_Read_8();
 8024b4a:	f000 fbfb 	bl	8025344 <Endpoint_Read_8>

					//Endpoint_ClearOUT();
					Endpoint_ClearStatusStage();

					if(0 != cdc_class_events.LineEncodingChanged)
 8024b4e:	4b21      	ldr	r3, [pc, #132]	; (8024bd4 <CDC_Device_ProcessControlRequest+0x120>)
					}

					CDCInterfaceInfo->State.LineEncoding.BaudRateBPS = Endpoint_Read_32_LE();
					CDCInterfaceInfo->State.LineEncoding.CharFormat  = Endpoint_Read_8();
					CDCInterfaceInfo->State.LineEncoding.ParityType  = Endpoint_Read_8();
					CDCInterfaceInfo->State.LineEncoding.DataBits    = Endpoint_Read_8();
 8024b50:	77a0      	strb	r0, [r4, #30]

					//Endpoint_ClearOUT();
					Endpoint_ClearStatusStage();

					if(0 != cdc_class_events.LineEncodingChanged)
 8024b52:	681b      	ldr	r3, [r3, #0]
 8024b54:	2b00      	cmp	r3, #0
 8024b56:	d134      	bne.n	8024bc2 <CDC_Device_ProcessControlRequest+0x10e>
 8024b58:	e7b8      	b.n	8024acc <CDC_Device_ProcessControlRequest+0x18>
	{

		switch (USB_ControlRequest.bRequest)
		{
			case CDC_REQ_GetLineEncoding:
				if ((REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE) == USB_ControlRequest.bmRequestType)
 8024b5a:	780b      	ldrb	r3, [r1, #0]
 8024b5c:	2ba1      	cmp	r3, #161	; 0xa1
 8024b5e:	d1b5      	bne.n	8024acc <CDC_Device_ProcessControlRequest+0x18>
	 *  \note This is not applicable for non CONTROL type endpoints.
	 */
	static inline void Endpoint_ClearSETUP(void);
	static inline void Endpoint_ClearSETUP(void)
	{
		device.IsSetupRecieved = 0;
 8024b60:	f892 113e 	ldrb.w	r1, [r2, #318]	; 0x13e
 8024b64:	f892 313c 	ldrb.w	r3, [r2, #316]	; 0x13c
 8024b68:	f021 0102 	bic.w	r1, r1, #2
	 */
	static inline bool Endpoint_IsINReady(void);
	static inline bool Endpoint_IsINReady(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
		return ep->InInUse == 0 && ep->IsEnabled;
 8024b6c:	202c      	movs	r0, #44	; 0x2c
	 *  \note This is not applicable for non CONTROL type endpoints.
	 */
	static inline void Endpoint_ClearSETUP(void);
	static inline void Endpoint_ClearSETUP(void)
	{
		device.IsSetupRecieved = 0;
 8024b6e:	f882 113e 	strb.w	r1, [r2, #318]	; 0x13e
	 */
	static inline bool Endpoint_IsINReady(void);
	static inline bool Endpoint_IsINReady(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
		return ep->InInUse == 0 && ep->IsEnabled;
 8024b72:	fb00 2203 	mla	r2, r0, r3, r2
 8024b76:	6893      	ldr	r3, [r2, #8]
 8024b78:	06d8      	lsls	r0, r3, #27
 8024b7a:	d4fc      	bmi.n	8024b76 <CDC_Device_ProcessControlRequest+0xc2>
 8024b7c:	6893      	ldr	r3, [r2, #8]
 8024b7e:	0799      	lsls	r1, r3, #30
 8024b80:	d5f9      	bpl.n	8024b76 <CDC_Device_ProcessControlRequest+0xc2>
				{
					Endpoint_ClearSETUP();

					while (!(Endpoint_IsINReady()));

					Endpoint_Write_32_LE(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS);
 8024b82:	69a0      	ldr	r0, [r4, #24]
 8024b84:	f000 fbf4 	bl	8025370 <Endpoint_Write_32_LE>
					Endpoint_Write_8(CDCInterfaceInfo->State.LineEncoding.CharFormat);
 8024b88:	7f20      	ldrb	r0, [r4, #28]
 8024b8a:	f000 fbc5 	bl	8025318 <Endpoint_Write_8>
					Endpoint_Write_8(CDCInterfaceInfo->State.LineEncoding.ParityType);
 8024b8e:	7f60      	ldrb	r0, [r4, #29]
 8024b90:	f000 fbc2 	bl	8025318 <Endpoint_Write_8>
					Endpoint_Write_8(CDCInterfaceInfo->State.LineEncoding.DataBits);
 8024b94:	7fa0      	ldrb	r0, [r4, #30]
 8024b96:	f000 fbbf 	bl	8025318 <Endpoint_Write_8>
				}

				break;
		}
	}
}
 8024b9a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
					Endpoint_Write_32_LE(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS);
					Endpoint_Write_8(CDCInterfaceInfo->State.LineEncoding.CharFormat);
					Endpoint_Write_8(CDCInterfaceInfo->State.LineEncoding.ParityType);
					Endpoint_Write_8(CDCInterfaceInfo->State.LineEncoding.DataBits);

					Endpoint_ClearIN();
 8024b9e:	f000 bb6b 	b.w	8025278 <Endpoint_ClearIN>

				}

				break;
			case CDC_REQ_SetControlLineState:
				if ((REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE) == USB_ControlRequest.bmRequestType)
 8024ba2:	780b      	ldrb	r3, [r1, #0]
 8024ba4:	490a      	ldr	r1, [pc, #40]	; (8024bd0 <CDC_Device_ProcessControlRequest+0x11c>)
 8024ba6:	2b21      	cmp	r3, #33	; 0x21
 8024ba8:	d190      	bne.n	8024acc <CDC_Device_ProcessControlRequest+0x18>
	 *  \note This is not applicable for non CONTROL type endpoints.
	 */
	static inline void Endpoint_ClearSETUP(void);
	static inline void Endpoint_ClearSETUP(void)
	{
		device.IsSetupRecieved = 0;
 8024baa:	f892 313e 	ldrb.w	r3, [r2, #318]	; 0x13e
					Endpoint_ClearSETUP();
					Endpoint_ClearStatusStage();

					CDCInterfaceInfo->State.ControlLineStates.HostToDevice = USB_ControlRequest.wValue;

					if(0 != cdc_class_events.ControLineStateChanged)
 8024bae:	4809      	ldr	r0, [pc, #36]	; (8024bd4 <CDC_Device_ProcessControlRequest+0x120>)
 8024bb0:	f023 0302 	bic.w	r3, r3, #2
 8024bb4:	f882 313e 	strb.w	r3, [r2, #318]	; 0x13e
 8024bb8:	6843      	ldr	r3, [r0, #4]
				if ((REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE) == USB_ControlRequest.bmRequestType)
				{
					Endpoint_ClearSETUP();
					Endpoint_ClearStatusStage();

					CDCInterfaceInfo->State.ControlLineStates.HostToDevice = USB_ControlRequest.wValue;
 8024bba:	884a      	ldrh	r2, [r1, #2]
 8024bbc:	82a2      	strh	r2, [r4, #20]

					if(0 != cdc_class_events.ControLineStateChanged)
 8024bbe:	2b00      	cmp	r3, #0
 8024bc0:	d084      	beq.n	8024acc <CDC_Device_ProcessControlRequest+0x18>
					{
						cdc_class_events.ControLineStateChanged(CDCInterfaceInfo);
 8024bc2:	4620      	mov	r0, r4
				}

				break;
		}
	}
}
 8024bc4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}

					CDCInterfaceInfo->State.ControlLineStates.HostToDevice = USB_ControlRequest.wValue;

					if(0 != cdc_class_events.ControLineStateChanged)
					{
						cdc_class_events.ControLineStateChanged(CDCInterfaceInfo);
 8024bc8:	4718      	bx	r3
 8024bca:	bf00      	nop
 8024bcc:	1fff0594 	.word	0x1fff0594
 8024bd0:	1fff038c 	.word	0x1fff038c
 8024bd4:	1ffe90e4 	.word	0x1ffe90e4
 8024bd8:	1fff0389 	.word	0x1fff0389

08024bdc <CDC_Device_ConfigureEndpoints>:




bool CDC_Device_ConfigureEndpoints(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
 8024bdc:	b538      	push	{r3, r4, r5, lr}
	bool status = true;
	memset(&CDCInterfaceInfo->State, 0x00, sizeof(CDCInterfaceInfo->State));

	CDCInterfaceInfo->Config.DataINEndpoint.Type       = EP_TYPE_BULK;
 8024bde:	2202      	movs	r2, #2


bool CDC_Device_ConfigureEndpoints(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
	bool status = true;
	memset(&CDCInterfaceInfo->State, 0x00, sizeof(CDCInterfaceInfo->State));
 8024be0:	2300      	movs	r3, #0

	CDCInterfaceInfo->Config.DataINEndpoint.Type       = EP_TYPE_BULK;
	CDCInterfaceInfo->Config.DataOUTEndpoint.Type      = EP_TYPE_BULK;
	CDCInterfaceInfo->Config.NotificationEndpoint.Type = EP_TYPE_INTERRUPT;
 8024be2:	2103      	movs	r1, #3


bool CDC_Device_ConfigureEndpoints(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
	bool status = true;
	memset(&CDCInterfaceInfo->State, 0x00, sizeof(CDCInterfaceInfo->State));
 8024be4:	7503      	strb	r3, [r0, #20]
 8024be6:	7543      	strb	r3, [r0, #21]
 8024be8:	7583      	strb	r3, [r0, #22]
 8024bea:	75c3      	strb	r3, [r0, #23]
 8024bec:	7603      	strb	r3, [r0, #24]
 8024bee:	7643      	strb	r3, [r0, #25]
 8024bf0:	7683      	strb	r3, [r0, #26]
 8024bf2:	76c3      	strb	r3, [r0, #27]
 8024bf4:	7703      	strb	r3, [r0, #28]
 8024bf6:	7743      	strb	r3, [r0, #29]
 8024bf8:	7783      	strb	r3, [r0, #30]
 8024bfa:	77c3      	strb	r3, [r0, #31]

	CDCInterfaceInfo->Config.DataINEndpoint.Type       = EP_TYPE_BULK;
 8024bfc:	7102      	strb	r2, [r0, #4]
	CDCInterfaceInfo->Config.DataOUTEndpoint.Type      = EP_TYPE_BULK;
 8024bfe:	7282      	strb	r2, [r0, #10]
	CDCInterfaceInfo->Config.NotificationEndpoint.Type = EP_TYPE_INTERRUPT;
 8024c00:	7401      	strb	r1, [r0, #16]

	if (!(Endpoint_ConfigureEndpointTable(&CDCInterfaceInfo->Config.DataINEndpoint, 1)))
 8024c02:	2101      	movs	r1, #1




bool CDC_Device_ConfigureEndpoints(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
 8024c04:	4604      	mov	r4, r0

	CDCInterfaceInfo->Config.DataINEndpoint.Type       = EP_TYPE_BULK;
	CDCInterfaceInfo->Config.DataOUTEndpoint.Type      = EP_TYPE_BULK;
	CDCInterfaceInfo->Config.NotificationEndpoint.Type = EP_TYPE_INTERRUPT;

	if (!(Endpoint_ConfigureEndpointTable(&CDCInterfaceInfo->Config.DataINEndpoint, 1)))
 8024c06:	f000 fbdf 	bl	80253c8 <Endpoint_ConfigureEndpointTable>
	{
		status = false;
	}

	if (!(Endpoint_ConfigureEndpointTable(
 8024c0a:	2101      	movs	r1, #1

	CDCInterfaceInfo->Config.DataINEndpoint.Type       = EP_TYPE_BULK;
	CDCInterfaceInfo->Config.DataOUTEndpoint.Type      = EP_TYPE_BULK;
	CDCInterfaceInfo->Config.NotificationEndpoint.Type = EP_TYPE_INTERRUPT;

	if (!(Endpoint_ConfigureEndpointTable(&CDCInterfaceInfo->Config.DataINEndpoint, 1)))
 8024c0c:	4605      	mov	r5, r0
	{
		status = false;
	}

	if (!(Endpoint_ConfigureEndpointTable(
 8024c0e:	1da0      	adds	r0, r4, #6
 8024c10:	f000 fbda 	bl	80253c8 <Endpoint_ConfigureEndpointTable>
							&CDCInterfaceInfo->Config.DataOUTEndpoint, 1)))
	{
		status = false;
	}

	if (!(Endpoint_ConfigureEndpointTable(
 8024c14:	2101      	movs	r1, #1
	if (!(Endpoint_ConfigureEndpointTable(&CDCInterfaceInfo->Config.DataINEndpoint, 1)))
	{
		status = false;
	}

	if (!(Endpoint_ConfigureEndpointTable(
 8024c16:	2800      	cmp	r0, #0
							&CDCInterfaceInfo->Config.DataOUTEndpoint, 1)))
	{
		status = false;
	}

	if (!(Endpoint_ConfigureEndpointTable(
 8024c18:	f104 000c 	add.w	r0, r4, #12
	}

	if (!(Endpoint_ConfigureEndpointTable(
							&CDCInterfaceInfo->Config.DataOUTEndpoint, 1)))
	{
		status = false;
 8024c1c:	bf08      	it	eq
 8024c1e:	2500      	moveq	r5, #0
	}

	if (!(Endpoint_ConfigureEndpointTable(
 8024c20:	f000 fbd2 	bl	80253c8 <Endpoint_ConfigureEndpointTable>
 8024c24:	2800      	cmp	r0, #0
	{
		status = false;
	}

	return status;
}
 8024c26:	bf14      	ite	ne
 8024c28:	4628      	movne	r0, r5
 8024c2a:	2000      	moveq	r0, #0
 8024c2c:	bd38      	pop	{r3, r4, r5, pc}
 8024c2e:	bf00      	nop

08024c30 <CDC_Device_USBTask>:

void CDC_Device_USBTask(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
	if ((USB_DeviceState == DEVICE_STATE_Configured) &&	(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS != 0))
 8024c30:	4b1c      	ldr	r3, [pc, #112]	; (8024ca4 <CDC_Device_USBTask+0x74>)
 8024c32:	781a      	ldrb	r2, [r3, #0]
 8024c34:	2a04      	cmp	r2, #4
 8024c36:	d000      	beq.n	8024c3a <CDC_Device_USBTask+0xa>
		{
		  CDC_Device_Flush(CDCInterfaceInfo);
		}
		#endif
	}
}
 8024c38:	4770      	bx	lr
	return status;
}

void CDC_Device_USBTask(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
	if ((USB_DeviceState == DEVICE_STATE_Configured) &&	(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS != 0))
 8024c3a:	6982      	ldr	r2, [r0, #24]
 8024c3c:	2a00      	cmp	r2, #0
 8024c3e:	d0fb      	beq.n	8024c38 <CDC_Device_USBTask+0x8>

	return status;
}

void CDC_Device_USBTask(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
 8024c40:	b470      	push	{r4, r5, r6}
	if ((USB_DeviceState == DEVICE_STATE_Configured) &&	(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS != 0))
	{
		#if !defined(NO_CLASS_DRIVER_AUTOFLUSH)
		Endpoint_SelectEndpoint(CDCInterfaceInfo->Config.DataINEndpoint.Address);
 8024c42:	7802      	ldrb	r2, [r0, #0]
	 *  \param[in] Address Endpoint address to select.
	 */
	static inline void Endpoint_SelectEndpoint(const uint8_t Address);
	static inline void Endpoint_SelectEndpoint(const uint8_t Address)
	{
		device.CurrentEndpoint = Address & ENDPOINT_EPNUM_MASK;
 8024c44:	4918      	ldr	r1, [pc, #96]	; (8024ca8 <CDC_Device_USBTask+0x78>)
 8024c46:	f002 040f 	and.w	r4, r2, #15
	 */
	static inline bool Endpoint_IsINReady(void);
	static inline bool Endpoint_IsINReady(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
		return ep->InInUse == 0 && ep->IsEnabled;
 8024c4a:	262c      	movs	r6, #44	; 0x2c
	 */
	static inline void Endpoint_SelectEndpoint(const uint8_t Address);
	static inline void Endpoint_SelectEndpoint(const uint8_t Address)
	{
		device.CurrentEndpoint = Address & ENDPOINT_EPNUM_MASK;
		device.CurrentDirection = (Address & ENDPOINT_DIR_MASK);
 8024c4c:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
	 */
	static inline bool Endpoint_IsINReady(void);
	static inline bool Endpoint_IsINReady(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
		return ep->InInUse == 0 && ep->IsEnabled;
 8024c50:	fb06 1504 	mla	r5, r6, r4, r1
	 *  \param[in] Address Endpoint address to select.
	 */
	static inline void Endpoint_SelectEndpoint(const uint8_t Address);
	static inline void Endpoint_SelectEndpoint(const uint8_t Address)
	{
		device.CurrentEndpoint = Address & ENDPOINT_EPNUM_MASK;
 8024c54:	f881 413c 	strb.w	r4, [r1, #316]	; 0x13c
		device.CurrentDirection = (Address & ENDPOINT_DIR_MASK);
 8024c58:	f881 213d 	strb.w	r2, [r1, #317]	; 0x13d
	 */
	static inline bool Endpoint_IsINReady(void);
	static inline bool Endpoint_IsINReady(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
		return ep->InInUse == 0 && ep->IsEnabled;
 8024c5c:	68aa      	ldr	r2, [r5, #8]
 8024c5e:	06d4      	lsls	r4, r2, #27
 8024c60:	d405      	bmi.n	8024c6e <CDC_Device_USBTask+0x3e>
 8024c62:	68aa      	ldr	r2, [r5, #8]
 8024c64:	0792      	lsls	r2, r2, #30
 8024c66:	d502      	bpl.n	8024c6e <CDC_Device_USBTask+0x3e>
}

uint8_t CDC_Device_Flush(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
	uint8_t status = 0;
	if ((USB_DeviceState == DEVICE_STATE_Configured) &&	(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS != 0))
 8024c68:	781b      	ldrb	r3, [r3, #0]
 8024c6a:	2b04      	cmp	r3, #4
 8024c6c:	d001      	beq.n	8024c72 <CDC_Device_USBTask+0x42>
		{
		  CDC_Device_Flush(CDCInterfaceInfo);
		}
		#endif
	}
}
 8024c6e:	bc70      	pop	{r4, r5, r6}
 8024c70:	4770      	bx	lr
}

uint8_t CDC_Device_Flush(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
	uint8_t status = 0;
	if ((USB_DeviceState == DEVICE_STATE_Configured) &&	(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS != 0))
 8024c72:	6983      	ldr	r3, [r0, #24]
 8024c74:	2b00      	cmp	r3, #0
 8024c76:	d0fa      	beq.n	8024c6e <CDC_Device_USBTask+0x3e>
	{
		Endpoint_SelectEndpoint(CDCInterfaceInfo->Config.DataINEndpoint.Address);
 8024c78:	7803      	ldrb	r3, [r0, #0]
	 *  \param[in] Address Endpoint address to select.
	 */
	static inline void Endpoint_SelectEndpoint(const uint8_t Address);
	static inline void Endpoint_SelectEndpoint(const uint8_t Address)
	{
		device.CurrentEndpoint = Address & ENDPOINT_EPNUM_MASK;
 8024c7a:	f003 020f 	and.w	r2, r3, #15
	 */
	static inline uint16_t Endpoint_BytesInEndpoint(void);
	static inline uint16_t Endpoint_BytesInEndpoint(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
		if (ep->Direction)
 8024c7e:	fb06 1602 	mla	r6, r6, r2, r1
	 */
	static inline void Endpoint_SelectEndpoint(const uint8_t Address);
	static inline void Endpoint_SelectEndpoint(const uint8_t Address)
	{
		device.CurrentEndpoint = Address & ENDPOINT_EPNUM_MASK;
		device.CurrentDirection = (Address & ENDPOINT_DIR_MASK);
 8024c82:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
	 *  \param[in] Address Endpoint address to select.
	 */
	static inline void Endpoint_SelectEndpoint(const uint8_t Address);
	static inline void Endpoint_SelectEndpoint(const uint8_t Address)
	{
		device.CurrentEndpoint = Address & ENDPOINT_EPNUM_MASK;
 8024c86:	f881 213c 	strb.w	r2, [r1, #316]	; 0x13c
		device.CurrentDirection = (Address & ENDPOINT_DIR_MASK);
 8024c8a:	f881 313d 	strb.w	r3, [r1, #317]	; 0x13d
	 */
	static inline uint16_t Endpoint_BytesInEndpoint(void);
	static inline uint16_t Endpoint_BytesInEndpoint(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
		if (ep->Direction)
 8024c8e:	7933      	ldrb	r3, [r6, #4]
 8024c90:	061b      	lsls	r3, r3, #24
			return (uint16_t)(ep->InBytesAvailable);
 8024c92:	bf4c      	ite	mi
 8024c94:	8bb3      	ldrhmi	r3, [r6, #28]
		else
			return (uint16_t)(ep->OutBytesAvailable);
 8024c96:	89b3      	ldrhpl	r3, [r6, #12]

		if (Endpoint_BytesInEndpoint())
 8024c98:	2b00      	cmp	r3, #0
 8024c9a:	d0e8      	beq.n	8024c6e <CDC_Device_USBTask+0x3e>
		{
		  CDC_Device_Flush(CDCInterfaceInfo);
		}
		#endif
	}
}
 8024c9c:	bc70      	pop	{r4, r5, r6}
	{
		Endpoint_SelectEndpoint(CDCInterfaceInfo->Config.DataINEndpoint.Address);

		if (Endpoint_BytesInEndpoint())
		{
			Endpoint_ClearIN();
 8024c9e:	f000 baeb 	b.w	8025278 <Endpoint_ClearIN>
 8024ca2:	bf00      	nop
 8024ca4:	1fff0389 	.word	0x1fff0389
 8024ca8:	1fff0594 	.word	0x1fff0594

08024cac <CDC_Device_SendData>:
uint8_t CDC_Device_SendData(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo,
                            const void* const Buffer,
                            const uint16_t Length)
{
	uint8_t status = 0;
	if ((USB_DeviceState == DEVICE_STATE_Configured) &&	(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS != 0))
 8024cac:	4b0c      	ldr	r3, [pc, #48]	; (8024ce0 <CDC_Device_SendData+0x34>)
 8024cae:	781b      	ldrb	r3, [r3, #0]
 8024cb0:	2b04      	cmp	r3, #4
 8024cb2:	d001      	beq.n	8024cb8 <CDC_Device_SendData+0xc>
	else
	{
		status = ENDPOINT_RWSTREAM_DeviceDisconnected;
	}
	return status;
}
 8024cb4:	2002      	movs	r0, #2
 8024cb6:	4770      	bx	lr
uint8_t CDC_Device_SendData(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo,
                            const void* const Buffer,
                            const uint16_t Length)
{
	uint8_t status = 0;
	if ((USB_DeviceState == DEVICE_STATE_Configured) &&	(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS != 0))
 8024cb8:	6983      	ldr	r3, [r0, #24]
 8024cba:	2b00      	cmp	r3, #0
 8024cbc:	d0fa      	beq.n	8024cb4 <CDC_Device_SendData+0x8>
}

uint8_t CDC_Device_SendData(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo,
                            const void* const Buffer,
                            const uint16_t Length)
{
 8024cbe:	b430      	push	{r4, r5}
	uint8_t status = 0;
	if ((USB_DeviceState == DEVICE_STATE_Configured) &&	(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS != 0))
	{

		Endpoint_SelectEndpoint(CDCInterfaceInfo->Config.DataINEndpoint.Address);
 8024cc0:	7803      	ldrb	r3, [r0, #0]
	 *  \param[in] Address Endpoint address to select.
	 */
	static inline void Endpoint_SelectEndpoint(const uint8_t Address);
	static inline void Endpoint_SelectEndpoint(const uint8_t Address)
	{
		device.CurrentEndpoint = Address & ENDPOINT_EPNUM_MASK;
 8024cc2:	4c08      	ldr	r4, [pc, #32]	; (8024ce4 <CDC_Device_SendData+0x38>)
 8024cc4:	f003 050f 	and.w	r5, r3, #15
		device.CurrentDirection = (Address & ENDPOINT_DIR_MASK);
 8024cc8:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
		status = Endpoint_Write_Stream_LE(Buffer, Length, NULL);
 8024ccc:	4608      	mov	r0, r1
	 *  \param[in] Address Endpoint address to select.
	 */
	static inline void Endpoint_SelectEndpoint(const uint8_t Address);
	static inline void Endpoint_SelectEndpoint(const uint8_t Address)
	{
		device.CurrentEndpoint = Address & ENDPOINT_EPNUM_MASK;
 8024cce:	f884 513c 	strb.w	r5, [r4, #316]	; 0x13c
 8024cd2:	4611      	mov	r1, r2
		device.CurrentDirection = (Address & ENDPOINT_DIR_MASK);
 8024cd4:	f884 313d 	strb.w	r3, [r4, #317]	; 0x13d
 8024cd8:	2200      	movs	r2, #0
	else
	{
		status = ENDPOINT_RWSTREAM_DeviceDisconnected;
	}
	return status;
}
 8024cda:	bc30      	pop	{r4, r5}
	uint8_t status = 0;
	if ((USB_DeviceState == DEVICE_STATE_Configured) &&	(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS != 0))
	{

		Endpoint_SelectEndpoint(CDCInterfaceInfo->Config.DataINEndpoint.Address);
		status = Endpoint_Write_Stream_LE(Buffer, Length, NULL);
 8024cdc:	f000 b9b4 	b.w	8025048 <Endpoint_Write_Stream_LE>
 8024ce0:	1fff0389 	.word	0x1fff0389
 8024ce4:	1fff0594 	.word	0x1fff0594

08024ce8 <CDC_Device_Flush>:
	return status;

}

uint8_t CDC_Device_Flush(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
 8024ce8:	b508      	push	{r3, lr}
	uint8_t status = 0;
	if ((USB_DeviceState == DEVICE_STATE_Configured) &&	(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS != 0))
 8024cea:	4b10      	ldr	r3, [pc, #64]	; (8024d2c <CDC_Device_Flush+0x44>)
 8024cec:	781b      	ldrb	r3, [r3, #0]
 8024cee:	2b04      	cmp	r3, #4
 8024cf0:	d001      	beq.n	8024cf6 <CDC_Device_Flush+0xe>

		status = ENDPOINT_READYWAIT_NoError;
	}
	else
	{
		status = ENDPOINT_RWSTREAM_DeviceDisconnected;
 8024cf2:	2002      	movs	r0, #2
	}

	return status;
}
 8024cf4:	bd08      	pop	{r3, pc}
}

uint8_t CDC_Device_Flush(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
	uint8_t status = 0;
	if ((USB_DeviceState == DEVICE_STATE_Configured) &&	(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS != 0))
 8024cf6:	6983      	ldr	r3, [r0, #24]
 8024cf8:	2b00      	cmp	r3, #0
 8024cfa:	d0fa      	beq.n	8024cf2 <CDC_Device_Flush+0xa>
	{
		Endpoint_SelectEndpoint(CDCInterfaceInfo->Config.DataINEndpoint.Address);
 8024cfc:	7803      	ldrb	r3, [r0, #0]
	 *  \param[in] Address Endpoint address to select.
	 */
	static inline void Endpoint_SelectEndpoint(const uint8_t Address);
	static inline void Endpoint_SelectEndpoint(const uint8_t Address)
	{
		device.CurrentEndpoint = Address & ENDPOINT_EPNUM_MASK;
 8024cfe:	490c      	ldr	r1, [pc, #48]	; (8024d30 <CDC_Device_Flush+0x48>)
 8024d00:	f003 000f 	and.w	r0, r3, #15
	 */
	static inline uint16_t Endpoint_BytesInEndpoint(void);
	static inline uint16_t Endpoint_BytesInEndpoint(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
		if (ep->Direction)
 8024d04:	222c      	movs	r2, #44	; 0x2c
 8024d06:	fb02 1200 	mla	r2, r2, r0, r1
	 */
	static inline void Endpoint_SelectEndpoint(const uint8_t Address);
	static inline void Endpoint_SelectEndpoint(const uint8_t Address)
	{
		device.CurrentEndpoint = Address & ENDPOINT_EPNUM_MASK;
		device.CurrentDirection = (Address & ENDPOINT_DIR_MASK);
 8024d0a:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
	 *  \param[in] Address Endpoint address to select.
	 */
	static inline void Endpoint_SelectEndpoint(const uint8_t Address);
	static inline void Endpoint_SelectEndpoint(const uint8_t Address)
	{
		device.CurrentEndpoint = Address & ENDPOINT_EPNUM_MASK;
 8024d0e:	f881 013c 	strb.w	r0, [r1, #316]	; 0x13c
		device.CurrentDirection = (Address & ENDPOINT_DIR_MASK);
 8024d12:	f881 313d 	strb.w	r3, [r1, #317]	; 0x13d
	 */
	static inline uint16_t Endpoint_BytesInEndpoint(void);
	static inline uint16_t Endpoint_BytesInEndpoint(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
		if (ep->Direction)
 8024d16:	7913      	ldrb	r3, [r2, #4]
 8024d18:	061b      	lsls	r3, r3, #24
			return (uint16_t)(ep->InBytesAvailable);
 8024d1a:	bf4c      	ite	mi
 8024d1c:	8b90      	ldrhmi	r0, [r2, #28]
		else
			return (uint16_t)(ep->OutBytesAvailable);
 8024d1e:	8990      	ldrhpl	r0, [r2, #12]

		if (Endpoint_BytesInEndpoint())
 8024d20:	2800      	cmp	r0, #0
 8024d22:	d0e7      	beq.n	8024cf4 <CDC_Device_Flush+0xc>
		{
			Endpoint_ClearIN();
 8024d24:	f000 faa8 	bl	8025278 <Endpoint_ClearIN>
 8024d28:	2000      	movs	r0, #0
 8024d2a:	bd08      	pop	{r3, pc}
 8024d2c:	1fff0389 	.word	0x1fff0389
 8024d30:	1fff0594 	.word	0x1fff0594

08024d34 <CDC_Device_BytesReceived>:

	return status;
}

uint16_t CDC_Device_BytesReceived(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
 8024d34:	b508      	push	{r3, lr}
	uint16_t bytes = 0;
	if ((USB_DeviceState == DEVICE_STATE_Configured) &&	(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS != 0))
 8024d36:	4b13      	ldr	r3, [pc, #76]	; (8024d84 <CDC_Device_BytesReceived+0x50>)
 8024d38:	781b      	ldrb	r3, [r3, #0]
 8024d3a:	2b04      	cmp	r3, #4
 8024d3c:	d001      	beq.n	8024d42 <CDC_Device_BytesReceived+0xe>
		if (Endpoint_IsOUTReceived())
		{
			if (!(Endpoint_BytesInEndpoint()))
			{
				Endpoint_ClearOUT();
				bytes = 0;
 8024d3e:	2000      	movs	r0, #0
			bytes = 0;
		}
	}

	return bytes;
}
 8024d40:	bd08      	pop	{r3, pc}
}

uint16_t CDC_Device_BytesReceived(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
	uint16_t bytes = 0;
	if ((USB_DeviceState == DEVICE_STATE_Configured) &&	(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS != 0))
 8024d42:	6983      	ldr	r3, [r0, #24]
 8024d44:	2b00      	cmp	r3, #0
 8024d46:	d0fa      	beq.n	8024d3e <CDC_Device_BytesReceived+0xa>
	{

		Endpoint_SelectEndpoint(CDCInterfaceInfo->Config.DataOUTEndpoint.Address);
 8024d48:	7982      	ldrb	r2, [r0, #6]
	 *  \param[in] Address Endpoint address to select.
	 */
	static inline void Endpoint_SelectEndpoint(const uint8_t Address);
	static inline void Endpoint_SelectEndpoint(const uint8_t Address)
	{
		device.CurrentEndpoint = Address & ENDPOINT_EPNUM_MASK;
 8024d4a:	490f      	ldr	r1, [pc, #60]	; (8024d88 <CDC_Device_BytesReceived+0x54>)
 8024d4c:	f002 000f 	and.w	r0, r2, #15
	 */
	static inline bool Endpoint_IsOUTReceived(void);
	static inline bool Endpoint_IsOUTReceived(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
		return ep->IsOutRecieved;
 8024d50:	232c      	movs	r3, #44	; 0x2c
	 */
	static inline void Endpoint_SelectEndpoint(const uint8_t Address);
	static inline void Endpoint_SelectEndpoint(const uint8_t Address)
	{
		device.CurrentEndpoint = Address & ENDPOINT_EPNUM_MASK;
		device.CurrentDirection = (Address & ENDPOINT_DIR_MASK);
 8024d52:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
	 */
	static inline bool Endpoint_IsOUTReceived(void);
	static inline bool Endpoint_IsOUTReceived(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
		return ep->IsOutRecieved;
 8024d56:	fb03 1300 	mla	r3, r3, r0, r1
	 */
	static inline void Endpoint_SelectEndpoint(const uint8_t Address);
	static inline void Endpoint_SelectEndpoint(const uint8_t Address)
	{
		device.CurrentEndpoint = Address & ENDPOINT_EPNUM_MASK;
		device.CurrentDirection = (Address & ENDPOINT_DIR_MASK);
 8024d5a:	f881 213d 	strb.w	r2, [r1, #317]	; 0x13d
	 *  \param[in] Address Endpoint address to select.
	 */
	static inline void Endpoint_SelectEndpoint(const uint8_t Address);
	static inline void Endpoint_SelectEndpoint(const uint8_t Address)
	{
		device.CurrentEndpoint = Address & ENDPOINT_EPNUM_MASK;
 8024d5e:	f881 013c 	strb.w	r0, [r1, #316]	; 0x13c
	 */
	static inline bool Endpoint_IsOUTReceived(void);
	static inline bool Endpoint_IsOUTReceived(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
		return ep->IsOutRecieved;
 8024d62:	689a      	ldr	r2, [r3, #8]

		if (Endpoint_IsOUTReceived())
 8024d64:	0691      	lsls	r1, r2, #26
 8024d66:	d5ea      	bpl.n	8024d3e <CDC_Device_BytesReceived+0xa>
	 */
	static inline uint16_t Endpoint_BytesInEndpoint(void);
	static inline uint16_t Endpoint_BytesInEndpoint(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
		if (ep->Direction)
 8024d68:	791a      	ldrb	r2, [r3, #4]
 8024d6a:	0612      	lsls	r2, r2, #24
 8024d6c:	d505      	bpl.n	8024d7a <CDC_Device_BytesReceived+0x46>
			return (uint16_t)(ep->InBytesAvailable);
 8024d6e:	8b98      	ldrh	r0, [r3, #28]
		{
			if (!(Endpoint_BytesInEndpoint()))
 8024d70:	2800      	cmp	r0, #0
 8024d72:	d1e5      	bne.n	8024d40 <CDC_Device_BytesReceived+0xc>
			{
				Endpoint_ClearOUT();
 8024d74:	f000 fa54 	bl	8025220 <Endpoint_ClearOUT>
 8024d78:	e7e1      	b.n	8024d3e <CDC_Device_BytesReceived+0xa>
		else
			return (uint16_t)(ep->OutBytesAvailable);
 8024d7a:	8998      	ldrh	r0, [r3, #12]

		Endpoint_SelectEndpoint(CDCInterfaceInfo->Config.DataOUTEndpoint.Address);

		if (Endpoint_IsOUTReceived())
		{
			if (!(Endpoint_BytesInEndpoint()))
 8024d7c:	2800      	cmp	r0, #0
 8024d7e:	d1df      	bne.n	8024d40 <CDC_Device_BytesReceived+0xc>
 8024d80:	e7f8      	b.n	8024d74 <CDC_Device_BytesReceived+0x40>
 8024d82:	bf00      	nop
 8024d84:	1fff0389 	.word	0x1fff0389
 8024d88:	1fff0594 	.word	0x1fff0594

08024d8c <USBD_VCOM_CDCClass_Event_LineEncodingChanged>:
 * as a parameter.*/
void USBD_VCOM_CDCClass_Event_LineEncodingChanged(USB_ClassInfo_CDC_Device_t* const cdc_interface_info)
{
  /*set here the global volatile flag(which can be polled from the top level application) to indicate
   * the event. */
  cdc_event_flags.line_encoding_event_flag = 1U;
 8024d8c:	4b01      	ldr	r3, [pc, #4]	; (8024d94 <USBD_VCOM_CDCClass_Event_LineEncodingChanged+0x8>)
 8024d8e:	2201      	movs	r2, #1
 8024d90:	701a      	strb	r2, [r3, #0]
 8024d92:	4770      	bx	lr
 8024d94:	1fff02e4 	.word	0x1fff02e4

08024d98 <USBD_VCOM_CDCClass_Event_ControlLineStateChanged>:
 * line states, such as DTR).The new control line states are available in the ControlLineStates.HostToDevice
 * value inside the CDC interface structure passed as a parameter. */
void USBD_VCOM_CDCClass_Event_ControlLineStateChanged(USB_ClassInfo_CDC_Device_t* const cdc_interface_info)
{
  /*set here the global volatile flag(which can be polled from the top level application) to indicate the event */
  cdc_event_flags.control_line_state_change_event_flag = 1U;
 8024d98:	4b01      	ldr	r3, [pc, #4]	; (8024da0 <USBD_VCOM_CDCClass_Event_ControlLineStateChanged+0x8>)
 8024d9a:	2201      	movs	r2, #1
 8024d9c:	705a      	strb	r2, [r3, #1]
 8024d9e:	4770      	bx	lr
 8024da0:	1fff02e4 	.word	0x1fff02e4

08024da4 <USBD_VCOM_CDCClass_Event_BreakSent>:
/*CDC class driver event for a send break request sent to the device from the host.
 * This is generally used to separate data or to indicate a special condition to the receiving device.*/
void USBD_VCOM_CDCClass_Event_BreakSent(USB_ClassInfo_CDC_Device_t* const cdc_interface_info,	const uint8_t duration)
{
  /*set here the global volatile flag(which can be polled from the top level application) to indicate the event */
  cdc_event_flags.break_event_flag = 1U;
 8024da4:	4b01      	ldr	r3, [pc, #4]	; (8024dac <USBD_VCOM_CDCClass_Event_BreakSent+0x8>)
 8024da6:	2201      	movs	r2, #1
 8024da8:	709a      	strb	r2, [r3, #2]
 8024daa:	4770      	bx	lr
 8024dac:	1fff02e4 	.word	0x1fff02e4

08024db0 <USBD_VCOM_Event_ConfigurationChanged>:

}

/* Event handler for the USB Configuration Changed event. */
void USBD_VCOM_Event_ConfigurationChanged(void)
{
 8024db0:	b508      	push	{r3, lr}
  USBD_SetEndpointBuffer(((uint8_t)CDC_IN_EP_MASK|(uint8_t)CDC_NOTIFICATION_EPNUM), notification_ep_buf, 
 8024db2:	2081      	movs	r0, #129	; 0x81
 8024db4:	490e      	ldr	r1, [pc, #56]	; (8024df0 <USBD_VCOM_Event_ConfigurationChanged+0x40>)
 8024db6:	2240      	movs	r2, #64	; 0x40
 8024db8:	f000 fff6 	bl	8025da8 <USBD_SetEndpointBuffer>
  (uint16_t)USB_FS_MAXPKT_SIZE);
  USBD_SetEndpointBuffer(((uint8_t)CDC_IN_EP_MASK|(uint8_t)CDC_TX_EPNUM), tx_ep_buf, (uint16_t)USB_FS_MAXPKT_SIZE);
 8024dbc:	2082      	movs	r0, #130	; 0x82
 8024dbe:	490d      	ldr	r1, [pc, #52]	; (8024df4 <USBD_VCOM_Event_ConfigurationChanged+0x44>)
 8024dc0:	2240      	movs	r2, #64	; 0x40
 8024dc2:	f000 fff1 	bl	8025da8 <USBD_SetEndpointBuffer>
  USBD_SetEndpointBuffer((CDC_RX_EPNUM), rx_ep_buf, (uint16_t)USB_FS_MAXPKT_SIZE);
 8024dc6:	2003      	movs	r0, #3
 8024dc8:	490b      	ldr	r1, [pc, #44]	; (8024df8 <USBD_VCOM_Event_ConfigurationChanged+0x48>)
 8024dca:	2240      	movs	r2, #64	; 0x40
 8024dcc:	f000 ffec 	bl	8025da8 <USBD_SetEndpointBuffer>
  if (true == CDC_Device_ConfigureEndpoints(&USBD_VCOM_cdc_interface))
 8024dd0:	480a      	ldr	r0, [pc, #40]	; (8024dfc <USBD_VCOM_Event_ConfigurationChanged+0x4c>)
 8024dd2:	f7ff ff03 	bl	8024bdc <CDC_Device_ConfigureEndpoints>
 8024dd6:	b148      	cbz	r0, 8024dec <USBD_VCOM_Event_ConfigurationChanged+0x3c>
  {
    device.IsConfigured = 1U;
 8024dd8:	4a09      	ldr	r2, [pc, #36]	; (8024e00 <USBD_VCOM_Event_ConfigurationChanged+0x50>)
    USB_DeviceState = (uint8_t)DEVICE_STATE_Configured;
 8024dda:	490a      	ldr	r1, [pc, #40]	; (8024e04 <USBD_VCOM_Event_ConfigurationChanged+0x54>)
  (uint16_t)USB_FS_MAXPKT_SIZE);
  USBD_SetEndpointBuffer(((uint8_t)CDC_IN_EP_MASK|(uint8_t)CDC_TX_EPNUM), tx_ep_buf, (uint16_t)USB_FS_MAXPKT_SIZE);
  USBD_SetEndpointBuffer((CDC_RX_EPNUM), rx_ep_buf, (uint16_t)USB_FS_MAXPKT_SIZE);
  if (true == CDC_Device_ConfigureEndpoints(&USBD_VCOM_cdc_interface))
  {
    device.IsConfigured = 1U;
 8024ddc:	f892 313e 	ldrb.w	r3, [r2, #318]	; 0x13e
    USB_DeviceState = (uint8_t)DEVICE_STATE_Configured;
 8024de0:	2004      	movs	r0, #4
  (uint16_t)USB_FS_MAXPKT_SIZE);
  USBD_SetEndpointBuffer(((uint8_t)CDC_IN_EP_MASK|(uint8_t)CDC_TX_EPNUM), tx_ep_buf, (uint16_t)USB_FS_MAXPKT_SIZE);
  USBD_SetEndpointBuffer((CDC_RX_EPNUM), rx_ep_buf, (uint16_t)USB_FS_MAXPKT_SIZE);
  if (true == CDC_Device_ConfigureEndpoints(&USBD_VCOM_cdc_interface))
  {
    device.IsConfigured = 1U;
 8024de2:	f043 0301 	orr.w	r3, r3, #1
 8024de6:	f882 313e 	strb.w	r3, [r2, #318]	; 0x13e
    USB_DeviceState = (uint8_t)DEVICE_STATE_Configured;
 8024dea:	7008      	strb	r0, [r1, #0]
 8024dec:	bd08      	pop	{r3, pc}
 8024dee:	bf00      	nop
 8024df0:	1fff02e8 	.word	0x1fff02e8
 8024df4:	1fff02a4 	.word	0x1fff02a4
 8024df8:	1fff0328 	.word	0x1fff0328
 8024dfc:	1fff0368 	.word	0x1fff0368
 8024e00:	1fff0594 	.word	0x1fff0594
 8024e04:	1fff0389 	.word	0x1fff0389

08024e08 <USBD_VCOM_Event_ControlRequest>:
}

/* Event handler for the USB Control Request reception event. */
void USBD_VCOM_Event_ControlRequest(void)
{
  CDC_Device_ProcessControlRequest(&USBD_VCOM_cdc_interface);
 8024e08:	4801      	ldr	r0, [pc, #4]	; (8024e10 <USBD_VCOM_Event_ControlRequest+0x8>)
 8024e0a:	f7ff be53 	b.w	8024ab4 <CDC_Device_ProcessControlRequest>
 8024e0e:	bf00      	nop
 8024e10:	1fff0368 	.word	0x1fff0368

08024e14 <USBD_VCOM_Event_Reset>:

/* Event handler for the USB reset event. */
void USBD_VCOM_Event_Reset(void)
{
  /*For self powered devices, reinitialize USB*/
  if (device.IsConfigured)
 8024e14:	492d      	ldr	r1, [pc, #180]	; (8024ecc <USBD_VCOM_Event_Reset+0xb8>)
 8024e16:	f891 213e 	ldrb.w	r2, [r1, #318]	; 0x13e
 8024e1a:	07d3      	lsls	r3, r2, #31
 8024e1c:	d400      	bmi.n	8024e20 <USBD_VCOM_Event_Reset+0xc>
 8024e1e:	4770      	bx	lr

  /*Register USB event call backs*/
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
 8024e20:	482b      	ldr	r0, [pc, #172]	; (8024ed0 <USBD_VCOM_Event_Reset+0xbc>)
  USBD_VCOM_STATUS_t status = USBD_VCOM_STATUS_SUCCESS;

  XMC_ASSERT("USBD_VCOM_Init: vcom_handle not valid", (vcom_handle != NULL));

  /*Initialize CDC interface*/
  USBD_VCOM_cdc_interface.Config.ControlInterfaceNumber = 0U;
 8024e22:	4b2c      	ldr	r3, [pc, #176]	; (8024ed4 <USBD_VCOM_Event_Reset+0xc0>)

  /*Register USB event call backs*/
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
 8024e24:	6800      	ldr	r0, [r0, #0]
  CDC_Device_ProcessControlRequest(&USBD_VCOM_cdc_interface);
}

/* Event handler for the USB reset event. */
void USBD_VCOM_Event_Reset(void)
{
 8024e26:	e92d 4ef0 	stmdb	sp!, {r4, r5, r6, r7, r9, sl, fp, lr}
  /*For self powered devices, reinitialize USB*/
  if (device.IsConfigured)
  {
    device.IsConfigured = 0U;
 8024e2a:	f36f 0200 	bfc	r2, #0, #1
  USBD_VCOM_STATUS_t status = USBD_VCOM_STATUS_SUCCESS;

  XMC_ASSERT("USBD_VCOM_Init: vcom_handle not valid", (vcom_handle != NULL));

  /*Initialize CDC interface*/
  USBD_VCOM_cdc_interface.Config.ControlInterfaceNumber = 0U;
 8024e2e:	f04f 0a00 	mov.w	sl, #0
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Address = (ENDPOINT_DIR_IN | CDC_TX_EPNUM);
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Address = CDC_RX_EPNUM;
 8024e32:	f04f 0903 	mov.w	r9, #3

  /*Register USB event call backs*/
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
 8024e36:	4c28      	ldr	r4, [pc, #160]	; (8024ed8 <USBD_VCOM_Event_Reset+0xc4>)
void USBD_VCOM_Event_Reset(void)
{
  /*For self powered devices, reinitialize USB*/
  if (device.IsConfigured)
  {
    device.IsConfigured = 0U;
 8024e38:	f881 213e 	strb.w	r2, [r1, #318]	; 0x13e
  USBD_VCOM_STATUS_t status = USBD_VCOM_STATUS_SUCCESS;

  XMC_ASSERT("USBD_VCOM_Init: vcom_handle not valid", (vcom_handle != NULL));

  /*Initialize CDC interface*/
  USBD_VCOM_cdc_interface.Config.ControlInterfaceNumber = 0U;
 8024e3c:	f883 a012 	strb.w	sl, [r3, #18]
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Address = (ENDPOINT_DIR_IN | CDC_NOTIFICATION_EPNUM);
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Size = CDC_NOTIFICATION_EPSIZE;
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Type = (uint8_t)EP_TYPE_INTERRUPT;
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Banks = 0U;
 8024e40:	f883 a011 	strb.w	sl, [r3, #17]
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Address = (ENDPOINT_DIR_IN | CDC_NOTIFICATION_EPNUM);
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Size = CDC_NOTIFICATION_EPSIZE;
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Type = (uint8_t)EP_TYPE_INTERRUPT;
 8024e44:	f883 9010 	strb.w	r9, [r3, #16]

  /*Register USB event call backs*/
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
 8024e48:	6902      	ldr	r2, [r0, #16]
    USBD_handle->event_cb->config_changed = event_callback->config_changed;
    USBD_handle->event_cb->connect = event_callback->connect;
    USBD_handle->event_cb->control_request = event_callback->control_request;
    USBD_handle->event_cb->disconnect = event_callback->disconnect;
    USBD_handle->event_cb->get_descriptor = event_callback->get_descriptor;
 8024e4a:	6966      	ldr	r6, [r4, #20]
 8024e4c:	6156      	str	r6, [r2, #20]
    USBD_handle->event_cb->suspend = event_callback->suspend;
 8024e4e:	69e6      	ldr	r6, [r4, #28]
 8024e50:	61d6      	str	r6, [r2, #28]
    USBD_handle->event_cb->wakeup = event_callback->wakeup;
 8024e52:	69a6      	ldr	r6, [r4, #24]
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Address = CDC_RX_EPNUM;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Banks = 0U;
 8024e54:	f883 a00b 	strb.w	sl, [r3, #11]
  CDC_Device_ProcessControlRequest(&USBD_VCOM_cdc_interface);
}

/* Event handler for the USB reset event. */
void USBD_VCOM_Event_Reset(void)
{
 8024e58:	b082      	sub	sp, #8
  /*Initialize CDC interface*/
  USBD_VCOM_cdc_interface.Config.ControlInterfaceNumber = 0U;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Address = (ENDPOINT_DIR_IN | CDC_TX_EPNUM);
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Banks = 0U;
 8024e5a:	f883 a005 	strb.w	sl, [r3, #5]
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Address = CDC_RX_EPNUM;
 8024e5e:	f883 9006 	strb.w	r9, [r3, #6]
    USBD_handle->event_cb->connect = event_callback->connect;
    USBD_handle->event_cb->control_request = event_callback->control_request;
    USBD_handle->event_cb->disconnect = event_callback->disconnect;
    USBD_handle->event_cb->get_descriptor = event_callback->get_descriptor;
    USBD_handle->event_cb->suspend = event_callback->suspend;
    USBD_handle->event_cb->wakeup = event_callback->wakeup;
 8024e62:	6196      	str	r6, [r2, #24]
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Address = CDC_RX_EPNUM;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Address = (ENDPOINT_DIR_IN | CDC_NOTIFICATION_EPNUM);
 8024e64:	f04f 0a81 	mov.w	sl, #129	; 0x81

  /*Register USB event call backs*/
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
 8024e68:	6926      	ldr	r6, [r4, #16]
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Address = CDC_RX_EPNUM;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Address = (ENDPOINT_DIR_IN | CDC_NOTIFICATION_EPNUM);
 8024e6a:	f883 a00c 	strb.w	sl, [r3, #12]
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Size = CDC_NOTIFICATION_EPSIZE;
 8024e6e:	f04f 0908 	mov.w	r9, #8
 8024e72:	f8a3 900e 	strh.w	r9, [r3, #14]
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
    USBD_handle->event_cb->config_changed = event_callback->config_changed;
    USBD_handle->event_cb->connect = event_callback->connect;
 8024e76:	6821      	ldr	r1, [r4, #0]
  /*Register USB event call backs*/
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
    USBD_handle->event_cb->config_changed = event_callback->config_changed;
 8024e78:	68a7      	ldr	r7, [r4, #8]
    USBD_handle->event_cb->connect = event_callback->connect;
    USBD_handle->event_cb->control_request = event_callback->control_request;
 8024e7a:	68e5      	ldr	r5, [r4, #12]

  /*Register USB event call backs*/
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
 8024e7c:	6116      	str	r6, [r2, #16]
  XMC_ASSERT("USBD_VCOM_Init: vcom_handle not valid", (vcom_handle != NULL));

  /*Initialize CDC interface*/
  USBD_VCOM_cdc_interface.Config.ControlInterfaceNumber = 0U;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Address = (ENDPOINT_DIR_IN | CDC_TX_EPNUM);
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Size = CDC_TXRX_EPSIZE;
 8024e7e:	f04f 0b40 	mov.w	fp, #64	; 0x40
    USBD_handle->event_cb->control_request = event_callback->control_request;
    USBD_handle->event_cb->disconnect = event_callback->disconnect;
    USBD_handle->event_cb->get_descriptor = event_callback->get_descriptor;
    USBD_handle->event_cb->suspend = event_callback->suspend;
    USBD_handle->event_cb->wakeup = event_callback->wakeup;
    USBD_handle->event_cb->start_of_frame = event_callback->start_of_frame;
 8024e82:	6a26      	ldr	r6, [r4, #32]
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Address = (ENDPOINT_DIR_IN | CDC_TX_EPNUM);
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Address = CDC_RX_EPNUM;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Size = CDC_TXRX_EPSIZE;
 8024e84:	f8a3 b008 	strh.w	fp, [r3, #8]

  /*Initialize CDC interface*/
  USBD_VCOM_cdc_interface.Config.ControlInterfaceNumber = 0U;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Address = (ENDPOINT_DIR_IN | CDC_TX_EPNUM);
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Type = (uint8_t)EP_TYPE_BULK;
 8024e88:	f04f 0a02 	mov.w	sl, #2

  XMC_ASSERT("USBD_VCOM_Init: vcom_handle not valid", (vcom_handle != NULL));

  /*Initialize CDC interface*/
  USBD_VCOM_cdc_interface.Config.ControlInterfaceNumber = 0U;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Address = (ENDPOINT_DIR_IN | CDC_TX_EPNUM);
 8024e8c:	f04f 0982 	mov.w	r9, #130	; 0x82
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Address = CDC_RX_EPNUM;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Type = (uint8_t)EP_TYPE_BULK;
 8024e90:	f883 a00a 	strb.w	sl, [r3, #10]
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
    USBD_handle->event_cb->config_changed = event_callback->config_changed;
    USBD_handle->event_cb->connect = event_callback->connect;
 8024e94:	9101      	str	r1, [sp, #4]
  XMC_ASSERT("USBD_VCOM_Init: vcom_handle not valid", (vcom_handle != NULL));

  /*Initialize CDC interface*/
  USBD_VCOM_cdc_interface.Config.ControlInterfaceNumber = 0U;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Address = (ENDPOINT_DIR_IN | CDC_TX_EPNUM);
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Size = CDC_TXRX_EPSIZE;
 8024e96:	f8a3 b002 	strh.w	fp, [r3, #2]
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
    USBD_handle->event_cb->config_changed = event_callback->config_changed;
    USBD_handle->event_cb->connect = event_callback->connect;
    USBD_handle->event_cb->control_request = event_callback->control_request;
    USBD_handle->event_cb->disconnect = event_callback->disconnect;
 8024e9a:	6861      	ldr	r1, [r4, #4]

  /*Initialize CDC interface*/
  USBD_VCOM_cdc_interface.Config.ControlInterfaceNumber = 0U;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Address = (ENDPOINT_DIR_IN | CDC_TX_EPNUM);
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Type = (uint8_t)EP_TYPE_BULK;
 8024e9c:	f883 a004 	strb.w	sl, [r3, #4]

  XMC_ASSERT("USBD_VCOM_Init: vcom_handle not valid", (vcom_handle != NULL));

  /*Initialize CDC interface*/
  USBD_VCOM_cdc_interface.Config.ControlInterfaceNumber = 0U;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Address = (ENDPOINT_DIR_IN | CDC_TX_EPNUM);
 8024ea0:	f883 9000 	strb.w	r9, [r3]
    USBD_handle->event_cb->control_request = event_callback->control_request;
    USBD_handle->event_cb->disconnect = event_callback->disconnect;
    USBD_handle->event_cb->get_descriptor = event_callback->get_descriptor;
    USBD_handle->event_cb->suspend = event_callback->suspend;
    USBD_handle->event_cb->wakeup = event_callback->wakeup;
    USBD_handle->event_cb->start_of_frame = event_callback->start_of_frame;
 8024ea4:	6216      	str	r6, [r2, #32]
  /*Register USB event call backs*/
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
    USBD_handle->event_cb->config_changed = event_callback->config_changed;
 8024ea6:	6097      	str	r7, [r2, #8]
    USBD_handle->event_cb->connect = event_callback->connect;
    USBD_handle->event_cb->control_request = event_callback->control_request;
 8024ea8:	60d5      	str	r5, [r2, #12]
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
    USBD_handle->event_cb->config_changed = event_callback->config_changed;
    USBD_handle->event_cb->connect = event_callback->connect;
 8024eaa:	9b01      	ldr	r3, [sp, #4]
 8024eac:	6013      	str	r3, [r2, #0]
    USBD_handle->event_cb->disconnect = event_callback->disconnect;
    USBD_handle->event_cb->get_descriptor = event_callback->get_descriptor;
    USBD_handle->event_cb->suspend = event_callback->suspend;
    USBD_handle->event_cb->wakeup = event_callback->wakeup;
    USBD_handle->event_cb->start_of_frame = event_callback->start_of_frame;
    USBD_handle->event_cb->reset = event_callback->reset;
 8024eae:	6a63      	ldr	r3, [r4, #36]	; 0x24
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
    USBD_handle->event_cb->config_changed = event_callback->config_changed;
    USBD_handle->event_cb->connect = event_callback->connect;
    USBD_handle->event_cb->control_request = event_callback->control_request;
    USBD_handle->event_cb->disconnect = event_callback->disconnect;
 8024eb0:	6051      	str	r1, [r2, #4]
    USBD_handle->event_cb->get_descriptor = event_callback->get_descriptor;
    USBD_handle->event_cb->suspend = event_callback->suspend;
    USBD_handle->event_cb->wakeup = event_callback->wakeup;
    USBD_handle->event_cb->start_of_frame = event_callback->start_of_frame;
    USBD_handle->event_cb->reset = event_callback->reset;
 8024eb2:	6253      	str	r3, [r2, #36]	; 0x24
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Banks = 0U;

  /*Register the required USB events*/
  if (USBD_VCOM_STATUS_SUCCESS == USBD_VCOM_Register_USBEvent_CB(&usbd_vcom_events))
  {
    if (USBD_VCOM_STATUS_SUCCESS != (USBD_VCOM_STATUS_t)USBD_Init(USBD_handle))
 8024eb4:	f000 fee2 	bl	8025c7c <USBD_Init>
 8024eb8:	b110      	cbz	r0, 8024ec0 <USBD_VCOM_Event_Reset+0xac>
      if (USBD_VCOM_STATUS_SUCCESS != USBD_VCOM_Connect())
      {
      }
    }
  }
}
 8024eba:	b002      	add	sp, #8
 8024ebc:	e8bd 8ef0 	ldmia.w	sp!, {r4, r5, r6, r7, r9, sl, fp, pc}
 8024ec0:	b002      	add	sp, #8
 8024ec2:	e8bd 4ef0 	ldmia.w	sp!, {r4, r5, r6, r7, r9, sl, fp, lr}
}

/*The API to connect the VCOM device to USB host*/
USBD_VCOM_STATUS_t USBD_VCOM_Connect(void)
{
  return (USBD_VCOM_STATUS_t)USBD_Connect();
 8024ec6:	f000 bf63 	b.w	8025d90 <USBD_Connect>
 8024eca:	bf00      	nop
 8024ecc:	1fff0594 	.word	0x1fff0594
 8024ed0:	1ffe9118 	.word	0x1ffe9118
 8024ed4:	1fff0368 	.word	0x1fff0368
 8024ed8:	1ffe90f0 	.word	0x1ffe90f0

08024edc <USBD_VCOM_Init>:

  /*Register USB event call backs*/
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
 8024edc:	4a26      	ldr	r2, [pc, #152]	; (8024f78 <USBD_VCOM_Init+0x9c>)
  USBD_VCOM_STATUS_t status = USBD_VCOM_STATUS_SUCCESS;

  XMC_ASSERT("USBD_VCOM_Init: vcom_handle not valid", (vcom_handle != NULL));

  /*Initialize CDC interface*/
  USBD_VCOM_cdc_interface.Config.ControlInterfaceNumber = 0U;
 8024ede:	4b27      	ldr	r3, [pc, #156]	; (8024f7c <USBD_VCOM_Init+0xa0>)

  /*Register USB event call backs*/
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
 8024ee0:	6810      	ldr	r0, [r2, #0]
 8024ee2:	4927      	ldr	r1, [pc, #156]	; (8024f80 <USBD_VCOM_Init+0xa4>)
}


/*The function initializes the USB core layer and register USB event call backs. */
USBD_VCOM_STATUS_t USBD_VCOM_Init(USBD_VCOM_t *vcom_handle)
{
 8024ee4:	e92d 4ef0 	stmdb	sp!, {r4, r5, r6, r7, r9, sl, fp, lr}
  USBD_VCOM_STATUS_t status = USBD_VCOM_STATUS_SUCCESS;

  XMC_ASSERT("USBD_VCOM_Init: vcom_handle not valid", (vcom_handle != NULL));

  /*Initialize CDC interface*/
  USBD_VCOM_cdc_interface.Config.ControlInterfaceNumber = 0U;
 8024ee8:	f04f 0a00 	mov.w	sl, #0
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Address = (ENDPOINT_DIR_IN | CDC_TX_EPNUM);
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Address = CDC_RX_EPNUM;
 8024eec:	f04f 0903 	mov.w	r9, #3
  USBD_VCOM_STATUS_t status = USBD_VCOM_STATUS_SUCCESS;

  XMC_ASSERT("USBD_VCOM_Init: vcom_handle not valid", (vcom_handle != NULL));

  /*Initialize CDC interface*/
  USBD_VCOM_cdc_interface.Config.ControlInterfaceNumber = 0U;
 8024ef0:	f883 a012 	strb.w	sl, [r3, #18]
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Address = (ENDPOINT_DIR_IN | CDC_NOTIFICATION_EPNUM);
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Size = CDC_NOTIFICATION_EPSIZE;
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Type = (uint8_t)EP_TYPE_INTERRUPT;
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Banks = 0U;
 8024ef4:	f883 a011 	strb.w	sl, [r3, #17]
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Address = (ENDPOINT_DIR_IN | CDC_NOTIFICATION_EPNUM);
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Size = CDC_NOTIFICATION_EPSIZE;
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Type = (uint8_t)EP_TYPE_INTERRUPT;
 8024ef8:	f883 9010 	strb.w	r9, [r3, #16]

  /*Register USB event call backs*/
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
 8024efc:	6902      	ldr	r2, [r0, #16]
    USBD_handle->event_cb->config_changed = event_callback->config_changed;
    USBD_handle->event_cb->connect = event_callback->connect;
    USBD_handle->event_cb->control_request = event_callback->control_request;
    USBD_handle->event_cb->disconnect = event_callback->disconnect;
    USBD_handle->event_cb->get_descriptor = event_callback->get_descriptor;
 8024efe:	694e      	ldr	r6, [r1, #20]
 8024f00:	6156      	str	r6, [r2, #20]
    USBD_handle->event_cb->suspend = event_callback->suspend;
 8024f02:	69ce      	ldr	r6, [r1, #28]
 8024f04:	61d6      	str	r6, [r2, #28]
}


/*The function initializes the USB core layer and register USB event call backs. */
USBD_VCOM_STATUS_t USBD_VCOM_Init(USBD_VCOM_t *vcom_handle)
{
 8024f06:	b082      	sub	sp, #8
    USBD_handle->event_cb->connect = event_callback->connect;
    USBD_handle->event_cb->control_request = event_callback->control_request;
    USBD_handle->event_cb->disconnect = event_callback->disconnect;
    USBD_handle->event_cb->get_descriptor = event_callback->get_descriptor;
    USBD_handle->event_cb->suspend = event_callback->suspend;
    USBD_handle->event_cb->wakeup = event_callback->wakeup;
 8024f08:	698e      	ldr	r6, [r1, #24]
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
    USBD_handle->event_cb->config_changed = event_callback->config_changed;
    USBD_handle->event_cb->connect = event_callback->connect;
 8024f0a:	680c      	ldr	r4, [r1, #0]
    USBD_handle->event_cb->control_request = event_callback->control_request;
    USBD_handle->event_cb->disconnect = event_callback->disconnect;
    USBD_handle->event_cb->get_descriptor = event_callback->get_descriptor;
    USBD_handle->event_cb->suspend = event_callback->suspend;
    USBD_handle->event_cb->wakeup = event_callback->wakeup;
 8024f0c:	6196      	str	r6, [r2, #24]
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Address = CDC_RX_EPNUM;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Banks = 0U;
 8024f0e:	f883 a00b 	strb.w	sl, [r3, #11]

  /*Register USB event call backs*/
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
 8024f12:	690e      	ldr	r6, [r1, #16]
  /*Initialize CDC interface*/
  USBD_VCOM_cdc_interface.Config.ControlInterfaceNumber = 0U;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Address = (ENDPOINT_DIR_IN | CDC_TX_EPNUM);
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Banks = 0U;
 8024f14:	f883 a005 	strb.w	sl, [r3, #5]
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Address = CDC_RX_EPNUM;
 8024f18:	f883 9006 	strb.w	r9, [r3, #6]
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Address = (ENDPOINT_DIR_IN | CDC_NOTIFICATION_EPNUM);
 8024f1c:	f04f 0a81 	mov.w	sl, #129	; 0x81
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Size = CDC_NOTIFICATION_EPSIZE;
 8024f20:	f04f 0908 	mov.w	r9, #8
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
    USBD_handle->event_cb->config_changed = event_callback->config_changed;
    USBD_handle->event_cb->connect = event_callback->connect;
    USBD_handle->event_cb->control_request = event_callback->control_request;
 8024f24:	68cd      	ldr	r5, [r1, #12]
  /*Register USB event call backs*/
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
    USBD_handle->event_cb->config_changed = event_callback->config_changed;
 8024f26:	688f      	ldr	r7, [r1, #8]

  /*Register USB event call backs*/
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
 8024f28:	6116      	str	r6, [r2, #16]
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Address = CDC_RX_EPNUM;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Address = (ENDPOINT_DIR_IN | CDC_NOTIFICATION_EPNUM);
 8024f2a:	f883 a00c 	strb.w	sl, [r3, #12]
    USBD_handle->event_cb->control_request = event_callback->control_request;
    USBD_handle->event_cb->disconnect = event_callback->disconnect;
    USBD_handle->event_cb->get_descriptor = event_callback->get_descriptor;
    USBD_handle->event_cb->suspend = event_callback->suspend;
    USBD_handle->event_cb->wakeup = event_callback->wakeup;
    USBD_handle->event_cb->start_of_frame = event_callback->start_of_frame;
 8024f2e:	6a0e      	ldr	r6, [r1, #32]
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Address = CDC_RX_EPNUM;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Address = (ENDPOINT_DIR_IN | CDC_NOTIFICATION_EPNUM);
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Size = CDC_NOTIFICATION_EPSIZE;
 8024f30:	f8a3 900e 	strh.w	r9, [r3, #14]
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
    USBD_handle->event_cb->config_changed = event_callback->config_changed;
    USBD_handle->event_cb->connect = event_callback->connect;
 8024f34:	9401      	str	r4, [sp, #4]
  XMC_ASSERT("USBD_VCOM_Init: vcom_handle not valid", (vcom_handle != NULL));

  /*Initialize CDC interface*/
  USBD_VCOM_cdc_interface.Config.ControlInterfaceNumber = 0U;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Address = (ENDPOINT_DIR_IN | CDC_TX_EPNUM);
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Size = CDC_TXRX_EPSIZE;
 8024f36:	f04f 0b40 	mov.w	fp, #64	; 0x40
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Type = (uint8_t)EP_TYPE_BULK;
 8024f3a:	f04f 0a02 	mov.w	sl, #2

  XMC_ASSERT("USBD_VCOM_Init: vcom_handle not valid", (vcom_handle != NULL));

  /*Initialize CDC interface*/
  USBD_VCOM_cdc_interface.Config.ControlInterfaceNumber = 0U;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Address = (ENDPOINT_DIR_IN | CDC_TX_EPNUM);
 8024f3e:	f04f 0982 	mov.w	r9, #130	; 0x82
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
    USBD_handle->event_cb->config_changed = event_callback->config_changed;
    USBD_handle->event_cb->connect = event_callback->connect;
    USBD_handle->event_cb->control_request = event_callback->control_request;
    USBD_handle->event_cb->disconnect = event_callback->disconnect;
 8024f42:	684c      	ldr	r4, [r1, #4]
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Address = (ENDPOINT_DIR_IN | CDC_TX_EPNUM);
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Address = CDC_RX_EPNUM;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Size = CDC_TXRX_EPSIZE;
 8024f44:	f8a3 b008 	strh.w	fp, [r3, #8]
    USBD_handle->event_cb->control_request = event_callback->control_request;
    USBD_handle->event_cb->disconnect = event_callback->disconnect;
    USBD_handle->event_cb->get_descriptor = event_callback->get_descriptor;
    USBD_handle->event_cb->suspend = event_callback->suspend;
    USBD_handle->event_cb->wakeup = event_callback->wakeup;
    USBD_handle->event_cb->start_of_frame = event_callback->start_of_frame;
 8024f48:	6216      	str	r6, [r2, #32]
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Address = CDC_RX_EPNUM;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Type = (uint8_t)EP_TYPE_BULK;
 8024f4a:	f883 a00a 	strb.w	sl, [r3, #10]
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
    USBD_handle->event_cb->config_changed = event_callback->config_changed;
    USBD_handle->event_cb->connect = event_callback->connect;
    USBD_handle->event_cb->control_request = event_callback->control_request;
 8024f4e:	60d5      	str	r5, [r2, #12]
  /*Register USB event call backs*/
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
    USBD_handle->event_cb->config_changed = event_callback->config_changed;
 8024f50:	6097      	str	r7, [r2, #8]
  XMC_ASSERT("USBD_VCOM_Init: vcom_handle not valid", (vcom_handle != NULL));

  /*Initialize CDC interface*/
  USBD_VCOM_cdc_interface.Config.ControlInterfaceNumber = 0U;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Address = (ENDPOINT_DIR_IN | CDC_TX_EPNUM);
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Size = CDC_TXRX_EPSIZE;
 8024f52:	f8a3 b002 	strh.w	fp, [r3, #2]
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Type = (uint8_t)EP_TYPE_BULK;
 8024f56:	f883 a004 	strb.w	sl, [r3, #4]

  XMC_ASSERT("USBD_VCOM_Init: vcom_handle not valid", (vcom_handle != NULL));

  /*Initialize CDC interface*/
  USBD_VCOM_cdc_interface.Config.ControlInterfaceNumber = 0U;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Address = (ENDPOINT_DIR_IN | CDC_TX_EPNUM);
 8024f5a:	f883 9000 	strb.w	r9, [r3]
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
    USBD_handle->event_cb->config_changed = event_callback->config_changed;
    USBD_handle->event_cb->connect = event_callback->connect;
 8024f5e:	9b01      	ldr	r3, [sp, #4]
    USBD_handle->event_cb->control_request = event_callback->control_request;
    USBD_handle->event_cb->disconnect = event_callback->disconnect;
 8024f60:	e882 0018 	stmia.w	r2, {r3, r4}
    USBD_handle->event_cb->get_descriptor = event_callback->get_descriptor;
    USBD_handle->event_cb->suspend = event_callback->suspend;
    USBD_handle->event_cb->wakeup = event_callback->wakeup;
    USBD_handle->event_cb->start_of_frame = event_callback->start_of_frame;
    USBD_handle->event_cb->reset = event_callback->reset;
 8024f64:	6a4b      	ldr	r3, [r1, #36]	; 0x24
 8024f66:	6253      	str	r3, [r2, #36]	; 0x24
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Banks = 0U;

  /*Register the required USB events*/
  if (USBD_VCOM_STATUS_SUCCESS == USBD_VCOM_Register_USBEvent_CB(&usbd_vcom_events))
  {
    if (USBD_VCOM_STATUS_SUCCESS != (USBD_VCOM_STATUS_t)USBD_Init(USBD_handle))
 8024f68:	f000 fe88 	bl	8025c7c <USBD_Init>
  }
  /*Remove the compilation warning*/
  (void)vcom_handle;

  return status;
}
 8024f6c:	3000      	adds	r0, #0
 8024f6e:	bf18      	it	ne
 8024f70:	2001      	movne	r0, #1
 8024f72:	b002      	add	sp, #8
 8024f74:	e8bd 8ef0 	ldmia.w	sp!, {r4, r5, r6, r7, r9, sl, fp, pc}
 8024f78:	1ffe9118 	.word	0x1ffe9118
 8024f7c:	1fff0368 	.word	0x1fff0368
 8024f80:	1ffe90f0 	.word	0x1ffe90f0

08024f84 <USBD_VCOM_IsEnumDone>:

/*The function check if the enumeration has been done already. */
uint32_t USBD_VCOM_IsEnumDone(void)
{
 8024f84:	b508      	push	{r3, lr}
  return (uint32_t)(USBD_IsEnumDone() && (USB_DeviceState == (uint8_t)DEVICE_STATE_Configured));
 8024f86:	f000 ff09 	bl	8025d9c <USBD_IsEnumDone>
 8024f8a:	b130      	cbz	r0, 8024f9a <USBD_VCOM_IsEnumDone+0x16>
 8024f8c:	4b03      	ldr	r3, [pc, #12]	; (8024f9c <USBD_VCOM_IsEnumDone+0x18>)
 8024f8e:	7818      	ldrb	r0, [r3, #0]
 8024f90:	f1a0 0004 	sub.w	r0, r0, #4
 8024f94:	fab0 f080 	clz	r0, r0
 8024f98:	0940      	lsrs	r0, r0, #5
}
 8024f9a:	bd08      	pop	{r3, pc}
 8024f9c:	1fff0389 	.word	0x1fff0389

08024fa0 <USBD_VCOM_SendData>:
  return status;
}

/* This function sends multiple bytes to the USB host. */
USBD_VCOM_STATUS_t USBD_VCOM_SendData(const int8_t* const data_buffer, const uint16_t length)
{
 8024fa0:	b510      	push	{r4, lr}
  USBD_VCOM_STATUS_t status = USBD_VCOM_STATUS_SUCCESS;

  if ((length == 0U) || (data_buffer == NULL))
 8024fa2:	b911      	cbnz	r1, 8024faa <USBD_VCOM_SendData+0xa>
  {
    status = USBD_VCOM_STATUS_CDC_ERROR;		  
 8024fa4:	2406      	movs	r4, #6
    {
      status = USBD_VCOM_STATUS_CDC_ERROR;
    }
  }
  return status;
}
 8024fa6:	4620      	mov	r0, r4
 8024fa8:	bd10      	pop	{r4, pc}
/* This function sends multiple bytes to the USB host. */
USBD_VCOM_STATUS_t USBD_VCOM_SendData(const int8_t* const data_buffer, const uint16_t length)
{
  USBD_VCOM_STATUS_t status = USBD_VCOM_STATUS_SUCCESS;

  if ((length == 0U) || (data_buffer == NULL))
 8024faa:	2800      	cmp	r0, #0
 8024fac:	d0fa      	beq.n	8024fa4 <USBD_VCOM_SendData+0x4>
 8024fae:	460a      	mov	r2, r1
 8024fb0:	4601      	mov	r1, r0
  }
  else
  {
    /* Send data to USB host.*/
    if ((uint8_t)ENDPOINT_RWSTREAM_NoError !=
        CDC_Device_SendData(&USBD_VCOM_cdc_interface, (const int8_t *)data_buffer, length))
 8024fb2:	4807      	ldr	r0, [pc, #28]	; (8024fd0 <USBD_VCOM_SendData+0x30>)
 8024fb4:	f7ff fe7a 	bl	8024cac <CDC_Device_SendData>
    status = USBD_VCOM_STATUS_CDC_ERROR;		  
  }
  else
  {
    /* Send data to USB host.*/
    if ((uint8_t)ENDPOINT_RWSTREAM_NoError !=
 8024fb8:	2800      	cmp	r0, #0
        CDC_Device_SendData(&USBD_VCOM_cdc_interface, (const int8_t *)data_buffer, length))
    {
      status = USBD_VCOM_STATUS_CDC_ERROR;
    }
    if ((uint8_t)ENDPOINT_READYWAIT_NoError != CDC_Device_Flush(&USBD_VCOM_cdc_interface))
 8024fba:	4805      	ldr	r0, [pc, #20]	; (8024fd0 <USBD_VCOM_SendData+0x30>)
  {
    /* Send data to USB host.*/
    if ((uint8_t)ENDPOINT_RWSTREAM_NoError !=
        CDC_Device_SendData(&USBD_VCOM_cdc_interface, (const int8_t *)data_buffer, length))
    {
      status = USBD_VCOM_STATUS_CDC_ERROR;
 8024fbc:	bf14      	ite	ne
 8024fbe:	2406      	movne	r4, #6
 8024fc0:	2400      	moveq	r4, #0
    }
    if ((uint8_t)ENDPOINT_READYWAIT_NoError != CDC_Device_Flush(&USBD_VCOM_cdc_interface))
 8024fc2:	f7ff fe91 	bl	8024ce8 <CDC_Device_Flush>
 8024fc6:	2800      	cmp	r0, #0
    {
      status = USBD_VCOM_STATUS_CDC_ERROR;
 8024fc8:	bf18      	it	ne
 8024fca:	2406      	movne	r4, #6
    }
  }
  return status;
}
 8024fcc:	4620      	mov	r0, r4
 8024fce:	bd10      	pop	{r4, pc}
 8024fd0:	1fff0368 	.word	0x1fff0368

08024fd4 <USBD_VCOM_ReceiveData>:
  return status;
}

/* This function receives number of bytes from the USB host.*/
USBD_VCOM_STATUS_t USBD_VCOM_ReceiveData(int8_t* data_buffer, uint16_t data_byte)
{
 8024fd4:	b530      	push	{r4, r5, lr}
 8024fd6:	b083      	sub	sp, #12
  USBD_VCOM_STATUS_t status = USBD_VCOM_STATUS_SUCCESS;
  uint16_t bytes_processed = 0U;
 8024fd8:	2300      	movs	r3, #0
 8024fda:	f8ad 3006 	strh.w	r3, [sp, #6]
  uint8_t ret = 0U;

  if ((data_byte > 0U) && (data_buffer != NULL))
 8024fde:	b911      	cbnz	r1, 8024fe6 <USBD_VCOM_ReceiveData+0x12>
      status = USBD_VCOM_STATUS_CDC_ERROR;
    }
  }
  else
  {
    status = USBD_VCOM_STATUS_CDC_ERROR;
 8024fe0:	2006      	movs	r0, #6
  }

  return status;
}
 8024fe2:	b003      	add	sp, #12
 8024fe4:	bd30      	pop	{r4, r5, pc}
{
  USBD_VCOM_STATUS_t status = USBD_VCOM_STATUS_SUCCESS;
  uint16_t bytes_processed = 0U;
  uint8_t ret = 0U;

  if ((data_byte > 0U) && (data_buffer != NULL))
 8024fe6:	2800      	cmp	r0, #0
 8024fe8:	d0fa      	beq.n	8024fe0 <USBD_VCOM_ReceiveData+0xc>
	 *  \param[in] Address Endpoint address to select.
	 */
	static inline void Endpoint_SelectEndpoint(const uint8_t Address);
	static inline void Endpoint_SelectEndpoint(const uint8_t Address)
	{
		device.CurrentEndpoint = Address & ENDPOINT_EPNUM_MASK;
 8024fea:	4a0b      	ldr	r2, [pc, #44]	; (8025018 <USBD_VCOM_ReceiveData+0x44>)
 8024fec:	460c      	mov	r4, r1
 8024fee:	2103      	movs	r1, #3
 8024ff0:	4605      	mov	r5, r0
		device.CurrentDirection = (Address & ENDPOINT_DIR_MASK);
 8024ff2:	f882 313d 	strb.w	r3, [r2, #317]	; 0x13d
	 *  \param[in] Address Endpoint address to select.
	 */
	static inline void Endpoint_SelectEndpoint(const uint8_t Address);
	static inline void Endpoint_SelectEndpoint(const uint8_t Address)
	{
		device.CurrentEndpoint = Address & ENDPOINT_EPNUM_MASK;
 8024ff6:	f882 113c 	strb.w	r1, [r2, #316]	; 0x13c
  {
    /* Fix for new read/write */
    Endpoint_SelectEndpoint(CDC_RX_EPNUM);
    while ((uint8_t)ENDPOINT_RWSTREAM_IncompleteTransfer == 
 8024ffa:	4628      	mov	r0, r5
 8024ffc:	4621      	mov	r1, r4
 8024ffe:	f10d 0206 	add.w	r2, sp, #6
 8025002:	f000 f871 	bl	80250e8 <Endpoint_Read_Stream_LE>
 8025006:	2805      	cmp	r0, #5
 8025008:	d0f7      	beq.n	8024ffa <USBD_VCOM_ReceiveData+0x26>
    (ret = Endpoint_Read_Stream_LE(data_buffer, data_byte,	&bytes_processed)))
    {      
    }      
    if ((uint8_t)ENDPOINT_RWSTREAM_NoError != ret )
    {
      status = USBD_VCOM_STATUS_CDC_ERROR;
 802500a:	2800      	cmp	r0, #0
 802500c:	bf0c      	ite	eq
 802500e:	2000      	moveq	r0, #0
 8025010:	2006      	movne	r0, #6
  {
    status = USBD_VCOM_STATUS_CDC_ERROR;
  }

  return status;
}
 8025012:	b003      	add	sp, #12
 8025014:	bd30      	pop	{r4, r5, pc}
 8025016:	bf00      	nop
 8025018:	1fff0594 	.word	0x1fff0594

0802501c <USBD_VCOM_BytesReceived>:
  return status;
}

/* This function checks number of bytes received from the USB host. */
uint16_t USBD_VCOM_BytesReceived(void)
{
 802501c:	b538      	push	{r3, r4, r5, lr}
 */
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 802501e:	4c07      	ldr	r4, [pc, #28]	; (802503c <USBD_VCOM_BytesReceived+0x20>)
 8025020:	f44f 6500 	mov.w	r5, #2048	; 0x800
 8025024:	f8c4 508c 	str.w	r5, [r4, #140]	; 0x8c
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 8025028:	f3bf 8f4f 	dsb	sy
           so that all instructions following the ISB are fetched from cache or memory,
           after the instruction has been completed.
 */
__attribute__((always_inline)) __STATIC_INLINE void __ISB(void)
{
  __ASM volatile ("isb 0xF":::"memory");
 802502c:	f3bf 8f6f 	isb	sy
  uint16_t bytes = 0U;

  /* Check if bytes are received from host */
  NVIC_DisableIRQ(USB0_0_IRQn);
  bytes = CDC_Device_BytesReceived(&USBD_VCOM_cdc_interface);
 8025030:	4803      	ldr	r0, [pc, #12]	; (8025040 <USBD_VCOM_BytesReceived+0x24>)
 8025032:	f7ff fe7f 	bl	8024d34 <CDC_Device_BytesReceived>
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8025036:	60e5      	str	r5, [r4, #12]
  NVIC_EnableIRQ(USB0_0_IRQn);	
    
  return bytes;
}
 8025038:	bd38      	pop	{r3, r4, r5, pc}
 802503a:	bf00      	nop
 802503c:	e000e100 	.word	0xe000e100
 8025040:	1fff0368 	.word	0x1fff0368

08025044 <USBD_VCOM_Connect>:
}

/*The API to connect the VCOM device to USB host*/
USBD_VCOM_STATUS_t USBD_VCOM_Connect(void)
{
  return (USBD_VCOM_STATUS_t)USBD_Connect();
 8025044:	f000 bea4 	b.w	8025d90 <USBD_Connect>

08025048 <Endpoint_Write_Stream_LE>:
/*Flag to indicate the zlp to be sent or not*/
volatile uint8_t zlp_flag = 0;

uint8_t Endpoint_Write_Stream_LE (const void *const Buffer, uint16_t Length,
											uint16_t *const BytesProcessed)
{
 8025048:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	USBD_Endpoint_t* ep = &device.Endpoints[device.CurrentEndpoint];
 802504c:	4b25      	ldr	r3, [pc, #148]	; (80250e4 <Endpoint_Write_Stream_LE+0x9c>)
/*Flag to indicate the zlp to be sent or not*/
volatile uint8_t zlp_flag = 0;

uint8_t Endpoint_Write_Stream_LE (const void *const Buffer, uint16_t Length,
											uint16_t *const BytesProcessed)
{
 802504e:	460c      	mov	r4, r1
 8025050:	4680      	mov	r8, r0
	USBD_Endpoint_t* ep = &device.Endpoints[device.CurrentEndpoint];
 8025052:	f893 113c 	ldrb.w	r1, [r3, #316]	; 0x13c
	uint16_t Bytes = 0;
	uint16_t BytesTransfered = 0;
	uint8_t ErrorCode;

	if (BytesProcessed!=NULL) 
 8025056:	4691      	mov	r9, r2
 8025058:	2a00      	cmp	r2, #0
 802505a:	d03b      	beq.n	80250d4 <Endpoint_Write_Stream_LE+0x8c>
	{
		Length -= *BytesProcessed;
 802505c:	8817      	ldrh	r7, [r2, #0]
 802505e:	1be4      	subs	r4, r4, r7
 8025060:	b2a4      	uxth	r4, r4
		BytesTransfered = *BytesProcessed;
	}

	while (Length) 
	{
		if (ep->InInUse)
 8025062:	262c      	movs	r6, #44	; 0x2c
 8025064:	fb06 3601 	mla	r6, r6, r1, r3
	{
		Length -= *BytesProcessed;
		BytesTransfered = *BytesProcessed;
	}

	while (Length) 
 8025068:	b1f4      	cbz	r4, 80250a8 <Endpoint_Write_Stream_LE+0x60>
	{
		if (ep->InInUse)
 802506a:	68b3      	ldr	r3, [r6, #8]
 802506c:	06db      	lsls	r3, r3, #27
 802506e:	d4fc      	bmi.n	802506a <Endpoint_Write_Stream_LE+0x22>
		{
			continue;
		}
		if (Endpoint_IsReadWriteAllowed()) 
 8025070:	f000 f93a 	bl	80252e8 <Endpoint_IsReadWriteAllowed>
 8025074:	b1f8      	cbz	r0, 80250b6 <Endpoint_Write_Stream_LE+0x6e>
		{
			if((ep->InBufferLength - ep->InBytesAvailable)  > Length)
 8025076:	6a75      	ldr	r5, [r6, #36]	; 0x24
 8025078:	69f0      	ldr	r0, [r6, #28]
 802507a:	1a2d      	subs	r5, r5, r0
 802507c:	42a5      	cmp	r5, r4
 802507e:	d816      	bhi.n	80250ae <Endpoint_Write_Stream_LE+0x66>
			{
				Bytes = Length;
			}
			else
			{
				Bytes = (ep->InBufferLength - ep->InBytesAvailable);
 8025080:	b2ad      	uxth	r5, r5
 8025082:	1b64      	subs	r4, r4, r5
 8025084:	fa1f fb84 	uxth.w	fp, r4
 8025088:	462c      	mov	r4, r5
			}
			memcpy(ep->InBuffer + ep->InBytesAvailable,(uint8_t*)Buffer + BytesTransfered,Bytes);
 802508a:	6a33      	ldr	r3, [r6, #32]
 802508c:	eb08 0107 	add.w	r1, r8, r7
 8025090:	462a      	mov	r2, r5
 8025092:	4418      	add	r0, r3
 8025094:	f008 fa54 	bl	802d540 <memcpy>
			ep->InBytesAvailable += Bytes;
 8025098:	69f3      	ldr	r3, [r6, #28]
			BytesTransfered += Bytes;
 802509a:	4427      	add	r7, r4
			else
			{
				Bytes = (ep->InBufferLength - ep->InBytesAvailable);
			}
			memcpy(ep->InBuffer + ep->InBytesAvailable,(uint8_t*)Buffer + BytesTransfered,Bytes);
			ep->InBytesAvailable += Bytes;
 802509c:	441d      	add	r5, r3
			BytesTransfered += Bytes;
			Length -= Bytes;
 802509e:	465c      	mov	r4, fp
			{
				Bytes = (ep->InBufferLength - ep->InBytesAvailable);
			}
			memcpy(ep->InBuffer + ep->InBytesAvailable,(uint8_t*)Buffer + BytesTransfered,Bytes);
			ep->InBytesAvailable += Bytes;
			BytesTransfered += Bytes;
 80250a0:	b2bf      	uxth	r7, r7
			else
			{
				Bytes = (ep->InBufferLength - ep->InBytesAvailable);
			}
			memcpy(ep->InBuffer + ep->InBytesAvailable,(uint8_t*)Buffer + BytesTransfered,Bytes);
			ep->InBytesAvailable += Bytes;
 80250a2:	61f5      	str	r5, [r6, #28]
	{
		Length -= *BytesProcessed;
		BytesTransfered = *BytesProcessed;
	}

	while (Length) 
 80250a4:	2c00      	cmp	r4, #0
 80250a6:	d1e0      	bne.n	802506a <Endpoint_Write_Stream_LE+0x22>
				return ErrorCode;
			}
		}
	}
	
	return ENDPOINT_RWSTREAM_NoError;
 80250a8:	4620      	mov	r0, r4
}
 80250aa:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80250ae:	4625      	mov	r5, r4
 80250b0:	f04f 0b00 	mov.w	fp, #0
 80250b4:	e7e9      	b.n	802508a <Endpoint_Write_Stream_LE+0x42>
			BytesTransfered += Bytes;
			Length -= Bytes;
		}
		else 
		{
			Endpoint_ClearIN();
 80250b6:	f000 f8df 	bl	8025278 <Endpoint_ClearIN>
			if(Length < ep->MaxPacketSize)
 80250ba:	8933      	ldrh	r3, [r6, #8]
 80250bc:	f3c3 1386 	ubfx	r3, r3, #6, #7
 80250c0:	429c      	cmp	r4, r3
 80250c2:	da02      	bge.n	80250ca <Endpoint_Write_Stream_LE+0x82>
			{
				if (BytesProcessed!=NULL) 
 80250c4:	f1b9 0f00 	cmp.w	r9, #0
 80250c8:	d106      	bne.n	80250d8 <Endpoint_Write_Stream_LE+0x90>
					*BytesProcessed = BytesTransfered;
					return ENDPOINT_RWSTREAM_IncompleteTransfer;
				}
			}

			ErrorCode = Endpoint_WaitUntilReady();
 80250ca:	f000 f85d 	bl	8025188 <Endpoint_WaitUntilReady>
			if (ErrorCode) 
 80250ce:	2800      	cmp	r0, #0
 80250d0:	d0ca      	beq.n	8025068 <Endpoint_Write_Stream_LE+0x20>
 80250d2:	e7ea      	b.n	80250aa <Endpoint_Write_Stream_LE+0x62>
uint8_t Endpoint_Write_Stream_LE (const void *const Buffer, uint16_t Length,
											uint16_t *const BytesProcessed)
{
	USBD_Endpoint_t* ep = &device.Endpoints[device.CurrentEndpoint];
	uint16_t Bytes = 0;
	uint16_t BytesTransfered = 0;
 80250d4:	4617      	mov	r7, r2
 80250d6:	e7c4      	b.n	8025062 <Endpoint_Write_Stream_LE+0x1a>
			Endpoint_ClearIN();
			if(Length < ep->MaxPacketSize)
			{
				if (BytesProcessed!=NULL) 
				{
					*BytesProcessed = BytesTransfered;
 80250d8:	f8a9 7000 	strh.w	r7, [r9]
					return ENDPOINT_RWSTREAM_IncompleteTransfer;
 80250dc:	2005      	movs	r0, #5
 80250de:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80250e2:	bf00      	nop
 80250e4:	1fff0594 	.word	0x1fff0594

080250e8 <Endpoint_Read_Stream_LE>:
	return ENDPOINT_RWSTREAM_NoError;
}

uint8_t	Endpoint_Read_Stream_LE (void *const Buffer, uint16_t Length,
									uint16_t *const BytesProcessed)
{
 80250e8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	USBD_Endpoint_t* ep = &device.Endpoints[device.CurrentEndpoint];
 80250ec:	4b25      	ldr	r3, [pc, #148]	; (8025184 <Endpoint_Read_Stream_LE+0x9c>)
	return ENDPOINT_RWSTREAM_NoError;
}

uint8_t	Endpoint_Read_Stream_LE (void *const Buffer, uint16_t Length,
									uint16_t *const BytesProcessed)
{
 80250ee:	460c      	mov	r4, r1
 80250f0:	4681      	mov	r9, r0
	USBD_Endpoint_t* ep = &device.Endpoints[device.CurrentEndpoint];
 80250f2:	f893 113c 	ldrb.w	r1, [r3, #316]	; 0x13c
	uint16_t Bytes = 0;
	uint16_t BytesTransfered = 0;
	uint8_t ErrorCode;

	if (BytesProcessed!=NULL) 
 80250f6:	4692      	mov	sl, r2
 80250f8:	2a00      	cmp	r2, #0
 80250fa:	d03b      	beq.n	8025174 <Endpoint_Read_Stream_LE+0x8c>
	{
		Length -= *BytesProcessed;
 80250fc:	f8b2 8000 	ldrh.w	r8, [r2]
 8025100:	ebc8 0404 	rsb	r4, r8, r4
 8025104:	b2a4      	uxth	r4, r4
		BytesTransfered = *BytesProcessed;
	}

	while (Length) 
	{
		if (ep->OutInUse)
 8025106:	252c      	movs	r5, #44	; 0x2c
 8025108:	fb05 3501 	mla	r5, r5, r1, r3
	{
		Length -= *BytesProcessed;
		BytesTransfered = *BytesProcessed;
	}

	while (Length) 
 802510c:	b30c      	cbz	r4, 8025152 <Endpoint_Read_Stream_LE+0x6a>
	{
		if (ep->OutInUse)
 802510e:	68ab      	ldr	r3, [r5, #8]
 8025110:	071b      	lsls	r3, r3, #28
 8025112:	d4fc      	bmi.n	802510e <Endpoint_Read_Stream_LE+0x26>
		{
			continue;
		}
		if (Endpoint_IsReadWriteAllowed()) 
 8025114:	f000 f8e8 	bl	80252e8 <Endpoint_IsReadWriteAllowed>
 8025118:	b310      	cbz	r0, 8025160 <Endpoint_Read_Stream_LE+0x78>
		{
			if(ep->OutBytesAvailable  > Length)
 802511a:	68ee      	ldr	r6, [r5, #12]
 802511c:	42a6      	cmp	r6, r4
 802511e:	d81b      	bhi.n	8025158 <Endpoint_Read_Stream_LE+0x70>
			{
				Bytes = Length;
			}
			else
			{
				Bytes = (uint16_t)ep->OutBytesAvailable;
 8025120:	b2b3      	uxth	r3, r6
 8025122:	1ae4      	subs	r4, r4, r3
 8025124:	fa1f fb84 	uxth.w	fp, r4
 8025128:	461c      	mov	r4, r3
			}

			memcpy((uint8_t*)Buffer + BytesTransfered,
									ep->OutBuffer + ep->OutOffset,Bytes);
 802512a:	692b      	ldr	r3, [r5, #16]
 802512c:	6969      	ldr	r1, [r5, #20]
			else
			{
				Bytes = (uint16_t)ep->OutBytesAvailable;
			}

			memcpy((uint8_t*)Buffer + BytesTransfered,
 802512e:	4632      	mov	r2, r6
 8025130:	eb09 0008 	add.w	r0, r9, r8
 8025134:	4419      	add	r1, r3
 8025136:	f008 fa03 	bl	802d540 <memcpy>
									ep->OutBuffer + ep->OutOffset,Bytes);
			ep->OutBytesAvailable -= Bytes;
 802513a:	68ea      	ldr	r2, [r5, #12]
			ep->OutOffset += Bytes;
 802513c:	692b      	ldr	r3, [r5, #16]
			BytesTransfered += Bytes;
 802513e:	44a0      	add	r8, r4
				Bytes = (uint16_t)ep->OutBytesAvailable;
			}

			memcpy((uint8_t*)Buffer + BytesTransfered,
									ep->OutBuffer + ep->OutOffset,Bytes);
			ep->OutBytesAvailable -= Bytes;
 8025140:	1b92      	subs	r2, r2, r6
			ep->OutOffset += Bytes;
			BytesTransfered += Bytes;
			Length -= Bytes;
 8025142:	465c      	mov	r4, fp
			}

			memcpy((uint8_t*)Buffer + BytesTransfered,
									ep->OutBuffer + ep->OutOffset,Bytes);
			ep->OutBytesAvailable -= Bytes;
			ep->OutOffset += Bytes;
 8025144:	441e      	add	r6, r3
			BytesTransfered += Bytes;
 8025146:	fa1f f888 	uxth.w	r8, r8
				Bytes = (uint16_t)ep->OutBytesAvailable;
			}

			memcpy((uint8_t*)Buffer + BytesTransfered,
									ep->OutBuffer + ep->OutOffset,Bytes);
			ep->OutBytesAvailable -= Bytes;
 802514a:	60ea      	str	r2, [r5, #12]
			ep->OutOffset += Bytes;
 802514c:	612e      	str	r6, [r5, #16]
	{
		Length -= *BytesProcessed;
		BytesTransfered = *BytesProcessed;
	}

	while (Length) 
 802514e:	2c00      	cmp	r4, #0
 8025150:	d1dd      	bne.n	802510e <Endpoint_Read_Stream_LE+0x26>
			{
				return ErrorCode;
			}
		}
	}
	return ENDPOINT_RWSTREAM_NoError;
 8025152:	4620      	mov	r0, r4
}
 8025154:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8025158:	4626      	mov	r6, r4
 802515a:	f04f 0b00 	mov.w	fp, #0
 802515e:	e7e4      	b.n	802512a <Endpoint_Read_Stream_LE+0x42>
			BytesTransfered += Bytes;
			Length -= Bytes;
		}
		else 
		{
			Endpoint_ClearOUT();
 8025160:	f000 f85e 	bl	8025220 <Endpoint_ClearOUT>
			if (BytesProcessed != NULL) 
 8025164:	f1ba 0f00 	cmp.w	sl, #0
 8025168:	d106      	bne.n	8025178 <Endpoint_Read_Stream_LE+0x90>
			{
				*BytesProcessed = BytesTransfered;
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
			}

			ErrorCode = Endpoint_WaitUntilReady();
 802516a:	f000 f80d 	bl	8025188 <Endpoint_WaitUntilReady>
			if (ErrorCode) 
 802516e:	2800      	cmp	r0, #0
 8025170:	d0cc      	beq.n	802510c <Endpoint_Read_Stream_LE+0x24>
 8025172:	e7ef      	b.n	8025154 <Endpoint_Read_Stream_LE+0x6c>
uint8_t	Endpoint_Read_Stream_LE (void *const Buffer, uint16_t Length,
									uint16_t *const BytesProcessed)
{
	USBD_Endpoint_t* ep = &device.Endpoints[device.CurrentEndpoint];
	uint16_t Bytes = 0;
	uint16_t BytesTransfered = 0;
 8025174:	4690      	mov	r8, r2
 8025176:	e7c6      	b.n	8025106 <Endpoint_Read_Stream_LE+0x1e>
		else 
		{
			Endpoint_ClearOUT();
			if (BytesProcessed != NULL) 
			{
				*BytesProcessed = BytesTransfered;
 8025178:	f8aa 8000 	strh.w	r8, [sl]
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
 802517c:	2005      	movs	r0, #5
 802517e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8025182:	bf00      	nop
 8025184:	1fff0594 	.word	0x1fff0594

08025188 <Endpoint_WaitUntilReady>:

#define USB_STREAM_TIMEOUT_MS 100


uint8_t Endpoint_WaitUntilReady(void)
{
 8025188:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 *
 *  \return Current USB frame number from the USB controller.
 */
static inline uint16_t USB_Device_GetFrameNumber(void);
static inline uint16_t USB_Device_GetFrameNumber() {
	return device.Driver->GetFrameNumber();
 802518c:	4c22      	ldr	r4, [pc, #136]	; (8025218 <Endpoint_WaitUntilReady+0x90>)
			{
			  return ENDPOINT_READYWAIT_NoError;
			}
		}

		uint8_t USB_DeviceState_LCL = USB_DeviceState;
 802518e:	4d23      	ldr	r5, [pc, #140]	; (802521c <Endpoint_WaitUntilReady+0x94>)
 8025190:	6823      	ldr	r3, [r4, #0]
 8025192:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8025194:	4798      	blx	r3
	 */
	static inline bool Endpoint_IsStalled(void);
	static inline bool Endpoint_IsStalled(void)
	{
		bool status = false;
		if(device.Endpoints[device.CurrentEndpoint].IsHalted == 1)
 8025196:	46a1      	mov	r9, r4
 8025198:	4680      	mov	r8, r0


uint8_t Endpoint_WaitUntilReady(void)
{
	#if (USB_STREAM_TIMEOUT_MS < 0xFF)
	uint8_t  TimeoutMSRem = USB_STREAM_TIMEOUT_MS;
 802519a:	2664      	movs	r6, #100	; 0x64
	 */
	static inline uint8_t Endpoint_GetEndpointDirection(void);
	static inline uint8_t Endpoint_GetEndpointDirection(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
		return ep->Address & ENDPOINT_DIR_MASK;
 802519c:	272c      	movs	r7, #44	; 0x2c
	 *  \c ENDPOINT_DIR_* mask.
	 */
	static inline uint8_t Endpoint_GetEndpointDirection(void);
	static inline uint8_t Endpoint_GetEndpointDirection(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
 802519e:	f894 313c 	ldrb.w	r3, [r4, #316]	; 0x13c
		return ep->Address & ENDPOINT_DIR_MASK;
 80251a2:	fb07 4203 	mla	r2, r7, r3, r4
 80251a6:	7911      	ldrb	r1, [r2, #4]

	uint16_t PreviousFrameNumber = USB_Device_GetFrameNumber();

	for (;;)
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
 80251a8:	0608      	lsls	r0, r1, #24
 80251aa:	d41a      	bmi.n	80251e2 <Endpoint_WaitUntilReady+0x5a>
	 */
	static inline bool Endpoint_IsOUTReceived(void);
	static inline bool Endpoint_IsOUTReceived(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
		return ep->IsOutRecieved;
 80251ac:	6892      	ldr	r2, [r2, #8]
			  return ENDPOINT_READYWAIT_NoError;
			}
		}
		else
		{
			if (Endpoint_IsOUTReceived())
 80251ae:	0692      	lsls	r2, r2, #26
 80251b0:	d42b      	bmi.n	802520a <Endpoint_WaitUntilReady+0x82>
			{
			  return ENDPOINT_READYWAIT_NoError;
			}
		}

		uint8_t USB_DeviceState_LCL = USB_DeviceState;
 80251b2:	782a      	ldrb	r2, [r5, #0]

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
 80251b4:	f002 01ff 	and.w	r1, r2, #255	; 0xff
 80251b8:	b322      	cbz	r2, 8025204 <Endpoint_WaitUntilReady+0x7c>
		{
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
		}
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
 80251ba:	2905      	cmp	r1, #5
 80251bc:	d01f      	beq.n	80251fe <Endpoint_WaitUntilReady+0x76>
	 */
	static inline bool Endpoint_IsStalled(void);
	static inline bool Endpoint_IsStalled(void)
	{
		bool status = false;
		if(device.Endpoints[device.CurrentEndpoint].IsHalted == 1)
 80251be:	fb07 4303 	mla	r3, r7, r3, r4
 80251c2:	6898      	ldr	r0, [r3, #8]
 80251c4:	f3c0 0080 	ubfx	r0, r0, #2, #1
 80251c8:	b9a8      	cbnz	r0, 80251f6 <Endpoint_WaitUntilReady+0x6e>
 80251ca:	f8d9 3000 	ldr.w	r3, [r9]
 80251ce:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80251d0:	4798      	blx	r3
		  return ENDPOINT_READYWAIT_EndpointStalled;
		}

		uint16_t CurrentFrameNumber = USB_Device_GetFrameNumber();

		if (CurrentFrameNumber != PreviousFrameNumber)
 80251d2:	4580      	cmp	r8, r0
 80251d4:	d011      	beq.n	80251fa <Endpoint_WaitUntilReady+0x72>
		{
			PreviousFrameNumber = CurrentFrameNumber;

			if (!(TimeoutMSRem--))
 80251d6:	1e73      	subs	r3, r6, #1
 80251d8:	b2db      	uxtb	r3, r3
 80251da:	b1ce      	cbz	r6, 8025210 <Endpoint_WaitUntilReady+0x88>
 80251dc:	4680      	mov	r8, r0
 80251de:	461e      	mov	r6, r3
 80251e0:	e7dd      	b.n	802519e <Endpoint_WaitUntilReady+0x16>
	 */
	static inline bool Endpoint_IsINReady(void);
	static inline bool Endpoint_IsINReady(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
		return ep->InInUse == 0 && ep->IsEnabled;
 80251e2:	6890      	ldr	r0, [r2, #8]
 80251e4:	f3c0 1000 	ubfx	r0, r0, #4, #1
 80251e8:	2800      	cmp	r0, #0
 80251ea:	d1e2      	bne.n	80251b2 <Endpoint_WaitUntilReady+0x2a>
 80251ec:	6892      	ldr	r2, [r2, #8]
 80251ee:	0791      	lsls	r1, r2, #30
 80251f0:	d5df      	bpl.n	80251b2 <Endpoint_WaitUntilReady+0x2a>
			{
			  return ENDPOINT_READYWAIT_Timeout;
			}
		}
	}
}
 80251f2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80251f6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80251fa:	4633      	mov	r3, r6
 80251fc:	e7ee      	b.n	80251dc <Endpoint_WaitUntilReady+0x54>
		{
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
		}
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		{
		  return ENDPOINT_READYWAIT_BusSuspended;
 80251fe:	2003      	movs	r0, #3
 8025200:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		{
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
 8025204:	2002      	movs	r0, #2
 8025206:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
		{
			if (Endpoint_IsINReady())
			{
			  return ENDPOINT_READYWAIT_NoError;
 802520a:	2000      	movs	r0, #0
 802520c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		{
			PreviousFrameNumber = CurrentFrameNumber;

			if (!(TimeoutMSRem--))
			{
			  return ENDPOINT_READYWAIT_Timeout;
 8025210:	2004      	movs	r0, #4
 8025212:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8025216:	bf00      	nop
 8025218:	1fff0594 	.word	0x1fff0594
 802521c:	1fff0389 	.word	0x1fff0389

08025220 <Endpoint_ClearOUT>:
		}
	}
}

void Endpoint_ClearOUT(void) 
{
 8025220:	b570      	push	{r4, r5, r6, lr}
	USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
 8025222:	4d14      	ldr	r5, [pc, #80]	; (8025274 <Endpoint_ClearOUT+0x54>)
 8025224:	f895 313c 	ldrb.w	r3, [r5, #316]	; 0x13c
	/* if we have data left which isn't read yet, we leave this routine to
	 * not override it */
	if (ep->IsEnabled == 0)
 8025228:	242c      	movs	r4, #44	; 0x2c
 802522a:	fb04 5403 	mla	r4, r4, r3, r5
 802522e:	68a3      	ldr	r3, [r4, #8]
 8025230:	079a      	lsls	r2, r3, #30
 8025232:	d400      	bmi.n	8025236 <Endpoint_ClearOUT+0x16>
 8025234:	bd70      	pop	{r4, r5, r6, pc}
	{
		return;
	}
	/* First Check whether we have data in the driver */
	ep->OutBytesAvailable = device.Driver->EndpointRead(ep->Address,ep->OutBuffer,ep->OutBufferLength);
 8025236:	682b      	ldr	r3, [r5, #0]
 8025238:	6961      	ldr	r1, [r4, #20]
 802523a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 802523c:	69a2      	ldr	r2, [r4, #24]
 802523e:	7920      	ldrb	r0, [r4, #4]
 8025240:	4798      	blx	r3
	ep->OutOffset = 0;
	/* If we didn't request new data and all data has been read, request new */
	if (!ep->OutInUse && !ep->OutBytesAvailable) 
 8025242:	68a3      	ldr	r3, [r4, #8]
	if (ep->IsEnabled == 0)
	{
		return;
	}
	/* First Check whether we have data in the driver */
	ep->OutBytesAvailable = device.Driver->EndpointRead(ep->Address,ep->OutBuffer,ep->OutBufferLength);
 8025244:	60e0      	str	r0, [r4, #12]
	ep->OutOffset = 0;
 8025246:	2100      	movs	r1, #0
	/* If we didn't request new data and all data has been read, request new */
	if (!ep->OutInUse && !ep->OutBytesAvailable) 
 8025248:	071b      	lsls	r3, r3, #28
	if (ep->IsEnabled == 0)
	{
		return;
	}
	/* First Check whether we have data in the driver */
	ep->OutBytesAvailable = device.Driver->EndpointRead(ep->Address,ep->OutBuffer,ep->OutBufferLength);
 802524a:	4602      	mov	r2, r0
	ep->OutOffset = 0;
 802524c:	6121      	str	r1, [r4, #16]
	/* If we didn't request new data and all data has been read, request new */
	if (!ep->OutInUse && !ep->OutBytesAvailable) 
 802524e:	d4f1      	bmi.n	8025234 <Endpoint_ClearOUT+0x14>
 8025250:	2800      	cmp	r0, #0
 8025252:	d1ef      	bne.n	8025234 <Endpoint_ClearOUT+0x14>
	{
		ep->OutInUse = true;
 8025254:	8923      	ldrh	r3, [r4, #8]
		ep->IsOutRecieved = 0;
		device.Driver->EndpointReadStart(ep->Address,ep->OutBufferLength);
 8025256:	7920      	ldrb	r0, [r4, #4]
 8025258:	69a1      	ldr	r1, [r4, #24]
	ep->OutBytesAvailable = device.Driver->EndpointRead(ep->Address,ep->OutBuffer,ep->OutBufferLength);
	ep->OutOffset = 0;
	/* If we didn't request new data and all data has been read, request new */
	if (!ep->OutInUse && !ep->OutBytesAvailable) 
	{
		ep->OutInUse = true;
 802525a:	f043 0308 	orr.w	r3, r3, #8
 802525e:	8123      	strh	r3, [r4, #8]
		ep->IsOutRecieved = 0;
 8025260:	8923      	ldrh	r3, [r4, #8]
 8025262:	f362 1345 	bfi	r3, r2, #5, #1
 8025266:	8123      	strh	r3, [r4, #8]
		device.Driver->EndpointReadStart(ep->Address,ep->OutBufferLength);
 8025268:	682b      	ldr	r3, [r5, #0]
	}
}
 802526a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	/* If we didn't request new data and all data has been read, request new */
	if (!ep->OutInUse && !ep->OutBytesAvailable) 
	{
		ep->OutInUse = true;
		ep->IsOutRecieved = 0;
		device.Driver->EndpointReadStart(ep->Address,ep->OutBufferLength);
 802526e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8025270:	4718      	bx	r3
 8025272:	bf00      	nop
 8025274:	1fff0594 	.word	0x1fff0594

08025278 <Endpoint_ClearIN>:
	}
}

void Endpoint_ClearIN(void)
{
 8025278:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
 802527a:	4919      	ldr	r1, [pc, #100]	; (80252e0 <Endpoint_ClearIN+0x68>)
 802527c:	f891 313c 	ldrb.w	r3, [r1, #316]	; 0x13c
	int32_t data_count;
	/* don't clear if in use or not enabled */
	if (ep->InInUse == 1 || ep->IsEnabled == 0)
 8025280:	222c      	movs	r2, #44	; 0x2c
 8025282:	fb02 1303 	mla	r3, r2, r3, r1
 8025286:	689a      	ldr	r2, [r3, #8]
 8025288:	06d0      	lsls	r0, r2, #27
 802528a:	d402      	bmi.n	8025292 <Endpoint_ClearIN+0x1a>
 802528c:	689a      	ldr	r2, [r3, #8]
 802528e:	0792      	lsls	r2, r2, #30
 8025290:	d400      	bmi.n	8025294 <Endpoint_ClearIN+0x1c>
 8025292:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return;
	ep->InInUse = true;
 8025294:	8918      	ldrh	r0, [r3, #8]
	/* store transfer information to loop over, if underlying is smaller */
	ep->InDataBuffer = ep->InBuffer;
 8025296:	6a1f      	ldr	r7, [r3, #32]
 */
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8025298:	4e12      	ldr	r6, [pc, #72]	; (80252e4 <Endpoint_ClearIN+0x6c>)
	USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
	int32_t data_count;
	/* don't clear if in use or not enabled */
	if (ep->InInUse == 1 || ep->IsEnabled == 0)
		return;
	ep->InInUse = true;
 802529a:	f040 0010 	orr.w	r0, r0, #16
	/* store transfer information to loop over, if underlying is smaller */
	ep->InDataBuffer = ep->InBuffer;
 802529e:	f103 0528 	add.w	r5, r3, #40	; 0x28
	ep->InDataLeft = ep->InBytesAvailable;
 80252a2:	f103 0420 	add.w	r4, r3, #32
	USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
	int32_t data_count;
	/* don't clear if in use or not enabled */
	if (ep->InInUse == 1 || ep->IsEnabled == 0)
		return;
	ep->InInUse = true;
 80252a6:	8118      	strh	r0, [r3, #8]
	/* store transfer information to loop over, if underlying is smaller */
	ep->InDataBuffer = ep->InBuffer;
	ep->InDataLeft = ep->InBytesAvailable;
 80252a8:	69d8      	ldr	r0, [r3, #28]
 80252aa:	60a0      	str	r0, [r4, #8]
	/* don't clear if in use or not enabled */
	if (ep->InInUse == 1 || ep->IsEnabled == 0)
		return;
	ep->InInUse = true;
	/* store transfer information to loop over, if underlying is smaller */
	ep->InDataBuffer = ep->InBuffer;
 80252ac:	606f      	str	r7, [r5, #4]
	ep->InDataLeft = ep->InBytesAvailable;
	ep->InBytesAvailable = 0;
 80252ae:	2000      	movs	r0, #0
 80252b0:	f44f 6700 	mov.w	r7, #2048	; 0x800
 80252b4:	61d8      	str	r0, [r3, #28]
 80252b6:	f8c6 708c 	str.w	r7, [r6, #140]	; 0x8c
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 80252ba:	f3bf 8f4f 	dsb	sy
           so that all instructions following the ISB are fetched from cache or memory,
           after the instruction has been completed.
 */
__attribute__((always_inline)) __STATIC_INLINE void __ISB(void)
{
  __ASM volatile ("isb 0xF":::"memory");
 80252be:	f3bf 8f6f 	isb	sy
	/* make next 3 operations atomic. Do not get interrupted.*/
	NVIC_DisableIRQ(USB0_0_IRQn);
	data_count = device.Driver->EndpointWrite(ep->Address,
 80252c2:	680a      	ldr	r2, [r1, #0]
 80252c4:	7918      	ldrb	r0, [r3, #4]
 80252c6:	6869      	ldr	r1, [r5, #4]
 80252c8:	6b13      	ldr	r3, [r2, #48]	; 0x30
 80252ca:	68a2      	ldr	r2, [r4, #8]
 80252cc:	4798      	blx	r3
			ep->InDataBuffer,ep->InDataLeft);
	ep->InDataBuffer += data_count;
 80252ce:	686a      	ldr	r2, [r5, #4]
	ep->InDataLeft -= data_count;
 80252d0:	68a3      	ldr	r3, [r4, #8]
	ep->InBytesAvailable = 0;
	/* make next 3 operations atomic. Do not get interrupted.*/
	NVIC_DisableIRQ(USB0_0_IRQn);
	data_count = device.Driver->EndpointWrite(ep->Address,
			ep->InDataBuffer,ep->InDataLeft);
	ep->InDataBuffer += data_count;
 80252d2:	4402      	add	r2, r0
	ep->InDataLeft -= data_count;
 80252d4:	1a1b      	subs	r3, r3, r0
	ep->InBytesAvailable = 0;
	/* make next 3 operations atomic. Do not get interrupted.*/
	NVIC_DisableIRQ(USB0_0_IRQn);
	data_count = device.Driver->EndpointWrite(ep->Address,
			ep->InDataBuffer,ep->InDataLeft);
	ep->InDataBuffer += data_count;
 80252d6:	606a      	str	r2, [r5, #4]
	ep->InDataLeft -= data_count;
 80252d8:	60a3      	str	r3, [r4, #8]
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 80252da:	60f7      	str	r7, [r6, #12]
 80252dc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80252de:	bf00      	nop
 80252e0:	1fff0594 	.word	0x1fff0594
 80252e4:	e000e100 	.word	0xe000e100

080252e8 <Endpoint_IsReadWriteAllowed>:
	NVIC_EnableIRQ(USB0_0_IRQn);

}

bool Endpoint_IsReadWriteAllowed() {
	USBD_Endpoint_t *EndPoint = &device.Endpoints[device.CurrentEndpoint];
 80252e8:	4b0a      	ldr	r3, [pc, #40]	; (8025314 <Endpoint_IsReadWriteAllowed+0x2c>)
 80252ea:	f893 213c 	ldrb.w	r2, [r3, #316]	; 0x13c
	bool Retval = false;

	if(EndPoint->Direction)
 80252ee:	212c      	movs	r1, #44	; 0x2c
 80252f0:	fb01 3302 	mla	r3, r1, r2, r3
 80252f4:	791a      	ldrb	r2, [r3, #4]
 80252f6:	0612      	lsls	r2, r2, #24
 80252f8:	d404      	bmi.n	8025304 <Endpoint_IsReadWriteAllowed+0x1c>
		Retval = (EndPoint->InBytesAvailable < EndPoint->InBufferLength)
														? true : false;
	}
	else
	{
		Retval = (EndPoint->OutBytesAvailable > 0) ? true : false;
 80252fa:	68d8      	ldr	r0, [r3, #12]
 80252fc:	3000      	adds	r0, #0
 80252fe:	bf18      	it	ne
 8025300:	2001      	movne	r0, #1
	}
	return Retval;
}
 8025302:	4770      	bx	lr
	USBD_Endpoint_t *EndPoint = &device.Endpoints[device.CurrentEndpoint];
	bool Retval = false;

	if(EndPoint->Direction)
	{
		Retval = (EndPoint->InBytesAvailable < EndPoint->InBufferLength)
 8025304:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8025306:	69da      	ldr	r2, [r3, #28]
 8025308:	4282      	cmp	r2, r0
 802530a:	bf2c      	ite	cs
 802530c:	2000      	movcs	r0, #0
 802530e:	2001      	movcc	r0, #1
 8025310:	4770      	bx	lr
 8025312:	bf00      	nop
 8025314:	1fff0594 	.word	0x1fff0594

08025318 <Endpoint_Write_8>:
	}
	return Retval;
}

void Endpoint_Write_8(const uint8_t Data) {
	USBD_Endpoint_t *EndPoint = &device.Endpoints[device.CurrentEndpoint];
 8025318:	4a09      	ldr	r2, [pc, #36]	; (8025340 <Endpoint_Write_8+0x28>)
 802531a:	f892 313c 	ldrb.w	r3, [r2, #316]	; 0x13c
 802531e:	212c      	movs	r1, #44	; 0x2c
 8025320:	fb01 2203 	mla	r2, r1, r3, r2
 8025324:	f102 0318 	add.w	r3, r2, #24
 8025328:	6a51      	ldr	r1, [r2, #36]	; 0x24
 802532a:	685a      	ldr	r2, [r3, #4]
 802532c:	428a      	cmp	r2, r1
 802532e:	d300      	bcc.n	8025332 <Endpoint_Write_8+0x1a>
 8025330:	e7fe      	b.n	8025330 <Endpoint_Write_8+0x18>

	 do
	  {
	    if(EndPoint->InBytesAvailable < EndPoint->InBufferLength)
	    {
	      EndPoint->InBuffer[EndPoint->InBytesAvailable] = Data;
 8025332:	6899      	ldr	r1, [r3, #8]
 8025334:	5488      	strb	r0, [r1, r2]
	      EndPoint->InBytesAvailable++;
 8025336:	685a      	ldr	r2, [r3, #4]
 8025338:	3201      	adds	r2, #1
 802533a:	605a      	str	r2, [r3, #4]
 802533c:	4770      	bx	lr
 802533e:	bf00      	nop
 8025340:	1fff0594 	.word	0x1fff0594

08025344 <Endpoint_Read_8>:
	    }
	  }while(!Success);
}

uint8_t Endpoint_Read_8() {
	USBD_Endpoint_t *EndPoint = &device.Endpoints[device.CurrentEndpoint];
 8025344:	4b09      	ldr	r3, [pc, #36]	; (802536c <Endpoint_Read_8+0x28>)
 8025346:	f893 213c 	ldrb.w	r2, [r3, #316]	; 0x13c
 802534a:	212c      	movs	r1, #44	; 0x2c
 802534c:	fb01 3302 	mla	r3, r1, r2, r3
 8025350:	f103 0208 	add.w	r2, r3, #8
 8025354:	6851      	ldr	r1, [r2, #4]
 8025356:	b901      	cbnz	r1, 802535a <Endpoint_Read_8+0x16>
 8025358:	e7fe      	b.n	8025358 <Endpoint_Read_8+0x14>

	 do
	  {
		if(EndPoint->OutBytesAvailable > 0)
		{
		  data = EndPoint->OutBuffer[EndPoint->OutOffset];
 802535a:	6958      	ldr	r0, [r3, #20]
 802535c:	6893      	ldr	r3, [r2, #8]
		  EndPoint->OutOffset++;
		  EndPoint->OutBytesAvailable--;
 802535e:	3901      	subs	r1, #1

	 do
	  {
		if(EndPoint->OutBytesAvailable > 0)
		{
		  data = EndPoint->OutBuffer[EndPoint->OutOffset];
 8025360:	5cc0      	ldrb	r0, [r0, r3]
		  EndPoint->OutOffset++;
		  EndPoint->OutBytesAvailable--;
 8025362:	6051      	str	r1, [r2, #4]
	 do
	  {
		if(EndPoint->OutBytesAvailable > 0)
		{
		  data = EndPoint->OutBuffer[EndPoint->OutOffset];
		  EndPoint->OutOffset++;
 8025364:	3301      	adds	r3, #1
 8025366:	6093      	str	r3, [r2, #8]

		  Success = true;
		}
	  }while(!Success);
	 return data;
}
 8025368:	4770      	bx	lr
 802536a:	bf00      	nop
 802536c:	1fff0594 	.word	0x1fff0594

08025370 <Endpoint_Write_32_LE>:

void Endpoint_Write_32_LE(const uint32_t Data) {
	USBD_Endpoint_t *EndPoint = &device.Endpoints[device.CurrentEndpoint];
 8025370:	4a09      	ldr	r2, [pc, #36]	; (8025398 <Endpoint_Write_32_LE+0x28>)
 8025372:	f892 313c 	ldrb.w	r3, [r2, #316]	; 0x13c
 8025376:	212c      	movs	r1, #44	; 0x2c
 8025378:	fb01 2203 	mla	r2, r1, r3, r2
 802537c:	f102 0318 	add.w	r3, r2, #24
 8025380:	6a52      	ldr	r2, [r2, #36]	; 0x24
 8025382:	6859      	ldr	r1, [r3, #4]
 8025384:	3a03      	subs	r2, #3
 8025386:	4291      	cmp	r1, r2
 8025388:	d300      	bcc.n	802538c <Endpoint_Write_32_LE+0x1c>
 802538a:	e7fe      	b.n	802538a <Endpoint_Write_32_LE+0x1a>
	bool Success = false;

	do {
		if(EndPoint->InBytesAvailable < (EndPoint->InBufferLength - 3)) {
			*(uint32_t*)(EndPoint->InBuffer + EndPoint->InBytesAvailable) =
 802538c:	689a      	ldr	r2, [r3, #8]
 802538e:	5050      	str	r0, [r2, r1]
																		Data;
			EndPoint->InBytesAvailable+=4;
 8025390:	685a      	ldr	r2, [r3, #4]
 8025392:	3204      	adds	r2, #4
 8025394:	605a      	str	r2, [r3, #4]
 8025396:	4770      	bx	lr
 8025398:	1fff0594 	.word	0x1fff0594

0802539c <Endpoint_Read_32_LE>:
		}
	}while(!Success);
}

uint32_t Endpoint_Read_32_LE() {
	USBD_Endpoint_t *EndPoint = &device.Endpoints[device.CurrentEndpoint];
 802539c:	4b09      	ldr	r3, [pc, #36]	; (80253c4 <Endpoint_Read_32_LE+0x28>)
 802539e:	f893 213c 	ldrb.w	r2, [r3, #316]	; 0x13c
 80253a2:	212c      	movs	r1, #44	; 0x2c
 80253a4:	fb01 3302 	mla	r3, r1, r2, r3
 80253a8:	f103 0208 	add.w	r2, r3, #8
 80253ac:	6851      	ldr	r1, [r2, #4]
 80253ae:	2903      	cmp	r1, #3
 80253b0:	d800      	bhi.n	80253b4 <Endpoint_Read_32_LE+0x18>
 80253b2:	e7fe      	b.n	80253b2 <Endpoint_Read_32_LE+0x16>
	bool Success = false;
	uint32_t data = 0;

	do {
		if(EndPoint->OutBytesAvailable > 3) {
			data = *(uint32_t*)(EndPoint->OutBuffer + EndPoint->OutOffset);
 80253b4:	6958      	ldr	r0, [r3, #20]
 80253b6:	6893      	ldr	r3, [r2, #8]
			EndPoint->OutOffset+=4;
			EndPoint->OutBytesAvailable-=4;
 80253b8:	3904      	subs	r1, #4
	bool Success = false;
	uint32_t data = 0;

	do {
		if(EndPoint->OutBytesAvailable > 3) {
			data = *(uint32_t*)(EndPoint->OutBuffer + EndPoint->OutOffset);
 80253ba:	58c0      	ldr	r0, [r0, r3]
			EndPoint->OutOffset+=4;
			EndPoint->OutBytesAvailable-=4;
 80253bc:	6051      	str	r1, [r2, #4]
	uint32_t data = 0;

	do {
		if(EndPoint->OutBytesAvailable > 3) {
			data = *(uint32_t*)(EndPoint->OutBuffer + EndPoint->OutOffset);
			EndPoint->OutOffset+=4;
 80253be:	3304      	adds	r3, #4
 80253c0:	6093      	str	r3, [r2, #8]

			Success = true;
		}
	} while(!Success);
	return data;
}
 80253c2:	4770      	bx	lr
 80253c4:	1fff0594 	.word	0x1fff0594

080253c8 <Endpoint_ConfigureEndpointTable>:

bool Endpoint_ConfigureEndpointTable(const USB_Endpoint_Table_t* const Table,
			                                     const uint8_t Entries) {
	uint8_t i;
	uint8_t Number;
	for (i=0;i<Entries;i++) {
 80253c8:	2900      	cmp	r1, #0
 80253ca:	d042      	beq.n	8025452 <Endpoint_ConfigureEndpointTable+0x8a>
	} while(!Success);
	return data;
}

bool Endpoint_ConfigureEndpointTable(const USB_Endpoint_Table_t* const Table,
			                                     const uint8_t Entries) {
 80253cc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80253d0:	1e4d      	subs	r5, r1, #1
 80253d2:	b2e9      	uxtb	r1, r5
 80253d4:	4f20      	ldr	r7, [pc, #128]	; (8025458 <Endpoint_ConfigureEndpointTable+0x90>)
 80253d6:	2506      	movs	r5, #6
 80253d8:	fb05 0501 	mla	r5, r5, r1, r0
 80253dc:	350a      	adds	r5, #10
 80253de:	f100 0904 	add.w	r9, r0, #4
	uint8_t i;
	uint8_t Number;
	for (i=0;i<Entries;i++) {
		Number = Table[i].Address & ENDPOINT_EPNUM_MASK;
		/* Configure endpoint in device controller driver */
		if (device.Driver->EndpointConfigure(Table[i].Address,
 80253e2:	463e      	mov	r6, r7
				(XMC_USBD_ENDPOINT_TYPE_t)Table[i].Type,Table[i].Size) !=
																XMC_USBD_STATUS_OK)
			return false;
		/* Set device core values */
		device.Endpoints[Number].Address = Table[i].Address;
 80253e4:	f04f 082c 	mov.w	r8, #44	; 0x2c
 80253e8:	e01c      	b.n	8025424 <Endpoint_ConfigureEndpointTable+0x5c>
 80253ea:	f819 2c04 	ldrb.w	r2, [r9, #-4]
 80253ee:	711a      	strb	r2, [r3, #4]
		device.Endpoints[Number].MaxPacketSize = Table[i].Size;
 80253f0:	f839 2c02 	ldrh.w	r2, [r9, #-2]
 80253f4:	8919      	ldrh	r1, [r3, #8]
 80253f6:	f362 118c 	bfi	r1, r2, #6, #7
		device.Endpoints[Number].IsConfigured = 1;
 80253fa:	b2ca      	uxtb	r2, r1
 80253fc:	f042 0201 	orr.w	r2, r2, #1
				(XMC_USBD_ENDPOINT_TYPE_t)Table[i].Type,Table[i].Size) !=
																XMC_USBD_STATUS_OK)
			return false;
		/* Set device core values */
		device.Endpoints[Number].Address = Table[i].Address;
		device.Endpoints[Number].MaxPacketSize = Table[i].Size;
 8025400:	8119      	strh	r1, [r3, #8]
		device.Endpoints[Number].IsConfigured = 1;
 8025402:	721a      	strb	r2, [r3, #8]
		device.Endpoints[Number].IsEnabled = 1;
 8025404:	891a      	ldrh	r2, [r3, #8]
 8025406:	f042 0202 	orr.w	r2, r2, #2
 802540a:	811a      	strh	r2, [r3, #8]
		/* Start read for out endpoints */
		if (!(Table[i].Address & ENDPOINT_DIR_MASK))
 802540c:	f819 0c04 	ldrb.w	r0, [r9, #-4]
 8025410:	0602      	lsls	r2, r0, #24
 8025412:	f109 0906 	add.w	r9, r9, #6
 8025416:	d403      	bmi.n	8025420 <Endpoint_ConfigureEndpointTable+0x58>
			device.Driver->EndpointReadStart(Table[i].Address,
 8025418:	6832      	ldr	r2, [r6, #0]
 802541a:	6999      	ldr	r1, [r3, #24]
 802541c:	6a93      	ldr	r3, [r2, #40]	; 0x28
 802541e:	4798      	blx	r3

bool Endpoint_ConfigureEndpointTable(const USB_Endpoint_Table_t* const Table,
			                                     const uint8_t Entries) {
	uint8_t i;
	uint8_t Number;
	for (i=0;i<Entries;i++) {
 8025420:	45a9      	cmp	r9, r5
 8025422:	d013      	beq.n	802544c <Endpoint_ConfigureEndpointTable+0x84>
		Number = Table[i].Address & ENDPOINT_EPNUM_MASK;
 8025424:	f819 3c04 	ldrb.w	r3, [r9, #-4]
		/* Configure endpoint in device controller driver */
		if (device.Driver->EndpointConfigure(Table[i].Address,
 8025428:	683a      	ldr	r2, [r7, #0]
 802542a:	f899 1000 	ldrb.w	r1, [r9]
 802542e:	f8d2 c01c 	ldr.w	ip, [r2, #28]
 8025432:	f839 2c02 	ldrh.w	r2, [r9, #-2]
 8025436:	4618      	mov	r0, r3
bool Endpoint_ConfigureEndpointTable(const USB_Endpoint_Table_t* const Table,
			                                     const uint8_t Entries) {
	uint8_t i;
	uint8_t Number;
	for (i=0;i<Entries;i++) {
		Number = Table[i].Address & ENDPOINT_EPNUM_MASK;
 8025438:	f003 040f 	and.w	r4, r3, #15
		/* Configure endpoint in device controller driver */
		if (device.Driver->EndpointConfigure(Table[i].Address,
 802543c:	47e0      	blx	ip
				(XMC_USBD_ENDPOINT_TYPE_t)Table[i].Type,Table[i].Size) !=
																XMC_USBD_STATUS_OK)
			return false;
		/* Set device core values */
		device.Endpoints[Number].Address = Table[i].Address;
 802543e:	fb08 6304 	mla	r3, r8, r4, r6
	uint8_t i;
	uint8_t Number;
	for (i=0;i<Entries;i++) {
		Number = Table[i].Address & ENDPOINT_EPNUM_MASK;
		/* Configure endpoint in device controller driver */
		if (device.Driver->EndpointConfigure(Table[i].Address,
 8025442:	2800      	cmp	r0, #0
 8025444:	d0d1      	beq.n	80253ea <Endpoint_ConfigureEndpointTable+0x22>
				(XMC_USBD_ENDPOINT_TYPE_t)Table[i].Type,Table[i].Size) !=
																XMC_USBD_STATUS_OK)
			return false;
 8025446:	2000      	movs	r0, #0
		if (!(Table[i].Address & ENDPOINT_DIR_MASK))
			device.Driver->EndpointReadStart(Table[i].Address,
					device.Endpoints[Number].OutBufferLength);
	}
	return true;
}
 8025448:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		/* Start read for out endpoints */
		if (!(Table[i].Address & ENDPOINT_DIR_MASK))
			device.Driver->EndpointReadStart(Table[i].Address,
					device.Endpoints[Number].OutBufferLength);
	}
	return true;
 802544c:	2001      	movs	r0, #1
 802544e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8025452:	2001      	movs	r0, #1
}
 8025454:	4770      	bx	lr
 8025456:	bf00      	nop
 8025458:	1fff0594 	.word	0x1fff0594

0802545c <USBD_SignalDeviceEventHandler>:
 */
static void USBD_SignalDeviceEventHandler(XMC_USBD_EVENT_t event)
{
  uint32_t i;

  switch (event)
 802545c:	2809      	cmp	r0, #9
 802545e:	d80e      	bhi.n	802547e <USBD_SignalDeviceEventHandler+0x22>
 8025460:	e8df f010 	tbh	[pc, r0, lsl #1]
 8025464:	0019000a 	.word	0x0019000a
 8025468:	002a0023 	.word	0x002a0023
 802546c:	000d0034 	.word	0x000d0034
 8025470:	000e00e8 	.word	0x000e00e8
 8025474:	00f6000d 	.word	0x00f6000d
      {
        device.events->disconnect();
      }
      break;
    case XMC_USBD_EVENT_POWER_ON:
      USB_DeviceState = (uint8_t)DEVICE_STATE_Powered;
 8025478:	4bb7      	ldr	r3, [pc, #732]	; (8025758 <USBD_SignalDeviceEventHandler+0x2fc>)
 802547a:	2201      	movs	r2, #1
 802547c:	701a      	strb	r2, [r3, #0]
 802547e:	4770      	bx	lr
      break;
    case XMC_USBD_EVENT_REMOTE_WAKEUP:
      break;
    case XMC_USBD_EVENT_RESUME:
      USB_DeviceState = (uint8_t)device.pre_suspend_device_state;
 8025480:	4bb6      	ldr	r3, [pc, #728]	; (802575c <USBD_SignalDeviceEventHandler+0x300>)
 8025482:	4ab5      	ldr	r2, [pc, #724]	; (8025758 <USBD_SignalDeviceEventHandler+0x2fc>)
      if (NULL != device.events->wakeup)
 8025484:	f8d3 0140 	ldr.w	r0, [r3, #320]	; 0x140
      USB_DeviceState = (uint8_t)DEVICE_STATE_Powered;
      break;
    case XMC_USBD_EVENT_REMOTE_WAKEUP:
      break;
    case XMC_USBD_EVENT_RESUME:
      USB_DeviceState = (uint8_t)device.pre_suspend_device_state;
 8025488:	f893 113a 	ldrb.w	r1, [r3, #314]	; 0x13a
      if (NULL != device.events->wakeup)
 802548c:	6983      	ldr	r3, [r0, #24]
      USB_DeviceState = (uint8_t)DEVICE_STATE_Powered;
      break;
    case XMC_USBD_EVENT_REMOTE_WAKEUP:
      break;
    case XMC_USBD_EVENT_RESUME:
      USB_DeviceState = (uint8_t)device.pre_suspend_device_state;
 802548e:	7011      	strb	r1, [r2, #0]
      if (NULL != device.events->wakeup)
 8025490:	2b00      	cmp	r3, #0
 8025492:	d0f4      	beq.n	802547e <USBD_SignalDeviceEventHandler+0x22>
      {
        device.events->wakeup();
 8025494:	4718      	bx	r3
        device.events->disconnect();
      }
      break;
    case XMC_USBD_EVENT_POWER_OFF:
      USB_DeviceState = (uint8_t)DEVICE_STATE_Unattached;
      if (NULL != device.events->disconnect)
 8025496:	4bb1      	ldr	r3, [pc, #708]	; (802575c <USBD_SignalDeviceEventHandler+0x300>)
      {
        device.events->disconnect();
      }
      break;
    case XMC_USBD_EVENT_POWER_OFF:
      USB_DeviceState = (uint8_t)DEVICE_STATE_Unattached;
 8025498:	4aaf      	ldr	r2, [pc, #700]	; (8025758 <USBD_SignalDeviceEventHandler+0x2fc>)
      if (NULL != device.events->disconnect)
 802549a:	f8d3 3140 	ldr.w	r3, [r3, #320]	; 0x140
 802549e:	685b      	ldr	r3, [r3, #4]
      {
        device.events->disconnect();
      }
      break;
    case XMC_USBD_EVENT_POWER_OFF:
      USB_DeviceState = (uint8_t)DEVICE_STATE_Unattached;
 80254a0:	2100      	movs	r1, #0
 80254a2:	7011      	strb	r1, [r2, #0]
      if (NULL != device.events->disconnect)
 80254a4:	2b00      	cmp	r3, #0
 80254a6:	d1f5      	bne.n	8025494 <USBD_SignalDeviceEventHandler+0x38>
 80254a8:	e7e9      	b.n	802547e <USBD_SignalDeviceEventHandler+0x22>
      {
        device.events->start_of_frame();
      }
      break;
    case XMC_USBD_EVENT_CONNECT:
      if (NULL != device.events->connect)
 80254aa:	4bac      	ldr	r3, [pc, #688]	; (802575c <USBD_SignalDeviceEventHandler+0x300>)
 80254ac:	f8d3 3140 	ldr.w	r3, [r3, #320]	; 0x140
 80254b0:	681b      	ldr	r3, [r3, #0]
 80254b2:	2b00      	cmp	r3, #0
 80254b4:	d1ee      	bne.n	8025494 <USBD_SignalDeviceEventHandler+0x38>
 80254b6:	e7e2      	b.n	802547e <USBD_SignalDeviceEventHandler+0x22>
        device.events->connect();
      }
      break;
    case XMC_USBD_EVENT_DISCONNECT:
      USB_DeviceState = (uint8_t)DEVICE_STATE_Powered;
      if (NULL != device.events->disconnect)
 80254b8:	4ba8      	ldr	r3, [pc, #672]	; (802575c <USBD_SignalDeviceEventHandler+0x300>)
      {
        device.events->connect();
      }
      break;
    case XMC_USBD_EVENT_DISCONNECT:
      USB_DeviceState = (uint8_t)DEVICE_STATE_Powered;
 80254ba:	4aa7      	ldr	r2, [pc, #668]	; (8025758 <USBD_SignalDeviceEventHandler+0x2fc>)
      if (NULL != device.events->disconnect)
 80254bc:	f8d3 3140 	ldr.w	r3, [r3, #320]	; 0x140
 80254c0:	685b      	ldr	r3, [r3, #4]
      {
        device.events->connect();
      }
      break;
    case XMC_USBD_EVENT_DISCONNECT:
      USB_DeviceState = (uint8_t)DEVICE_STATE_Powered;
 80254c2:	2101      	movs	r1, #1
 80254c4:	7011      	strb	r1, [r2, #0]
      if (NULL != device.events->disconnect)
 80254c6:	2b00      	cmp	r3, #0
 80254c8:	d1e4      	bne.n	8025494 <USBD_SignalDeviceEventHandler+0x38>
 80254ca:	e7d8      	b.n	802547e <USBD_SignalDeviceEventHandler+0x22>
 * The device can have several events, by which it notifies the application about the occurance of event.
 * Not all events are available on all chip series. (Power Events are only supported on XMC4500)
 *
 */
static void USBD_SignalDeviceEventHandler(XMC_USBD_EVENT_t event)
{
 80254cc:	b570      	push	{r4, r5, r6, lr}
  uint32_t i;

  switch (event)
  {
    case XMC_USBD_EVENT_RESET:
      USB_DeviceState = (uint8_t)DEVICE_STATE_Default;
 80254ce:	4ba2      	ldr	r3, [pc, #648]	; (8025758 <USBD_SignalDeviceEventHandler+0x2fc>)
      device.ep0_state = USBD_EP0_STATE_IDLE;
 80254d0:	4ca2      	ldr	r4, [pc, #648]	; (802575c <USBD_SignalDeviceEventHandler+0x300>)
  uint32_t i;

  switch (event)
  {
    case XMC_USBD_EVENT_RESET:
      USB_DeviceState = (uint8_t)DEVICE_STATE_Default;
 80254d2:	2202      	movs	r2, #2
 80254d4:	701a      	strb	r2, [r3, #0]
      device.ep0_state = USBD_EP0_STATE_IDLE;
      device.remote_wakeup = (uint8_t)0;
      /* Reset endpoints and configuration */
      for (i = ((uint32_t)XMC_USBD_NUM_EPS); i > 0U; i--)
      {
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].InInUse = (uint8_t)0;
 80254d6:	8922      	ldrh	r2, [r4, #8]
  switch (event)
  {
    case XMC_USBD_EVENT_RESET:
      USB_DeviceState = (uint8_t)DEVICE_STATE_Default;
      device.ep0_state = USBD_EP0_STATE_IDLE;
      device.remote_wakeup = (uint8_t)0;
 80254d8:	f894 313e 	ldrb.w	r3, [r4, #318]	; 0x13e
      /* Reset endpoints and configuration */
      for (i = ((uint32_t)XMC_USBD_NUM_EPS); i > 0U; i--)
      {
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].InInUse = (uint8_t)0;
 80254dc:	f36f 1204 	bfc	r2, #4, #1
 80254e0:	8122      	strh	r2, [r4, #8]
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
 80254e2:	8922      	ldrh	r2, [r4, #8]
 80254e4:	f36f 02c3 	bfc	r2, #3, #1
 80254e8:	8122      	strh	r2, [r4, #8]
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
 80254ea:	8922      	ldrh	r2, [r4, #8]
 80254ec:	f36f 0282 	bfc	r2, #2, #1
 80254f0:	8122      	strh	r2, [r4, #8]
      device.ep0_state = USBD_EP0_STATE_IDLE;
      device.remote_wakeup = (uint8_t)0;
      /* Reset endpoints and configuration */
      for (i = ((uint32_t)XMC_USBD_NUM_EPS); i > 0U; i--)
      {
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].InInUse = (uint8_t)0;
 80254f2:	8ea2      	ldrh	r2, [r4, #52]	; 0x34
 80254f4:	f36f 1204 	bfc	r2, #4, #1
 80254f8:	86a2      	strh	r2, [r4, #52]	; 0x34
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
 80254fa:	8ea2      	ldrh	r2, [r4, #52]	; 0x34
 80254fc:	f36f 02c3 	bfc	r2, #3, #1
 8025500:	86a2      	strh	r2, [r4, #52]	; 0x34
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
 8025502:	8ea2      	ldrh	r2, [r4, #52]	; 0x34
 8025504:	f36f 0282 	bfc	r2, #2, #1
 8025508:	86a2      	strh	r2, [r4, #52]	; 0x34
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
           (device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured))
 802550a:	f894 2034 	ldrb.w	r2, [r4, #52]	; 0x34
  switch (event)
  {
    case XMC_USBD_EVENT_RESET:
      USB_DeviceState = (uint8_t)DEVICE_STATE_Default;
      device.ep0_state = USBD_EP0_STATE_IDLE;
      device.remote_wakeup = (uint8_t)0;
 802550e:	f36f 0382 	bfc	r3, #2, #1

  switch (event)
  {
    case XMC_USBD_EVENT_RESET:
      USB_DeviceState = (uint8_t)DEVICE_STATE_Default;
      device.ep0_state = USBD_EP0_STATE_IDLE;
 8025512:	2101      	movs	r1, #1
      device.remote_wakeup = (uint8_t)0;
 8025514:	f884 313e 	strb.w	r3, [r4, #318]	; 0x13e
      for (i = ((uint32_t)XMC_USBD_NUM_EPS); i > 0U; i--)
      {
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].InInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
 8025518:	07d3      	lsls	r3, r2, #31

  switch (event)
  {
    case XMC_USBD_EVENT_RESET:
      USB_DeviceState = (uint8_t)DEVICE_STATE_Default;
      device.ep0_state = USBD_EP0_STATE_IDLE;
 802551a:	f884 113b 	strb.w	r1, [r4, #315]	; 0x13b
      for (i = ((uint32_t)XMC_USBD_NUM_EPS); i > 0U; i--)
      {
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].InInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
 802551e:	f100 809f 	bmi.w	8025660 <USBD_SignalDeviceEventHandler+0x204>
      device.ep0_state = USBD_EP0_STATE_IDLE;
      device.remote_wakeup = (uint8_t)0;
      /* Reset endpoints and configuration */
      for (i = ((uint32_t)XMC_USBD_NUM_EPS); i > 0U; i--)
      {
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].InInUse = (uint8_t)0;
 8025522:	f8b4 3060 	ldrh.w	r3, [r4, #96]	; 0x60
 8025526:	4d8d      	ldr	r5, [pc, #564]	; (802575c <USBD_SignalDeviceEventHandler+0x300>)
 8025528:	f36f 1304 	bfc	r3, #4, #1
 802552c:	f8a4 3060 	strh.w	r3, [r4, #96]	; 0x60
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
 8025530:	f8b4 3060 	ldrh.w	r3, [r4, #96]	; 0x60
 8025534:	f36f 03c3 	bfc	r3, #3, #1
 8025538:	f8a4 3060 	strh.w	r3, [r4, #96]	; 0x60
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
 802553c:	f8b4 3060 	ldrh.w	r3, [r4, #96]	; 0x60
 8025540:	f36f 0382 	bfc	r3, #2, #1
 8025544:	f8a4 3060 	strh.w	r3, [r4, #96]	; 0x60
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
           (device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured))
 8025548:	f894 3060 	ldrb.w	r3, [r4, #96]	; 0x60
      for (i = ((uint32_t)XMC_USBD_NUM_EPS); i > 0U; i--)
      {
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].InInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
 802554c:	07de      	lsls	r6, r3, #31
 802554e:	f100 80ec 	bmi.w	802572a <USBD_SignalDeviceEventHandler+0x2ce>
      device.ep0_state = USBD_EP0_STATE_IDLE;
      device.remote_wakeup = (uint8_t)0;
      /* Reset endpoints and configuration */
      for (i = ((uint32_t)XMC_USBD_NUM_EPS); i > 0U; i--)
      {
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].InInUse = (uint8_t)0;
 8025552:	f8b4 308c 	ldrh.w	r3, [r4, #140]	; 0x8c
 8025556:	4d81      	ldr	r5, [pc, #516]	; (802575c <USBD_SignalDeviceEventHandler+0x300>)
 8025558:	f36f 1304 	bfc	r3, #4, #1
 802555c:	f8a4 308c 	strh.w	r3, [r4, #140]	; 0x8c
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
 8025560:	f8b4 308c 	ldrh.w	r3, [r4, #140]	; 0x8c
 8025564:	f36f 03c3 	bfc	r3, #3, #1
 8025568:	f8a4 308c 	strh.w	r3, [r4, #140]	; 0x8c
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
 802556c:	f8b4 308c 	ldrh.w	r3, [r4, #140]	; 0x8c
 8025570:	f36f 0382 	bfc	r3, #2, #1
 8025574:	f8a4 308c 	strh.w	r3, [r4, #140]	; 0x8c
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
           (device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured))
 8025578:	f894 308c 	ldrb.w	r3, [r4, #140]	; 0x8c
      for (i = ((uint32_t)XMC_USBD_NUM_EPS); i > 0U; i--)
      {
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].InInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
 802557c:	07d8      	lsls	r0, r3, #31
 802557e:	f100 80bf 	bmi.w	8025700 <USBD_SignalDeviceEventHandler+0x2a4>
      device.ep0_state = USBD_EP0_STATE_IDLE;
      device.remote_wakeup = (uint8_t)0;
      /* Reset endpoints and configuration */
      for (i = ((uint32_t)XMC_USBD_NUM_EPS); i > 0U; i--)
      {
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].InInUse = (uint8_t)0;
 8025582:	f8b4 30b8 	ldrh.w	r3, [r4, #184]	; 0xb8
 8025586:	4d75      	ldr	r5, [pc, #468]	; (802575c <USBD_SignalDeviceEventHandler+0x300>)
 8025588:	f36f 1304 	bfc	r3, #4, #1
 802558c:	f8a4 30b8 	strh.w	r3, [r4, #184]	; 0xb8
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
 8025590:	f8b4 30b8 	ldrh.w	r3, [r4, #184]	; 0xb8
 8025594:	f36f 03c3 	bfc	r3, #3, #1
 8025598:	f8a4 30b8 	strh.w	r3, [r4, #184]	; 0xb8
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
 802559c:	f8b4 30b8 	ldrh.w	r3, [r4, #184]	; 0xb8
 80255a0:	f36f 0382 	bfc	r3, #2, #1
 80255a4:	f8a4 30b8 	strh.w	r3, [r4, #184]	; 0xb8
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
           (device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured))
 80255a8:	f894 30b8 	ldrb.w	r3, [r4, #184]	; 0xb8
      for (i = ((uint32_t)XMC_USBD_NUM_EPS); i > 0U; i--)
      {
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].InInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
 80255ac:	07d9      	lsls	r1, r3, #31
 80255ae:	f100 8092 	bmi.w	80256d6 <USBD_SignalDeviceEventHandler+0x27a>
      device.ep0_state = USBD_EP0_STATE_IDLE;
      device.remote_wakeup = (uint8_t)0;
      /* Reset endpoints and configuration */
      for (i = ((uint32_t)XMC_USBD_NUM_EPS); i > 0U; i--)
      {
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].InInUse = (uint8_t)0;
 80255b2:	f8b4 30e4 	ldrh.w	r3, [r4, #228]	; 0xe4
 80255b6:	4d69      	ldr	r5, [pc, #420]	; (802575c <USBD_SignalDeviceEventHandler+0x300>)
 80255b8:	f36f 1304 	bfc	r3, #4, #1
 80255bc:	f8a4 30e4 	strh.w	r3, [r4, #228]	; 0xe4
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
 80255c0:	f8b4 30e4 	ldrh.w	r3, [r4, #228]	; 0xe4
 80255c4:	f36f 03c3 	bfc	r3, #3, #1
 80255c8:	f8a4 30e4 	strh.w	r3, [r4, #228]	; 0xe4
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
 80255cc:	f8b4 30e4 	ldrh.w	r3, [r4, #228]	; 0xe4
 80255d0:	f36f 0382 	bfc	r3, #2, #1
 80255d4:	f8a4 30e4 	strh.w	r3, [r4, #228]	; 0xe4
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
           (device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured))
 80255d8:	f894 30e4 	ldrb.w	r3, [r4, #228]	; 0xe4
      for (i = ((uint32_t)XMC_USBD_NUM_EPS); i > 0U; i--)
      {
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].InInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
 80255dc:	07da      	lsls	r2, r3, #31
 80255de:	d466      	bmi.n	80256ae <USBD_SignalDeviceEventHandler+0x252>
      device.ep0_state = USBD_EP0_STATE_IDLE;
      device.remote_wakeup = (uint8_t)0;
      /* Reset endpoints and configuration */
      for (i = ((uint32_t)XMC_USBD_NUM_EPS); i > 0U; i--)
      {
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].InInUse = (uint8_t)0;
 80255e0:	f8b4 3110 	ldrh.w	r3, [r4, #272]	; 0x110
 80255e4:	4d5d      	ldr	r5, [pc, #372]	; (802575c <USBD_SignalDeviceEventHandler+0x300>)
 80255e6:	f36f 1304 	bfc	r3, #4, #1
 80255ea:	f8a4 3110 	strh.w	r3, [r4, #272]	; 0x110
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
 80255ee:	f8b4 3110 	ldrh.w	r3, [r4, #272]	; 0x110
 80255f2:	f36f 03c3 	bfc	r3, #3, #1
 80255f6:	f8a4 3110 	strh.w	r3, [r4, #272]	; 0x110
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
 80255fa:	f8b4 3110 	ldrh.w	r3, [r4, #272]	; 0x110
 80255fe:	f36f 0382 	bfc	r3, #2, #1
 8025602:	f8a4 3110 	strh.w	r3, [r4, #272]	; 0x110
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
           (device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured))
 8025606:	f894 3110 	ldrb.w	r3, [r4, #272]	; 0x110
      for (i = ((uint32_t)XMC_USBD_NUM_EPS); i > 0U; i--)
      {
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].InInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
 802560a:	07db      	lsls	r3, r3, #31
 802560c:	d43b      	bmi.n	8025686 <USBD_SignalDeviceEventHandler+0x22a>
            device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured = (uint8_t)0;
            device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsEnabled = (uint8_t)0;
          }
        }
      }
      device.configuration = (uint8_t)0;
 802560e:	2300      	movs	r3, #0
      for (i = ((uint32_t)NUM_INTERFACES); i > 0U; i--)
      {
        device.interface_settings[((uint32_t)NUM_INTERFACES - i)] = (uint8_t)0;
      }
      device.Driver->EndpointReadStart((uint8_t)device.Endpoints[0].Address,(uint32_t)USBD_EP0_3SETUP_PKT_SIZE);
 8025610:	6822      	ldr	r2, [r4, #0]
            device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured = (uint8_t)0;
            device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsEnabled = (uint8_t)0;
          }
        }
      }
      device.configuration = (uint8_t)0;
 8025612:	f884 3139 	strb.w	r3, [r4, #313]	; 0x139
      for (i = ((uint32_t)NUM_INTERFACES); i > 0U; i--)
      {
        device.interface_settings[((uint32_t)NUM_INTERFACES - i)] = (uint8_t)0;
 8025616:	f884 3138 	strb.w	r3, [r4, #312]	; 0x138
      }
      device.Driver->EndpointReadStart((uint8_t)device.Endpoints[0].Address,(uint32_t)USBD_EP0_3SETUP_PKT_SIZE);
 802561a:	6a93      	ldr	r3, [r2, #40]	; 0x28
 802561c:	7920      	ldrb	r0, [r4, #4]
 802561e:	2118      	movs	r1, #24
 8025620:	4798      	blx	r3
      if (NULL != device.events->reset)
 8025622:	f8d4 3140 	ldr.w	r3, [r4, #320]	; 0x140
 8025626:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8025628:	2b00      	cmp	r3, #0
 802562a:	f000 8093 	beq.w	8025754 <USBD_SignalDeviceEventHandler+0x2f8>
      }
      break;
    default:
      break;
  }
}
 802562e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        device.interface_settings[((uint32_t)NUM_INTERFACES - i)] = (uint8_t)0;
      }
      device.Driver->EndpointReadStart((uint8_t)device.Endpoints[0].Address,(uint32_t)USBD_EP0_3SETUP_PKT_SIZE);
      if (NULL != device.events->reset)
      {
        device.events->reset();
 8025632:	4718      	bx	r3
      {
        device.events->wakeup();
      }
      break;
    case XMC_USBD_EVENT_SUSPEND:
      device.pre_suspend_device_state = USB_DeviceState;
 8025634:	4a49      	ldr	r2, [pc, #292]	; (802575c <USBD_SignalDeviceEventHandler+0x300>)
 8025636:	4b48      	ldr	r3, [pc, #288]	; (8025758 <USBD_SignalDeviceEventHandler+0x2fc>)
      USB_DeviceState = (uint8_t)DEVICE_STATE_Suspended;
      if (NULL != device.events->suspend)
 8025638:	f8d2 1140 	ldr.w	r1, [r2, #320]	; 0x140
      {
        device.events->wakeup();
      }
      break;
    case XMC_USBD_EVENT_SUSPEND:
      device.pre_suspend_device_state = USB_DeviceState;
 802563c:	7818      	ldrb	r0, [r3, #0]
 802563e:	f882 013a 	strb.w	r0, [r2, #314]	; 0x13a
      USB_DeviceState = (uint8_t)DEVICE_STATE_Suspended;
      if (NULL != device.events->suspend)
 8025642:	69ca      	ldr	r2, [r1, #28]
        device.events->wakeup();
      }
      break;
    case XMC_USBD_EVENT_SUSPEND:
      device.pre_suspend_device_state = USB_DeviceState;
      USB_DeviceState = (uint8_t)DEVICE_STATE_Suspended;
 8025644:	2105      	movs	r1, #5
 8025646:	7019      	strb	r1, [r3, #0]
      if (NULL != device.events->suspend)
 8025648:	2a00      	cmp	r2, #0
 802564a:	f43f af18 	beq.w	802547e <USBD_SignalDeviceEventHandler+0x22>
      {
        device.events->suspend();
 802564e:	4710      	bx	r2
      {
        device.events->reset();
      }
      break;
    case XMC_USBD_EVENT_SOF:
      if (NULL != device.events->start_of_frame)
 8025650:	4b42      	ldr	r3, [pc, #264]	; (802575c <USBD_SignalDeviceEventHandler+0x300>)
 8025652:	f8d3 3140 	ldr.w	r3, [r3, #320]	; 0x140
 8025656:	6a1b      	ldr	r3, [r3, #32]
 8025658:	2b00      	cmp	r3, #0
 802565a:	f47f af1b 	bne.w	8025494 <USBD_SignalDeviceEventHandler+0x38>
 802565e:	e70e      	b.n	802547e <USBD_SignalDeviceEventHandler+0x22>
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
           (device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured))
        {
          if (USBD_STATUS_SUCCESS == 
          (USBD_STATUS_t)device.Driver->EndpointUnconfigure
 8025660:	6823      	ldr	r3, [r4, #0]
 8025662:	f894 0030 	ldrb.w	r0, [r4, #48]	; 0x30
 8025666:	6a1b      	ldr	r3, [r3, #32]
 8025668:	4798      	blx	r3
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
           (device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured))
        {
          if (USBD_STATUS_SUCCESS == 
 802566a:	2800      	cmp	r0, #0
 802566c:	f47f af59 	bne.w	8025522 <USBD_SignalDeviceEventHandler+0xc6>
          (USBD_STATUS_t)device.Driver->EndpointUnconfigure
          ((uint8_t)device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].Address))
          {
            device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured = (uint8_t)0;
 8025670:	f894 3034 	ldrb.w	r3, [r4, #52]	; 0x34
 8025674:	f360 0300 	bfi	r3, r0, #0, #1
 8025678:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
            device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsEnabled = (uint8_t)0;
 802567c:	8ea3      	ldrh	r3, [r4, #52]	; 0x34
 802567e:	f360 0341 	bfi	r3, r0, #1, #1
 8025682:	86a3      	strh	r3, [r4, #52]	; 0x34
 8025684:	e74d      	b.n	8025522 <USBD_SignalDeviceEventHandler+0xc6>
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
           (device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured))
        {
          if (USBD_STATUS_SUCCESS == 
          (USBD_STATUS_t)device.Driver->EndpointUnconfigure
 8025686:	682b      	ldr	r3, [r5, #0]
 8025688:	f895 010c 	ldrb.w	r0, [r5, #268]	; 0x10c
 802568c:	6a1b      	ldr	r3, [r3, #32]
 802568e:	4798      	blx	r3
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
           (device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured))
        {
          if (USBD_STATUS_SUCCESS == 
 8025690:	2800      	cmp	r0, #0
 8025692:	d1bc      	bne.n	802560e <USBD_SignalDeviceEventHandler+0x1b2>
          (USBD_STATUS_t)device.Driver->EndpointUnconfigure
          ((uint8_t)device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].Address))
          {
            device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured = (uint8_t)0;
 8025694:	f895 3110 	ldrb.w	r3, [r5, #272]	; 0x110
 8025698:	f360 0300 	bfi	r3, r0, #0, #1
 802569c:	f885 3110 	strb.w	r3, [r5, #272]	; 0x110
            device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsEnabled = (uint8_t)0;
 80256a0:	f8b5 3110 	ldrh.w	r3, [r5, #272]	; 0x110
 80256a4:	f360 0341 	bfi	r3, r0, #1, #1
 80256a8:	f8a5 3110 	strh.w	r3, [r5, #272]	; 0x110
 80256ac:	e7af      	b.n	802560e <USBD_SignalDeviceEventHandler+0x1b2>
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
           (device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured))
        {
          if (USBD_STATUS_SUCCESS == 
          (USBD_STATUS_t)device.Driver->EndpointUnconfigure
 80256ae:	682b      	ldr	r3, [r5, #0]
 80256b0:	f895 00e0 	ldrb.w	r0, [r5, #224]	; 0xe0
 80256b4:	6a1b      	ldr	r3, [r3, #32]
 80256b6:	4798      	blx	r3
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
           (device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured))
        {
          if (USBD_STATUS_SUCCESS == 
 80256b8:	2800      	cmp	r0, #0
 80256ba:	d191      	bne.n	80255e0 <USBD_SignalDeviceEventHandler+0x184>
          (USBD_STATUS_t)device.Driver->EndpointUnconfigure
          ((uint8_t)device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].Address))
          {
            device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured = (uint8_t)0;
 80256bc:	f895 30e4 	ldrb.w	r3, [r5, #228]	; 0xe4
 80256c0:	f360 0300 	bfi	r3, r0, #0, #1
 80256c4:	f885 30e4 	strb.w	r3, [r5, #228]	; 0xe4
            device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsEnabled = (uint8_t)0;
 80256c8:	f8b5 30e4 	ldrh.w	r3, [r5, #228]	; 0xe4
 80256cc:	f360 0341 	bfi	r3, r0, #1, #1
 80256d0:	f8a5 30e4 	strh.w	r3, [r5, #228]	; 0xe4
 80256d4:	e784      	b.n	80255e0 <USBD_SignalDeviceEventHandler+0x184>
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
           (device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured))
        {
          if (USBD_STATUS_SUCCESS == 
          (USBD_STATUS_t)device.Driver->EndpointUnconfigure
 80256d6:	682b      	ldr	r3, [r5, #0]
 80256d8:	f895 00b4 	ldrb.w	r0, [r5, #180]	; 0xb4
 80256dc:	6a1b      	ldr	r3, [r3, #32]
 80256de:	4798      	blx	r3
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
           (device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured))
        {
          if (USBD_STATUS_SUCCESS == 
 80256e0:	2800      	cmp	r0, #0
 80256e2:	f47f af66 	bne.w	80255b2 <USBD_SignalDeviceEventHandler+0x156>
          (USBD_STATUS_t)device.Driver->EndpointUnconfigure
          ((uint8_t)device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].Address))
          {
            device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured = (uint8_t)0;
 80256e6:	f895 30b8 	ldrb.w	r3, [r5, #184]	; 0xb8
 80256ea:	f360 0300 	bfi	r3, r0, #0, #1
 80256ee:	f885 30b8 	strb.w	r3, [r5, #184]	; 0xb8
            device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsEnabled = (uint8_t)0;
 80256f2:	f8b5 30b8 	ldrh.w	r3, [r5, #184]	; 0xb8
 80256f6:	f360 0341 	bfi	r3, r0, #1, #1
 80256fa:	f8a5 30b8 	strh.w	r3, [r5, #184]	; 0xb8
 80256fe:	e758      	b.n	80255b2 <USBD_SignalDeviceEventHandler+0x156>
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
           (device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured))
        {
          if (USBD_STATUS_SUCCESS == 
          (USBD_STATUS_t)device.Driver->EndpointUnconfigure
 8025700:	682b      	ldr	r3, [r5, #0]
 8025702:	f895 0088 	ldrb.w	r0, [r5, #136]	; 0x88
 8025706:	6a1b      	ldr	r3, [r3, #32]
 8025708:	4798      	blx	r3
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
           (device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured))
        {
          if (USBD_STATUS_SUCCESS == 
 802570a:	2800      	cmp	r0, #0
 802570c:	f47f af39 	bne.w	8025582 <USBD_SignalDeviceEventHandler+0x126>
          (USBD_STATUS_t)device.Driver->EndpointUnconfigure
          ((uint8_t)device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].Address))
          {
            device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured = (uint8_t)0;
 8025710:	f895 308c 	ldrb.w	r3, [r5, #140]	; 0x8c
 8025714:	f360 0300 	bfi	r3, r0, #0, #1
 8025718:	f885 308c 	strb.w	r3, [r5, #140]	; 0x8c
            device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsEnabled = (uint8_t)0;
 802571c:	f8b5 308c 	ldrh.w	r3, [r5, #140]	; 0x8c
 8025720:	f360 0341 	bfi	r3, r0, #1, #1
 8025724:	f8a5 308c 	strh.w	r3, [r5, #140]	; 0x8c
 8025728:	e72b      	b.n	8025582 <USBD_SignalDeviceEventHandler+0x126>
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
           (device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured))
        {
          if (USBD_STATUS_SUCCESS == 
          (USBD_STATUS_t)device.Driver->EndpointUnconfigure
 802572a:	682b      	ldr	r3, [r5, #0]
 802572c:	f895 005c 	ldrb.w	r0, [r5, #92]	; 0x5c
 8025730:	6a1b      	ldr	r3, [r3, #32]
 8025732:	4798      	blx	r3
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
           (device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured))
        {
          if (USBD_STATUS_SUCCESS == 
 8025734:	2800      	cmp	r0, #0
 8025736:	f47f af0c 	bne.w	8025552 <USBD_SignalDeviceEventHandler+0xf6>
          (USBD_STATUS_t)device.Driver->EndpointUnconfigure
          ((uint8_t)device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].Address))
          {
            device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured = (uint8_t)0;
 802573a:	f895 3060 	ldrb.w	r3, [r5, #96]	; 0x60
 802573e:	f360 0300 	bfi	r3, r0, #0, #1
 8025742:	f885 3060 	strb.w	r3, [r5, #96]	; 0x60
            device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsEnabled = (uint8_t)0;
 8025746:	f8b5 3060 	ldrh.w	r3, [r5, #96]	; 0x60
 802574a:	f360 0341 	bfi	r3, r0, #1, #1
 802574e:	f8a5 3060 	strh.w	r3, [r5, #96]	; 0x60
 8025752:	e6fe      	b.n	8025552 <USBD_SignalDeviceEventHandler+0xf6>
 8025754:	bd70      	pop	{r4, r5, r6, pc}
 8025756:	bf00      	nop
 8025758:	1fff0389 	.word	0x1fff0389
 802575c:	1fff0594 	.word	0x1fff0594

08025760 <USBD_HandleEP0_Stall>:
 *
 * Stalls EP0 and then restarts a new transfer including setting EP0 state to
 * 																\ref USBD_EP0_STATE_IDLE.
 */
static void USBD_HandleEP0_Stall(void)
{
 8025760:	b510      	push	{r4, lr}
  /* When we stall ep0 as protocol stall, we go back into idle state and
  * start a new read */
  if (USBD_STATUS_SUCCESS == (USBD_STATUS_t)device.Driver->EndpointStall(ENDPOINT_DIR_IN | 0U,1U))
 8025762:	4c08      	ldr	r4, [pc, #32]	; (8025784 <USBD_HandleEP0_Stall+0x24>)
 8025764:	6823      	ldr	r3, [r4, #0]
 8025766:	2080      	movs	r0, #128	; 0x80
 8025768:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 802576a:	2101      	movs	r1, #1
 802576c:	4798      	blx	r3
 802576e:	b100      	cbz	r0, 8025772 <USBD_HandleEP0_Stall+0x12>
 8025770:	bd10      	pop	{r4, pc}
  {
    device.ep0_state = USBD_EP0_STATE_IDLE;
    if ( USBD_STATUS_SUCCESS != (USBD_STATUS_t)device.Driver->EndpointReadStart(0U,USBD_EP0_3SETUP_PKT_SIZE))
 8025772:	6823      	ldr	r3, [r4, #0]
{
  /* When we stall ep0 as protocol stall, we go back into idle state and
  * start a new read */
  if (USBD_STATUS_SUCCESS == (USBD_STATUS_t)device.Driver->EndpointStall(ENDPOINT_DIR_IN | 0U,1U))
  {
    device.ep0_state = USBD_EP0_STATE_IDLE;
 8025774:	2201      	movs	r2, #1
    if ( USBD_STATUS_SUCCESS != (USBD_STATUS_t)device.Driver->EndpointReadStart(0U,USBD_EP0_3SETUP_PKT_SIZE))
 8025776:	6a9b      	ldr	r3, [r3, #40]	; 0x28
{
  /* When we stall ep0 as protocol stall, we go back into idle state and
  * start a new read */
  if (USBD_STATUS_SUCCESS == (USBD_STATUS_t)device.Driver->EndpointStall(ENDPOINT_DIR_IN | 0U,1U))
  {
    device.ep0_state = USBD_EP0_STATE_IDLE;
 8025778:	f884 213b 	strb.w	r2, [r4, #315]	; 0x13b
    if ( USBD_STATUS_SUCCESS != (USBD_STATUS_t)device.Driver->EndpointReadStart(0U,USBD_EP0_3SETUP_PKT_SIZE))
 802577c:	2118      	movs	r1, #24
    {
      XMC_ASSERT("USBD_HandleEP0_Stall: EndpointReadStart failed", 0);
    }
  }
}
 802577e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  /* When we stall ep0 as protocol stall, we go back into idle state and
  * start a new read */
  if (USBD_STATUS_SUCCESS == (USBD_STATUS_t)device.Driver->EndpointStall(ENDPOINT_DIR_IN | 0U,1U))
  {
    device.ep0_state = USBD_EP0_STATE_IDLE;
    if ( USBD_STATUS_SUCCESS != (USBD_STATUS_t)device.Driver->EndpointReadStart(0U,USBD_EP0_3SETUP_PKT_SIZE))
 8025782:	4718      	bx	r3
 8025784:	1fff0594 	.word	0x1fff0594

08025788 <USBD_Handle_DeviceRequest>:
 * handle some custom request or override the request handling in this function.
 * If the user has handled the request, he has to call \ref Endpoint_ClearSETUP.
 *
 */
static void USBD_Handle_DeviceRequest(void)
{
 8025788:	b570      	push	{r4, r5, r6, lr}
  

  value = (uint32_t)USB_ControlRequest.wValue & (uint32_t)USBD_BYTE_MASK;

  /* Handling of class/vendor requests */
  if (NULL != device.events->control_request)
 802578a:	4ca2      	ldr	r4, [pc, #648]	; (8025a14 <USBD_Handle_DeviceRequest+0x28c>)
  uint32_t value;
  uint32_t tmp_value;
  uint32_t tmp_index;
  

  value = (uint32_t)USB_ControlRequest.wValue & (uint32_t)USBD_BYTE_MASK;
 802578c:	4ea2      	ldr	r6, [pc, #648]	; (8025a18 <USBD_Handle_DeviceRequest+0x290>)

  /* Handling of class/vendor requests */
  if (NULL != device.events->control_request)
 802578e:	f8d4 3140 	ldr.w	r3, [r4, #320]	; 0x140
  uint32_t value;
  uint32_t tmp_value;
  uint32_t tmp_index;
  

  value = (uint32_t)USB_ControlRequest.wValue & (uint32_t)USBD_BYTE_MASK;
 8025792:	8870      	ldrh	r0, [r6, #2]

  /* Handling of class/vendor requests */
  if (NULL != device.events->control_request)
 8025794:	68da      	ldr	r2, [r3, #12]
 * handle some custom request or override the request handling in this function.
 * If the user has handled the request, he has to call \ref Endpoint_ClearSETUP.
 *
 */
static void USBD_Handle_DeviceRequest(void)
{
 8025796:	b082      	sub	sp, #8
  uint32_t length = 0U;
  uint32_t ret;
  void *buffer = NULL;
 8025798:	2300      	movs	r3, #0
  uint32_t value;
  uint32_t tmp_value;
  uint32_t tmp_index;
  

  value = (uint32_t)USB_ControlRequest.wValue & (uint32_t)USBD_BYTE_MASK;
 802579a:	b285      	uxth	r5, r0
 */
static void USBD_Handle_DeviceRequest(void)
{
  uint32_t length = 0U;
  uint32_t ret;
  void *buffer = NULL;
 802579c:	9300      	str	r3, [sp, #0]
  uint32_t status = 0U;
 802579e:	9301      	str	r3, [sp, #4]
  

  value = (uint32_t)USB_ControlRequest.wValue & (uint32_t)USBD_BYTE_MASK;

  /* Handling of class/vendor requests */
  if (NULL != device.events->control_request)
 80257a0:	b102      	cbz	r2, 80257a4 <USBD_Handle_DeviceRequest+0x1c>
  {
    device.events->control_request();
 80257a2:	4790      	blx	r2
  }

  if (1U == device.IsSetupRecieved)
 80257a4:	f894 313e 	ldrb.w	r3, [r4, #318]	; 0x13e
 80257a8:	079b      	lsls	r3, r3, #30
 80257aa:	d407      	bmi.n	80257bc <USBD_Handle_DeviceRequest+0x34>
      default:
        USBD_HandleEP0_Stall();
        break;
    }
  }
  device.IsSetupRecieved = 0U;
 80257ac:	f894 313e 	ldrb.w	r3, [r4, #318]	; 0x13e
 80257b0:	f023 0302 	bic.w	r3, r3, #2
 80257b4:	f884 313e 	strb.w	r3, [r4, #318]	; 0x13e
}
 80257b8:	b002      	add	sp, #8
 80257ba:	bd70      	pop	{r4, r5, r6, pc}
  }

  if (1U == device.IsSetupRecieved)
  {
    /* default request handling */
    switch (USB_ControlRequest.bRequest)
 80257bc:	7873      	ldrb	r3, [r6, #1]
  uint32_t value;
  uint32_t tmp_value;
  uint32_t tmp_index;
  

  value = (uint32_t)USB_ControlRequest.wValue & (uint32_t)USBD_BYTE_MASK;
 80257be:	b2ed      	uxtb	r5, r5
  }

  if (1U == device.IsSetupRecieved)
  {
    /* default request handling */
    switch (USB_ControlRequest.bRequest)
 80257c0:	2b0c      	cmp	r3, #12
 80257c2:	d816      	bhi.n	80257f2 <USBD_Handle_DeviceRequest+0x6a>
 80257c4:	e8df f013 	tbh	[pc, r3, lsl #1]
 80257c8:	00be0025 	.word	0x00be0025
 80257cc:	009d0015 	.word	0x009d0015
 80257d0:	00d00015 	.word	0x00d00015
 80257d4:	00150056 	.word	0x00150056
 80257d8:	008a0083 	.word	0x008a0083
 80257dc:	0078000d 	.word	0x0078000d
 80257e0:	0015      	.short	0x0015
          device.Endpoints[0].InDataBuffer = (uint8_t *)buffer + ret;
        }
        break;

      case REQ_GetInterface:
        if ((uint8_t)DEVICE_STATE_Configured == USB_DeviceState)
 80257e2:	4b8e      	ldr	r3, [pc, #568]	; (8025a1c <USBD_Handle_DeviceRequest+0x294>)
 80257e4:	781a      	ldrb	r2, [r3, #0]
 80257e6:	2a04      	cmp	r2, #4
 80257e8:	f000 8136 	beq.w	8025a58 <USBD_Handle_DeviceRequest+0x2d0>
          tmp_value = (uint32_t)USB_ControlRequest.wValue;
          tmp_index = (uint32_t)USB_ControlRequest.wIndex;
          device.interface_settings[tmp_index] =	(uint8_t)tmp_value;
          break;
        }
        if ((uint8_t)DEVICE_STATE_Addressed == USB_DeviceState)
 80257ec:	781b      	ldrb	r3, [r3, #0]
 80257ee:	2b03      	cmp	r3, #3
 80257f0:	d1dc      	bne.n	80257ac <USBD_Handle_DeviceRequest+0x24>
 */
static void USBD_HandleEP0_Stall(void)
{
  /* When we stall ep0 as protocol stall, we go back into idle state and
  * start a new read */
  if (USBD_STATUS_SUCCESS == (USBD_STATUS_t)device.Driver->EndpointStall(ENDPOINT_DIR_IN | 0U,1U))
 80257f2:	6823      	ldr	r3, [r4, #0]
 80257f4:	4d87      	ldr	r5, [pc, #540]	; (8025a14 <USBD_Handle_DeviceRequest+0x28c>)
 80257f6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80257f8:	2080      	movs	r0, #128	; 0x80
 80257fa:	2101      	movs	r1, #1
 80257fc:	4798      	blx	r3
 80257fe:	2800      	cmp	r0, #0
 8025800:	d1d4      	bne.n	80257ac <USBD_Handle_DeviceRequest+0x24>
  {
    device.ep0_state = USBD_EP0_STATE_IDLE;
    if ( USBD_STATUS_SUCCESS != (USBD_STATUS_t)device.Driver->EndpointReadStart(0U,USBD_EP0_3SETUP_PKT_SIZE))
 8025802:	682b      	ldr	r3, [r5, #0]
{
  /* When we stall ep0 as protocol stall, we go back into idle state and
  * start a new read */
  if (USBD_STATUS_SUCCESS == (USBD_STATUS_t)device.Driver->EndpointStall(ENDPOINT_DIR_IN | 0U,1U))
  {
    device.ep0_state = USBD_EP0_STATE_IDLE;
 8025804:	2201      	movs	r2, #1
    if ( USBD_STATUS_SUCCESS != (USBD_STATUS_t)device.Driver->EndpointReadStart(0U,USBD_EP0_3SETUP_PKT_SIZE))
 8025806:	6a9b      	ldr	r3, [r3, #40]	; 0x28
{
  /* When we stall ep0 as protocol stall, we go back into idle state and
  * start a new read */
  if (USBD_STATUS_SUCCESS == (USBD_STATUS_t)device.Driver->EndpointStall(ENDPOINT_DIR_IN | 0U,1U))
  {
    device.ep0_state = USBD_EP0_STATE_IDLE;
 8025808:	f885 213b 	strb.w	r2, [r5, #315]	; 0x13b
    if ( USBD_STATUS_SUCCESS != (USBD_STATUS_t)device.Driver->EndpointReadStart(0U,USBD_EP0_3SETUP_PKT_SIZE))
 802580c:	2118      	movs	r1, #24
 802580e:	4798      	blx	r3
 8025810:	e7cc      	b.n	80257ac <USBD_Handle_DeviceRequest+0x24>
          break;
        }
        break;

      case REQ_GetStatus:
        if (REQREC_DEVICE == ((uint32_t)USB_ControlRequest.bmRequestType & REQ_RECIPIENT_MASK))
 8025812:	7830      	ldrb	r0, [r6, #0]
 8025814:	4b80      	ldr	r3, [pc, #512]	; (8025a18 <USBD_Handle_DeviceRequest+0x290>)
 8025816:	f010 0003 	ands.w	r0, r0, #3
 802581a:	f000 8103 	beq.w	8025a24 <USBD_Handle_DeviceRequest+0x29c>
          {
            XMC_ASSERT("USBD_Handle_DeviceRequest: EndpointWrite failed on REQ_GetStatus", 0);
          }          
          break;
        }
        if ((REQREC_INTERFACE == ((uint32_t)USB_ControlRequest.bmRequestType & REQ_RECIPIENT_MASK)) &&
 802581e:	781b      	ldrb	r3, [r3, #0]
 8025820:	f003 0303 	and.w	r3, r3, #3
 8025824:	2b01      	cmp	r3, #1
 8025826:	f000 80e7 	beq.w	80259f8 <USBD_Handle_DeviceRequest+0x270>
            XMC_ASSERT("USBD_Handle_DeviceRequest: EndpointWrite failed on REQ_GetStatus- REQREC_INTERFACE", 0);
          }          
          break;
        }

        if (REQREC_ENDPOINT == ((uint32_t)USB_ControlRequest.bmRequestType & REQ_RECIPIENT_MASK))
 802582a:	7833      	ldrb	r3, [r6, #0]
 802582c:	4a7a      	ldr	r2, [pc, #488]	; (8025a18 <USBD_Handle_DeviceRequest+0x290>)
 802582e:	f003 0303 	and.w	r3, r3, #3
 8025832:	2b02      	cmp	r3, #2
 8025834:	d1dd      	bne.n	80257f2 <USBD_Handle_DeviceRequest+0x6a>
        {
          index = (uint32_t)(USB_ControlRequest.wIndex & USBD_BYTE_MASK & ENDPOINT_EPNUM_MASK);
          if ((((uint8_t)DEVICE_STATE_Configured == USB_DeviceState) || ((uint16_t)0 == USB_ControlRequest.wIndex)) &&
 8025836:	4979      	ldr	r1, [pc, #484]	; (8025a1c <USBD_Handle_DeviceRequest+0x294>)
          break;
        }

        if (REQREC_ENDPOINT == ((uint32_t)USB_ControlRequest.bmRequestType & REQ_RECIPIENT_MASK))
        {
          index = (uint32_t)(USB_ControlRequest.wIndex & USBD_BYTE_MASK & ENDPOINT_EPNUM_MASK);
 8025838:	8893      	ldrh	r3, [r2, #4]
          if ((((uint8_t)DEVICE_STATE_Configured == USB_DeviceState) || ((uint16_t)0 == USB_ControlRequest.wIndex)) &&
 802583a:	7809      	ldrb	r1, [r1, #0]
 802583c:	2904      	cmp	r1, #4
          break;
        }

        if (REQREC_ENDPOINT == ((uint32_t)USB_ControlRequest.bmRequestType & REQ_RECIPIENT_MASK))
        {
          index = (uint32_t)(USB_ControlRequest.wIndex & USBD_BYTE_MASK & ENDPOINT_EPNUM_MASK);
 802583e:	b29b      	uxth	r3, r3
          if ((((uint8_t)DEVICE_STATE_Configured == USB_DeviceState) || ((uint16_t)0 == USB_ControlRequest.wIndex)) &&
 8025840:	d003      	beq.n	802584a <USBD_Handle_DeviceRequest+0xc2>
 8025842:	8892      	ldrh	r2, [r2, #4]
 8025844:	b292      	uxth	r2, r2
 8025846:	2a00      	cmp	r2, #0
 8025848:	d1d3      	bne.n	80257f2 <USBD_Handle_DeviceRequest+0x6a>
              (1U == device.Endpoints[index].IsConfigured))
 802584a:	222c      	movs	r2, #44	; 0x2c
          break;
        }

        if (REQREC_ENDPOINT == ((uint32_t)USB_ControlRequest.bmRequestType & REQ_RECIPIENT_MASK))
        {
          index = (uint32_t)(USB_ControlRequest.wIndex & USBD_BYTE_MASK & ENDPOINT_EPNUM_MASK);
 802584c:	f003 030f 	and.w	r3, r3, #15
          if ((((uint8_t)DEVICE_STATE_Configured == USB_DeviceState) || ((uint16_t)0 == USB_ControlRequest.wIndex)) &&
              (1U == device.Endpoints[index].IsConfigured))
 8025850:	fb02 4303 	mla	r3, r2, r3, r4
 8025854:	496f      	ldr	r1, [pc, #444]	; (8025a14 <USBD_Handle_DeviceRequest+0x28c>)
 8025856:	7a1a      	ldrb	r2, [r3, #8]
        }

        if (REQREC_ENDPOINT == ((uint32_t)USB_ControlRequest.bmRequestType & REQ_RECIPIENT_MASK))
        {
          index = (uint32_t)(USB_ControlRequest.wIndex & USBD_BYTE_MASK & ENDPOINT_EPNUM_MASK);
          if ((((uint8_t)DEVICE_STATE_Configured == USB_DeviceState) || ((uint16_t)0 == USB_ControlRequest.wIndex)) &&
 8025858:	07d0      	lsls	r0, r2, #31
 802585a:	d5ca      	bpl.n	80257f2 <USBD_Handle_DeviceRequest+0x6a>
              (1U == device.Endpoints[index].IsConfigured))
          {
            status = (uint32_t)device.Endpoints[index].IsHalted;
 802585c:	689b      	ldr	r3, [r3, #8]
            if (0U == (uint32_t)device.Driver->EndpointWrite(0U, (uint8_t*)&status, USBD_WORD_SIZE))
 802585e:	680a      	ldr	r2, [r1, #0]
        {
          index = (uint32_t)(USB_ControlRequest.wIndex & USBD_BYTE_MASK & ENDPOINT_EPNUM_MASK);
          if ((((uint8_t)DEVICE_STATE_Configured == USB_DeviceState) || ((uint16_t)0 == USB_ControlRequest.wIndex)) &&
              (1U == device.Endpoints[index].IsConfigured))
          {
            status = (uint32_t)device.Endpoints[index].IsHalted;
 8025860:	a902      	add	r1, sp, #8
 8025862:	f3c3 0380 	ubfx	r3, r3, #2, #1
 8025866:	f841 3d04 	str.w	r3, [r1, #-4]!
            if (0U == (uint32_t)device.Driver->EndpointWrite(0U, (uint8_t*)&status, USBD_WORD_SIZE))
 802586a:	2000      	movs	r0, #0
 802586c:	6b13      	ldr	r3, [r2, #48]	; 0x30
 802586e:	2202      	movs	r2, #2
 8025870:	4798      	blx	r3
            {
              XMC_ASSERT("USBD_Handle_DeviceRequest: EndpointWrite failed on REQ_GetStatus- REQREC_ENDPOINT", 0);
            }              
            break;
 8025872:	e79b      	b.n	80257ac <USBD_Handle_DeviceRequest+0x24>
          XMC_ASSERT("USBD_Handle_DeviceRequest: EndpointWrite failed on get configuration request", 0);
        }
        break;

      case REQ_GetDescriptor:
        if (NULL != device.events->get_descriptor)
 8025874:	f8d4 3140 	ldr.w	r3, [r4, #320]	; 0x140
 8025878:	695b      	ldr	r3, [r3, #20]
 802587a:	2b00      	cmp	r3, #0
 802587c:	d0b9      	beq.n	80257f2 <USBD_Handle_DeviceRequest+0x6a>
        {
          tmp_value = (uint32_t)USB_ControlRequest.wValue;
 802587e:	8870      	ldrh	r0, [r6, #2]
          tmp_index = (uint32_t)USB_ControlRequest.wIndex;
 8025880:	88b1      	ldrh	r1, [r6, #4]
        break;

      case REQ_GetDescriptor:
        if (NULL != device.events->get_descriptor)
        {
          tmp_value = (uint32_t)USB_ControlRequest.wValue;
 8025882:	4e65      	ldr	r6, [pc, #404]	; (8025a18 <USBD_Handle_DeviceRequest+0x290>)
          tmp_index = (uint32_t)USB_ControlRequest.wIndex;
          length = (uint32_t)device.events->get_descriptor((uint16_t)tmp_value, (uint16_t)tmp_index, (void*)&buffer);
 8025884:	b280      	uxth	r0, r0
 8025886:	b289      	uxth	r1, r1
 8025888:	466a      	mov	r2, sp
 802588a:	4798      	blx	r3
        }

        if (0U == length)
 802588c:	4605      	mov	r5, r0
 802588e:	2800      	cmp	r0, #0
 8025890:	d0af      	beq.n	80257f2 <USBD_Handle_DeviceRequest+0x6a>
        {
          USBD_HandleEP0_Stall();
        }
        else
        {
          if (length >= (uint32_t)USB_ControlRequest.wLength)
 8025892:	88f3      	ldrh	r3, [r6, #6]
          {
            length = (uint32_t)USB_ControlRequest.wLength;
          }

          ret = (uint32_t)device.Driver->EndpointWrite(0U,buffer,length);
 8025894:	9900      	ldr	r1, [sp, #0]
        {
          USBD_HandleEP0_Stall();
        }
        else
        {
          if (length >= (uint32_t)USB_ControlRequest.wLength)
 8025896:	b29b      	uxth	r3, r3
 8025898:	4298      	cmp	r0, r3
          {
            length = (uint32_t)USB_ControlRequest.wLength;
 802589a:	bf28      	it	cs
 802589c:	88f5      	ldrhcs	r5, [r6, #6]
          }

          ret = (uint32_t)device.Driver->EndpointWrite(0U,buffer,length);
 802589e:	6823      	ldr	r3, [r4, #0]
        }
        else
        {
          if (length >= (uint32_t)USB_ControlRequest.wLength)
          {
            length = (uint32_t)USB_ControlRequest.wLength;
 80258a0:	bf28      	it	cs
 80258a2:	b2ad      	uxthcs	r5, r5
          }

          ret = (uint32_t)device.Driver->EndpointWrite(0U,buffer,length);
 80258a4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80258a6:	462a      	mov	r2, r5
 80258a8:	2000      	movs	r0, #0
 80258aa:	4798      	blx	r3
          device.Endpoints[0].InDataLeft = length - ret;
          device.Endpoints[0].InDataBuffer = (uint8_t *)buffer + ret;
 80258ac:	9b00      	ldr	r3, [sp, #0]
          {
            length = (uint32_t)USB_ControlRequest.wLength;
          }

          ret = (uint32_t)device.Driver->EndpointWrite(0U,buffer,length);
          device.Endpoints[0].InDataLeft = length - ret;
 80258ae:	1a2d      	subs	r5, r5, r0
          device.Endpoints[0].InDataBuffer = (uint8_t *)buffer + ret;
 80258b0:	4418      	add	r0, r3
          {
            length = (uint32_t)USB_ControlRequest.wLength;
          }

          ret = (uint32_t)device.Driver->EndpointWrite(0U,buffer,length);
          device.Endpoints[0].InDataLeft = length - ret;
 80258b2:	62a5      	str	r5, [r4, #40]	; 0x28
          device.Endpoints[0].InDataBuffer = (uint8_t *)buffer + ret;
 80258b4:	62e0      	str	r0, [r4, #44]	; 0x2c
 80258b6:	e779      	b.n	80257ac <USBD_Handle_DeviceRequest+0x24>
        /* Set Descriptor not supported, so stall */
        USBD_HandleEP0_Stall();
        break;

      case REQ_SetInterface:
        if ((uint8_t)DEVICE_STATE_Configured == USB_DeviceState)
 80258b8:	4b58      	ldr	r3, [pc, #352]	; (8025a1c <USBD_Handle_DeviceRequest+0x294>)
 80258ba:	781a      	ldrb	r2, [r3, #0]
 80258bc:	2a04      	cmp	r2, #4
 80258be:	d195      	bne.n	80257ec <USBD_Handle_DeviceRequest+0x64>
        {
          tmp_value = (uint32_t)USB_ControlRequest.wValue;
 80258c0:	8872      	ldrh	r2, [r6, #2]
          tmp_index = (uint32_t)USB_ControlRequest.wIndex;
 80258c2:	88b3      	ldrh	r3, [r6, #4]
          device.interface_settings[tmp_index] =	(uint8_t)tmp_value;
 80258c4:	fa14 f383 	uxtah	r3, r4, r3
 80258c8:	f883 2138 	strb.w	r2, [r3, #312]	; 0x138
          break;
 80258cc:	e76e      	b.n	80257ac <USBD_Handle_DeviceRequest+0x24>
        }
        USBD_HandleEP0_Stall();
        break;

      case REQ_GetConfiguration:
        if (0U == (uint32_t)device.Driver->EndpointWrite(0U,&device.configuration,1U))
 80258ce:	6823      	ldr	r3, [r4, #0]
 80258d0:	4953      	ldr	r1, [pc, #332]	; (8025a20 <USBD_Handle_DeviceRequest+0x298>)
 80258d2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80258d4:	2201      	movs	r2, #1
 80258d6:	2000      	movs	r0, #0
 80258d8:	4798      	blx	r3
        {
          XMC_ASSERT("USBD_Handle_DeviceRequest: EndpointWrite failed on get configuration request", 0);
        }
        break;
 80258da:	e767      	b.n	80257ac <USBD_Handle_DeviceRequest+0x24>

      case REQ_SetConfiguration:
        /* Regardless the state update the configuration to unconfigure
         * endpoints */
        device.configuration = (uint8_t)value;
        if (NULL != device.events->config_changed)
 80258dc:	f8d4 3140 	ldr.w	r3, [r4, #320]	; 0x140
        break;

      case REQ_SetConfiguration:
        /* Regardless the state update the configuration to unconfigure
         * endpoints */
        device.configuration = (uint8_t)value;
 80258e0:	f884 5139 	strb.w	r5, [r4, #313]	; 0x139
        if (NULL != device.events->config_changed)
 80258e4:	689b      	ldr	r3, [r3, #8]
 80258e6:	b103      	cbz	r3, 80258ea <USBD_Handle_DeviceRequest+0x162>
        {
          device.events->config_changed();
 80258e8:	4798      	blx	r3
        }

        /* when config 0 is choosen, we are back in address state */
        if (0U == value)
 80258ea:	2d00      	cmp	r5, #0
 80258ec:	d054      	beq.n	8025998 <USBD_Handle_DeviceRequest+0x210>
        {
          USB_DeviceState = (uint8_t)DEVICE_STATE_Addressed;
          break;
        }
        /* go ahead only with vailid config. (must be set in event) */
        if (1U == device.IsConfigured)
 80258ee:	f894 313e 	ldrb.w	r3, [r4, #318]	; 0x13e
 80258f2:	4d48      	ldr	r5, [pc, #288]	; (8025a14 <USBD_Handle_DeviceRequest+0x28c>)
 80258f4:	07d9      	lsls	r1, r3, #31
 80258f6:	f140 80a6 	bpl.w	8025a46 <USBD_Handle_DeviceRequest+0x2be>
        {
          USB_DeviceState = (uint8_t)DEVICE_STATE_Configured;
 80258fa:	4b48      	ldr	r3, [pc, #288]	; (8025a1c <USBD_Handle_DeviceRequest+0x294>)
 80258fc:	2204      	movs	r2, #4
 80258fe:	701a      	strb	r2, [r3, #0]
 8025900:	e754      	b.n	80257ac <USBD_Handle_DeviceRequest+0x24>
        }
        break;

      case REQ_SetFeature:
        /* we do not support test mode */
        if ((uint32_t)FEATURE_SEL_TestMode == value)
 8025902:	2d02      	cmp	r5, #2
 8025904:	f43f af75 	beq.w	80257f2 <USBD_Handle_DeviceRequest+0x6a>
        {
          USBD_HandleEP0_Stall();
          break;
        }
        /* configured state */
        if ((uint8_t)DEVICE_STATE_Configured == USB_DeviceState)
 8025908:	4b44      	ldr	r3, [pc, #272]	; (8025a1c <USBD_Handle_DeviceRequest+0x294>)
 802590a:	781a      	ldrb	r2, [r3, #0]
 802590c:	2a04      	cmp	r2, #4
 802590e:	d067      	beq.n	80259e0 <USBD_Handle_DeviceRequest+0x258>
              break;
          }
          break;
        }
        /* when addressed, only ep0 can be halted */
        if ((uint8_t)DEVICE_STATE_Addressed == USB_DeviceState)
 8025910:	781b      	ldrb	r3, [r3, #0]
 8025912:	2b03      	cmp	r3, #3
 8025914:	f47f af6d 	bne.w	80257f2 <USBD_Handle_DeviceRequest+0x6a>
        {
          if (((uint32_t)FEATURE_SEL_EndpointHalt == value) &&
 8025918:	2d00      	cmp	r5, #0
 802591a:	f47f af6a 	bne.w	80257f2 <USBD_Handle_DeviceRequest+0x6a>
              (REQREC_ENDPOINT == ((uint32_t)USB_ControlRequest.bmRequestType & REQ_RECIPIENT_MASK)) &&
 802591e:	7833      	ldrb	r3, [r6, #0]
 8025920:	4a3d      	ldr	r2, [pc, #244]	; (8025a18 <USBD_Handle_DeviceRequest+0x290>)
          break;
        }
        /* when addressed, only ep0 can be halted */
        if ((uint8_t)DEVICE_STATE_Addressed == USB_DeviceState)
        {
          if (((uint32_t)FEATURE_SEL_EndpointHalt == value) &&
 8025922:	f003 0303 	and.w	r3, r3, #3
 8025926:	2b02      	cmp	r3, #2
 8025928:	f47f af63 	bne.w	80257f2 <USBD_Handle_DeviceRequest+0x6a>
              (REQREC_ENDPOINT == ((uint32_t)USB_ControlRequest.bmRequestType & REQ_RECIPIENT_MASK)) &&
              ((uint16_t)0 == ((uint16_t)USB_ControlRequest.wIndex & (uint16_t)USBD_BYTE_MASK)))
 802592c:	8893      	ldrh	r3, [r2, #4]
        }
        /* when addressed, only ep0 can be halted */
        if ((uint8_t)DEVICE_STATE_Addressed == USB_DeviceState)
        {
          if (((uint32_t)FEATURE_SEL_EndpointHalt == value) &&
              (REQREC_ENDPOINT == ((uint32_t)USB_ControlRequest.bmRequestType & REQ_RECIPIENT_MASK)) &&
 802592e:	f013 0fff 	tst.w	r3, #255	; 0xff
 8025932:	f47f af5e 	bne.w	80257f2 <USBD_Handle_DeviceRequest+0x6a>
              ((uint16_t)0 == ((uint16_t)USB_ControlRequest.wIndex & (uint16_t)USBD_BYTE_MASK)))
          {
            device.Endpoints[0].IsHalted = 1U;
 8025936:	8923      	ldrh	r3, [r4, #8]
 8025938:	f043 0304 	orr.w	r3, r3, #4
 802593c:	8123      	strh	r3, [r4, #8]
            USBD_HandleEP0_Stall();
 802593e:	f7ff ff0f 	bl	8025760 <USBD_HandleEP0_Stall>
            break;
 8025942:	e733      	b.n	80257ac <USBD_Handle_DeviceRequest+0x24>
  {
    /* default request handling */
    switch (USB_ControlRequest.bRequest)
    {
      case REQ_ClearFeature:
        if ((uint8_t)REQREC_ENDPOINT == (USB_ControlRequest.bmRequestType & (uint8_t)REQ_RECIPIENT_MASK))
 8025944:	7833      	ldrb	r3, [r6, #0]
 8025946:	4a34      	ldr	r2, [pc, #208]	; (8025a18 <USBD_Handle_DeviceRequest+0x290>)
 8025948:	f003 0303 	and.w	r3, r3, #3
 802594c:	2b02      	cmp	r3, #2
 802594e:	d027      	beq.n	80259a0 <USBD_Handle_DeviceRequest+0x218>
          {
            USBD_HandleEP0_Stall();
          }
          break;
        }
        if (REQREC_DEVICE == ((uint32_t)USB_ControlRequest.bmRequestType & REQ_RECIPIENT_MASK))
 8025950:	7813      	ldrb	r3, [r2, #0]
 8025952:	f013 0303 	ands.w	r3, r3, #3
 8025956:	f47f af4c 	bne.w	80257f2 <USBD_Handle_DeviceRequest+0x6a>
        {
          device.remote_wakeup = 0U;
 802595a:	f894 213e 	ldrb.w	r2, [r4, #318]	; 0x13e
 802595e:	f363 0282 	bfi	r2, r3, #2, #1
 8025962:	f884 213e 	strb.w	r2, [r4, #318]	; 0x13e
          break;
 8025966:	e721      	b.n	80257ac <USBD_Handle_DeviceRequest+0x24>
        break;

      case REQ_SetAddress:
        if (0U == value)
        {
          USB_DeviceState = (uint8_t)DEVICE_STATE_Default;
 8025968:	4b2c      	ldr	r3, [pc, #176]	; (8025a1c <USBD_Handle_DeviceRequest+0x294>)
        /* default stall */
        USBD_HandleEP0_Stall();
        break;

      case REQ_SetAddress:
        if (0U == value)
 802596a:	b995      	cbnz	r5, 8025992 <USBD_Handle_DeviceRequest+0x20a>
        {
          USB_DeviceState = (uint8_t)DEVICE_STATE_Default;
 802596c:	2202      	movs	r2, #2
 802596e:	701a      	strb	r2, [r3, #0]
        }
        else
        {
          USB_DeviceState = (uint8_t)DEVICE_STATE_Addressed;
        }
        if (USBD_STATUS_SUCCESS == (USBD_STATUS_t)device.Driver->DeviceSetAddress((uint8_t)value,
 8025970:	6823      	ldr	r3, [r4, #0]
 8025972:	4e28      	ldr	r6, [pc, #160]	; (8025a14 <USBD_Handle_DeviceRequest+0x28c>)
 8025974:	699b      	ldr	r3, [r3, #24]
 8025976:	4628      	mov	r0, r5
 8025978:	2100      	movs	r1, #0
 802597a:	4798      	blx	r3
 802597c:	2800      	cmp	r0, #0
 802597e:	f47f af15 	bne.w	80257ac <USBD_Handle_DeviceRequest+0x24>
                                   XMC_USBD_SET_ADDRESS_STAGE_SETUP))
        {
          if (NULL != device.events->set_address)
 8025982:	f8d6 3140 	ldr.w	r3, [r6, #320]	; 0x140
 8025986:	691b      	ldr	r3, [r3, #16]
 8025988:	2b00      	cmp	r3, #0
 802598a:	f43f af0f 	beq.w	80257ac <USBD_Handle_DeviceRequest+0x24>
          {
            device.events->set_address();
 802598e:	4798      	blx	r3
 8025990:	e70c      	b.n	80257ac <USBD_Handle_DeviceRequest+0x24>
        {
          USB_DeviceState = (uint8_t)DEVICE_STATE_Default;
        }
        else
        {
          USB_DeviceState = (uint8_t)DEVICE_STATE_Addressed;
 8025992:	2203      	movs	r2, #3
 8025994:	701a      	strb	r2, [r3, #0]
 8025996:	e7eb      	b.n	8025970 <USBD_Handle_DeviceRequest+0x1e8>
        }

        /* when config 0 is choosen, we are back in address state */
        if (0U == value)
        {
          USB_DeviceState = (uint8_t)DEVICE_STATE_Addressed;
 8025998:	4b20      	ldr	r3, [pc, #128]	; (8025a1c <USBD_Handle_DeviceRequest+0x294>)
 802599a:	2203      	movs	r2, #3
 802599c:	701a      	strb	r2, [r3, #0]
          break;
 802599e:	e705      	b.n	80257ac <USBD_Handle_DeviceRequest+0x24>
    {
      case REQ_ClearFeature:
        if ((uint8_t)REQREC_ENDPOINT == (USB_ControlRequest.bmRequestType & (uint8_t)REQ_RECIPIENT_MASK))
        {
          index = (uint32_t)USB_ControlRequest.wIndex & (uint32_t)ENDPOINT_EPNUM_MASK;
          if ((((uint8_t)DEVICE_STATE_Configured == USB_DeviceState) || ((uint16_t)0U == USB_ControlRequest.wIndex)) &&
 80259a0:	491e      	ldr	r1, [pc, #120]	; (8025a1c <USBD_Handle_DeviceRequest+0x294>)
    switch (USB_ControlRequest.bRequest)
    {
      case REQ_ClearFeature:
        if ((uint8_t)REQREC_ENDPOINT == (USB_ControlRequest.bmRequestType & (uint8_t)REQ_RECIPIENT_MASK))
        {
          index = (uint32_t)USB_ControlRequest.wIndex & (uint32_t)ENDPOINT_EPNUM_MASK;
 80259a2:	8893      	ldrh	r3, [r2, #4]
          if ((((uint8_t)DEVICE_STATE_Configured == USB_DeviceState) || ((uint16_t)0U == USB_ControlRequest.wIndex)) &&
 80259a4:	7809      	ldrb	r1, [r1, #0]
 80259a6:	2904      	cmp	r1, #4
    switch (USB_ControlRequest.bRequest)
    {
      case REQ_ClearFeature:
        if ((uint8_t)REQREC_ENDPOINT == (USB_ControlRequest.bmRequestType & (uint8_t)REQ_RECIPIENT_MASK))
        {
          index = (uint32_t)USB_ControlRequest.wIndex & (uint32_t)ENDPOINT_EPNUM_MASK;
 80259a8:	b29b      	uxth	r3, r3
          if ((((uint8_t)DEVICE_STATE_Configured == USB_DeviceState) || ((uint16_t)0U == USB_ControlRequest.wIndex)) &&
 80259aa:	d004      	beq.n	80259b6 <USBD_Handle_DeviceRequest+0x22e>
 80259ac:	8892      	ldrh	r2, [r2, #4]
 80259ae:	b292      	uxth	r2, r2
 80259b0:	2a00      	cmp	r2, #0
 80259b2:	f47f af1e 	bne.w	80257f2 <USBD_Handle_DeviceRequest+0x6a>
                  (1U == device.Endpoints[index].IsConfigured))
 80259b6:	222c      	movs	r2, #44	; 0x2c
    switch (USB_ControlRequest.bRequest)
    {
      case REQ_ClearFeature:
        if ((uint8_t)REQREC_ENDPOINT == (USB_ControlRequest.bmRequestType & (uint8_t)REQ_RECIPIENT_MASK))
        {
          index = (uint32_t)USB_ControlRequest.wIndex & (uint32_t)ENDPOINT_EPNUM_MASK;
 80259b8:	f003 030f 	and.w	r3, r3, #15
          if ((((uint8_t)DEVICE_STATE_Configured == USB_DeviceState) || ((uint16_t)0U == USB_ControlRequest.wIndex)) &&
                  (1U == device.Endpoints[index].IsConfigured))
 80259bc:	fb02 4303 	mla	r3, r2, r3, r4
 80259c0:	4914      	ldr	r1, [pc, #80]	; (8025a14 <USBD_Handle_DeviceRequest+0x28c>)
 80259c2:	7a1a      	ldrb	r2, [r3, #8]
    {
      case REQ_ClearFeature:
        if ((uint8_t)REQREC_ENDPOINT == (USB_ControlRequest.bmRequestType & (uint8_t)REQ_RECIPIENT_MASK))
        {
          index = (uint32_t)USB_ControlRequest.wIndex & (uint32_t)ENDPOINT_EPNUM_MASK;
          if ((((uint8_t)DEVICE_STATE_Configured == USB_DeviceState) || ((uint16_t)0U == USB_ControlRequest.wIndex)) &&
 80259c4:	07d5      	lsls	r5, r2, #31
 80259c6:	f57f af14 	bpl.w	80257f2 <USBD_Handle_DeviceRequest+0x6a>
                  (1U == device.Endpoints[index].IsConfigured))
          {
            device.Endpoints[index].IsHalted = 0U;
 80259ca:	891a      	ldrh	r2, [r3, #8]
 80259cc:	f36f 0282 	bfc	r2, #2, #1
 80259d0:	811a      	strh	r2, [r3, #8]
            if (USBD_STATUS_SUCCESS != 
                                 (USBD_STATUS_t)device.Driver->EndpointStall((uint8_t)USB_ControlRequest.wIndex,false))
 80259d2:	88b0      	ldrh	r0, [r6, #4]
 80259d4:	680b      	ldr	r3, [r1, #0]
 80259d6:	b2c0      	uxtb	r0, r0
 80259d8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80259da:	2100      	movs	r1, #0
 80259dc:	4798      	blx	r3
          index = (uint32_t)USB_ControlRequest.wIndex & (uint32_t)ENDPOINT_EPNUM_MASK;
          if ((((uint8_t)DEVICE_STATE_Configured == USB_DeviceState) || ((uint16_t)0U == USB_ControlRequest.wIndex)) &&
                  (1U == device.Endpoints[index].IsConfigured))
          {
            device.Endpoints[index].IsHalted = 0U;
            if (USBD_STATUS_SUCCESS != 
 80259de:	e6e5      	b.n	80257ac <USBD_Handle_DeviceRequest+0x24>
          break;
        }
        /* configured state */
        if ((uint8_t)DEVICE_STATE_Configured == USB_DeviceState)
        {
          switch (value)
 80259e0:	2d00      	cmp	r5, #0
 80259e2:	d044      	beq.n	8025a6e <USBD_Handle_DeviceRequest+0x2e6>
 80259e4:	2d01      	cmp	r5, #1
 80259e6:	f47f aee1 	bne.w	80257ac <USBD_Handle_DeviceRequest+0x24>
          {
            case FEATURE_SEL_DeviceRemoteWakeup:
              device.remote_wakeup = 1U;
 80259ea:	f894 313e 	ldrb.w	r3, [r4, #318]	; 0x13e
 80259ee:	f043 0304 	orr.w	r3, r3, #4
 80259f2:	f884 313e 	strb.w	r3, [r4, #318]	; 0x13e
              break;
 80259f6:	e6d9      	b.n	80257ac <USBD_Handle_DeviceRequest+0x24>
            XMC_ASSERT("USBD_Handle_DeviceRequest: EndpointWrite failed on REQ_GetStatus", 0);
          }          
          break;
        }
        if ((REQREC_INTERFACE == ((uint32_t)USB_ControlRequest.bmRequestType & REQ_RECIPIENT_MASK)) &&
            ((uint8_t)DEVICE_STATE_Configured == USB_DeviceState))
 80259f8:	4b08      	ldr	r3, [pc, #32]	; (8025a1c <USBD_Handle_DeviceRequest+0x294>)
 80259fa:	781b      	ldrb	r3, [r3, #0]
          {
            XMC_ASSERT("USBD_Handle_DeviceRequest: EndpointWrite failed on REQ_GetStatus", 0);
          }          
          break;
        }
        if ((REQREC_INTERFACE == ((uint32_t)USB_ControlRequest.bmRequestType & REQ_RECIPIENT_MASK)) &&
 80259fc:	2b04      	cmp	r3, #4
 80259fe:	f47f af14 	bne.w	802582a <USBD_Handle_DeviceRequest+0xa2>
            ((uint8_t)DEVICE_STATE_Configured == USB_DeviceState))
        {
          status = 0U;
 8025a02:	a902      	add	r1, sp, #8
          if (0U == (uint32_t)device.Driver->EndpointWrite(0U, (uint8_t*)&status, USBD_WORD_SIZE))
 8025a04:	6823      	ldr	r3, [r4, #0]
          break;
        }
        if ((REQREC_INTERFACE == ((uint32_t)USB_ControlRequest.bmRequestType & REQ_RECIPIENT_MASK)) &&
            ((uint8_t)DEVICE_STATE_Configured == USB_DeviceState))
        {
          status = 0U;
 8025a06:	2000      	movs	r0, #0
 8025a08:	f841 0d04 	str.w	r0, [r1, #-4]!
          if (0U == (uint32_t)device.Driver->EndpointWrite(0U, (uint8_t*)&status, USBD_WORD_SIZE))
 8025a0c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8025a0e:	2202      	movs	r2, #2
 8025a10:	4798      	blx	r3
          {
            XMC_ASSERT("USBD_Handle_DeviceRequest: EndpointWrite failed on REQ_GetStatus- REQREC_INTERFACE", 0);
          }          
          break;
 8025a12:	e6cb      	b.n	80257ac <USBD_Handle_DeviceRequest+0x24>
 8025a14:	1fff0594 	.word	0x1fff0594
 8025a18:	1fff038c 	.word	0x1fff038c
 8025a1c:	1fff0389 	.word	0x1fff0389
 8025a20:	1fff06cd 	.word	0x1fff06cd
        break;

      case REQ_GetStatus:
        if (REQREC_DEVICE == ((uint32_t)USB_ControlRequest.bmRequestType & REQ_RECIPIENT_MASK))
        {
          status = (uint32_t)((uint8_t)(device.remote_wakeup << (uint8_t)1) | device.self_powered);					
 8025a24:	f894 313e 	ldrb.w	r3, [r4, #318]	; 0x13e
          if (0U == (uint32_t)device.Driver->EndpointWrite(0U, (uint8_t*)&status, USBD_WORD_SIZE))
 8025a28:	6822      	ldr	r2, [r4, #0]
        break;

      case REQ_GetStatus:
        if (REQREC_DEVICE == ((uint32_t)USB_ControlRequest.bmRequestType & REQ_RECIPIENT_MASK))
        {
          status = (uint32_t)((uint8_t)(device.remote_wakeup << (uint8_t)1) | device.self_powered);					
 8025a2a:	f3c3 0580 	ubfx	r5, r3, #2, #1
 8025a2e:	006d      	lsls	r5, r5, #1
 8025a30:	b2ed      	uxtb	r5, r5
 8025a32:	a902      	add	r1, sp, #8
 8025a34:	f3c3 03c0 	ubfx	r3, r3, #3, #1
 8025a38:	432b      	orrs	r3, r5
 8025a3a:	f841 3d04 	str.w	r3, [r1, #-4]!
          if (0U == (uint32_t)device.Driver->EndpointWrite(0U, (uint8_t*)&status, USBD_WORD_SIZE))
 8025a3e:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8025a40:	2202      	movs	r2, #2
 8025a42:	4798      	blx	r3
          {
            XMC_ASSERT("USBD_Handle_DeviceRequest: EndpointWrite failed on REQ_GetStatus", 0);
          }          
          break;
 8025a44:	e6b2      	b.n	80257ac <USBD_Handle_DeviceRequest+0x24>
 */
static void USBD_HandleEP0_Stall(void)
{
  /* When we stall ep0 as protocol stall, we go back into idle state and
  * start a new read */
  if (USBD_STATUS_SUCCESS == (USBD_STATUS_t)device.Driver->EndpointStall(ENDPOINT_DIR_IN | 0U,1U))
 8025a46:	682b      	ldr	r3, [r5, #0]
 8025a48:	2080      	movs	r0, #128	; 0x80
 8025a4a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8025a4c:	2101      	movs	r1, #1
 8025a4e:	4798      	blx	r3
 8025a50:	2800      	cmp	r0, #0
 8025a52:	f47f aeab 	bne.w	80257ac <USBD_Handle_DeviceRequest+0x24>
 8025a56:	e6d4      	b.n	8025802 <USBD_Handle_DeviceRequest+0x7a>

      case REQ_GetInterface:
        if ((uint8_t)DEVICE_STATE_Configured == USB_DeviceState)
        {          
          if (0U == (uint32_t)device.Driver->EndpointWrite(0U, 
             &device.interface_settings[USB_ControlRequest.wIndex], 1U))
 8025a58:	88b1      	ldrh	r1, [r6, #4]
        break;

      case REQ_GetInterface:
        if ((uint8_t)DEVICE_STATE_Configured == USB_DeviceState)
        {          
          if (0U == (uint32_t)device.Driver->EndpointWrite(0U, 
 8025a5a:	6823      	ldr	r3, [r4, #0]
             &device.interface_settings[USB_ControlRequest.wIndex], 1U))
 8025a5c:	b289      	uxth	r1, r1
 8025a5e:	f501 719c 	add.w	r1, r1, #312	; 0x138
        break;

      case REQ_GetInterface:
        if ((uint8_t)DEVICE_STATE_Configured == USB_DeviceState)
        {          
          if (0U == (uint32_t)device.Driver->EndpointWrite(0U, 
 8025a62:	4421      	add	r1, r4
 8025a64:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8025a66:	2201      	movs	r2, #1
 8025a68:	2000      	movs	r0, #0
 8025a6a:	4798      	blx	r3
             &device.interface_settings[USB_ControlRequest.wIndex], 1U))
          {
            XMC_ASSERT("USBD_Handle_DeviceRequest: EndpointWrite failed on REQ_GetInterface", 0);
          }
          break;
 8025a6c:	e69e      	b.n	80257ac <USBD_Handle_DeviceRequest+0x24>
          {
            case FEATURE_SEL_DeviceRemoteWakeup:
              device.remote_wakeup = 1U;
              break;
            case FEATURE_SEL_EndpointHalt:
              index = ((uint32_t)USB_ControlRequest.wIndex & (uint32_t)USBD_BYTE_MASK & 
 8025a6e:	88b3      	ldrh	r3, [r6, #4]
 8025a70:	480a      	ldr	r0, [pc, #40]	; (8025a9c <USBD_Handle_DeviceRequest+0x314>)
                      (uint32_t)XMC_USBD_ENDPOINT_NUMBER_MASK);
              if (0U == device.Endpoints[index].IsConfigured)
 8025a72:	490b      	ldr	r1, [pc, #44]	; (8025aa0 <USBD_Handle_DeviceRequest+0x318>)
 8025a74:	222c      	movs	r2, #44	; 0x2c
          {
            case FEATURE_SEL_DeviceRemoteWakeup:
              device.remote_wakeup = 1U;
              break;
            case FEATURE_SEL_EndpointHalt:
              index = ((uint32_t)USB_ControlRequest.wIndex & (uint32_t)USBD_BYTE_MASK & 
 8025a76:	f003 030f 	and.w	r3, r3, #15
                      (uint32_t)XMC_USBD_ENDPOINT_NUMBER_MASK);
              if (0U == device.Endpoints[index].IsConfigured)
 8025a7a:	fb02 4303 	mla	r3, r2, r3, r4
 8025a7e:	7a1a      	ldrb	r2, [r3, #8]
 8025a80:	07d2      	lsls	r2, r2, #31
 8025a82:	f57f af5c 	bpl.w	802593e <USBD_Handle_DeviceRequest+0x1b6>
              {
                USBD_HandleEP0_Stall();
              }
              else
              {
                device.Endpoints[index].IsHalted = 1U;
 8025a86:	891a      	ldrh	r2, [r3, #8]
 8025a88:	f042 0204 	orr.w	r2, r2, #4
 8025a8c:	811a      	strh	r2, [r3, #8]
                if (USBD_STATUS_SUCCESS != 
                                  (USBD_STATUS_t)device.Driver->EndpointStall((uint8_t)USB_ControlRequest.wIndex,true))
 8025a8e:	680b      	ldr	r3, [r1, #0]
 8025a90:	8880      	ldrh	r0, [r0, #4]
 8025a92:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8025a94:	2101      	movs	r1, #1
 8025a96:	b2c0      	uxtb	r0, r0
 8025a98:	4798      	blx	r3
 8025a9a:	e687      	b.n	80257ac <USBD_Handle_DeviceRequest+0x24>
 8025a9c:	1fff038c 	.word	0x1fff038c
 8025aa0:	1fff0594 	.word	0x1fff0594

08025aa4 <USBD_SignalEndpointEvent_Handler>:
 * If the driver detects an event (See XMC_USBD_EP_EVENT_t) for a specified endpoint it calls this function.
 * Based on the event some further action is taken, e.g. process control request or update transfer information
 * and read data from the driver into the core buffer.
 */
static void USBD_SignalEndpointEvent_Handler(uint8_t ep_addr, XMC_USBD_EP_EVENT_t ep_event)
{
 8025aa4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  uint32_t temp_num;
  uint32_t temp_dir;

  ep =  &device.Endpoints[(ep_addr & ENDPOINT_EPNUM_MASK)];
  /* store CurrentEndpoint and direction for restore after handling */
  temp_num = (uint32_t)device.CurrentEndpoint;
 8025aa8:	4c72      	ldr	r4, [pc, #456]	; (8025c74 <USBD_SignalEndpointEvent_Handler+0x1d0>)
  USBD_Endpoint_t *ep;
  int32_t data_count;
  uint32_t temp_num;
  uint32_t temp_dir;

  ep =  &device.Endpoints[(ep_addr & ENDPOINT_EPNUM_MASK)];
 8025aaa:	f000 050f 	and.w	r5, r0, #15
  temp_dir = (uint32_t)device.CurrentDirection;
  /* select the given endpoint */
  device.CurrentEndpoint = ep_addr & ENDPOINT_EPNUM_MASK;
  device.CurrentDirection = ep_addr & (uint8_t)ENDPOINT_DIR_MASK;
  /* choose what to do based on the event */
  switch (ep_event)
 8025aae:	2901      	cmp	r1, #1
  /* store CurrentEndpoint and direction for restore after handling */
  temp_num = (uint32_t)device.CurrentEndpoint;
  temp_dir = (uint32_t)device.CurrentDirection;
  /* select the given endpoint */
  device.CurrentEndpoint = ep_addr & ENDPOINT_EPNUM_MASK;
  device.CurrentDirection = ep_addr & (uint8_t)ENDPOINT_DIR_MASK;
 8025ab0:	f020 007f 	bic.w	r0, r0, #127	; 0x7f
  uint32_t temp_dir;

  ep =  &device.Endpoints[(ep_addr & ENDPOINT_EPNUM_MASK)];
  /* store CurrentEndpoint and direction for restore after handling */
  temp_num = (uint32_t)device.CurrentEndpoint;
  temp_dir = (uint32_t)device.CurrentDirection;
 8025ab4:	f894 713d 	ldrb.w	r7, [r4, #317]	; 0x13d
  uint32_t temp_num;
  uint32_t temp_dir;

  ep =  &device.Endpoints[(ep_addr & ENDPOINT_EPNUM_MASK)];
  /* store CurrentEndpoint and direction for restore after handling */
  temp_num = (uint32_t)device.CurrentEndpoint;
 8025ab8:	f894 813c 	ldrb.w	r8, [r4, #316]	; 0x13c
  temp_dir = (uint32_t)device.CurrentDirection;
  /* select the given endpoint */
  device.CurrentEndpoint = ep_addr & ENDPOINT_EPNUM_MASK;
  device.CurrentDirection = ep_addr & (uint8_t)ENDPOINT_DIR_MASK;
 8025abc:	f884 013d 	strb.w	r0, [r4, #317]	; 0x13d
  USBD_Endpoint_t *ep;
  int32_t data_count;
  uint32_t temp_num;
  uint32_t temp_dir;

  ep =  &device.Endpoints[(ep_addr & ENDPOINT_EPNUM_MASK)];
 8025ac0:	462e      	mov	r6, r5
  /* store CurrentEndpoint and direction for restore after handling */
  temp_num = (uint32_t)device.CurrentEndpoint;
  temp_dir = (uint32_t)device.CurrentDirection;
  /* select the given endpoint */
  device.CurrentEndpoint = ep_addr & ENDPOINT_EPNUM_MASK;
 8025ac2:	f884 513c 	strb.w	r5, [r4, #316]	; 0x13c
  device.CurrentDirection = ep_addr & (uint8_t)ENDPOINT_DIR_MASK;
  /* choose what to do based on the event */
  switch (ep_event)
 8025ac6:	d067      	beq.n	8025b98 <USBD_SignalEndpointEvent_Handler+0xf4>
 8025ac8:	d33a      	bcc.n	8025b40 <USBD_SignalEndpointEvent_Handler+0x9c>
 8025aca:	2902      	cmp	r1, #2
 8025acc:	d132      	bne.n	8025b34 <USBD_SignalEndpointEvent_Handler+0x90>
          break;
      }
      break;
    case XMC_USBD_EP_EVENT_IN:
      /* loop write transfers */
      if (ep->InDataLeft > 0U)
 8025ace:	232c      	movs	r3, #44	; 0x2c
 8025ad0:	fb03 4305 	mla	r3, r3, r5, r4
 8025ad4:	f103 0920 	add.w	r9, r3, #32
 8025ad8:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8025ada:	2a00      	cmp	r2, #0
 8025adc:	f040 8091 	bne.w	8025c02 <USBD_SignalEndpointEvent_Handler+0x15e>
        data_count = device.Driver->EndpointWrite((uint8_t)ep->Address,ep->InDataBuffer,ep->InDataLeft);
        ep->InDataLeft -= (uint32_t)data_count;
        ep->InDataBuffer += (uint32_t)data_count;
        break;
      }
      else if (((uint32_t)ep->Number == 0U) && (ep->InBytesAvailable > 0U) &&
 8025ae0:	7918      	ldrb	r0, [r3, #4]
 8025ae2:	0702      	lsls	r2, r0, #28
 8025ae4:	d114      	bne.n	8025b10 <USBD_SignalEndpointEvent_Handler+0x6c>
 8025ae6:	69da      	ldr	r2, [r3, #28]
 8025ae8:	b192      	cbz	r2, 8025b10 <USBD_SignalEndpointEvent_Handler+0x6c>
              (ep->InBytesAvailable != (uint32_t)USB_ControlRequest.wLength) &&
 8025aea:	4963      	ldr	r1, [pc, #396]	; (8025c78 <USBD_SignalEndpointEvent_Handler+0x1d4>)
 8025aec:	88c9      	ldrh	r1, [r1, #6]
 8025aee:	b289      	uxth	r1, r1
        data_count = device.Driver->EndpointWrite((uint8_t)ep->Address,ep->InDataBuffer,ep->InDataLeft);
        ep->InDataLeft -= (uint32_t)data_count;
        ep->InDataBuffer += (uint32_t)data_count;
        break;
      }
      else if (((uint32_t)ep->Number == 0U) && (ep->InBytesAvailable > 0U) &&
 8025af0:	428a      	cmp	r2, r1
 8025af2:	d00d      	beq.n	8025b10 <USBD_SignalEndpointEvent_Handler+0x6c>
              (ep->InBytesAvailable != (uint32_t)USB_ControlRequest.wLength) &&
              ((ep->InBytesAvailable % (uint32_t)ep->MaxPacketSize) == 0U))
 8025af4:	891b      	ldrh	r3, [r3, #8]
 8025af6:	f3c3 1386 	ubfx	r3, r3, #6, #7
 8025afa:	fbb2 f1f3 	udiv	r1, r2, r3
 8025afe:	fb03 2111 	mls	r1, r3, r1, r2
        ep->InDataLeft -= (uint32_t)data_count;
        ep->InDataBuffer += (uint32_t)data_count;
        break;
      }
      else if (((uint32_t)ep->Number == 0U) && (ep->InBytesAvailable > 0U) &&
              (ep->InBytesAvailable != (uint32_t)USB_ControlRequest.wLength) &&
 8025b02:	b929      	cbnz	r1, 8025b10 <USBD_SignalEndpointEvent_Handler+0x6c>
              ((ep->InBytesAvailable % (uint32_t)ep->MaxPacketSize) == 0U))
      {
        /* if the amount of data for endpoint 0 is exact the requested
         * amount, then no zlp has to be send */
        device.Driver->EndpointWrite((uint8_t)ep->Address,0,0U);
 8025b04:	6823      	ldr	r3, [r4, #0]
 8025b06:	460a      	mov	r2, r1
 8025b08:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8025b0a:	4798      	blx	r3
 8025b0c:	f894 513c 	ldrb.w	r5, [r4, #316]	; 0x13c
      }
      else
      {
      }
      ep->InBytesAvailable = 0U;
 8025b10:	f8df 9160 	ldr.w	r9, [pc, #352]	; 8025c74 <USBD_SignalEndpointEvent_Handler+0x1d0>
 8025b14:	232c      	movs	r3, #44	; 0x2c
 8025b16:	fb03 4606 	mla	r6, r3, r6, r4
 8025b1a:	2200      	movs	r2, #0
      ep->InInUse = (uint8_t)0;
 8025b1c:	8933      	ldrh	r3, [r6, #8]
        device.Driver->EndpointWrite((uint8_t)ep->Address,0,0U);
      }
      else
      {
      }
      ep->InBytesAvailable = 0U;
 8025b1e:	61f2      	str	r2, [r6, #28]
      ep->InInUse = (uint8_t)0;
 8025b20:	f362 1304 	bfi	r3, r2, #4, #1
 8025b24:	8133      	strh	r3, [r6, #8]
      switch (device.CurrentEndpoint)
 8025b26:	b92d      	cbnz	r5, 8025b34 <USBD_SignalEndpointEvent_Handler+0x90>
 * In USBD_EP0_STATE_IN_STATUS state it starts a new read of setup packets and switches
 * to USBD_EP0_STATE_IDLE.
 */
static void USBD_HandleEP0_IN()
{
  if (USBD_EP0_STATE_IN_DATA == device.ep0_state)
 8025b28:	f899 313b 	ldrb.w	r3, [r9, #315]	; 0x13b
 8025b2c:	2b02      	cmp	r3, #2
 8025b2e:	d078      	beq.n	8025c22 <USBD_SignalEndpointEvent_Handler+0x17e>
  {
    /* Read zero length out data packet */
    device.Driver->EndpointReadStart((uint8_t)0,0U);
    device.ep0_state = USBD_EP0_STATE_OUT_STATUS;
  }
  else if (USBD_EP0_STATE_IN_STATUS == device.ep0_state)
 8025b30:	2b03      	cmp	r3, #3
 8025b32:	d04e      	beq.n	8025bd2 <USBD_SignalEndpointEvent_Handler+0x12e>
      }
      break;
    default:
      break;
  }
  device.CurrentEndpoint = (uint8_t)temp_num;
 8025b34:	f884 813c 	strb.w	r8, [r4, #316]	; 0x13c
  device.CurrentDirection = (uint8_t)temp_dir;
 8025b38:	f884 713d 	strb.w	r7, [r4, #317]	; 0x13d
 8025b3c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  device.CurrentDirection = ep_addr & (uint8_t)ENDPOINT_DIR_MASK;
  /* choose what to do based on the event */
  switch (ep_event)
  {
    case XMC_USBD_EP_EVENT_SETUP:
      ep->OutInUse = 0U;
 8025b40:	232c      	movs	r3, #44	; 0x2c
 8025b42:	fb03 4305 	mla	r3, r3, r5, r4
 8025b46:	891a      	ldrh	r2, [r3, #8]
 8025b48:	f36f 02c3 	bfc	r2, #3, #1
 8025b4c:	811a      	strh	r2, [r3, #8]
      switch (device.CurrentEndpoint)
 8025b4e:	2d00      	cmp	r5, #0
 8025b50:	d1f0      	bne.n	8025b34 <USBD_SignalEndpointEvent_Handler+0x90>
static void USBD_HandleEP0_SETUP()
{
  /* read setup packet from ep0 */
  uint32_t ret_val;

  ret_val = (uint32_t)device.Driver->EndpointRead((uint8_t)0,(void*)&USB_ControlRequest,
 8025b52:	6823      	ldr	r3, [r4, #0]
 8025b54:	4e48      	ldr	r6, [pc, #288]	; (8025c78 <USBD_SignalEndpointEvent_Handler+0x1d4>)
 8025b56:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8025b58:	4631      	mov	r1, r6
 8025b5a:	4628      	mov	r0, r5
 8025b5c:	2208      	movs	r2, #8
 8025b5e:	4798      	blx	r3
            (uint32_t)USBD_EP0_SETUP_PKT_SIZE);
  device.IsSetupRecieved = (uint8_t)true;
 8025b60:	f894 313e 	ldrb.w	r3, [r4, #318]	; 0x13e

  if ((uint32_t)USBD_EP0_SETUP_PKT_SIZE == ret_val)
 8025b64:	2808      	cmp	r0, #8
  /* read setup packet from ep0 */
  uint32_t ret_val;

  ret_val = (uint32_t)device.Driver->EndpointRead((uint8_t)0,(void*)&USB_ControlRequest,
            (uint32_t)USBD_EP0_SETUP_PKT_SIZE);
  device.IsSetupRecieved = (uint8_t)true;
 8025b66:	f043 0302 	orr.w	r3, r3, #2
 8025b6a:	f884 313e 	strb.w	r3, [r4, #318]	; 0x13e

  if ((uint32_t)USBD_EP0_SETUP_PKT_SIZE == ret_val)
 8025b6e:	d1e1      	bne.n	8025b34 <USBD_SignalEndpointEvent_Handler+0x90>
  {
    /* if length is zero we have only a in_status phase */
    if (0U == (uint32_t)USB_ControlRequest.wLength)
 8025b70:	f8b6 9006 	ldrh.w	r9, [r6, #6]
 8025b74:	fa1f f989 	uxth.w	r9, r9
 8025b78:	f1b9 0f00 	cmp.w	r9, #0
 8025b7c:	d068      	beq.n	8025c50 <USBD_SignalEndpointEvent_Handler+0x1ac>
      USBD_Handle_DeviceRequest();
      device.Driver->EndpointWrite((uint8_t)0, (uint8_t*)0, (uint32_t)0);
    }
    else
    {
      if (USB_ControlRequest.bmRequestType & CONTROL_REQTYPE_DIRECTION)
 8025b7e:	7833      	ldrb	r3, [r6, #0]
 8025b80:	0619      	lsls	r1, r3, #24
 8025b82:	d471      	bmi.n	8025c68 <USBD_SignalEndpointEvent_Handler+0x1c4>
      }
      else
      {
        device.ep0_state = USBD_EP0_STATE_OUT_DATA;
        /* Do not process request here, first read data */
        device.Driver->EndpointReadStart((uint8_t)0, (uint32_t)USB_ControlRequest.wLength);
 8025b84:	88f1      	ldrh	r1, [r6, #6]
 8025b86:	6823      	ldr	r3, [r4, #0]
        device.ep0_state = USBD_EP0_STATE_IN_DATA;
        USBD_Handle_DeviceRequest();
      }
      else
      {
        device.ep0_state = USBD_EP0_STATE_OUT_DATA;
 8025b88:	2204      	movs	r2, #4
        /* Do not process request here, first read data */
        device.Driver->EndpointReadStart((uint8_t)0, (uint32_t)USB_ControlRequest.wLength);
 8025b8a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
        device.ep0_state = USBD_EP0_STATE_IN_DATA;
        USBD_Handle_DeviceRequest();
      }
      else
      {
        device.ep0_state = USBD_EP0_STATE_OUT_DATA;
 8025b8c:	f884 213b 	strb.w	r2, [r4, #315]	; 0x13b
        /* Do not process request here, first read data */
        device.Driver->EndpointReadStart((uint8_t)0, (uint32_t)USB_ControlRequest.wLength);
 8025b90:	b289      	uxth	r1, r1
 8025b92:	4628      	mov	r0, r5
 8025b94:	4798      	blx	r3
 8025b96:	e7cd      	b.n	8025b34 <USBD_SignalEndpointEvent_Handler+0x90>
        default:
          break;
      }
      break;
    case XMC_USBD_EP_EVENT_OUT:
      ep->IsOutRecieved = 1U;
 8025b98:	232c      	movs	r3, #44	; 0x2c
 8025b9a:	fb03 4305 	mla	r3, r3, r5, r4
 8025b9e:	4699      	mov	r9, r3
 8025ba0:	891a      	ldrh	r2, [r3, #8]
 8025ba2:	f042 0220 	orr.w	r2, r2, #32
 8025ba6:	f829 2f08 	strh.w	r2, [r9, #8]!
      if (ep->OutBytesAvailable == 0U)
 8025baa:	f8d9 2004 	ldr.w	r2, [r9, #4]
 8025bae:	b1da      	cbz	r2, 8025be8 <USBD_SignalEndpointEvent_Handler+0x144>
      {
        ep->OutOffset = 0U; /* clear offset, new data is there */
        ep->OutBytesAvailable = (uint32_t)device.Driver->EndpointRead((uint8_t)ep->Address,
                                ep->OutBuffer,ep->OutBufferLength);
      }
      ep->OutInUse = (uint8_t)0;
 8025bb0:	232c      	movs	r3, #44	; 0x2c
 8025bb2:	fb03 4606 	mla	r6, r3, r6, r4
 8025bb6:	f8df 90bc 	ldr.w	r9, [pc, #188]	; 8025c74 <USBD_SignalEndpointEvent_Handler+0x1d0>
 8025bba:	8933      	ldrh	r3, [r6, #8]
 8025bbc:	f36f 03c3 	bfc	r3, #3, #1
 8025bc0:	8133      	strh	r3, [r6, #8]
      switch (device.CurrentEndpoint)
 8025bc2:	2d00      	cmp	r5, #0
 8025bc4:	d1b6      	bne.n	8025b34 <USBD_SignalEndpointEvent_Handler+0x90>
 * USBD_EP0_STATE_OUT_DATA state, it handles the received data and starts a write
 * transaction for \ref USBD_EP0_STATE_IN_STATUS.
 */
static void USBD_HandleEP0_OUT()
{
  if (USBD_EP0_STATE_OUT_DATA == device.ep0_state)
 8025bc6:	f899 313b 	ldrb.w	r3, [r9, #315]	; 0x13b
 8025bca:	2b04      	cmp	r3, #4
 8025bcc:	d033      	beq.n	8025c36 <USBD_SignalEndpointEvent_Handler+0x192>
    USBD_Handle_DeviceRequest();
    /* Zero length packet for status stage */
    device.Driver->EndpointWrite((uint8_t)0,(uint8_t*)0,(uint32_t)0);
    device.ep0_state = USBD_EP0_STATE_IN_STATUS;
  }
  else if (USBD_EP0_STATE_OUT_STATUS == device.ep0_state)
 8025bce:	2b05      	cmp	r3, #5
 8025bd0:	d1b0      	bne.n	8025b34 <USBD_SignalEndpointEvent_Handler+0x90>
    device.ep0_state = USBD_EP0_STATE_OUT_STATUS;
  }
  else if (USBD_EP0_STATE_IN_STATUS == device.ep0_state)
  {
    /* Request new setup packet */
    device.Driver->EndpointReadStart((uint8_t)device.Endpoints[0].Address,(uint32_t)USBD_EP0_3SETUP_PKT_SIZE);
 8025bd2:	f8d9 3000 	ldr.w	r3, [r9]
 8025bd6:	f899 0004 	ldrb.w	r0, [r9, #4]
 8025bda:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8025bdc:	2118      	movs	r1, #24
 8025bde:	4798      	blx	r3
    device.ep0_state = USBD_EP0_STATE_IDLE;
 8025be0:	2301      	movs	r3, #1
 8025be2:	f889 313b 	strb.w	r3, [r9, #315]	; 0x13b
 8025be6:	e7a5      	b.n	8025b34 <USBD_SignalEndpointEvent_Handler+0x90>
    case XMC_USBD_EP_EVENT_OUT:
      ep->IsOutRecieved = 1U;
      if (ep->OutBytesAvailable == 0U)
      {
        ep->OutOffset = 0U; /* clear offset, new data is there */
        ep->OutBytesAvailable = (uint32_t)device.Driver->EndpointRead((uint8_t)ep->Address,
 8025be8:	6821      	ldr	r1, [r4, #0]
      break;
    case XMC_USBD_EP_EVENT_OUT:
      ep->IsOutRecieved = 1U;
      if (ep->OutBytesAvailable == 0U)
      {
        ep->OutOffset = 0U; /* clear offset, new data is there */
 8025bea:	f8c9 2008 	str.w	r2, [r9, #8]
        ep->OutBytesAvailable = (uint32_t)device.Driver->EndpointRead((uint8_t)ep->Address,
 8025bee:	6acd      	ldr	r5, [r1, #44]	; 0x2c
 8025bf0:	7918      	ldrb	r0, [r3, #4]
 8025bf2:	6959      	ldr	r1, [r3, #20]
 8025bf4:	699a      	ldr	r2, [r3, #24]
 8025bf6:	47a8      	blx	r5
 8025bf8:	f894 513c 	ldrb.w	r5, [r4, #316]	; 0x13c
 8025bfc:	f8c9 0004 	str.w	r0, [r9, #4]
 8025c00:	e7d6      	b.n	8025bb0 <USBD_SignalEndpointEvent_Handler+0x10c>
      break;
    case XMC_USBD_EP_EVENT_IN:
      /* loop write transfers */
      if (ep->InDataLeft > 0U)
      {
        data_count = device.Driver->EndpointWrite((uint8_t)ep->Address,ep->InDataBuffer,ep->InDataLeft);
 8025c02:	6821      	ldr	r1, [r4, #0]
 8025c04:	7918      	ldrb	r0, [r3, #4]
 8025c06:	6b0e      	ldr	r6, [r1, #48]	; 0x30
 8025c08:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 8025c0a:	f103 0528 	add.w	r5, r3, #40	; 0x28
 8025c0e:	47b0      	blx	r6
        ep->InDataLeft -= (uint32_t)data_count;
        ep->InDataBuffer += (uint32_t)data_count;
 8025c10:	686a      	ldr	r2, [r5, #4]
    case XMC_USBD_EP_EVENT_IN:
      /* loop write transfers */
      if (ep->InDataLeft > 0U)
      {
        data_count = device.Driver->EndpointWrite((uint8_t)ep->Address,ep->InDataBuffer,ep->InDataLeft);
        ep->InDataLeft -= (uint32_t)data_count;
 8025c12:	f8d9 3008 	ldr.w	r3, [r9, #8]
        ep->InDataBuffer += (uint32_t)data_count;
 8025c16:	4402      	add	r2, r0
    case XMC_USBD_EP_EVENT_IN:
      /* loop write transfers */
      if (ep->InDataLeft > 0U)
      {
        data_count = device.Driver->EndpointWrite((uint8_t)ep->Address,ep->InDataBuffer,ep->InDataLeft);
        ep->InDataLeft -= (uint32_t)data_count;
 8025c18:	1a1b      	subs	r3, r3, r0
        ep->InDataBuffer += (uint32_t)data_count;
 8025c1a:	606a      	str	r2, [r5, #4]
    case XMC_USBD_EP_EVENT_IN:
      /* loop write transfers */
      if (ep->InDataLeft > 0U)
      {
        data_count = device.Driver->EndpointWrite((uint8_t)ep->Address,ep->InDataBuffer,ep->InDataLeft);
        ep->InDataLeft -= (uint32_t)data_count;
 8025c1c:	f8c9 3008 	str.w	r3, [r9, #8]
        ep->InDataBuffer += (uint32_t)data_count;
        break;
 8025c20:	e788      	b.n	8025b34 <USBD_SignalEndpointEvent_Handler+0x90>
static void USBD_HandleEP0_IN()
{
  if (USBD_EP0_STATE_IN_DATA == device.ep0_state)
  {
    /* Read zero length out data packet */
    device.Driver->EndpointReadStart((uint8_t)0,0U);
 8025c22:	f8d9 3000 	ldr.w	r3, [r9]
 8025c26:	4628      	mov	r0, r5
 8025c28:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8025c2a:	4629      	mov	r1, r5
 8025c2c:	4798      	blx	r3
    device.ep0_state = USBD_EP0_STATE_OUT_STATUS;
 8025c2e:	2305      	movs	r3, #5
 8025c30:	f889 313b 	strb.w	r3, [r9, #315]	; 0x13b
 8025c34:	e77e      	b.n	8025b34 <USBD_SignalEndpointEvent_Handler+0x90>
static void USBD_HandleEP0_OUT()
{
  if (USBD_EP0_STATE_OUT_DATA == device.ep0_state)
  {
    /* Now we have the data for handling the request */
    USBD_Handle_DeviceRequest();
 8025c36:	f7ff fda7 	bl	8025788 <USBD_Handle_DeviceRequest>
    /* Zero length packet for status stage */
    device.Driver->EndpointWrite((uint8_t)0,(uint8_t*)0,(uint32_t)0);
 8025c3a:	f8d9 3000 	ldr.w	r3, [r9]
 8025c3e:	4628      	mov	r0, r5
 8025c40:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8025c42:	4629      	mov	r1, r5
 8025c44:	462a      	mov	r2, r5
 8025c46:	4798      	blx	r3
    device.ep0_state = USBD_EP0_STATE_IN_STATUS;
 8025c48:	2303      	movs	r3, #3
 8025c4a:	f889 313b 	strb.w	r3, [r9, #315]	; 0x13b
 8025c4e:	e771      	b.n	8025b34 <USBD_SignalEndpointEvent_Handler+0x90>
  if ((uint32_t)USBD_EP0_SETUP_PKT_SIZE == ret_val)
  {
    /* if length is zero we have only a in_status phase */
    if (0U == (uint32_t)USB_ControlRequest.wLength)
    {
      device.ep0_state = USBD_EP0_STATE_IN_STATUS;
 8025c50:	2303      	movs	r3, #3
 8025c52:	f884 313b 	strb.w	r3, [r4, #315]	; 0x13b
      USBD_Handle_DeviceRequest();
 8025c56:	f7ff fd97 	bl	8025788 <USBD_Handle_DeviceRequest>
      device.Driver->EndpointWrite((uint8_t)0, (uint8_t*)0, (uint32_t)0);
 8025c5a:	6823      	ldr	r3, [r4, #0]
 8025c5c:	4648      	mov	r0, r9
 8025c5e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8025c60:	4649      	mov	r1, r9
 8025c62:	464a      	mov	r2, r9
 8025c64:	4798      	blx	r3
 8025c66:	e765      	b.n	8025b34 <USBD_SignalEndpointEvent_Handler+0x90>
    }
    else
    {
      if (USB_ControlRequest.bmRequestType & CONTROL_REQTYPE_DIRECTION)
      {
        device.ep0_state = USBD_EP0_STATE_IN_DATA;
 8025c68:	2302      	movs	r3, #2
 8025c6a:	f884 313b 	strb.w	r3, [r4, #315]	; 0x13b
        USBD_Handle_DeviceRequest();
 8025c6e:	f7ff fd8b 	bl	8025788 <USBD_Handle_DeviceRequest>
 8025c72:	e75f      	b.n	8025b34 <USBD_SignalEndpointEvent_Handler+0x90>
 8025c74:	1fff0594 	.word	0x1fff0594
 8025c78:	1fff038c 	.word	0x1fff038c

08025c7c <USBD_Init>:
 * Intializes the USB driver core data structures and sets it into default
 * state. Afterwards it initializes the USB device controller driver and prepare
 *  it for connection via USBD_Connect.
 */
USBD_STATUS_t USBD_Init(USBD_t *handle)
{
 8025c7c:	b570      	push	{r4, r5, r6, lr}
	/* Disable USB to resolve the disconnect issue on self powered devices.
	 * Later in the XMC_USBD_Init() it enables the USB.
	 */
	XMC_USBD_Disable();

	memset(&device,0x0,sizeof(USB_Device_t));
 8025c7e:	4c3b      	ldr	r4, [pc, #236]	; (8025d6c <USBD_Init+0xf0>)
 * Intializes the USB driver core data structures and sets it into default
 * state. Afterwards it initializes the USB device controller driver and prepare
 *  it for connection via USBD_Connect.
 */
USBD_STATUS_t USBD_Init(USBD_t *handle)
{
 8025c80:	4605      	mov	r5, r0


	/* Disable USB to resolve the disconnect issue on self powered devices.
	 * Later in the XMC_USBD_Init() it enables the USB.
	 */
	XMC_USBD_Disable();
 8025c82:	f7fd fb29 	bl	80232d8 <XMC_USBD_Disable>

	memset(&device,0x0,sizeof(USB_Device_t));
 8025c86:	2100      	movs	r1, #0
 8025c88:	f44f 72a2 	mov.w	r2, #324	; 0x144
 8025c8c:	4620      	mov	r0, r4
 8025c8e:	f007 fc62 	bl	802d556 <memset>
	USB_DeviceState = (uint8_t)DEVICE_STATE_Unattached;
 8025c92:	4b37      	ldr	r3, [pc, #220]	; (8025d70 <USBD_Init+0xf4>)
	device.Driver = &Driver_USBD0;
 8025c94:	4837      	ldr	r0, [pc, #220]	; (8025d74 <USBD_Init+0xf8>)
 8025c96:	6020      	str	r0, [r4, #0]
	device.Endpoints[0].InBuffer = endpoint0_in_buffer;
	device.Endpoints[0].InBufferLength = USBD_EP0_BUF_SIZE;
	device.Endpoints[0].OutBuffer = endpoint0_out_buffer;
	device.Endpoints[0].OutBufferLength = USBD_EP0_BUF_SIZE;
	device.Endpoints[0].Direction = (uint8_t)0;
	device.Endpoints[0].IsConfigured = (uint8_t)1;
 8025c98:	2601      	movs	r6, #1
	 * Later in the XMC_USBD_Init() it enables the USB.
	 */
	XMC_USBD_Disable();

	memset(&device,0x0,sizeof(USB_Device_t));
	USB_DeviceState = (uint8_t)DEVICE_STATE_Unattached;
 8025c9a:	2000      	movs	r0, #0
 8025c9c:	7018      	strb	r0, [r3, #0]
	device.Endpoints[0].InBuffer = endpoint0_in_buffer;
	device.Endpoints[0].InBufferLength = USBD_EP0_BUF_SIZE;
	device.Endpoints[0].OutBuffer = endpoint0_out_buffer;
	device.Endpoints[0].OutBufferLength = USBD_EP0_BUF_SIZE;
	device.Endpoints[0].Direction = (uint8_t)0;
	device.Endpoints[0].IsConfigured = (uint8_t)1;
 8025c9e:	7226      	strb	r6, [r4, #8]
	device.Endpoints[0].IsEnabled = (uint8_t)1;
 8025ca0:	8923      	ldrh	r3, [r4, #8]
	USB_DeviceState = (uint8_t)DEVICE_STATE_Unattached;
	device.Driver = &Driver_USBD0;
	device.ep0_state = USBD_EP0_STATE_IDLE;
	device.Endpoints[0].InBuffer = endpoint0_in_buffer;
	device.Endpoints[0].InBufferLength = USBD_EP0_BUF_SIZE;
	device.Endpoints[0].OutBuffer = endpoint0_out_buffer;
 8025ca2:	4a35      	ldr	r2, [pc, #212]	; (8025d78 <USBD_Init+0xfc>)
 8025ca4:	6162      	str	r2, [r4, #20]
	device.Endpoints[0].OutBufferLength = USBD_EP0_BUF_SIZE;
	device.Endpoints[0].Direction = (uint8_t)0;
	device.Endpoints[0].IsConfigured = (uint8_t)1;
	device.Endpoints[0].IsEnabled = (uint8_t)1;
 8025ca6:	f043 0302 	orr.w	r3, r3, #2
 8025caa:	8123      	strh	r3, [r4, #8]
	device.Endpoints[0].MaxPacketSize = (uint8_t)USBD_EP0_MAX_PKT_SIZE;
 8025cac:	8923      	ldrh	r3, [r4, #8]

	memset(&device,0x0,sizeof(USB_Device_t));
	USB_DeviceState = (uint8_t)DEVICE_STATE_Unattached;
	device.Driver = &Driver_USBD0;
	device.ep0_state = USBD_EP0_STATE_IDLE;
	device.Endpoints[0].InBuffer = endpoint0_in_buffer;
 8025cae:	4933      	ldr	r1, [pc, #204]	; (8025d7c <USBD_Init+0x100>)
 8025cb0:	6221      	str	r1, [r4, #32]
	device.Endpoints[0].OutBuffer = endpoint0_out_buffer;
	device.Endpoints[0].OutBufferLength = USBD_EP0_BUF_SIZE;
	device.Endpoints[0].Direction = (uint8_t)0;
	device.Endpoints[0].IsConfigured = (uint8_t)1;
	device.Endpoints[0].IsEnabled = (uint8_t)1;
	device.Endpoints[0].MaxPacketSize = (uint8_t)USBD_EP0_MAX_PKT_SIZE;
 8025cb2:	2240      	movs	r2, #64	; 0x40
 8025cb4:	f362 138c 	bfi	r3, r2, #6, #7
 8025cb8:	8123      	strh	r3, [r4, #8]

	if ((handle->event_cb->control_request == 0) ||
 8025cba:	692b      	ldr	r3, [r5, #16]
 8025cbc:	68d9      	ldr	r1, [r3, #12]
	XMC_USBD_Disable();

	memset(&device,0x0,sizeof(USB_Device_t));
	USB_DeviceState = (uint8_t)DEVICE_STATE_Unattached;
	device.Driver = &Driver_USBD0;
	device.ep0_state = USBD_EP0_STATE_IDLE;
 8025cbe:	f884 613b 	strb.w	r6, [r4, #315]	; 0x13b
	device.Endpoints[0].InBuffer = endpoint0_in_buffer;
	device.Endpoints[0].InBufferLength = USBD_EP0_BUF_SIZE;
 8025cc2:	f44f 7280 	mov.w	r2, #256	; 0x100
	XMC_USBD_Disable();

	memset(&device,0x0,sizeof(USB_Device_t));
	USB_DeviceState = (uint8_t)DEVICE_STATE_Unattached;
	device.Driver = &Driver_USBD0;
	device.ep0_state = USBD_EP0_STATE_IDLE;
 8025cc6:	4630      	mov	r0, r6
	device.Endpoints[0].InBuffer = endpoint0_in_buffer;
	device.Endpoints[0].InBufferLength = USBD_EP0_BUF_SIZE;
 8025cc8:	6262      	str	r2, [r4, #36]	; 0x24
	device.Endpoints[0].OutBuffer = endpoint0_out_buffer;
	device.Endpoints[0].OutBufferLength = USBD_EP0_BUF_SIZE;
 8025cca:	61a2      	str	r2, [r4, #24]
	device.Endpoints[0].Direction = (uint8_t)0;
	device.Endpoints[0].IsConfigured = (uint8_t)1;
	device.Endpoints[0].IsEnabled = (uint8_t)1;
	device.Endpoints[0].MaxPacketSize = (uint8_t)USBD_EP0_MAX_PKT_SIZE;

	if ((handle->event_cb->control_request == 0) ||
 8025ccc:	b321      	cbz	r1, 8025d18 <USBD_Init+0x9c>
 8025cce:	695a      	ldr	r2, [r3, #20]
 8025cd0:	b312      	cbz	r2, 8025d18 <USBD_Init+0x9c>
	    (handle->event_cb->get_descriptor == 0) ||
 8025cd2:	689a      	ldr	r2, [r3, #8]
 8025cd4:	b302      	cbz	r2, 8025d18 <USBD_Init+0x9c>
	{
	  status = USBD_STATUS_FAILURE;
	}
	else
	{
	  device.events = handle->event_cb;
 8025cd6:	f8c4 3140 	str.w	r3, [r4, #320]	; 0x140

	  XMC_SCU_CLOCK_EnableClock(XMC_SCU_CLOCK_USB);
 8025cda:	f7fb fa05 	bl	80210e8 <XMC_SCU_CLOCK_EnableClock>

	  /* First initalize the device */
	  handle->usb_init.cb_xmc_device_event = USBD_SignalDeviceEventHandler;
	  handle->usb_init.cb_endpoint_event = USBD_SignalEndpointEvent_Handler;

	  status = (USBD_STATUS_t)device.Driver->Initialize(&handle->usb_init);
 8025cde:	6823      	ldr	r3, [r4, #0]
	  device.events = handle->event_cb;

	  XMC_SCU_CLOCK_EnableClock(XMC_SCU_CLOCK_USB);

	  /* First initalize the device */
	  handle->usb_init.cb_xmc_device_event = USBD_SignalDeviceEventHandler;
 8025ce0:	4927      	ldr	r1, [pc, #156]	; (8025d80 <USBD_Init+0x104>)
	  handle->usb_init.cb_endpoint_event = USBD_SignalEndpointEvent_Handler;
 8025ce2:	4a28      	ldr	r2, [pc, #160]	; (8025d84 <USBD_Init+0x108>)

	  status = (USBD_STATUS_t)device.Driver->Initialize(&handle->usb_init);
 8025ce4:	685b      	ldr	r3, [r3, #4]
	  device.events = handle->event_cb;

	  XMC_SCU_CLOCK_EnableClock(XMC_SCU_CLOCK_USB);

	  /* First initalize the device */
	  handle->usb_init.cb_xmc_device_event = USBD_SignalDeviceEventHandler;
 8025ce6:	6069      	str	r1, [r5, #4]
	  handle->usb_init.cb_endpoint_event = USBD_SignalEndpointEvent_Handler;
 8025ce8:	60aa      	str	r2, [r5, #8]

	  status = (USBD_STATUS_t)device.Driver->Initialize(&handle->usb_init);
 8025cea:	4628      	mov	r0, r5
 8025cec:	4798      	blx	r3
	  if (USBD_STATUS_SUCCESS == status)
 8025cee:	4605      	mov	r5, r0
 8025cf0:	b1a8      	cbz	r0, 8025d1e <USBD_Init+0xa2>
	       (uint16_t)XMC_USBD_MAX_PACKET_SIZE);
	  }

	  if (USBD_STATUS_SUCCESS != status)
	  {
	  XMC_USBD_Disable();
 8025cf2:	f7fd faf1 	bl	80232d8 <XMC_USBD_Disable>
	  if (USBD_STATUS_SUCCESS == (USBD_STATUS_t)device.Driver->Uninitialize())
 8025cf6:	6823      	ldr	r3, [r4, #0]
 8025cf8:	689b      	ldr	r3, [r3, #8]
 8025cfa:	4798      	blx	r3
 8025cfc:	b950      	cbnz	r0, 8025d14 <USBD_Init+0x98>
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8025cfe:	4b22      	ldr	r3, [pc, #136]	; (8025d88 <USBD_Init+0x10c>)
 8025d00:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8025d04:	f8c3 218c 	str.w	r2, [r3, #396]	; 0x18c
 */
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8025d08:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 8025d0c:	f3bf 8f4f 	dsb	sy
           so that all instructions following the ISB are fetched from cache or memory,
           after the instruction has been completed.
 */
__attribute__((always_inline)) __STATIC_INLINE void __ISB(void)
{
  __ASM volatile ("isb 0xF":::"memory");
 8025d10:	f3bf 8f6f 	isb	sy
	  }
	}


	return status;
}
 8025d14:	4628      	mov	r0, r5
 8025d16:	bd70      	pop	{r4, r5, r6, pc}

	if ((handle->event_cb->control_request == 0) ||
	    (handle->event_cb->get_descriptor == 0) ||
	    (handle->event_cb->config_changed == 0))
	{
	  status = USBD_STATUS_FAILURE;
 8025d18:	4605      	mov	r5, r0
	  }
	}


	return status;
}
 8025d1a:	4628      	mov	r0, r5
 8025d1c:	bd70      	pop	{r4, r5, r6, pc}
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8025d1e:	4b1b      	ldr	r3, [pc, #108]	; (8025d8c <USBD_Init+0x110>)
 8025d20:	68db      	ldr	r3, [r3, #12]
 8025d22:	f3c3 2302 	ubfx	r3, r3, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8025d26:	f1c3 0107 	rsb	r1, r3, #7
 8025d2a:	2906      	cmp	r1, #6
 8025d2c:	bf28      	it	cs
 8025d2e:	2106      	movcs	r1, #6
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8025d30:	b1cb      	cbz	r3, 8025d66 <USBD_Init+0xea>
 8025d32:	1e5a      	subs	r2, r3, #1

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8025d34:	2301      	movs	r3, #1
 8025d36:	408b      	lsls	r3, r1
 8025d38:	3b01      	subs	r3, #1
 8025d3a:	4093      	lsls	r3, r2
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8025d3c:	009b      	lsls	r3, r3, #2
 8025d3e:	4a12      	ldr	r2, [pc, #72]	; (8025d88 <USBD_Init+0x10c>)
 8025d40:	b2db      	uxtb	r3, r3
 8025d42:	f882 336b 	strb.w	r3, [r2, #875]	; 0x36b
	  {
	  /* Enable Interrupts in NVIC */
	  USB_EnableUSBInterrupt();

	  /* then configure endpoint 0 */
	  status = (USBD_STATUS_t)device.Driver->EndpointConfigure((uint8_t)0,XMC_USBD_ENDPOINT_TYPE_CONTROL,
 8025d46:	6823      	ldr	r3, [r4, #0]
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8025d48:	f44f 6100 	mov.w	r1, #2048	; 0x800
 8025d4c:	2000      	movs	r0, #0
 8025d4e:	f8c2 118c 	str.w	r1, [r2, #396]	; 0x18c
 8025d52:	69db      	ldr	r3, [r3, #28]
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8025d54:	60d1      	str	r1, [r2, #12]
 8025d56:	4601      	mov	r1, r0
 8025d58:	2240      	movs	r2, #64	; 0x40
 8025d5a:	4798      	blx	r3
	       (uint16_t)XMC_USBD_MAX_PACKET_SIZE);
	  }

	  if (USBD_STATUS_SUCCESS != status)
 8025d5c:	4605      	mov	r5, r0
 8025d5e:	2800      	cmp	r0, #0
 8025d60:	d1c7      	bne.n	8025cf2 <USBD_Init+0x76>
	  }
	}


	return status;
}
 8025d62:	4628      	mov	r0, r5
 8025d64:	bd70      	pop	{r4, r5, r6, pc}
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8025d66:	461a      	mov	r2, r3
 8025d68:	e7e4      	b.n	8025d34 <USBD_Init+0xb8>
 8025d6a:	bf00      	nop
 8025d6c:	1fff0594 	.word	0x1fff0594
 8025d70:	1fff0389 	.word	0x1fff0389
 8025d74:	0802d7f4 	.word	0x0802d7f4
 8025d78:	1fff0494 	.word	0x1fff0494
 8025d7c:	1fff0394 	.word	0x1fff0394
 8025d80:	0802545d 	.word	0x0802545d
 8025d84:	08025aa5 	.word	0x08025aa5
 8025d88:	e000e100 	.word	0xe000e100
 8025d8c:	e000ed00 	.word	0xe000ed00

08025d90 <USBD_Connect>:
 * Tell the USB device controller driver to connect to the bus. Successful connection will be shown
 * through update of the device status ( USB_DeviceState) and a firing of the USB device connect event.
 */
USBD_STATUS_t USBD_Connect(void)
{
  return (USBD_STATUS_t)device.Driver->DeviceConnect();
 8025d90:	4b01      	ldr	r3, [pc, #4]	; (8025d98 <USBD_Connect+0x8>)
 8025d92:	681b      	ldr	r3, [r3, #0]
 8025d94:	68db      	ldr	r3, [r3, #12]
 8025d96:	4718      	bx	r3
 8025d98:	1fff0594 	.word	0x1fff0594

08025d9c <USBD_IsEnumDone>:
 * Check with the USB device controller driver if the enumeration is done.
 * Returns 1 on completion of enumeration.
 */
uint32_t USBD_IsEnumDone(void)
{
  return device.Driver->IsEnumDone();
 8025d9c:	4b01      	ldr	r3, [pc, #4]	; (8025da4 <USBD_IsEnumDone+0x8>)
 8025d9e:	681b      	ldr	r3, [r3, #0]
 8025da0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8025da2:	4718      	bx	r3
 8025da4:	1fff0594 	.word	0x1fff0594

08025da8 <USBD_SetEndpointBuffer>:
  XMC_ASSERT("USBD_SetEndpointBuffer: invalid buffer", (buf != NULL));

  number = (uint32_t)addr & (uint32_t)ENDPOINT_EPNUM_MASK;
  XMC_ASSERT("USBD_SetEndpointBuffer: invalid ep address", (number < (uint8_t)USBD_MAX_NUM_EPS));

  if (addr & (uint8_t)ENDPOINT_DIR_MASK)
 8025da8:	f010 0f80 	tst.w	r0, #128	; 0x80
 *
 * The user has to ensure that an endpoint has a valid buffer for proper data transfer.
 *
 */
void USBD_SetEndpointBuffer(uint8_t addr, uint8_t *buf, uint16_t len)
{
 8025dac:	b410      	push	{r4}
  number = (uint32_t)addr & (uint32_t)ENDPOINT_EPNUM_MASK;
  XMC_ASSERT("USBD_SetEndpointBuffer: invalid ep address", (number < (uint8_t)USBD_MAX_NUM_EPS));

  if (addr & (uint8_t)ENDPOINT_DIR_MASK)
  {
    device.Endpoints[number].InBuffer = buf;
 8025dae:	4b0a      	ldr	r3, [pc, #40]	; (8025dd8 <USBD_SetEndpointBuffer+0x30>)
void USBD_SetEndpointBuffer(uint8_t addr, uint8_t *buf, uint16_t len)
{
  uint32_t number;
  XMC_ASSERT("USBD_SetEndpointBuffer: invalid buffer", (buf != NULL));

  number = (uint32_t)addr & (uint32_t)ENDPOINT_EPNUM_MASK;
 8025db0:	f000 040f 	and.w	r4, r0, #15
  XMC_ASSERT("USBD_SetEndpointBuffer: invalid ep address", (number < (uint8_t)USBD_MAX_NUM_EPS));

  if (addr & (uint8_t)ENDPOINT_DIR_MASK)
  {
    device.Endpoints[number].InBuffer = buf;
 8025db4:	f04f 002c 	mov.w	r0, #44	; 0x2c
  XMC_ASSERT("USBD_SetEndpointBuffer: invalid buffer", (buf != NULL));

  number = (uint32_t)addr & (uint32_t)ENDPOINT_EPNUM_MASK;
  XMC_ASSERT("USBD_SetEndpointBuffer: invalid ep address", (number < (uint8_t)USBD_MAX_NUM_EPS));

  if (addr & (uint8_t)ENDPOINT_DIR_MASK)
 8025db8:	d106      	bne.n	8025dc8 <USBD_SetEndpointBuffer+0x20>
    device.Endpoints[number].InBuffer = buf;
    device.Endpoints[number].InBufferLength = len;
  }
  else
  {
    device.Endpoints[number].OutBuffer = buf;
 8025dba:	fb00 3304 	mla	r3, r0, r4, r3
    device.Endpoints[number].OutBufferLength = len;
  }

}
 8025dbe:	f85d 4b04 	ldr.w	r4, [sp], #4
    device.Endpoints[number].InBuffer = buf;
    device.Endpoints[number].InBufferLength = len;
  }
  else
  {
    device.Endpoints[number].OutBuffer = buf;
 8025dc2:	6159      	str	r1, [r3, #20]
    device.Endpoints[number].OutBufferLength = len;
 8025dc4:	619a      	str	r2, [r3, #24]
  }

}
 8025dc6:	4770      	bx	lr
  number = (uint32_t)addr & (uint32_t)ENDPOINT_EPNUM_MASK;
  XMC_ASSERT("USBD_SetEndpointBuffer: invalid ep address", (number < (uint8_t)USBD_MAX_NUM_EPS));

  if (addr & (uint8_t)ENDPOINT_DIR_MASK)
  {
    device.Endpoints[number].InBuffer = buf;
 8025dc8:	fb00 3404 	mla	r4, r0, r4, r3
 8025dcc:	6221      	str	r1, [r4, #32]
    device.Endpoints[number].InBufferLength = len;
 8025dce:	6262      	str	r2, [r4, #36]	; 0x24
  {
    device.Endpoints[number].OutBuffer = buf;
    device.Endpoints[number].OutBufferLength = len;
  }

}
 8025dd0:	f85d 4b04 	ldr.w	r4, [sp], #4
 8025dd4:	4770      	bx	lr
 8025dd6:	bf00      	nop
 8025dd8:	1fff0594 	.word	0x1fff0594

08025ddc <USB0_0_IRQHandler>:
 * This function gets called, if a USB exception (interrupt) was thrown and
 * dispatches it to XMC_USBD_IRQHandler.
 */
void USB0_0_IRQHandler(void)
{
  XMC_USBD_IRQHandler(&(USBD_handle->usb_init));
 8025ddc:	4b01      	ldr	r3, [pc, #4]	; (8025de4 <USB0_0_IRQHandler+0x8>)
 8025dde:	6818      	ldr	r0, [r3, #0]
 8025de0:	f7fc be0e 	b.w	8022a00 <XMC_USBD_IRQHandler>
 8025de4:	1ffe9118 	.word	0x1ffe9118

08025de8 <TIMER_Init>:
/*
 * This function initializes a TIMER APP based on user configuration.
 *
 */
TIMER_STATUS_t TIMER_Init(TIMER_t* const handle_ptr)
{
 8025de8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  XMC_ASSERT("TIMER_Init:handle_ptr NULL" , (handle_ptr != NULL));

  status = TIMER_STATUS_SUCCESS;
  /* Check for APP instance is initialized or not */
  if (false == handle_ptr->initialized)
 8025dea:	f890 3026 	ldrb.w	r3, [r0, #38]	; 0x26
 8025dee:	2b00      	cmp	r3, #0
 8025df0:	d12f      	bne.n	8025e52 <TIMER_Init+0x6a>
  {
#ifdef TIMER_CCU4_USED
    if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
 8025df2:	f890 6021 	ldrb.w	r6, [r0, #33]	; 0x21
 8025df6:	b116      	cbz	r6, 8025dfe <TIMER_Init+0x16>
{
  TIMER_STATUS_t status;

  XMC_ASSERT("TIMER_Init:handle_ptr NULL" , (handle_ptr != NULL));

  status = TIMER_STATUS_SUCCESS;
 8025df8:	461d      	mov	r5, r3
    }
#endif
  }

  return (status);
}
 8025dfa:	4628      	mov	r0, r5
 8025dfc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8025dfe:	4604      	mov	r4, r0
 */
TIMER_STATUS_t TIMER_CCU4_lInit(TIMER_t* const handle_ptr)
{
  TIMER_STATUS_t status;
  /* Initialize the global registers */
  status = (TIMER_STATUS_t)GLOBAL_CCU4_Init(handle_ptr->global_ccu4_handler);
 8025e00:	6900      	ldr	r0, [r0, #16]
 8025e02:	f000 fc31 	bl	8026668 <GLOBAL_CCU4_Init>

  /* Enable the clock for selected timer */
  XMC_CCU4_EnableClock(handle_ptr->global_ccu4_handler->module_ptr, handle_ptr->ccu4_slice_number);
 8025e06:	6923      	ldr	r3, [r4, #16]
__STATIC_INLINE void XMC_CCU4_EnableClock(XMC_CCU4_MODULE_t *const module, const uint8_t slice_number)
{
  XMC_ASSERT("XMC_CCU4_EnableClock:Invalid Module Pointer", XMC_CCU4_IsValidModule(module));
  XMC_ASSERT("XMC_CCU4_EnableClock:Invalid Slice Number", (slice_number < 4U));

  module->GIDLC |= ((uint32_t) 1) << slice_number;
 8025e08:	f894 e018 	ldrb.w	lr, [r4, #24]
 8025e0c:	689f      	ldr	r7, [r3, #8]
  /* Configure the timer with required settings */
  XMC_CCU4_SLICE_CompareInit(handle_ptr->ccu4_slice_ptr, handle_ptr->ccu4_slice_config_ptr);
 8025e0e:	69e1      	ldr	r1, [r4, #28]
 8025e10:	68fa      	ldr	r2, [r7, #12]
 8025e12:	2301      	movs	r3, #1
 8025e14:	fa03 f30e 	lsl.w	r3, r3, lr
 8025e18:	4313      	orrs	r3, r2
 */
TIMER_STATUS_t TIMER_CCU4_lInit(TIMER_t* const handle_ptr)
{
  TIMER_STATUS_t status;
  /* Initialize the global registers */
  status = (TIMER_STATUS_t)GLOBAL_CCU4_Init(handle_ptr->global_ccu4_handler);
 8025e1a:	4605      	mov	r5, r0

  /* Enable the clock for selected timer */
  XMC_CCU4_EnableClock(handle_ptr->global_ccu4_handler->module_ptr, handle_ptr->ccu4_slice_number);
  /* Configure the timer with required settings */
  XMC_CCU4_SLICE_CompareInit(handle_ptr->ccu4_slice_ptr, handle_ptr->ccu4_slice_config_ptr);
 8025e1c:	6960      	ldr	r0, [r4, #20]
 8025e1e:	60fb      	str	r3, [r7, #12]
 8025e20:	f7fb fbe4 	bl	80215ec <XMC_CCU4_SLICE_CompareInit>
  /* programs the timer period register according to time interval value */
  XMC_CCU4_SLICE_SetTimerPeriodMatch(handle_ptr->ccu4_slice_ptr, handle_ptr->period_value);
  /* programs the timer compare register for 50% duty cycle */
  XMC_CCU4_SLICE_SetTimerCompareMatch(handle_ptr->ccu4_slice_ptr, TIMER_CMP_100_DUTY);
  /* Transfers value from shadow timer registers to actual timer registers */
  XMC_CCU4_EnableShadowTransfer(handle_ptr->global_ccu4_handler->module_ptr, handle_ptr->shadow_mask);
 8025e24:	6923      	ldr	r3, [r4, #16]
 * This function configures timer period and compare values and triggers the shadow transfer operation
 */
void TIMER_CCU4_lShadowTransfer(TIMER_t* const handle_ptr)
{
  /* programs the timer period register according to time interval value */
  XMC_CCU4_SLICE_SetTimerPeriodMatch(handle_ptr->ccu4_slice_ptr, handle_ptr->period_value);
 8025e26:	6960      	ldr	r0, [r4, #20]
  /* programs the timer compare register for 50% duty cycle */
  XMC_CCU4_SLICE_SetTimerCompareMatch(handle_ptr->ccu4_slice_ptr, TIMER_CMP_100_DUTY);
  /* Transfers value from shadow timer registers to actual timer registers */
  XMC_CCU4_EnableShadowTransfer(handle_ptr->global_ccu4_handler->module_ptr, handle_ptr->shadow_mask);
 8025e28:	689a      	ldr	r2, [r3, #8]
  XMC_CCU4_SLICE_CompareInit(handle_ptr->ccu4_slice_ptr, handle_ptr->ccu4_slice_config_ptr);
  /* programs the timer period and compare register according to time interval value and do the shadow transfer */
  TIMER_CCU4_lShadowTransfer(handle_ptr);

#ifdef  TIMER_INTERRUPT
  if (true == handle_ptr->period_match_enable)
 8025e2a:	f894 3025 	ldrb.w	r3, [r4, #37]	; 0x25
 *  XMC_CCU4_SLICE_GetTimerPeriodMatch().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_SetTimerPeriodMatch(XMC_CCU4_SLICE_t *const slice, const uint16_t period_val)
{
  XMC_ASSERT("XMC_CCU4_SLICE_SetTimerPeriodMatch:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->PRS = (uint32_t) period_val;
 8025e2e:	8c67      	ldrh	r7, [r4, #34]	; 0x22
  /* programs the timer period register according to time interval value */
  XMC_CCU4_SLICE_SetTimerPeriodMatch(handle_ptr->ccu4_slice_ptr, handle_ptr->period_value);
  /* programs the timer compare register for 50% duty cycle */
  XMC_CCU4_SLICE_SetTimerCompareMatch(handle_ptr->ccu4_slice_ptr, TIMER_CMP_100_DUTY);
  /* Transfers value from shadow timer registers to actual timer registers */
  XMC_CCU4_EnableShadowTransfer(handle_ptr->global_ccu4_handler->module_ptr, handle_ptr->shadow_mask);
 8025e30:	68e1      	ldr	r1, [r4, #12]
 8025e32:	6347      	str	r7, [r0, #52]	; 0x34
 *  XMC_CCU4_SLICE_GetTimerPeriodMatch().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_SetTimerCompareMatch(XMC_CCU4_SLICE_t *const slice, const uint16_t compare_val)
{
  XMC_ASSERT("XMC_CCU4_SLICE_SetTimerCompareMatch:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->CRS = (uint32_t) compare_val;
 8025e34:	63c6      	str	r6, [r0, #60]	; 0x3c
 *  None.
 */
__STATIC_INLINE void XMC_CCU4_EnableShadowTransfer(XMC_CCU4_MODULE_t *const module, const uint32_t shadow_transfer_msk)
{
  XMC_ASSERT("XMC_CCU4_EnableShadowTransfer:Invalid Slice Pointer", XMC_CCU4_IsValidModule(module));
  module->GCSS = (uint32_t)shadow_transfer_msk;  
 8025e36:	6111      	str	r1, [r2, #16]
  XMC_CCU4_SLICE_CompareInit(handle_ptr->ccu4_slice_ptr, handle_ptr->ccu4_slice_config_ptr);
  /* programs the timer period and compare register according to time interval value and do the shadow transfer */
  TIMER_CCU4_lShadowTransfer(handle_ptr);

#ifdef  TIMER_INTERRUPT
  if (true == handle_ptr->period_match_enable)
 8025e38:	b973      	cbnz	r3, 8025e58 <TIMER_Init+0x70>

  /* update the initialization flag as true for particular instance*/
  handle_ptr->initialized = true;

  /* Check whether the start of the timer is enabled during initialization or not */
  if (handle_ptr->start_control == true)
 8025e3a:	f894 2024 	ldrb.w	r2, [r4, #36]	; 0x24
 *  XMC_CCU4_SLICE_StartTimer().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_ClearTimer(XMC_CCU4_SLICE_t *const slice)
{
  XMC_ASSERT("XMC_CCU4_SLICE_ClearTimer:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->TCCLR = (uint32_t) CCU4_CC4_TCCLR_TCC_Msk;
 8025e3e:	2102      	movs	r1, #2
#endif
  /* Clears the timer register */
  XMC_CCU4_SLICE_ClearTimer(handle_ptr->ccu4_slice_ptr);

  /* update the initialization flag as true for particular instance*/
  handle_ptr->initialized = true;
 8025e40:	2301      	movs	r3, #1
 8025e42:	6101      	str	r1, [r0, #16]
 8025e44:	f884 3026 	strb.w	r3, [r4, #38]	; 0x26

  /* Check whether the start of the timer is enabled during initialization or not */
  if (handle_ptr->start_control == true)
 8025e48:	2a00      	cmp	r2, #0
 8025e4a:	d0d6      	beq.n	8025dfa <TIMER_Init+0x12>
 *  XMC_CCU4_SLICE_StopTimer().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_StartTimer(XMC_CCU4_SLICE_t *const slice)
{
  XMC_ASSERT("XMC_CCU4_SLICE_StartTimer:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->TCSET = CCU4_CC4_TCSET_TRBS_Msk;
 8025e4c:	60c3      	str	r3, [r0, #12]
    }
#endif
  }

  return (status);
}
 8025e4e:	4628      	mov	r0, r5
 8025e50:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
{
  TIMER_STATUS_t status;

  XMC_ASSERT("TIMER_Init:handle_ptr NULL" , (handle_ptr != NULL));

  status = TIMER_STATUS_SUCCESS;
 8025e52:	2500      	movs	r5, #0
    }
#endif
  }

  return (status);
}
 8025e54:	4628      	mov	r0, r5
 8025e56:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

#ifdef  TIMER_INTERRUPT
  if (true == handle_ptr->period_match_enable)
  {
    /* Binds a period match event to an NVIC node  */
    XMC_CCU4_SLICE_SetInterruptNode(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_PERIOD_MATCH,
 8025e58:	4631      	mov	r1, r6
 8025e5a:	f894 2020 	ldrb.w	r2, [r4, #32]
 8025e5e:	f7fb fbe7 	bl	8021630 <XMC_CCU4_SLICE_SetInterruptNode>
                                    handle_ptr->ccu4_period_match_node);
    /* Enables a timer(period match) event  */
    XMC_CCU4_SLICE_EnableEvent(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_PERIOD_MATCH);
 8025e62:	6960      	ldr	r0, [r4, #20]
__STATIC_INLINE void XMC_CCU4_SLICE_EnableEvent(XMC_CCU4_SLICE_t *const slice,
                                                const XMC_CCU4_SLICE_IRQ_ID_t event)
{
  XMC_ASSERT("XMC_CCU4_SLICE_EnableEvent:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_EnableEvent:Invalid SR event", XMC_CCU4_SLICE_CHECK_INTERRUPT(event));
  slice->INTE |= ((uint32_t) 1) << ((uint32_t) event);
 8025e64:	f8d0 30a4 	ldr.w	r3, [r0, #164]	; 0xa4
 8025e68:	f043 0301 	orr.w	r3, r3, #1
 8025e6c:	f8c0 30a4 	str.w	r3, [r0, #164]	; 0xa4
 8025e70:	e7e3      	b.n	8025e3a <TIMER_Init+0x52>
 8025e72:	bf00      	nop

08025e74 <TIMER_Start>:
  TIMER_STATUS_t status;

  XMC_ASSERT("TIMER_Start:handle_ptr NULL" , (handle_ptr != NULL));

  /* Check for APP instance is initialized or not */
  if (true == handle_ptr->initialized)
 8025e74:	f890 3026 	ldrb.w	r3, [r0, #38]	; 0x26
 8025e78:	b14b      	cbz	r3, 8025e8e <TIMER_Start+0x1a>
  {
#ifdef TIMER_CCU4_USED
    if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
 8025e7a:	f890 3021 	ldrb.w	r3, [r0, #33]	; 0x21
 8025e7e:	b923      	cbnz	r3, 8025e8a <TIMER_Start+0x16>
    {
      /* Start the timer manually */
      XMC_CCU4_SLICE_StartTimer(handle_ptr->ccu4_slice_ptr);
 8025e80:	6942      	ldr	r2, [r0, #20]
 *  XMC_CCU4_SLICE_StopTimer().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_StartTimer(XMC_CCU4_SLICE_t *const slice)
{
  XMC_ASSERT("XMC_CCU4_SLICE_StartTimer:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->TCSET = CCU4_CC4_TCSET_TRBS_Msk;
 8025e82:	2101      	movs	r1, #1
       {
      /* Start the timer manually */
      XMC_CCU8_SLICE_StartTimer(handle_ptr->ccu8_slice_ptr);
       }
#endif
    status = TIMER_STATUS_SUCCESS;
 8025e84:	4618      	mov	r0, r3
 8025e86:	60d1      	str	r1, [r2, #12]
 8025e88:	4770      	bx	lr
 8025e8a:	2000      	movs	r0, #0
  {
    status = TIMER_STATUS_FAILURE;
  }

  return (status);
}
 8025e8c:	4770      	bx	lr
#endif
    status = TIMER_STATUS_SUCCESS;
  }
  else
  {
    status = TIMER_STATUS_FAILURE;
 8025e8e:	2001      	movs	r0, #1
 8025e90:	4770      	bx	lr
 8025e92:	bf00      	nop

08025e94 <TIMER_Stop>:
  XMC_ASSERT("TIMER_GetTimerStatus:handle_ptr NULL" , (handle_ptr != NULL));

  status = false;

#ifdef TIMER_CCU4_USED
  if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
 8025e94:	f890 3021 	ldrb.w	r3, [r0, #33]	; 0x21
 8025e98:	b10b      	cbz	r3, 8025e9e <TIMER_Stop+0xa>
#endif
    status = TIMER_STATUS_SUCCESS;
  }
  else
  {
    status = TIMER_STATUS_FAILURE;
 8025e9a:	2001      	movs	r0, #1
  }

  return (status);
}
 8025e9c:	4770      	bx	lr

#ifdef TIMER_CCU4_USED
  if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
  {
    /* Returns the current status of the timer */
    status = XMC_CCU4_SLICE_IsTimerRunning(handle_ptr->ccu4_slice_ptr);
 8025e9e:	6941      	ldr	r1, [r0, #20]
 *  XMC_CCU4_SLICE_StartTimer()<BR> XMC_CCU4_SLICE_StopTimer().
 */
__STATIC_INLINE bool XMC_CCU4_SLICE_IsTimerRunning(const XMC_CCU4_SLICE_t *const slice)
{
  XMC_ASSERT("XMC_CCU4_SLICE_GetTimerStatus:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  return (bool)(((slice->TCST) & CCU4_CC4_TCST_TRB_Msk) == CCU4_CC4_TCST_TRB_Msk);
 8025ea0:	688a      	ldr	r2, [r1, #8]
  TIMER_STATUS_t status;

  XMC_ASSERT("TIMER_Stop:handle_ptr NULL" , (handle_ptr != NULL));

  /* Check whether timer is initialized and in running state */
  if ((TIMER_GetTimerStatus(handle_ptr)) && (true == handle_ptr->initialized))
 8025ea2:	07d2      	lsls	r2, r2, #31
 8025ea4:	d5f9      	bpl.n	8025e9a <TIMER_Stop+0x6>
 8025ea6:	f890 2026 	ldrb.w	r2, [r0, #38]	; 0x26
 8025eaa:	2a00      	cmp	r2, #0
 8025eac:	d0f5      	beq.n	8025e9a <TIMER_Stop+0x6>
 *  XMC_CCU4_SLICE_StartTimer().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_StopTimer(XMC_CCU4_SLICE_t *const slice)
{
  XMC_ASSERT("XMC_CCU4_SLICE_StopTimer:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->TCCLR = (uint32_t) CCU4_CC4_TCCLR_TRBC_Msk;
 8025eae:	2201      	movs	r2, #1
       {
      /* Stops the timer */
      XMC_CCU8_SLICE_StopTimer(handle_ptr->ccu8_slice_ptr);
       }
#endif
    status = TIMER_STATUS_SUCCESS;
 8025eb0:	4618      	mov	r0, r3
 8025eb2:	610a      	str	r2, [r1, #16]
 8025eb4:	4770      	bx	lr
 8025eb6:	bf00      	nop

08025eb8 <TIMER_SetTimeInterval>:
/*
 * This function changes the PWM period which in turn changes the time tick interval value by checking that
 * the given time tick value is within supported range.
 */
TIMER_STATUS_t TIMER_SetTimeInterval(TIMER_t  *const handle_ptr, uint32_t time_interval)
{
 8025eb8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  XMC_ASSERT("TIMER_GetTimerStatus:handle_ptr NULL" , (handle_ptr != NULL));

  status = false;

#ifdef TIMER_CCU4_USED
  if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
 8025eba:	f890 6021 	ldrb.w	r6, [r0, #33]	; 0x21
 8025ebe:	2e00      	cmp	r6, #0
 8025ec0:	d04a      	beq.n	8025f58 <TIMER_SetTimeInterval+0xa0>
  status = TIMER_STATUS_FAILURE;

  if (false == TIMER_GetTimerStatus(handle_ptr))
  {
    /* check for time_interval range */
    if ((time_interval >= handle_ptr->timer_min_value_us) && (time_interval <= handle_ptr->timer_max_value_us))
 8025ec2:	6883      	ldr	r3, [r0, #8]
 8025ec4:	428b      	cmp	r3, r1
 8025ec6:	d84b      	bhi.n	8025f60 <TIMER_SetTimeInterval+0xa8>
 8025ec8:	6845      	ldr	r5, [r0, #4]
 8025eca:	42a9      	cmp	r1, r5
 8025ecc:	d848      	bhi.n	8025f60 <TIMER_SetTimeInterval+0xa8>
    {
      /* Initialize the prescaler */
      lprescaler = 0U;
      while (time_interval > (handle_ptr->timer_max_value_us >> (TIMER_PRESCALER_MAX - lprescaler)))
 8025ece:	ebb1 3fd5 	cmp.w	r1, r5, lsr #15
 8025ed2:	d947      	bls.n	8025f64 <TIMER_SetTimeInterval+0xac>
 8025ed4:	2300      	movs	r3, #0
 8025ed6:	f1c3 020e 	rsb	r2, r3, #14
 8025eda:	fa25 f202 	lsr.w	r2, r5, r2
      {
        lprescaler++;
 8025ede:	1c5c      	adds	r4, r3, #1
    /* check for time_interval range */
    if ((time_interval >= handle_ptr->timer_min_value_us) && (time_interval <= handle_ptr->timer_max_value_us))
    {
      /* Initialize the prescaler */
      lprescaler = 0U;
      while (time_interval > (handle_ptr->timer_max_value_us >> (TIMER_PRESCALER_MAX - lprescaler)))
 8025ee0:	4291      	cmp	r1, r2
      {
        lprescaler++;
 8025ee2:	4623      	mov	r3, r4
    /* check for time_interval range */
    if ((time_interval >= handle_ptr->timer_min_value_us) && (time_interval <= handle_ptr->timer_max_value_us))
    {
      /* Initialize the prescaler */
      lprescaler = 0U;
      while (time_interval > (handle_ptr->timer_max_value_us >> (TIMER_PRESCALER_MAX - lprescaler)))
 8025ee4:	d8f7      	bhi.n	8025ed6 <TIMER_SetTimeInterval+0x1e>
      {
        lprescaler++;
      }
#ifdef TIMER_CCU4_USED
      if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
 8025ee6:	2e00      	cmp	r6, #0
 8025ee8:	d13a      	bne.n	8025f60 <TIMER_SetTimeInterval+0xa8>
      {
        lfrequency = handle_ptr->global_ccu4_handler->module_frequency;
 8025eea:	6903      	ldr	r3, [r0, #16]
        handle_ptr->ccu4_slice_config_ptr->prescaler_initval = lprescaler;
 8025eec:	69c7      	ldr	r7, [r0, #28]
        lprescaler++;
      }
#ifdef TIMER_CCU4_USED
      if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
      {
        lfrequency = handle_ptr->global_ccu4_handler->module_frequency;
 8025eee:	681a      	ldr	r2, [r3, #0]
        handle_ptr->ccu4_slice_config_ptr->prescaler_initval = lprescaler;
 8025ef0:	f897 e004 	ldrb.w	lr, [r7, #4]
 8025ef4:	f004 060f 	and.w	r6, r4, #15
        /* Calculate the period register for the required time_interval value */
        handle_ptr->period_value = (uint16_t)((((uint64_t)time_interval * lfrequency) >> \
 8025ef8:	fba1 2302 	umull	r2, r3, r1, r2
 8025efc:	f1c6 0120 	rsb	r1, r6, #32
 8025f00:	4605      	mov	r5, r0
 8025f02:	fa03 f101 	lsl.w	r1, r3, r1
 8025f06:	fa22 f006 	lsr.w	r0, r2, r6
 8025f0a:	f1a6 0220 	sub.w	r2, r6, #32
      }
#ifdef TIMER_CCU4_USED
      if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
      {
        lfrequency = handle_ptr->global_ccu4_handler->module_frequency;
        handle_ptr->ccu4_slice_config_ptr->prescaler_initval = lprescaler;
 8025f0e:	f364 0e03 	bfi	lr, r4, #0, #4
        /* Calculate the period register for the required time_interval value */
        handle_ptr->period_value = (uint16_t)((((uint64_t)time_interval * lfrequency) >> \
 8025f12:	4308      	orrs	r0, r1
 8025f14:	fa23 f202 	lsr.w	r2, r3, r2
                                               handle_ptr->ccu4_slice_config_ptr->prescaler_initval) / \
 8025f18:	fa23 f106 	lsr.w	r1, r3, r6
      }
#ifdef TIMER_CCU4_USED
      if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
      {
        lfrequency = handle_ptr->global_ccu4_handler->module_frequency;
        handle_ptr->ccu4_slice_config_ptr->prescaler_initval = lprescaler;
 8025f1c:	f887 e004 	strb.w	lr, [r7, #4]
        /* Calculate the period register for the required time_interval value */
        handle_ptr->period_value = (uint16_t)((((uint64_t)time_interval * lfrequency) >> \
                                               handle_ptr->ccu4_slice_config_ptr->prescaler_initval) / \
 8025f20:	4310      	orrs	r0, r2
 8025f22:	a313      	add	r3, pc, #76	; (adr r3, 8025f70 <TIMER_SetTimeInterval+0xb8>)
 8025f24:	e9d3 2300 	ldrd	r2, r3, [r3]
 8025f28:	f007 f828 	bl	802cf7c <__aeabi_uldivmod>
      if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
      {
        lfrequency = handle_ptr->global_ccu4_handler->module_frequency;
        handle_ptr->ccu4_slice_config_ptr->prescaler_initval = lprescaler;
        /* Calculate the period register for the required time_interval value */
        handle_ptr->period_value = (uint16_t)((((uint64_t)time_interval * lfrequency) >> \
 8025f2c:	b280      	uxth	r0, r0
                                               handle_ptr->ccu4_slice_config_ptr->prescaler_initval) / \
                                              TIMER_RESOLUTION_SEC_TO_MICRO);
        /* Actual timer period values is Period_reg_val+1U */
        if (handle_ptr->period_value > TIMER_PERIOD_MIN)
 8025f2e:	2801      	cmp	r0, #1
        {
          (handle_ptr->period_value)--;
 8025f30:	bf88      	it	hi
 8025f32:	f100 30ff 	addhi.w	r0, r0, #4294967295
      }
#ifdef TIMER_CCU4_USED
      if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
      {
        lfrequency = handle_ptr->global_ccu4_handler->module_frequency;
        handle_ptr->ccu4_slice_config_ptr->prescaler_initval = lprescaler;
 8025f36:	b2e4      	uxtb	r4, r4
                                               handle_ptr->ccu4_slice_config_ptr->prescaler_initval) / \
                                              TIMER_RESOLUTION_SEC_TO_MICRO);
        /* Actual timer period values is Period_reg_val+1U */
        if (handle_ptr->period_value > TIMER_PERIOD_MIN)
        {
          (handle_ptr->period_value)--;
 8025f38:	8468      	strh	r0, [r5, #34]	; 0x22
        }
        /* Update the prescaler */
        XMC_CCU4_SLICE_SetPrescaler(handle_ptr->ccu4_slice_ptr, handle_ptr->ccu4_slice_config_ptr->prescaler_initval);
 8025f3a:	f004 010f 	and.w	r1, r4, #15
 8025f3e:	6968      	ldr	r0, [r5, #20]
 8025f40:	f7fb fb6e 	bl	8021620 <XMC_CCU4_SLICE_SetPrescaler>
  /* programs the timer period register according to time interval value */
  XMC_CCU4_SLICE_SetTimerPeriodMatch(handle_ptr->ccu4_slice_ptr, handle_ptr->period_value);
  /* programs the timer compare register for 50% duty cycle */
  XMC_CCU4_SLICE_SetTimerCompareMatch(handle_ptr->ccu4_slice_ptr, TIMER_CMP_100_DUTY);
  /* Transfers value from shadow timer registers to actual timer registers */
  XMC_CCU4_EnableShadowTransfer(handle_ptr->global_ccu4_handler->module_ptr, handle_ptr->shadow_mask);
 8025f44:	692a      	ldr	r2, [r5, #16]
 * This function configures timer period and compare values and triggers the shadow transfer operation
 */
void TIMER_CCU4_lShadowTransfer(TIMER_t* const handle_ptr)
{
  /* programs the timer period register according to time interval value */
  XMC_CCU4_SLICE_SetTimerPeriodMatch(handle_ptr->ccu4_slice_ptr, handle_ptr->period_value);
 8025f46:	696b      	ldr	r3, [r5, #20]
 *  XMC_CCU4_SLICE_GetTimerPeriodMatch().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_SetTimerPeriodMatch(XMC_CCU4_SLICE_t *const slice, const uint16_t period_val)
{
  XMC_ASSERT("XMC_CCU4_SLICE_SetTimerPeriodMatch:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->PRS = (uint32_t) period_val;
 8025f48:	8c68      	ldrh	r0, [r5, #34]	; 0x22
  /* programs the timer compare register for 50% duty cycle */
  XMC_CCU4_SLICE_SetTimerCompareMatch(handle_ptr->ccu4_slice_ptr, TIMER_CMP_100_DUTY);
  /* Transfers value from shadow timer registers to actual timer registers */
  XMC_CCU4_EnableShadowTransfer(handle_ptr->global_ccu4_handler->module_ptr, handle_ptr->shadow_mask);
 8025f4a:	6892      	ldr	r2, [r2, #8]
 8025f4c:	68e9      	ldr	r1, [r5, #12]
 8025f4e:	6358      	str	r0, [r3, #52]	; 0x34
 *  XMC_CCU4_SLICE_GetTimerPeriodMatch().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_SetTimerCompareMatch(XMC_CCU4_SLICE_t *const slice, const uint16_t compare_val)
{
  XMC_ASSERT("XMC_CCU4_SLICE_SetTimerCompareMatch:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->CRS = (uint32_t) compare_val;
 8025f50:	2000      	movs	r0, #0
 8025f52:	63d8      	str	r0, [r3, #60]	; 0x3c
 *  None.
 */
__STATIC_INLINE void XMC_CCU4_EnableShadowTransfer(XMC_CCU4_MODULE_t *const module, const uint32_t shadow_transfer_msk)
{
  XMC_ASSERT("XMC_CCU4_EnableShadowTransfer:Invalid Slice Pointer", XMC_CCU4_IsValidModule(module));
  module->GCSS = (uint32_t)shadow_transfer_msk;  
 8025f54:	6111      	str	r1, [r2, #16]
 8025f56:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

#ifdef TIMER_CCU4_USED
  if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
  {
    /* Returns the current status of the timer */
    status = XMC_CCU4_SLICE_IsTimerRunning(handle_ptr->ccu4_slice_ptr);
 8025f58:	6943      	ldr	r3, [r0, #20]
 *  XMC_CCU4_SLICE_StartTimer()<BR> XMC_CCU4_SLICE_StopTimer().
 */
__STATIC_INLINE bool XMC_CCU4_SLICE_IsTimerRunning(const XMC_CCU4_SLICE_t *const slice)
{
  XMC_ASSERT("XMC_CCU4_SLICE_GetTimerStatus:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  return (bool)(((slice->TCST) & CCU4_CC4_TCST_TRB_Msk) == CCU4_CC4_TCST_TRB_Msk);
 8025f5a:	689b      	ldr	r3, [r3, #8]

  XMC_ASSERT("TIMER_SetTimeInterval:handle_ptr NULL" , (handle_ptr != NULL));

  status = TIMER_STATUS_FAILURE;

  if (false == TIMER_GetTimerStatus(handle_ptr))
 8025f5c:	07db      	lsls	r3, r3, #31
 8025f5e:	d5b0      	bpl.n	8025ec2 <TIMER_SetTimeInterval+0xa>
  uint32_t lfrequency;
  uint32_t lprescaler;

  XMC_ASSERT("TIMER_SetTimeInterval:handle_ptr NULL" , (handle_ptr != NULL));

  status = TIMER_STATUS_FAILURE;
 8025f60:	2001      	movs	r0, #1
      }
#endif
    }
  }
  return (status);
}
 8025f62:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    /* check for time_interval range */
    if ((time_interval >= handle_ptr->timer_min_value_us) && (time_interval <= handle_ptr->timer_max_value_us))
    {
      /* Initialize the prescaler */
      lprescaler = 0U;
      while (time_interval > (handle_ptr->timer_max_value_us >> (TIMER_PRESCALER_MAX - lprescaler)))
 8025f64:	2400      	movs	r4, #0
      {
        lprescaler++;
      }
#ifdef TIMER_CCU4_USED
      if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
 8025f66:	2e00      	cmp	r6, #0
 8025f68:	d0bf      	beq.n	8025eea <TIMER_SetTimeInterval+0x32>
 8025f6a:	e7f9      	b.n	8025f60 <TIMER_SetTimeInterval+0xa8>
 8025f6c:	f3af 8000 	nop.w
 8025f70:	05f5e100 	.word	0x05f5e100
 8025f74:	00000000 	.word	0x00000000

08025f78 <TIMER_GetInterruptStatus>:
{
  bool status;
  XMC_ASSERT("TIMER_GetInterruptStatus:handle_ptr NULL" , (handle_ptr != NULL));
  status = false;
#ifdef TIMER_CCU4_USED
  if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
 8025f78:	f890 3021 	ldrb.w	r3, [r0, #33]	; 0x21
 8025f7c:	b92b      	cbnz	r3, 8025f8a <TIMER_GetInterruptStatus+0x12>
  {
    /* Reads the interrupt status */
    status = XMC_CCU4_SLICE_GetEvent(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_PERIOD_MATCH);
 8025f7e:	6943      	ldr	r3, [r0, #20]
__STATIC_INLINE bool XMC_CCU4_SLICE_GetEvent(const XMC_CCU4_SLICE_t *const slice, const XMC_CCU4_SLICE_IRQ_ID_t event)
{
  XMC_ASSERT("XMC_CCU4_SLICE_GetEvent:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_GetEvent:Invalid SR event", XMC_CCU4_SLICE_CHECK_INTERRUPT(event));

  return(((uint32_t)(slice->INTS & ((uint32_t)1 << (uint32_t)event))) != 0U);
 8025f80:	f8d3 00a0 	ldr.w	r0, [r3, #160]	; 0xa0
 8025f84:	f000 0001 	and.w	r0, r0, #1
 8025f88:	4770      	bx	lr
 */
bool TIMER_GetInterruptStatus(TIMER_t * const handle_ptr)
{
  bool status;
  XMC_ASSERT("TIMER_GetInterruptStatus:handle_ptr NULL" , (handle_ptr != NULL));
  status = false;
 8025f8a:	2000      	movs	r0, #0
    /* Reads the interrupt status */
    status = XMC_CCU8_SLICE_GetEvent(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_IRQ_ID_PERIOD_MATCH);
  }
#endif
  return (status);
}
 8025f8c:	4770      	bx	lr
 8025f8e:	bf00      	nop

08025f90 <TIMER_ClearEvent>:
void TIMER_ClearEvent(TIMER_t *const handle_ptr)
{
  XMC_ASSERT("TIME_CCU_AcknowledgeInterrupt:handle_ptr NULL" , (handle_ptr != NULL));

#ifdef TIMER_CCU4_USED
  if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
 8025f90:	f890 3021 	ldrb.w	r3, [r0, #33]	; 0x21
 8025f94:	b933      	cbnz	r3, 8025fa4 <TIMER_ClearEvent+0x14>
  {
    /* clears the timer event(period match interrupt) */
    XMC_CCU4_SLICE_ClearEvent(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_PERIOD_MATCH);
 8025f96:	6942      	ldr	r2, [r0, #20]
 */
__STATIC_INLINE void XMC_CCU4_SLICE_ClearEvent(XMC_CCU4_SLICE_t *const slice, const XMC_CCU4_SLICE_IRQ_ID_t event)
{
  XMC_ASSERT("XMC_CCU4_SLICE_ClearEvent:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_ClearEvent:Invalid SR event", XMC_CCU4_SLICE_CHECK_INTERRUPT(event));
  slice->SWR |= ((uint32_t) 1) << ((uint32_t) event);
 8025f98:	f8d2 30b0 	ldr.w	r3, [r2, #176]	; 0xb0
 8025f9c:	f043 0301 	orr.w	r3, r3, #1
 8025fa0:	f8c2 30b0 	str.w	r3, [r2, #176]	; 0xb0
 8025fa4:	4770      	bx	lr
 8025fa6:	bf00      	nop

08025fa8 <TIMER_Clear>:
  TIMER_STATUS_t status;

  XMC_ASSERT("TIMER_Clear:handle_ptr NULL" , (handle_ptr != NULL));

  /* Check for APP instance is initialized or not */
  if (true == handle_ptr->initialized)
 8025fa8:	f890 3026 	ldrb.w	r3, [r0, #38]	; 0x26
 8025fac:	b14b      	cbz	r3, 8025fc2 <TIMER_Clear+0x1a>
  {
#ifdef TIMER_CCU4_USED
    if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
 8025fae:	f890 3021 	ldrb.w	r3, [r0, #33]	; 0x21
 8025fb2:	b923      	cbnz	r3, 8025fbe <TIMER_Clear+0x16>
    {
      /* Clear the timer register */
      XMC_CCU4_SLICE_ClearTimer(handle_ptr->ccu4_slice_ptr);
 8025fb4:	6942      	ldr	r2, [r0, #20]
 *  XMC_CCU4_SLICE_StartTimer().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_ClearTimer(XMC_CCU4_SLICE_t *const slice)
{
  XMC_ASSERT("XMC_CCU4_SLICE_ClearTimer:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->TCCLR = (uint32_t) CCU4_CC4_TCCLR_TCC_Msk;
 8025fb6:	2102      	movs	r1, #2
    {
      /* Clear the timer register */
      XMC_CCU8_SLICE_ClearTimer(handle_ptr->ccu8_slice_ptr);
    }
#endif
    status = TIMER_STATUS_SUCCESS;
 8025fb8:	4618      	mov	r0, r3
 8025fba:	6111      	str	r1, [r2, #16]
 8025fbc:	4770      	bx	lr
 8025fbe:	2000      	movs	r0, #0
  {
    status = TIMER_STATUS_FAILURE;
  }

  return (status);
}
 8025fc0:	4770      	bx	lr
#endif
    status = TIMER_STATUS_SUCCESS;
  }
  else
  {
    status = TIMER_STATUS_FAILURE;
 8025fc2:	2001      	movs	r0, #1
 8025fc4:	4770      	bx	lr
 8025fc6:	bf00      	nop

08025fc8 <PWM_CCU8_Init>:
  return version;
}

/* This function initializes the app */
PWM_CCU8_STATUS_t PWM_CCU8_Init(PWM_CCU8_t* handle_ptr)
{
 8025fc8:	b5f0      	push	{r4, r5, r6, r7, lr}

  status = PWM_CCU8_STATUS_FAILURE;
  status_ccu8_global = GLOBAL_CCU8_STATUS_FAILURE;
  XMC_ASSERT("PWM_CCU8_Init:handle_ptr is NULL", (handle_ptr != NULL));

  if (PWM_CCU8_STATE_UNINITIALIZED == handle_ptr->state)
 8025fca:	7f05      	ldrb	r5, [r0, #28]
  return version;
}

/* This function initializes the app */
PWM_CCU8_STATUS_t PWM_CCU8_Init(PWM_CCU8_t* handle_ptr)
{
 8025fcc:	b083      	sub	sp, #12

  status = PWM_CCU8_STATUS_FAILURE;
  status_ccu8_global = GLOBAL_CCU8_STATUS_FAILURE;
  XMC_ASSERT("PWM_CCU8_Init:handle_ptr is NULL", (handle_ptr != NULL));

  if (PWM_CCU8_STATE_UNINITIALIZED == handle_ptr->state)
 8025fce:	b115      	cbz	r5, 8025fd6 <PWM_CCU8_Init+0xe>
    }

  }
  else
  {
    status = PWM_CCU8_STATUS_ALREADY_INITIALIZED;
 8025fd0:	2002      	movs	r0, #2
    XMC_DEBUG("PWM_CCU8_Init:PWM_CCU8_STATUS_ALREADY_INITIALIZED");
  }

  return (status);
} /* end of PWM_CCU8_Init() api */
 8025fd2:	b003      	add	sp, #12
 8025fd4:	bdf0      	pop	{r4, r5, r6, r7, pc}
  XMC_ASSERT("PWM_CCU8_Init:handle_ptr is NULL", (handle_ptr != NULL));

  if (PWM_CCU8_STATE_UNINITIALIZED == handle_ptr->state)
  {
    /* Initialize consumed Apps */
    status_ccu8_global = GLOBAL_CCU8_Init(handle_ptr->config_ptr->global_ccu8_handle);
 8025fd6:	6803      	ldr	r3, [r0, #0]
 8025fd8:	4604      	mov	r4, r0
 8025fda:	f8d3 008c 	ldr.w	r0, [r3, #140]	; 0x8c
 8025fde:	f000 fb2f 	bl	8026640 <GLOBAL_CCU8_Init>

    /* Initialize CCU8x_CC8y slice */
    if (GLOBAL_CCU8_STATUS_SUCCESS == status_ccu8_global)
 8025fe2:	4606      	mov	r6, r0
 8025fe4:	b118      	cbz	r0, 8025fee <PWM_CCU8_Init+0x26>
  PWM_CCU8_STATUS_t status;
  GLOBAL_CCU8_STATUS_t status_ccu8_global;
  uint32_t frequency_module;
  uint32_t prescalar;

  status = PWM_CCU8_STATUS_FAILURE;
 8025fe6:	2001      	movs	r0, #1
      }

    }
    else
    {
      handle_ptr->state = PWM_CCU8_STATE_UNINITIALIZED;
 8025fe8:	7725      	strb	r5, [r4, #28]
    status = PWM_CCU8_STATUS_ALREADY_INITIALIZED;
    XMC_DEBUG("PWM_CCU8_Init:PWM_CCU8_STATUS_ALREADY_INITIALIZED");
  }

  return (status);
} /* end of PWM_CCU8_Init() api */
 8025fea:	b003      	add	sp, #12
 8025fec:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (GLOBAL_CCU8_STATUS_SUCCESS == status_ccu8_global)
    {
      XMC_DEBUG("PWM_CCU8_Init:Initilizing slice");

      /* Configure CCU8x_CC8y slice as timer */
      XMC_CCU8_SLICE_CompareInit(handle_ptr->ccu8_slice_ptr, handle_ptr->config_ptr->ccu8_cc8_slice_timer_ptr);
 8025fee:	6823      	ldr	r3, [r4, #0]
 8025ff0:	68a0      	ldr	r0, [r4, #8]
 8025ff2:	6c99      	ldr	r1, [r3, #72]	; 0x48
 8025ff4:	f7fb fb64 	bl	80216c0 <XMC_CCU8_SLICE_CompareInit>
      /* Set period match value of the timer  */
      XMC_CCU8_SLICE_SetTimerPeriodMatch(handle_ptr->ccu8_slice_ptr, handle_ptr->config_ptr->period_value);
 8025ff8:	6823      	ldr	r3, [r4, #0]
 8025ffa:	68a0      	ldr	r0, [r4, #8]
 8025ffc:	8859      	ldrh	r1, [r3, #2]
 8025ffe:	f7fb fc6b 	bl	80218d8 <XMC_CCU8_SLICE_SetTimerPeriodMatch>

      /* Set timer compare match value for channel 1 */
      XMC_CCU8_SLICE_SetTimerCompareMatch(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_COMPARE_CHANNEL_1,
 8026002:	6823      	ldr	r3, [r4, #0]
 8026004:	68a0      	ldr	r0, [r4, #8]
 8026006:	889a      	ldrh	r2, [r3, #4]
 8026008:	4631      	mov	r1, r6
 802600a:	f7fb fc67 	bl	80218dc <XMC_CCU8_SLICE_SetTimerCompareMatch>
                                          (uint16_t) handle_ptr->config_ptr->compare1_value);
      /* Set timer compare match value for channel 2 */
      XMC_CCU8_SLICE_SetTimerCompareMatch(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_COMPARE_CHANNEL_2,
 802600e:	6823      	ldr	r3, [r4, #0]
 8026010:	68a0      	ldr	r0, [r4, #8]
 8026012:	88da      	ldrh	r2, [r3, #6]
 8026014:	2101      	movs	r1, #1
 8026016:	f7fb fc61 	bl	80218dc <XMC_CCU8_SLICE_SetTimerCompareMatch>
                                          (uint16_t) handle_ptr->config_ptr->compare2_value);

      if ((1U == handle_ptr->config_ptr->ccu8_cc8_slice_timer_ptr->mcm_ch1_enable) || (1U
 802601a:	6822      	ldr	r2, [r4, #0]
 802601c:	6c93      	ldr	r3, [r2, #72]	; 0x48
 802601e:	78db      	ldrb	r3, [r3, #3]
 8026020:	f013 0f06 	tst.w	r3, #6
 8026024:	f040 8166 	bne.w	80262f4 <PWM_CCU8_Init+0x32c>
        XMC_CCU8_SetMultiChannelShadowTransferMode(handle_ptr->ccu8_module_ptr,
                                                   (uint32_t) handle_ptr->config_ptr->mcm_shadow_txfr_mode);
      }

#if (UC_SERIES != XMC45) /*STC register not available on XMC45xx devices */
      XMC_CCU8_SLICE_SetShadowTransferMode(handle_ptr->ccu8_slice_ptr, handle_ptr->config_ptr->shadow_transfer_mode);
 8026028:	68a0      	ldr	r0, [r4, #8]
__STATIC_INLINE void XMC_CCU8_SLICE_SetShadowTransferMode(XMC_CCU8_SLICE_t *const slice,
                                                          const XMC_CCU8_SLICE_SHADOW_TRANSFER_MODE_t shadow_transfer_mode)
{
  XMC_ASSERT("XMC_CCU8_SLICE_SetShadowTransferMode:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  slice->STC = ((slice->STC) & ~(uint32_t)((uint32_t)CCU8_CC8_STC_STM_Msk << (uint32_t)CCU8_CC8_STC_STM_Pos)) |
               ((shadow_transfer_mode << CCU8_CC8_STC_STM_Pos) & (uint32_t)CCU8_CC8_STC_STM_Msk);
 802602a:	f892 5044 	ldrb.w	r5, [r2, #68]	; 0x44
 */
__STATIC_INLINE void XMC_CCU8_SLICE_SetShadowTransferMode(XMC_CCU8_SLICE_t *const slice,
                                                          const XMC_CCU8_SLICE_SHADOW_TRANSFER_MODE_t shadow_transfer_mode)
{
  XMC_ASSERT("XMC_CCU8_SLICE_SetShadowTransferMode:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  slice->STC = ((slice->STC) & ~(uint32_t)((uint32_t)CCU8_CC8_STC_STM_Msk << (uint32_t)CCU8_CC8_STC_STM_Pos)) |
 802602e:	f8d0 30b4 	ldr.w	r3, [r0, #180]	; 0xb4

      /* Transfer value from shadow timer registers to actual timer registers */
      XMC_CCU8_EnableShadowTransfer(handle_ptr->ccu8_module_ptr, handle_ptr->shadow_txfr_msk);
      XMC_CCU8_EnableShadowTransfer(handle_ptr->ccu8_module_ptr, handle_ptr->dither_shadow_txfr_msk);

      XMC_CCU8_SLICE_DeadTimeInit(handle_ptr->ccu8_slice_ptr, handle_ptr->config_ptr->dt_config_ptr);
 8026032:	6c11      	ldr	r1, [r2, #64]	; 0x40
        XMC_CCU8_SLICE_EnableCascadedShadowTransfer(handle_ptr->ccu8_slice_ptr);
      }
#endif

      /* Transfer value from shadow timer registers to actual timer registers */
      XMC_CCU8_EnableShadowTransfer(handle_ptr->ccu8_module_ptr, handle_ptr->shadow_txfr_msk);
 8026034:	6866      	ldr	r6, [r4, #4]
 8026036:	f8d4 e010 	ldr.w	lr, [r4, #16]
      XMC_CCU8_EnableShadowTransfer(handle_ptr->ccu8_module_ptr, handle_ptr->dither_shadow_txfr_msk);
 802603a:	6967      	ldr	r7, [r4, #20]
               ((shadow_transfer_mode << CCU8_CC8_STC_STM_Pos) & (uint32_t)CCU8_CC8_STC_STM_Msk);
 802603c:	006d      	lsls	r5, r5, #1
 */
__STATIC_INLINE void XMC_CCU8_SLICE_SetShadowTransferMode(XMC_CCU8_SLICE_t *const slice,
                                                          const XMC_CCU8_SLICE_SHADOW_TRANSFER_MODE_t shadow_transfer_mode)
{
  XMC_ASSERT("XMC_CCU8_SLICE_SetShadowTransferMode:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  slice->STC = ((slice->STC) & ~(uint32_t)((uint32_t)CCU8_CC8_STC_STM_Msk << (uint32_t)CCU8_CC8_STC_STM_Pos)) |
 802603e:	f023 020c 	bic.w	r2, r3, #12
               ((shadow_transfer_mode << CCU8_CC8_STC_STM_Pos) & (uint32_t)CCU8_CC8_STC_STM_Msk);
 8026042:	f005 0306 	and.w	r3, r5, #6
 */
__STATIC_INLINE void XMC_CCU8_SLICE_SetShadowTransferMode(XMC_CCU8_SLICE_t *const slice,
                                                          const XMC_CCU8_SLICE_SHADOW_TRANSFER_MODE_t shadow_transfer_mode)
{
  XMC_ASSERT("XMC_CCU8_SLICE_SetShadowTransferMode:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  slice->STC = ((slice->STC) & ~(uint32_t)((uint32_t)CCU8_CC8_STC_STM_Msk << (uint32_t)CCU8_CC8_STC_STM_Pos)) |
 8026046:	4313      	orrs	r3, r2
 8026048:	f8c0 30b4 	str.w	r3, [r0, #180]	; 0xb4
 *  None.
 */
__STATIC_INLINE void XMC_CCU8_EnableShadowTransfer(XMC_CCU8_MODULE_t *const module, const uint32_t shadow_transfer_msk)
{
  XMC_ASSERT("XMC_CCU8_EnableShadowTransfer:Invalid module Pointer", XMC_CCU8_IsValidModule(module));
  module->GCSS = (uint32_t)shadow_transfer_msk;  
 802604c:	f8c6 e010 	str.w	lr, [r6, #16]
 8026050:	6137      	str	r7, [r6, #16]

      XMC_CCU8_SLICE_DeadTimeInit(handle_ptr->ccu8_slice_ptr, handle_ptr->config_ptr->dt_config_ptr);
 8026052:	f7fb fc65 	bl	8021920 <XMC_CCU8_SLICE_DeadTimeInit>
}

static void PWM_CCU8_lConfigure_Events(PWM_CCU8_t* handle_ptr)
{
  /* Configure slice to a external event 0 */
  XMC_CCU8_SLICE_ConfigureEvent(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_EVENT_0,
 8026056:	6823      	ldr	r3, [r4, #0]
 8026058:	68a0      	ldr	r0, [r4, #8]
 802605a:	69da      	ldr	r2, [r3, #28]
 802605c:	2101      	movs	r1, #1
 802605e:	f7fb fbff 	bl	8021860 <XMC_CCU8_SLICE_ConfigureEvent>
                                handle_ptr->config_ptr->event0_config_ptr);

  /* Configure slice to a external event 1 */
  XMC_CCU8_SLICE_ConfigureEvent(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_EVENT_1,
 8026062:	6823      	ldr	r3, [r4, #0]
 8026064:	68a0      	ldr	r0, [r4, #8]
 8026066:	6a1a      	ldr	r2, [r3, #32]
 8026068:	2102      	movs	r1, #2
 802606a:	f7fb fbf9 	bl	8021860 <XMC_CCU8_SLICE_ConfigureEvent>
                                handle_ptr->config_ptr->event1_config_ptr);

  /* Configure slice to a external event 2 */
  XMC_CCU8_SLICE_ConfigureEvent(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_EVENT_2,
 802606e:	6823      	ldr	r3, [r4, #0]
 8026070:	68a0      	ldr	r0, [r4, #8]
 8026072:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8026074:	2103      	movs	r1, #3
 8026076:	f7fb fbf3 	bl	8021860 <XMC_CCU8_SLICE_ConfigureEvent>
                                handle_ptr->config_ptr->event2_config_ptr);

  /* External signal controls start of the timer */
  if (XMC_CCU8_SLICE_EVENT_NONE != handle_ptr->config_ptr->ext_start_event)
 802607a:	6823      	ldr	r3, [r4, #0]
 802607c:	f893 1028 	ldrb.w	r1, [r3, #40]	; 0x28
 8026080:	2900      	cmp	r1, #0
 8026082:	f040 8130 	bne.w	80262e6 <PWM_CCU8_Init+0x31e>
    XMC_CCU8_SLICE_StartConfig(handle_ptr->ccu8_slice_ptr, handle_ptr->config_ptr->ext_start_event,
                               handle_ptr->config_ptr->ext_start_mode);
  }

  /* External signal can stop the timer */
  if (XMC_CCU8_SLICE_EVENT_NONE != handle_ptr->config_ptr->ext_stop_event)
 8026086:	f893 102a 	ldrb.w	r1, [r3, #42]	; 0x2a
 802608a:	2900      	cmp	r1, #0
 802608c:	f040 8124 	bne.w	80262d8 <PWM_CCU8_Init+0x310>
    XMC_CCU8_SLICE_StopConfig(handle_ptr->ccu8_slice_ptr, handle_ptr->config_ptr->ext_stop_event,
                              handle_ptr->config_ptr->ext_stop_mode);
  }

  /* External signal can change the timer counting direction */
  if (XMC_CCU8_SLICE_EVENT_NONE != handle_ptr->config_ptr->ext_count_dir_event)
 8026090:	f893 102c 	ldrb.w	r1, [r3, #44]	; 0x2c
 8026094:	2900      	cmp	r1, #0
 8026096:	f040 811a 	bne.w	80262ce <PWM_CCU8_Init+0x306>
  {
    XMC_CCU8_SLICE_DirectionConfig(handle_ptr->ccu8_slice_ptr, handle_ptr->config_ptr->ext_count_dir_event);
  }
  /* External signal can stop the timer and the timer value remains same */
  if (XMC_CCU8_SLICE_EVENT_NONE != handle_ptr->config_ptr->ext_gate_event)
 802609a:	f893 102d 	ldrb.w	r1, [r3, #45]	; 0x2d
 802609e:	2900      	cmp	r1, #0
 80260a0:	f040 8110 	bne.w	80262c4 <PWM_CCU8_Init+0x2fc>
  {
    XMC_CCU8_SLICE_GateConfig(handle_ptr->ccu8_slice_ptr, handle_ptr->config_ptr->ext_gate_event);
  }
  /* Timer increments on external signal */
  if (XMC_CCU8_SLICE_EVENT_NONE != handle_ptr->config_ptr->ext_count_event)
 80260a4:	f893 102e 	ldrb.w	r1, [r3, #46]	; 0x2e
 80260a8:	2900      	cmp	r1, #0
 80260aa:	f040 8106 	bne.w	80262ba <PWM_CCU8_Init+0x2f2>
  {
    XMC_CCU8_SLICE_CountConfig(handle_ptr->ccu8_slice_ptr, handle_ptr->config_ptr->ext_count_event);
  }
  /* Timer gets loaded with compare register value or period register value on external signal */
  if (XMC_CCU8_SLICE_EVENT_NONE != handle_ptr->config_ptr->ext_load_event)
 80260ae:	f893 102f 	ldrb.w	r1, [r3, #47]	; 0x2f
 80260b2:	2900      	cmp	r1, #0
 80260b4:	f040 80f6 	bne.w	80262a4 <PWM_CCU8_Init+0x2dc>
  {
    XMC_CCU8_SLICE_LoadConfig(handle_ptr->ccu8_slice_ptr, handle_ptr->config_ptr->ext_load_event);
    XMC_CCU8_SLICE_LoadSelector(handle_ptr->ccu8_slice_ptr, handle_ptr->config_ptr->ext_load_selector);
  }
  /* External signal PWM signal (ST bit) output gets modulated by external signal */
  if (XMC_CCU8_SLICE_EVENT_NONE != handle_ptr->config_ptr->ext_mod_event)
 80260b8:	f893 1031 	ldrb.w	r1, [r3, #49]	; 0x31
 80260bc:	2900      	cmp	r1, #0
 80260be:	f040 80e6 	bne.w	802628e <PWM_CCU8_Init+0x2c6>
                                    handle_ptr->config_ptr->ext_mod_mode, XMC_CCU8_SLICE_MODULATION_CHANNEL_1_AND_2,
                                    handle_ptr->config_ptr->ext_mod_sync);
  }

  /* PWM signal (ST bit) output gets modulated by external signal */
  if (XMC_CCU8_SLICE_EVENT_2 == handle_ptr->config_ptr->ext_trap_event)
 80260c2:	f893 2037 	ldrb.w	r2, [r3, #55]	; 0x37
  {
    XMC_CCU8_SLICE_TrapConfig(handle_ptr->ccu8_slice_ptr, handle_ptr->config_ptr->ext_trap_exit,
 80260c6:	68a0      	ldr	r0, [r4, #8]
                                    handle_ptr->config_ptr->ext_mod_mode, XMC_CCU8_SLICE_MODULATION_CHANNEL_1_AND_2,
                                    handle_ptr->config_ptr->ext_mod_sync);
  }

  /* PWM signal (ST bit) output gets modulated by external signal */
  if (XMC_CCU8_SLICE_EVENT_2 == handle_ptr->config_ptr->ext_trap_event)
 80260c8:	2a03      	cmp	r2, #3
 80260ca:	f000 8119 	beq.w	8026300 <PWM_CCU8_Init+0x338>
          (uint32_t)(XMC_CCU8_SLICE_OUTPUT_0 | XMC_CCU8_SLICE_OUTPUT_1 | XMC_CCU8_SLICE_OUTPUT_2 | XMC_CCU8_SLICE_OUTPUT_3)
		  );
    }
  }

  if ((XMC_CCU8_SLICE_EVENT_NONE != handle_ptr->config_ptr->ext_override_edge_event) || (XMC_CCU8_SLICE_EVENT_NONE
 80260ce:	8e9a      	ldrh	r2, [r3, #52]	; 0x34
 80260d0:	b142      	cbz	r2, 80260e4 <PWM_CCU8_Init+0x11c>
      != handle_ptr->config_ptr->ext_override_level_event))
  {
    XMC_CCU8_SLICE_ConfigureStatusBitOverrideEvent(handle_ptr->ccu8_slice_ptr,
 80260d2:	6a19      	ldr	r1, [r3, #32]
 80260d4:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80260d6:	f7fb fb95 	bl	8021804 <XMC_CCU8_SLICE_ConfigureStatusBitOverrideEvent>
                                                   handle_ptr->config_ptr->event1_config_ptr,
                                                   handle_ptr->config_ptr->event2_config_ptr);
    XMC_CCU8_SLICE_StatusBitOverrideConfig(handle_ptr->ccu8_slice_ptr);
 80260da:	68a0      	ldr	r0, [r4, #8]
 80260dc:	f7fb fb78 	bl	80217d0 <XMC_CCU8_SLICE_StatusBitOverrideConfig>
 80260e0:	6823      	ldr	r3, [r4, #0]
 80260e2:	68a0      	ldr	r0, [r4, #8]
static void PWM_CCU8_lInit_Interrupt(PWM_CCU8_t* handle_ptr)
{

  /* Enable events. Bind event to corresponding service request node. */

  XMC_CCU8_SLICE_SetInterruptNode(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_IRQ_ID_PERIOD_MATCH,
 80260e4:	7c5a      	ldrb	r2, [r3, #17]
 80260e6:	2100      	movs	r1, #0
 80260e8:	f7fb fbfe 	bl	80218e8 <XMC_CCU8_SLICE_SetInterruptNode>
                                  handle_ptr->config_ptr->sr_per_match);
  XMC_CCU8_SLICE_SetInterruptNode(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_IRQ_ID_COMPARE_MATCH_UP_CH_1,
 80260ec:	6823      	ldr	r3, [r4, #0]
 80260ee:	68a0      	ldr	r0, [r4, #8]
 80260f0:	7c9a      	ldrb	r2, [r3, #18]
 80260f2:	2102      	movs	r1, #2
 80260f4:	f7fb fbf8 	bl	80218e8 <XMC_CCU8_SLICE_SetInterruptNode>
                                  handle_ptr->config_ptr->sr_cmp1_match_up);
  XMC_CCU8_SLICE_SetInterruptNode(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_IRQ_ID_COMPARE_MATCH_DOWN_CH_1,
 80260f8:	6823      	ldr	r3, [r4, #0]
 80260fa:	68a0      	ldr	r0, [r4, #8]
 80260fc:	7cda      	ldrb	r2, [r3, #19]
 80260fe:	2103      	movs	r1, #3
 8026100:	f7fb fbf2 	bl	80218e8 <XMC_CCU8_SLICE_SetInterruptNode>
                                  handle_ptr->config_ptr->sr_cmp1_match_down);
  XMC_CCU8_SLICE_SetInterruptNode(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_IRQ_ID_COMPARE_MATCH_UP_CH_2,
 8026104:	6823      	ldr	r3, [r4, #0]
 8026106:	68a0      	ldr	r0, [r4, #8]
 8026108:	7d1a      	ldrb	r2, [r3, #20]
 802610a:	2104      	movs	r1, #4
 802610c:	f7fb fbec 	bl	80218e8 <XMC_CCU8_SLICE_SetInterruptNode>
                                  handle_ptr->config_ptr->sr_cmp2_match_up);
  XMC_CCU8_SLICE_SetInterruptNode(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_IRQ_ID_COMPARE_MATCH_DOWN_CH_2,
 8026110:	6823      	ldr	r3, [r4, #0]
 8026112:	68a0      	ldr	r0, [r4, #8]
 8026114:	7d5a      	ldrb	r2, [r3, #21]
 8026116:	2105      	movs	r1, #5
 8026118:	f7fb fbe6 	bl	80218e8 <XMC_CCU8_SLICE_SetInterruptNode>
                                  handle_ptr->config_ptr->sr_cmp2_match_down);
  XMC_CCU8_SLICE_SetInterruptNode(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_IRQ_ID_ONE_MATCH,
 802611c:	6823      	ldr	r3, [r4, #0]
 802611e:	68a0      	ldr	r0, [r4, #8]
 8026120:	7d9a      	ldrb	r2, [r3, #22]
 8026122:	2101      	movs	r1, #1
 8026124:	f7fb fbe0 	bl	80218e8 <XMC_CCU8_SLICE_SetInterruptNode>
                                  handle_ptr->config_ptr->sr_one_match_down);
  XMC_CCU8_SLICE_SetInterruptNode(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_IRQ_ID_EVENT0,
 8026128:	6823      	ldr	r3, [r4, #0]
 802612a:	68a0      	ldr	r0, [r4, #8]
 802612c:	7dda      	ldrb	r2, [r3, #23]
 802612e:	2108      	movs	r1, #8
 8026130:	f7fb fbda 	bl	80218e8 <XMC_CCU8_SLICE_SetInterruptNode>
                                  handle_ptr->config_ptr->sr_e0);
  XMC_CCU8_SLICE_SetInterruptNode(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_IRQ_ID_EVENT1,
 8026134:	6823      	ldr	r3, [r4, #0]
 8026136:	68a0      	ldr	r0, [r4, #8]
 8026138:	7e1a      	ldrb	r2, [r3, #24]
 802613a:	2109      	movs	r1, #9
 802613c:	f7fb fbd4 	bl	80218e8 <XMC_CCU8_SLICE_SetInterruptNode>
                                  handle_ptr->config_ptr->sr_e1);
  XMC_CCU8_SLICE_SetInterruptNode(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_IRQ_ID_EVENT2,
 8026140:	6823      	ldr	r3, [r4, #0]
 8026142:	68a0      	ldr	r0, [r4, #8]
 8026144:	7e5a      	ldrb	r2, [r3, #25]
 8026146:	210a      	movs	r1, #10
 8026148:	f7fb fbce 	bl	80218e8 <XMC_CCU8_SLICE_SetInterruptNode>
                                  handle_ptr->config_ptr->sr_e2);

  if ((bool) true == handle_ptr->config_ptr->int_per_match)
 802614c:	6823      	ldr	r3, [r4, #0]
 802614e:	7a1a      	ldrb	r2, [r3, #8]
 8026150:	b132      	cbz	r2, 8026160 <PWM_CCU8_Init+0x198>
  {
    XMC_DEBUG("PWM_CCU8_Init: Interrupt period match enable");
    XMC_CCU8_SLICE_EnableEvent(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_IRQ_ID_PERIOD_MATCH);
 8026152:	68a1      	ldr	r1, [r4, #8]
__STATIC_INLINE void XMC_CCU8_SLICE_EnableEvent(XMC_CCU8_SLICE_t *const slice, const XMC_CCU8_SLICE_IRQ_ID_t event)
{
  XMC_ASSERT("XMC_CCU8_SLICE_EnableEvent:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU8_SLICE_EnableEvent:Invalid SR event", XMC_CCU8_SLICE_CHECK_INTERRUPT(event));

  slice->INTE |= ((uint32_t) 1) << ((uint32_t) event);
 8026154:	f8d1 20a4 	ldr.w	r2, [r1, #164]	; 0xa4
 8026158:	f042 0201 	orr.w	r2, r2, #1
 802615c:	f8c1 20a4 	str.w	r2, [r1, #164]	; 0xa4
  }

  if ((bool) true == handle_ptr->config_ptr->int_cmp1_match_up)
 8026160:	7a5a      	ldrb	r2, [r3, #9]
 8026162:	b132      	cbz	r2, 8026172 <PWM_CCU8_Init+0x1aa>
  {
    XMC_DEBUG("PWM_CCU8_Init: Interrupt compare match ch1 up enable");
    XMC_CCU8_SLICE_EnableEvent(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_IRQ_ID_COMPARE_MATCH_UP_CH_1);
 8026164:	68a1      	ldr	r1, [r4, #8]
 8026166:	f8d1 20a4 	ldr.w	r2, [r1, #164]	; 0xa4
 802616a:	f042 0204 	orr.w	r2, r2, #4
 802616e:	f8c1 20a4 	str.w	r2, [r1, #164]	; 0xa4
  }

  if ((bool) true == handle_ptr->config_ptr->int_cmp1_match_down)
 8026172:	7a9a      	ldrb	r2, [r3, #10]
 8026174:	b132      	cbz	r2, 8026184 <PWM_CCU8_Init+0x1bc>
  {
    XMC_DEBUG("PWM_CCU8_Init: Interrupt compare match ch1 down enable");
    XMC_CCU8_SLICE_EnableEvent(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_IRQ_ID_COMPARE_MATCH_DOWN_CH_1);
 8026176:	68a1      	ldr	r1, [r4, #8]
 8026178:	f8d1 20a4 	ldr.w	r2, [r1, #164]	; 0xa4
 802617c:	f042 0208 	orr.w	r2, r2, #8
 8026180:	f8c1 20a4 	str.w	r2, [r1, #164]	; 0xa4
  }

  if ((bool) true == handle_ptr->config_ptr->int_cmp2_match_up)
 8026184:	7ada      	ldrb	r2, [r3, #11]
 8026186:	b132      	cbz	r2, 8026196 <PWM_CCU8_Init+0x1ce>
  {
    XMC_DEBUG("PWM_CCU8_Init: Interrupt compare match ch2 up enable");
    XMC_CCU8_SLICE_EnableEvent(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_IRQ_ID_COMPARE_MATCH_UP_CH_2);
 8026188:	68a1      	ldr	r1, [r4, #8]
 802618a:	f8d1 20a4 	ldr.w	r2, [r1, #164]	; 0xa4
 802618e:	f042 0210 	orr.w	r2, r2, #16
 8026192:	f8c1 20a4 	str.w	r2, [r1, #164]	; 0xa4
  }

  if ((bool) true == handle_ptr->config_ptr->int_cmp2_match_down)
 8026196:	7b1a      	ldrb	r2, [r3, #12]
 8026198:	b132      	cbz	r2, 80261a8 <PWM_CCU8_Init+0x1e0>
  {
    XMC_DEBUG("PWM_CCU8_Init: Interrupt compare match ch2 down enable");
    XMC_CCU8_SLICE_EnableEvent(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_IRQ_ID_COMPARE_MATCH_DOWN_CH_2);
 802619a:	68a1      	ldr	r1, [r4, #8]
 802619c:	f8d1 20a4 	ldr.w	r2, [r1, #164]	; 0xa4
 80261a0:	f042 0220 	orr.w	r2, r2, #32
 80261a4:	f8c1 20a4 	str.w	r2, [r1, #164]	; 0xa4
  }

  if ((bool) true == handle_ptr->config_ptr->int_one_match_down)
 80261a8:	7b5a      	ldrb	r2, [r3, #13]
 80261aa:	b132      	cbz	r2, 80261ba <PWM_CCU8_Init+0x1f2>
  {
    XMC_DEBUG("PWM_CCU8_Init: Interrupt one match enable");
    XMC_CCU8_SLICE_EnableEvent(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_IRQ_ID_ONE_MATCH);
 80261ac:	68a1      	ldr	r1, [r4, #8]
 80261ae:	f8d1 20a4 	ldr.w	r2, [r1, #164]	; 0xa4
 80261b2:	f042 0202 	orr.w	r2, r2, #2
 80261b6:	f8c1 20a4 	str.w	r2, [r1, #164]	; 0xa4
  }

  if ((bool) true == handle_ptr->config_ptr->int_e0)
 80261ba:	7b9a      	ldrb	r2, [r3, #14]
 80261bc:	b132      	cbz	r2, 80261cc <PWM_CCU8_Init+0x204>
  {
    XMC_DEBUG("PWM_CCU8_Init: Interrupt event 0 enable");
    XMC_CCU8_SLICE_EnableEvent(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_IRQ_ID_EVENT0);
 80261be:	68a1      	ldr	r1, [r4, #8]
 80261c0:	f8d1 20a4 	ldr.w	r2, [r1, #164]	; 0xa4
 80261c4:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 80261c8:	f8c1 20a4 	str.w	r2, [r1, #164]	; 0xa4
  }

  if ((bool) true == handle_ptr->config_ptr->int_e1)
 80261cc:	7bda      	ldrb	r2, [r3, #15]
 80261ce:	b132      	cbz	r2, 80261de <PWM_CCU8_Init+0x216>
  {
    XMC_DEBUG("PWM_CCU8_Init: Interrupt event 1 enable");
    XMC_CCU8_SLICE_EnableEvent(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_IRQ_ID_EVENT1);
 80261d0:	68a1      	ldr	r1, [r4, #8]
 80261d2:	f8d1 20a4 	ldr.w	r2, [r1, #164]	; 0xa4
 80261d6:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 80261da:	f8c1 20a4 	str.w	r2, [r1, #164]	; 0xa4
  }

  if ((bool) true == handle_ptr->config_ptr->int_e2)
 80261de:	7c1a      	ldrb	r2, [r3, #16]
 80261e0:	b132      	cbz	r2, 80261f0 <PWM_CCU8_Init+0x228>
  {
    XMC_DEBUG("PWM_CCU8_Init: Interrupt event 2 enable");
    XMC_CCU8_SLICE_EnableEvent(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_IRQ_ID_EVENT2);
 80261e2:	68a1      	ldr	r1, [r4, #8]
 80261e4:	f8d1 20a4 	ldr.w	r2, [r1, #164]	; 0xa4
 80261e8:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 80261ec:	f8c1 20a4 	str.w	r2, [r1, #164]	; 0xa4
  }
}
static void PWM_CCU8_lInit_GPIO(PWM_CCU8_t* handle_ptr)
{
  if ((bool) true == handle_ptr->config_ptr->gpio_ch1_out0_enable)
 80261f0:	f893 204c 	ldrb.w	r2, [r3, #76]	; 0x4c
 80261f4:	2a00      	cmp	r2, #0
 80261f6:	d142      	bne.n	802627e <PWM_CCU8_Init+0x2b6>
 80261f8:	461d      	mov	r5, r3
  {
    XMC_GPIO_Init(handle_ptr->config_ptr->gpio_ch1_out0_ptr, handle_ptr->config_ptr->gpio_ch1_out0_pin,
                  handle_ptr->config_ptr->gpio_ch1_out0_config_ptr);
  }

  if ((bool) true == handle_ptr->config_ptr->gpio_ch1_out1_enable)
 80261fa:	f895 305c 	ldrb.w	r3, [r5, #92]	; 0x5c
 80261fe:	2b00      	cmp	r3, #0
 8026200:	d135      	bne.n	802626e <PWM_CCU8_Init+0x2a6>
  {
    XMC_GPIO_Init(handle_ptr->config_ptr->gpio_ch1_out1_ptr, handle_ptr->config_ptr->gpio_ch1_out1_pin,
                  handle_ptr->config_ptr->gpio_ch1_out1_config_ptr);
  }

  if ((bool) true == handle_ptr->config_ptr->gpio_ch2_out2_enable)
 8026202:	f895 306c 	ldrb.w	r3, [r5, #108]	; 0x6c
 8026206:	bb53      	cbnz	r3, 802625e <PWM_CCU8_Init+0x296>
  {
    XMC_GPIO_Init(handle_ptr->config_ptr->gpio_ch2_out2_ptr, handle_ptr->config_ptr->gpio_ch2_out2_pin,
                  handle_ptr->config_ptr->gpio_ch2_out2_config_ptr);
  }

  if ((bool) true == handle_ptr->config_ptr->gpio_ch2_out3_enable)
 8026208:	f895 307c 	ldrb.w	r3, [r5, #124]	; 0x7c
 802620c:	b143      	cbz	r3, 8026220 <PWM_CCU8_Init+0x258>
  {
    XMC_GPIO_Init(handle_ptr->config_ptr->gpio_ch2_out3_ptr, handle_ptr->config_ptr->gpio_ch2_out3_pin,
 802620e:	f8d5 0080 	ldr.w	r0, [r5, #128]	; 0x80
 8026212:	f895 1084 	ldrb.w	r1, [r5, #132]	; 0x84
 8026216:	f8d5 2088 	ldr.w	r2, [r5, #136]	; 0x88
 802621a:	f7fa feab 	bl	8020f74 <XMC_GPIO_Init>
 802621e:	6825      	ldr	r5, [r4, #0]

      /*Initializes the GPIO*/
      PWM_CCU8_lInit_GPIO(handle_ptr);

      frequency_module = handle_ptr->config_ptr->global_ccu8_handle->module_frequency;
      prescalar = (uint32_t) handle_ptr->config_ptr->ccu8_cc8_slice_timer_ptr->prescaler_initval;
 8026220:	6caa      	ldr	r2, [r5, #72]	; 0x48
      PWM_CCU8_lInit_Interrupt(handle_ptr);

      /*Initializes the GPIO*/
      PWM_CCU8_lInit_GPIO(handle_ptr);

      frequency_module = handle_ptr->config_ptr->global_ccu8_handle->module_frequency;
 8026222:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
      prescalar = (uint32_t) handle_ptr->config_ptr->ccu8_cc8_slice_timer_ptr->prescaler_initval;
 8026226:	7b12      	ldrb	r2, [r2, #12]
      PWM_CCU8_lInit_Interrupt(handle_ptr);

      /*Initializes the GPIO*/
      PWM_CCU8_lInit_GPIO(handle_ptr);

      frequency_module = handle_ptr->config_ptr->global_ccu8_handle->module_frequency;
 8026228:	681b      	ldr	r3, [r3, #0]

      handle_ptr->state = PWM_CCU8_STATE_INITIALIZED;
      status = PWM_CCU8_STATUS_SUCCESS;

      /* Start the PWM generation if start at initialization is enabled */
      if ((bool) true == handle_ptr->config_ptr->start_control)
 802622a:	7828      	ldrb	r0, [r5, #0]
      /*Initializes the GPIO*/
      PWM_CCU8_lInit_GPIO(handle_ptr);

      frequency_module = handle_ptr->config_ptr->global_ccu8_handle->module_frequency;
      prescalar = (uint32_t) handle_ptr->config_ptr->ccu8_cc8_slice_timer_ptr->prescaler_initval;
      frequency_module = frequency_module / ((uint32_t) 1 << prescalar);
 802622c:	f002 020f 	and.w	r2, r2, #15
 8026230:	40d3      	lsrs	r3, r2
      handle_ptr->frequency_tclk = frequency_module;

      handle_ptr->state = PWM_CCU8_STATE_INITIALIZED;
 8026232:	2201      	movs	r2, #1
      PWM_CCU8_lInit_GPIO(handle_ptr);

      frequency_module = handle_ptr->config_ptr->global_ccu8_handle->module_frequency;
      prescalar = (uint32_t) handle_ptr->config_ptr->ccu8_cc8_slice_timer_ptr->prescaler_initval;
      frequency_module = frequency_module / ((uint32_t) 1 << prescalar);
      handle_ptr->frequency_tclk = frequency_module;
 8026234:	6223      	str	r3, [r4, #32]

      handle_ptr->state = PWM_CCU8_STATE_INITIALIZED;
 8026236:	7722      	strb	r2, [r4, #28]
      status = PWM_CCU8_STATUS_SUCCESS;

      /* Start the PWM generation if start at initialization is enabled */
      if ((bool) true == handle_ptr->config_ptr->start_control)
 8026238:	2800      	cmp	r0, #0
 802623a:	f43f aeca 	beq.w	8025fd2 <PWM_CCU8_Init+0xa>
  status = PWM_CCU8_STATUS_FAILURE;
  XMC_ASSERT("PWM_CCU8_Start:handle_ptr NULL", (handle_ptr != NULL));
  if ((PWM_CCU8_STATE_INITIALIZED == handle_ptr->state) || (PWM_CCU8_STATE_STOPPED == handle_ptr->state))
  {
    /* clear IDLE mode for the slice; Start timer */
    XMC_CCU8_EnableClock(handle_ptr->ccu8_module_ptr, handle_ptr->slice_number);
 802623e:	6861      	ldr	r1, [r4, #4]
__STATIC_INLINE void XMC_CCU8_EnableClock(XMC_CCU8_MODULE_t *const module, const uint8_t slice_number)
{
  XMC_ASSERT("XMC_CCU8_EnableClock:Invalid Module Pointer", XMC_CCU8_IsValidModule(module));
  XMC_ASSERT("XMC_CCU8_EnableClock:Invalid Slice Number", (slice_number < 4U));

  module->GIDLC |= ((uint32_t) 1 << slice_number);
 8026240:	7b66      	ldrb	r6, [r4, #13]
 8026242:	68cb      	ldr	r3, [r1, #12]

    if (XMC_CCU8_SLICE_EVENT_NONE == handle_ptr->config_ptr->ext_start_event)
 8026244:	f895 0028 	ldrb.w	r0, [r5, #40]	; 0x28
 8026248:	fa02 f506 	lsl.w	r5, r2, r6
 802624c:	432b      	orrs	r3, r5
 802624e:	60cb      	str	r3, [r1, #12]
 8026250:	b908      	cbnz	r0, 8026256 <PWM_CCU8_Init+0x28e>
    {
      XMC_CCU8_SLICE_StartTimer(handle_ptr->ccu8_slice_ptr);
 8026252:	68a3      	ldr	r3, [r4, #8]
 *  XMC_CCU8_SLICE_StopTimer().
 */
__STATIC_INLINE void XMC_CCU8_SLICE_StartTimer(XMC_CCU8_SLICE_t *const slice)
{
  XMC_ASSERT("XMC_CCU8_SLICE_StartTimer:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  slice->TCSET = CCU8_CC8_TCSET_TRBS_Msk;
 8026254:	60da      	str	r2, [r3, #12]
    }

    handle_ptr->state = PWM_CCU8_STATE_RUNNING;
 8026256:	2302      	movs	r3, #2
 8026258:	7723      	strb	r3, [r4, #28]
      status = PWM_CCU8_STATUS_SUCCESS;

      /* Start the PWM generation if start at initialization is enabled */
      if ((bool) true == handle_ptr->config_ptr->start_control)
      {
        status = PWM_CCU8_Start(handle_ptr);
 802625a:	2000      	movs	r0, #0
 802625c:	e6b9      	b.n	8025fd2 <PWM_CCU8_Init+0xa>
                  handle_ptr->config_ptr->gpio_ch1_out1_config_ptr);
  }

  if ((bool) true == handle_ptr->config_ptr->gpio_ch2_out2_enable)
  {
    XMC_GPIO_Init(handle_ptr->config_ptr->gpio_ch2_out2_ptr, handle_ptr->config_ptr->gpio_ch2_out2_pin,
 802625e:	6f28      	ldr	r0, [r5, #112]	; 0x70
 8026260:	f895 1074 	ldrb.w	r1, [r5, #116]	; 0x74
 8026264:	6faa      	ldr	r2, [r5, #120]	; 0x78
 8026266:	f7fa fe85 	bl	8020f74 <XMC_GPIO_Init>
 802626a:	6825      	ldr	r5, [r4, #0]
 802626c:	e7cc      	b.n	8026208 <PWM_CCU8_Init+0x240>
                  handle_ptr->config_ptr->gpio_ch1_out0_config_ptr);
  }

  if ((bool) true == handle_ptr->config_ptr->gpio_ch1_out1_enable)
  {
    XMC_GPIO_Init(handle_ptr->config_ptr->gpio_ch1_out1_ptr, handle_ptr->config_ptr->gpio_ch1_out1_pin,
 802626e:	6e28      	ldr	r0, [r5, #96]	; 0x60
 8026270:	f895 1064 	ldrb.w	r1, [r5, #100]	; 0x64
 8026274:	6eaa      	ldr	r2, [r5, #104]	; 0x68
 8026276:	f7fa fe7d 	bl	8020f74 <XMC_GPIO_Init>
 802627a:	6825      	ldr	r5, [r4, #0]
 802627c:	e7c1      	b.n	8026202 <PWM_CCU8_Init+0x23a>
}
static void PWM_CCU8_lInit_GPIO(PWM_CCU8_t* handle_ptr)
{
  if ((bool) true == handle_ptr->config_ptr->gpio_ch1_out0_enable)
  {
    XMC_GPIO_Init(handle_ptr->config_ptr->gpio_ch1_out0_ptr, handle_ptr->config_ptr->gpio_ch1_out0_pin,
 802627e:	6d18      	ldr	r0, [r3, #80]	; 0x50
 8026280:	f893 1054 	ldrb.w	r1, [r3, #84]	; 0x54
 8026284:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8026286:	f7fa fe75 	bl	8020f74 <XMC_GPIO_Init>
 802628a:	6825      	ldr	r5, [r4, #0]
 802628c:	e7b5      	b.n	80261fa <PWM_CCU8_Init+0x232>
    XMC_CCU8_SLICE_LoadSelector(handle_ptr->ccu8_slice_ptr, handle_ptr->config_ptr->ext_load_selector);
  }
  /* External signal PWM signal (ST bit) output gets modulated by external signal */
  if (XMC_CCU8_SLICE_EVENT_NONE != handle_ptr->config_ptr->ext_mod_event)
  {
    XMC_CCU8_SLICE_ModulationConfig(handle_ptr->ccu8_slice_ptr, handle_ptr->config_ptr->ext_mod_event,
 802628e:	f893 2032 	ldrb.w	r2, [r3, #50]	; 0x32
 8026292:	f893 3033 	ldrb.w	r3, [r3, #51]	; 0x33
 8026296:	68a0      	ldr	r0, [r4, #8]
 8026298:	9300      	str	r3, [sp, #0]
 802629a:	2303      	movs	r3, #3
 802629c:	f7fb fa62 	bl	8021764 <XMC_CCU8_SLICE_ModulationConfig>
 80262a0:	6823      	ldr	r3, [r4, #0]
 80262a2:	e70e      	b.n	80260c2 <PWM_CCU8_Init+0xfa>
    XMC_CCU8_SLICE_CountConfig(handle_ptr->ccu8_slice_ptr, handle_ptr->config_ptr->ext_count_event);
  }
  /* Timer gets loaded with compare register value or period register value on external signal */
  if (XMC_CCU8_SLICE_EVENT_NONE != handle_ptr->config_ptr->ext_load_event)
  {
    XMC_CCU8_SLICE_LoadConfig(handle_ptr->ccu8_slice_ptr, handle_ptr->config_ptr->ext_load_event);
 80262a4:	68a0      	ldr	r0, [r4, #8]
 80262a6:	f7fb fa4d 	bl	8021744 <XMC_CCU8_SLICE_LoadConfig>
    XMC_CCU8_SLICE_LoadSelector(handle_ptr->ccu8_slice_ptr, handle_ptr->config_ptr->ext_load_selector);
 80262aa:	6823      	ldr	r3, [r4, #0]
 80262ac:	68a0      	ldr	r0, [r4, #8]
 80262ae:	f893 1030 	ldrb.w	r1, [r3, #48]	; 0x30
 80262b2:	f7fb fa4f 	bl	8021754 <XMC_CCU8_SLICE_LoadSelector>
 80262b6:	6823      	ldr	r3, [r4, #0]
 80262b8:	e6fe      	b.n	80260b8 <PWM_CCU8_Init+0xf0>
    XMC_CCU8_SLICE_GateConfig(handle_ptr->ccu8_slice_ptr, handle_ptr->config_ptr->ext_gate_event);
  }
  /* Timer increments on external signal */
  if (XMC_CCU8_SLICE_EVENT_NONE != handle_ptr->config_ptr->ext_count_event)
  {
    XMC_CCU8_SLICE_CountConfig(handle_ptr->ccu8_slice_ptr, handle_ptr->config_ptr->ext_count_event);
 80262ba:	68a0      	ldr	r0, [r4, #8]
 80262bc:	f7fb fa70 	bl	80217a0 <XMC_CCU8_SLICE_CountConfig>
 80262c0:	6823      	ldr	r3, [r4, #0]
 80262c2:	e6f4      	b.n	80260ae <PWM_CCU8_Init+0xe6>
    XMC_CCU8_SLICE_DirectionConfig(handle_ptr->ccu8_slice_ptr, handle_ptr->config_ptr->ext_count_dir_event);
  }
  /* External signal can stop the timer and the timer value remains same */
  if (XMC_CCU8_SLICE_EVENT_NONE != handle_ptr->config_ptr->ext_gate_event)
  {
    XMC_CCU8_SLICE_GateConfig(handle_ptr->ccu8_slice_ptr, handle_ptr->config_ptr->ext_gate_event);
 80262c4:	68a0      	ldr	r0, [r4, #8]
 80262c6:	f7fb fa73 	bl	80217b0 <XMC_CCU8_SLICE_GateConfig>
 80262ca:	6823      	ldr	r3, [r4, #0]
 80262cc:	e6ea      	b.n	80260a4 <PWM_CCU8_Init+0xdc>
  }

  /* External signal can change the timer counting direction */
  if (XMC_CCU8_SLICE_EVENT_NONE != handle_ptr->config_ptr->ext_count_dir_event)
  {
    XMC_CCU8_SLICE_DirectionConfig(handle_ptr->ccu8_slice_ptr, handle_ptr->config_ptr->ext_count_dir_event);
 80262ce:	68a0      	ldr	r0, [r4, #8]
 80262d0:	f7fb fa76 	bl	80217c0 <XMC_CCU8_SLICE_DirectionConfig>
 80262d4:	6823      	ldr	r3, [r4, #0]
 80262d6:	e6e0      	b.n	802609a <PWM_CCU8_Init+0xd2>
  }

  /* External signal can stop the timer */
  if (XMC_CCU8_SLICE_EVENT_NONE != handle_ptr->config_ptr->ext_stop_event)
  {
    XMC_CCU8_SLICE_StopConfig(handle_ptr->ccu8_slice_ptr, handle_ptr->config_ptr->ext_stop_event,
 80262d8:	f893 202b 	ldrb.w	r2, [r3, #43]	; 0x2b
 80262dc:	68a0      	ldr	r0, [r4, #8]
 80262de:	f7fb fa23 	bl	8021728 <XMC_CCU8_SLICE_StopConfig>
 80262e2:	6823      	ldr	r3, [r4, #0]
 80262e4:	e6d4      	b.n	8026090 <PWM_CCU8_Init+0xc8>
                                handle_ptr->config_ptr->event2_config_ptr);

  /* External signal controls start of the timer */
  if (XMC_CCU8_SLICE_EVENT_NONE != handle_ptr->config_ptr->ext_start_event)
  {
    XMC_CCU8_SLICE_StartConfig(handle_ptr->ccu8_slice_ptr, handle_ptr->config_ptr->ext_start_event,
 80262e6:	f893 2029 	ldrb.w	r2, [r3, #41]	; 0x29
 80262ea:	68a0      	ldr	r0, [r4, #8]
 80262ec:	f7fb fa0e 	bl	802170c <XMC_CCU8_SLICE_StartConfig>
 80262f0:	6823      	ldr	r3, [r4, #0]
 80262f2:	e6c8      	b.n	8026086 <PWM_CCU8_Init+0xbe>
                                          (uint16_t) handle_ptr->config_ptr->compare2_value);

      if ((1U == handle_ptr->config_ptr->ccu8_cc8_slice_timer_ptr->mcm_ch1_enable) || (1U
          == handle_ptr->config_ptr->ccu8_cc8_slice_timer_ptr->mcm_ch2_enable))
      {
        XMC_CCU8_SetMultiChannelShadowTransferMode(handle_ptr->ccu8_module_ptr,
 80262f4:	6bd1      	ldr	r1, [r2, #60]	; 0x3c
 80262f6:	6860      	ldr	r0, [r4, #4]
 80262f8:	f7fb fa00 	bl	80216fc <XMC_CCU8_SetMultiChannelShadowTransferMode>
 80262fc:	6822      	ldr	r2, [r4, #0]
 80262fe:	e693      	b.n	8026028 <PWM_CCU8_Init+0x60>
  }

  /* PWM signal (ST bit) output gets modulated by external signal */
  if (XMC_CCU8_SLICE_EVENT_2 == handle_ptr->config_ptr->ext_trap_event)
  {
    XMC_CCU8_SLICE_TrapConfig(handle_ptr->ccu8_slice_ptr, handle_ptr->config_ptr->ext_trap_exit,
 8026300:	f893 2038 	ldrb.w	r2, [r3, #56]	; 0x38
 8026304:	f893 1039 	ldrb.w	r1, [r3, #57]	; 0x39
 8026308:	f7fb fa68 	bl	80217dc <XMC_CCU8_SLICE_TrapConfig>
                              handle_ptr->config_ptr->ext_trap_sync);
    if ((bool) true == handle_ptr->config_ptr->ext_trap_enable)
 802630c:	6823      	ldr	r3, [r4, #0]
    {
      XMC_CCU8_SLICE_EnableTrap(
 802630e:	68a0      	ldr	r0, [r4, #8]
  /* PWM signal (ST bit) output gets modulated by external signal */
  if (XMC_CCU8_SLICE_EVENT_2 == handle_ptr->config_ptr->ext_trap_event)
  {
    XMC_CCU8_SLICE_TrapConfig(handle_ptr->ccu8_slice_ptr, handle_ptr->config_ptr->ext_trap_exit,
                              handle_ptr->config_ptr->ext_trap_sync);
    if ((bool) true == handle_ptr->config_ptr->ext_trap_enable)
 8026310:	f893 2036 	ldrb.w	r2, [r3, #54]	; 0x36
 8026314:	2a00      	cmp	r2, #0
 8026316:	f43f aeda 	beq.w	80260ce <PWM_CCU8_Init+0x106>
 *  XMC_CCU8_SLICE_SetInput().
 */
__STATIC_INLINE void XMC_CCU8_SLICE_EnableTrap(XMC_CCU8_SLICE_t *const slice, const uint32_t out_mask)
{
  XMC_ASSERT("XMC_CCU8_SLICE_EnableTrap:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  slice->TC |= (uint32_t)out_mask << CCU8_CC8_TC_TRAPE0_Pos;
 802631a:	6942      	ldr	r2, [r0, #20]
 802631c:	f442 12f0 	orr.w	r2, r2, #1966080	; 0x1e0000
 8026320:	6142      	str	r2, [r0, #20]
 8026322:	e6d4      	b.n	80260ce <PWM_CCU8_Init+0x106>

08026324 <PWM_CCU8_Start>:
{
  PWM_CCU8_STATUS_t status;

  status = PWM_CCU8_STATUS_FAILURE;
  XMC_ASSERT("PWM_CCU8_Start:handle_ptr NULL", (handle_ptr != NULL));
  if ((PWM_CCU8_STATE_INITIALIZED == handle_ptr->state) || (PWM_CCU8_STATE_STOPPED == handle_ptr->state))
 8026324:	7f03      	ldrb	r3, [r0, #28]
 8026326:	f003 03fd 	and.w	r3, r3, #253	; 0xfd
 802632a:	2b01      	cmp	r3, #1
 802632c:	d001      	beq.n	8026332 <PWM_CCU8_Start+0xe>
/*Starts the CCU8_CC8 slice. This needs to be called even if external start is configured.*/
PWM_CCU8_STATUS_t PWM_CCU8_Start(PWM_CCU8_t* handle_ptr)
{
  PWM_CCU8_STATUS_t status;

  status = PWM_CCU8_STATUS_FAILURE;
 802632e:	2001      	movs	r0, #1
 8026330:	4770      	bx	lr

}
/**********************************************************************************************************/
/*Starts the CCU8_CC8 slice. This needs to be called even if external start is configured.*/
PWM_CCU8_STATUS_t PWM_CCU8_Start(PWM_CCU8_t* handle_ptr)
{
 8026332:	b430      	push	{r4, r5}
  status = PWM_CCU8_STATUS_FAILURE;
  XMC_ASSERT("PWM_CCU8_Start:handle_ptr NULL", (handle_ptr != NULL));
  if ((PWM_CCU8_STATE_INITIALIZED == handle_ptr->state) || (PWM_CCU8_STATE_STOPPED == handle_ptr->state))
  {
    /* clear IDLE mode for the slice; Start timer */
    XMC_CCU8_EnableClock(handle_ptr->ccu8_module_ptr, handle_ptr->slice_number);
 8026334:	6841      	ldr	r1, [r0, #4]
__STATIC_INLINE void XMC_CCU8_EnableClock(XMC_CCU8_MODULE_t *const module, const uint8_t slice_number)
{
  XMC_ASSERT("XMC_CCU8_EnableClock:Invalid Module Pointer", XMC_CCU8_IsValidModule(module));
  XMC_ASSERT("XMC_CCU8_EnableClock:Invalid Slice Number", (slice_number < 4U));

  module->GIDLC |= ((uint32_t) 1 << slice_number);
 8026336:	7b45      	ldrb	r5, [r0, #13]

    if (XMC_CCU8_SLICE_EVENT_NONE == handle_ptr->config_ptr->ext_start_event)
 8026338:	6804      	ldr	r4, [r0, #0]
 802633a:	68ca      	ldr	r2, [r1, #12]
 802633c:	f894 4028 	ldrb.w	r4, [r4, #40]	; 0x28
 8026340:	fa03 f505 	lsl.w	r5, r3, r5
 8026344:	432a      	orrs	r2, r5
 8026346:	60ca      	str	r2, [r1, #12]
 8026348:	b90c      	cbnz	r4, 802634e <PWM_CCU8_Start+0x2a>
    {
      XMC_CCU8_SLICE_StartTimer(handle_ptr->ccu8_slice_ptr);
 802634a:	6882      	ldr	r2, [r0, #8]
 *  XMC_CCU8_SLICE_StopTimer().
 */
__STATIC_INLINE void XMC_CCU8_SLICE_StartTimer(XMC_CCU8_SLICE_t *const slice)
{
  XMC_ASSERT("XMC_CCU8_SLICE_StartTimer:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  slice->TCSET = CCU8_CC8_TCSET_TRBS_Msk;
 802634c:	60d3      	str	r3, [r2, #12]
    }

    handle_ptr->state = PWM_CCU8_STATE_RUNNING;
 802634e:	2302      	movs	r3, #2
 8026350:	7703      	strb	r3, [r0, #28]
    status = PWM_CCU8_STATUS_SUCCESS;
    XMC_DEBUG("PWM_CCU8_Start:start PWM");
  }
  return (status);
} /* end of PWM_CCU8_Start() api */
 8026352:	bc30      	pop	{r4, r5}
    if (XMC_CCU8_SLICE_EVENT_NONE == handle_ptr->config_ptr->ext_start_event)
    {
      XMC_CCU8_SLICE_StartTimer(handle_ptr->ccu8_slice_ptr);
    }

    handle_ptr->state = PWM_CCU8_STATE_RUNNING;
 8026354:	2000      	movs	r0, #0
    status = PWM_CCU8_STATUS_SUCCESS;
    XMC_DEBUG("PWM_CCU8_Start:start PWM");
  }
  return (status);
} /* end of PWM_CCU8_Start() api */
 8026356:	4770      	bx	lr

08026358 <PWM_CCU8_Stop>:
{
  PWM_CCU8_STATUS_t status;

  status = PWM_CCU8_STATUS_FAILURE;
  XMC_ASSERT("PWM_CCU8_Stop:handle_ptr NULL", (handle_ptr != NULL));
  if (PWM_CCU8_STATE_UNINITIALIZED != handle_ptr->state)
 8026358:	7f02      	ldrb	r2, [r0, #28]
  return (status);
} /* end of PWM_CCU8_Start() api */
/**********************************************************************************************************/
/*Stops the CCU8_CC8 slice. */
PWM_CCU8_STATUS_t PWM_CCU8_Stop(PWM_CCU8_t* handle_ptr)
{
 802635a:	4603      	mov	r3, r0
  PWM_CCU8_STATUS_t status;

  status = PWM_CCU8_STATUS_FAILURE;
  XMC_ASSERT("PWM_CCU8_Stop:handle_ptr NULL", (handle_ptr != NULL));
  if (PWM_CCU8_STATE_UNINITIALIZED != handle_ptr->state)
 802635c:	b15a      	cbz	r2, 8026376 <PWM_CCU8_Stop+0x1e>
  {
    XMC_CCU8_SLICE_StopTimer(handle_ptr->ccu8_slice_ptr);
 802635e:	6882      	ldr	r2, [r0, #8]
  return (status);
} /* end of PWM_CCU8_Start() api */
/**********************************************************************************************************/
/*Stops the CCU8_CC8 slice. */
PWM_CCU8_STATUS_t PWM_CCU8_Stop(PWM_CCU8_t* handle_ptr)
{
 8026360:	b410      	push	{r4}
 *  XMC_CCU8_SLICE_StartTimer().
 */
__STATIC_INLINE void XMC_CCU8_SLICE_StopTimer(XMC_CCU8_SLICE_t *const slice)
{
  XMC_ASSERT("XMC_CCU8_SLICE_StopTimer:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  slice->TCCLR = (uint32_t) CCU8_CC8_TCCLR_TRBC_Msk;
 8026362:	2001      	movs	r0, #1
 *  XMC_CCU8_SLICE_StartTimer().
 */
__STATIC_INLINE void XMC_CCU8_SLICE_ClearTimer(XMC_CCU8_SLICE_t *const slice)
{
  XMC_ASSERT("XMC_CCU8_SLICE_ClearTimer:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  slice->TCCLR = (uint32_t) CCU8_CC8_TCCLR_TCC_Msk;
 8026364:	2402      	movs	r4, #2
  if (PWM_CCU8_STATE_UNINITIALIZED != handle_ptr->state)
  {
    XMC_CCU8_SLICE_StopTimer(handle_ptr->ccu8_slice_ptr);
    XMC_CCU8_SLICE_ClearTimer(handle_ptr->ccu8_slice_ptr);

    handle_ptr->state = PWM_CCU8_STATE_STOPPED;
 8026366:	2103      	movs	r1, #3
 *  XMC_CCU8_SLICE_StartTimer().
 */
__STATIC_INLINE void XMC_CCU8_SLICE_StopTimer(XMC_CCU8_SLICE_t *const slice)
{
  XMC_ASSERT("XMC_CCU8_SLICE_StopTimer:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  slice->TCCLR = (uint32_t) CCU8_CC8_TCCLR_TRBC_Msk;
 8026368:	6110      	str	r0, [r2, #16]
 *  XMC_CCU8_SLICE_StartTimer().
 */
__STATIC_INLINE void XMC_CCU8_SLICE_ClearTimer(XMC_CCU8_SLICE_t *const slice)
{
  XMC_ASSERT("XMC_CCU8_SLICE_ClearTimer:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  slice->TCCLR = (uint32_t) CCU8_CC8_TCCLR_TCC_Msk;
 802636a:	6114      	str	r4, [r2, #16]
    status = PWM_CCU8_STATUS_SUCCESS;
 802636c:	2000      	movs	r0, #0
  if (PWM_CCU8_STATE_UNINITIALIZED != handle_ptr->state)
  {
    XMC_CCU8_SLICE_StopTimer(handle_ptr->ccu8_slice_ptr);
    XMC_CCU8_SLICE_ClearTimer(handle_ptr->ccu8_slice_ptr);

    handle_ptr->state = PWM_CCU8_STATE_STOPPED;
 802636e:	7719      	strb	r1, [r3, #28]
    status = PWM_CCU8_STATUS_SUCCESS;
    XMC_DEBUG("PWM_CCU8_Stop:stop PWM");
  }
  return (status);

} /* end of PWM_CCU8_Stop() api */
 8026370:	f85d 4b04 	ldr.w	r4, [sp], #4
 8026374:	4770      	bx	lr
/*Stops the CCU8_CC8 slice. */
PWM_CCU8_STATUS_t PWM_CCU8_Stop(PWM_CCU8_t* handle_ptr)
{
  PWM_CCU8_STATUS_t status;

  status = PWM_CCU8_STATUS_FAILURE;
 8026376:	2001      	movs	r0, #1
 8026378:	4770      	bx	lr
 802637a:	bf00      	nop

0802637c <PWM_CCU8_SetFreqAndDutyCycleSymmetric>:
/**********************************************************************************************************/

/*Sets the frequency and duty cycle for CCU8_CC8 slice Symmetric Mode. */
PWM_CCU8_STATUS_t PWM_CCU8_SetFreqAndDutyCycleSymmetric(PWM_CCU8_t* handle_ptr, uint32_t pwm_freq_hz, uint32_t duty_ch1,
                                                        uint32_t duty_ch2)
{
 802637c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t compare_ch2;

  status = PWM_CCU8_STATUS_FAILURE;
  frequency_tclk = 0U;
  XMC_ASSERT("PWM_CCU8_SetFreqAndDutyCycleSymmetric:handle_ptr NULL", (handle_ptr != NULL));
  if (PWM_CCU8_STATE_UNINITIALIZED != handle_ptr->state)
 8026380:	7f04      	ldrb	r4, [r0, #28]
 8026382:	2c00      	cmp	r4, #0
 8026384:	d040      	beq.n	8026408 <PWM_CCU8_SetFreqAndDutyCycleSymmetric+0x8c>
  {
    if (0U == pwm_freq_hz)
 8026386:	2900      	cmp	r1, #0
 8026388:	d03e      	beq.n	8026408 <PWM_CCU8_SetFreqAndDutyCycleSymmetric+0x8c>
    {
      XMC_DEBUG("PWM_CCU8_SetFreqAndDutyCycleSymmetric:cannot set frequency 0Hz");
    }
    else if ((duty_ch1 > PWM_CCU8_SYM_DUTY_MAX) || (duty_ch2 > PWM_CCU8_SYM_DUTY_MAX))
 802638a:	f242 7410 	movw	r4, #10000	; 0x2710
 802638e:	42a2      	cmp	r2, r4
 8026390:	d83a      	bhi.n	8026408 <PWM_CCU8_SetFreqAndDutyCycleSymmetric+0x8c>
 8026392:	42a3      	cmp	r3, r4
 8026394:	d838      	bhi.n	8026408 <PWM_CCU8_SetFreqAndDutyCycleSymmetric+0x8c>
    else
    {
      frequency_tclk = handle_ptr->frequency_tclk;
      period = frequency_tclk / pwm_freq_hz;

      if ((uint32_t) XMC_CCU8_SLICE_TIMER_COUNT_MODE_CA == handle_ptr->config_ptr->ccu8_cc8_slice_timer_ptr->timer_mode)
 8026396:	6804      	ldr	r4, [r0, #0]
      XMC_DEBUG("PWM_CCU8_SetFreqAndDutyCycleSymmetric:duty > 100%");
    }
    else
    {
      frequency_tclk = handle_ptr->frequency_tclk;
      period = frequency_tclk / pwm_freq_hz;
 8026398:	6a07      	ldr	r7, [r0, #32]

      if ((uint32_t) XMC_CCU8_SLICE_TIMER_COUNT_MODE_CA == handle_ptr->config_ptr->ccu8_cc8_slice_timer_ptr->timer_mode)
 802639a:	6ca4      	ldr	r4, [r4, #72]	; 0x48
      XMC_DEBUG("PWM_CCU8_SetFreqAndDutyCycleSymmetric:duty > 100%");
    }
    else
    {
      frequency_tclk = handle_ptr->frequency_tclk;
      period = frequency_tclk / pwm_freq_hz;
 802639c:	fbb7 f7f1 	udiv	r7, r7, r1

      if ((uint32_t) XMC_CCU8_SLICE_TIMER_COUNT_MODE_CA == handle_ptr->config_ptr->ccu8_cc8_slice_timer_ptr->timer_mode)
 80263a0:	7821      	ldrb	r1, [r4, #0]
 80263a2:	07c9      	lsls	r1, r1, #31
      {
        period = period >> 1U;/*divide by 2*/
 80263a4:	bf48      	it	mi
 80263a6:	087f      	lsrmi	r7, r7, #1
      }

      if ((period != 0U) && (period <= PWM_CCU8_MAX_TIMER_COUNT))
 80263a8:	1e79      	subs	r1, r7, #1
 80263aa:	f64f 74fe 	movw	r4, #65534	; 0xfffe
 80263ae:	42a1      	cmp	r1, r4
 80263b0:	d82a      	bhi.n	8026408 <PWM_CCU8_SetFreqAndDutyCycleSymmetric+0x8c>
 80263b2:	4604      	mov	r4, r0
 80263b4:	4615      	mov	r5, r2
      {
        /*Calculate the current duty cycle in no-timer concatenation mode*/
        compare_ch1 = ((period * (PWM_CCU8_DUTY_FULL_SCALE - duty_ch1)) / PWM_CCU8_DUTY_FULL_SCALE);
        compare_ch2 = ((period * (PWM_CCU8_DUTY_FULL_SCALE - duty_ch2)) / PWM_CCU8_DUTY_FULL_SCALE);

        XMC_CCU8_SLICE_SetTimerPeriodMatch(handle_ptr->ccu8_slice_ptr, (uint16_t)(period - 1U));
 80263b6:	b289      	uxth	r1, r1
 80263b8:	6880      	ldr	r0, [r0, #8]
      }

      if ((period != 0U) && (period <= PWM_CCU8_MAX_TIMER_COUNT))
      {
        /*Calculate the current duty cycle in no-timer concatenation mode*/
        compare_ch1 = ((period * (PWM_CCU8_DUTY_FULL_SCALE - duty_ch1)) / PWM_CCU8_DUTY_FULL_SCALE);
 80263ba:	f8df 8054 	ldr.w	r8, [pc, #84]	; 8026410 <PWM_CCU8_SetFreqAndDutyCycleSymmetric+0x94>
 80263be:	461e      	mov	r6, r3
        compare_ch2 = ((period * (PWM_CCU8_DUTY_FULL_SCALE - duty_ch2)) / PWM_CCU8_DUTY_FULL_SCALE);

        XMC_CCU8_SLICE_SetTimerPeriodMatch(handle_ptr->ccu8_slice_ptr, (uint16_t)(period - 1U));
 80263c0:	f7fb fa8a 	bl	80218d8 <XMC_CCU8_SLICE_SetTimerPeriodMatch>
      }

      if ((period != 0U) && (period <= PWM_CCU8_MAX_TIMER_COUNT))
      {
        /*Calculate the current duty cycle in no-timer concatenation mode*/
        compare_ch1 = ((period * (PWM_CCU8_DUTY_FULL_SCALE - duty_ch1)) / PWM_CCU8_DUTY_FULL_SCALE);
 80263c4:	f5c5 531c 	rsb	r3, r5, #9984	; 0x2700
 80263c8:	3310      	adds	r3, #16
 80263ca:	fb03 f307 	mul.w	r3, r3, r7
 80263ce:	fba8 3203 	umull	r3, r2, r8, r3
        compare_ch2 = ((period * (PWM_CCU8_DUTY_FULL_SCALE - duty_ch2)) / PWM_CCU8_DUTY_FULL_SCALE);

        XMC_CCU8_SLICE_SetTimerPeriodMatch(handle_ptr->ccu8_slice_ptr, (uint16_t)(period - 1U));
        XMC_CCU8_SLICE_SetTimerCompareMatch(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_COMPARE_CHANNEL_1,
 80263d2:	68a0      	ldr	r0, [r4, #8]
 80263d4:	f3c2 324f 	ubfx	r2, r2, #13, #16
 80263d8:	2100      	movs	r1, #0
 80263da:	f7fb fa7f 	bl	80218dc <XMC_CCU8_SLICE_SetTimerCompareMatch>

      if ((period != 0U) && (period <= PWM_CCU8_MAX_TIMER_COUNT))
      {
        /*Calculate the current duty cycle in no-timer concatenation mode*/
        compare_ch1 = ((period * (PWM_CCU8_DUTY_FULL_SCALE - duty_ch1)) / PWM_CCU8_DUTY_FULL_SCALE);
        compare_ch2 = ((period * (PWM_CCU8_DUTY_FULL_SCALE - duty_ch2)) / PWM_CCU8_DUTY_FULL_SCALE);
 80263de:	f5c6 511c 	rsb	r1, r6, #9984	; 0x2700
 80263e2:	3110      	adds	r1, #16
 80263e4:	fb01 f107 	mul.w	r1, r1, r7
 80263e8:	fba8 3201 	umull	r3, r2, r8, r1

        XMC_CCU8_SLICE_SetTimerPeriodMatch(handle_ptr->ccu8_slice_ptr, (uint16_t)(period - 1U));
        XMC_CCU8_SLICE_SetTimerCompareMatch(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_COMPARE_CHANNEL_1,
                                            (uint16_t) compare_ch1);
        XMC_CCU8_SLICE_SetTimerCompareMatch(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_COMPARE_CHANNEL_2,
 80263ec:	68a0      	ldr	r0, [r4, #8]
 80263ee:	f3c2 324f 	ubfx	r2, r2, #13, #16
 80263f2:	2101      	movs	r1, #1
 80263f4:	f7fb fa72 	bl	80218dc <XMC_CCU8_SLICE_SetTimerCompareMatch>
                                            (uint16_t) compare_ch2);
        XMC_CCU8_EnableShadowTransfer(handle_ptr->ccu8_module_ptr, handle_ptr->shadow_txfr_msk);
 80263f8:	6863      	ldr	r3, [r4, #4]
 80263fa:	6922      	ldr	r2, [r4, #16]
 *  None.
 */
__STATIC_INLINE void XMC_CCU8_EnableShadowTransfer(XMC_CCU8_MODULE_t *const module, const uint32_t shadow_transfer_msk)
{
  XMC_ASSERT("XMC_CCU8_EnableShadowTransfer:Invalid module Pointer", XMC_CCU8_IsValidModule(module));
  module->GCSS = (uint32_t)shadow_transfer_msk;  
 80263fc:	611a      	str	r2, [r3, #16]

        handle_ptr->sym_duty1 = duty_ch1;
        handle_ptr->sym_duty2 = duty_ch2;

        XMC_DEBUG("PWM_CCU8_SetFreqAndDutyCycleSymmetric:frequency set");
        status = PWM_CCU8_STATUS_SUCCESS;
 80263fe:	2000      	movs	r0, #0
                                            (uint16_t) compare_ch1);
        XMC_CCU8_SLICE_SetTimerCompareMatch(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_COMPARE_CHANNEL_2,
                                            (uint16_t) compare_ch2);
        XMC_CCU8_EnableShadowTransfer(handle_ptr->ccu8_module_ptr, handle_ptr->shadow_txfr_msk);

        handle_ptr->sym_duty1 = duty_ch1;
 8026400:	6265      	str	r5, [r4, #36]	; 0x24
        handle_ptr->sym_duty2 = duty_ch2;
 8026402:	62a6      	str	r6, [r4, #40]	; 0x28
 8026404:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  uint32_t frequency_tclk;
  uint32_t period;
  uint32_t compare_ch1;
  uint32_t compare_ch2;

  status = PWM_CCU8_STATUS_FAILURE;
 8026408:	2001      	movs	r0, #1
      }
    }
  }
  return (status);

}/* end of PWM_CCU8_SetFreqAndDutyCycleSymmetric() api */
 802640a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802640e:	bf00      	nop
 8026410:	d1b71759 	.word	0xd1b71759

08026414 <PWM_CCU8_SetFreqAndDutyCycleAsymmetric>:
/**********************************************************************************************************/

/*Sets the frequency, (uint32_t)shift and (uint32_t)duty cycle for CCU8_CC8 slice Asymmetric Mode. */
PWM_CCU8_STATUS_t PWM_CCU8_SetFreqAndDutyCycleAsymmetric(PWM_CCU8_t* handle_ptr, uint32_t pwm_freq_hz, uint32_t shift,
                                                         uint32_t duty_cycle)
{
 8026414:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  uint32_t compare_ch2;

  status = PWM_CCU8_STATUS_FAILURE;
  frequency_tclk = 0U;
  XMC_ASSERT("PWM_CCU8_SetFreqAndDutyCycleAsymmetric:handle_ptr NULL", (handle_ptr != NULL));
  if (PWM_CCU8_STATE_UNINITIALIZED != handle_ptr->state)
 8026418:	7f04      	ldrb	r4, [r0, #28]
 802641a:	b304      	cbz	r4, 802645e <PWM_CCU8_SetFreqAndDutyCycleAsymmetric+0x4a>
  {
    if (0U == pwm_freq_hz)
 802641c:	b1f9      	cbz	r1, 802645e <PWM_CCU8_SetFreqAndDutyCycleAsymmetric+0x4a>
 802641e:	461f      	mov	r7, r3
    else
    {
      frequency_tclk = handle_ptr->frequency_tclk;
      period = frequency_tclk / pwm_freq_hz;

      if ((uint32_t) XMC_CCU8_SLICE_TIMER_COUNT_MODE_CA == handle_ptr->config_ptr->ccu8_cc8_slice_timer_ptr->timer_mode)
 8026420:	6803      	ldr	r3, [r0, #0]
 8026422:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8026424:	4616      	mov	r6, r2
 8026426:	4604      	mov	r4, r0
      XMC_DEBUG("PWM_CCU8_SetFreqAndDutyCycleAsymmetric:cannot set frequency 0Hz");
    }
    else
    {
      frequency_tclk = handle_ptr->frequency_tclk;
      period = frequency_tclk / pwm_freq_hz;
 8026428:	6a02      	ldr	r2, [r0, #32]

      if ((uint32_t) XMC_CCU8_SLICE_TIMER_COUNT_MODE_CA == handle_ptr->config_ptr->ccu8_cc8_slice_timer_ptr->timer_mode)
 802642a:	7818      	ldrb	r0, [r3, #0]
      XMC_DEBUG("PWM_CCU8_SetFreqAndDutyCycleAsymmetric:cannot set frequency 0Hz");
    }
    else
    {
      frequency_tclk = handle_ptr->frequency_tclk;
      period = frequency_tclk / pwm_freq_hz;
 802642c:	fbb2 f8f1 	udiv	r8, r2, r1

      if ((uint32_t) XMC_CCU8_SLICE_TIMER_COUNT_MODE_CA == handle_ptr->config_ptr->ccu8_cc8_slice_timer_ptr->timer_mode)
 8026430:	f010 0501 	ands.w	r5, r0, #1
 8026434:	d016      	beq.n	8026464 <PWM_CCU8_SetFreqAndDutyCycleAsymmetric+0x50>
      {
        if (((shift + duty_cycle) > PWM_CCU8_ASYM_CA_MAX) || ((shift + duty_cycle) < PWM_CCU8_ASYM_CA_MIN))
 8026436:	19f5      	adds	r5, r6, r7
 8026438:	f5a5 539c 	sub.w	r3, r5, #4992	; 0x1380
 802643c:	3b08      	subs	r3, #8
 802643e:	f241 3288 	movw	r2, #5000	; 0x1388
 8026442:	4293      	cmp	r3, r2
 8026444:	d80b      	bhi.n	802645e <PWM_CCU8_SetFreqAndDutyCycleAsymmetric+0x4a>
        {
          XMC_DEBUG("PWM_CCU8_SetDutyCycleAsymmetric:Cannot set center aligned mode 50% < (shift + duty_cycle) < 100%");
        }
        else if (shift >= PWM_CCU8_ASYM_CA_SHIFT_MAX)
 8026446:	f241 3387 	movw	r3, #4999	; 0x1387
 802644a:	429e      	cmp	r6, r3
 802644c:	d807      	bhi.n	802645e <PWM_CCU8_SetFreqAndDutyCycleAsymmetric+0x4a>
        {
          XMC_DEBUG("PWM_CCU8_SetDutyCycleAsymmetric:Cannot set center aligned mode shift > 50%");
        }
        else
        {
          period = period >> 1U;/*divide by 2*/
 802644e:	ea4f 0858 	mov.w	r8, r8, lsr #1

          if ((period != 0U) && (period <= PWM_CCU8_MAX_TIMER_COUNT))
 8026452:	f108 31ff 	add.w	r1, r8, #4294967295
 8026456:	f64f 73fe 	movw	r3, #65534	; 0xfffe
 802645a:	4299      	cmp	r1, r3
 802645c:	d92f      	bls.n	80264be <PWM_CCU8_SetFreqAndDutyCycleAsymmetric+0xaa>
  uint32_t frequency_tclk;
  uint32_t period;
  uint32_t compare_ch1;
  uint32_t compare_ch2;

  status = PWM_CCU8_STATUS_FAILURE;
 802645e:	2001      	movs	r0, #1
        }
      }
    }
  }
  return (status);
}/* end of PWM_CCU8_SetFreqAndDutyCycleAsymmetric() api */
 8026460:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
          }
        }
      }
      else
      {
        if (period <= PWM_CCU8_MAX_TIMER_COUNT)
 8026464:	f5b8 3f80 	cmp.w	r8, #65536	; 0x10000
 8026468:	d2f9      	bcs.n	802645e <PWM_CCU8_SetFreqAndDutyCycleAsymmetric+0x4a>
        {
          if (((shift + duty_cycle) > PWM_CCU8_ASYM_EA_MAX))
 802646a:	eb06 0907 	add.w	r9, r6, r7
 802646e:	f242 7310 	movw	r3, #10000	; 0x2710
 8026472:	4599      	cmp	r9, r3
 8026474:	d8f3      	bhi.n	802645e <PWM_CCU8_SetFreqAndDutyCycleAsymmetric+0x4a>
          else
          {
            compare_ch1 = ((period * shift) / PWM_CCU8_DUTY_FULL_SCALE);
            compare_ch2 = ((period * (shift + duty_cycle)) / PWM_CCU8_DUTY_FULL_SCALE);

            XMC_CCU8_SLICE_SetTimerPeriodMatch(handle_ptr->ccu8_slice_ptr, (uint16_t)(period - 1U));
 8026476:	f108 31ff 	add.w	r1, r8, #4294967295
 802647a:	b289      	uxth	r1, r1
 802647c:	68a0      	ldr	r0, [r4, #8]
          {
            XMC_DEBUG("PWM_CCU8_SetDutyCycleAsymmetric:Cannot set edge aligned mode (shift + duty_cycle) > 100%");
          }
          else
          {
            compare_ch1 = ((period * shift) / PWM_CCU8_DUTY_FULL_SCALE);
 802647e:	f8df a074 	ldr.w	sl, [pc, #116]	; 80264f4 <PWM_CCU8_SetFreqAndDutyCycleAsymmetric+0xe0>
            compare_ch2 = ((period * (shift + duty_cycle)) / PWM_CCU8_DUTY_FULL_SCALE);

            XMC_CCU8_SLICE_SetTimerPeriodMatch(handle_ptr->ccu8_slice_ptr, (uint16_t)(period - 1U));
 8026482:	f7fb fa29 	bl	80218d8 <XMC_CCU8_SLICE_SetTimerPeriodMatch>
          {
            XMC_DEBUG("PWM_CCU8_SetDutyCycleAsymmetric:Cannot set edge aligned mode (shift + duty_cycle) > 100%");
          }
          else
          {
            compare_ch1 = ((period * shift) / PWM_CCU8_DUTY_FULL_SCALE);
 8026486:	fb06 f208 	mul.w	r2, r6, r8
 802648a:	fbaa 3202 	umull	r3, r2, sl, r2
            compare_ch2 = ((period * (shift + duty_cycle)) / PWM_CCU8_DUTY_FULL_SCALE);

            XMC_CCU8_SLICE_SetTimerPeriodMatch(handle_ptr->ccu8_slice_ptr, (uint16_t)(period - 1U));
            XMC_CCU8_SLICE_SetTimerCompareMatch(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_COMPARE_CHANNEL_1,
 802648e:	f3c2 324f 	ubfx	r2, r2, #13, #16
 8026492:	4629      	mov	r1, r5
 8026494:	68a0      	ldr	r0, [r4, #8]
 8026496:	f7fb fa21 	bl	80218dc <XMC_CCU8_SLICE_SetTimerCompareMatch>
            XMC_DEBUG("PWM_CCU8_SetDutyCycleAsymmetric:Cannot set edge aligned mode (shift + duty_cycle) > 100%");
          }
          else
          {
            compare_ch1 = ((period * shift) / PWM_CCU8_DUTY_FULL_SCALE);
            compare_ch2 = ((period * (shift + duty_cycle)) / PWM_CCU8_DUTY_FULL_SCALE);
 802649a:	fb09 f108 	mul.w	r1, r9, r8
 802649e:	fbaa 3201 	umull	r3, r2, sl, r1
                ((2U * period * (PWM_CCU8_DUTY_FULL_SCALE - (shift + duty_cycle))) / PWM_CCU8_DUTY_FULL_SCALE);

            XMC_CCU8_SLICE_SetTimerPeriodMatch(handle_ptr->ccu8_slice_ptr, (uint16_t)(period - 1U));
            XMC_CCU8_SLICE_SetTimerCompareMatch(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_COMPARE_CHANNEL_1,
                                                (uint16_t) compare_ch1);
            XMC_CCU8_SLICE_SetTimerCompareMatch(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_COMPARE_CHANNEL_2,
 80264a2:	68a0      	ldr	r0, [r4, #8]
 80264a4:	f3c2 324f 	ubfx	r2, r2, #13, #16
 80264a8:	2101      	movs	r1, #1
 80264aa:	f7fb fa17 	bl	80218dc <XMC_CCU8_SLICE_SetTimerCompareMatch>
                                                (uint16_t) compare_ch2);
            XMC_CCU8_EnableShadowTransfer(handle_ptr->ccu8_module_ptr, handle_ptr->shadow_txfr_msk);
 80264ae:	6863      	ldr	r3, [r4, #4]
 80264b0:	6922      	ldr	r2, [r4, #16]
 80264b2:	611a      	str	r2, [r3, #16]

            handle_ptr->asym_duty = duty_cycle;
            handle_ptr->asym_shift = shift;

            XMC_DEBUG("PWM_CCU8_SetFreqAndDutyCycleAsymmetric:frequency and duty set center aligned mode");
            status = PWM_CCU8_STATUS_SUCCESS;
 80264b4:	2000      	movs	r0, #0
                                                (uint16_t) compare_ch1);
            XMC_CCU8_SLICE_SetTimerCompareMatch(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_COMPARE_CHANNEL_2,
                                                (uint16_t) compare_ch2);
            XMC_CCU8_EnableShadowTransfer(handle_ptr->ccu8_module_ptr, handle_ptr->shadow_txfr_msk);

            handle_ptr->asym_duty = duty_cycle;
 80264b6:	62e7      	str	r7, [r4, #44]	; 0x2c
            handle_ptr->asym_shift = shift;
 80264b8:	6326      	str	r6, [r4, #48]	; 0x30
 80264ba:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
          {
            compare_ch1 = ((2U * period * shift) / PWM_CCU8_DUTY_FULL_SCALE);
            compare_ch2 =
                ((2U * period * (PWM_CCU8_DUTY_FULL_SCALE - (shift + duty_cycle))) / PWM_CCU8_DUTY_FULL_SCALE);

            XMC_CCU8_SLICE_SetTimerPeriodMatch(handle_ptr->ccu8_slice_ptr, (uint16_t)(period - 1U));
 80264be:	b289      	uxth	r1, r1
 80264c0:	68a0      	ldr	r0, [r4, #8]
        {
          period = period >> 1U;/*divide by 2*/

          if ((period != 0U) && (period <= PWM_CCU8_MAX_TIMER_COUNT))
          {
            compare_ch1 = ((2U * period * shift) / PWM_CCU8_DUTY_FULL_SCALE);
 80264c2:	f8df 9030 	ldr.w	r9, [pc, #48]	; 80264f4 <PWM_CCU8_SetFreqAndDutyCycleAsymmetric+0xe0>
            compare_ch2 =
                ((2U * period * (PWM_CCU8_DUTY_FULL_SCALE - (shift + duty_cycle))) / PWM_CCU8_DUTY_FULL_SCALE);

            XMC_CCU8_SLICE_SetTimerPeriodMatch(handle_ptr->ccu8_slice_ptr, (uint16_t)(period - 1U));
 80264c6:	f7fb fa07 	bl	80218d8 <XMC_CCU8_SLICE_SetTimerPeriodMatch>
 80264ca:	0072      	lsls	r2, r6, #1
        {
          period = period >> 1U;/*divide by 2*/

          if ((period != 0U) && (period <= PWM_CCU8_MAX_TIMER_COUNT))
          {
            compare_ch1 = ((2U * period * shift) / PWM_CCU8_DUTY_FULL_SCALE);
 80264cc:	fb08 f202 	mul.w	r2, r8, r2
 80264d0:	fba9 3202 	umull	r3, r2, r9, r2
            compare_ch2 =
                ((2U * period * (PWM_CCU8_DUTY_FULL_SCALE - (shift + duty_cycle))) / PWM_CCU8_DUTY_FULL_SCALE);
 80264d4:	f5c5 551c 	rsb	r5, r5, #9984	; 0x2700

            XMC_CCU8_SLICE_SetTimerPeriodMatch(handle_ptr->ccu8_slice_ptr, (uint16_t)(period - 1U));
            XMC_CCU8_SLICE_SetTimerCompareMatch(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_COMPARE_CHANNEL_1,
 80264d8:	f3c2 324f 	ubfx	r2, r2, #13, #16
 80264dc:	68a0      	ldr	r0, [r4, #8]
 80264de:	2100      	movs	r1, #0

          if ((period != 0U) && (period <= PWM_CCU8_MAX_TIMER_COUNT))
          {
            compare_ch1 = ((2U * period * shift) / PWM_CCU8_DUTY_FULL_SCALE);
            compare_ch2 =
                ((2U * period * (PWM_CCU8_DUTY_FULL_SCALE - (shift + duty_cycle))) / PWM_CCU8_DUTY_FULL_SCALE);
 80264e0:	3510      	adds	r5, #16

            XMC_CCU8_SLICE_SetTimerPeriodMatch(handle_ptr->ccu8_slice_ptr, (uint16_t)(period - 1U));
            XMC_CCU8_SLICE_SetTimerCompareMatch(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_COMPARE_CHANNEL_1,
 80264e2:	f7fb f9fb 	bl	80218dc <XMC_CCU8_SLICE_SetTimerCompareMatch>

          if ((period != 0U) && (period <= PWM_CCU8_MAX_TIMER_COUNT))
          {
            compare_ch1 = ((2U * period * shift) / PWM_CCU8_DUTY_FULL_SCALE);
            compare_ch2 =
                ((2U * period * (PWM_CCU8_DUTY_FULL_SCALE - (shift + duty_cycle))) / PWM_CCU8_DUTY_FULL_SCALE);
 80264e6:	fb05 f208 	mul.w	r2, r5, r8
 80264ea:	0052      	lsls	r2, r2, #1
          period = period >> 1U;/*divide by 2*/

          if ((period != 0U) && (period <= PWM_CCU8_MAX_TIMER_COUNT))
          {
            compare_ch1 = ((2U * period * shift) / PWM_CCU8_DUTY_FULL_SCALE);
            compare_ch2 =
 80264ec:	fba9 3202 	umull	r3, r2, r9, r2
 80264f0:	e7d7      	b.n	80264a2 <PWM_CCU8_SetFreqAndDutyCycleAsymmetric+0x8e>
 80264f2:	bf00      	nop
 80264f4:	d1b71759 	.word	0xd1b71759

080264f8 <INTERRUPT_Init>:
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 80264f8:	4b20      	ldr	r3, [pc, #128]	; (802657c <INTERRUPT_Init+0x84>)

/*
 * API to initialize the INTERRUPT APP
 */
INTERRUPT_STATUS_t INTERRUPT_Init(const INTERRUPT_t *const handler)
{
 80264fa:	b4f0      	push	{r4, r5, r6, r7}
 80264fc:	68db      	ldr	r3, [r3, #12]
  XMC_ASSERT("INTERRUPT_Init:HandlePtr NULL", (handler != NULL));
  
#if(UC_FAMILY == XMC4)

  NVIC_SetPriority(handler->node,
 80264fe:	7804      	ldrb	r4, [r0, #0]
 8026500:	7841      	ldrb	r1, [r0, #1]
                   NVIC_EncodePriority(NVIC_GetPriorityGrouping(),
                                       handler->priority,
                                       handler->subpriority));
 8026502:	7887      	ldrb	r7, [r0, #2]
 8026504:	f3c3 2302 	ubfx	r3, r3, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8026508:	f1c3 0507 	rsb	r5, r3, #7
 802650c:	2d06      	cmp	r5, #6
 802650e:	bf28      	it	cs
 8026510:	2506      	movcs	r5, #6
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8026512:	b34b      	cbz	r3, 8026568 <INTERRUPT_Init+0x70>
 8026514:	1e5e      	subs	r6, r3, #1
 8026516:	2201      	movs	r2, #1
 8026518:	40b2      	lsls	r2, r6
 802651a:	3a01      	subs	r2, #1
 802651c:	ea02 0307 	and.w	r3, r2, r7

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8026520:	2201      	movs	r2, #1
 8026522:	40aa      	lsls	r2, r5
 8026524:	3a01      	subs	r2, #1
 8026526:	400a      	ands	r2, r1
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
 8026528:	b261      	sxtb	r1, r4

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 802652a:	40b2      	lsls	r2, r6
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
 802652c:	2900      	cmp	r1, #0
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
 802652e:	ea43 0302 	orr.w	r3, r3, r2
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
 8026532:	db1b      	blt.n	802656c <INTERRUPT_Init+0x74>
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8026534:	f101 4260 	add.w	r2, r1, #3758096384	; 0xe0000000
 8026538:	f502 4261 	add.w	r2, r2, #57600	; 0xe100
 802653c:	009b      	lsls	r3, r3, #2
 802653e:	b2db      	uxtb	r3, r3
 8026540:	f882 3300 	strb.w	r3, [r2, #768]	; 0x300
  if (handler->enable_at_init == true)
 8026544:	78c3      	ldrb	r3, [r0, #3]
 8026546:	b163      	cbz	r3, 8026562 <INTERRUPT_Init+0x6a>
 8026548:	7802      	ldrb	r2, [r0, #0]
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
 802654a:	b253      	sxtb	r3, r2
 802654c:	2b00      	cmp	r3, #0
 802654e:	db08      	blt.n	8026562 <INTERRUPT_Init+0x6a>
  {
    NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8026550:	f002 021f 	and.w	r2, r2, #31
 8026554:	095b      	lsrs	r3, r3, #5
 8026556:	2101      	movs	r1, #1
 8026558:	4809      	ldr	r0, [pc, #36]	; (8026580 <INTERRUPT_Init+0x88>)
 802655a:	fa01 f202 	lsl.w	r2, r1, r2
 802655e:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
    INTERRUPT_Enable(handler);
  }
#endif

  return (INTERRUPT_STATUS_SUCCESS);
}
 8026562:	2000      	movs	r0, #0
 8026564:	bcf0      	pop	{r4, r5, r6, r7}
 8026566:	4770      	bx	lr
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8026568:	461e      	mov	r6, r3
 802656a:	e7d9      	b.n	8026520 <INTERRUPT_Init+0x28>
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
  else
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 802656c:	4a05      	ldr	r2, [pc, #20]	; (8026584 <INTERRUPT_Init+0x8c>)
 802656e:	f004 040f 	and.w	r4, r4, #15
 8026572:	009b      	lsls	r3, r3, #2
 8026574:	4422      	add	r2, r4
 8026576:	b2db      	uxtb	r3, r3
 8026578:	7613      	strb	r3, [r2, #24]
 802657a:	e7e3      	b.n	8026544 <INTERRUPT_Init+0x4c>
 802657c:	e000ed00 	.word	0xe000ed00
 8026580:	e000e100 	.word	0xe000e100
 8026584:	e000ecfc 	.word	0xe000ecfc

08026588 <GLOBAL_DMA_Init>:
  return version;
}

/* GLOBAL_DMA initialization function */
GLOBAL_DMA_STATUS_t GLOBAL_DMA_Init(GLOBAL_DMA_t *const obj)
{
 8026588:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  XMC_ASSERT("DMA_GLOBAL_Init: NULL DMA_GLOBAL_t object", (obj != NULL));

  if (obj->initialized == false)
 802658a:	7a03      	ldrb	r3, [r0, #8]
 802658c:	b10b      	cbz	r3, 8026592 <GLOBAL_DMA_Init+0xa>
    NVIC_EnableIRQ(obj->irq_node);
    obj->initialized = true;
  }

  return GLOBAL_DMA_STATUS_SUCCESS;
}
 802658e:	2000      	movs	r0, #0
 8026590:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8026592:	4604      	mov	r4, r0
  XMC_ASSERT("DMA_GLOBAL_Init: NULL DMA_GLOBAL_t object", (obj != NULL));

  if (obj->initialized == false)
  {
    /* Enable DMA module */
    XMC_DMA_Init(obj->dma);
 8026594:	6800      	ldr	r0, [r0, #0]
 8026596:	f7fb f9cb 	bl	8021930 <XMC_DMA_Init>
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 802659a:	4a20      	ldr	r2, [pc, #128]	; (802661c <GLOBAL_DMA_Init+0x94>)

    /* Enable DMA event handling */
    NVIC_SetPriority(obj->irq_node, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),
                                                        obj->config->priority,
 802659c:	6863      	ldr	r3, [r4, #4]
 802659e:	68d2      	ldr	r2, [r2, #12]
  {
    /* Enable DMA module */
    XMC_DMA_Init(obj->dma);

    /* Enable DMA event handling */
    NVIC_SetPriority(obj->irq_node, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),
 80265a0:	7819      	ldrb	r1, [r3, #0]
                                                        obj->config->priority,
                                                        obj->config->sub_priority));
 80265a2:	785f      	ldrb	r7, [r3, #1]
  {
    /* Enable DMA module */
    XMC_DMA_Init(obj->dma);

    /* Enable DMA event handling */
    NVIC_SetPriority(obj->irq_node, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),
 80265a4:	7a60      	ldrb	r0, [r4, #9]
 80265a6:	f3c2 2302 	ubfx	r3, r2, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 80265aa:	f1c3 0507 	rsb	r5, r3, #7
 80265ae:	2d06      	cmp	r5, #6
 80265b0:	bf28      	it	cs
 80265b2:	2506      	movcs	r5, #6
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80265b4:	bb1b      	cbnz	r3, 80265fe <GLOBAL_DMA_Init+0x76>
 80265b6:	461e      	mov	r6, r3

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 80265b8:	2201      	movs	r2, #1
 80265ba:	40aa      	lsls	r2, r5
 80265bc:	3a01      	subs	r2, #1
 80265be:	400a      	ands	r2, r1
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
 80265c0:	b241      	sxtb	r1, r0

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 80265c2:	40b2      	lsls	r2, r6
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
 80265c4:	2900      	cmp	r1, #0
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
 80265c6:	ea43 0302 	orr.w	r3, r3, r2
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
 80265ca:	db1f      	blt.n	802660c <GLOBAL_DMA_Init+0x84>
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80265cc:	f101 4260 	add.w	r2, r1, #3758096384	; 0xe0000000
 80265d0:	f502 4261 	add.w	r2, r2, #57600	; 0xe100
 80265d4:	009b      	lsls	r3, r3, #2
 80265d6:	b2db      	uxtb	r3, r3
 80265d8:	f882 3300 	strb.w	r3, [r2, #768]	; 0x300
                                                        obj->config->priority,
                                                        obj->config->sub_priority));
    NVIC_EnableIRQ(obj->irq_node);
 80265dc:	7a62      	ldrb	r2, [r4, #9]
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
 80265de:	b253      	sxtb	r3, r2
 80265e0:	2b00      	cmp	r3, #0
 80265e2:	db08      	blt.n	80265f6 <GLOBAL_DMA_Init+0x6e>
  {
    NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 80265e4:	f002 021f 	and.w	r2, r2, #31
 80265e8:	095b      	lsrs	r3, r3, #5
 80265ea:	2101      	movs	r1, #1
 80265ec:	480c      	ldr	r0, [pc, #48]	; (8026620 <GLOBAL_DMA_Init+0x98>)
 80265ee:	fa01 f202 	lsl.w	r2, r1, r2
 80265f2:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
    obj->initialized = true;
 80265f6:	2301      	movs	r3, #1
 80265f8:	7223      	strb	r3, [r4, #8]
  }

  return GLOBAL_DMA_STATUS_SUCCESS;
}
 80265fa:	2000      	movs	r0, #0
 80265fc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80265fe:	1e5e      	subs	r6, r3, #1
 8026600:	2201      	movs	r2, #1
 8026602:	40b2      	lsls	r2, r6
 8026604:	3a01      	subs	r2, #1
 8026606:	ea02 0307 	and.w	r3, r2, r7
 802660a:	e7d5      	b.n	80265b8 <GLOBAL_DMA_Init+0x30>
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
  else
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 802660c:	4a05      	ldr	r2, [pc, #20]	; (8026624 <GLOBAL_DMA_Init+0x9c>)
 802660e:	f000 000f 	and.w	r0, r0, #15
 8026612:	009b      	lsls	r3, r3, #2
 8026614:	4402      	add	r2, r0
 8026616:	b2db      	uxtb	r3, r3
 8026618:	7613      	strb	r3, [r2, #24]
 802661a:	e7df      	b.n	80265dc <GLOBAL_DMA_Init+0x54>
 802661c:	e000ed00 	.word	0xe000ed00
 8026620:	e000e100 	.word	0xe000e100
 8026624:	e000ecfc 	.word	0xe000ecfc

08026628 <GPDMA0_0_IRQHandler>:
  .irq_node = (IRQn_Type)110U /* Allotted DMA IRQ node */
};

void GPDMA0_0_IRQHandler(void)
{
  XMC_DMA_IRQHandler(XMC_DMA0);
 8026628:	4801      	ldr	r0, [pc, #4]	; (8026630 <GPDMA0_0_IRQHandler+0x8>)
 802662a:	f7fb bb3b 	b.w	8021ca4 <XMC_DMA_IRQHandler>
 802662e:	bf00      	nop
 8026630:	50014000 	.word	0x50014000

08026634 <GPDMA1_0_IRQHandler>:
}

#ifdef XMC_DMA1
void GPDMA1_0_IRQHandler(void)
{
  XMC_DMA_IRQHandler(XMC_DMA1);
 8026634:	4801      	ldr	r0, [pc, #4]	; (802663c <GPDMA1_0_IRQHandler+0x8>)
 8026636:	f7fb bb35 	b.w	8021ca4 <XMC_DMA_IRQHandler>
 802663a:	bf00      	nop
 802663c:	50018000 	.word	0x50018000

08026640 <GLOBAL_CCU8_Init>:
/* Initializes the slice with the generated configuration */
GLOBAL_CCU8_STATUS_t GLOBAL_CCU8_Init(GLOBAL_CCU8_t* handle)
{
  XMC_ASSERT("GLOBAL_CCU8_Init:NULL handler", (NULL != handle));

  if (false == handle->is_initialized)
 8026640:	7b43      	ldrb	r3, [r0, #13]
 8026642:	b10b      	cbz	r3, 8026648 <GLOBAL_CCU8_Init+0x8>
    /* Restricts multiple initializations */
    handle->is_initialized = true;
  }

  return (GLOBAL_CCU8_STATUS_SUCCESS);
}
 8026644:	2000      	movs	r0, #0
 8026646:	4770      	bx	lr
  return version;
}

/* Initializes the slice with the generated configuration */
GLOBAL_CCU8_STATUS_t GLOBAL_CCU8_Init(GLOBAL_CCU8_t* handle)
{
 8026648:	b510      	push	{r4, lr}
 802664a:	4604      	mov	r4, r0
  XMC_ASSERT("GLOBAL_CCU8_Init:NULL handler", (NULL != handle));

  if (false == handle->is_initialized)
  {
    /* Enable CCU8 module */
    XMC_CCU8_Init(handle->module_ptr,handle->mcs_action);
 802664c:	6880      	ldr	r0, [r0, #8]
 802664e:	7b21      	ldrb	r1, [r4, #12]
 8026650:	f7fb f80a 	bl	8021668 <XMC_CCU8_Init>
    /* Start the prescaler */
    XMC_CCU8_StartPrescaler(handle->module_ptr);
 8026654:	68a2      	ldr	r2, [r4, #8]
 *  XMC_CCU8_StopPrescaler().
 */
__STATIC_INLINE void XMC_CCU8_StartPrescaler(XMC_CCU8_MODULE_t *const module)
{
  XMC_ASSERT("XMC_CCU8_StartPrescaler:Invalid Module Pointer", XMC_CCU8_IsValidModule(module));
  module->GIDLC |= (uint32_t) CCU8_GIDLC_SPRB_Msk;
 8026656:	68d3      	ldr	r3, [r2, #12]
    /* Restricts multiple initializations */
    handle->is_initialized = true;
 8026658:	2101      	movs	r1, #1
 802665a:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 802665e:	60d3      	str	r3, [r2, #12]
  }

  return (GLOBAL_CCU8_STATUS_SUCCESS);
}
 8026660:	2000      	movs	r0, #0
    /* Enable CCU8 module */
    XMC_CCU8_Init(handle->module_ptr,handle->mcs_action);
    /* Start the prescaler */
    XMC_CCU8_StartPrescaler(handle->module_ptr);
    /* Restricts multiple initializations */
    handle->is_initialized = true;
 8026662:	7361      	strb	r1, [r4, #13]
  }

  return (GLOBAL_CCU8_STATUS_SUCCESS);
}
 8026664:	bd10      	pop	{r4, pc}
 8026666:	bf00      	nop

08026668 <GLOBAL_CCU4_Init>:
/* Initializes the slice with the generated configuration */
GLOBAL_CCU4_STATUS_t GLOBAL_CCU4_Init(GLOBAL_CCU4_t* handle)
{
  XMC_ASSERT("GLOBAL_CCU4_Init:NULL handler", (NULL != handle));

  if (false == handle->is_initialized)
 8026668:	7b43      	ldrb	r3, [r0, #13]
 802666a:	b10b      	cbz	r3, 8026670 <GLOBAL_CCU4_Init+0x8>
    /* Restricts multiple initializations */
    handle->is_initialized = true;
  }

  return (GLOBAL_CCU4_STATUS_SUCCESS);
}
 802666c:	2000      	movs	r0, #0
 802666e:	4770      	bx	lr
  return version;
}

/* Initializes the slice with the generated configuration */
GLOBAL_CCU4_STATUS_t GLOBAL_CCU4_Init(GLOBAL_CCU4_t* handle)
{
 8026670:	b510      	push	{r4, lr}
 8026672:	4604      	mov	r4, r0
  XMC_ASSERT("GLOBAL_CCU4_Init:NULL handler", (NULL != handle));

  if (false == handle->is_initialized)
  {
    /* Enable CCU4 module */
    XMC_CCU4_Init(handle->module_ptr,handle->mcs_action);
 8026674:	6880      	ldr	r0, [r0, #8]
 8026676:	7b21      	ldrb	r1, [r4, #12]
 8026678:	f7fa ff74 	bl	8021564 <XMC_CCU4_Init>
    /* Start the prescaler */
    XMC_CCU4_StartPrescaler(handle->module_ptr);
 802667c:	68a2      	ldr	r2, [r4, #8]
 * XMC_CCU4_StopPrescaler().
 */
__STATIC_INLINE void XMC_CCU4_StartPrescaler(XMC_CCU4_MODULE_t *const module)
{
  XMC_ASSERT("XMC_CCU4_StartPrescaler:Invalid Module Pointer", XMC_CCU4_IsValidModule(module));
  module->GIDLC |= (uint32_t) CCU4_GIDLC_SPRB_Msk;
 802667e:	68d3      	ldr	r3, [r2, #12]
    /* Restricts multiple initializations */
    handle->is_initialized = true;
 8026680:	2101      	movs	r1, #1
 8026682:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8026686:	60d3      	str	r3, [r2, #12]
  }

  return (GLOBAL_CCU4_STATUS_SUCCESS);
}
 8026688:	2000      	movs	r0, #0
    /* Enable CCU4 module */
    XMC_CCU4_Init(handle->module_ptr,handle->mcs_action);
    /* Start the prescaler */
    XMC_CCU4_StartPrescaler(handle->module_ptr);
    /* Restricts multiple initializations */
    handle->is_initialized = true;
 802668a:	7361      	strb	r1, [r4, #13]
  }

  return (GLOBAL_CCU4_STATUS_SUCCESS);
}
 802668c:	bd10      	pop	{r4, pc}
 802668e:	bf00      	nop

08026690 <GLOBAL_ADC_Init>:
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/**
 * This function initializes all instances of the ADC Global APP and low level app.
 */
GLOBAL_ADC_STATUS_t GLOBAL_ADC_Init(GLOBAL_ADC_t *const handle_ptr)
{
 8026690:	4603      	mov	r3, r0
  XMC_ASSERT("GLOBAL_ADC_Init:Invalid handle_ptr", (handle_ptr != NULL))
#if (XMC_VADC_GROUP_AVAILABLE == 1U)
  uint32_t group_index;
#endif

  if (GLOBAL_ADC_UNINITIALIZED == handle_ptr->init_state)
 8026692:	7e00      	ldrb	r0, [r0, #24]
 8026694:	2802      	cmp	r0, #2
 8026696:	d000      	beq.n	802669a <GLOBAL_ADC_Init+0xa>
    	XMC_VADC_GLOBAL_StartupCalibration(handle_ptr->module_ptr);
    }
    handle_ptr->init_state = GLOBAL_ADC_SUCCESS;
  }
  return (handle_ptr->init_state);
}
 8026698:	4770      	bx	lr
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/**
 * This function initializes all instances of the ADC Global APP and low level app.
 */
GLOBAL_ADC_STATUS_t GLOBAL_ADC_Init(GLOBAL_ADC_t *const handle_ptr)
{
 802669a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
#endif

  if (GLOBAL_ADC_UNINITIALIZED == handle_ptr->init_state)
  {  
    /* Initialize an instance of Global hardware */
    XMC_VADC_GLOBAL_Init(handle_ptr->module_ptr, handle_ptr->global_config_handle);
 802669e:	6958      	ldr	r0, [r3, #20]
 80266a0:	6919      	ldr	r1, [r3, #16]
 80266a2:	461e      	mov	r6, r3
 80266a4:	f7fc feaa 	bl	80233fc <XMC_VADC_GLOBAL_Init>
 80266a8:	4634      	mov	r4, r6
 80266aa:	2510      	movs	r5, #16

__STATIC_INLINE void XMC_VADC_GLOBAL_DisablePostCalibration(XMC_VADC_GLOBAL_t *const global_ptr, uint32_t group_number)
{
  XMC_ASSERT("XMC_VADC_GLOBAL_DisablePostCalibration:Wrong Module Pointer", (global_ptr == VADC))

  global_ptr->GLOBCFG |= (uint32_t)((uint32_t)1 << ((uint32_t)VADC_GLOBCFG_DPCAL0_Pos + group_number));
 80266ac:	f04f 0801 	mov.w	r8, #1

#if(XMC_VADC_SHS_AVAILABLE == 1U)
      XMC_VADC_GLOBAL_SHS_EnableAcceleratedMode(handle_ptr->global_shs_ptr, (XMC_VADC_GROUP_INDEX_t)group_index);
#endif

      handle_ptr->group_ptrs_array[group_index]->state = GLOBAL_ADC_SUCCESS;
 80266b0:	2700      	movs	r7, #0
    /* Initialize all the Groups */
#if (XMC_VADC_GROUP_AVAILABLE == 1U)
    for(group_index = (uint32_t)0; group_index < XMC_VADC_MAXIMUM_NUM_GROUPS; group_index++)
    {
      /*Initialize Group*/
      XMC_VADC_GROUP_Init(handle_ptr->group_ptrs_array[group_index]->group_handle,
 80266b2:	6823      	ldr	r3, [r4, #0]
 80266b4:	e893 0003 	ldmia.w	r3, {r0, r1}
 80266b8:	f7fc feec 	bl	8023494 <XMC_VADC_GROUP_Init>
    		            handle_ptr->group_ptrs_array[group_index]->group_config_handle);

      /* Switch on the converter of the Group[group_index]*/
      XMC_VADC_GROUP_SetPowerMode(handle_ptr->group_ptrs_array[group_index]->group_handle,
 80266bc:	6823      	ldr	r3, [r4, #0]
 80266be:	2103      	movs	r1, #3
 80266c0:	6818      	ldr	r0, [r3, #0]
 80266c2:	f7fc ff85 	bl	80235d0 <XMC_VADC_GROUP_SetPowerMode>
                                  XMC_VADC_GROUP_POWERMODE_NORMAL);

      /* Disable the post calibration option for the respective group*/
      if ((bool)false == handle_ptr->group_ptrs_array[group_index]->post_calibration)
 80266c6:	f854 3b04 	ldr.w	r3, [r4], #4
 80266ca:	7a1a      	ldrb	r2, [r3, #8]
 80266cc:	b93a      	cbnz	r2, 80266de <GLOBAL_ADC_Init+0x4e>
      {
        XMC_VADC_GLOBAL_DisablePostCalibration(handle_ptr->module_ptr,group_index);
 80266ce:	6971      	ldr	r1, [r6, #20]
 80266d0:	f8d1 2080 	ldr.w	r2, [r1, #128]	; 0x80
 80266d4:	fa08 f005 	lsl.w	r0, r8, r5
 80266d8:	4302      	orrs	r2, r0
 80266da:	f8c1 2080 	str.w	r2, [r1, #128]	; 0x80
 80266de:	3501      	adds	r5, #1
    /* Initialize an instance of Global hardware */
    XMC_VADC_GLOBAL_Init(handle_ptr->module_ptr, handle_ptr->global_config_handle);

    /* Initialize all the Groups */
#if (XMC_VADC_GROUP_AVAILABLE == 1U)
    for(group_index = (uint32_t)0; group_index < XMC_VADC_MAXIMUM_NUM_GROUPS; group_index++)
 80266e0:	2d14      	cmp	r5, #20

#if(XMC_VADC_SHS_AVAILABLE == 1U)
      XMC_VADC_GLOBAL_SHS_EnableAcceleratedMode(handle_ptr->global_shs_ptr, (XMC_VADC_GROUP_INDEX_t)group_index);
#endif

      handle_ptr->group_ptrs_array[group_index]->state = GLOBAL_ADC_SUCCESS;
 80266e2:	725f      	strb	r7, [r3, #9]
    /* Initialize an instance of Global hardware */
    XMC_VADC_GLOBAL_Init(handle_ptr->module_ptr, handle_ptr->global_config_handle);

    /* Initialize all the Groups */
#if (XMC_VADC_GROUP_AVAILABLE == 1U)
    for(group_index = (uint32_t)0; group_index < XMC_VADC_MAXIMUM_NUM_GROUPS; group_index++)
 80266e4:	d1e5      	bne.n	80266b2 <GLOBAL_ADC_Init+0x22>
#endif
#endif /* _XMC_VADC_GROUP_AVAILABLE_ */
#if(XMC_VADC_SHS_AVAILABLE == 1U)
    XMC_VADC_GLOBAL_SHS_SetAnalogReference(handle_ptr->global_shs_ptr, GLOBAL_ADC_AREF_VALUE);
#endif
    if((bool)true == handle_ptr->enable_startup_calibration)
 80266e6:	7e73      	ldrb	r3, [r6, #25]
 80266e8:	b91b      	cbnz	r3, 80266f2 <GLOBAL_ADC_Init+0x62>
    {
    	XMC_VADC_GLOBAL_StartupCalibration(handle_ptr->module_ptr);
    }
    handle_ptr->init_state = GLOBAL_ADC_SUCCESS;
 80266ea:	2000      	movs	r0, #0
 80266ec:	7630      	strb	r0, [r6, #24]
  }
  return (handle_ptr->init_state);
}
 80266ee:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
#if(XMC_VADC_SHS_AVAILABLE == 1U)
    XMC_VADC_GLOBAL_SHS_SetAnalogReference(handle_ptr->global_shs_ptr, GLOBAL_ADC_AREF_VALUE);
#endif
    if((bool)true == handle_ptr->enable_startup_calibration)
    {
    	XMC_VADC_GLOBAL_StartupCalibration(handle_ptr->module_ptr);
 80266f2:	6970      	ldr	r0, [r6, #20]
 80266f4:	f7fc feb0 	bl	8023458 <XMC_VADC_GLOBAL_StartupCalibration>
 80266f8:	e7f7      	b.n	80266ea <GLOBAL_ADC_Init+0x5a>
 80266fa:	bf00      	nop

080266fc <DMA_CH_Init>:
  return version;
}

/* DMA_CH initialization function */
DMA_CH_STATUS_t DMA_CH_Init(DMA_CH_t *const obj)
{
 80266fc:	b510      	push	{r4, lr}
 80266fe:	4604      	mov	r4, r0
  DMA_CH_STATUS_t status;

  XMC_ASSERT("DMA_CH_Init: NULL DMA_CH_t object", (obj != NULL));

  /* This cannot possibly fail! */
  GLOBAL_DMA_Init(obj->dma_global);
 8026700:	6800      	ldr	r0, [r0, #0]
 8026702:	f7ff ff41 	bl	8026588 <GLOBAL_DMA_Init>

  if (XMC_DMA_CH_Init(obj->dma_global->dma, obj->ch_num, &obj->config->ch_config) == XMC_DMA_CH_STATUS_OK)
 8026706:	6823      	ldr	r3, [r4, #0]
 8026708:	7b21      	ldrb	r1, [r4, #12]
 802670a:	6818      	ldr	r0, [r3, #0]
 802670c:	6862      	ldr	r2, [r4, #4]
 802670e:	f7fb f93b 	bl	8021988 <XMC_DMA_CH_Init>
 8026712:	b938      	cbnz	r0, 8026724 <DMA_CH_Init+0x28>
  {
	if(obj->config->events)
 8026714:	6863      	ldr	r3, [r4, #4]
 8026716:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8026718:	b932      	cbnz	r2, 8026728 <DMA_CH_Init+0x2c>
	{
		XMC_DMA_CH_EnableEvent(obj->dma_global->dma, obj->ch_num, obj->config->events);
		XMC_DMA_CH_SetEventHandler(obj->dma_global->dma, obj->ch_num, obj->config->callback);
	}
    obj->reload(obj);
 802671a:	4620      	mov	r0, r4
 802671c:	68a3      	ldr	r3, [r4, #8]
 802671e:	4798      	blx	r3
    status = DMA_CH_STATUS_SUCCESS;
 8026720:	2000      	movs	r0, #0
 8026722:	bd10      	pop	{r4, pc}
  }
  else
  {
    status = DMA_CH_STATUS_FAILURE;
 8026724:	2001      	movs	r0, #1
  }

  return status;
}
 8026726:	bd10      	pop	{r4, pc}

  if (XMC_DMA_CH_Init(obj->dma_global->dma, obj->ch_num, &obj->config->ch_config) == XMC_DMA_CH_STATUS_OK)
  {
	if(obj->config->events)
	{
		XMC_DMA_CH_EnableEvent(obj->dma_global->dma, obj->ch_num, obj->config->events);
 8026728:	6823      	ldr	r3, [r4, #0]
 802672a:	7b21      	ldrb	r1, [r4, #12]
 802672c:	6818      	ldr	r0, [r3, #0]
 802672e:	f7fb fa77 	bl	8021c20 <XMC_DMA_CH_EnableEvent>
		XMC_DMA_CH_SetEventHandler(obj->dma_global->dma, obj->ch_num, obj->config->callback);
 8026732:	e894 000c 	ldmia.w	r4, {r2, r3}
 8026736:	7b21      	ldrb	r1, [r4, #12]
 8026738:	6810      	ldr	r0, [r2, #0]
 802673a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 802673c:	f7fb fa88 	bl	8021c50 <XMC_DMA_CH_SetEventHandler>
 8026740:	e7eb      	b.n	802671a <DMA_CH_Init+0x1e>
 8026742:	bf00      	nop

08026744 <DMA_CH_G0_reload>:

extern uint32_t* pDMA_dst_G0; /* Destination address symbol */

void DMA_CH_G0_reload(DMA_CH_t *obj)
{
  XMC_DMA_CH_SetBlockSize(obj->dma_global->dma, obj->ch_num, 256);
 8026744:	6802      	ldr	r2, [r0, #0]
 * see ::XMC_DMA_CH_Enable() for more information.
 *
 */
__STATIC_INLINE void XMC_DMA_CH_SetBlockSize(XMC_DMA_t *const dma, const uint8_t channel, uint32_t block_size)
{
  dma->CH[channel].CTLH = block_size;
 8026746:	7b03      	ldrb	r3, [r0, #12]
 8026748:	6811      	ldr	r1, [r2, #0]
  XMC_DMA_CH_SetSourceAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_src_G0);
 802674a:	4a0a      	ldr	r2, [pc, #40]	; (8026774 <DMA_CH_G0_reload+0x30>)
extern uint32_t* pDMA_src_G0; /* Source address symbol */

extern uint32_t* pDMA_dst_G0; /* Destination address symbol */

void DMA_CH_G0_reload(DMA_CH_t *obj)
{
 802674c:	b470      	push	{r4, r5, r6}
 802674e:	2458      	movs	r4, #88	; 0x58
 8026750:	fb04 1303 	mla	r3, r4, r3, r1
 8026754:	f44f 7680 	mov.w	r6, #256	; 0x100
 8026758:	61de      	str	r6, [r3, #28]
 * \par<b>Related API: </b><br>
 * ::XMC_DMA_CH_SetDestinationAddress() <br>
 */
__STATIC_INLINE void XMC_DMA_CH_SetSourceAddress(XMC_DMA_t *const dma, const uint8_t channel, uint32_t addr)
{
  dma->CH[channel].SAR = addr;
 802675a:	7b03      	ldrb	r3, [r0, #12]
  XMC_DMA_CH_SetBlockSize(obj->dma_global->dma, obj->ch_num, 256);
  XMC_DMA_CH_SetSourceAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_src_G0);
  XMC_DMA_CH_SetDestinationAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_dst_G0);
 802675c:	4d06      	ldr	r5, [pc, #24]	; (8026778 <DMA_CH_G0_reload+0x34>)
extern uint32_t* pDMA_dst_G0; /* Destination address symbol */

void DMA_CH_G0_reload(DMA_CH_t *obj)
{
  XMC_DMA_CH_SetBlockSize(obj->dma_global->dma, obj->ch_num, 256);
  XMC_DMA_CH_SetSourceAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_src_G0);
 802675e:	6812      	ldr	r2, [r2, #0]
  XMC_DMA_CH_SetDestinationAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_dst_G0);
 8026760:	682d      	ldr	r5, [r5, #0]
 8026762:	fb04 f303 	mul.w	r3, r4, r3
 8026766:	50ca      	str	r2, [r1, r3]
 * \par<b>Related API: </b><br>
 * ::XMC_DMA_CH_SetSourceAddress() <br>
 */
__STATIC_INLINE void XMC_DMA_CH_SetDestinationAddress(XMC_DMA_t *const dma, const uint8_t channel, uint32_t addr)
{
  dma->CH[channel].DAR = addr;
 8026768:	7b02      	ldrb	r2, [r0, #12]
 802676a:	fb04 1302 	mla	r3, r4, r2, r1
 802676e:	609d      	str	r5, [r3, #8]
}
 8026770:	bc70      	pop	{r4, r5, r6}
 8026772:	4770      	bx	lr
 8026774:	1ffedbdc 	.word	0x1ffedbdc
 8026778:	1ffedbec 	.word	0x1ffedbec

0802677c <DMA_CH_G1_reload>:

extern uint32_t* pDMA_dst_G1; /* Destination address symbol */

void DMA_CH_G1_reload(DMA_CH_t *obj)
{
  XMC_DMA_CH_SetBlockSize(obj->dma_global->dma, obj->ch_num, 256);
 802677c:	6802      	ldr	r2, [r0, #0]
 * see ::XMC_DMA_CH_Enable() for more information.
 *
 */
__STATIC_INLINE void XMC_DMA_CH_SetBlockSize(XMC_DMA_t *const dma, const uint8_t channel, uint32_t block_size)
{
  dma->CH[channel].CTLH = block_size;
 802677e:	7b03      	ldrb	r3, [r0, #12]
 8026780:	6811      	ldr	r1, [r2, #0]
  XMC_DMA_CH_SetSourceAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_src_G1);
 8026782:	4a0a      	ldr	r2, [pc, #40]	; (80267ac <DMA_CH_G1_reload+0x30>)
extern uint32_t* pDMA_src_G1; /* Source address symbol */

extern uint32_t* pDMA_dst_G1; /* Destination address symbol */

void DMA_CH_G1_reload(DMA_CH_t *obj)
{
 8026784:	b470      	push	{r4, r5, r6}
 8026786:	2458      	movs	r4, #88	; 0x58
 8026788:	fb04 1303 	mla	r3, r4, r3, r1
 802678c:	f44f 7680 	mov.w	r6, #256	; 0x100
 8026790:	61de      	str	r6, [r3, #28]
 * \par<b>Related API: </b><br>
 * ::XMC_DMA_CH_SetDestinationAddress() <br>
 */
__STATIC_INLINE void XMC_DMA_CH_SetSourceAddress(XMC_DMA_t *const dma, const uint8_t channel, uint32_t addr)
{
  dma->CH[channel].SAR = addr;
 8026792:	7b03      	ldrb	r3, [r0, #12]
  XMC_DMA_CH_SetBlockSize(obj->dma_global->dma, obj->ch_num, 256);
  XMC_DMA_CH_SetSourceAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_src_G1);
  XMC_DMA_CH_SetDestinationAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_dst_G1);
 8026794:	4d06      	ldr	r5, [pc, #24]	; (80267b0 <DMA_CH_G1_reload+0x34>)
extern uint32_t* pDMA_dst_G1; /* Destination address symbol */

void DMA_CH_G1_reload(DMA_CH_t *obj)
{
  XMC_DMA_CH_SetBlockSize(obj->dma_global->dma, obj->ch_num, 256);
  XMC_DMA_CH_SetSourceAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_src_G1);
 8026796:	6812      	ldr	r2, [r2, #0]
  XMC_DMA_CH_SetDestinationAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_dst_G1);
 8026798:	682d      	ldr	r5, [r5, #0]
 802679a:	fb04 f303 	mul.w	r3, r4, r3
 802679e:	50ca      	str	r2, [r1, r3]
 * \par<b>Related API: </b><br>
 * ::XMC_DMA_CH_SetSourceAddress() <br>
 */
__STATIC_INLINE void XMC_DMA_CH_SetDestinationAddress(XMC_DMA_t *const dma, const uint8_t channel, uint32_t addr)
{
  dma->CH[channel].DAR = addr;
 80267a0:	7b02      	ldrb	r2, [r0, #12]
 80267a2:	fb04 1302 	mla	r3, r4, r2, r1
 80267a6:	609d      	str	r5, [r3, #8]
}
 80267a8:	bc70      	pop	{r4, r5, r6}
 80267aa:	4770      	bx	lr
 80267ac:	1ffedbe0 	.word	0x1ffedbe0
 80267b0:	1ffedbf0 	.word	0x1ffedbf0

080267b4 <DMA_CH_G3_reload>:

extern uint32_t* pDMA_dst_G3; /* Destination address symbol */

void DMA_CH_G3_reload(DMA_CH_t *obj)
{
  XMC_DMA_CH_SetBlockSize(obj->dma_global->dma, obj->ch_num, 256);
 80267b4:	6802      	ldr	r2, [r0, #0]
 * see ::XMC_DMA_CH_Enable() for more information.
 *
 */
__STATIC_INLINE void XMC_DMA_CH_SetBlockSize(XMC_DMA_t *const dma, const uint8_t channel, uint32_t block_size)
{
  dma->CH[channel].CTLH = block_size;
 80267b6:	7b03      	ldrb	r3, [r0, #12]
 80267b8:	6811      	ldr	r1, [r2, #0]
  XMC_DMA_CH_SetSourceAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_src_G3);
 80267ba:	4a0a      	ldr	r2, [pc, #40]	; (80267e4 <DMA_CH_G3_reload+0x30>)
extern uint32_t* pDMA_src_G3; /* Source address symbol */

extern uint32_t* pDMA_dst_G3; /* Destination address symbol */

void DMA_CH_G3_reload(DMA_CH_t *obj)
{
 80267bc:	b470      	push	{r4, r5, r6}
 80267be:	2458      	movs	r4, #88	; 0x58
 80267c0:	fb04 1303 	mla	r3, r4, r3, r1
 80267c4:	f44f 7680 	mov.w	r6, #256	; 0x100
 80267c8:	61de      	str	r6, [r3, #28]
 * \par<b>Related API: </b><br>
 * ::XMC_DMA_CH_SetDestinationAddress() <br>
 */
__STATIC_INLINE void XMC_DMA_CH_SetSourceAddress(XMC_DMA_t *const dma, const uint8_t channel, uint32_t addr)
{
  dma->CH[channel].SAR = addr;
 80267ca:	7b03      	ldrb	r3, [r0, #12]
  XMC_DMA_CH_SetBlockSize(obj->dma_global->dma, obj->ch_num, 256);
  XMC_DMA_CH_SetSourceAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_src_G3);
  XMC_DMA_CH_SetDestinationAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_dst_G3);
 80267cc:	4d06      	ldr	r5, [pc, #24]	; (80267e8 <DMA_CH_G3_reload+0x34>)
extern uint32_t* pDMA_dst_G3; /* Destination address symbol */

void DMA_CH_G3_reload(DMA_CH_t *obj)
{
  XMC_DMA_CH_SetBlockSize(obj->dma_global->dma, obj->ch_num, 256);
  XMC_DMA_CH_SetSourceAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_src_G3);
 80267ce:	6812      	ldr	r2, [r2, #0]
  XMC_DMA_CH_SetDestinationAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_dst_G3);
 80267d0:	682d      	ldr	r5, [r5, #0]
 80267d2:	fb04 f303 	mul.w	r3, r4, r3
 80267d6:	50ca      	str	r2, [r1, r3]
 * \par<b>Related API: </b><br>
 * ::XMC_DMA_CH_SetSourceAddress() <br>
 */
__STATIC_INLINE void XMC_DMA_CH_SetDestinationAddress(XMC_DMA_t *const dma, const uint8_t channel, uint32_t addr)
{
  dma->CH[channel].DAR = addr;
 80267d8:	7b02      	ldrb	r2, [r0, #12]
 80267da:	fb04 1302 	mla	r3, r4, r2, r1
 80267de:	609d      	str	r5, [r3, #8]
}
 80267e0:	bc70      	pop	{r4, r5, r6}
 80267e2:	4770      	bx	lr
 80267e4:	1ffedbe8 	.word	0x1ffedbe8
 80267e8:	1ffeb480 	.word	0x1ffeb480

080267ec <DMA_CH_G2_reload>:

extern uint32_t* pDMA_dst_G2; /* Destination address symbol */

void DMA_CH_G2_reload(DMA_CH_t *obj)
{
  XMC_DMA_CH_SetBlockSize(obj->dma_global->dma, obj->ch_num, 256);
 80267ec:	6802      	ldr	r2, [r0, #0]
 * see ::XMC_DMA_CH_Enable() for more information.
 *
 */
__STATIC_INLINE void XMC_DMA_CH_SetBlockSize(XMC_DMA_t *const dma, const uint8_t channel, uint32_t block_size)
{
  dma->CH[channel].CTLH = block_size;
 80267ee:	7b03      	ldrb	r3, [r0, #12]
 80267f0:	6811      	ldr	r1, [r2, #0]
  XMC_DMA_CH_SetSourceAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_src_G2);
 80267f2:	4a0a      	ldr	r2, [pc, #40]	; (802681c <DMA_CH_G2_reload+0x30>)
extern uint32_t* pDMA_src_G2; /* Source address symbol */

extern uint32_t* pDMA_dst_G2; /* Destination address symbol */

void DMA_CH_G2_reload(DMA_CH_t *obj)
{
 80267f4:	b470      	push	{r4, r5, r6}
 80267f6:	2458      	movs	r4, #88	; 0x58
 80267f8:	fb04 1303 	mla	r3, r4, r3, r1
 80267fc:	f44f 7680 	mov.w	r6, #256	; 0x100
 8026800:	61de      	str	r6, [r3, #28]
 * \par<b>Related API: </b><br>
 * ::XMC_DMA_CH_SetDestinationAddress() <br>
 */
__STATIC_INLINE void XMC_DMA_CH_SetSourceAddress(XMC_DMA_t *const dma, const uint8_t channel, uint32_t addr)
{
  dma->CH[channel].SAR = addr;
 8026802:	7b03      	ldrb	r3, [r0, #12]
  XMC_DMA_CH_SetBlockSize(obj->dma_global->dma, obj->ch_num, 256);
  XMC_DMA_CH_SetSourceAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_src_G2);
  XMC_DMA_CH_SetDestinationAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_dst_G2);
 8026804:	4d06      	ldr	r5, [pc, #24]	; (8026820 <DMA_CH_G2_reload+0x34>)
extern uint32_t* pDMA_dst_G2; /* Destination address symbol */

void DMA_CH_G2_reload(DMA_CH_t *obj)
{
  XMC_DMA_CH_SetBlockSize(obj->dma_global->dma, obj->ch_num, 256);
  XMC_DMA_CH_SetSourceAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_src_G2);
 8026806:	6812      	ldr	r2, [r2, #0]
  XMC_DMA_CH_SetDestinationAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_dst_G2);
 8026808:	682d      	ldr	r5, [r5, #0]
 802680a:	fb04 f303 	mul.w	r3, r4, r3
 802680e:	50ca      	str	r2, [r1, r3]
 * \par<b>Related API: </b><br>
 * ::XMC_DMA_CH_SetSourceAddress() <br>
 */
__STATIC_INLINE void XMC_DMA_CH_SetDestinationAddress(XMC_DMA_t *const dma, const uint8_t channel, uint32_t addr)
{
  dma->CH[channel].DAR = addr;
 8026810:	7b02      	ldrb	r2, [r0, #12]
 8026812:	fb04 1302 	mla	r3, r4, r2, r1
 8026816:	609d      	str	r5, [r3, #8]
}
 8026818:	bc70      	pop	{r4, r5, r6}
 802681a:	4770      	bx	lr
 802681c:	1ffedbe4 	.word	0x1ffedbe4
 8026820:	1ffedbd8 	.word	0x1ffedbd8

08026824 <DIGITAL_IO_Init>:
* @param handler Pointer pointing to APP data structure.
* @return DIGITAL_IO_STATUS_t DIGITAL_IO APP status.
*/

DIGITAL_IO_STATUS_t DIGITAL_IO_Init(const DIGITAL_IO_t *const handler)
{
 8026824:	b510      	push	{r4, lr}
 8026826:	4604      	mov	r4, r0
  XMC_ASSERT("DIGITAL_IO_Init: handler null pointer", handler != NULL);

  /* Initializes input / output characteristics */
  XMC_GPIO_Init(handler->gpio_port, handler->gpio_pin, &handler->gpio_config);
 8026828:	1d02      	adds	r2, r0, #4
 802682a:	7c21      	ldrb	r1, [r4, #16]
 802682c:	6800      	ldr	r0, [r0, #0]
 802682e:	f7fa fba1 	bl	8020f74 <XMC_GPIO_Init>

  /*Configure hardware port control*/
  XMC_GPIO_SetHardwareControl(handler->gpio_port, handler->gpio_pin, handler->hwctrl);
 8026832:	6820      	ldr	r0, [r4, #0]
 8026834:	7c21      	ldrb	r1, [r4, #16]
 8026836:	7c62      	ldrb	r2, [r4, #17]
 8026838:	f7fb fb04 	bl	8021e44 <XMC_GPIO_SetHardwareControl>

  return (DIGITAL_IO_STATUS_OK);
}
 802683c:	2000      	movs	r0, #0
 802683e:	bd10      	pop	{r4, pc}

08026840 <CRC_SW_Init>:
*/
CRC_SW_STATUS_t CRC_SW_Init(CRC_SW_t *const handle)
{
  CRC_SW_STATUS_t status;

  if (handle != NULL)
 8026840:	4603      	mov	r3, r0
 8026842:	b1a0      	cbz	r0, 802686e <CRC_SW_Init+0x2e>
/*
 * This function initializes CRC_SW handle.
 *
*/
CRC_SW_STATUS_t CRC_SW_Init(CRC_SW_t *const handle)
{
 8026844:	b470      	push	{r4, r5, r6}
  CRC_SW_STATUS_t status;

  if (handle != NULL)
  {
    /* calculate MSB mask, CRC Mask and shift from polynomial width */
    handle->msb_mask = (uint32_t)(CRC_SW_ONE << (handle->config->crc_width - CRC_SW_ONE));
 8026846:	6804      	ldr	r4, [r0, #0]
 8026848:	6821      	ldr	r1, [r4, #0]

    handle->crc_mask = (uint32_t)((handle->msb_mask - CRC_SW_ONE) | (handle->msb_mask));

    handle->crc_shift = CRC_SW_ZERO;

    handle->config->output_reflection &= handle->crc_mask;
 802684a:	7c62      	ldrb	r2, [r4, #17]

    handle->crc_runningval = handle->config->crc_initval;
 802684c:	68a6      	ldr	r6, [r4, #8]
  CRC_SW_STATUS_t status;

  if (handle != NULL)
  {
    /* calculate MSB mask, CRC Mask and shift from polynomial width */
    handle->msb_mask = (uint32_t)(CRC_SW_ONE << (handle->config->crc_width - CRC_SW_ONE));
 802684e:	1e48      	subs	r0, r1, #1
 8026850:	2101      	movs	r1, #1
 8026852:	4081      	lsls	r1, r0

    handle->crc_mask = (uint32_t)((handle->msb_mask - CRC_SW_ONE) | (handle->msb_mask));
 8026854:	1e4d      	subs	r5, r1, #1
 8026856:	430d      	orrs	r5, r1

    handle->crc_shift = CRC_SW_ZERO;

    handle->config->output_reflection &= handle->crc_mask;
 8026858:	402a      	ands	r2, r5
    /* calculate MSB mask, CRC Mask and shift from polynomial width */
    handle->msb_mask = (uint32_t)(CRC_SW_ONE << (handle->config->crc_width - CRC_SW_ONE));

    handle->crc_mask = (uint32_t)((handle->msb_mask - CRC_SW_ONE) | (handle->msb_mask));

    handle->crc_shift = CRC_SW_ZERO;
 802685a:	2000      	movs	r0, #0

    handle->config->output_reflection &= handle->crc_mask;
 802685c:	f002 0201 	and.w	r2, r2, #1
  if (handle != NULL)
  {
    /* calculate MSB mask, CRC Mask and shift from polynomial width */
    handle->msb_mask = (uint32_t)(CRC_SW_ONE << (handle->config->crc_width - CRC_SW_ONE));

    handle->crc_mask = (uint32_t)((handle->msb_mask - CRC_SW_ONE) | (handle->msb_mask));
 8026860:	60dd      	str	r5, [r3, #12]
  CRC_SW_STATUS_t status;

  if (handle != NULL)
  {
    /* calculate MSB mask, CRC Mask and shift from polynomial width */
    handle->msb_mask = (uint32_t)(CRC_SW_ONE << (handle->config->crc_width - CRC_SW_ONE));
 8026862:	6099      	str	r1, [r3, #8]

    handle->crc_mask = (uint32_t)((handle->msb_mask - CRC_SW_ONE) | (handle->msb_mask));

    handle->crc_shift = CRC_SW_ZERO;
 8026864:	6118      	str	r0, [r3, #16]

    handle->config->output_reflection &= handle->crc_mask;
 8026866:	7462      	strb	r2, [r4, #17]

    handle->crc_runningval = handle->config->crc_initval;
 8026868:	605e      	str	r6, [r3, #4]
  {
    status = CRC_SW_STATUS_FAILURE;
  }

  return (status);
}
 802686a:	bc70      	pop	{r4, r5, r6}
 802686c:	4770      	bx	lr

    status = CRC_SW_STATUS_SUCCESS;
  }
  else
  {
    status = CRC_SW_STATUS_FAILURE;
 802686e:	2001      	movs	r0, #1
 8026870:	4770      	bx	lr
 8026872:	bf00      	nop

08026874 <CRC_SW_CalculateCRC>:

/*
 * This function calculates CRC on a block of data.
 */
void CRC_SW_CalculateCRC(CRC_SW_t *const handle, void * bufferptr, uint32_t length)
{
 8026874:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  XMC_ASSERT("CalculateCRC: NULL Handle", handle != NULL);
  XMC_ASSERT("CalculateCRC: NULL Buffer", bufferptr != NULL);

  /* Load the initial CRC value as running value for CRC */
  handle->crc_runningval = handle->config->crc_initval;
 8026878:	6804      	ldr	r4, [r0, #0]
 802687a:	68a3      	ldr	r3, [r4, #8]
 802687c:	6043      	str	r3, [r0, #4]
  uint32_t buffer;
  uint8_t *temp;
  
  temp = (uint8_t *)bufferptr;

  while (length--)
 802687e:	2a00      	cmp	r2, #0
 8026880:	d038      	beq.n	80268f4 <CRC_SW_CalculateCRC+0x80>
 8026882:	f8d0 e010 	ldr.w	lr, [r0, #16]
 8026886:	68c5      	ldr	r5, [r0, #12]
 8026888:	f894 c010 	ldrb.w	ip, [r4, #16]
 802688c:	6946      	ldr	r6, [r0, #20]
 802688e:	6987      	ldr	r7, [r0, #24]
 8026890:	fa05 f50e 	lsl.w	r5, r5, lr
 8026894:	f1bc 0f00 	cmp.w	ip, #0
 8026898:	d11a      	bne.n	80268d0 <CRC_SW_CalculateCRC+0x5c>
                                 (handle->crc_runningval >> CRC_SW_EIGHT)) & (handle->crc_mask << handle->crc_shift);
    }
    else
    {
      /* load the lookup table value based on CRC width */
      tableindex = ((handle->crc_runningval >> ((handle->config->crc_width - CRC_SW_EIGHT) +
 802689a:	6824      	ldr	r4, [r4, #0]
 802689c:	eb0e 0c04 	add.w	ip, lr, r4
 80268a0:	f1ac 0c08 	sub.w	ip, ip, #8
 80268a4:	440a      	add	r2, r1
 80268a6:	f1ce 0e08 	rsb	lr, lr, #8
  
  temp = (uint8_t *)bufferptr;

  while (length--)
  {
    buffer = (uint32_t) *temp;
 80268aa:	f811 8b01 	ldrb.w	r8, [r1], #1
                                 (handle->crc_runningval >> CRC_SW_EIGHT)) & (handle->crc_mask << handle->crc_shift);
    }
    else
    {
      /* load the lookup table value based on CRC width */
      tableindex = ((handle->crc_runningval >> ((handle->config->crc_width - CRC_SW_EIGHT) +
 80268ae:	fa23 f40c 	lsr.w	r4, r3, ip
                     handle->crc_shift)) ^ buffer) & (uint32_t)0xff;
 80268b2:	ea88 0404 	eor.w	r4, r8, r4
                                 (handle->crc_runningval >> CRC_SW_EIGHT)) & (handle->crc_mask << handle->crc_shift);
    }
    else
    {
      /* load the lookup table value based on CRC width */
      tableindex = ((handle->crc_runningval >> ((handle->config->crc_width - CRC_SW_EIGHT) +
 80268b6:	b2e4      	uxtb	r4, r4
                     handle->crc_shift)) ^ buffer) & (uint32_t)0xff;

      /* compute the CRC running value from the lookup table */
      handle->crc_runningval = (*(uint32_t *)((uint32_t)handle->crctable + (tableindex * handle->tableoffset)) ^ \
 80268b8:	fb07 f404 	mul.w	r4, r7, r4
                                 (handle->crc_runningval  << (CRC_SW_EIGHT - handle->crc_shift))) & \
 80268bc:	fa03 f30e 	lsl.w	r3, r3, lr
      /* load the lookup table value based on CRC width */
      tableindex = ((handle->crc_runningval >> ((handle->config->crc_width - CRC_SW_EIGHT) +
                     handle->crc_shift)) ^ buffer) & (uint32_t)0xff;

      /* compute the CRC running value from the lookup table */
      handle->crc_runningval = (*(uint32_t *)((uint32_t)handle->crctable + (tableindex * handle->tableoffset)) ^ \
 80268c0:	59a4      	ldr	r4, [r4, r6]
 80268c2:	4063      	eors	r3, r4
                                 (handle->crc_runningval  << (CRC_SW_EIGHT - handle->crc_shift))) & \
 80268c4:	402b      	ands	r3, r5
  uint32_t buffer;
  uint8_t *temp;
  
  temp = (uint8_t *)bufferptr;

  while (length--)
 80268c6:	4291      	cmp	r1, r2
 80268c8:	6043      	str	r3, [r0, #4]
 80268ca:	d1ee      	bne.n	80268aa <CRC_SW_CalculateCRC+0x36>
 80268cc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80268d0:	440a      	add	r2, r1
  {
    buffer = (uint32_t) *temp;
 80268d2:	f811 cb01 	ldrb.w	ip, [r1], #1

    /* if input reflection is set */
    if (handle->config->input_reflection == true)
    {
      tableindex = ((handle->crc_runningval >> handle->crc_shift) ^ buffer) & (int32_t)0xff;
 80268d6:	fa23 f40e 	lsr.w	r4, r3, lr
 80268da:	ea8c 0404 	eor.w	r4, ip, r4
 80268de:	b2e4      	uxtb	r4, r4

      /* compute the CRC running value from the lookup table */
      handle->crc_runningval = (*(uint32_t*)((uint32_t)handle->crctable + (tableindex * handle->tableoffset))  ^ \
 80268e0:	fb07 f404 	mul.w	r4, r7, r4
  uint32_t buffer;
  uint8_t *temp;
  
  temp = (uint8_t *)bufferptr;

  while (length--)
 80268e4:	4291      	cmp	r1, r2
    if (handle->config->input_reflection == true)
    {
      tableindex = ((handle->crc_runningval >> handle->crc_shift) ^ buffer) & (int32_t)0xff;

      /* compute the CRC running value from the lookup table */
      handle->crc_runningval = (*(uint32_t*)((uint32_t)handle->crctable + (tableindex * handle->tableoffset))  ^ \
 80268e6:	59a4      	ldr	r4, [r4, r6]
 80268e8:	ea84 2313 	eor.w	r3, r4, r3, lsr #8
                                 (handle->crc_runningval >> CRC_SW_EIGHT)) & (handle->crc_mask << handle->crc_shift);
 80268ec:	ea03 0305 	and.w	r3, r3, r5
 80268f0:	6043      	str	r3, [r0, #4]
  uint32_t buffer;
  uint8_t *temp;
  
  temp = (uint8_t *)bufferptr;

  while (length--)
 80268f2:	d1ee      	bne.n	80268d2 <CRC_SW_CalculateCRC+0x5e>
 80268f4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

080268f8 <CRC_SW_GetCRCResult>:
/**
 * This function returns the CRC value for the already calculated CRC by doing
 * reflection(if selected) and inversion.
 **/
uint32_t CRC_SW_GetCRCResult(CRC_SW_t *const handle)
{
 80268f8:	b4f0      	push	{r4, r5, r6, r7}
  uint32_t result;
  
  if (handle != NULL)
 80268fa:	4606      	mov	r6, r0
 80268fc:	b310      	cbz	r0, 8026944 <CRC_SW_GetCRCResult+0x4c>
  {
    handle->crc_runningval &= (handle->crc_mask << handle->crc_shift);
 80268fe:	6902      	ldr	r2, [r0, #16]
 8026900:	68c7      	ldr	r7, [r0, #12]
    handle->crc_runningval >>= handle->crc_shift;

    /* Do not reflect the bytes if input reflection and output reflection are set to true. Otherwise reflect the bytes*/
    if (handle->config->input_reflection != handle->config->output_reflection)
 8026902:	c809      	ldmia	r0, {r0, r3}
{
  uint32_t result;
  
  if (handle != NULL)
  {
    handle->crc_runningval &= (handle->crc_mask << handle->crc_shift);
 8026904:	fa07 f102 	lsl.w	r1, r7, r2
 8026908:	400b      	ands	r3, r1
    handle->crc_runningval >>= handle->crc_shift;

    /* Do not reflect the bytes if input reflection and output reflection are set to true. Otherwise reflect the bytes*/
    if (handle->config->input_reflection != handle->config->output_reflection)
 802690a:	7c04      	ldrb	r4, [r0, #16]
 802690c:	7c41      	ldrb	r1, [r0, #17]
  uint32_t result;
  
  if (handle != NULL)
  {
    handle->crc_runningval &= (handle->crc_mask << handle->crc_shift);
    handle->crc_runningval >>= handle->crc_shift;
 802690e:	40d3      	lsrs	r3, r2

    /* Do not reflect the bytes if input reflection and output reflection are set to true. Otherwise reflect the bytes*/
    if (handle->config->input_reflection != handle->config->output_reflection)
 8026910:	428c      	cmp	r4, r1
  uint32_t result;
  
  if (handle != NULL)
  {
    handle->crc_runningval &= (handle->crc_mask << handle->crc_shift);
    handle->crc_runningval >>= handle->crc_shift;
 8026912:	6073      	str	r3, [r6, #4]

    /* Do not reflect the bytes if input reflection and output reflection are set to true. Otherwise reflect the bytes*/
    if (handle->config->input_reflection != handle->config->output_reflection)
 8026914:	d014      	beq.n	8026940 <CRC_SW_GetCRCResult+0x48>
    {
      handle->crc_runningval = CRC_SW_lReflect(handle->crc_runningval, handle->config->crc_width);
 8026916:	6805      	ldr	r5, [r0, #0]
  uint32_t count;
  uint32_t retval;

  retval = data & CRC_SW_ONE;
  
  for (count = CRC_SW_ONE; count < length ; count++)
 8026918:	2d01      	cmp	r5, #1
static uint32_t CRC_SW_lReflect(uint32_t data, uint32_t length)
{
  uint32_t count;
  uint32_t retval;

  retval = data & CRC_SW_ONE;
 802691a:	f003 0101 	and.w	r1, r3, #1
  
  for (count = CRC_SW_ONE; count < length ; count++)
 802691e:	d908      	bls.n	8026932 <CRC_SW_GetCRCResult+0x3a>
 8026920:	2201      	movs	r2, #1
  {
    data >>= CRC_SW_ONE;
 8026922:	085b      	lsrs	r3, r3, #1
  uint32_t count;
  uint32_t retval;

  retval = data & CRC_SW_ONE;
  
  for (count = CRC_SW_ONE; count < length ; count++)
 8026924:	3201      	adds	r2, #1
  {
    data >>= CRC_SW_ONE;
    retval = (retval << CRC_SW_ONE) | (data & CRC_SW_ONE);
 8026926:	f003 0401 	and.w	r4, r3, #1
  uint32_t count;
  uint32_t retval;

  retval = data & CRC_SW_ONE;
  
  for (count = CRC_SW_ONE; count < length ; count++)
 802692a:	42aa      	cmp	r2, r5
  {
    data >>= CRC_SW_ONE;
    retval = (retval << CRC_SW_ONE) | (data & CRC_SW_ONE);
 802692c:	ea44 0141 	orr.w	r1, r4, r1, lsl #1
  uint32_t count;
  uint32_t retval;

  retval = data & CRC_SW_ONE;
  
  for (count = CRC_SW_ONE; count < length ; count++)
 8026930:	d1f7      	bne.n	8026922 <CRC_SW_GetCRCResult+0x2a>
    if (handle->config->input_reflection != handle->config->output_reflection)
    {
      handle->crc_runningval = CRC_SW_lReflect(handle->crc_runningval, handle->config->crc_width);
    }

    handle->crc_runningval ^= handle->config->output_inversion;
 8026932:	68c0      	ldr	r0, [r0, #12]
 8026934:	4041      	eors	r1, r0
    handle->crc_runningval &= handle->crc_mask;
 8026936:	ea01 0007 	and.w	r0, r1, r7
 802693a:	6070      	str	r0, [r6, #4]
  else
  {
    result = CRC_SW_ZERO;
  }
  return (result);
}
 802693c:	bcf0      	pop	{r4, r5, r6, r7}
 802693e:	4770      	bx	lr
 8026940:	4619      	mov	r1, r3
 8026942:	e7f6      	b.n	8026932 <CRC_SW_GetCRCResult+0x3a>
 8026944:	bcf0      	pop	{r4, r5, r6, r7}
 8026946:	4770      	bx	lr

08026948 <SystemCoreSetup>:
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8026948:	4b18      	ldr	r3, [pc, #96]	; (80269ac <SystemCoreSetup+0x64>)
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
 802694a:	4a19      	ldr	r2, [pc, #100]	; (80269b0 <SystemCoreSetup+0x68>)
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 802694c:	68d8      	ldr	r0, [r3, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 802694e:	f64f 01ff 	movw	r1, #63743	; 0xf8ff
 8026952:	4001      	ands	r1, r0
  reg_value  =  (reg_value                                   |
 8026954:	430a      	orrs	r2, r1
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 8026956:	60da      	str	r2, [r3, #12]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__((always_inline)) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8026958:	b672      	cpsid	i
	
  /* relocate vector table */
  __disable_irq();

#if !defined(__TASKING__)
  SCB->VTOR = (uint32_t)(&__Vectors);
 802695a:	4a16      	ldr	r2, [pc, #88]	; (80269b4 <SystemCoreSetup+0x6c>)
 802695c:	609a      	str	r2, [r3, #8]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 802695e:	f3bf 8f4f 	dsb	sy
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__((always_inline)) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8026962:	b662      	cpsie	i

  __DSB();
  __enable_irq();
	
#if ((__FPU_PRESENT == 1) && (__FPU_USED == 1))
  SCB->CPACR |= ((3UL << 10*2) |                 /* set CP10 Full Access */
 8026964:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
				 (3UL << 11*2)  );               /* set CP11 Full Access */
#endif
  /* Set flash wait states */
  temp = FLASH0->FCON;
 8026968:	4813      	ldr	r0, [pc, #76]	; (80269b8 <SystemCoreSetup+0x70>)

  __DSB();
  __enable_irq();
	
#if ((__FPU_PRESENT == 1) && (__FPU_USED == 1))
  SCB->CPACR |= ((3UL << 10*2) |                 /* set CP10 Full Access */
 802696a:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
				 (3UL << 11*2)  );               /* set CP11 Full Access */
#endif
  /* Set flash wait states */
  temp = FLASH0->FCON;
 802696e:	f241 0114 	movw	r1, #4116	; 0x1014

  __DSB();
  __enable_irq();
	
#if ((__FPU_PRESENT == 1) && (__FPU_USED == 1))
  SCB->CPACR |= ((3UL << 10*2) |                 /* set CP10 Full Access */
 8026972:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
				 (3UL << 11*2)  );               /* set CP11 Full Access */
#endif
  /* Set flash wait states */
  temp = FLASH0->FCON;
 8026976:	5842      	ldr	r2, [r0, r1]
  temp &= ~FLASH_FCON_WSPFLASH_Msk;
 8026978:	f022 020f 	bic.w	r2, r2, #15
  temp |= PMU_FLASH_WS;
 802697c:	f042 0204 	orr.w	r2, r2, #4
  FLASH0->FCON = temp;
 8026980:	5042      	str	r2, [r0, r1]


  /* Disable divide by zero trap */
  SCB->CCR &= ~SCB_CCR_DIV_0_TRP_Msk; 
 8026982:	695a      	ldr	r2, [r3, #20]
 8026984:	f022 0210 	bic.w	r2, r2, #16
 8026988:	615a      	str	r2, [r3, #20]

  /* Disable unaligned memory access trap */
  SCB->CCR &= ~SCB_CCR_UNALIGN_TRP_Msk; 
 802698a:	695a      	ldr	r2, [r3, #20]
 802698c:	f022 0208 	bic.w	r2, r2, #8
 8026990:	615a      	str	r2, [r3, #20]

  /* Disable memory management fault */
  SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;
 8026992:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8026994:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8026998:	625a      	str	r2, [r3, #36]	; 0x24

  /* Disable bus fault */
  SCB->SHCSR &= ~SCB_SHCSR_BUSFAULTENA_Msk;
 802699a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 802699c:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
 80269a0:	625a      	str	r2, [r3, #36]	; 0x24

  /* Disable usage fault */
  SCB->SHCSR &= ~SCB_SHCSR_USGFAULTENA_Msk;
 80269a2:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80269a4:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 80269a8:	625a      	str	r2, [r3, #36]	; 0x24
 80269aa:	4770      	bx	lr
 80269ac:	e000ed00 	.word	0xe000ed00
 80269b0:	05fa0100 	.word	0x05fa0100
 80269b4:	08000000 	.word	0x08000000
 80269b8:	58001000 	.word	0x58001000

080269bc <arm_bitreversal_32>:
	ENDP

#else

arm_bitreversal_32 PROC
	ADDS     r3,r1,#1
 80269bc:	1c4b      	adds	r3, r1, #1
	CMP      r3,#1
 80269be:	2b01      	cmp	r3, #1
	IT       LS
 80269c0:	bf98      	it	ls
	BXLS     lr
 80269c2:	4770      	bxls	lr
	PUSH     {r4-r9}
 80269c4:	e92d 03f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9}
	ADDS     r1,r2,#2
 80269c8:	1c91      	adds	r1, r2, #2
	LSRS     r3,r3,#2
 80269ca:	089b      	lsrs	r3, r3, #2

080269cc <arm_bitreversal_32_0>:
arm_bitreversal_32_0 LABEL       ;/* loop unrolled by 2 */
	LDRH     r8,[r1,#4]
 80269cc:	f8b1 8004 	ldrh.w	r8, [r1, #4]
	LDRH     r9,[r1,#2]
 80269d0:	f8b1 9002 	ldrh.w	r9, [r1, #2]
	LDRH     r2,[r1,#0]
 80269d4:	880a      	ldrh	r2, [r1, #0]
	LDRH     r12,[r1,#-2]
 80269d6:	f831 cc02 	ldrh.w	ip, [r1, #-2]
	ADD      r8,r0,r8
 80269da:	4480      	add	r8, r0
	ADD      r9,r0,r9
 80269dc:	4481      	add	r9, r0
	ADD      r2,r0,r2
 80269de:	4402      	add	r2, r0
	ADD      r12,r0,r12
 80269e0:	4484      	add	ip, r0
	LDR      r7,[r9,#0]
 80269e2:	f8d9 7000 	ldr.w	r7, [r9]
	LDR      r6,[r8,#0]
 80269e6:	f8d8 6000 	ldr.w	r6, [r8]
	LDR      r5,[r2,#0]
 80269ea:	6815      	ldr	r5, [r2, #0]
	LDR      r4,[r12,#0]
 80269ec:	f8dc 4000 	ldr.w	r4, [ip]
	STR      r6,[r9,#0]
 80269f0:	f8c9 6000 	str.w	r6, [r9]
	STR      r7,[r8,#0]
 80269f4:	f8c8 7000 	str.w	r7, [r8]
	STR      r5,[r12,#0]
 80269f8:	f8cc 5000 	str.w	r5, [ip]
	STR      r4,[r2,#0]
 80269fc:	6014      	str	r4, [r2, #0]
	LDR      r7,[r9,#4]
 80269fe:	f8d9 7004 	ldr.w	r7, [r9, #4]
	LDR      r6,[r8,#4]
 8026a02:	f8d8 6004 	ldr.w	r6, [r8, #4]
	LDR      r5,[r2,#4]
 8026a06:	6855      	ldr	r5, [r2, #4]
	LDR      r4,[r12,#4]
 8026a08:	f8dc 4004 	ldr.w	r4, [ip, #4]
	STR      r6,[r9,#4]
 8026a0c:	f8c9 6004 	str.w	r6, [r9, #4]
	STR      r7,[r8,#4]
 8026a10:	f8c8 7004 	str.w	r7, [r8, #4]
	STR      r5,[r12,#4]
 8026a14:	f8cc 5004 	str.w	r5, [ip, #4]
	STR      r4,[r2,#4]
 8026a18:	6054      	str	r4, [r2, #4]
	ADDS     r1,r1,#8
 8026a1a:	3108      	adds	r1, #8
	SUBS     r3,r3,#1
 8026a1c:	3b01      	subs	r3, #1
	BNE      arm_bitreversal_32_0
 8026a1e:	d1d5      	bne.n	80269cc <arm_bitreversal_32_0>
	POP      {r4-r9}
 8026a20:	e8bd 03f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9}
	BX       lr
 8026a24:	4770      	bx	lr

08026a26 <arm_bitreversal_16>:
	ENDP

arm_bitreversal_16 PROC
	ADDS     r3,r1,#1
 8026a26:	1c4b      	adds	r3, r1, #1
	CMP      r3,#1
 8026a28:	2b01      	cmp	r3, #1
	IT       LS
 8026a2a:	bf98      	it	ls
	BXLS     lr
 8026a2c:	4770      	bxls	lr
	PUSH     {r4-r9}
 8026a2e:	e92d 03f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9}
	ADDS     r1,r2,#2
 8026a32:	1c91      	adds	r1, r2, #2
	LSRS     r3,r3,#2
 8026a34:	089b      	lsrs	r3, r3, #2

08026a36 <arm_bitreversal_16_0>:
arm_bitreversal_16_0 LABEL       ;/* loop unrolled by 2 */
	LDRH     r8,[r1,#4]
 8026a36:	f8b1 8004 	ldrh.w	r8, [r1, #4]
	LDRH     r9,[r1,#2]
 8026a3a:	f8b1 9002 	ldrh.w	r9, [r1, #2]
	LDRH     r2,[r1,#0]
 8026a3e:	880a      	ldrh	r2, [r1, #0]
	LDRH     r12,[r1,#-2]
 8026a40:	f831 cc02 	ldrh.w	ip, [r1, #-2]
	ADD      r8,r0,r8,LSR #1
 8026a44:	eb00 0858 	add.w	r8, r0, r8, lsr #1
	ADD      r9,r0,r9,LSR #1
 8026a48:	eb00 0959 	add.w	r9, r0, r9, lsr #1
	ADD      r2,r0,r2,LSR #1
 8026a4c:	eb00 0252 	add.w	r2, r0, r2, lsr #1
	ADD      r12,r0,r12,LSR #1
 8026a50:	eb00 0c5c 	add.w	ip, r0, ip, lsr #1
	LDR      r7,[r9,#0]
 8026a54:	f8d9 7000 	ldr.w	r7, [r9]
	LDR      r6,[r8,#0]
 8026a58:	f8d8 6000 	ldr.w	r6, [r8]
	LDR      r5,[r2,#0]
 8026a5c:	6815      	ldr	r5, [r2, #0]
	LDR      r4,[r12,#0]
 8026a5e:	f8dc 4000 	ldr.w	r4, [ip]
	STR      r6,[r9,#0]
 8026a62:	f8c9 6000 	str.w	r6, [r9]
	STR      r7,[r8,#0]
 8026a66:	f8c8 7000 	str.w	r7, [r8]
	STR      r5,[r12,#0]
 8026a6a:	f8cc 5000 	str.w	r5, [ip]
	STR      r4,[r2,#0]
 8026a6e:	6014      	str	r4, [r2, #0]
	ADDS     r1,r1,#8
 8026a70:	3108      	adds	r1, #8
	SUBS     r3,r3,#1
 8026a72:	3b01      	subs	r3, #1
	BNE      arm_bitreversal_16_0
 8026a74:	d1df      	bne.n	8026a36 <arm_bitreversal_16_0>
	POP      {r4-r9}
 8026a76:	e8bd 03f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9}
	BX       lr
 8026a7a:	4770      	bx	lr

08026a7c <arm_cfft_radix8by2_f32>:
* \endcode
*
*/

void arm_cfft_radix8by2_f32( arm_cfft_instance_f32 * S, float32_t * p1)
{
 8026a7c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    uint32_t    L  = S->fftLen;
 8026a80:	f8b0 e000 	ldrh.w	lr, [r0]
    float32_t * pCol1, * pCol2, * pMid1, * pMid2;
    float32_t * p2 = p1 + L;
    const float32_t * tw = (float32_t *) S->pTwiddle;
 8026a84:	6842      	ldr	r2, [r0, #4]
* \endcode
*
*/

void arm_cfft_radix8by2_f32( arm_cfft_instance_f32 * S, float32_t * p1)
{
 8026a86:	4680      	mov	r8, r0
    uint32_t    L  = S->fftLen;
    float32_t * pCol1, * pCol2, * pMid1, * pMid2;
    float32_t * p2 = p1 + L;
 8026a88:	eb01 098e 	add.w	r9, r1, lr, lsl #2

    pCol1 = p1;
    pCol2 = p2;

    //    Define new length
    L >>= 1;
 8026a8c:	ea4f 005e 	mov.w	r0, lr, lsr #1
    //    Initialize mid pointers
    pMid1 = p1 + L;
    pMid2 = p2 + L;

    // do two dot Fourier transform
    for ( l = L >> 2; l > 0; l-- )
 8026a90:	ea5f 0ede 	movs.w	lr, lr, lsr #3
* \endcode
*
*/

void arm_cfft_radix8by2_f32( arm_cfft_instance_f32 * S, float32_t * p1)
{
 8026a94:	ed2d 8b08 	vpush	{d8-d11}
    pCol2 = p2;

    //    Define new length
    L >>= 1;
    //    Initialize mid pointers
    pMid1 = p1 + L;
 8026a98:	ea4f 0380 	mov.w	r3, r0, lsl #2
    pMid2 = p2 + L;

    // do two dot Fourier transform
    for ( l = L >> 2; l > 0; l-- )
 8026a9c:	f000 809f 	beq.w	8026bde <arm_cfft_radix8by2_f32+0x162>
 8026aa0:	3310      	adds	r3, #16
 8026aa2:	18ce      	adds	r6, r1, r3
 8026aa4:	f101 0510 	add.w	r5, r1, #16
 8026aa8:	444b      	add	r3, r9
 8026aaa:	f102 0710 	add.w	r7, r2, #16
 8026aae:	f109 0410 	add.w	r4, r9, #16
        t1[0] = p1[0];
        t1[1] = p1[1];
        t1[2] = p1[2];
        t1[3] = p1[3];

        t2[0] = p2[0];
 8026ab2:	ed14 2a04 	vldr	s4, [r4, #-16]
        t2[1] = p2[1];
 8026ab6:	ed54 2a03 	vldr	s5, [r4, #-12]
        t3[0] = pMid1[0];
        t3[1] = pMid1[1];
        t3[2] = pMid1[2];
        t3[3] = pMid1[3];

        t4[0] = pMid2[0];
 8026aba:	ed13 5a04 	vldr	s10, [r3, #-16]
        t4[1] = pMid2[1];
 8026abe:	ed53 5a03 	vldr	s11, [r3, #-12]
        t1[2] = p1[2];
        t1[3] = p1[3];

        t2[0] = p2[0];
        t2[1] = p2[1];
        t2[2] = p2[2];
 8026ac2:	ed54 8a02 	vldr	s17, [r4, #-8]
        t2[3] = p2[3];

        t3[0] = pMid1[0];
 8026ac6:	ed16 3a04 	vldr	s6, [r6, #-16]
        t3[1] = pMid1[1];
 8026aca:	ed56 3a03 	vldr	s7, [r6, #-12]
        t3[2] = pMid1[2];
        t3[3] = pMid1[3];

        t4[0] = pMid2[0];
        t4[1] = pMid2[1];
        t4[2] = pMid2[2];
 8026ace:	ed13 7a02 	vldr	s14, [r3, #-8]
        t4[3] = pMid2[3];
 8026ad2:	ed53 7a01 	vldr	s15, [r3, #-4]
    pMid2 = p2 + L;

    // do two dot Fourier transform
    for ( l = L >> 2; l > 0; l-- )
    {
        t1[0] = p1[0];
 8026ad6:	ed55 4a04 	vldr	s9, [r5, #-16]
        t1[3] = p1[3];

        t2[0] = p2[0];
        t2[1] = p2[1];
        t2[2] = p2[2];
        t2[3] = p2[3];
 8026ada:	ed14 8a01 	vldr	s16, [r4, #-4]

        t3[0] = pMid1[0];
        t3[1] = pMid1[1];
        t3[2] = pMid1[2];
 8026ade:	ed16 0a02 	vldr	s0, [r6, #-8]
        t3[3] = pMid1[3];
 8026ae2:	ed56 0a01 	vldr	s1, [r6, #-4]

    // do two dot Fourier transform
    for ( l = L >> 2; l > 0; l-- )
    {
        t1[0] = p1[0];
        t1[1] = p1[1];
 8026ae6:	ed15 4a03 	vldr	s8, [r5, #-12]
        t1[2] = p1[2];
 8026aea:	ed55 6a02 	vldr	s13, [r5, #-8]
        t1[3] = p1[3];
 8026aee:	ed15 6a01 	vldr	s12, [r5, #-4]
        t4[0] = pMid2[0];
        t4[1] = pMid2[1];
        t4[2] = pMid2[2];
        t4[3] = pMid2[3];

        *p1++ = t1[0] + t2[0];
 8026af2:	ee74 ba82 	vadd.f32	s23, s9, s4
        *p1++ = t1[1] + t2[1];
 8026af6:	ee34 ba22 	vadd.f32	s22, s8, s5
        t2[0] = t1[0] - t2[0];
        t2[1] = t1[1] - t2[1];
        t2[2] = t1[2] - t2[2];
        t2[3] = t1[3] - t2[3];    // for col 2

        *pMid1++ = t3[0] + t4[0];
 8026afa:	ee73 9a05 	vadd.f32	s19, s6, s10
        *pMid1++ = t3[1] + t4[1];
 8026afe:	ee33 9aa5 	vadd.f32	s18, s7, s11
        *pMid1++ = t3[2] + t4[2];
 8026b02:	ee30 1a07 	vadd.f32	s2, s0, s14
        *pMid1++ = t3[3] + t4[3]; // col 1
 8026b06:	ee70 1aa7 	vadd.f32	s3, s1, s15
        t4[2] = pMid2[2];
        t4[3] = pMid2[3];

        *p1++ = t1[0] + t2[0];
        *p1++ = t1[1] + t2[1];
        *p1++ = t1[2] + t2[2];
 8026b0a:	ee76 aaa8 	vadd.f32	s21, s13, s17
        *p1++ = t1[3] + t2[3];    // col 1
 8026b0e:	ee36 aa08 	vadd.f32	s20, s12, s16
        t4[0] = pMid2[0];
        t4[1] = pMid2[1];
        t4[2] = pMid2[2];
        t4[3] = pMid2[3];

        *p1++ = t1[0] + t2[0];
 8026b12:	ed45 ba04 	vstr	s23, [r5, #-16]
        *p1++ = t1[1] + t2[1];
 8026b16:	ed05 ba03 	vstr	s22, [r5, #-12]
        *p1++ = t1[2] + t2[2];
 8026b1a:	ed45 aa02 	vstr	s21, [r5, #-8]
        *p1++ = t1[3] + t2[3];    // col 1
 8026b1e:	ed05 aa01 	vstr	s20, [r5, #-4]
        t2[2] = t1[2] - t2[2];
        t2[3] = t1[3] - t2[3];    // for col 2

        *pMid1++ = t3[0] + t4[0];
        *pMid1++ = t3[1] + t4[1];
        *pMid1++ = t3[2] + t4[2];
 8026b22:	ed06 1a02 	vstr	s2, [r6, #-8]
        *pMid1++ = t3[3] + t4[3]; // col 1
 8026b26:	ed46 1a01 	vstr	s3, [r6, #-4]
        t2[0] = t1[0] - t2[0];
        t2[1] = t1[1] - t2[1];
        t2[2] = t1[2] - t2[2];
        t2[3] = t1[3] - t2[3];    // for col 2

        *pMid1++ = t3[0] + t4[0];
 8026b2a:	ed46 9a04 	vstr	s19, [r6, #-16]
        *pMid1++ = t3[1] + t4[1];
 8026b2e:	ed06 9a03 	vstr	s18, [r6, #-12]
        *p1++ = t1[0] + t2[0];
        *p1++ = t1[1] + t2[1];
        *p1++ = t1[2] + t2[2];
        *p1++ = t1[3] + t2[3];    // col 1

        t2[0] = t1[0] - t2[0];
 8026b32:	ee74 4ac2 	vsub.f32	s9, s9, s4
        t2[1] = t1[1] - t2[1];
 8026b36:	ee34 4a62 	vsub.f32	s8, s8, s5
        *pMid1++ = t3[0] + t4[0];
        *pMid1++ = t3[1] + t4[1];
        *pMid1++ = t3[2] + t4[2];
        *pMid1++ = t3[3] + t4[3]; // col 1

        t4[0] = t4[0] - t3[0];
 8026b3a:	ee35 5a43 	vsub.f32	s10, s10, s6
        t4[1] = t4[1] - t3[1];
 8026b3e:	ee75 5ae3 	vsub.f32	s11, s11, s7
        t4[2] = t4[2] - t3[2];
        t4[3] = t4[3] - t3[3];    // for col 2

        twR = *tw++;
 8026b42:	ed17 3a04 	vldr	s6, [r7, #-16]
        twI = *tw++;
 8026b46:	ed57 3a03 	vldr	s7, [r7, #-12]
 8026b4a:	ee23 2a65 	vnmul.f32	s4, s6, s11

        // multiply by twiddle factors
        m0 = t2[0] * twR;
        m1 = t2[1] * twI;
 8026b4e:	ee64 1a23 	vmul.f32	s3, s8, s7
 8026b52:	ee23 1ae4 	vnmul.f32	s2, s7, s9
        // use vertical symmetry
        //  0.9988 - 0.0491i <==> -0.0491 - 0.9988i
        m0 = t4[0] * twI;
        m1 = t4[1] * twR;
        m2 = t4[1] * twI;
        m3 = t4[0] * twR;
 8026b56:	ee65 2a03 	vmul.f32	s5, s10, s6
        m3 = t2[0] * twI;

        // R  =  R  *  Tr - I * Ti
        *p2++ = m0 + m1;
        // I  =  I  *  Tr + R * Ti
        *p2++ = m2 - m3;
 8026b5a:	eea4 1a03 	vfma.f32	s2, s8, s6
    //    Initialize mid pointers
    pMid1 = p1 + L;
    pMid2 = p2 + L;

    // do two dot Fourier transform
    for ( l = L >> 2; l > 0; l-- )
 8026b5e:	f1be 0e01 	subs.w	lr, lr, #1
 8026b62:	f105 0510 	add.w	r5, r5, #16
        m1 = t2[1] * twI;
        m2 = t2[1] * twR;
        m3 = t2[0] * twI;

        // R  =  R  *  Tr - I * Ti
        *p2++ = m0 + m1;
 8026b66:	eee4 1a83 	vfma.f32	s3, s9, s6
 8026b6a:	f106 0610 	add.w	r6, r6, #16
 8026b6e:	f107 0710 	add.w	r7, r7, #16
        m0 = t4[0] * twI;
        m1 = t4[1] * twR;
        m2 = t4[1] * twI;
        m3 = t4[0] * twR;

        *pMid2++ = m0 - m1;
 8026b72:	eea5 2a23 	vfma.f32	s4, s10, s7
 8026b76:	f104 0410 	add.w	r4, r4, #16
 8026b7a:	f103 0310 	add.w	r3, r3, #16
        *pMid2++ = m2 + m3;
 8026b7e:	eee5 2aa3 	vfma.f32	s5, s11, s7
        m3 = t2[0] * twI;

        // R  =  R  *  Tr - I * Ti
        *p2++ = m0 + m1;
        // I  =  I  *  Tr + R * Ti
        *p2++ = m2 - m3;
 8026b82:	ed04 1a07 	vstr	s2, [r4, #-28]	; 0xffffffe4
        m1 = t2[1] * twI;
        m2 = t2[1] * twR;
        m3 = t2[0] * twI;

        // R  =  R  *  Tr - I * Ti
        *p2++ = m0 + m1;
 8026b86:	ed44 1a08 	vstr	s3, [r4, #-32]	; 0xffffffe0
        m0 = t4[0] * twI;
        m1 = t4[1] * twR;
        m2 = t4[1] * twI;
        m3 = t4[0] * twR;

        *pMid2++ = m0 - m1;
 8026b8a:	ed03 2a08 	vstr	s4, [r3, #-32]	; 0xffffffe0
        *pMid2++ = m2 + m3;
 8026b8e:	ed43 2a07 	vstr	s5, [r3, #-28]	; 0xffffffe4

        twR = *tw++;
        twI = *tw++;
 8026b92:	ed57 5a05 	vldr	s11, [r7, #-20]	; 0xffffffec
        m3 = t4[0] * twR;

        *pMid2++ = m0 - m1;
        *pMid2++ = m2 + m3;

        twR = *tw++;
 8026b96:	ed17 5a06 	vldr	s10, [r7, #-24]	; 0xffffffe8
        *p1++ = t1[2] + t2[2];
        *p1++ = t1[3] + t2[3];    // col 1

        t2[0] = t1[0] - t2[0];
        t2[1] = t1[1] - t2[1];
        t2[2] = t1[2] - t2[2];
 8026b9a:	ee76 6ae8 	vsub.f32	s13, s13, s17
        t2[3] = t1[3] - t2[3];    // for col 2
 8026b9e:	ee36 6a48 	vsub.f32	s12, s12, s16
        *pMid1++ = t3[2] + t4[2];
        *pMid1++ = t3[3] + t4[3]; // col 1

        t4[0] = t4[0] - t3[0];
        t4[1] = t4[1] - t3[1];
        t4[2] = t4[2] - t3[2];
 8026ba2:	ee37 7a40 	vsub.f32	s14, s14, s0
        t4[3] = t4[3] - t3[3];    // for col 2
 8026ba6:	ee77 7ae0 	vsub.f32	s15, s15, s1

        twR = *tw++;
        twI = *tw++;

        m0 = t2[2] * twR;
        m1 = t2[3] * twI;
 8026baa:	ee26 3a25 	vmul.f32	s6, s12, s11
 8026bae:	ee65 3ae6 	vnmul.f32	s7, s11, s13
 8026bb2:	ee25 4a67 	vnmul.f32	s8, s10, s15
        *p2++ = m2 - m3;

        m0 = t4[2] * twI;
        m1 = t4[3] * twR;
        m2 = t4[3] * twI;
        m3 = t4[2] * twR;
 8026bb6:	ee67 4a05 	vmul.f32	s9, s14, s10
        m1 = t2[3] * twI;
        m2 = t2[3] * twR;
        m3 = t2[2] * twI;

        *p2++ = m0 + m1;
        *p2++ = m2 - m3;
 8026bba:	eee6 3a05 	vfma.f32	s7, s12, s10
        m0 = t2[2] * twR;
        m1 = t2[3] * twI;
        m2 = t2[3] * twR;
        m3 = t2[2] * twI;

        *p2++ = m0 + m1;
 8026bbe:	eea6 3a85 	vfma.f32	s6, s13, s10
        m0 = t4[2] * twI;
        m1 = t4[3] * twR;
        m2 = t4[3] * twI;
        m3 = t4[2] * twR;

        *pMid2++ = m0 - m1;
 8026bc2:	eea7 4a25 	vfma.f32	s8, s14, s11
        *pMid2++ = m2 + m3;
 8026bc6:	eee7 4aa5 	vfma.f32	s9, s15, s11
        m0 = t2[2] * twR;
        m1 = t2[3] * twI;
        m2 = t2[3] * twR;
        m3 = t2[2] * twI;

        *p2++ = m0 + m1;
 8026bca:	ed04 3a06 	vstr	s6, [r4, #-24]	; 0xffffffe8
        *p2++ = m2 - m3;
 8026bce:	ed44 3a05 	vstr	s7, [r4, #-20]	; 0xffffffec
        m0 = t4[2] * twI;
        m1 = t4[3] * twR;
        m2 = t4[3] * twI;
        m3 = t4[2] * twR;

        *pMid2++ = m0 - m1;
 8026bd2:	ed03 4a06 	vstr	s8, [r3, #-24]	; 0xffffffe8
        *pMid2++ = m2 + m3;
 8026bd6:	ed43 4a05 	vstr	s9, [r3, #-20]	; 0xffffffec
    //    Initialize mid pointers
    pMid1 = p1 + L;
    pMid2 = p2 + L;

    // do two dot Fourier transform
    for ( l = L >> 2; l > 0; l-- )
 8026bda:	f47f af6a 	bne.w	8026ab2 <arm_cfft_radix8by2_f32+0x36>
        *pMid2++ = m0 - m1;
        *pMid2++ = m2 + m3;
    }

    // first col
    arm_radix8_butterfly_f32( pCol1, L, (float32_t *) S->pTwiddle, 2u);
 8026bde:	b284      	uxth	r4, r0
 8026be0:	2302      	movs	r3, #2
 8026be2:	4608      	mov	r0, r1
 8026be4:	4621      	mov	r1, r4
 8026be6:	f000 fac5 	bl	8027174 <arm_radix8_butterfly_f32>
    // second col
    arm_radix8_butterfly_f32( pCol2, L, (float32_t *) S->pTwiddle, 2u);
}
 8026bea:	ecbd 8b08 	vpop	{d8-d11}
    }

    // first col
    arm_radix8_butterfly_f32( pCol1, L, (float32_t *) S->pTwiddle, 2u);
    // second col
    arm_radix8_butterfly_f32( pCol2, L, (float32_t *) S->pTwiddle, 2u);
 8026bee:	4648      	mov	r0, r9
 8026bf0:	4621      	mov	r1, r4
 8026bf2:	f8d8 2004 	ldr.w	r2, [r8, #4]
 8026bf6:	2302      	movs	r3, #2
}
 8026bf8:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    }

    // first col
    arm_radix8_butterfly_f32( pCol1, L, (float32_t *) S->pTwiddle, 2u);
    // second col
    arm_radix8_butterfly_f32( pCol2, L, (float32_t *) S->pTwiddle, 2u);
 8026bfc:	f000 baba 	b.w	8027174 <arm_radix8_butterfly_f32>

08026c00 <arm_cfft_radix8by4_f32>:
}

void arm_cfft_radix8by4_f32( arm_cfft_instance_f32 * S, float32_t * p1)
{
 8026c00:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8026c04:	ed2d 8b0a 	vpush	{d8-d12}
    uint32_t    L  = S->fftLen >> 1;
 8026c08:	8804      	ldrh	r4, [r0, #0]
    pEnd1 = p2 - 1;     // points to imaginary values by default
    pEnd2 = p3 - 1;
    pEnd3 = p4 - 1;
    pEnd4 = pEnd3 + L;

    tw2 = tw3 = tw4 = (float32_t *) S->pTwiddle;
 8026c0a:	6843      	ldr	r3, [r0, #4]
    twMod2 = 2;
    twMod3 = 4;
    twMod4 = 6;

    // TOP
    p1ap3_0 = p1[0] + p3[0];
 8026c0c:	ed91 6a00 	vldr	s12, [r1]
    p1sp3_0 = p1[0] - p3[0];
    p1ap3_1 = p1[1] + p3[1];
 8026c10:	ed91 7a01 	vldr	s14, [r1, #4]
    // second col
    arm_radix8_butterfly_f32( pCol2, L, (float32_t *) S->pTwiddle, 2u);
}

void arm_cfft_radix8by4_f32( arm_cfft_instance_f32 * S, float32_t * p1)
{
 8026c14:	b08f      	sub	sp, #60	; 0x3c
    uint32_t    L  = S->fftLen >> 1;
 8026c16:	0864      	lsrs	r4, r4, #1
    pEnd1 = p2 - 1;     // points to imaginary values by default
    pEnd2 = p3 - 1;
    pEnd3 = p4 - 1;
    pEnd4 = pEnd3 + L;

    tw2 = tw3 = tw4 = (float32_t *) S->pTwiddle;
 8026c18:	9301      	str	r3, [sp, #4]
    twMod4 = 6;

    // TOP
    p1ap3_0 = p1[0] + p3[0];
    p1sp3_0 = p1[0] - p3[0];
    p1ap3_1 = p1[1] + p3[1];
 8026c1a:	460a      	mov	r2, r1
void arm_cfft_radix8by4_f32( arm_cfft_instance_f32 * S, float32_t * p1)
{
    uint32_t    L  = S->fftLen >> 1;
    float32_t * pCol1, *pCol2, *pCol3, *pCol4, *pEnd1, *pEnd2, *pEnd3, *pEnd4;
    const float32_t *tw2, *tw3, *tw4;
    float32_t * p2 = p1 + L;
 8026c1c:	00a3      	lsls	r3, r4, #2
 8026c1e:	441a      	add	r2, r3
 8026c20:	4615      	mov	r5, r2
 8026c22:	9208      	str	r2, [sp, #32]
    float32_t * p3 = p2 + L;
 8026c24:	441a      	add	r2, r3
    twMod2 = 2;
    twMod3 = 4;
    twMod4 = 6;

    // TOP
    p1ap3_0 = p1[0] + p3[0];
 8026c26:	edd2 6a00 	vldr	s13, [r2]
    p1ap3_1 = p1[1] + p3[1];
    p1sp3_1 = p1[1] - p3[1];

    // col 2
    t2[0] = p1sp3_0 + p2[1] - p4[1];
    t2[1] = p1sp3_1 - p2[0] + p4[0];
 8026c2a:	edd5 3a00 	vldr	s7, [r5]
    // second col
    arm_radix8_butterfly_f32( pCol2, L, (float32_t *) S->pTwiddle, 2u);
}

void arm_cfft_radix8by4_f32( arm_cfft_instance_f32 * S, float32_t * p1)
{
 8026c2e:	910c      	str	r1, [sp, #48]	; 0x30
 8026c30:	460e      	mov	r6, r1
    twMod2 = 2;
    twMod3 = 4;
    twMod4 = 6;

    // TOP
    p1ap3_0 = p1[0] + p3[0];
 8026c32:	ee76 5a26 	vadd.f32	s11, s12, s13
    p1sp3_0 = p1[0] - p3[0];
    p1ap3_1 = p1[1] + p3[1];
 8026c36:	4611      	mov	r1, r2
    // second col
    arm_radix8_butterfly_f32( pCol2, L, (float32_t *) S->pTwiddle, 2u);
}

void arm_cfft_radix8by4_f32( arm_cfft_instance_f32 * S, float32_t * p1)
{
 8026c38:	900b      	str	r0, [sp, #44]	; 0x2c
    uint32_t    L  = S->fftLen >> 1;
    float32_t * pCol1, *pCol2, *pCol3, *pCol4, *pEnd1, *pEnd2, *pEnd3, *pEnd4;
    const float32_t *tw2, *tw3, *tw4;
    float32_t * p2 = p1 + L;
    float32_t * p3 = p2 + L;
    float32_t * p4 = p3 + L;
 8026c3a:	4608      	mov	r0, r1
 8026c3c:	4419      	add	r1, r3
    p1ap3_1 = p1[1] + p3[1];
    p1sp3_1 = p1[1] - p3[1];

    // col 2
    t2[0] = p1sp3_0 + p2[1] - p4[1];
    t2[1] = p1sp3_1 - p2[0] + p4[0];
 8026c3e:	ed91 4a00 	vldr	s8, [r1]
    p1sp3_0 = p1[0] - p3[0];
    p1ap3_1 = p1[1] + p3[1];
    p1sp3_1 = p1[1] - p3[1];

    // col 2
    t2[0] = p1sp3_0 + p2[1] - p4[1];
 8026c42:	edd5 2a01 	vldr	s5, [r5, #4]
    twMod4 = 6;

    // TOP
    p1ap3_0 = p1[0] + p3[0];
    p1sp3_0 = p1[0] - p3[0];
    p1ap3_1 = p1[1] + p3[1];
 8026c46:	edd2 7a01 	vldr	s15, [r2, #4]
{
    uint32_t    L  = S->fftLen >> 1;
    float32_t * pCol1, *pCol2, *pCol3, *pCol4, *pEnd1, *pEnd2, *pEnd3, *pEnd4;
    const float32_t *tw2, *tw3, *tw4;
    float32_t * p2 = p1 + L;
    float32_t * p3 = p2 + L;
 8026c4a:	9209      	str	r2, [sp, #36]	; 0x24
    t3[1] = p1ap3_1 - p2[1] - p4[1];
    // col 4
    t4[0] = p1sp3_0 - p2[1] + p4[1];
    t4[1] = p1sp3_1 + p2[0] - p4[0];
    // col 1
    *p1++ = p1ap3_0 + p2[0] + p4[0];
 8026c4c:	ee75 4aa3 	vadd.f32	s9, s11, s7
    p1sp3_0 = p1[0] - p3[0];
    p1ap3_1 = p1[1] + p3[1];
    p1sp3_1 = p1[1] - p3[1];

    // col 2
    t2[0] = p1sp3_0 + p2[1] - p4[1];
 8026c50:	462a      	mov	r2, r5
    t3[1] = p1ap3_1 - p2[1] - p4[1];
    // col 4
    t4[0] = p1sp3_0 - p2[1] + p4[1];
    t4[1] = p1sp3_1 + p2[0] - p4[0];
    // col 1
    *p1++ = p1ap3_0 + p2[0] + p4[0];
 8026c52:	ee74 4a24 	vadd.f32	s9, s8, s9
 8026c56:	4635      	mov	r5, r6
 8026c58:	ee14 ea90 	vmov	lr, s9
    p1sp3_0 = p1[0] - p3[0];
    p1ap3_1 = p1[1] + p3[1];
    p1sp3_1 = p1[1] - p3[1];

    // col 2
    t2[0] = p1sp3_0 + p2[1] - p4[1];
 8026c5c:	ed91 5a01 	vldr	s10, [r1, #4]
    t3[1] = p1ap3_1 - p2[1] - p4[1];
    // col 4
    t4[0] = p1sp3_0 - p2[1] + p4[1];
    t4[1] = p1sp3_1 + p2[0] - p4[0];
    // col 1
    *p1++ = p1ap3_0 + p2[0] + p4[0];
 8026c60:	f845 eb08 	str.w	lr, [r5], #8
    twMod3 = 4;
    twMod4 = 6;

    // TOP
    p1ap3_0 = p1[0] + p3[0];
    p1sp3_0 = p1[0] - p3[0];
 8026c64:	ee76 6a66 	vsub.f32	s13, s12, s13
    // col 4
    t4[0] = p1sp3_0 - p2[1] + p4[1];
    t4[1] = p1sp3_1 + p2[0] - p4[0];
    // col 1
    *p1++ = p1ap3_0 + p2[0] + p4[0];
    *p1++ = p1ap3_1 + p2[1] + p4[1];
 8026c68:	edd2 4a01 	vldr	s9, [r2, #4]
    uint32_t    L  = S->fftLen >> 1;
    float32_t * pCol1, *pCol2, *pCol3, *pCol4, *pEnd1, *pEnd2, *pEnd3, *pEnd4;
    const float32_t *tw2, *tw3, *tw4;
    float32_t * p2 = p1 + L;
    float32_t * p3 = p2 + L;
    float32_t * p4 = p3 + L;
 8026c6c:	9100      	str	r1, [sp, #0]
    twMod4 = 6;

    // TOP
    p1ap3_0 = p1[0] + p3[0];
    p1sp3_0 = p1[0] - p3[0];
    p1ap3_1 = p1[1] + p3[1];
 8026c6e:	ee37 6a27 	vadd.f32	s12, s14, s15
    p1sp3_1 = p1[1] - p3[1];

    // col 2
    t2[0] = p1sp3_0 + p2[1] - p4[1];
 8026c72:	460f      	mov	r7, r1
    // col 4
    t4[0] = p1sp3_0 - p2[1] + p4[1];
    t4[1] = p1sp3_1 + p2[0] - p4[0];
    // col 1
    *p1++ = p1ap3_0 + p2[0] + p4[0];
    *p1++ = p1ap3_1 + p2[1] + p4[1];
 8026c74:	ed97 2a01 	vldr	s4, [r7, #4]
    t3[1] = p1ap3_1 - p2[1] - p4[1];
    // col 4
    t4[0] = p1sp3_0 - p2[1] + p4[1];
    t4[1] = p1sp3_1 + p2[0] - p4[0];
    // col 1
    *p1++ = p1ap3_0 + p2[0] + p4[0];
 8026c78:	9503      	str	r5, [sp, #12]

    // TOP
    p1ap3_0 = p1[0] + p3[0];
    p1sp3_0 = p1[0] - p3[0];
    p1ap3_1 = p1[1] + p3[1];
    p1sp3_1 = p1[1] - p3[1];
 8026c7a:	ee77 7a67 	vsub.f32	s15, s14, s15

    // col 2
    t2[0] = p1sp3_0 + p2[1] - p4[1];
 8026c7e:	ee32 3aa6 	vadd.f32	s6, s5, s13
    // col 4
    t4[0] = p1sp3_0 - p2[1] + p4[1];
    t4[1] = p1sp3_1 + p2[0] - p4[0];
    // col 1
    *p1++ = p1ap3_0 + p2[0] + p4[0];
    *p1++ = p1ap3_1 + p2[1] + p4[1];
 8026c82:	ee36 7a24 	vadd.f32	s14, s12, s9

    // col 2
    t2[0] = p1sp3_0 + p2[1] - p4[1];
    t2[1] = p1sp3_1 - p2[0] + p4[0];
    // col 3
    t3[0] = p1ap3_0 - p2[0] - p4[0];
 8026c86:	ee75 5ae3 	vsub.f32	s11, s11, s7
    p1ap3_1 = p1[1] + p3[1];
    p1sp3_1 = p1[1] - p3[1];

    // col 2
    t2[0] = p1sp3_0 + p2[1] - p4[1];
    t2[1] = p1sp3_1 - p2[0] + p4[0];
 8026c8a:	ee77 4ae3 	vsub.f32	s9, s15, s7
    // col 3
    t3[0] = p1ap3_0 - p2[0] - p4[0];
    t3[1] = p1ap3_1 - p2[1] - p4[1];
 8026c8e:	ee36 6a62 	vsub.f32	s12, s12, s5
    // col 4
    t4[0] = p1sp3_0 - p2[1] + p4[1];
    t4[1] = p1sp3_1 + p2[0] - p4[0];
 8026c92:	ee77 7aa3 	vadd.f32	s15, s15, s7
    t2[1] = p1sp3_1 - p2[0] + p4[0];
    // col 3
    t3[0] = p1ap3_0 - p2[0] - p4[0];
    t3[1] = p1ap3_1 - p2[1] - p4[1];
    // col 4
    t4[0] = p1sp3_0 - p2[1] + p4[1];
 8026c96:	ee76 6ae2 	vsub.f32	s13, s13, s5
    p1sp3_0 = p1[0] - p3[0];
    p1ap3_1 = p1[1] + p3[1];
    p1sp3_1 = p1[1] - p3[1];

    // col 2
    t2[0] = p1sp3_0 + p2[1] - p4[1];
 8026c9a:	ee73 3a45 	vsub.f32	s7, s6, s10
    // col 4
    t4[0] = p1sp3_0 - p2[1] + p4[1];
    t4[1] = p1sp3_1 + p2[0] - p4[0];
    // col 1
    *p1++ = p1ap3_0 + p2[0] + p4[0];
    *p1++ = p1ap3_1 + p2[1] + p4[1];
 8026c9e:	ee37 7a02 	vadd.f32	s14, s14, s4
 8026ca2:	4611      	mov	r1, r2
 8026ca4:	ed86 7a01 	vstr	s14, [r6, #4]
    pEnd3 = p4 - 1;
    pEnd4 = pEnd3 + L;

    tw2 = tw3 = tw4 = (float32_t *) S->pTwiddle;

    L >>= 1;
 8026ca8:	0862      	lsrs	r2, r4, #1
    // col 2
    t2[0] = p1sp3_0 + p2[1] - p4[1];
    t2[1] = p1sp3_1 - p2[0] + p4[0];
    // col 3
    t3[0] = p1ap3_0 - p2[0] - p4[0];
    t3[1] = p1ap3_1 - p2[1] - p4[1];
 8026caa:	ee36 6a45 	vsub.f32	s12, s12, s10
    *p3++ = t3[0];
    *p3++ = t3[1];
    *p4++ = t4[0];
    *p4++ = t4[1];

    tw2 += twMod2;
 8026cae:	9c01      	ldr	r4, [sp, #4]
    pEnd3 = p4 - 1;
    pEnd4 = pEnd3 + L;

    tw2 = tw3 = tw4 = (float32_t *) S->pTwiddle;

    L >>= 1;
 8026cb0:	920a      	str	r2, [sp, #40]	; 0x28
    t2[1] = p1sp3_1 - p2[0] + p4[0];
    // col 3
    t3[0] = p1ap3_0 - p2[0] - p4[0];
    t3[1] = p1ap3_1 - p2[1] - p4[1];
    // col 4
    t4[0] = p1sp3_0 - p2[1] + p4[1];
 8026cb2:	ee75 6a26 	vadd.f32	s13, s10, s13
    // col 1
    *p1++ = p1ap3_0 + p2[0] + p4[0];
    *p1++ = p1ap3_1 + p2[1] + p4[1];

    // Twiddle factors are ones
    *p2++ = t2[0];
 8026cb6:	4688      	mov	r8, r1
    *p2++ = t2[1];
    *p3++ = t3[0];
    *p3++ = t3[1];
    *p4++ = t4[0];
 8026cb8:	46bc      	mov	ip, r7
    p1ap3_1 = p1[1] + p3[1];
    p1sp3_1 = p1[1] - p3[1];

    // col 2
    t2[0] = p1sp3_0 + p2[1] - p4[1];
    t2[1] = p1sp3_1 - p2[0] + p4[0];
 8026cba:	ee34 5a84 	vadd.f32	s10, s9, s8
    // col 4
    t4[0] = p1sp3_0 - p2[1] + p4[1];
    t4[1] = p1sp3_1 + p2[0] - p4[0];
    // col 1
    *p1++ = p1ap3_0 + p2[0] + p4[0];
    *p1++ = p1ap3_1 + p2[1] + p4[1];
 8026cbe:	4635      	mov	r5, r6
    pCol2 = p2;
    pCol3 = p3;
    pCol4 = p4;
    pEnd1 = p2 - 1;     // points to imaginary values by default
    pEnd2 = p3 - 1;
    pEnd3 = p4 - 1;
 8026cc0:	1f3e      	subs	r6, r7, #4
    // col 1
    *p1++ = p1ap3_0 + p2[0] + p4[0];
    *p1++ = p1ap3_1 + p2[1] + p4[1];

    // Twiddle factors are ones
    *p2++ = t2[0];
 8026cc2:	ee13 7a90 	vmov	r7, s7
 8026cc6:	468e      	mov	lr, r1

    // col 2
    t2[0] = p1sp3_0 + p2[1] - p4[1];
    t2[1] = p1sp3_1 - p2[0] + p4[0];
    // col 3
    t3[0] = p1ap3_0 - p2[0] - p4[0];
 8026cc8:	ee75 5ac4 	vsub.f32	s11, s11, s8
    // col 1
    *p1++ = p1ap3_0 + p2[0] + p4[0];
    *p1++ = p1ap3_1 + p2[1] + p4[1];

    // Twiddle factors are ones
    *p2++ = t2[0];
 8026ccc:	f848 7b08 	str.w	r7, [r8], #8
    *p2++ = t2[1];
 8026cd0:	ed8e 5a01 	vstr	s10, [lr, #4]

    pCol1 = p1;         // points to real values by default
    pCol2 = p2;
    pCol3 = p3;
    pCol4 = p4;
    pEnd1 = p2 - 1;     // points to imaginary values by default
 8026cd4:	f1ae 0704 	sub.w	r7, lr, #4
    *p3++ = t3[0];
    *p3++ = t3[1];
    *p4++ = t4[0];
    *p4++ = t4[1];

    tw2 += twMod2;
 8026cd8:	f104 0e08 	add.w	lr, r4, #8
    *p1++ = p1ap3_1 + p2[1] + p4[1];

    // Twiddle factors are ones
    *p2++ = t2[0];
    *p2++ = t2[1];
    *p3++ = t3[0];
 8026cdc:	4601      	mov	r1, r0
    *p3++ = t3[1];
    *p4++ = t4[0];
    *p4++ = t4[1];

    tw2 += twMod2;
 8026cde:	f8cd e010 	str.w	lr, [sp, #16]
    *p1++ = p1ap3_1 + p2[1] + p4[1];

    // Twiddle factors are ones
    *p2++ = t2[0];
    *p2++ = t2[1];
    *p3++ = t3[0];
 8026ce2:	ee15 ea90 	vmov	lr, s11
 8026ce6:	f841 eb08 	str.w	lr, [r1], #8
 8026cea:	9106      	str	r1, [sp, #24]
    *p3++ = t3[1];
    *p4++ = t4[0];
    *p4++ = t4[1];

    tw2 += twMod2;
    tw3 += twMod3;
 8026cec:	9901      	ldr	r1, [sp, #4]

    // Twiddle factors are ones
    *p2++ = t2[0];
    *p2++ = t2[1];
    *p3++ = t3[0];
    *p3++ = t3[1];
 8026cee:	ed80 6a01 	vstr	s12, [r0, #4]
    *p4++ = t4[0];
    *p4++ = t4[1];

    tw2 += twMod2;
    tw3 += twMod3;
 8026cf2:	f101 0e10 	add.w	lr, r1, #16
 8026cf6:	f8cd e008 	str.w	lr, [sp, #8]
    tw4 += twMod4;
 8026cfa:	f101 0e18 	add.w	lr, r1, #24
 8026cfe:	f8cd e014 	str.w	lr, [sp, #20]
    // col 3
    t3[0] = p1ap3_0 - p2[0] - p4[0];
    t3[1] = p1ap3_1 - p2[1] - p4[1];
    // col 4
    t4[0] = p1sp3_0 - p2[1] + p4[1];
    t4[1] = p1sp3_1 + p2[0] - p4[0];
 8026d02:	ee77 7ac4 	vsub.f32	s15, s15, s8

    tw2 += twMod2;
    tw3 += twMod3;
    tw4 += twMod4;

    for (l = (L - 2) >> 1; l > 0; l-- )
 8026d06:	3a02      	subs	r2, #2
    // Twiddle factors are ones
    *p2++ = t2[0];
    *p2++ = t2[1];
    *p3++ = t3[0];
    *p3++ = t3[1];
    *p4++ = t4[0];
 8026d08:	ee16 ea90 	vmov	lr, s13
    *p4++ = t4[1];
 8026d0c:	9c00      	ldr	r4, [sp, #0]
    // Twiddle factors are ones
    *p2++ = t2[0];
    *p2++ = t2[1];
    *p3++ = t3[0];
    *p3++ = t3[1];
    *p4++ = t4[0];
 8026d0e:	f84c eb08 	str.w	lr, [ip], #8

    tw2 += twMod2;
    tw3 += twMod3;
    tw4 += twMod4;

    for (l = (L - 2) >> 1; l > 0; l-- )
 8026d12:	0852      	lsrs	r2, r2, #1
    *p2++ = t2[0];
    *p2++ = t2[1];
    *p3++ = t3[0];
    *p3++ = t3[1];
    *p4++ = t4[0];
    *p4++ = t4[1];
 8026d14:	edc4 7a01 	vstr	s15, [r4, #4]

    tw2 += twMod2;
    tw3 += twMod3;
    tw4 += twMod4;

    for (l = (L - 2) >> 1; l > 0; l-- )
 8026d18:	9207      	str	r2, [sp, #28]
 8026d1a:	f000 811b 	beq.w	8026f54 <arm_cfft_radix8by4_f32+0x354>
 8026d1e:	4604      	mov	r4, r0
 8026d20:	3b08      	subs	r3, #8
 8026d22:	f8dd a008 	ldr.w	sl, [sp, #8]
 8026d26:	f8cd c034 	str.w	ip, [sp, #52]	; 0x34
 8026d2a:	4693      	mov	fp, r2
 8026d2c:	f101 0920 	add.w	r9, r1, #32
 8026d30:	f1a0 020c 	sub.w	r2, r0, #12
 8026d34:	f101 0e30 	add.w	lr, r1, #48	; 0x30
 8026d38:	4433      	add	r3, r6
 8026d3a:	3510      	adds	r5, #16
 8026d3c:	3410      	adds	r4, #16
 8026d3e:	4660      	mov	r0, ip
 8026d40:	4641      	mov	r1, r8
    {
        // TOP
        p1ap3_0 = p1[0] + p3[0];
 8026d42:	ed14 7a02 	vldr	s14, [r4, #-8]
 8026d46:	ed55 3a02 	vldr	s7, [r5, #-8]
        p1sp3_0 = p1[0] - p3[0];
        p1ap3_1 = p1[1] + p3[1];
        p1sp3_1 = p1[1] - p3[1];
        // col 2
        t2[0] = p1sp3_0 + p2[1] - p4[1];
        t2[1] = p1sp3_1 - p2[0] + p4[0];
 8026d4a:	edd1 5a00 	vldr	s11, [r1]
 8026d4e:	ed90 6a00 	vldr	s12, [r0]
    for (l = (L - 2) >> 1; l > 0; l-- )
    {
        // TOP
        p1ap3_0 = p1[0] + p3[0];
        p1sp3_0 = p1[0] - p3[0];
        p1ap3_1 = p1[1] + p3[1];
 8026d52:	ed54 6a01 	vldr	s13, [r4, #-4]
 8026d56:	ed15 5a01 	vldr	s10, [r5, #-4]
        p1sp3_1 = p1[1] - p3[1];
        // col 2
        t2[0] = p1sp3_0 + p2[1] - p4[1];
 8026d5a:	edd0 4a01 	vldr	s9, [r0, #4]
 8026d5e:	ed91 4a01 	vldr	s8, [r1, #4]
    tw4 += twMod4;

    for (l = (L - 2) >> 1; l > 0; l-- )
    {
        // TOP
        p1ap3_0 = p1[0] + p3[0];
 8026d62:	ee33 0a87 	vadd.f32	s0, s7, s14
        p1sp3_0 = p1[0] - p3[0];
        p1ap3_1 = p1[1] + p3[1];
 8026d66:	ee35 8a26 	vadd.f32	s16, s10, s13
        t3[1] = p1ap3_1 - p2[1] - p4[1];
        // col 4
        t4[0] = p1sp3_0 - p2[1] + p4[1];
        t4[1] = p1sp3_1 + p2[0] - p4[0];
        // col 1 - top
        *p1++ = p1ap3_0 + p2[0] + p4[0];
 8026d6a:	ee70 7a25 	vadd.f32	s15, s0, s11

    for (l = (L - 2) >> 1; l > 0; l-- )
    {
        // TOP
        p1ap3_0 = p1[0] + p3[0];
        p1sp3_0 = p1[0] - p3[0];
 8026d6e:	ee73 3ac7 	vsub.f32	s7, s7, s14
        t3[1] = p1ap3_1 - p2[1] - p4[1];
        // col 4
        t4[0] = p1sp3_0 - p2[1] + p4[1];
        t4[1] = p1sp3_1 + p2[0] - p4[0];
        // col 1 - top
        *p1++ = p1ap3_0 + p2[0] + p4[0];
 8026d72:	ee76 7a27 	vadd.f32	s15, s12, s15
    {
        // TOP
        p1ap3_0 = p1[0] + p3[0];
        p1sp3_0 = p1[0] - p3[0];
        p1ap3_1 = p1[1] + p3[1];
        p1sp3_1 = p1[1] - p3[1];
 8026d76:	ee35 5a66 	vsub.f32	s10, s10, s13
        t3[1] = p1ap3_1 - p2[1] - p4[1];
        // col 4
        t4[0] = p1sp3_0 - p2[1] + p4[1];
        t4[1] = p1sp3_1 + p2[0] - p4[0];
        // col 1 - top
        *p1++ = p1ap3_0 + p2[0] + p4[0];
 8026d7a:	ed45 7a02 	vstr	s15, [r5, #-8]
        *p1++ = p1ap3_1 + p2[1] + p4[1];
 8026d7e:	edd1 7a01 	vldr	s15, [r1, #4]
 8026d82:	ed90 7a01 	vldr	s14, [r0, #4]
 8026d86:	ee78 7a27 	vadd.f32	s15, s16, s15
        p1sp3_0 = p1[0] - p3[0];
        p1ap3_1 = p1[1] + p3[1];
        p1sp3_1 = p1[1] - p3[1];
        // col 2
        t2[0] = p1sp3_0 + p2[1] - p4[1];
        t2[1] = p1sp3_1 - p2[0] + p4[0];
 8026d8a:	ee35 aa65 	vsub.f32	s20, s10, s11
        // col 4
        t4[0] = p1sp3_0 - p2[1] + p4[1];
        t4[1] = p1sp3_1 + p2[0] - p4[0];
        // col 1 - top
        *p1++ = p1ap3_0 + p2[0] + p4[0];
        *p1++ = p1ap3_1 + p2[1] + p4[1];
 8026d8e:	ee77 7a87 	vadd.f32	s15, s15, s14
        p1sp3_0 = p1[0] - p3[0];
        p1ap3_1 = p1[1] + p3[1];
        p1sp3_1 = p1[1] - p3[1];
        // col 2
        t2[0] = p1sp3_0 + p2[1] - p4[1];
        t2[1] = p1sp3_1 - p2[0] + p4[0];
 8026d92:	ee3a aa06 	vadd.f32	s20, s20, s12
        // col 4
        t4[0] = p1sp3_0 - p2[1] + p4[1];
        t4[1] = p1sp3_1 + p2[0] - p4[0];
        // col 1 - top
        *p1++ = p1ap3_0 + p2[0] + p4[0];
        *p1++ = p1ap3_1 + p2[1] + p4[1];
 8026d96:	ed45 7a01 	vstr	s15, [r5, #-4]

        // BOTTOM
        p1ap3_1 = pEnd1[-1] + pEnd3[-1];
        p1sp3_1 = pEnd1[-1] - pEnd3[-1];
        p1ap3_0 = pEnd1[0] + pEnd3[0];
 8026d9a:	ed96 2a00 	vldr	s4, [r6]
 8026d9e:	ed97 1a00 	vldr	s2, [r7]
        p1sp3_0 = pEnd1[0] - pEnd3[0];
        // col 2
        t2[2] = pEnd2[0]  - pEnd4[0] + p1sp3_1;
 8026da2:	edd2 7a02 	vldr	s15, [r2, #8]
 8026da6:	ed93 7a02 	vldr	s14, [r3, #8]
        t2[3] = pEnd1[0] - pEnd3[0] - pEnd2[-1] + pEnd4[-1];
 8026daa:	edd3 2a01 	vldr	s5, [r3, #4]
        // col 1 - top
        *p1++ = p1ap3_0 + p2[0] + p4[0];
        *p1++ = p1ap3_1 + p2[1] + p4[1];

        // BOTTOM
        p1ap3_1 = pEnd1[-1] + pEnd3[-1];
 8026dae:	ed56 1a01 	vldr	s3, [r6, #-4]
        p1sp3_1 = pEnd1[-1] - pEnd3[-1];
        p1ap3_0 = pEnd1[0] + pEnd3[0];
        p1sp3_0 = pEnd1[0] - pEnd3[0];
        // col 2
        t2[2] = pEnd2[0]  - pEnd4[0] + p1sp3_1;
        t2[3] = pEnd1[0] - pEnd3[0] - pEnd2[-1] + pEnd4[-1];
 8026db2:	ed92 3a01 	vldr	s6, [r2, #4]
        // col 1 - top
        *p1++ = p1ap3_0 + p2[0] + p4[0];
        *p1++ = p1ap3_1 + p2[1] + p4[1];

        // BOTTOM
        p1ap3_1 = pEnd1[-1] + pEnd3[-1];
 8026db6:	ed57 9a01 	vldr	s19, [r7, #-4]
        p1sp3_1 = pEnd1[-1] - pEnd3[-1];
        p1ap3_0 = pEnd1[0] + pEnd3[0];
 8026dba:	ee71 6a02 	vadd.f32	s13, s2, s4
        // col 1 - top
        *p1++ = p1ap3_0 + p2[0] + p4[0];
        *p1++ = p1ap3_1 + p2[1] + p4[1];

        // BOTTOM
        p1ap3_1 = pEnd1[-1] + pEnd3[-1];
 8026dbe:	ee79 0aa1 	vadd.f32	s1, s19, s3
        t3[3] = p1ap3_0 - pEnd2[0]  - pEnd4[0];
        // col 4
        t4[2] = pEnd2[0]  - pEnd4[0]  - p1sp3_1;
        t4[3] = pEnd4[-1] - pEnd2[-1] - p1sp3_0;
        // col 1 - Bottom
        *pEnd1-- = p1ap3_0 + pEnd2[0] + pEnd4[0];
 8026dc2:	ee76 8aa7 	vadd.f32	s17, s13, s15

        // BOTTOM
        p1ap3_1 = pEnd1[-1] + pEnd3[-1];
        p1sp3_1 = pEnd1[-1] - pEnd3[-1];
        p1ap3_0 = pEnd1[0] + pEnd3[0];
        p1sp3_0 = pEnd1[0] - pEnd3[0];
 8026dc6:	ee31 2a42 	vsub.f32	s4, s2, s4
        t3[3] = p1ap3_0 - pEnd2[0]  - pEnd4[0];
        // col 4
        t4[2] = pEnd2[0]  - pEnd4[0]  - p1sp3_1;
        t4[3] = pEnd4[-1] - pEnd2[-1] - p1sp3_0;
        // col 1 - Bottom
        *pEnd1-- = p1ap3_0 + pEnd2[0] + pEnd4[0];
 8026dca:	ee77 8a28 	vadd.f32	s17, s14, s17
        p1ap3_0 = p1[0] + p3[0];
        p1sp3_0 = p1[0] - p3[0];
        p1ap3_1 = p1[1] + p3[1];
        p1sp3_1 = p1[1] - p3[1];
        // col 2
        t2[0] = p1sp3_0 + p2[1] - p4[1];
 8026dce:	ee74 aa23 	vadd.f32	s21, s8, s7
        t3[3] = p1ap3_0 - pEnd2[0]  - pEnd4[0];
        // col 4
        t4[2] = pEnd2[0]  - pEnd4[0]  - p1sp3_1;
        t4[3] = pEnd4[-1] - pEnd2[-1] - p1sp3_0;
        // col 1 - Bottom
        *pEnd1-- = p1ap3_0 + pEnd2[0] + pEnd4[0];
 8026dd2:	ee18 ca90 	vmov	ip, s17
 8026dd6:	f847 c908 	str.w	ip, [r7], #-8
        *pEnd1-- = p1ap3_1 + pEnd2[-1] + pEnd4[-1];
 8026dda:	edd2 8a01 	vldr	s17, [r2, #4]
 8026dde:	ed93 9a01 	vldr	s18, [r3, #4]
 8026de2:	ee70 8aa8 	vadd.f32	s17, s1, s17
        p1ap3_1 = pEnd1[-1] + pEnd3[-1];
        p1sp3_1 = pEnd1[-1] - pEnd3[-1];
        p1ap3_0 = pEnd1[0] + pEnd3[0];
        p1sp3_0 = pEnd1[0] - pEnd3[0];
        // col 2
        t2[2] = pEnd2[0]  - pEnd4[0] + p1sp3_1;
 8026de6:	ee37 1ac7 	vsub.f32	s2, s15, s14
        // col 4
        t4[2] = pEnd2[0]  - pEnd4[0]  - p1sp3_1;
        t4[3] = pEnd4[-1] - pEnd2[-1] - p1sp3_0;
        // col 1 - Bottom
        *pEnd1-- = p1ap3_0 + pEnd2[0] + pEnd4[0];
        *pEnd1-- = p1ap3_1 + pEnd2[-1] + pEnd4[-1];
 8026dea:	ee78 8a89 	vadd.f32	s17, s17, s18
        p1ap3_0 = p1[0] + p3[0];
        p1sp3_0 = p1[0] - p3[0];
        p1ap3_1 = p1[1] + p3[1];
        p1sp3_1 = p1[1] - p3[1];
        // col 2
        t2[0] = p1sp3_0 + p2[1] - p4[1];
 8026dee:	ee7a aae4 	vsub.f32	s21, s21, s9
        // col 4
        t4[2] = pEnd2[0]  - pEnd4[0]  - p1sp3_1;
        t4[3] = pEnd4[-1] - pEnd2[-1] - p1sp3_0;
        // col 1 - Bottom
        *pEnd1-- = p1ap3_0 + pEnd2[0] + pEnd4[0];
        *pEnd1-- = p1ap3_1 + pEnd2[-1] + pEnd4[-1];
 8026df2:	edc7 8a01 	vstr	s17, [r7, #4]

        // COL 2
        // read twiddle factors
        twR = *tw2++;
        twI = *tw2++;
 8026df6:	ed5a 8a01 	vldr	s17, [sl, #-4]
        *p1++ = p1ap3_0 + p2[0] + p4[0];
        *p1++ = p1ap3_1 + p2[1] + p4[1];

        // BOTTOM
        p1ap3_1 = pEnd1[-1] + pEnd3[-1];
        p1sp3_1 = pEnd1[-1] - pEnd3[-1];
 8026dfa:	ee79 1ae1 	vsub.f32	s3, s19, s3
        //  let    Z1 = a + i(b),   Z2 = c + i(d)
        //   =>  Z1 * Z2  =  (a*c - b*d) + i(b*c + a*d)

        // Top
        m0 = t2[0] * twR;
        m1 = t2[1] * twI;
 8026dfe:	ee2a ca28 	vmul.f32	s24, s20, s17
        *pEnd1-- = p1ap3_0 + pEnd2[0] + pEnd4[0];
        *pEnd1-- = p1ap3_1 + pEnd2[-1] + pEnd4[-1];

        // COL 2
        // read twiddle factors
        twR = *tw2++;
 8026e02:	ed5a 9a02 	vldr	s19, [sl, #-8]
        p1sp3_1 = pEnd1[-1] - pEnd3[-1];
        p1ap3_0 = pEnd1[0] + pEnd3[0];
        p1sp3_0 = pEnd1[0] - pEnd3[0];
        // col 2
        t2[2] = pEnd2[0]  - pEnd4[0] + p1sp3_1;
        t2[3] = pEnd1[0] - pEnd3[0] - pEnd2[-1] + pEnd4[-1];
 8026e06:	ee32 9a43 	vsub.f32	s18, s4, s6
        m0 = t2[0] * twR;
        m1 = t2[1] * twI;
        m2 = t2[1] * twR;
        m3 = t2[0] * twI;

        *p2++ = m0 + m1;
 8026e0a:	eeaa caa9 	vfma.f32	s24, s21, s19

    tw2 += twMod2;
    tw3 += twMod3;
    tw4 += twMod4;

    for (l = (L - 2) >> 1; l > 0; l-- )
 8026e0e:	f1bb 0b01 	subs.w	fp, fp, #1
 8026e12:	f105 0508 	add.w	r5, r5, #8
        p1sp3_1 = pEnd1[-1] - pEnd3[-1];
        p1ap3_0 = pEnd1[0] + pEnd3[0];
        p1sp3_0 = pEnd1[0] - pEnd3[0];
        // col 2
        t2[2] = pEnd2[0]  - pEnd4[0] + p1sp3_1;
        t2[3] = pEnd1[0] - pEnd3[0] - pEnd2[-1] + pEnd4[-1];
 8026e16:	ee39 9a22 	vadd.f32	s18, s18, s5
        p1ap3_1 = pEnd1[-1] + pEnd3[-1];
        p1sp3_1 = pEnd1[-1] - pEnd3[-1];
        p1ap3_0 = pEnd1[0] + pEnd3[0];
        p1sp3_0 = pEnd1[0] - pEnd3[0];
        // col 2
        t2[2] = pEnd2[0]  - pEnd4[0] + p1sp3_1;
 8026e1a:	ee71 ca21 	vadd.f32	s25, s2, s3
 8026e1e:	ee68 baea 	vnmul.f32	s23, s17, s21
 8026e22:	ee29 baec 	vnmul.f32	s22, s19, s25
        // 0.9997 - 0.0245i  <==>  0.0245 - 0.9997i
        // Bottom
        m0 = t2[3] * twI;
        m1 = t2[2] * twR;
        m2 = t2[2] * twI;
        m3 = t2[3] * twR;
 8026e26:	ee69 aa29 	vmul.f32	s21, s18, s19

        *pEnd2-- = m0 - m1;
 8026e2a:	eea9 ba28 	vfma.f32	s22, s18, s17
 8026e2e:	f10a 0a08 	add.w	sl, sl, #8
 8026e32:	f1a2 0208 	sub.w	r2, r2, #8
        m1 = t2[1] * twI;
        m2 = t2[1] * twR;
        m3 = t2[0] * twI;

        *p2++ = m0 + m1;
        *p2++ = m2 - m3;
 8026e36:	eeea ba29 	vfma.f32	s23, s20, s19
 8026e3a:	f109 0910 	add.w	r9, r9, #16
 8026e3e:	f104 0408 	add.w	r4, r4, #8
        m0 = t2[0] * twR;
        m1 = t2[1] * twI;
        m2 = t2[1] * twR;
        m3 = t2[0] * twI;

        *p2++ = m0 + m1;
 8026e42:	ee1c ca10 	vmov	ip, s24
        m1 = t2[2] * twR;
        m2 = t2[2] * twI;
        m3 = t2[3] * twR;

        *pEnd2-- = m0 - m1;
        *pEnd2-- = m2 + m3;
 8026e46:	eeec aaa8 	vfma.f32	s21, s25, s17
        m0 = t2[0] * twR;
        m1 = t2[1] * twI;
        m2 = t2[1] * twR;
        m3 = t2[0] * twI;

        *p2++ = m0 + m1;
 8026e4a:	f841 cb08 	str.w	ip, [r1], #8
        p1sp3_0 = pEnd1[0] - pEnd3[0];
        // col 2
        t2[2] = pEnd2[0]  - pEnd4[0] + p1sp3_1;
        t2[3] = pEnd1[0] - pEnd3[0] - pEnd2[-1] + pEnd4[-1];
        // col 3
        t3[2] = p1ap3_1 - pEnd2[-1] - pEnd4[-1];
 8026e4e:	ee70 0ac3 	vsub.f32	s1, s1, s6
        m1 = t2[1] * twI;
        m2 = t2[1] * twR;
        m3 = t2[0] * twI;

        *p2++ = m0 + m1;
        *p2++ = m2 - m3;
 8026e52:	ed41 ba01 	vstr	s23, [r1, #-4]
        m0 = t2[3] * twI;
        m1 = t2[2] * twR;
        m2 = t2[2] * twI;
        m3 = t2[3] * twR;

        *pEnd2-- = m0 - m1;
 8026e56:	ed82 ba04 	vstr	s22, [r2, #16]
        *pEnd2-- = m2 + m3;
 8026e5a:	edc2 aa03 	vstr	s21, [r2, #12]
        // col 2
        t2[2] = pEnd2[0]  - pEnd4[0] + p1sp3_1;
        t2[3] = pEnd1[0] - pEnd3[0] - pEnd2[-1] + pEnd4[-1];
        // col 3
        t3[2] = p1ap3_1 - pEnd2[-1] - pEnd4[-1];
        t3[3] = p1ap3_0 - pEnd2[0]  - pEnd4[0];
 8026e5e:	ee76 6ae7 	vsub.f32	s13, s13, s15
        p1sp3_1 = p1[1] - p3[1];
        // col 2
        t2[0] = p1sp3_0 + p2[1] - p4[1];
        t2[1] = p1sp3_1 - p2[0] + p4[0];
        // col 3
        t3[0] = p1ap3_0 - p2[0] - p4[0];
 8026e62:	ee30 0a65 	vsub.f32	s0, s0, s11
        *pEnd2-- = m0 - m1;
        *pEnd2-- = m2 + m3;

        // COL 3
        twR = tw3[0];
        twI = tw3[1];
 8026e66:	ed59 7a07 	vldr	s15, [r9, #-28]	; 0xffffffe4

        *pEnd2-- = m0 - m1;
        *pEnd2-- = m2 + m3;

        // COL 3
        twR = tw3[0];
 8026e6a:	ed59 8a08 	vldr	s17, [r9, #-32]	; 0xffffffe0
        // col 2
        t2[0] = p1sp3_0 + p2[1] - p4[1];
        t2[1] = p1sp3_1 - p2[0] + p4[0];
        // col 3
        t3[0] = p1ap3_0 - p2[0] - p4[0];
        t3[1] = p1ap3_1 - p2[1] - p4[1];
 8026e6e:	ee38 8a44 	vsub.f32	s16, s16, s8
        p1sp3_0 = pEnd1[0] - pEnd3[0];
        // col 2
        t2[2] = pEnd2[0]  - pEnd4[0] + p1sp3_1;
        t2[3] = pEnd1[0] - pEnd3[0] - pEnd2[-1] + pEnd4[-1];
        // col 3
        t3[2] = p1ap3_1 - pEnd2[-1] - pEnd4[-1];
 8026e72:	ee70 0ae2 	vsub.f32	s1, s1, s5
        t3[3] = p1ap3_0 - pEnd2[0]  - pEnd4[0];
 8026e76:	ee36 7ac7 	vsub.f32	s14, s13, s14
        p1sp3_1 = p1[1] - p3[1];
        // col 2
        t2[0] = p1sp3_0 + p2[1] - p4[1];
        t2[1] = p1sp3_1 - p2[0] + p4[0];
        // col 3
        t3[0] = p1ap3_0 - p2[0] - p4[0];
 8026e7a:	ee30 0a46 	vsub.f32	s0, s0, s12
        t3[1] = p1ap3_1 - p2[1] - p4[1];
 8026e7e:	ee38 8a64 	vsub.f32	s16, s16, s9
 8026e82:	ee67 6ae0 	vnmul.f32	s13, s15, s1
        twR = tw3[0];
        twI = tw3[1];
        tw3 += twMod3;
        // Top
        m0 = t3[0] * twR;
        m1 = t3[1] * twI;
 8026e86:	ee68 9a27 	vmul.f32	s19, s16, s15
        m0 = -t3[3] * twR;
        m1 = t3[2] * twI;
        m2 = t3[2] * twR;
        m3 = t3[3] * twI;

        *pEnd3-- = m0 - m1;
 8026e8a:	eee7 6a68 	vfms.f32	s13, s14, s17
 8026e8e:	f10e 0e18 	add.w	lr, lr, #24
 8026e92:	f1a3 0308 	sub.w	r3, r3, #8
 8026e96:	ee27 9ac0 	vnmul.f32	s18, s15, s0
        m0 = t3[0] * twR;
        m1 = t3[1] * twI;
        m2 = t3[1] * twR;
        m3 = t3[0] * twI;

        *p3++ = m0 + m1;
 8026e9a:	eee0 9a28 	vfma.f32	s19, s0, s17
        // 0.9988 - 0.0491i  <==>  -0.9988 - 0.0491i
        // Bottom
        m0 = -t3[3] * twR;
        m1 = t3[2] * twI;
        m2 = t3[2] * twR;
        m3 = t3[3] * twI;
 8026e9e:	ee67 7a27 	vmul.f32	s15, s14, s15
        m1 = t3[1] * twI;
        m2 = t3[1] * twR;
        m3 = t3[0] * twI;

        *p3++ = m0 + m1;
        *p3++ = m2 - m3;
 8026ea2:	eea8 9a28 	vfma.f32	s18, s16, s17
        m0 = -t3[3] * twR;
        m1 = t3[2] * twI;
        m2 = t3[2] * twR;
        m3 = t3[3] * twI;

        *pEnd3-- = m0 - m1;
 8026ea6:	ee16 ca90 	vmov	ip, s13
        *pEnd3-- = m3 - m2;
 8026eaa:	eee0 7ae8 	vfms.f32	s15, s1, s17
        m0 = t3[0] * twR;
        m1 = t3[1] * twI;
        m2 = t3[1] * twR;
        m3 = t3[0] * twI;

        *p3++ = m0 + m1;
 8026eae:	ed44 9a04 	vstr	s19, [r4, #-16]
        *p3++ = m2 - m3;
 8026eb2:	ed04 9a03 	vstr	s18, [r4, #-12]
        m0 = -t3[3] * twR;
        m1 = t3[2] * twI;
        m2 = t3[2] * twR;
        m3 = t3[3] * twI;

        *pEnd3-- = m0 - m1;
 8026eb6:	f846 c908 	str.w	ip, [r6], #-8
        // col 3
        t3[0] = p1ap3_0 - p2[0] - p4[0];
        t3[1] = p1ap3_1 - p2[1] - p4[1];
        // col 4
        t4[0] = p1sp3_0 - p2[1] + p4[1];
        t4[1] = p1sp3_1 + p2[0] - p4[0];
 8026eba:	ee75 5a25 	vadd.f32	s11, s10, s11
        m1 = t3[2] * twI;
        m2 = t3[2] * twR;
        m3 = t3[3] * twI;

        *pEnd3-- = m0 - m1;
        *pEnd3-- = m3 - m2;
 8026ebe:	edc6 7a01 	vstr	s15, [r6, #4]

        // COL 4
        twR = tw4[0];
        twI = tw4[1];
 8026ec2:	ed5e 6a0b 	vldr	s13, [lr, #-44]	; 0xffffffd4
        // col 3
        t3[0] = p1ap3_0 - p2[0] - p4[0];
        t3[1] = p1ap3_1 - p2[1] - p4[1];
        // col 4
        t4[0] = p1sp3_0 - p2[1] + p4[1];
        t4[1] = p1sp3_1 + p2[0] - p4[0];
 8026ec6:	ee35 6ac6 	vsub.f32	s12, s11, s12
        t2[1] = p1sp3_1 - p2[0] + p4[0];
        // col 3
        t3[0] = p1ap3_0 - p2[0] - p4[0];
        t3[1] = p1ap3_1 - p2[1] - p4[1];
        // col 4
        t4[0] = p1sp3_0 - p2[1] + p4[1];
 8026eca:	ee33 4ac4 	vsub.f32	s8, s7, s8
        // col 3
        t3[2] = p1ap3_1 - pEnd2[-1] - pEnd4[-1];
        t3[3] = p1ap3_0 - pEnd2[0]  - pEnd4[0];
        // col 4
        t4[2] = pEnd2[0]  - pEnd4[0]  - p1sp3_1;
        t4[3] = pEnd4[-1] - pEnd2[-1] - p1sp3_0;
 8026ece:	ee72 7ac3 	vsub.f32	s15, s5, s6

        *pEnd3-- = m0 - m1;
        *pEnd3-- = m3 - m2;

        // COL 4
        twR = tw4[0];
 8026ed2:	ed5e 5a0c 	vldr	s11, [lr, #-48]	; 0xffffffd0
        t2[1] = p1sp3_1 - p2[0] + p4[0];
        // col 3
        t3[0] = p1ap3_0 - p2[0] - p4[0];
        t3[1] = p1ap3_1 - p2[1] - p4[1];
        // col 4
        t4[0] = p1sp3_0 - p2[1] + p4[1];
 8026ed6:	ee74 4a84 	vadd.f32	s9, s9, s8
        t2[3] = pEnd1[0] - pEnd3[0] - pEnd2[-1] + pEnd4[-1];
        // col 3
        t3[2] = p1ap3_1 - pEnd2[-1] - pEnd4[-1];
        t3[3] = p1ap3_0 - pEnd2[0]  - pEnd4[0];
        // col 4
        t4[2] = pEnd2[0]  - pEnd4[0]  - p1sp3_1;
 8026eda:	ee31 7a61 	vsub.f32	s14, s2, s3
        twR = tw4[0];
        twI = tw4[1];
        tw4 += twMod4;
        // Top
        m0 = t4[0] * twR;
        m1 = t4[1] * twI;
 8026ede:	ee66 3a26 	vmul.f32	s7, s12, s13
        // col 3
        t3[2] = p1ap3_1 - pEnd2[-1] - pEnd4[-1];
        t3[3] = p1ap3_0 - pEnd2[0]  - pEnd4[0];
        // col 4
        t4[2] = pEnd2[0]  - pEnd4[0]  - p1sp3_1;
        t4[3] = pEnd4[-1] - pEnd2[-1] - p1sp3_0;
 8026ee2:	ee77 7ac2 	vsub.f32	s15, s15, s4
 8026ee6:	ee26 4ae4 	vnmul.f32	s8, s13, s9
        m0 = t4[0] * twR;
        m1 = t4[1] * twI;
        m2 = t4[1] * twR;
        m3 = t4[0] * twI;

        *p4++ = m0 + m1;
 8026eea:	eee4 3aa5 	vfma.f32	s7, s9, s11
 8026eee:	ee65 4ac7 	vnmul.f32	s9, s11, s14
        // 0.9973 - 0.0736i  <==>  -0.0736 + 0.9973i
        // Bottom
        m0 = t4[3] * twI;
        m1 = t4[2] * twR;
        m2 = t4[2] * twI;
        m3 = t4[3] * twR;
 8026ef2:	ee27 5aa5 	vmul.f32	s10, s15, s11
        m1 = t4[1] * twI;
        m2 = t4[1] * twR;
        m3 = t4[0] * twI;

        *p4++ = m0 + m1;
        *p4++ = m2 - m3;
 8026ef6:	eea6 4a25 	vfma.f32	s8, s12, s11
        m0 = t4[3] * twI;
        m1 = t4[2] * twR;
        m2 = t4[2] * twI;
        m3 = t4[3] * twR;

        *pEnd4-- = m0 - m1;
 8026efa:	eeb0 6a64 	vmov.f32	s12, s9
 8026efe:	eea7 6aa6 	vfma.f32	s12, s15, s13
        *pEnd4-- = m2 + m3;
 8026f02:	eef0 7a45 	vmov.f32	s15, s10
        m0 = t4[0] * twR;
        m1 = t4[1] * twI;
        m2 = t4[1] * twR;
        m3 = t4[0] * twI;

        *p4++ = m0 + m1;
 8026f06:	ee13 ca90 	vmov	ip, s7
        m1 = t4[2] * twR;
        m2 = t4[2] * twI;
        m3 = t4[3] * twR;

        *pEnd4-- = m0 - m1;
        *pEnd4-- = m2 + m3;
 8026f0a:	eee7 7a26 	vfma.f32	s15, s14, s13
        m0 = t4[0] * twR;
        m1 = t4[1] * twI;
        m2 = t4[1] * twR;
        m3 = t4[0] * twI;

        *p4++ = m0 + m1;
 8026f0e:	f840 cb08 	str.w	ip, [r0], #8
        *p4++ = m2 - m3;
 8026f12:	ed00 4a01 	vstr	s8, [r0, #-4]
        m0 = t4[3] * twI;
        m1 = t4[2] * twR;
        m2 = t4[2] * twI;
        m3 = t4[3] * twR;

        *pEnd4-- = m0 - m1;
 8026f16:	ed83 6a04 	vstr	s12, [r3, #16]
        *pEnd4-- = m2 + m3;
 8026f1a:	edc3 7a03 	vstr	s15, [r3, #12]

    tw2 += twMod2;
    tw3 += twMod3;
    tw4 += twMod4;

    for (l = (L - 2) >> 1; l > 0; l-- )
 8026f1e:	f47f af10 	bne.w	8026d42 <arm_cfft_radix8by4_f32+0x142>
 8026f22:	9907      	ldr	r1, [sp, #28]
 8026f24:	9802      	ldr	r0, [sp, #8]
 8026f26:	f8dd c034 	ldr.w	ip, [sp, #52]	; 0x34
 8026f2a:	00cb      	lsls	r3, r1, #3
 8026f2c:	eb01 0241 	add.w	r2, r1, r1, lsl #1
 8026f30:	eb00 1101 	add.w	r1, r0, r1, lsl #4
 8026f34:	9102      	str	r1, [sp, #8]
 8026f36:	9903      	ldr	r1, [sp, #12]
 8026f38:	4419      	add	r1, r3
 8026f3a:	9103      	str	r1, [sp, #12]
 8026f3c:	9904      	ldr	r1, [sp, #16]
 8026f3e:	4419      	add	r1, r3
 8026f40:	9104      	str	r1, [sp, #16]
 8026f42:	9906      	ldr	r1, [sp, #24]
 8026f44:	4498      	add	r8, r3
 8026f46:	4419      	add	r1, r3
 8026f48:	449c      	add	ip, r3
 8026f4a:	9b05      	ldr	r3, [sp, #20]
 8026f4c:	9106      	str	r1, [sp, #24]
 8026f4e:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8026f52:	9305      	str	r3, [sp, #20]
    }

    //MIDDLE
    // Twiddle factors are
    //  1.0000  0.7071-0.7071i  -1.0000i  -0.7071-0.7071i
    p1ap3_0 = p1[0] + p3[0];
 8026f54:	9a03      	ldr	r2, [sp, #12]
 8026f56:	9e06      	ldr	r6, [sp, #24]
 8026f58:	ed92 3a00 	vldr	s6, [r2]
 8026f5c:	edd6 6a00 	vldr	s13, [r6]
    p1ap3_1 = p1[1] + p3[1];
    p1sp3_1 = p1[1] - p3[1];

    // col 2
    t2[0] = p1sp3_0 + p2[1] - p4[1];
    t2[1] = p1sp3_1 - p2[0] + p4[0];
 8026f60:	edd8 7a00 	vldr	s15, [r8]
 8026f64:	ed9c 4a00 	vldr	s8, [ip]
    //MIDDLE
    // Twiddle factors are
    //  1.0000  0.7071-0.7071i  -1.0000i  -0.7071-0.7071i
    p1ap3_0 = p1[0] + p3[0];
    p1sp3_0 = p1[0] - p3[0];
    p1ap3_1 = p1[1] + p3[1];
 8026f68:	ed96 7a01 	vldr	s14, [r6, #4]
 8026f6c:	edd2 3a01 	vldr	s7, [r2, #4]
    p1sp3_1 = p1[1] - p3[1];

    // col 2
    t2[0] = p1sp3_0 + p2[1] - p4[1];
 8026f70:	edd8 2a01 	vldr	s5, [r8, #4]
 8026f74:	eddc 4a01 	vldr	s9, [ip, #4]

    *p2++ = m0 + m1;
    *p2++ = m2 - m3;
    // COL 3
    twR = tw3[0];
    twI = tw3[1];
 8026f78:	9d02      	ldr	r5, [sp, #8]

    *p4++ = m0 + m1;
    *p4++ = m2 - m3;

    // first col
    arm_radix8_butterfly_f32( pCol1, L, (float32_t *) S->pTwiddle, 4u);
 8026f7a:	f8bd 4028 	ldrh.w	r4, [sp, #40]	; 0x28
 8026f7e:	980c      	ldr	r0, [sp, #48]	; 0x30
    }

    //MIDDLE
    // Twiddle factors are
    //  1.0000  0.7071-0.7071i  -1.0000i  -0.7071-0.7071i
    p1ap3_0 = p1[0] + p3[0];
 8026f80:	ee73 5a26 	vadd.f32	s11, s6, s13
    p1sp3_0 = p1[0] - p3[0];
    p1ap3_1 = p1[1] + p3[1];
 8026f84:	ee33 6a87 	vadd.f32	s12, s7, s14
    t3[1] = p1ap3_1 - p2[1] - p4[1];
    // col 4
    t4[0] = p1sp3_0 - p2[1] + p4[1];
    t4[1] = p1sp3_1 + p2[0] - p4[0];
    // col 1 - Top
    *p1++ = p1ap3_0 + p2[0] + p4[0];
 8026f88:	ee35 5aa7 	vadd.f32	s10, s11, s15

    //MIDDLE
    // Twiddle factors are
    //  1.0000  0.7071-0.7071i  -1.0000i  -0.7071-0.7071i
    p1ap3_0 = p1[0] + p3[0];
    p1sp3_0 = p1[0] - p3[0];
 8026f8c:	ee73 6a66 	vsub.f32	s13, s6, s13
    t3[1] = p1ap3_1 - p2[1] - p4[1];
    // col 4
    t4[0] = p1sp3_0 - p2[1] + p4[1];
    t4[1] = p1sp3_1 + p2[0] - p4[0];
    // col 1 - Top
    *p1++ = p1ap3_0 + p2[0] + p4[0];
 8026f90:	ee34 5a05 	vadd.f32	s10, s8, s10
    // Twiddle factors are
    //  1.0000  0.7071-0.7071i  -1.0000i  -0.7071-0.7071i
    p1ap3_0 = p1[0] + p3[0];
    p1sp3_0 = p1[0] - p3[0];
    p1ap3_1 = p1[1] + p3[1];
    p1sp3_1 = p1[1] - p3[1];
 8026f94:	ee33 7ac7 	vsub.f32	s14, s7, s14
    t3[1] = p1ap3_1 - p2[1] - p4[1];
    // col 4
    t4[0] = p1sp3_0 - p2[1] + p4[1];
    t4[1] = p1sp3_1 + p2[0] - p4[0];
    // col 1 - Top
    *p1++ = p1ap3_0 + p2[0] + p4[0];
 8026f98:	ed82 5a00 	vstr	s10, [r2]
    *p1++ = p1ap3_1 + p2[1] + p4[1];
 8026f9c:	ed98 5a01 	vldr	s10, [r8, #4]
 8026fa0:	ed9c 3a01 	vldr	s6, [ip, #4]
 8026fa4:	ee36 5a05 	vadd.f32	s10, s12, s10
    p1ap3_1 = p1[1] + p3[1];
    p1sp3_1 = p1[1] - p3[1];

    // col 2
    t2[0] = p1sp3_0 + p2[1] - p4[1];
    t2[1] = p1sp3_1 - p2[0] + p4[0];
 8026fa8:	ee77 3a67 	vsub.f32	s7, s14, s15
    // col 4
    t4[0] = p1sp3_0 - p2[1] + p4[1];
    t4[1] = p1sp3_1 + p2[0] - p4[0];
    // col 1 - Top
    *p1++ = p1ap3_0 + p2[0] + p4[0];
    *p1++ = p1ap3_1 + p2[1] + p4[1];
 8026fac:	ee35 5a03 	vadd.f32	s10, s10, s6
    p1sp3_0 = p1[0] - p3[0];
    p1ap3_1 = p1[1] + p3[1];
    p1sp3_1 = p1[1] - p3[1];

    // col 2
    t2[0] = p1sp3_0 + p2[1] - p4[1];
 8026fb0:	ee32 3aa6 	vadd.f32	s6, s5, s13
    // col 4
    t4[0] = p1sp3_0 - p2[1] + p4[1];
    t4[1] = p1sp3_1 + p2[0] - p4[0];
    // col 1 - Top
    *p1++ = p1ap3_0 + p2[0] + p4[0];
    *p1++ = p1ap3_1 + p2[1] + p4[1];
 8026fb4:	ed82 5a01 	vstr	s10, [r2, #4]

    // COL 2
    twR = tw2[0];
    twI = tw2[1];
 8026fb8:	9a04      	ldr	r2, [sp, #16]
    p1ap3_1 = p1[1] + p3[1];
    p1sp3_1 = p1[1] - p3[1];

    // col 2
    t2[0] = p1sp3_0 + p2[1] - p4[1];
    t2[1] = p1sp3_1 - p2[0] + p4[0];
 8026fba:	ee73 3a84 	vadd.f32	s7, s7, s8
    *p1++ = p1ap3_0 + p2[0] + p4[0];
    *p1++ = p1ap3_1 + p2[1] + p4[1];

    // COL 2
    twR = tw2[0];
    twI = tw2[1];
 8026fbe:	ed92 5a01 	vldr	s10, [r2, #4]
    // col 1 - Top
    *p1++ = p1ap3_0 + p2[0] + p4[0];
    *p1++ = p1ap3_1 + p2[1] + p4[1];

    // COL 2
    twR = tw2[0];
 8026fc2:	edd2 1a00 	vldr	s3, [r2]

    *p4++ = m0 + m1;
    *p4++ = m2 - m3;

    // first col
    arm_radix8_butterfly_f32( pCol1, L, (float32_t *) S->pTwiddle, 4u);
 8026fc6:	9a01      	ldr	r2, [sp, #4]
    p1sp3_0 = p1[0] - p3[0];
    p1ap3_1 = p1[1] + p3[1];
    p1sp3_1 = p1[1] - p3[1];

    // col 2
    t2[0] = p1sp3_0 + p2[1] - p4[1];
 8026fc8:	ee33 3a64 	vsub.f32	s6, s6, s9
    // COL 2
    twR = tw2[0];
    twI = tw2[1];

    m0 = t2[0] * twR;
    m1 = t2[1] * twI;
 8026fcc:	ee23 2a85 	vmul.f32	s4, s7, s10
 8026fd0:	ee25 5a43 	vnmul.f32	s10, s10, s6
    m2 = t2[1] * twR;
    m3 = t2[0] * twI;

    *p2++ = m0 + m1;
 8026fd4:	eea3 2a21 	vfma.f32	s4, s6, s3

    *p4++ = m0 + m1;
    *p4++ = m2 - m3;

    // first col
    arm_radix8_butterfly_f32( pCol1, L, (float32_t *) S->pTwiddle, 4u);
 8026fd8:	4621      	mov	r1, r4
 8026fda:	2304      	movs	r3, #4
    m1 = t2[1] * twI;
    m2 = t2[1] * twR;
    m3 = t2[0] * twI;

    *p2++ = m0 + m1;
    *p2++ = m2 - m3;
 8026fdc:	eea3 5aa1 	vfma.f32	s10, s7, s3
    // col 2
    t2[0] = p1sp3_0 + p2[1] - p4[1];
    t2[1] = p1sp3_1 - p2[0] + p4[0];
    // col 3
    t3[0] = p1ap3_0 - p2[0] - p4[0];
    t3[1] = p1ap3_1 - p2[1] - p4[1];
 8026fe0:	ee36 6a62 	vsub.f32	s12, s12, s5

    // col 2
    t2[0] = p1sp3_0 + p2[1] - p4[1];
    t2[1] = p1sp3_1 - p2[0] + p4[0];
    // col 3
    t3[0] = p1ap3_0 - p2[0] - p4[0];
 8026fe4:	ee75 5ae7 	vsub.f32	s11, s11, s15
    m0 = t2[0] * twR;
    m1 = t2[1] * twI;
    m2 = t2[1] * twR;
    m3 = t2[0] * twI;

    *p2++ = m0 + m1;
 8026fe8:	ed88 2a00 	vstr	s4, [r8]
    *p2++ = m2 - m3;
 8026fec:	ed88 5a01 	vstr	s10, [r8, #4]

    // col 2
    t2[0] = p1sp3_0 + p2[1] - p4[1];
    t2[1] = p1sp3_1 - p2[0] + p4[0];
    // col 3
    t3[0] = p1ap3_0 - p2[0] - p4[0];
 8026ff0:	ee75 5ac4 	vsub.f32	s11, s11, s8
    t3[1] = p1ap3_1 - p2[1] - p4[1];
 8026ff4:	ee36 6a64 	vsub.f32	s12, s12, s9

    *p2++ = m0 + m1;
    *p2++ = m2 - m3;
    // COL 3
    twR = tw3[0];
    twI = tw3[1];
 8026ff8:	ed95 5a01 	vldr	s10, [r5, #4]
    m3 = t2[0] * twI;

    *p2++ = m0 + m1;
    *p2++ = m2 - m3;
    // COL 3
    twR = tw3[0];
 8026ffc:	ed95 3a00 	vldr	s6, [r5]
    twI = tw3[1];

    m0 = t3[0] * twR;
    m1 = t3[1] * twI;
 8027000:	ee66 3a05 	vmul.f32	s7, s12, s10
 8027004:	ee25 5a65 	vnmul.f32	s10, s10, s11
    m2 = t3[1] * twR;
    m3 = t3[0] * twI;

    *p3++ = m0 + m1;
 8027008:	eee5 3a83 	vfma.f32	s7, s11, s6
 802700c:	4635      	mov	r5, r6
    *p3++ = m2 - m3;
 802700e:	eea6 5a03 	vfma.f32	s10, s12, s6
    m0 = t3[0] * twR;
    m1 = t3[1] * twI;
    m2 = t3[1] * twR;
    m3 = t3[0] * twI;

    *p3++ = m0 + m1;
 8027012:	edc5 3a00 	vstr	s7, [r5]
    t2[1] = p1sp3_1 - p2[0] + p4[0];
    // col 3
    t3[0] = p1ap3_0 - p2[0] - p4[0];
    t3[1] = p1ap3_1 - p2[1] - p4[1];
    // col 4
    t4[0] = p1sp3_0 - p2[1] + p4[1];
 8027016:	ee76 6ae2 	vsub.f32	s13, s13, s5
    m1 = t3[1] * twI;
    m2 = t3[1] * twR;
    m3 = t3[0] * twI;

    *p3++ = m0 + m1;
    *p3++ = m2 - m3;
 802701a:	ed86 5a01 	vstr	s10, [r6, #4]
    // col 3
    t3[0] = p1ap3_0 - p2[0] - p4[0];
    t3[1] = p1ap3_1 - p2[1] - p4[1];
    // col 4
    t4[0] = p1sp3_0 - p2[1] + p4[1];
    t4[1] = p1sp3_1 + p2[0] - p4[0];
 802701e:	ee37 7a27 	vadd.f32	s14, s14, s15

    *p3++ = m0 + m1;
    *p3++ = m2 - m3;
    // COL 4
    twR = tw4[0];
    twI = tw4[1];
 8027022:	9e05      	ldr	r6, [sp, #20]
    // col 3
    t3[0] = p1ap3_0 - p2[0] - p4[0];
    t3[1] = p1ap3_1 - p2[1] - p4[1];
    // col 4
    t4[0] = p1sp3_0 - p2[1] + p4[1];
    t4[1] = p1sp3_1 + p2[0] - p4[0];
 8027024:	ee77 7a44 	vsub.f32	s15, s14, s8
    t2[1] = p1sp3_1 - p2[0] + p4[0];
    // col 3
    t3[0] = p1ap3_0 - p2[0] - p4[0];
    t3[1] = p1ap3_1 - p2[1] - p4[1];
    // col 4
    t4[0] = p1sp3_0 - p2[1] + p4[1];
 8027028:	ee74 6aa6 	vadd.f32	s13, s9, s13

    *p3++ = m0 + m1;
    *p3++ = m2 - m3;
    // COL 4
    twR = tw4[0];
    twI = tw4[1];
 802702c:	ed96 7a01 	vldr	s14, [r6, #4]
    m3 = t3[0] * twI;

    *p3++ = m0 + m1;
    *p3++ = m2 - m3;
    // COL 4
    twR = tw4[0];
 8027030:	edd6 5a00 	vldr	s11, [r6]
    twI = tw4[1];

    m0 = t4[0] * twR;
    m1 = t4[1] * twI;
 8027034:	ee27 6a87 	vmul.f32	s12, s15, s14
 8027038:	ee27 7a66 	vnmul.f32	s14, s14, s13
    m2 = t4[1] * twR;
    m3 = t4[0] * twI;

    *p4++ = m0 + m1;
 802703c:	eea6 6aa5 	vfma.f32	s12, s13, s11
    *p4++ = m2 - m3;
 8027040:	eea7 7aa5 	vfma.f32	s14, s15, s11
    m0 = t4[0] * twR;
    m1 = t4[1] * twI;
    m2 = t4[1] * twR;
    m3 = t4[0] * twI;

    *p4++ = m0 + m1;
 8027044:	ed8c 6a00 	vstr	s12, [ip]
    *p4++ = m2 - m3;
 8027048:	ed8c 7a01 	vstr	s14, [ip, #4]

    // first col
    arm_radix8_butterfly_f32( pCol1, L, (float32_t *) S->pTwiddle, 4u);
 802704c:	f000 f892 	bl	8027174 <arm_radix8_butterfly_f32>
    // second col
    arm_radix8_butterfly_f32( pCol2, L, (float32_t *) S->pTwiddle, 4u);
 8027050:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 8027052:	9808      	ldr	r0, [sp, #32]
 8027054:	686a      	ldr	r2, [r5, #4]
 8027056:	4621      	mov	r1, r4
 8027058:	2304      	movs	r3, #4
 802705a:	f000 f88b 	bl	8027174 <arm_radix8_butterfly_f32>
    // third col
    arm_radix8_butterfly_f32( pCol3, L, (float32_t *) S->pTwiddle, 4u);
 802705e:	9809      	ldr	r0, [sp, #36]	; 0x24
 8027060:	686a      	ldr	r2, [r5, #4]
 8027062:	4621      	mov	r1, r4
 8027064:	2304      	movs	r3, #4
 8027066:	f000 f885 	bl	8027174 <arm_radix8_butterfly_f32>
    // fourth col
    arm_radix8_butterfly_f32( pCol4, L, (float32_t *) S->pTwiddle, 4u);
 802706a:	9800      	ldr	r0, [sp, #0]
 802706c:	686a      	ldr	r2, [r5, #4]
 802706e:	4621      	mov	r1, r4
 8027070:	2304      	movs	r3, #4
}
 8027072:	b00f      	add	sp, #60	; 0x3c
 8027074:	ecbd 8b0a 	vpop	{d8-d12}
 8027078:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    // second col
    arm_radix8_butterfly_f32( pCol2, L, (float32_t *) S->pTwiddle, 4u);
    // third col
    arm_radix8_butterfly_f32( pCol3, L, (float32_t *) S->pTwiddle, 4u);
    // fourth col
    arm_radix8_butterfly_f32( pCol4, L, (float32_t *) S->pTwiddle, 4u);
 802707c:	f000 b87a 	b.w	8027174 <arm_radix8_butterfly_f32>

08027080 <arm_cfft_f32>:
    uint8_t bitReverseFlag)
{
    uint32_t  L = S->fftLen, l;
    float32_t invL, * pSrc;

    if (ifftFlag == 1u)
 8027080:	2a01      	cmp	r2, #1
void arm_cfft_f32(
    const arm_cfft_instance_f32 * S,
    float32_t * p1,
    uint8_t ifftFlag,
    uint8_t bitReverseFlag)
{
 8027082:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8027086:	4606      	mov	r6, r0
 8027088:	4617      	mov	r7, r2
 802708a:	460c      	mov	r4, r1
 802708c:	4698      	mov	r8, r3
    uint32_t  L = S->fftLen, l;
 802708e:	8805      	ldrh	r5, [r0, #0]
    float32_t invL, * pSrc;

    if (ifftFlag == 1u)
 8027090:	d054      	beq.n	802713c <arm_cfft_f32+0xbc>
            *pSrc = -*pSrc;
            pSrc += 2;
        }
    }

    switch (L)
 8027092:	f5b5 7f80 	cmp.w	r5, #256	; 0x100
 8027096:	d04c      	beq.n	8027132 <arm_cfft_f32+0xb2>
 8027098:	d916      	bls.n	80270c8 <arm_cfft_f32+0x48>
 802709a:	f5b5 6f80 	cmp.w	r5, #1024	; 0x400
 802709e:	d01a      	beq.n	80270d6 <arm_cfft_f32+0x56>
 80270a0:	d95c      	bls.n	802715c <arm_cfft_f32+0xdc>
 80270a2:	f5b5 6f00 	cmp.w	r5, #2048	; 0x800
 80270a6:	d044      	beq.n	8027132 <arm_cfft_f32+0xb2>
 80270a8:	f5b5 5f80 	cmp.w	r5, #4096	; 0x1000
 80270ac:	d105      	bne.n	80270ba <arm_cfft_f32+0x3a>
        arm_cfft_radix8by4_f32  ( (arm_cfft_instance_f32 *) S, p1);
        break;
    case 64:
    case 512:
    case 4096:
        arm_radix8_butterfly_f32( p1, L, (float32_t *) S->pTwiddle, 1);
 80270ae:	4620      	mov	r0, r4
 80270b0:	4629      	mov	r1, r5
 80270b2:	6872      	ldr	r2, [r6, #4]
 80270b4:	2301      	movs	r3, #1
 80270b6:	f000 f85d 	bl	8027174 <arm_radix8_butterfly_f32>
        break;
    }

    if ( bitReverseFlag )
 80270ba:	f1b8 0f00 	cmp.w	r8, #0
 80270be:	d111      	bne.n	80270e4 <arm_cfft_f32+0x64>
        arm_bitreversal_32((uint32_t*)p1,S->bitRevLength,S->pBitRevTable);

    if (ifftFlag == 1u)
 80270c0:	2f01      	cmp	r7, #1
 80270c2:	d016      	beq.n	80270f2 <arm_cfft_f32+0x72>
 80270c4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            *pSrc = -*pSrc;
            pSrc += 2;
        }
    }

    switch (L)
 80270c8:	2d20      	cmp	r5, #32
 80270ca:	d032      	beq.n	8027132 <arm_cfft_f32+0xb2>
 80270cc:	d94a      	bls.n	8027164 <arm_cfft_f32+0xe4>
 80270ce:	2d40      	cmp	r5, #64	; 0x40
 80270d0:	d0ed      	beq.n	80270ae <arm_cfft_f32+0x2e>
 80270d2:	2d80      	cmp	r5, #128	; 0x80
 80270d4:	d1f1      	bne.n	80270ba <arm_cfft_f32+0x3a>
    {
    case 16:
    case 128:
    case 1024:
        arm_cfft_radix8by2_f32  ( (arm_cfft_instance_f32 *) S, p1);
 80270d6:	4630      	mov	r0, r6
 80270d8:	4621      	mov	r1, r4
 80270da:	f7ff fccf 	bl	8026a7c <arm_cfft_radix8by2_f32>
    case 4096:
        arm_radix8_butterfly_f32( p1, L, (float32_t *) S->pTwiddle, 1);
        break;
    }

    if ( bitReverseFlag )
 80270de:	f1b8 0f00 	cmp.w	r8, #0
 80270e2:	d0ed      	beq.n	80270c0 <arm_cfft_f32+0x40>
        arm_bitreversal_32((uint32_t*)p1,S->bitRevLength,S->pBitRevTable);
 80270e4:	4620      	mov	r0, r4
 80270e6:	89b1      	ldrh	r1, [r6, #12]
 80270e8:	68b2      	ldr	r2, [r6, #8]
 80270ea:	f7ff fc67 	bl	80269bc <arm_bitreversal_32>

    if (ifftFlag == 1u)
 80270ee:	2f01      	cmp	r7, #1
 80270f0:	d1e8      	bne.n	80270c4 <arm_cfft_f32+0x44>
    {
        invL = 1.0f/(float32_t)L;
 80270f2:	ee07 5a90 	vmov	s15, r5
 80270f6:	eef8 6a67 	vcvt.f32.u32	s13, s15
 80270fa:	eef7 7a00 	vmov.f32	s15, #112	; 0x70
 80270fe:	eec7 6aa6 	vdiv.f32	s13, s15, s13
        /*  Conjugate and scale output data */
        pSrc = p1;
        for(l=0; l<L; l++)
 8027102:	2d00      	cmp	r5, #0
 8027104:	d0de      	beq.n	80270c4 <arm_cfft_f32+0x44>
 8027106:	f104 0108 	add.w	r1, r4, #8
 802710a:	2300      	movs	r3, #0
 802710c:	3301      	adds	r3, #1
 802710e:	429d      	cmp	r5, r3
 8027110:	f101 0108 	add.w	r1, r1, #8
        {
            *pSrc++ *=   invL ;
 8027114:	ed11 7a04 	vldr	s14, [r1, #-16]
            *pSrc  = -(*pSrc) * invL;
 8027118:	ed51 7a03 	vldr	s15, [r1, #-12]
        invL = 1.0f/(float32_t)L;
        /*  Conjugate and scale output data */
        pSrc = p1;
        for(l=0; l<L; l++)
        {
            *pSrc++ *=   invL ;
 802711c:	ee27 7a26 	vmul.f32	s14, s14, s13
            *pSrc  = -(*pSrc) * invL;
 8027120:	ee67 7ae6 	vnmul.f32	s15, s15, s13
        invL = 1.0f/(float32_t)L;
        /*  Conjugate and scale output data */
        pSrc = p1;
        for(l=0; l<L; l++)
        {
            *pSrc++ *=   invL ;
 8027124:	ed01 7a04 	vstr	s14, [r1, #-16]
            *pSrc  = -(*pSrc) * invL;
 8027128:	ed41 7a03 	vstr	s15, [r1, #-12]
    if (ifftFlag == 1u)
    {
        invL = 1.0f/(float32_t)L;
        /*  Conjugate and scale output data */
        pSrc = p1;
        for(l=0; l<L; l++)
 802712c:	d1ee      	bne.n	802710c <arm_cfft_f32+0x8c>
 802712e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        arm_cfft_radix8by2_f32  ( (arm_cfft_instance_f32 *) S, p1);
        break;
    case 32:
    case 256:
    case 2048:
        arm_cfft_radix8by4_f32  ( (arm_cfft_instance_f32 *) S, p1);
 8027132:	4630      	mov	r0, r6
 8027134:	4621      	mov	r1, r4
 8027136:	f7ff fd63 	bl	8026c00 <arm_cfft_radix8by4_f32>
        break;
 802713a:	e7be      	b.n	80270ba <arm_cfft_f32+0x3a>

    if (ifftFlag == 1u)
    {
        /*  Conjugate input data  */
        pSrc = p1 + 1;
        for(l=0; l<L; l++)
 802713c:	b1ad      	cbz	r5, 802716a <arm_cfft_f32+0xea>
 802713e:	f101 030c 	add.w	r3, r1, #12
 8027142:	2200      	movs	r2, #0
        {
            *pSrc = -*pSrc;
 8027144:	ed53 7a02 	vldr	s15, [r3, #-8]

    if (ifftFlag == 1u)
    {
        /*  Conjugate input data  */
        pSrc = p1 + 1;
        for(l=0; l<L; l++)
 8027148:	3201      	adds	r2, #1
        {
            *pSrc = -*pSrc;
 802714a:	eef1 7a67 	vneg.f32	s15, s15

    if (ifftFlag == 1u)
    {
        /*  Conjugate input data  */
        pSrc = p1 + 1;
        for(l=0; l<L; l++)
 802714e:	4295      	cmp	r5, r2
        {
            *pSrc = -*pSrc;
 8027150:	ed43 7a02 	vstr	s15, [r3, #-8]
 8027154:	f103 0308 	add.w	r3, r3, #8

    if (ifftFlag == 1u)
    {
        /*  Conjugate input data  */
        pSrc = p1 + 1;
        for(l=0; l<L; l++)
 8027158:	d1f4      	bne.n	8027144 <arm_cfft_f32+0xc4>
 802715a:	e79a      	b.n	8027092 <arm_cfft_f32+0x12>
            *pSrc = -*pSrc;
            pSrc += 2;
        }
    }

    switch (L)
 802715c:	f5b5 7f00 	cmp.w	r5, #512	; 0x200
 8027160:	d0a5      	beq.n	80270ae <arm_cfft_f32+0x2e>
 8027162:	e7aa      	b.n	80270ba <arm_cfft_f32+0x3a>
 8027164:	2d10      	cmp	r5, #16
 8027166:	d0b6      	beq.n	80270d6 <arm_cfft_f32+0x56>
 8027168:	e7a7      	b.n	80270ba <arm_cfft_f32+0x3a>
 802716a:	f5b5 7f80 	cmp.w	r5, #256	; 0x100
 802716e:	d894      	bhi.n	802709a <arm_cfft_f32+0x1a>
 8027170:	e7aa      	b.n	80270c8 <arm_cfft_f32+0x48>
 8027172:	bf00      	nop

08027174 <arm_radix8_butterfly_f32>:
void arm_radix8_butterfly_f32(
float32_t * pSrc,
uint16_t fftLen,
const float32_t * pCoef,
uint16_t twidCoefModifier)
{
 8027174:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8027178:	ed2d 8b10 	vpush	{d8-d15}
 802717c:	b09d      	sub	sp, #116	; 0x74
 802717e:	461c      	mov	r4, r3
         pSrc[2 * i7 + 1] = t2 + r3;
         r1 = (r6 - r8) * C81;
         r6 = (r6 + r8) * C81;
         r2 = (s6 - s8) * C81;
         s6 = (s6 + s8) * C81;
         t1 = r5 - r1;
 8027180:	eddf aac9 	vldr	s21, [pc, #804]	; 80274a8 <arm_radix8_butterfly_f32+0x334>
void arm_radix8_butterfly_f32(
float32_t * pSrc,
uint16_t fftLen,
const float32_t * pCoef,
uint16_t twidCoefModifier)
{
 8027184:	921a      	str	r2, [sp, #104]	; 0x68
 8027186:	1d03      	adds	r3, r0, #4
 8027188:	4682      	mov	sl, r0
 802718a:	4689      	mov	r9, r1
   float32_t p1, p2, p3, p4;
   float32_t co2, co3, co4, co5, co6, co7, co8;
   float32_t si2, si3, si4, si5, si6, si7, si8;
   const float32_t C81 = 0.70710678118f;

   n2 = fftLen;
 802718c:	468b      	mov	fp, r1
 802718e:	931b      	str	r3, [sp, #108]	; 0x6c
 8027190:	9400      	str	r4, [sp, #0]
 8027192:	469e      	mov	lr, r3

   do
   {
      n1 = n2;
      n2 = n2 >> 3;
 8027194:	ea4f 03db 	mov.w	r3, fp, lsr #3
 8027198:	005a      	lsls	r2, r3, #1
 802719a:	18d6      	adds	r6, r2, r3
 802719c:	18f5      	adds	r5, r6, r3
 802719e:	9204      	str	r2, [sp, #16]
 80271a0:	195a      	adds	r2, r3, r5
 80271a2:	18d0      	adds	r0, r2, r3
 80271a4:	00df      	lsls	r7, r3, #3
 80271a6:	1819      	adds	r1, r3, r0
 80271a8:	463c      	mov	r4, r7
 80271aa:	9702      	str	r7, [sp, #8]
 80271ac:	4457      	add	r7, sl
 80271ae:	930c      	str	r3, [sp, #48]	; 0x30
 80271b0:	eb0a 02c2 	add.w	r2, sl, r2, lsl #3
 80271b4:	011b      	lsls	r3, r3, #4
 80271b6:	eb0a 01c1 	add.w	r1, sl, r1, lsl #3
 80271ba:	eb07 0c04 	add.w	ip, r7, r4
      i1 = 0;
 80271be:	9c00      	ldr	r4, [sp, #0]
 80271c0:	9303      	str	r3, [sp, #12]
 80271c2:	eb0a 06c6 	add.w	r6, sl, r6, lsl #3
 80271c6:	eb0a 05c5 	add.w	r5, sl, r5, lsl #3
 80271ca:	3204      	adds	r2, #4
 80271cc:	3104      	adds	r1, #4
 80271ce:	eb0a 00c0 	add.w	r0, sl, r0, lsl #3
 80271d2:	ea4f 03cb 	mov.w	r3, fp, lsl #3
 80271d6:	f04f 0800 	mov.w	r8, #0
         i4 = i3 + n2;
         i5 = i4 + n2;
         i6 = i5 + n2;
         i7 = i6 + n2;
         i8 = i7 + n2;
         r1 = pSrc[2 * i1] + pSrc[2 * i5];
 80271da:	ed5e 1a01 	vldr	s3, [lr, #-4]
         r5 = pSrc[2 * i1] - pSrc[2 * i5];
         r2 = pSrc[2 * i2] + pSrc[2 * i6];
         r6 = pSrc[2 * i2] - pSrc[2 * i6];
         r3 = pSrc[2 * i3] + pSrc[2 * i7];
 80271de:	ed90 2a00 	vldr	s4, [r0]
         i6 = i5 + n2;
         i7 = i6 + n2;
         i8 = i7 + n2;
         r1 = pSrc[2 * i1] + pSrc[2 * i5];
         r5 = pSrc[2 * i1] - pSrc[2 * i5];
         r2 = pSrc[2 * i2] + pSrc[2 * i6];
 80271e2:	ed97 4a00 	vldr	s8, [r7]
 80271e6:	ed52 6a01 	vldr	s13, [r2, #-4]
         r6 = pSrc[2 * i2] - pSrc[2 * i6];
         r3 = pSrc[2 * i3] + pSrc[2 * i7];
         r7 = pSrc[2 * i3] - pSrc[2 * i7];
         r4 = pSrc[2 * i4] + pSrc[2 * i8];
 80271ea:	ed96 3a00 	vldr	s6, [r6]
 80271ee:	ed51 0a01 	vldr	s1, [r1, #-4]
         i4 = i3 + n2;
         i5 = i4 + n2;
         i6 = i5 + n2;
         i7 = i6 + n2;
         i8 = i7 + n2;
         r1 = pSrc[2 * i1] + pSrc[2 * i5];
 80271f2:	edd5 2a00 	vldr	s5, [r5]
         r5 = pSrc[2 * i1] - pSrc[2 * i5];
         r2 = pSrc[2 * i2] + pSrc[2 * i6];
         r6 = pSrc[2 * i2] - pSrc[2 * i6];
         r3 = pSrc[2 * i3] + pSrc[2 * i7];
 80271f6:	ed9c 1a00 	vldr	s2, [ip]
         i4 = i3 + n2;
         i5 = i4 + n2;
         i6 = i5 + n2;
         i7 = i6 + n2;
         i8 = i7 + n2;
         r1 = pSrc[2 * i1] + pSrc[2 * i5];
 80271fa:	ee31 0aa2 	vadd.f32	s0, s3, s5
         r5 = pSrc[2 * i1] - pSrc[2 * i5];
         r2 = pSrc[2 * i2] + pSrc[2 * i6];
         r6 = pSrc[2 * i2] - pSrc[2 * i6];
         r3 = pSrc[2 * i3] + pSrc[2 * i7];
 80271fe:	ee71 9a02 	vadd.f32	s19, s2, s4
         i6 = i5 + n2;
         i7 = i6 + n2;
         i8 = i7 + n2;
         r1 = pSrc[2 * i1] + pSrc[2 * i5];
         r5 = pSrc[2 * i1] - pSrc[2 * i5];
         r2 = pSrc[2 * i2] + pSrc[2 * i6];
 8027202:	ee34 6a26 	vadd.f32	s12, s8, s13
         r6 = pSrc[2 * i2] - pSrc[2 * i6];
         r3 = pSrc[2 * i3] + pSrc[2 * i7];
         r7 = pSrc[2 * i3] - pSrc[2 * i7];
         r4 = pSrc[2 * i4] + pSrc[2 * i8];
 8027206:	ee33 9a20 	vadd.f32	s18, s6, s1
         r8 = pSrc[2 * i4] - pSrc[2 * i8];
         t1 = r1 - r3;
         r1 = r1 + r3;
 802720a:	ee30 7a29 	vadd.f32	s14, s0, s19
         r3 = r2 - r4;
         r2 = r2 + r4;
 802720e:	ee76 7a09 	vadd.f32	s15, s12, s18
         i7 = i6 + n2;
         i8 = i7 + n2;
         r1 = pSrc[2 * i1] + pSrc[2 * i5];
         r5 = pSrc[2 * i1] - pSrc[2 * i5];
         r2 = pSrc[2 * i2] + pSrc[2 * i6];
         r6 = pSrc[2 * i2] - pSrc[2 * i6];
 8027212:	ee74 3a66 	vsub.f32	s7, s8, s13
         r8 = pSrc[2 * i4] - pSrc[2 * i8];
         t1 = r1 - r3;
         r1 = r1 + r3;
         r3 = r2 - r4;
         r2 = r2 + r4;
         pSrc[2 * i1] = r1 + r2;
 8027216:	ee77 6a27 	vadd.f32	s13, s14, s15
         pSrc[2 * i5] = r1 - r2;
 802721a:	ee37 7a67 	vsub.f32	s14, s14, s15
         r8 = pSrc[2 * i4] - pSrc[2 * i8];
         t1 = r1 - r3;
         r1 = r1 + r3;
         r3 = r2 - r4;
         r2 = r2 + r4;
         pSrc[2 * i1] = r1 + r2;
 802721e:	ed4e 6a01 	vstr	s13, [lr, #-4]
         pSrc[2 * i5] = r1 - r2;
 8027222:	ed85 7a00 	vstr	s14, [r5]
         r1 = pSrc[2 * i1 + 1] + pSrc[2 * i5 + 1];
         s5 = pSrc[2 * i1 + 1] - pSrc[2 * i5 + 1];
         r2 = pSrc[2 * i2 + 1] + pSrc[2 * i6 + 1];
 8027226:	edd7 5a01 	vldr	s11, [r7, #4]
 802722a:	edd2 6a00 	vldr	s13, [r2]
         s6 = pSrc[2 * i2 + 1] - pSrc[2 * i6 + 1];
         s3 = pSrc[2 * i3 + 1] + pSrc[2 * i7 + 1];
         s7 = pSrc[2 * i3 + 1] - pSrc[2 * i7 + 1];
         r4 = pSrc[2 * i4 + 1] + pSrc[2 * i8 + 1];
 802722e:	edd6 4a01 	vldr	s9, [r6, #4]
 8027232:	ed91 ba00 	vldr	s22, [r1]
         r1 = r1 + r3;
         r3 = r2 - r4;
         r2 = r2 + r4;
         pSrc[2 * i1] = r1 + r2;
         pSrc[2 * i5] = r1 - r2;
         r1 = pSrc[2 * i1 + 1] + pSrc[2 * i5 + 1];
 8027236:	edd5 8a01 	vldr	s17, [r5, #4]
 802723a:	ed9e 7a00 	vldr	s14, [lr]
         s5 = pSrc[2 * i1 + 1] - pSrc[2 * i5 + 1];
         r2 = pSrc[2 * i2 + 1] + pSrc[2 * i6 + 1];
         s6 = pSrc[2 * i2 + 1] - pSrc[2 * i6 + 1];
         s3 = pSrc[2 * i3 + 1] + pSrc[2 * i7 + 1];
 802723e:	edd0 7a01 	vldr	s15, [r0, #4]
 8027242:	ed9c 5a01 	vldr	s10, [ip, #4]
         r2 = pSrc[2 * i2] + pSrc[2 * i6];
         r6 = pSrc[2 * i2] - pSrc[2 * i6];
         r3 = pSrc[2 * i3] + pSrc[2 * i7];
         r7 = pSrc[2 * i3] - pSrc[2 * i7];
         r4 = pSrc[2 * i4] + pSrc[2 * i8];
         r8 = pSrc[2 * i4] - pSrc[2 * i8];
 8027246:	ee33 4a60 	vsub.f32	s8, s6, s1
         pSrc[2 * i1] = r1 + r2;
         pSrc[2 * i5] = r1 - r2;
         r1 = pSrc[2 * i1 + 1] + pSrc[2 * i5 + 1];
         s5 = pSrc[2 * i1 + 1] - pSrc[2 * i5 + 1];
         r2 = pSrc[2 * i2 + 1] + pSrc[2 * i6 + 1];
         s6 = pSrc[2 * i2 + 1] - pSrc[2 * i6 + 1];
 802724a:	ee35 3ae6 	vsub.f32	s6, s11, s13
         s3 = pSrc[2 * i3 + 1] + pSrc[2 * i7 + 1];
         s7 = pSrc[2 * i3 + 1] - pSrc[2 * i7 + 1];
         r4 = pSrc[2 * i4 + 1] + pSrc[2 * i8 + 1];
         s8 = pSrc[2 * i4 + 1] - pSrc[2 * i8 + 1];
 802724e:	ee74 0acb 	vsub.f32	s1, s9, s22
         r1 = pSrc[2 * i1] + pSrc[2 * i5];
         r5 = pSrc[2 * i1] - pSrc[2 * i5];
         r2 = pSrc[2 * i2] + pSrc[2 * i6];
         r6 = pSrc[2 * i2] - pSrc[2 * i6];
         r3 = pSrc[2 * i3] + pSrc[2 * i7];
         r7 = pSrc[2 * i3] - pSrc[2 * i7];
 8027252:	ee31 1a42 	vsub.f32	s2, s2, s4
         r1 = pSrc[2 * i1 + 1] + pSrc[2 * i5 + 1];
         s5 = pSrc[2 * i1 + 1] - pSrc[2 * i5 + 1];
         r2 = pSrc[2 * i2 + 1] + pSrc[2 * i6 + 1];
         s6 = pSrc[2 * i2 + 1] - pSrc[2 * i6 + 1];
         s3 = pSrc[2 * i3 + 1] + pSrc[2 * i7 + 1];
         s7 = pSrc[2 * i3 + 1] - pSrc[2 * i7 + 1];
 8027256:	ee35 8a67 	vsub.f32	s16, s10, s15
         r3 = r2 - r4;
         r2 = r2 + r4;
         pSrc[2 * i1] = r1 + r2;
         pSrc[2 * i5] = r1 - r2;
         r1 = pSrc[2 * i1 + 1] + pSrc[2 * i5 + 1];
         s5 = pSrc[2 * i1 + 1] - pSrc[2 * i5 + 1];
 802725a:	ee37 2a68 	vsub.f32	s4, s14, s17
         i5 = i4 + n2;
         i6 = i5 + n2;
         i7 = i6 + n2;
         i8 = i7 + n2;
         r1 = pSrc[2 * i1] + pSrc[2 * i5];
         r5 = pSrc[2 * i1] - pSrc[2 * i5];
 802725e:	ee71 2ae2 	vsub.f32	s5, s3, s5
         pSrc[2 * i3 + 1] = t2 - r3;
         pSrc[2 * i7 + 1] = t2 + r3;
         r1 = (r6 - r8) * C81;
         r6 = (r6 + r8) * C81;
         r2 = (s6 - s8) * C81;
         s6 = (s6 + s8) * C81;
 8027262:	ee73 1a20 	vadd.f32	s3, s6, s1
         pSrc[2 * i7]     = t1 - s3;
         pSrc[2 * i3 + 1] = t2 - r3;
         pSrc[2 * i7 + 1] = t2 + r3;
         r1 = (r6 - r8) * C81;
         r6 = (r6 + r8) * C81;
         r2 = (s6 - s8) * C81;
 8027266:	ee33 3a60 	vsub.f32	s6, s6, s1
         pSrc[2 * i5 + 1] = r1 - r2;
         pSrc[2 * i3]     = t1 + s3;
         pSrc[2 * i7]     = t1 - s3;
         pSrc[2 * i3 + 1] = t2 - r3;
         pSrc[2 * i7 + 1] = t2 + r3;
         r1 = (r6 - r8) * C81;
 802726a:	ee33 aac4 	vsub.f32	s20, s7, s8
         r2 = r2 + r4;
         pSrc[2 * i1] = r1 + r2;
         pSrc[2 * i5] = r1 - r2;
         r1 = pSrc[2 * i1 + 1] + pSrc[2 * i5 + 1];
         s5 = pSrc[2 * i1 + 1] - pSrc[2 * i5 + 1];
         r2 = pSrc[2 * i2 + 1] + pSrc[2 * i6 + 1];
 802726e:	ee75 0aa6 	vadd.f32	s1, s11, s13
         pSrc[2 * i3]     = t1 + s3;
         pSrc[2 * i7]     = t1 - s3;
         pSrc[2 * i3 + 1] = t2 - r3;
         pSrc[2 * i7 + 1] = t2 + r3;
         r1 = (r6 - r8) * C81;
         r6 = (r6 + r8) * C81;
 8027272:	ee33 4a84 	vadd.f32	s8, s7, s8
         r1 = r1 + r3;
         r3 = r2 - r4;
         r2 = r2 + r4;
         pSrc[2 * i1] = r1 + r2;
         pSrc[2 * i5] = r1 - r2;
         r1 = pSrc[2 * i1 + 1] + pSrc[2 * i5 + 1];
 8027276:	ee37 7a28 	vadd.f32	s14, s14, s17
         s5 = pSrc[2 * i1 + 1] - pSrc[2 * i5 + 1];
         r2 = pSrc[2 * i2 + 1] + pSrc[2 * i6 + 1];
         s6 = pSrc[2 * i2 + 1] - pSrc[2 * i6 + 1];
         s3 = pSrc[2 * i3 + 1] + pSrc[2 * i7 + 1];
         s7 = pSrc[2 * i3 + 1] - pSrc[2 * i7 + 1];
         r4 = pSrc[2 * i4 + 1] + pSrc[2 * i8 + 1];
 802727a:	ee74 5a8b 	vadd.f32	s11, s9, s22
         r8 = r7 - r6;
         r7 = r7 + r6;
         t2 = s5 - r2;
         s5 = s5 + r2;
         s8 = s7 - s6;
         s7 = s7 + s6;
 802727e:	eef0 8a48 	vmov.f32	s17, s16
         t1 = r5 - r1;
         r5 = r5 + r1;
         r8 = r7 - r6;
         r7 = r7 + r6;
         t2 = s5 - r2;
         s5 = s5 + r2;
 8027282:	eef0 3a42 	vmov.f32	s7, s4
         s6 = (s6 + s8) * C81;
         t1 = r5 - r1;
         r5 = r5 + r1;
         r8 = r7 - r6;
         r7 = r7 + r6;
         t2 = s5 - r2;
 8027286:	eef0 4a42 	vmov.f32	s9, s4
         s5 = s5 + r2;
         s8 = s7 - s6;
         s7 = s7 + s6;
 802728a:	eee1 8aaa 	vfma.f32	s17, s3, s21
         pSrc[2 * i2 + 1] = s5 - r7;
         pSrc[2 * i8 + 1] = s5 + r7;
         pSrc[2 * i6 + 1] = t2 - r8;
         pSrc[2 * i4 + 1] = t2 + r8;

         i1 += n1;
 802728e:	44d8      	add	r8, fp
      } while (i1 < fftLen);
 8027290:	45c1      	cmp	r9, r8
         r5 = r5 + r1;
         r8 = r7 - r6;
         r7 = r7 + r6;
         t2 = s5 - r2;
         s5 = s5 + r2;
         s8 = s7 - s6;
 8027292:	eea1 8aea 	vfms.f32	s16, s3, s21
         t1 = r5 - r1;
         r5 = r5 + r1;
         r8 = r7 - r6;
         r7 = r7 + r6;
         t2 = s5 - r2;
         s5 = s5 + r2;
 8027296:	eee3 3a2a 	vfma.f32	s7, s6, s21
         s6 = (s6 + s8) * C81;
         t1 = r5 - r1;
         r5 = r5 + r1;
         r8 = r7 - r6;
         r7 = r7 + r6;
         t2 = s5 - r2;
 802729a:	eee3 4a6a 	vfms.f32	s9, s6, s21
         r1 = (r6 - r8) * C81;
         r6 = (r6 + r8) * C81;
         r2 = (s6 - s8) * C81;
         s6 = (s6 + s8) * C81;
         t1 = r5 - r1;
         r5 = r5 + r1;
 802729e:	eef0 1a62 	vmov.f32	s3, s5
         r8 = r7 - r6;
         r7 = r7 + r6;
 80272a2:	eeb0 2a41 	vmov.f32	s4, s2
         r6 = (r6 + r8) * C81;
         r2 = (s6 - s8) * C81;
         s6 = (s6 + s8) * C81;
         t1 = r5 - r1;
         r5 = r5 + r1;
         r8 = r7 - r6;
 80272a6:	eeb0 3a41 	vmov.f32	s6, s2
         pSrc[2 * i5] = r1 - r2;
         r1 = pSrc[2 * i1 + 1] + pSrc[2 * i5 + 1];
         s5 = pSrc[2 * i1 + 1] - pSrc[2 * i5 + 1];
         r2 = pSrc[2 * i2 + 1] + pSrc[2 * i6 + 1];
         s6 = pSrc[2 * i2 + 1] - pSrc[2 * i6 + 1];
         s3 = pSrc[2 * i3 + 1] + pSrc[2 * i7 + 1];
 80272aa:	ee35 5a27 	vadd.f32	s10, s10, s15
         r2 = (s6 - s8) * C81;
         s6 = (s6 + s8) * C81;
         t1 = r5 - r1;
         r5 = r5 + r1;
         r8 = r7 - r6;
         r7 = r7 + r6;
 80272ae:	eea4 2a2a 	vfma.f32	s4, s8, s21
         r6 = (r6 + r8) * C81;
         r2 = (s6 - s8) * C81;
         s6 = (s6 + s8) * C81;
         t1 = r5 - r1;
         r5 = r5 + r1;
         r8 = r7 - r6;
 80272b2:	eea4 3a6a 	vfms.f32	s6, s8, s21
         r1 = (r6 - r8) * C81;
         r6 = (r6 + r8) * C81;
         r2 = (s6 - s8) * C81;
         s6 = (s6 + s8) * C81;
         t1 = r5 - r1;
         r5 = r5 + r1;
 80272b6:	eeea 1a2a 	vfma.f32	s3, s20, s21
         pSrc[2 * i7 + 1] = t2 + r3;
         r1 = (r6 - r8) * C81;
         r6 = (r6 + r8) * C81;
         r2 = (s6 - s8) * C81;
         s6 = (s6 + s8) * C81;
         t1 = r5 - r1;
 80272ba:	eeea 2a6a 	vfms.f32	s5, s20, s21
         r4 = pSrc[2 * i4 + 1] + pSrc[2 * i8 + 1];
         s8 = pSrc[2 * i4 + 1] - pSrc[2 * i8 + 1];
         t2 = r1 - s3;
         r1 = r1 + s3;
         s3 = r2 - r4;
         r2 = r2 + r4;
 80272be:	ee30 1aa5 	vadd.f32	s2, s1, s11
         s3 = pSrc[2 * i3 + 1] + pSrc[2 * i7 + 1];
         s7 = pSrc[2 * i3 + 1] - pSrc[2 * i7 + 1];
         r4 = pSrc[2 * i4 + 1] + pSrc[2 * i8 + 1];
         s8 = pSrc[2 * i4 + 1] - pSrc[2 * i8 + 1];
         t2 = r1 - s3;
         r1 = r1 + s3;
 80272c2:	ee37 4a05 	vadd.f32	s8, s14, s10
         s6 = pSrc[2 * i2 + 1] - pSrc[2 * i6 + 1];
         s3 = pSrc[2 * i3 + 1] + pSrc[2 * i7 + 1];
         s7 = pSrc[2 * i3 + 1] - pSrc[2 * i7 + 1];
         r4 = pSrc[2 * i4 + 1] + pSrc[2 * i8 + 1];
         s8 = pSrc[2 * i4 + 1] - pSrc[2 * i8 + 1];
         t2 = r1 - s3;
 80272c6:	ee77 7a45 	vsub.f32	s15, s14, s10
         r6 = pSrc[2 * i2] - pSrc[2 * i6];
         r3 = pSrc[2 * i3] + pSrc[2 * i7];
         r7 = pSrc[2 * i3] - pSrc[2 * i7];
         r4 = pSrc[2 * i4] + pSrc[2 * i8];
         r8 = pSrc[2 * i4] - pSrc[2 * i8];
         t1 = r1 - r3;
 80272ca:	ee70 6a69 	vsub.f32	s13, s0, s19
         r1 = r1 + r3;
         r3 = r2 - r4;
 80272ce:	ee36 6a49 	vsub.f32	s12, s12, s18
         s7 = pSrc[2 * i3 + 1] - pSrc[2 * i7 + 1];
         r4 = pSrc[2 * i4 + 1] + pSrc[2 * i8 + 1];
         s8 = pSrc[2 * i4 + 1] - pSrc[2 * i8 + 1];
         t2 = r1 - s3;
         r1 = r1 + s3;
         s3 = r2 - r4;
 80272d2:	ee70 5ae5 	vsub.f32	s11, s1, s11
         r2 = r2 + r4;
         pSrc[2 * i1 + 1] = r1 + r2;
 80272d6:	ee34 0a01 	vadd.f32	s0, s8, s2
         pSrc[2 * i5 + 1] = r1 - r2;
         pSrc[2 * i3]     = t1 + s3;
 80272da:	ee76 0aa5 	vadd.f32	s1, s13, s11
         t2 = r1 - s3;
         r1 = r1 + s3;
         s3 = r2 - r4;
         r2 = r2 + r4;
         pSrc[2 * i1 + 1] = r1 + r2;
         pSrc[2 * i5 + 1] = r1 - r2;
 80272de:	ee34 4a41 	vsub.f32	s8, s8, s2
         pSrc[2 * i3]     = t1 + s3;
         pSrc[2 * i7]     = t1 - s3;
 80272e2:	ee76 6ae5 	vsub.f32	s13, s13, s11
         pSrc[2 * i3 + 1] = t2 - r3;
 80272e6:	ee37 1ac6 	vsub.f32	s2, s15, s12
         r7 = r7 + r6;
         t2 = s5 - r2;
         s5 = s5 + r2;
         s8 = s7 - s6;
         s7 = s7 + s6;
         pSrc[2 * i2]     = r5 + s7;
 80272ea:	ee31 5aa8 	vadd.f32	s10, s3, s17
         pSrc[2 * i1 + 1] = r1 + r2;
         pSrc[2 * i5 + 1] = r1 - r2;
         pSrc[2 * i3]     = t1 + s3;
         pSrc[2 * i7]     = t1 - s3;
         pSrc[2 * i3 + 1] = t2 - r3;
         pSrc[2 * i7 + 1] = t2 + r3;
 80272ee:	ee77 7a86 	vadd.f32	s15, s15, s12
         s5 = s5 + r2;
         s8 = s7 - s6;
         s7 = s7 + s6;
         pSrc[2 * i2]     = r5 + s7;
         pSrc[2 * i8]     = r5 - s7;
         pSrc[2 * i6]     = t1 + s8;
 80272f2:	ee72 5a88 	vadd.f32	s11, s5, s16
         pSrc[2 * i4]     = t1 - s8;
         pSrc[2 * i2 + 1] = s5 - r7;
 80272f6:	ee33 6ac2 	vsub.f32	s12, s7, s4
         pSrc[2 * i8 + 1] = s5 + r7;
         pSrc[2 * i6 + 1] = t2 - r8;
 80272fa:	ee34 7ac3 	vsub.f32	s14, s9, s6
         t2 = s5 - r2;
         s5 = s5 + r2;
         s8 = s7 - s6;
         s7 = s7 + s6;
         pSrc[2 * i2]     = r5 + s7;
         pSrc[2 * i8]     = r5 - s7;
 80272fe:	ee71 1ae8 	vsub.f32	s3, s3, s17
         pSrc[2 * i6]     = t1 + s8;
         pSrc[2 * i4]     = t1 - s8;
 8027302:	ee72 2ac8 	vsub.f32	s5, s5, s16
         pSrc[2 * i2 + 1] = s5 - r7;
         pSrc[2 * i8 + 1] = s5 + r7;
 8027306:	ee73 3a82 	vadd.f32	s7, s7, s4
         pSrc[2 * i6 + 1] = t2 - r8;
         pSrc[2 * i4 + 1] = t2 + r8;
 802730a:	ee74 4a83 	vadd.f32	s9, s9, s6
         s8 = pSrc[2 * i4 + 1] - pSrc[2 * i8 + 1];
         t2 = r1 - s3;
         r1 = r1 + s3;
         s3 = r2 - r4;
         r2 = r2 + r4;
         pSrc[2 * i1 + 1] = r1 + r2;
 802730e:	ed8e 0a00 	vstr	s0, [lr]
         pSrc[2 * i5 + 1] = r1 - r2;
 8027312:	ed85 4a01 	vstr	s8, [r5, #4]
 8027316:	449e      	add	lr, r3
         pSrc[2 * i3]     = t1 + s3;
 8027318:	edcc 0a00 	vstr	s1, [ip]
 802731c:	441d      	add	r5, r3
         pSrc[2 * i7]     = t1 - s3;
 802731e:	edc0 6a00 	vstr	s13, [r0]
         pSrc[2 * i3 + 1] = t2 - r3;
 8027322:	ed8c 1a01 	vstr	s2, [ip, #4]
         pSrc[2 * i7 + 1] = t2 + r3;
 8027326:	edc0 7a01 	vstr	s15, [r0, #4]
 802732a:	449c      	add	ip, r3
         r7 = r7 + r6;
         t2 = s5 - r2;
         s5 = s5 + r2;
         s8 = s7 - s6;
         s7 = s7 + s6;
         pSrc[2 * i2]     = r5 + s7;
 802732c:	ed87 5a00 	vstr	s10, [r7]
 8027330:	4418      	add	r0, r3
         pSrc[2 * i8]     = r5 - s7;
 8027332:	ed41 1a01 	vstr	s3, [r1, #-4]
         pSrc[2 * i6]     = t1 + s8;
 8027336:	ed42 5a01 	vstr	s11, [r2, #-4]
         pSrc[2 * i4]     = t1 - s8;
 802733a:	edc6 2a00 	vstr	s5, [r6]
         pSrc[2 * i2 + 1] = s5 - r7;
 802733e:	ed87 6a01 	vstr	s12, [r7, #4]
         pSrc[2 * i8 + 1] = s5 + r7;
 8027342:	edc1 3a00 	vstr	s7, [r1]
 8027346:	441f      	add	r7, r3
         pSrc[2 * i6 + 1] = t2 - r8;
 8027348:	ed82 7a00 	vstr	s14, [r2]
 802734c:	4419      	add	r1, r3
         pSrc[2 * i4 + 1] = t2 + r8;
 802734e:	edc6 4a01 	vstr	s9, [r6, #4]
 8027352:	441a      	add	r2, r3
 8027354:	441e      	add	r6, r3

         i1 += n1;
      } while (i1 < fftLen);
 8027356:	f63f af40 	bhi.w	80271da <arm_radix8_butterfly_f32+0x66>

      if (n2 < 8)
 802735a:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 802735c:	9301      	str	r3, [sp, #4]
 802735e:	2a07      	cmp	r2, #7
 8027360:	4623      	mov	r3, r4
 8027362:	f240 81ca 	bls.w	80276fa <arm_radix8_butterfly_f32+0x586>
 8027366:	eb04 0e44 	add.w	lr, r4, r4, lsl #1
 802736a:	eb0e 0703 	add.w	r7, lr, r3
 802736e:	18fd      	adds	r5, r7, r3
 8027370:	18e8      	adds	r0, r5, r3
 8027372:	9c04      	ldr	r4, [sp, #16]
 8027374:	9300      	str	r3, [sp, #0]
 8027376:	eb00 0c03 	add.w	ip, r0, r3
 802737a:	00c0      	lsls	r0, r0, #3
 802737c:	9010      	str	r0, [sp, #64]	; 0x40
 802737e:	9800      	ldr	r0, [sp, #0]
 8027380:	18a1      	adds	r1, r4, r2
 8027382:	1c66      	adds	r6, r4, #1
 8027384:	ea4f 04ce 	mov.w	r4, lr, lsl #3
 8027388:	940f      	str	r4, [sp, #60]	; 0x3c
 802738a:	00c4      	lsls	r4, r0, #3
 802738c:	940d      	str	r4, [sp, #52]	; 0x34
 802738e:	9c02      	ldr	r4, [sp, #8]
 8027390:	3408      	adds	r4, #8
 8027392:	9417      	str	r4, [sp, #92]	; 0x5c
 8027394:	9c03      	ldr	r4, [sp, #12]
 8027396:	3408      	adds	r4, #8
 8027398:	00ed      	lsls	r5, r5, #3
 802739a:	9416      	str	r4, [sp, #88]	; 0x58
 802739c:	9c1a      	ldr	r4, [sp, #104]	; 0x68
 802739e:	9513      	str	r5, [sp, #76]	; 0x4c
 80273a0:	462b      	mov	r3, r5
 80273a2:	ea4f 05cc 	mov.w	r5, ip, lsl #3
 80273a6:	9512      	str	r5, [sp, #72]	; 0x48
 80273a8:	1965      	adds	r5, r4, r5
 80273aa:	9507      	str	r5, [sp, #28]
 80273ac:	9d10      	ldr	r5, [sp, #64]	; 0x40
 80273ae:	eb06 0682 	add.w	r6, r6, r2, lsl #2
 80273b2:	4416      	add	r6, r2
 80273b4:	1965      	adds	r5, r4, r5
 80273b6:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 80273ba:	0100      	lsls	r0, r0, #4
 80273bc:	00d2      	lsls	r2, r2, #3
 80273be:	9508      	str	r5, [sp, #32]
 80273c0:	18e5      	adds	r5, r4, r3
 80273c2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80273c4:	900e      	str	r0, [sp, #56]	; 0x38
 80273c6:	320c      	adds	r2, #12
 80273c8:	eb0a 06c6 	add.w	r6, sl, r6, lsl #3
 80273cc:	980c      	ldr	r0, [sp, #48]	; 0x30
 80273ce:	9214      	str	r2, [sp, #80]	; 0x50
 80273d0:	18e2      	adds	r2, r4, r3
 80273d2:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80273d4:	9509      	str	r5, [sp, #36]	; 0x24
 80273d6:	00ff      	lsls	r7, r7, #3
 80273d8:	1d35      	adds	r5, r6, #4
 80273da:	9e0f      	ldr	r6, [sp, #60]	; 0x3c
 80273dc:	950a      	str	r5, [sp, #40]	; 0x28
 80273de:	18e3      	adds	r3, r4, r3
 80273e0:	19e5      	adds	r5, r4, r7
 80273e2:	0140      	lsls	r0, r0, #5
 80273e4:	ea4f 0ec1 	mov.w	lr, r1, lsl #3
 80273e8:	9506      	str	r5, [sp, #24]
 80273ea:	0109      	lsls	r1, r1, #4
 80273ec:	19a5      	adds	r5, r4, r6
 80273ee:	9305      	str	r3, [sp, #20]
 80273f0:	f100 0308 	add.w	r3, r0, #8
 80273f4:	9504      	str	r5, [sp, #16]
 80273f6:	310c      	adds	r1, #12
 80273f8:	f10e 0508 	add.w	r5, lr, #8
 80273fc:	9318      	str	r3, [sp, #96]	; 0x60
 80273fe:	9b01      	ldr	r3, [sp, #4]
 8027400:	9203      	str	r2, [sp, #12]
 8027402:	9711      	str	r7, [sp, #68]	; 0x44
 8027404:	9519      	str	r5, [sp, #100]	; 0x64
 8027406:	9115      	str	r1, [sp, #84]	; 0x54
 8027408:	2200      	movs	r2, #0
 802740a:	f04f 0801 	mov.w	r8, #1
 802740e:	f102 0108 	add.w	r1, r2, #8
 8027412:	460f      	mov	r7, r1
 8027414:	910b      	str	r1, [sp, #44]	; 0x2c
 8027416:	9918      	ldr	r1, [sp, #96]	; 0x60
 8027418:	188e      	adds	r6, r1, r2
 802741a:	9917      	ldr	r1, [sp, #92]	; 0x5c
 802741c:	188d      	adds	r5, r1, r2
 802741e:	9916      	ldr	r1, [sp, #88]	; 0x58
 8027420:	188c      	adds	r4, r1, r2
 8027422:	9919      	ldr	r1, [sp, #100]	; 0x64
 8027424:	1888      	adds	r0, r1, r2
 8027426:	9914      	ldr	r1, [sp, #80]	; 0x50
 8027428:	eb01 0c02 	add.w	ip, r1, r2
 802742c:	9915      	ldr	r1, [sp, #84]	; 0x54
 802742e:	440a      	add	r2, r1
         ia4 = ia3 + id;
         ia5 = ia4 + id;
         ia6 = ia5 + id;
         ia7 = ia6 + id;

         co2 = pCoef[2 * ia1];
 8027430:	9903      	ldr	r1, [sp, #12]
 8027432:	ed91 fa00 	vldr	s30, [r1]
         co3 = pCoef[2 * ia2];
 8027436:	9905      	ldr	r1, [sp, #20]
 8027438:	edd1 ea00 	vldr	s29, [r1]
         co4 = pCoef[2 * ia3];
 802743c:	9904      	ldr	r1, [sp, #16]
 802743e:	ed91 ea00 	vldr	s28, [r1]
         co5 = pCoef[2 * ia4];
 8027442:	9906      	ldr	r1, [sp, #24]
 8027444:	edd1 da00 	vldr	s27, [r1]
         co6 = pCoef[2 * ia5];
 8027448:	9909      	ldr	r1, [sp, #36]	; 0x24
 802744a:	ed91 da00 	vldr	s26, [r1]
         co7 = pCoef[2 * ia6];
 802744e:	9908      	ldr	r1, [sp, #32]
 8027450:	edd1 ca00 	vldr	s25, [r1]
         co8 = pCoef[2 * ia7];
 8027454:	9907      	ldr	r1, [sp, #28]
 8027456:	ed91 ca00 	vldr	s24, [r1]
         si2 = pCoef[2 * ia1 + 1];
 802745a:	9903      	ldr	r1, [sp, #12]
 802745c:	edd1 ba01 	vldr	s23, [r1, #4]
         si3 = pCoef[2 * ia2 + 1];
 8027460:	9905      	ldr	r1, [sp, #20]
 8027462:	ed91 ba01 	vldr	s22, [r1, #4]
         si4 = pCoef[2 * ia3 + 1];
 8027466:	9904      	ldr	r1, [sp, #16]
 8027468:	ed91 aa01 	vldr	s20, [r1, #4]
         si5 = pCoef[2 * ia4 + 1];
 802746c:	9906      	ldr	r1, [sp, #24]
 802746e:	edd1 9a01 	vldr	s19, [r1, #4]
         si6 = pCoef[2 * ia5 + 1];
 8027472:	9909      	ldr	r1, [sp, #36]	; 0x24
 8027474:	edd1 7a01 	vldr	s15, [r1, #4]
         si7 = pCoef[2 * ia6 + 1];
 8027478:	9908      	ldr	r1, [sp, #32]
         co8 = pCoef[2 * ia7];
         si2 = pCoef[2 * ia1 + 1];
         si3 = pCoef[2 * ia2 + 1];
         si4 = pCoef[2 * ia3 + 1];
         si5 = pCoef[2 * ia4 + 1];
         si6 = pCoef[2 * ia5 + 1];
 802747a:	edcd 7a00 	vstr	s15, [sp]
         si7 = pCoef[2 * ia6 + 1];
 802747e:	edd1 7a01 	vldr	s15, [r1, #4]
         si8 = pCoef[2 * ia7 + 1];
 8027482:	9907      	ldr	r1, [sp, #28]
         si2 = pCoef[2 * ia1 + 1];
         si3 = pCoef[2 * ia2 + 1];
         si4 = pCoef[2 * ia3 + 1];
         si5 = pCoef[2 * ia4 + 1];
         si6 = pCoef[2 * ia5 + 1];
         si7 = pCoef[2 * ia6 + 1];
 8027484:	edcd 7a01 	vstr	s15, [sp, #4]
         si8 = pCoef[2 * ia7 + 1];
 8027488:	edd1 7a01 	vldr	s15, [r1, #4]
 802748c:	eb0a 0e07 	add.w	lr, sl, r7
 8027490:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 8027492:	edcd 7a02 	vstr	s15, [sp, #8]
 8027496:	eb0c 010a 	add.w	r1, ip, sl
 802749a:	4456      	add	r6, sl
 802749c:	4455      	add	r5, sl
 802749e:	4454      	add	r4, sl
 80274a0:	4450      	add	r0, sl
 80274a2:	4452      	add	r2, sl

         i1 = j;
 80274a4:	46c4      	mov	ip, r8
 80274a6:	e001      	b.n	80274ac <arm_radix8_butterfly_f32+0x338>
 80274a8:	3f3504f3 	.word	0x3f3504f3
            i4 = i3 + n2;
            i5 = i4 + n2;
            i6 = i5 + n2;
            i7 = i6 + n2;
            i8 = i7 + n2;
            r1 = pSrc[2 * i1] + pSrc[2 * i5];
 80274ac:	edde fa00 	vldr	s31, [lr]
            r5 = pSrc[2 * i1] - pSrc[2 * i5];
            r2 = pSrc[2 * i2] + pSrc[2 * i6];
            r6 = pSrc[2 * i2] - pSrc[2 * i6];
            r3 = pSrc[2 * i3] + pSrc[2 * i7];
 80274b0:	ed52 2a01 	vldr	s5, [r2, #-4]
            i6 = i5 + n2;
            i7 = i6 + n2;
            i8 = i7 + n2;
            r1 = pSrc[2 * i1] + pSrc[2 * i5];
            r5 = pSrc[2 * i1] - pSrc[2 * i5];
            r2 = pSrc[2 * i2] + pSrc[2 * i6];
 80274b4:	ed11 6a01 	vldr	s12, [r1, #-4]
            r6 = pSrc[2 * i2] - pSrc[2 * i6];
            r3 = pSrc[2 * i3] + pSrc[2 * i7];
            r7 = pSrc[2 * i3] - pSrc[2 * i7];
            r4 = pSrc[2 * i4] + pSrc[2 * i8];
 80274b8:	edd0 5a00 	vldr	s11, [r0]
 80274bc:	ed57 6a01 	vldr	s13, [r7, #-4]
            i4 = i3 + n2;
            i5 = i4 + n2;
            i6 = i5 + n2;
            i7 = i6 + n2;
            i8 = i7 + n2;
            r1 = pSrc[2 * i1] + pSrc[2 * i5];
 80274c0:	ed96 7a00 	vldr	s14, [r6]
            r5 = pSrc[2 * i1] - pSrc[2 * i5];
            r2 = pSrc[2 * i2] + pSrc[2 * i6];
            r6 = pSrc[2 * i2] - pSrc[2 * i6];
            r3 = pSrc[2 * i3] + pSrc[2 * i7];
 80274c4:	edd4 7a00 	vldr	s15, [r4]
            i6 = i5 + n2;
            i7 = i6 + n2;
            i8 = i7 + n2;
            r1 = pSrc[2 * i1] + pSrc[2 * i5];
            r5 = pSrc[2 * i1] - pSrc[2 * i5];
            r2 = pSrc[2 * i2] + pSrc[2 * i6];
 80274c8:	ed95 2a00 	vldr	s4, [r5]
            r1 = r1 + r3;
            r3 = r2 - r4;
            r2 = r2 + r4;
            pSrc[2 * i1] = r1 + r2;
            r2 = r1 - r2;
            s1 = pSrc[2 * i1 + 1] + pSrc[2 * i5 + 1];
 80274cc:	ed9e 8a01 	vldr	s16, [lr, #4]
            i4 = i3 + n2;
            i5 = i4 + n2;
            i6 = i5 + n2;
            i7 = i6 + n2;
            i8 = i7 + n2;
            r1 = pSrc[2 * i1] + pSrc[2 * i5];
 80274d0:	ee7f 0a87 	vadd.f32	s1, s31, s14
            r5 = pSrc[2 * i1] - pSrc[2 * i5];
            r2 = pSrc[2 * i2] + pSrc[2 * i6];
 80274d4:	ee32 1a06 	vadd.f32	s2, s4, s12
            r6 = pSrc[2 * i2] - pSrc[2 * i6];
            r3 = pSrc[2 * i3] + pSrc[2 * i7];
 80274d8:	ee37 4aa2 	vadd.f32	s8, s15, s5
            r7 = pSrc[2 * i3] - pSrc[2 * i7];
            r4 = pSrc[2 * i4] + pSrc[2 * i8];
 80274dc:	ee75 4aa6 	vadd.f32	s9, s11, s13
            r8 = pSrc[2 * i4] - pSrc[2 * i8];
            t1 = r1 - r3;
            r1 = r1 + r3;
 80274e0:	ee70 1a84 	vadd.f32	s3, s1, s8
            r3 = r2 - r4;
            r2 = r2 + r4;
 80274e4:	ee31 5a24 	vadd.f32	s10, s2, s9
            i7 = i6 + n2;
            i8 = i7 + n2;
            r1 = pSrc[2 * i1] + pSrc[2 * i5];
            r5 = pSrc[2 * i1] - pSrc[2 * i5];
            r2 = pSrc[2 * i2] + pSrc[2 * i6];
            r6 = pSrc[2 * i2] - pSrc[2 * i6];
 80274e8:	ee32 2a46 	vsub.f32	s4, s4, s12
            r8 = pSrc[2 * i4] - pSrc[2 * i8];
            t1 = r1 - r3;
            r1 = r1 + r3;
            r3 = r2 - r4;
            r2 = r2 + r4;
            pSrc[2 * i1] = r1 + r2;
 80274ec:	ee31 6a85 	vadd.f32	s12, s3, s10
            r2 = pSrc[2 * i2] + pSrc[2 * i6];
            r6 = pSrc[2 * i2] - pSrc[2 * i6];
            r3 = pSrc[2 * i3] + pSrc[2 * i7];
            r7 = pSrc[2 * i3] - pSrc[2 * i7];
            r4 = pSrc[2 * i4] + pSrc[2 * i8];
            r8 = pSrc[2 * i4] - pSrc[2 * i8];
 80274f0:	ee75 5ae6 	vsub.f32	s11, s11, s13
            t1 = r1 - r3;
            r1 = r1 + r3;
            r3 = r2 - r4;
            r2 = r2 + r4;
            pSrc[2 * i1] = r1 + r2;
 80274f4:	ed8e 6a00 	vstr	s12, [lr]
            s5 = pSrc[2 * i1 + 1] - pSrc[2 * i5 + 1];
            s2 = pSrc[2 * i2 + 1] + pSrc[2 * i6 + 1];
            s6 = pSrc[2 * i2 + 1] - pSrc[2 * i6 + 1];
            s3 = pSrc[2 * i3 + 1] + pSrc[2 * i7 + 1];
            s7 = pSrc[2 * i3 + 1] - pSrc[2 * i7 + 1];
            s4 = pSrc[2 * i4 + 1] + pSrc[2 * i8 + 1];
 80274f8:	edd0 8a01 	vldr	s17, [r0, #4]
            r2 = r2 + r4;
            pSrc[2 * i1] = r1 + r2;
            r2 = r1 - r2;
            s1 = pSrc[2 * i1 + 1] + pSrc[2 * i5 + 1];
            s5 = pSrc[2 * i1 + 1] - pSrc[2 * i5 + 1];
            s2 = pSrc[2 * i2 + 1] + pSrc[2 * i6 + 1];
 80274fc:	ed95 9a01 	vldr	s18, [r5, #4]
 8027500:	ed91 3a00 	vldr	s6, [r1]
            s6 = pSrc[2 * i2 + 1] - pSrc[2 * i6 + 1];
            s3 = pSrc[2 * i3 + 1] + pSrc[2 * i7 + 1];
            s7 = pSrc[2 * i3 + 1] - pSrc[2 * i7 + 1];
            s4 = pSrc[2 * i4 + 1] + pSrc[2 * i8 + 1];
 8027504:	ed97 6a00 	vldr	s12, [r7]
            r2 = r1 - r2;
            s1 = pSrc[2 * i1 + 1] + pSrc[2 * i5 + 1];
            s5 = pSrc[2 * i1 + 1] - pSrc[2 * i5 + 1];
            s2 = pSrc[2 * i2 + 1] + pSrc[2 * i6 + 1];
            s6 = pSrc[2 * i2 + 1] - pSrc[2 * i6 + 1];
            s3 = pSrc[2 * i3 + 1] + pSrc[2 * i7 + 1];
 8027508:	ed94 0a01 	vldr	s0, [r4, #4]
 802750c:	edd2 6a00 	vldr	s13, [r2]
            r1 = r1 + r3;
            r3 = r2 - r4;
            r2 = r2 + r4;
            pSrc[2 * i1] = r1 + r2;
            r2 = r1 - r2;
            s1 = pSrc[2 * i1 + 1] + pSrc[2 * i5 + 1];
 8027510:	edd6 3a01 	vldr	s7, [r6, #4]
            i5 = i4 + n2;
            i6 = i5 + n2;
            i7 = i6 + n2;
            i8 = i7 + n2;
            r1 = pSrc[2 * i1] + pSrc[2 * i5];
            r5 = pSrc[2 * i1] - pSrc[2 * i5];
 8027514:	ee3f 7ac7 	vsub.f32	s14, s31, s14
            r2 = pSrc[2 * i2] + pSrc[2 * i6];
            r6 = pSrc[2 * i2] - pSrc[2 * i6];
            r3 = pSrc[2 * i3] + pSrc[2 * i7];
            r7 = pSrc[2 * i3] - pSrc[2 * i7];
 8027518:	ee77 7ae2 	vsub.f32	s15, s15, s5
            s2 = pSrc[2 * i2 + 1] + pSrc[2 * i6 + 1];
            s6 = pSrc[2 * i2 + 1] - pSrc[2 * i6 + 1];
            s3 = pSrc[2 * i3 + 1] + pSrc[2 * i7 + 1];
            s7 = pSrc[2 * i3 + 1] - pSrc[2 * i7 + 1];
            s4 = pSrc[2 * i4 + 1] + pSrc[2 * i8 + 1];
            s8 = pSrc[2 * i4 + 1] - pSrc[2 * i8 + 1];
 802751c:	ee78 fac6 	vsub.f32	s31, s17, s12
            pSrc[2 * i1] = r1 + r2;
            r2 = r1 - r2;
            s1 = pSrc[2 * i1 + 1] + pSrc[2 * i5 + 1];
            s5 = pSrc[2 * i1 + 1] - pSrc[2 * i5 + 1];
            s2 = pSrc[2 * i2 + 1] + pSrc[2 * i6 + 1];
            s6 = pSrc[2 * i2 + 1] - pSrc[2 * i6 + 1];
 8027520:	ee79 2a43 	vsub.f32	s5, s18, s6
            r2 = r2 + r4;
            pSrc[2 * i1] = r1 + r2;
            r2 = r1 - r2;
            s1 = pSrc[2 * i1 + 1] + pSrc[2 * i5 + 1];
            s5 = pSrc[2 * i1 + 1] - pSrc[2 * i5 + 1];
            s2 = pSrc[2 * i2 + 1] + pSrc[2 * i6 + 1];
 8027524:	ee39 3a03 	vadd.f32	s6, s18, s6
            s6 = pSrc[2 * i2 + 1] - pSrc[2 * i6 + 1];
            s3 = pSrc[2 * i3 + 1] + pSrc[2 * i7 + 1];
            s7 = pSrc[2 * i3 + 1] - pSrc[2 * i7 + 1];
 8027528:	ee30 9a66 	vsub.f32	s18, s0, s13
            s4 = pSrc[2 * i4 + 1] + pSrc[2 * i8 + 1];
 802752c:	ee38 6a86 	vadd.f32	s12, s17, s12
            r2 = r1 - r2;
            s1 = pSrc[2 * i1 + 1] + pSrc[2 * i5 + 1];
            s5 = pSrc[2 * i1 + 1] - pSrc[2 * i5 + 1];
            s2 = pSrc[2 * i2 + 1] + pSrc[2 * i6 + 1];
            s6 = pSrc[2 * i2 + 1] - pSrc[2 * i6 + 1];
            s3 = pSrc[2 * i3 + 1] + pSrc[2 * i7 + 1];
 8027530:	ee70 6a26 	vadd.f32	s13, s0, s13
            r3 = r2 - r4;
            r2 = r2 + r4;
            pSrc[2 * i1] = r1 + r2;
            r2 = r1 - r2;
            s1 = pSrc[2 * i1 + 1] + pSrc[2 * i5 + 1];
            s5 = pSrc[2 * i1 + 1] - pSrc[2 * i5 + 1];
 8027534:	ee78 8a63 	vsub.f32	s17, s16, s7
            p4 = si7 * t1;
            pSrc[2 * i7]     = p1 + p2;
            pSrc[2 * i7 + 1] = p3 - p4;
            r1 = (r6 - r8) * C81;
            r6 = (r6 + r8) * C81;
            s1 = (s6 - s8) * C81;
 8027538:	ee32 0aef 	vsub.f32	s0, s5, s31
            s6 = (s6 + s8) * C81;
 802753c:	ee72 2aaf 	vadd.f32	s5, s5, s31
            r1 = r1 + r3;
            r3 = r2 - r4;
            r2 = r2 + r4;
            pSrc[2 * i1] = r1 + r2;
            r2 = r1 - r2;
            s1 = pSrc[2 * i1 + 1] + pSrc[2 * i5 + 1];
 8027540:	ee78 3a23 	vadd.f32	s7, s16, s7
            r6 = pSrc[2 * i2] - pSrc[2 * i6];
            r3 = pSrc[2 * i3] + pSrc[2 * i7];
            r7 = pSrc[2 * i3] - pSrc[2 * i7];
            r4 = pSrc[2 * i4] + pSrc[2 * i8];
            r8 = pSrc[2 * i4] - pSrc[2 * i8];
            t1 = r1 - r3;
 8027544:	ee30 4ac4 	vsub.f32	s8, s1, s8
            p3 = co7 * t2;
            p4 = si7 * t1;
            pSrc[2 * i7]     = p1 + p2;
            pSrc[2 * i7 + 1] = p3 - p4;
            r1 = (r6 - r8) * C81;
            r6 = (r6 + r8) * C81;
 8027548:	ee32 8a25 	vadd.f32	s16, s4, s11
            r8 = r7 - r6;
            r7 = r7 + r6;
            t2 = s5 - s1;
            s5 = s5 + s1;
            s8 = s7 - s6;
            s7 = s7 + s6;
 802754c:	eef0 0a49 	vmov.f32	s1, s18
            p2 = si7 * t2;
            p3 = co7 * t2;
            p4 = si7 * t1;
            pSrc[2 * i7]     = p1 + p2;
            pSrc[2 * i7 + 1] = p3 - p4;
            r1 = (r6 - r8) * C81;
 8027550:	ee72 5a65 	vsub.f32	s11, s4, s11
            r8 = r7 - r6;
            r7 = r7 + r6;
            t2 = s5 - s1;
            s5 = s5 + s1;
            s8 = s7 - s6;
            s7 = s7 + s6;
 8027554:	eee2 0aaa 	vfma.f32	s1, s5, s21
            p3 = co4 * t2;
            p4 = si4 * t1;
            pSrc[2 * i4]     = p1 + p2;
            pSrc[2 * i4 + 1] = p3 - p4;

            i1 += n1;
 8027558:	44dc      	add	ip, fp
         } while (i1 < fftLen);
 802755a:	45e1      	cmp	r9, ip
            r5 = r5 + r1;
            r8 = r7 - r6;
            r7 = r7 + r6;
            t2 = s5 - s1;
            s5 = s5 + s1;
            s8 = s7 - s6;
 802755c:	eea2 9aea 	vfms.f32	s18, s5, s21
            t1 = r5 - r1;
            r5 = r5 + r1;
            r8 = r7 - r6;
            r7 = r7 + r6;
            t2 = s5 - s1;
            s5 = s5 + s1;
 8027560:	eeb0 2a68 	vmov.f32	s4, s17
            r1 = (r6 - r8) * C81;
            r6 = (r6 + r8) * C81;
            s1 = (s6 - s8) * C81;
            s6 = (s6 + s8) * C81;
            t1 = r5 - r1;
            r5 = r5 + r1;
 8027564:	eef0 2a47 	vmov.f32	s5, s14
 8027568:	eee5 2aaa 	vfma.f32	s5, s11, s21
            pSrc[2 * i7 + 1] = p3 - p4;
            r1 = (r6 - r8) * C81;
            r6 = (r6 + r8) * C81;
            s1 = (s6 - s8) * C81;
            s6 = (s6 + s8) * C81;
            t1 = r5 - r1;
 802756c:	eea5 7aea 	vfms.f32	s14, s11, s21
            r5 = r5 + r1;
            r8 = r7 - r6;
            r7 = r7 + r6;
            t2 = s5 - s1;
            s5 = s5 + s1;
 8027570:	eea0 2a2a 	vfma.f32	s4, s0, s21
            s4 = pSrc[2 * i4 + 1] + pSrc[2 * i8 + 1];
            s8 = pSrc[2 * i4 + 1] - pSrc[2 * i8 + 1];
            t2 = s1 - s3;
            s1 = s1 + s3;
            s3 = s2 - s4;
            s2 = s2 + s4;
 8027574:	ee73 5a06 	vadd.f32	s11, s6, s12
            s6 = (s6 + s8) * C81;
            t1 = r5 - r1;
            r5 = r5 + r1;
            r8 = r7 - r6;
            r7 = r7 + r6;
            t2 = s5 - s1;
 8027578:	eee0 8a6a 	vfms.f32	s17, s0, s21
            s1 = (s6 - s8) * C81;
            s6 = (s6 + s8) * C81;
            t1 = r5 - r1;
            r5 = r5 + r1;
            r8 = r7 - r6;
            r7 = r7 + r6;
 802757c:	eef0 fa67 	vmov.f32	s31, s15
            s3 = pSrc[2 * i3 + 1] + pSrc[2 * i7 + 1];
            s7 = pSrc[2 * i3 + 1] - pSrc[2 * i7 + 1];
            s4 = pSrc[2 * i4 + 1] + pSrc[2 * i8 + 1];
            s8 = pSrc[2 * i4 + 1] - pSrc[2 * i8 + 1];
            t2 = s1 - s3;
            s1 = s1 + s3;
 8027580:	ee33 0aa6 	vadd.f32	s0, s7, s13
            r6 = (r6 + r8) * C81;
            s1 = (s6 - s8) * C81;
            s6 = (s6 + s8) * C81;
            t1 = r5 - r1;
            r5 = r5 + r1;
            r8 = r7 - r6;
 8027584:	eee8 7a6a 	vfms.f32	s15, s16, s21
            r7 = pSrc[2 * i3] - pSrc[2 * i7];
            r4 = pSrc[2 * i4] + pSrc[2 * i8];
            r8 = pSrc[2 * i4] - pSrc[2 * i8];
            t1 = r1 - r3;
            r1 = r1 + r3;
            r3 = r2 - r4;
 8027588:	ee71 4a64 	vsub.f32	s9, s2, s9
            r2 = r2 + r4;
            pSrc[2 * i1] = r1 + r2;
            r2 = r1 - r2;
 802758c:	ee31 5ac5 	vsub.f32	s10, s3, s10
            s1 = (s6 - s8) * C81;
            s6 = (s6 + s8) * C81;
            t1 = r5 - r1;
            r5 = r5 + r1;
            r8 = r7 - r6;
            r7 = r7 + r6;
 8027590:	eee8 fa2a 	vfma.f32	s31, s16, s21
            s7 = pSrc[2 * i3 + 1] - pSrc[2 * i7 + 1];
            s4 = pSrc[2 * i4 + 1] + pSrc[2 * i8 + 1];
            s8 = pSrc[2 * i4 + 1] - pSrc[2 * i8 + 1];
            t2 = s1 - s3;
            s1 = s1 + s3;
            s3 = s2 - s4;
 8027594:	ee33 3a46 	vsub.f32	s6, s6, s12
            s2 = s2 + s4;
            r1 = t1 + s3;
            t1 = t1 - s3;
            pSrc[2 * i1 + 1] = s1 + s2;
            s2 = s1 - s2;
 8027598:	ee30 8a65 	vsub.f32	s16, s0, s11
            s6 = pSrc[2 * i2 + 1] - pSrc[2 * i6 + 1];
            s3 = pSrc[2 * i3 + 1] + pSrc[2 * i7 + 1];
            s7 = pSrc[2 * i3 + 1] - pSrc[2 * i7 + 1];
            s4 = pSrc[2 * i4 + 1] + pSrc[2 * i8 + 1];
            s8 = pSrc[2 * i4 + 1] - pSrc[2 * i8 + 1];
            t2 = s1 - s3;
 802759c:	ee73 3ae6 	vsub.f32	s7, s7, s13
            s1 = s1 + s3;
            s3 = s2 - s4;
            s2 = s2 + s4;
            r1 = t1 + s3;
 80275a0:	ee34 6a03 	vadd.f32	s12, s8, s6
            r7 = r7 + r6;
            t2 = s5 - s1;
            s5 = s5 + s1;
            s8 = s7 - s6;
            s7 = s7 + s6;
            r1 = r5 + s7;
 80275a4:	ee72 6aa0 	vadd.f32	s13, s5, s1
            t2 = s1 - s3;
            s1 = s1 + s3;
            s3 = s2 - s4;
            s2 = s2 + s4;
            r1 = t1 + s3;
            t1 = t1 - s3;
 80275a8:	ee34 4a43 	vsub.f32	s8, s8, s6
            t2 = s5 - s1;
            s5 = s5 + s1;
            s8 = s7 - s6;
            s7 = s7 + s6;
            r1 = r5 + s7;
            r5 = r5 - s7;
 80275ac:	ee72 0ae0 	vsub.f32	s1, s5, s1
            s2 = s2 + s4;
            r1 = t1 + s3;
            t1 = t1 - s3;
            pSrc[2 * i1 + 1] = s1 + s2;
            s2 = s1 - s2;
            s1 = t2 - r3;
 80275b0:	ee33 3ae4 	vsub.f32	s6, s7, s9
 80275b4:	ee65 2a69 	vnmul.f32	s5, s10, s19
            t2 = t2 + r3;
 80275b8:	ee73 3aa4 	vadd.f32	s7, s7, s9
            s5 = s5 + s1;
            s8 = s7 - s6;
            s7 = s7 + s6;
            r1 = r5 + s7;
            r5 = r5 - s7;
            r6 = t1 + s8;
 80275bc:	ee77 4a09 	vadd.f32	s9, s14, s18
            t1 = t1 - s8;
 80275c0:	ee37 9a49 	vsub.f32	s18, s14, s18
            s1 = s5 - r7;
            s5 = s5 + r7;
            s6 = t2 - r8;
 80275c4:	ee38 7ae7 	vsub.f32	s14, s17, s15
            t2 = t2 + r8;
 80275c8:	ee78 8aa7 	vadd.f32	s17, s17, s15
            pSrc[2 * i1 + 1] = s1 + s2;
            s2 = s1 - s2;
            s1 = t2 - r3;
            t2 = t2 + r3;
            p1 = co5 * r2;
            p2 = si5 * s2;
 80275cc:	ee69 7a88 	vmul.f32	s15, s19, s16
            p3 = co5 * s2;
            p4 = si5 * r2;
            pSrc[2 * i5]     = p1 + p2;
            pSrc[2 * i5 + 1] = p3 - p4;
 80275d0:	eeed 2a88 	vfma.f32	s5, s27, s16
            t2 = t2 + r3;
            p1 = co5 * r2;
            p2 = si5 * s2;
            p3 = co5 * s2;
            p4 = si5 * r2;
            pSrc[2 * i5]     = p1 + p2;
 80275d4:	eeed 7a85 	vfma.f32	s15, s27, s10
            p3 = co3 * s1;
            p4 = si3 * r1;
            pSrc[2 * i3]     = p1 + p2;
            pSrc[2 * i3 + 1] = p3 - p4;
            p1 = co7 * t1;
            p2 = si7 * t2;
 80275d8:	ed9d 8a01 	vldr	s16, [sp, #4]
 80275dc:	ee26 5a4b 	vnmul.f32	s10, s12, s22
            p3 = co5 * s2;
            p4 = si5 * r2;
            pSrc[2 * i5]     = p1 + p2;
            pSrc[2 * i5 + 1] = p3 - p4;
            p1 = co3 * r1;
            p2 = si3 * s1;
 80275e0:	ee2b 1a03 	vmul.f32	s2, s22, s6
            s7 = s7 + s6;
            r1 = r5 + s7;
            r5 = r5 - s7;
            r6 = t1 + s8;
            t1 = t1 - s8;
            s1 = s5 - r7;
 80275e4:	ee72 1a6f 	vsub.f32	s3, s4, s31
            p1 = co3 * r1;
            p2 = si3 * s1;
            p3 = co3 * s1;
            p4 = si3 * r1;
            pSrc[2 * i3]     = p1 + p2;
            pSrc[2 * i3 + 1] = p3 - p4;
 80275e8:	eeae 5a83 	vfma.f32	s10, s29, s6
            pSrc[2 * i5 + 1] = p3 - p4;
            p1 = co3 * r1;
            p2 = si3 * s1;
            p3 = co3 * s1;
            p4 = si3 * r1;
            pSrc[2 * i3]     = p1 + p2;
 80275ec:	eeae 1a86 	vfma.f32	s2, s29, s12
            pSrc[2 * i3 + 1] = p3 - p4;
            p1 = co7 * t1;
            p2 = si7 * t2;
 80275f0:	ee28 3a23 	vmul.f32	s6, s16, s7
 80275f4:	ee24 6a48 	vnmul.f32	s12, s8, s16
            r1 = r5 + s7;
            r5 = r5 - s7;
            r6 = t1 + s8;
            t1 = t1 - s8;
            s1 = s5 - r7;
            s5 = s5 + r7;
 80275f8:	ee32 2a2f 	vadd.f32	s4, s4, s31
            p3 = co2 * s1;
            p4 = si2 * r1;
            pSrc[2 * i2]     = p1 + p2;
            pSrc[2 * i2 + 1] = p3 - p4;
            p1 = co8 * r5;
            p2 = si8 * s5;
 80275fc:	ed9d 8a02 	vldr	s16, [sp, #8]
            pSrc[2 * i3 + 1] = p3 - p4;
            p1 = co7 * t1;
            p2 = si7 * t2;
            p3 = co7 * t2;
            p4 = si7 * t1;
            pSrc[2 * i7]     = p1 + p2;
 8027600:	eeac 3a84 	vfma.f32	s6, s25, s8
            pSrc[2 * i7 + 1] = p3 - p4;
 8027604:	eeac 6aa3 	vfma.f32	s12, s25, s7
            s1 = s5 - r7;
            s5 = s5 + r7;
            s6 = t2 - r8;
            t2 = t2 + r8;
            p1 = co2 * r1;
            p2 = si2 * s1;
 8027608:	ee2b 4aa1 	vmul.f32	s8, s23, s3
 802760c:	ee66 3aeb 	vnmul.f32	s7, s13, s23
            p3 = co2 * s1;
            p4 = si2 * r1;
            pSrc[2 * i2]     = p1 + p2;
 8027610:	eeaf 4a26 	vfma.f32	s8, s30, s13
            pSrc[2 * i2 + 1] = p3 - p4;
 8027614:	eeef 3a21 	vfma.f32	s7, s30, s3
            p1 = co8 * r5;
            p2 = si8 * s5;
 8027618:	ee68 6a02 	vmul.f32	s13, s16, s4
 802761c:	ee60 1ac8 	vnmul.f32	s3, s1, s16
 8027620:	ed9d 8a00 	vldr	s16, [sp]
            p3 = co8 * s5;
            p4 = si8 * r5;
            pSrc[2 * i8]     = p1 + p2;
 8027624:	eeec 6a20 	vfma.f32	s13, s24, s1
            pSrc[2 * i8 + 1] = p3 - p4;
 8027628:	eeec 1a02 	vfma.f32	s3, s24, s4
 802762c:	ee64 0ac8 	vnmul.f32	s1, s9, s16
            p1 = co6 * r6;
            p2 = si6 * s6;
 8027630:	ee28 2a07 	vmul.f32	s4, s16, s14
            p3 = co6 * s6;
            p4 = si6 * r6;
            pSrc[2 * i6]     = p1 + p2;
            pSrc[2 * i6 + 1] = p3 - p4;
 8027634:	eeed 0a07 	vfma.f32	s1, s26, s14
            pSrc[2 * i8 + 1] = p3 - p4;
            p1 = co6 * r6;
            p2 = si6 * s6;
            p3 = co6 * s6;
            p4 = si6 * r6;
            pSrc[2 * i6]     = p1 + p2;
 8027638:	eead 2a24 	vfma.f32	s4, s26, s9
            pSrc[2 * i6 + 1] = p3 - p4;
            p1 = co4 * t1;
            p2 = si4 * t2;
 802763c:	ee2a 7a28 	vmul.f32	s14, s20, s17
 8027640:	ee69 4a4a 	vnmul.f32	s9, s18, s20
            p3 = co4 * t2;
            p4 = si4 * t1;
            pSrc[2 * i4]     = p1 + p2;
 8027644:	eeae 7a09 	vfma.f32	s14, s28, s18
            pSrc[2 * i4 + 1] = p3 - p4;
 8027648:	eeee 4a28 	vfma.f32	s9, s28, s17
            s1 = s1 + s3;
            s3 = s2 - s4;
            s2 = s2 + s4;
            r1 = t1 + s3;
            t1 = t1 - s3;
            pSrc[2 * i1 + 1] = s1 + s2;
 802764c:	ee70 5a25 	vadd.f32	s11, s0, s11
 8027650:	edce 5a01 	vstr	s11, [lr, #4]
            t2 = t2 + r3;
            p1 = co5 * r2;
            p2 = si5 * s2;
            p3 = co5 * s2;
            p4 = si5 * r2;
            pSrc[2 * i5]     = p1 + p2;
 8027654:	edc6 7a00 	vstr	s15, [r6]
            pSrc[2 * i5 + 1] = p3 - p4;
 8027658:	edc6 2a01 	vstr	s5, [r6, #4]
 802765c:	449e      	add	lr, r3
            p1 = co3 * r1;
            p2 = si3 * s1;
            p3 = co3 * s1;
            p4 = si3 * r1;
            pSrc[2 * i3]     = p1 + p2;
 802765e:	ed84 1a00 	vstr	s2, [r4]
            pSrc[2 * i3 + 1] = p3 - p4;
 8027662:	ed84 5a01 	vstr	s10, [r4, #4]
 8027666:	441e      	add	r6, r3
            p1 = co7 * t1;
            p2 = si7 * t2;
            p3 = co7 * t2;
            p4 = si7 * t1;
            pSrc[2 * i7]     = p1 + p2;
 8027668:	ed02 3a01 	vstr	s6, [r2, #-4]
            pSrc[2 * i7 + 1] = p3 - p4;
 802766c:	ed82 6a00 	vstr	s12, [r2]
 8027670:	441c      	add	r4, r3
            t2 = t2 + r8;
            p1 = co2 * r1;
            p2 = si2 * s1;
            p3 = co2 * s1;
            p4 = si2 * r1;
            pSrc[2 * i2]     = p1 + p2;
 8027672:	ed85 4a00 	vstr	s8, [r5]
            pSrc[2 * i2 + 1] = p3 - p4;
 8027676:	edc5 3a01 	vstr	s7, [r5, #4]
 802767a:	441a      	add	r2, r3
            p1 = co8 * r5;
            p2 = si8 * s5;
            p3 = co8 * s5;
            p4 = si8 * r5;
            pSrc[2 * i8]     = p1 + p2;
 802767c:	ed47 6a01 	vstr	s13, [r7, #-4]
            pSrc[2 * i8 + 1] = p3 - p4;
 8027680:	edc7 1a00 	vstr	s3, [r7]
 8027684:	441d      	add	r5, r3
            p1 = co6 * r6;
            p2 = si6 * s6;
            p3 = co6 * s6;
            p4 = si6 * r6;
            pSrc[2 * i6]     = p1 + p2;
 8027686:	ed01 2a01 	vstr	s4, [r1, #-4]
            pSrc[2 * i6 + 1] = p3 - p4;
 802768a:	edc1 0a00 	vstr	s1, [r1]
 802768e:	441f      	add	r7, r3
            p1 = co4 * t1;
            p2 = si4 * t2;
            p3 = co4 * t2;
            p4 = si4 * t1;
            pSrc[2 * i4]     = p1 + p2;
 8027690:	ed80 7a00 	vstr	s14, [r0]
 8027694:	4419      	add	r1, r3
            pSrc[2 * i4 + 1] = p3 - p4;
 8027696:	edc0 4a01 	vstr	s9, [r0, #4]
 802769a:	4418      	add	r0, r3

            i1 += n1;
         } while (i1 < fftLen);
 802769c:	f63f af06 	bhi.w	80274ac <arm_radix8_butterfly_f32+0x338>
 80276a0:	9a03      	ldr	r2, [sp, #12]
 80276a2:	990d      	ldr	r1, [sp, #52]	; 0x34
 80276a4:	440a      	add	r2, r1
 80276a6:	9203      	str	r2, [sp, #12]
 80276a8:	990e      	ldr	r1, [sp, #56]	; 0x38
 80276aa:	9a05      	ldr	r2, [sp, #20]
 80276ac:	440a      	add	r2, r1
 80276ae:	9205      	str	r2, [sp, #20]
 80276b0:	990f      	ldr	r1, [sp, #60]	; 0x3c
 80276b2:	9a04      	ldr	r2, [sp, #16]
 80276b4:	440a      	add	r2, r1
 80276b6:	9204      	str	r2, [sp, #16]
 80276b8:	9911      	ldr	r1, [sp, #68]	; 0x44
 80276ba:	9a06      	ldr	r2, [sp, #24]
 80276bc:	440a      	add	r2, r1
 80276be:	9206      	str	r2, [sp, #24]
 80276c0:	9913      	ldr	r1, [sp, #76]	; 0x4c
 80276c2:	9a09      	ldr	r2, [sp, #36]	; 0x24
 80276c4:	440a      	add	r2, r1
 80276c6:	9209      	str	r2, [sp, #36]	; 0x24
 80276c8:	9910      	ldr	r1, [sp, #64]	; 0x40
 80276ca:	9a08      	ldr	r2, [sp, #32]
 80276cc:	440a      	add	r2, r1
 80276ce:	9208      	str	r2, [sp, #32]
 80276d0:	9912      	ldr	r1, [sp, #72]	; 0x48
 80276d2:	9a07      	ldr	r2, [sp, #28]
 80276d4:	440a      	add	r2, r1
 80276d6:	9207      	str	r2, [sp, #28]

         j++;
      } while (j < n2);
 80276d8:	990c      	ldr	r1, [sp, #48]	; 0x30
 80276da:	9a0a      	ldr	r2, [sp, #40]	; 0x28
            pSrc[2 * i4 + 1] = p3 - p4;

            i1 += n1;
         } while (i1 < fftLen);

         j++;
 80276dc:	f108 0801 	add.w	r8, r8, #1
 80276e0:	3208      	adds	r2, #8
      } while (j < n2);
 80276e2:	4588      	cmp	r8, r1
 80276e4:	920a      	str	r2, [sp, #40]	; 0x28
 80276e6:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 80276e8:	f47f ae91 	bne.w	802740e <arm_radix8_butterfly_f32+0x29a>

      twidCoefModifier <<= 3;
 80276ec:	f8bd 3034 	ldrh.w	r3, [sp, #52]	; 0x34
 80276f0:	9300      	str	r3, [sp, #0]
 80276f2:	46c3      	mov	fp, r8
 80276f4:	f8dd e06c 	ldr.w	lr, [sp, #108]	; 0x6c
 80276f8:	e54c      	b.n	8027194 <arm_radix8_butterfly_f32+0x20>
   } while (n2 > 7);
}
 80276fa:	b01d      	add	sp, #116	; 0x74
 80276fc:	ecbd 8b10 	vpop	{d8-d15}
 8027700:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08027704 <arm_max_f32>:
void arm_max_f32(
  float32_t * pSrc,
  uint32_t blockSize,
  float32_t * pResult,
  uint32_t * pIndex)
{
 8027704:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  outIndex = 0u;
  /* Load first input value that act as reference value for comparision */
  out = *pSrc++;

  /* Loop unrolling */
  blkCnt = (blockSize - 1u) >> 2u;
 8027708:	1e4f      	subs	r7, r1, #1

  while (blkCnt > 0u)
 802770a:	ea5f 0897 	movs.w	r8, r7, lsr #2
  /* Initialise the count value. */
  count = 0u;
  /* Initialise the index value to zero. */
  outIndex = 0u;
  /* Load first input value that act as reference value for comparision */
  out = *pSrc++;
 802770e:	f100 0e04 	add.w	lr, r0, #4
 8027712:	edd0 7a00 	vldr	s15, [r0]

  /* Loop unrolling */
  blkCnt = (blockSize - 1u) >> 2u;

  while (blkCnt > 0u)
 8027716:	d058      	beq.n	80277ca <arm_max_f32+0xc6>
 8027718:	3014      	adds	r0, #20
 802771a:	46c4      	mov	ip, r8
 802771c:	2604      	movs	r6, #4
 802771e:	2400      	movs	r4, #0
  {
    /* Initialize maxVal to the next consecutive values one by one */
    maxVal1 = *pSrc++;
 8027720:	ed10 6a04 	vldr	s12, [r0, #-16]
    maxVal2 = *pSrc++;
 8027724:	ed50 6a03 	vldr	s13, [r0, #-12]
      out = maxVal2;
      outIndex = count + 2u;
    }

    /* Initialize maxVal to the next consecutive values one by one */
    maxVal1 = *pSrc++;
 8027728:	ed10 7a02 	vldr	s14, [r0, #-8]
    maxVal2 = *pSrc++;
 802772c:	ed50 5a01 	vldr	s11, [r0, #-4]
 8027730:	eeb4 6ae7 	vcmpe.f32	s12, s15
 8027734:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8027738:	bfc8      	it	gt
 802773a:	eef0 7a46 	vmovgt.f32	s15, s12
    /* compare for the maximum value */
    if (out < maxVal1)
    {
      /* Update the maximum value and its index */
      out = maxVal1;
      outIndex = count + 1u;
 802773e:	f1a6 0503 	sub.w	r5, r6, #3
 8027742:	eef4 7ae6 	vcmpe.f32	s15, s13
 8027746:	bfc8      	it	gt
 8027748:	462c      	movgt	r4, r5
 802774a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802774e:	bf48      	it	mi
 8027750:	eef0 7a66 	vmovmi.f32	s15, s13
    /* compare for the maximum value */
    if (out < maxVal2)
    {
      /* Update the maximum value and its index */
      out = maxVal2;
      outIndex = count + 2u;
 8027754:	f1a6 0502 	sub.w	r5, r6, #2
 8027758:	eef4 7ac7 	vcmpe.f32	s15, s14
 802775c:	bf48      	it	mi
 802775e:	462c      	movmi	r4, r5
 8027760:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8027764:	bf48      	it	mi
 8027766:	eef0 7a47 	vmovmi.f32	s15, s14
    /* compare for the maximum value */
    if (out < maxVal1)
    {
      /* Update the maximum value and its index */
      out = maxVal1;
      outIndex = count + 3u;
 802776a:	f106 35ff 	add.w	r5, r6, #4294967295
 802776e:	eef4 7ae5 	vcmpe.f32	s15, s11
 8027772:	bf48      	it	mi
 8027774:	462c      	movmi	r4, r5
 8027776:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802777a:	bf48      	it	mi
 802777c:	4634      	movmi	r4, r6
 802777e:	bf48      	it	mi
 8027780:	eef0 7a65 	vmovmi.f32	s15, s11
  out = *pSrc++;

  /* Loop unrolling */
  blkCnt = (blockSize - 1u) >> 2u;

  while (blkCnt > 0u)
 8027784:	f1bc 0c01 	subs.w	ip, ip, #1
 8027788:	f106 0604 	add.w	r6, r6, #4
 802778c:	f100 0010 	add.w	r0, r0, #16
 8027790:	d1c6      	bne.n	8027720 <arm_max_f32+0x1c>
 8027792:	eb0e 1e08 	add.w	lr, lr, r8, lsl #4

  blkCnt = (blockSize - 1u);

#endif /* #if defined (ARM_MATH_DSP) */

  while (blkCnt > 0u)
 8027796:	f017 0003 	ands.w	r0, r7, #3
 802779a:	d018      	beq.n	80277ce <arm_max_f32+0xca>
 802779c:	1a08      	subs	r0, r1, r0
  {
    /* Initialize maxVal to the next consecutive values one by one */
    maxVal1 = *pSrc++;
 802779e:	ecbe 7a01 	vldmia	lr!, {s14}
 80277a2:	eeb4 7ae7 	vcmpe.f32	s14, s15
 80277a6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80277aa:	bfc8      	it	gt
 80277ac:	4604      	movgt	r4, r0
 80277ae:	f100 0001 	add.w	r0, r0, #1
 80277b2:	bfd8      	it	le
 80277b4:	eeb0 7a67 	vmovle.f32	s14, s15

  blkCnt = (blockSize - 1u);

#endif /* #if defined (ARM_MATH_DSP) */

  while (blkCnt > 0u)
 80277b8:	4288      	cmp	r0, r1
 80277ba:	eef0 7a47 	vmov.f32	s15, s14
 80277be:	d1ee      	bne.n	802779e <arm_max_f32+0x9a>
    /* Decrement the loop counter */
    blkCnt--;
  }

  /* Store the maximum value and it's index into destination pointers */
  *pResult = out;
 80277c0:	ed82 7a00 	vstr	s14, [r2]
  *pIndex = outIndex;
 80277c4:	601c      	str	r4, [r3, #0]
 80277c6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  uint32_t blkCnt, outIndex, count;              /* loop counter */

  /* Initialise the count value. */
  count = 0u;
  /* Initialise the index value to zero. */
  outIndex = 0u;
 80277ca:	4644      	mov	r4, r8
 80277cc:	e7e3      	b.n	8027796 <arm_max_f32+0x92>

  blkCnt = (blockSize - 1u);

#endif /* #if defined (ARM_MATH_DSP) */

  while (blkCnt > 0u)
 80277ce:	eeb0 7a67 	vmov.f32	s14, s15
 80277d2:	e7f5      	b.n	80277c0 <arm_max_f32+0xbc>

080277d4 <arm_mean_f32>:

void arm_mean_f32(
  float32_t * pSrc,
  uint32_t blockSize,
  float32_t * pResult)
{
 80277d4:	b430      	push	{r4, r5}
  /*loop Unrolling */
  blkCnt = blockSize >> 2u;

  /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.
   ** a second loop below computes the remaining 1 to 3 samples. */
  while (blkCnt > 0u)
 80277d6:	088d      	lsrs	r5, r1, #2
 80277d8:	eddf 7a17 	vldr	s15, [pc, #92]	; 8027838 <arm_mean_f32+0x64>
 80277dc:	d018      	beq.n	8027810 <arm_mean_f32+0x3c>
 80277de:	f100 0310 	add.w	r3, r0, #16
 80277e2:	462c      	mov	r4, r5
    in1 = *pSrc++;
    in2 = *pSrc++;
    in3 = *pSrc++;
    in4 = *pSrc++;

    sum += in1;
 80277e4:	ed13 7a04 	vldr	s14, [r3, #-16]
    sum += in2;
 80277e8:	ed53 5a03 	vldr	s11, [r3, #-12]
    sum += in3;
 80277ec:	ed13 6a02 	vldr	s12, [r3, #-8]
    sum += in4;
 80277f0:	ed53 6a01 	vldr	s13, [r3, #-4]
    in1 = *pSrc++;
    in2 = *pSrc++;
    in3 = *pSrc++;
    in4 = *pSrc++;

    sum += in1;
 80277f4:	ee37 7a87 	vadd.f32	s14, s15, s14
  /*loop Unrolling */
  blkCnt = blockSize >> 2u;

  /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.
   ** a second loop below computes the remaining 1 to 3 samples. */
  while (blkCnt > 0u)
 80277f8:	3c01      	subs	r4, #1
    in2 = *pSrc++;
    in3 = *pSrc++;
    in4 = *pSrc++;

    sum += in1;
    sum += in2;
 80277fa:	ee77 7a25 	vadd.f32	s15, s14, s11
 80277fe:	f103 0310 	add.w	r3, r3, #16
    sum += in3;
 8027802:	ee77 7a86 	vadd.f32	s15, s15, s12
    sum += in4;
 8027806:	ee77 7aa6 	vadd.f32	s15, s15, s13
  /*loop Unrolling */
  blkCnt = blockSize >> 2u;

  /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.
   ** a second loop below computes the remaining 1 to 3 samples. */
  while (blkCnt > 0u)
 802780a:	d1eb      	bne.n	80277e4 <arm_mean_f32+0x10>
 802780c:	eb00 1005 	add.w	r0, r0, r5, lsl #4
  /* Loop over blockSize number of values */
  blkCnt = blockSize;

#endif /* #if defined (ARM_MATH_DSP) */

  while (blkCnt > 0u)
 8027810:	f011 0303 	ands.w	r3, r1, #3
 8027814:	d005      	beq.n	8027822 <arm_mean_f32+0x4e>
  {
    /* C = (A[0] + A[1] + A[2] + ... + A[blockSize-1]) */
    sum += *pSrc++;
 8027816:	ecb0 7a01 	vldmia	r0!, {s14}
  /* Loop over blockSize number of values */
  blkCnt = blockSize;

#endif /* #if defined (ARM_MATH_DSP) */

  while (blkCnt > 0u)
 802781a:	3b01      	subs	r3, #1
  {
    /* C = (A[0] + A[1] + A[2] + ... + A[blockSize-1]) */
    sum += *pSrc++;
 802781c:	ee77 7a87 	vadd.f32	s15, s15, s14
  /* Loop over blockSize number of values */
  blkCnt = blockSize;

#endif /* #if defined (ARM_MATH_DSP) */

  while (blkCnt > 0u)
 8027820:	d1f9      	bne.n	8027816 <arm_mean_f32+0x42>
    blkCnt--;
  }

  /* C = (A[0] + A[1] + A[2] + ... + A[blockSize-1]) / blockSize  */
  /* Store the result to the destination */
  *pResult = sum / (float32_t) blockSize;
 8027822:	ee07 1a10 	vmov	s14, r1
 8027826:	eeb8 7a47 	vcvt.f32.u32	s14, s14
}
 802782a:	bc30      	pop	{r4, r5}
    blkCnt--;
  }

  /* C = (A[0] + A[1] + A[2] + ... + A[blockSize-1]) / blockSize  */
  /* Store the result to the destination */
  *pResult = sum / (float32_t) blockSize;
 802782c:	eec7 7a87 	vdiv.f32	s15, s15, s14
 8027830:	edc2 7a00 	vstr	s15, [r2]
}
 8027834:	4770      	bx	lr
 8027836:	bf00      	nop
 8027838:	00000000 	.word	0x00000000

0802783c <arm_cos_f32>:
  int32_t n;
  float32_t findex;

  /* input x is in radians */
  /* Scale the input to [0 1] range from [0 2*PI] , divide input by 2*pi, add 0.25 (pi/2) to read sine table */
  in = x * 0.159154943092f + 0.25f;
 802783c:	ed9f 7a1c 	vldr	s14, [pc, #112]	; 80278b0 <arm_cos_f32+0x74>
 8027840:	ee06 0a90 	vmov	s13, r0
 8027844:	eef5 7a00 	vmov.f32	s15, #80	; 0x50
 8027848:	eee6 7a87 	vfma.f32	s15, s13, s14

  /* Calculation of floor value of input */
  n = (int32_t) in;

  /* Make negative values towards -infinity */
  if (in < 0.0f)
 802784c:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8027850:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  /* input x is in radians */
  /* Scale the input to [0 1] range from [0 2*PI] , divide input by 2*pi, add 0.25 (pi/2) to read sine table */
  in = x * 0.159154943092f + 0.25f;

  /* Calculation of floor value of input */
  n = (int32_t) in;
 8027854:	eebd 7ae7 	vcvt.s32.f32	s14, s15

  /* Make negative values towards -infinity */
  if (in < 0.0f)
 8027858:	d504      	bpl.n	8027864 <arm_cos_f32+0x28>
  {
    n--;
 802785a:	ee17 3a10 	vmov	r3, s14
 802785e:	3b01      	subs	r3, #1
 8027860:	ee07 3a10 	vmov	s14, r3
  }

  /* Map input value to [0 1] */
  in = in - (float32_t) n;
 8027864:	eeb8 7ac7 	vcvt.f32.s32	s14, s14

  /* Calculation of index of the table */
  findex = (float32_t) FAST_MATH_TABLE_SIZE * in;
 8027868:	eddf 6a12 	vldr	s13, [pc, #72]	; 80278b4 <arm_cos_f32+0x78>
  /* fractional value calculation */
  fract = findex - (float32_t) index;

  /* Read two nearest values of input value from the cos table */
  a = sinTable_f32[index];
  b = sinTable_f32[index+1];
 802786c:	4a12      	ldr	r2, [pc, #72]	; (80278b8 <arm_cos_f32+0x7c>)
  {
    n--;
  }

  /* Map input value to [0 1] */
  in = in - (float32_t) n;
 802786e:	ee77 7ac7 	vsub.f32	s15, s15, s14
  /* Read two nearest values of input value from the cos table */
  a = sinTable_f32[index];
  b = sinTable_f32[index+1];

  /* Linear interpolation process */
  cosVal = (1.0f-fract)*a + fract*b;
 8027872:	eeb7 7a00 	vmov.f32	s14, #112	; 0x70

  /* Map input value to [0 1] */
  in = in - (float32_t) n;

  /* Calculation of index of the table */
  findex = (float32_t) FAST_MATH_TABLE_SIZE * in;
 8027876:	ee67 7aa6 	vmul.f32	s15, s15, s13
  index = ((uint16_t)findex) & 0x1ff;
 802787a:	eefc 6ae7 	vcvt.u32.f32	s13, s15
 802787e:	ee16 3a90 	vmov	r3, s13
 8027882:	f3c3 0308 	ubfx	r3, r3, #0, #9

  /* fractional value calculation */
  fract = findex - (float32_t) index;
 8027886:	ee06 3a90 	vmov	s13, r3
 802788a:	eef8 6a66 	vcvt.f32.u32	s13, s13

  /* Read two nearest values of input value from the cos table */
  a = sinTable_f32[index];
  b = sinTable_f32[index+1];
 802788e:	eb02 0183 	add.w	r1, r2, r3, lsl #2
  /* Calculation of index of the table */
  findex = (float32_t) FAST_MATH_TABLE_SIZE * in;
  index = ((uint16_t)findex) & 0x1ff;

  /* fractional value calculation */
  fract = findex - (float32_t) index;
 8027892:	ee77 7ae6 	vsub.f32	s15, s15, s13
  /* Read two nearest values of input value from the cos table */
  a = sinTable_f32[index];
  b = sinTable_f32[index+1];

  /* Linear interpolation process */
  cosVal = (1.0f-fract)*a + fract*b;
 8027896:	edd1 6a01 	vldr	s13, [r1, #4]
 802789a:	ee37 7a67 	vsub.f32	s14, s14, s15
 802789e:	ee67 7aa6 	vmul.f32	s15, s15, s13
 80278a2:	edd1 6a00 	vldr	s13, [r1]

  /* Return the output value */
  return (cosVal);
}
 80278a6:	eee7 7a26 	vfma.f32	s15, s14, s13
 80278aa:	ee17 0a90 	vmov	r0, s15
 80278ae:	4770      	bx	lr
 80278b0:	3e22f983 	.word	0x3e22f983
 80278b4:	44000000 	.word	0x44000000
 80278b8:	0802e8d4 	.word	0x0802e8d4

080278bc <arm_cmplx_mag_f32>:

void arm_cmplx_mag_f32(
  float32_t * pSrc,
  float32_t * pDst,
  uint32_t numSamples)
{
 80278bc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  /*loop Unrolling */
  blkCnt = numSamples >> 2u;

  /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.
   ** a second loop below computes the remaining 1 to 3 samples. */
  while (blkCnt > 0u)
 80278c0:	ea5f 0992 	movs.w	r9, r2, lsr #2

void arm_cmplx_mag_f32(
  float32_t * pSrc,
  float32_t * pDst,
  uint32_t numSamples)
{
 80278c4:	b083      	sub	sp, #12
 80278c6:	4606      	mov	r6, r0
  /*loop Unrolling */
  blkCnt = numSamples >> 2u;

  /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.
   ** a second loop below computes the remaining 1 to 3 samples. */
  while (blkCnt > 0u)
 80278c8:	d078      	beq.n	80279bc <arm_cmplx_mag_f32+0x100>
   */
  CMSIS_INLINE __STATIC_INLINE arm_status arm_sqrt_f32(
  float32_t in,
  float32_t * pOut)
  {
    if (in >= 0.0f)
 80278ca:	f04f 0800 	mov.w	r8, #0
 80278ce:	f100 0420 	add.w	r4, r0, #32
 80278d2:	f101 0510 	add.w	r5, r1, #16
 80278d6:	464f      	mov	r7, r9
 80278d8:	e054      	b.n	8027984 <arm_cmplx_mag_f32+0xc8>
#if   (__FPU_USED == 1) && defined ( __CC_ARM   )
      *pOut = __sqrtf(in);
#elif (__FPU_USED == 1) && (defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050))
      *pOut = __builtin_sqrtf(in);
#elif (__FPU_USED == 1) && defined(__GNUC__)
      *pOut = __builtin_sqrtf(in);
 80278da:	eeb1 7ae7 	vsqrt.f32	s14, s15
 80278de:	eeb4 7a47 	vcmp.f32	s14, s14
 80278e2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80278e6:	f040 809a 	bne.w	8027a1e <arm_cmplx_mag_f32+0x162>
 80278ea:	ed05 7a04 	vstr	s14, [r5, #-16]
    imagIn = *pSrc++;
    /* store the result in the destination buffer. */
    arm_sqrt_f32((realIn * realIn) + (imagIn * imagIn), pDst++);

    realIn = *pSrc++;
    imagIn = *pSrc++;
 80278ee:	ed54 7a05 	vldr	s15, [r4, #-20]	; 0xffffffec
    realIn = *pSrc++;
    imagIn = *pSrc++;
    /* store the result in the destination buffer. */
    arm_sqrt_f32((realIn * realIn) + (imagIn * imagIn), pDst++);

    realIn = *pSrc++;
 80278f2:	ed14 7a06 	vldr	s14, [r4, #-24]	; 0xffffffe8
    imagIn = *pSrc++;
    arm_sqrt_f32((realIn * realIn) + (imagIn * imagIn), pDst++);
 80278f6:	ee67 7aa7 	vmul.f32	s15, s15, s15
 80278fa:	eee7 7a07 	vfma.f32	s15, s14, s14
   */
  CMSIS_INLINE __STATIC_INLINE arm_status arm_sqrt_f32(
  float32_t in,
  float32_t * pOut)
  {
    if (in >= 0.0f)
 80278fe:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8027902:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8027906:	f2c0 8087 	blt.w	8027a18 <arm_cmplx_mag_f32+0x15c>
#if   (__FPU_USED == 1) && defined ( __CC_ARM   )
      *pOut = __sqrtf(in);
#elif (__FPU_USED == 1) && (defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050))
      *pOut = __builtin_sqrtf(in);
#elif (__FPU_USED == 1) && defined(__GNUC__)
      *pOut = __builtin_sqrtf(in);
 802790a:	eeb1 7ae7 	vsqrt.f32	s14, s15
 802790e:	eeb4 7a47 	vcmp.f32	s14, s14
 8027912:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8027916:	f040 80ac 	bne.w	8027a72 <arm_cmplx_mag_f32+0x1b6>
 802791a:	ed05 7a03 	vstr	s14, [r5, #-12]

    realIn = *pSrc++;
    imagIn = *pSrc++;
 802791e:	ed54 7a03 	vldr	s15, [r4, #-12]

    realIn = *pSrc++;
    imagIn = *pSrc++;
    arm_sqrt_f32((realIn * realIn) + (imagIn * imagIn), pDst++);

    realIn = *pSrc++;
 8027922:	ed14 7a04 	vldr	s14, [r4, #-16]
    imagIn = *pSrc++;
    arm_sqrt_f32((realIn * realIn) + (imagIn * imagIn), pDst++);
 8027926:	ee67 7aa7 	vmul.f32	s15, s15, s15
 802792a:	eee7 7a07 	vfma.f32	s15, s14, s14
   */
  CMSIS_INLINE __STATIC_INLINE arm_status arm_sqrt_f32(
  float32_t in,
  float32_t * pOut)
  {
    if (in >= 0.0f)
 802792e:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8027932:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8027936:	db6c      	blt.n	8027a12 <arm_cmplx_mag_f32+0x156>
#if   (__FPU_USED == 1) && defined ( __CC_ARM   )
      *pOut = __sqrtf(in);
#elif (__FPU_USED == 1) && (defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050))
      *pOut = __builtin_sqrtf(in);
#elif (__FPU_USED == 1) && defined(__GNUC__)
      *pOut = __builtin_sqrtf(in);
 8027938:	eeb1 7ae7 	vsqrt.f32	s14, s15
 802793c:	eeb4 7a47 	vcmp.f32	s14, s14
 8027940:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8027944:	f040 808a 	bne.w	8027a5c <arm_cmplx_mag_f32+0x1a0>
 8027948:	ed05 7a02 	vstr	s14, [r5, #-8]

    realIn = *pSrc++;
    imagIn = *pSrc++;
 802794c:	ed54 7a01 	vldr	s15, [r4, #-4]

    realIn = *pSrc++;
    imagIn = *pSrc++;
    arm_sqrt_f32((realIn * realIn) + (imagIn * imagIn), pDst++);

    realIn = *pSrc++;
 8027950:	ed14 7a02 	vldr	s14, [r4, #-8]
    imagIn = *pSrc++;
    arm_sqrt_f32((realIn * realIn) + (imagIn * imagIn), pDst++);
 8027954:	ee67 7aa7 	vmul.f32	s15, s15, s15
 8027958:	eee7 7a07 	vfma.f32	s15, s14, s14
   */
  CMSIS_INLINE __STATIC_INLINE arm_status arm_sqrt_f32(
  float32_t in,
  float32_t * pOut)
  {
    if (in >= 0.0f)
 802795c:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8027960:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8027964:	db1e      	blt.n	80279a4 <arm_cmplx_mag_f32+0xe8>
#if   (__FPU_USED == 1) && defined ( __CC_ARM   )
      *pOut = __sqrtf(in);
#elif (__FPU_USED == 1) && (defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050))
      *pOut = __builtin_sqrtf(in);
#elif (__FPU_USED == 1) && defined(__GNUC__)
      *pOut = __builtin_sqrtf(in);
 8027966:	eeb1 7ae7 	vsqrt.f32	s14, s15
 802796a:	eeb4 7a47 	vcmp.f32	s14, s14
 802796e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8027972:	d168      	bne.n	8027a46 <arm_cmplx_mag_f32+0x18a>
  /*loop Unrolling */
  blkCnt = numSamples >> 2u;

  /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.
   ** a second loop below computes the remaining 1 to 3 samples. */
  while (blkCnt > 0u)
 8027974:	3f01      	subs	r7, #1
 8027976:	ed05 7a01 	vstr	s14, [r5, #-4]
 802797a:	f104 0420 	add.w	r4, r4, #32
 802797e:	f105 0510 	add.w	r5, r5, #16
 8027982:	d017      	beq.n	80279b4 <arm_cmplx_mag_f32+0xf8>
  {

    /* C[0] = sqrt(A[0] * A[0] + A[1] * A[1]) */
    realIn = *pSrc++;
    imagIn = *pSrc++;
 8027984:	ed54 7a07 	vldr	s15, [r4, #-28]	; 0xffffffe4
   ** a second loop below computes the remaining 1 to 3 samples. */
  while (blkCnt > 0u)
  {

    /* C[0] = sqrt(A[0] * A[0] + A[1] * A[1]) */
    realIn = *pSrc++;
 8027988:	ed14 7a08 	vldr	s14, [r4, #-32]	; 0xffffffe0
    imagIn = *pSrc++;
    /* store the result in the destination buffer. */
    arm_sqrt_f32((realIn * realIn) + (imagIn * imagIn), pDst++);
 802798c:	ee67 7aa7 	vmul.f32	s15, s15, s15
 8027990:	eee7 7a07 	vfma.f32	s15, s14, s14
   */
  CMSIS_INLINE __STATIC_INLINE arm_status arm_sqrt_f32(
  float32_t in,
  float32_t * pOut)
  {
    if (in >= 0.0f)
 8027994:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8027998:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802799c:	da9d      	bge.n	80278da <arm_cmplx_mag_f32+0x1e>

      return (ARM_MATH_SUCCESS);
    }
    else
    {
      *pOut = 0.0f;
 802799e:	f845 8c10 	str.w	r8, [r5, #-16]
 80279a2:	e7a4      	b.n	80278ee <arm_cmplx_mag_f32+0x32>
  /*loop Unrolling */
  blkCnt = numSamples >> 2u;

  /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.
   ** a second loop below computes the remaining 1 to 3 samples. */
  while (blkCnt > 0u)
 80279a4:	3f01      	subs	r7, #1
 80279a6:	f845 8c04 	str.w	r8, [r5, #-4]
 80279aa:	f104 0420 	add.w	r4, r4, #32
 80279ae:	f105 0510 	add.w	r5, r5, #16
 80279b2:	d1e7      	bne.n	8027984 <arm_cmplx_mag_f32+0xc8>
 80279b4:	eb06 1649 	add.w	r6, r6, r9, lsl #5
 80279b8:	eb01 1109 	add.w	r1, r1, r9, lsl #4

  /* If the numSamples is not a multiple of 4, compute any remaining output samples here.
   ** No loop unrolling is used. */
  blkCnt = numSamples % 0x4u;

  while (blkCnt > 0u)
 80279bc:	f012 0503 	ands.w	r5, r2, #3
 80279c0:	d024      	beq.n	8027a0c <arm_cmplx_mag_f32+0x150>
   */
  CMSIS_INLINE __STATIC_INLINE arm_status arm_sqrt_f32(
  float32_t in,
  float32_t * pOut)
  {
    if (in >= 0.0f)
 80279c2:	2700      	movs	r7, #0
 80279c4:	f106 0408 	add.w	r4, r6, #8
 80279c8:	e00c      	b.n	80279e4 <arm_cmplx_mag_f32+0x128>
#if   (__FPU_USED == 1) && defined ( __CC_ARM   )
      *pOut = __sqrtf(in);
#elif (__FPU_USED == 1) && (defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050))
      *pOut = __builtin_sqrtf(in);
#elif (__FPU_USED == 1) && defined(__GNUC__)
      *pOut = __builtin_sqrtf(in);
 80279ca:	eeb1 7ae7 	vsqrt.f32	s14, s15
 80279ce:	eeb4 7a47 	vcmp.f32	s14, s14
 80279d2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80279d6:	d12d      	bne.n	8027a34 <arm_cmplx_mag_f32+0x178>
 80279d8:	3d01      	subs	r5, #1
 80279da:	ed01 7a01 	vstr	s14, [r1, #-4]
 80279de:	f104 0408 	add.w	r4, r4, #8
 80279e2:	d013      	beq.n	8027a0c <arm_cmplx_mag_f32+0x150>
  {
    /* C[0] = sqrt(A[0] * A[0] + A[1] * A[1]) */
    realIn = *pSrc++;
    imagIn = *pSrc++;
 80279e4:	ed54 7a01 	vldr	s15, [r4, #-4]
  blkCnt = numSamples % 0x4u;

  while (blkCnt > 0u)
  {
    /* C[0] = sqrt(A[0] * A[0] + A[1] * A[1]) */
    realIn = *pSrc++;
 80279e8:	ed14 7a02 	vldr	s14, [r4, #-8]
    imagIn = *pSrc++;
    /* store the result in the destination buffer. */
    arm_sqrt_f32((realIn * realIn) + (imagIn * imagIn), pDst++);
 80279ec:	ee67 7aa7 	vmul.f32	s15, s15, s15
 80279f0:	3104      	adds	r1, #4
 80279f2:	eee7 7a07 	vfma.f32	s15, s14, s14
   */
  CMSIS_INLINE __STATIC_INLINE arm_status arm_sqrt_f32(
  float32_t in,
  float32_t * pOut)
  {
    if (in >= 0.0f)
 80279f6:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 80279fa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80279fe:	dae4      	bge.n	80279ca <arm_cmplx_mag_f32+0x10e>

  /* If the numSamples is not a multiple of 4, compute any remaining output samples here.
   ** No loop unrolling is used. */
  blkCnt = numSamples % 0x4u;

  while (blkCnt > 0u)
 8027a00:	3d01      	subs	r5, #1

      return (ARM_MATH_SUCCESS);
    }
    else
    {
      *pOut = 0.0f;
 8027a02:	f841 7c04 	str.w	r7, [r1, #-4]
 8027a06:	f104 0408 	add.w	r4, r4, #8
 8027a0a:	d1eb      	bne.n	80279e4 <arm_cmplx_mag_f32+0x128>
    numSamples--;
  }

#endif /* #if defined (ARM_MATH_DSP) */

}
 8027a0c:	b003      	add	sp, #12
 8027a0e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8027a12:	f845 8c08 	str.w	r8, [r5, #-8]
 8027a16:	e799      	b.n	802794c <arm_cmplx_mag_f32+0x90>
 8027a18:	f845 8c0c 	str.w	r8, [r5, #-12]
 8027a1c:	e77f      	b.n	802791e <arm_cmplx_mag_f32+0x62>
#if   (__FPU_USED == 1) && defined ( __CC_ARM   )
      *pOut = __sqrtf(in);
#elif (__FPU_USED == 1) && (defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050))
      *pOut = __builtin_sqrtf(in);
#elif (__FPU_USED == 1) && defined(__GNUC__)
      *pOut = __builtin_sqrtf(in);
 8027a1e:	ee17 0a90 	vmov	r0, s15
 8027a22:	e88d 0006 	stmia.w	sp, {r1, r2}
 8027a26:	f003 fa87 	bl	802af38 <sqrtf>
 8027a2a:	e89d 0006 	ldmia.w	sp, {r1, r2}
 8027a2e:	ee07 0a10 	vmov	s14, r0
 8027a32:	e75a      	b.n	80278ea <arm_cmplx_mag_f32+0x2e>
 8027a34:	ee17 0a90 	vmov	r0, s15
 8027a38:	9100      	str	r1, [sp, #0]
 8027a3a:	f003 fa7d 	bl	802af38 <sqrtf>
 8027a3e:	9900      	ldr	r1, [sp, #0]
 8027a40:	ee07 0a10 	vmov	s14, r0
 8027a44:	e7c8      	b.n	80279d8 <arm_cmplx_mag_f32+0x11c>
 8027a46:	ee17 0a90 	vmov	r0, s15
 8027a4a:	e88d 0006 	stmia.w	sp, {r1, r2}
 8027a4e:	f003 fa73 	bl	802af38 <sqrtf>
 8027a52:	e89d 0006 	ldmia.w	sp, {r1, r2}
 8027a56:	ee07 0a10 	vmov	s14, r0
 8027a5a:	e78b      	b.n	8027974 <arm_cmplx_mag_f32+0xb8>
 8027a5c:	ee17 0a90 	vmov	r0, s15
 8027a60:	e88d 0006 	stmia.w	sp, {r1, r2}
 8027a64:	f003 fa68 	bl	802af38 <sqrtf>
 8027a68:	e89d 0006 	ldmia.w	sp, {r1, r2}
 8027a6c:	ee07 0a10 	vmov	s14, r0
 8027a70:	e76a      	b.n	8027948 <arm_cmplx_mag_f32+0x8c>
 8027a72:	ee17 0a90 	vmov	r0, s15
 8027a76:	e88d 0006 	stmia.w	sp, {r1, r2}
 8027a7a:	f003 fa5d 	bl	802af38 <sqrtf>
 8027a7e:	e89d 0006 	ldmia.w	sp, {r1, r2}
 8027a82:	ee07 0a10 	vmov	s14, r0
 8027a86:	e748      	b.n	802791a <arm_cmplx_mag_f32+0x5e>

08027a88 <CLOCK_XMC4_Init>:
{
  CLOCK_XMC4_STATUS_t status = CLOCK_XMC4_STATUS_SUCCESS;

  XMC_ASSERT("CLOCK_XMC4 APP handle function pointer uninitialized", (handle != NULL));

  handle->init_status = true;
 8027a88:	2301      	movs	r3, #1
 8027a8a:	7003      	strb	r3, [r0, #0]

  return (status);
}
 8027a8c:	2000      	movs	r0, #0
 8027a8e:	4770      	bx	lr

08027a90 <OSCHP_GetFrequency>:
#ifdef CLOCK_XMC4_OSCHP_ENABLED
/*  API to retrieve high precision external oscillator frequency */
uint32_t OSCHP_GetFrequency(void)
{
  return (CLOCK_XMC4_OSCHP_FREQUENCY);
}
 8027a90:	4800      	ldr	r0, [pc, #0]	; (8027a94 <OSCHP_GetFrequency+0x4>)
 8027a92:	4770      	bx	lr
 8027a94:	00b71b00 	.word	0x00b71b00

08027a98 <SystemCoreClockSetup>:
* @note   -
* @param  None
* @retval None
*/
void SystemCoreClockSetup(void)
{
 8027a98:	b530      	push	{r4, r5, lr}
  /* Local data structure for initializing the clock functional block */
  const XMC_SCU_CLOCK_CONFIG_t CLOCK_XMC4_0_CONFIG =
 8027a9a:	4d11      	ldr	r5, [pc, #68]	; (8027ae0 <SystemCoreClockSetup+0x48>)
 8027a9c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
* @note   -
* @param  None
* @retval None
*/
void SystemCoreClockSetup(void)
{
 8027a9e:	b087      	sub	sp, #28
  /* Local data structure for initializing the clock functional block */
  const XMC_SCU_CLOCK_CONFIG_t CLOCK_XMC4_0_CONFIG =
 8027aa0:	ac01      	add	r4, sp, #4
 8027aa2:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8027aa4:	682b      	ldr	r3, [r5, #0]
 8027aa6:	6023      	str	r3, [r4, #0]
#endif
    /* Peripheral Clock Divider Value */
    .fperipheral_clkdiv = 1U
  };
  /* Initialize the SCU clock */
  XMC_SCU_CLOCK_Init(&CLOCK_XMC4_0_CONFIG);
 8027aa8:	a801      	add	r0, sp, #4
 8027aaa:	f7f9 fc57 	bl	802135c <XMC_SCU_CLOCK_Init>
  /* RTC source clock */
  XMC_SCU_HIB_SetRtcClockSource(XMC_SCU_HIB_RTCCLKSRC_OSI);
 8027aae:	2000      	movs	r0, #0
 8027ab0:	f7f9 faec 	bl	802108c <XMC_SCU_HIB_SetRtcClockSource>
  
#ifdef CLOCK_XMC4_USBCLK_ENABLED  
  /* USB/SDMMC source clock */
  XMC_SCU_CLOCK_SetUsbClockSource(XMC_SCU_CLOCK_USBCLKSRC_USBPLL);
 8027ab4:	2000      	movs	r0, #0
 8027ab6:	f7f9 fad5 	bl	8021064 <XMC_SCU_CLOCK_SetUsbClockSource>
  /* USB/SDMMC divider setting */
  XMC_SCU_CLOCK_SetUsbClockDivider(4U);
 8027aba:	2004      	movs	r0, #4
 8027abc:	f7f9 faf6 	bl	80210ac <XMC_SCU_CLOCK_SetUsbClockDivider>
#endif
  /* Start USB PLL */
  XMC_SCU_CLOCK_StartUsbPll(1U, 32U);
 8027ac0:	2120      	movs	r1, #32
 8027ac2:	2001      	movs	r0, #1
 8027ac4:	f7f9 fb3e 	bl	8021144 <XMC_SCU_CLOCK_StartUsbPll>

#ifdef CLOCK_XMC4_WDTCLK_ENABLED    
  /* WDT source clock */
  XMC_SCU_CLOCK_SetWdtClockSource(XMC_SCU_CLOCK_WDTCLKSRC_PLL);
 8027ac8:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 8027acc:	f7f9 fad4 	bl	8021078 <XMC_SCU_CLOCK_SetWdtClockSource>
  /* WDT divider setting */
  XMC_SCU_CLOCK_SetWdtClockDivider(1U);
 8027ad0:	2001      	movs	r0, #1
 8027ad2:	f7f9 faff 	bl	80210d4 <XMC_SCU_CLOCK_SetWdtClockDivider>
#endif

#ifdef CLOCK_XMC4_EBUCLK_ENABLED 
  /* EBU divider setting */
  XMC_SCU_CLOCK_SetEbuClockDivider(1U);
 8027ad6:	2001      	movs	r0, #1
 8027ad8:	f7f9 faf2 	bl	80210c0 <XMC_SCU_CLOCK_SetEbuClockDivider>
#endif

}
 8027adc:	b007      	add	sp, #28
 8027ade:	bd30      	pop	{r4, r5, pc}
 8027ae0:	0802fc38 	.word	0x0802fc38

08027ae4 <ADC_MEASUREMENT_ADV_Init>:
#ifdef ADC_MEASUREMENT_ADV_SHS_GAIN_NON_DEFAULT
  uint8_t channel_number;
#endif
  bool arbitration_status = (bool)false;

  if (ADC_MEASUREMENT_ADV_STATUS_UNINITIALIZED == *handle_ptr->init_state)
 8027ae4:	6903      	ldr	r3, [r0, #16]
 8027ae6:	781b      	ldrb	r3, [r3, #0]
 8027ae8:	2b02      	cmp	r3, #2
 8027aea:	d001      	beq.n	8027af0 <ADC_MEASUREMENT_ADV_Init+0xc>
#endif

    *handle_ptr->init_state = status;
  }
  return (*handle_ptr->init_state);
}
 8027aec:	4618      	mov	r0, r3
 8027aee:	4770      	bx	lr
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Initialization routine to call ADC LLD API's */
ADC_MEASUREMENT_ADV_STATUS_t ADC_MEASUREMENT_ADV_Init(const ADC_MEASUREMENT_ADV_t *const handle_ptr)
{
 8027af0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8027af4:	4605      	mov	r5, r0
  /* To check if the arbiter is already enabled. Before checking this ensure that clock and reset states are correct */
#if defined(CLOCK_GATING_SUPPORTED) && defined(ADC_MEASUREMENT_ADV_CHECK_CLOCK_GATING)
  clock_reset_check = !XMC_SCU_CLOCK_IsPeripheralClockGated(XMC_SCU_PERIPHERAL_CLOCK_VADC);
#endif
#ifdef PERIPHERAL_RESET_SUPPORTED
  clock_reset_check |= !XMC_SCU_RESET_IsPeripheralResetAsserted(XMC_SCU_PERIPHERAL_RESET_VADC);
 8027af6:	2001      	movs	r0, #1
 8027af8:	f7f9 fa98 	bl	802102c <XMC_SCU_RESET_IsPeripheralResetAsserted>
#endif
  if(clock_reset_check != (bool)false)
 8027afc:	2800      	cmp	r0, #0
 8027afe:	f040 80c8 	bne.w	8027c92 <ADC_MEASUREMENT_ADV_Init+0x1ae>
  {
#ifdef ADC_MEASUREMENT_ADV_SCAN_USED
  #ifdef ADC_MEASUREMENT_ADV_QUEUE_USED
    if ( ADC_MEASUREMENT_ADV_REQUEST_SOURCE_LOCAL_SCAN >= handle_ptr->req_src)
 8027b02:	7d2b      	ldrb	r3, [r5, #20]
  #endif
      {
        arbitration_status = XMC_VADC_GROUP_ScanIsArbitrationSlotEnabled(group_ptrs[handle_ptr->group_index]);
 8027b04:	4e94      	ldr	r6, [pc, #592]	; (8027d58 <ADC_MEASUREMENT_ADV_Init+0x274>)
#endif
  if(clock_reset_check != (bool)false)
  {
#ifdef ADC_MEASUREMENT_ADV_SCAN_USED
  #ifdef ADC_MEASUREMENT_ADV_QUEUE_USED
    if ( ADC_MEASUREMENT_ADV_REQUEST_SOURCE_LOCAL_SCAN >= handle_ptr->req_src)
 8027b06:	2b01      	cmp	r3, #1
  #endif
      {
        arbitration_status = XMC_VADC_GROUP_ScanIsArbitrationSlotEnabled(group_ptrs[handle_ptr->group_index]);
 8027b08:	7dab      	ldrb	r3, [r5, #22]
 8027b0a:	f856 4023 	ldr.w	r4, [r6, r3, lsl #2]
 */
__STATIC_INLINE bool XMC_VADC_GROUP_ScanIsArbitrationSlotEnabled(XMC_VADC_GROUP_t *const group_ptr)
{
  XMC_ASSERT("XMC_VADC_GROUP_ScanIsArbitrationSlotEnabled:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))

  return ((group_ptr->ARBPR & (uint32_t)VADC_G_ARBPR_ASEN1_Msk) >> VADC_G_ARBPR_ASEN1_Pos);
 8027b0e:	f8d4 3084 	ldr.w	r3, [r4, #132]	; 0x84
#endif
  if(clock_reset_check != (bool)false)
  {
#ifdef ADC_MEASUREMENT_ADV_SCAN_USED
  #ifdef ADC_MEASUREMENT_ADV_QUEUE_USED
    if ( ADC_MEASUREMENT_ADV_REQUEST_SOURCE_LOCAL_SCAN >= handle_ptr->req_src)
 8027b12:	f240 81fb 	bls.w	8027f0c <ADC_MEASUREMENT_ADV_Init+0x428>
 */
__STATIC_INLINE bool XMC_VADC_GROUP_QueueIsArbitrationSlotEnabled(XMC_VADC_GROUP_t *const group_ptr)
{
  XMC_ASSERT("XMC_VADC_GROUP_QueueIsArbitrationSlotEnabled:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))

  return ((group_ptr->ARBPR & (uint32_t)VADC_G_ARBPR_ASEN0_Msk) >> VADC_G_ARBPR_ASEN0_Pos);
 8027b16:	f3c3 6900 	ubfx	r9, r3, #24, #1
                                                           uint8_t group_index)
{
  ADC_MEASUREMENT_ADV_STATUS_t status;

  /*Initialization of APP 'GLOBAL_ADC'*/
  status = (ADC_MEASUREMENT_ADV_STATUS_t) GLOBAL_ADC_Init(ADC_MEASUREMENT_ADV_GLOBAL_HANDLE);
 8027b1a:	4890      	ldr	r0, [pc, #576]	; (8027d5c <ADC_MEASUREMENT_ADV_Init+0x278>)
#ifdef ADC_MEASUREMENT_ADV_LOCAL_QUEUE_USED
  #ifdef ADC_MEASUREMENT_ADV_ADC_QUEUE_USED
      if ( ADC_MEASUREMENT_ADV_REQUEST_SOURCE_QUEUE != handle_ptr->req_src)
  #endif
      {
        status = ADC_MEASUREMENT_ADV_lQueueInit(handle_ptr->local_queue_handle,handle_ptr->group_index);
 8027b1c:	68ef      	ldr	r7, [r5, #12]
                                                           uint8_t group_index)
{
  ADC_MEASUREMENT_ADV_STATUS_t status;

  /*Initialization of APP 'GLOBAL_ADC'*/
  status = (ADC_MEASUREMENT_ADV_STATUS_t) GLOBAL_ADC_Init(ADC_MEASUREMENT_ADV_GLOBAL_HANDLE);
 8027b1e:	f7fe fdb7 	bl	8026690 <GLOBAL_ADC_Init>

  /*Class Configuration*/
  XMC_VADC_GROUP_InputClassInit(group_ptrs[group_index],handle_ptr->iclass_config_handle,
 8027b22:	7ebb      	ldrb	r3, [r7, #26]
 8027b24:	6939      	ldr	r1, [r7, #16]
 8027b26:	2200      	movs	r2, #0
                                                           uint8_t group_index)
{
  ADC_MEASUREMENT_ADV_STATUS_t status;

  /*Initialization of APP 'GLOBAL_ADC'*/
  status = (ADC_MEASUREMENT_ADV_STATUS_t) GLOBAL_ADC_Init(ADC_MEASUREMENT_ADV_GLOBAL_HANDLE);
 8027b28:	4680      	mov	r8, r0

  /*Class Configuration*/
  XMC_VADC_GROUP_InputClassInit(group_ptrs[group_index],handle_ptr->iclass_config_handle,
 8027b2a:	4620      	mov	r0, r4
 8027b2c:	f7fb fd2a 	bl	8023584 <XMC_VADC_GROUP_InputClassInit>
                                XMC_VADC_GROUP_CONV_STD,handle_ptr->iclass_num);

  /* Initialize the Queue hardware */
  XMC_VADC_GROUP_QueueInit(group_ptrs[group_index],handle_ptr->queue_config_handle);
 8027b30:	4620      	mov	r0, r4
 8027b32:	6979      	ldr	r1, [r7, #20]
 8027b34:	f7fb fde2 	bl	80236fc <XMC_VADC_GROUP_QueueInit>
{
  XMC_ASSERT("XMC_VADC_GROUP_QueueSetGatingMode:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  XMC_ASSERT("XMC_VADC_GROUP_QueueSetGatingMode:Wrong mode selected", (mode_sel <= XMC_VADC_GATEMODE_ACTIVELOW))

  /* Clear the existing gate configuration */
  group_ptr->QMR0 &= (uint32_t)(~((uint32_t) VADC_G_QMR0_ENGT_Msk));
 8027b38:	f8d4 2104 	ldr.w	r2, [r4, #260]	; 0x104

  /* Configure the gating mode for queue*/
  XMC_VADC_GROUP_QueueSetGatingMode(group_ptrs[group_index], handle_ptr->gating_mode);
 8027b3c:	7e38      	ldrb	r0, [r7, #24]

  /*Interrupt Configuration*/
  if ((bool)true == handle_ptr->rs_intr_handle.interrupt_enable)
 8027b3e:	7b39      	ldrb	r1, [r7, #12]
 8027b40:	f022 0203 	bic.w	r2, r2, #3
 8027b44:	f8c4 2104 	str.w	r2, [r4, #260]	; 0x104
  /* Set the new gating mode */
  group_ptr->QMR0 |= (uint32_t)((uint32_t)mode_sel << VADC_G_QMR0_ENGT_Pos);
 8027b48:	f8d4 3104 	ldr.w	r3, [r4, #260]	; 0x104
 8027b4c:	4303      	orrs	r3, r0
 8027b4e:	f8c4 3104 	str.w	r3, [r4, #260]	; 0x104
 8027b52:	b389      	cbz	r1, 8027bb8 <ADC_MEASUREMENT_ADV_Init+0xd4>
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8027b54:	4b82      	ldr	r3, [pc, #520]	; (8027d60 <ADC_MEASUREMENT_ADV_Init+0x27c>)
  {
#if (UC_FAMILY == XMC1)
    NVIC_SetPriority((IRQn_Type)handle_ptr->rs_intr_handle.node_id, handle_ptr->rs_intr_handle.priority);
#else
    NVIC_SetPriority((IRQn_Type)handle_ptr->rs_intr_handle.node_id,
 8027b56:	f8d7 e000 	ldr.w	lr, [r7]
 8027b5a:	68db      	ldr	r3, [r3, #12]
 8027b5c:	6878      	ldr	r0, [r7, #4]
 8027b5e:	f8d7 c008 	ldr.w	ip, [r7, #8]
 8027b62:	f3c3 2302 	ubfx	r3, r3, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8027b66:	f1c3 0a07 	rsb	sl, r3, #7
 8027b6a:	f1ba 0f06 	cmp.w	sl, #6
 8027b6e:	bf28      	it	cs
 8027b70:	f04f 0a06 	movcs.w	sl, #6
 8027b74:	fa5f f18e 	uxtb.w	r1, lr
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8027b78:	2b00      	cmp	r3, #0
 8027b7a:	f040 818d 	bne.w	8027e98 <ADC_MEASUREMENT_ADV_Init+0x3b4>
 8027b7e:	461a      	mov	r2, r3

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8027b80:	f04f 0c01 	mov.w	ip, #1
 8027b84:	fa0c fc0a 	lsl.w	ip, ip, sl
 8027b88:	f10c 3cff 	add.w	ip, ip, #4294967295
 8027b8c:	ea0c 0000 	and.w	r0, ip, r0
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
 8027b90:	b249      	sxtb	r1, r1

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8027b92:	fa00 f202 	lsl.w	r2, r0, r2
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
 8027b96:	2900      	cmp	r1, #0
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
 8027b98:	ea43 0302 	orr.w	r3, r3, r2
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
 8027b9c:	f2c0 81ae 	blt.w	8027efc <ADC_MEASUREMENT_ADV_Init+0x418>
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8027ba0:	f101 4260 	add.w	r2, r1, #3758096384	; 0xe0000000
 8027ba4:	f502 4261 	add.w	r2, r2, #57600	; 0xe100
 8027ba8:	009b      	lsls	r3, r3, #2
 8027baa:	b2db      	uxtb	r3, r3
 8027bac:	f882 3300 	strb.w	r3, [r2, #768]	; 0x300
    XMC_SCU_SetInterruptControl(handle_ptr->rs_intr_handle.node_id,
                                ((handle_ptr->rs_intr_handle.node_id << 8) | handle_ptr->rs_intr_handle.irqctrl));
#endif

    /* Connect RS Events to NVIC nodes */
    XMC_VADC_GROUP_QueueSetReqSrcEventInterruptNode(group_ptrs[group_index], (XMC_VADC_SR_t)handle_ptr->srv_req_node);
 8027bb0:	4620      	mov	r0, r4
 8027bb2:	7e79      	ldrb	r1, [r7, #25]
 8027bb4:	f7fb fde6 	bl	8023784 <XMC_VADC_GROUP_QueueSetReqSrcEventInterruptNode>

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
__STATIC_INLINE void ADC_MEASUREMENT_ADV_lDisableArbitration(const ADC_MEASUREMENT_ADV_t *const handle_ptr,
                                                             bool arbitration_status)
{
  if(arbitration_status == (bool)false)
 8027bb8:	f1b9 0f00 	cmp.w	r9, #0
 8027bbc:	d10d      	bne.n	8027bda <ADC_MEASUREMENT_ADV_Init+0xf6>
  {
#ifdef ADC_MEASUREMENT_ADV_SCAN_USED
  #ifdef ADC_MEASUREMENT_ADV_QUEUE_USED
      if ( ADC_MEASUREMENT_ADV_REQUEST_SOURCE_LOCAL_SCAN >= handle_ptr->req_src)
 8027bbe:	7d2b      	ldrb	r3, [r5, #20]
 8027bc0:	2b01      	cmp	r3, #1
  #endif
      {
        XMC_VADC_GROUP_ScanDisableArbitrationSlot(group_ptrs[handle_ptr->group_index]);
 8027bc2:	7dab      	ldrb	r3, [r5, #22]
 8027bc4:	f856 2023 	ldr.w	r2, [r6, r3, lsl #2]
 *  XMC_VADC_GROUP_ScanEnableArbitrationSlot()<BR>
 */
__STATIC_INLINE void XMC_VADC_GROUP_ScanDisableArbitrationSlot(XMC_VADC_GROUP_t *const group_ptr)
{
  XMC_ASSERT("XMC_VADC_GROUP_ScanDisableArbitrationSlot:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  group_ptr->ARBPR &= ~((uint32_t)VADC_G_ARBPR_ASEN1_Msk);
 8027bc8:	f8d2 3084 	ldr.w	r3, [r2, #132]	; 0x84
 8027bcc:	bf94      	ite	ls
 8027bce:	f023 7300 	bicls.w	r3, r3, #33554432	; 0x2000000
 *  XMC_VADC_GROUP_QueueEnableArbitrationSlot()<BR>
 */
__STATIC_INLINE void XMC_VADC_GROUP_QueueDisableArbitrationSlot(XMC_VADC_GROUP_t *const group_ptr)
{
  XMC_ASSERT("XMC_VADC_GROUP_QueueDisableArbitrationSlot:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr));
  group_ptr->ARBPR &= ~((uint32_t)VADC_G_ARBPR_ASEN0_Msk);
 8027bd2:	f023 7380 	bichi.w	r3, r3, #16777216	; 0x1000000
 8027bd6:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
   /* Disable the Arbitration if no other instance has enabled it*/
   ADC_MEASUREMENT_ADV_lDisableArbitration(handle_ptr,arbitration_status);

#ifdef ADC_MEASUREMENT_ADV_SYNC_USED
  #ifdef ADC_MEASUREMENT_ADV_SYNC_NOT_ALL_USED
    if ((uint32_t)0 != handle_ptr->sync_slaves)
 8027bda:	7d6b      	ldrb	r3, [r5, #21]
 8027bdc:	2b00      	cmp	r3, #0
 8027bde:	f040 80c1 	bne.w	8027d64 <ADC_MEASUREMENT_ADV_Init+0x280>
#endif

    /* Initialize the SR lines for the Channel event and the Result event, if required*/
#ifdef ADC_MEASUREMENT_ADV_MUX_USED
  #ifdef ADC_MEASUREMENT_ADV_MUX_NOT_ALL_USED
    if (handle_ptr->event_config != NULL)
 8027be2:	68ab      	ldr	r3, [r5, #8]
 8027be4:	b103      	cbz	r3, 8027be8 <ADC_MEASUREMENT_ADV_Init+0x104>
  #endif
    {
      (handle_ptr->event_config)();
 8027be6:	4798      	blx	r3
    }
#endif

    total_number_of_channels = (uint8_t)handle_ptr->total_number_of_channels;
 8027be8:	7e2b      	ldrb	r3, [r5, #24]
    for (ch_num = (uint8_t)0; ch_num < (uint8_t)total_number_of_channels; ch_num++)
 8027bea:	b1fb      	cbz	r3, 8027c2c <ADC_MEASUREMENT_ADV_Init+0x148>
 8027bec:	1e5f      	subs	r7, r3, #1
 8027bee:	b2ff      	uxtb	r7, r7
 8027bf0:	3701      	adds	r7, #1
 8027bf2:	00bf      	lsls	r7, r7, #2
 8027bf4:	f04f 0900 	mov.w	r9, #0
    {
      indexed = handle_ptr->channel_array[ch_num];
 8027bf8:	682b      	ldr	r3, [r5, #0]
 8027bfa:	f853 4009 	ldr.w	r4, [r3, r9]

      /* Initialize for configured channels*/
      XMC_VADC_GROUP_ChannelInit(group_ptrs[indexed->group_index],(uint32_t)indexed->ch_num, indexed->ch_handle);
 8027bfe:	7a23      	ldrb	r3, [r4, #8]
 8027c00:	7a61      	ldrb	r1, [r4, #9]
 8027c02:	f856 0023 	ldr.w	r0, [r6, r3, lsl #2]
 8027c06:	6822      	ldr	r2, [r4, #0]
 8027c08:	f7fb fdc4 	bl	8023794 <XMC_VADC_GROUP_ChannelInit>
      XMC_VADC_GROUP_ResultInit(group_ptrs[indexed->group_index], (uint32_t)indexed->result_fifo_tail_number,
                                indexed->res_handle[ADC_MEASUREMENT_ADV_TAIL_RESULT_REG_CONFIG]);
  }
#endif
      /* Initialize for configured result registers For FIFO Head configuration*/
      XMC_VADC_GROUP_ResultInit(group_ptrs[indexed->group_index], (uint32_t)indexed->ch_handle->result_reg_number,
 8027c0c:	6823      	ldr	r3, [r4, #0]
 8027c0e:	7a22      	ldrb	r2, [r4, #8]
 8027c10:	789b      	ldrb	r3, [r3, #2]
__STATIC_INLINE void XMC_VADC_GROUP_ResultInit(XMC_VADC_GROUP_t *const group_ptr,
                                               const uint32_t res_reg_num,
                                               const XMC_VADC_RESULT_CONFIG_t *config)
{
  XMC_ASSERT("XMC_VADC_GROUP_ResultInit:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  group_ptr->RCR[res_reg_num] = config->g_rcr;
 8027c12:	6861      	ldr	r1, [r4, #4]
 8027c14:	f856 2022 	ldr.w	r2, [r6, r2, lsl #2]
 8027c18:	6809      	ldr	r1, [r1, #0]
 8027c1a:	f003 030f 	and.w	r3, r3, #15
 8027c1e:	33a0      	adds	r3, #160	; 0xa0
 8027c20:	f109 0904 	add.w	r9, r9, #4
      (handle_ptr->event_config)();
    }
#endif

    total_number_of_channels = (uint8_t)handle_ptr->total_number_of_channels;
    for (ch_num = (uint8_t)0; ch_num < (uint8_t)total_number_of_channels; ch_num++)
 8027c24:	45b9      	cmp	r9, r7
 8027c26:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
 8027c2a:	d1e5      	bne.n	8027bf8 <ADC_MEASUREMENT_ADV_Init+0x114>
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Enables the NVIC(if needed) when scan/queue request source is consumed internally in the APP. */
void ADC_MEASUREMENT_ADC_lNvicEnable(const ADC_MEASUREMENT_ADV_t *const handle_ptr)
{
#ifdef ADC_MEASUREMENT_ADV_LOCAL_SCAN_USED
    if (((bool)true == handle_ptr->local_scan_handle->rs_intr_handle.interrupt_enable) &&
 8027c2c:	68ea      	ldr	r2, [r5, #12]
 8027c2e:	7b13      	ldrb	r3, [r2, #12]
 8027c30:	b36b      	cbz	r3, 8027c8e <ADC_MEASUREMENT_ADV_Init+0x1aa>
        (ADC_MEASUREMENT_ADV_REQUEST_SOURCE_LOCAL_SCAN == handle_ptr->req_src))
 8027c32:	7d2b      	ldrb	r3, [r5, #20]
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Enables the NVIC(if needed) when scan/queue request source is consumed internally in the APP. */
void ADC_MEASUREMENT_ADC_lNvicEnable(const ADC_MEASUREMENT_ADV_t *const handle_ptr)
{
#ifdef ADC_MEASUREMENT_ADV_LOCAL_SCAN_USED
    if (((bool)true == handle_ptr->local_scan_handle->rs_intr_handle.interrupt_enable) &&
 8027c34:	2b01      	cmp	r3, #1
 8027c36:	f000 8145 	beq.w	8027ec4 <ADC_MEASUREMENT_ADV_Init+0x3e0>
    {
      NVIC_EnableIRQ((IRQn_Type)handle_ptr->local_scan_handle->rs_intr_handle.node_id);
    }
#endif
#ifdef ADC_MEASUREMENT_ADV_LOCAL_QUEUE_USED
    if (((bool)true == handle_ptr->local_queue_handle->rs_intr_handle.interrupt_enable) &&
 8027c3a:	2b03      	cmp	r3, #3
 8027c3c:	f000 8133 	beq.w	8027ea6 <ADC_MEASUREMENT_ADV_Init+0x3c2>
{
  XMC_ASSERT("ADC_MEASUREMENT_ADV_InsertChannels:Invalid handle_ptr", (handle_ptr != NULL))

#ifdef ADC_MEASUREMENT_ADV_SCAN_USED
  #ifdef ADC_MEASUREMENT_ADV_QUEUE_USED
    if ( ADC_MEASUREMENT_ADV_REQUEST_SOURCE_LOCAL_SCAN >= handle_ptr->req_src)
 8027c40:	2b01      	cmp	r3, #1
 8027c42:	f240 814b 	bls.w	8027edc <ADC_MEASUREMENT_ADV_Init+0x3f8>
/* Local function to insert the queue entries into the hardware.*/
__STATIC_INLINE void ADC_MEASUREMENT_ADV_lQueueInsertEntries(const ADC_MEASUREMENT_ADV_t *const handle_ptr)
{
  uint32_t entry_index;

  XMC_VADC_GROUP_t *queue_group_ptr = group_ptrs[handle_ptr->group_index];
 8027c46:	7daa      	ldrb	r2, [r5, #22]
  const XMC_VADC_QUEUE_ENTRY_t **const entries_array = handle_ptr->local_queue_entries;

  for(entry_index = 0; entry_index < handle_ptr->total_number_of_entries; entry_index++)
 8027c48:	7deb      	ldrb	r3, [r5, #23]
/* Local function to insert the queue entries into the hardware.*/
__STATIC_INLINE void ADC_MEASUREMENT_ADV_lQueueInsertEntries(const ADC_MEASUREMENT_ADV_t *const handle_ptr)
{
  uint32_t entry_index;

  XMC_VADC_GROUP_t *queue_group_ptr = group_ptrs[handle_ptr->group_index];
 8027c4a:	f856 0022 	ldr.w	r0, [r6, r2, lsl #2]
  const XMC_VADC_QUEUE_ENTRY_t **const entries_array = handle_ptr->local_queue_entries;
 8027c4e:	686a      	ldr	r2, [r5, #4]

  for(entry_index = 0; entry_index < handle_ptr->total_number_of_entries; entry_index++)
 8027c50:	b18b      	cbz	r3, 8027c76 <ADC_MEASUREMENT_ADV_Init+0x192>
 8027c52:	3a04      	subs	r2, #4
 8027c54:	2300      	movs	r3, #0
 8027c56:	f852 1f04 	ldr.w	r1, [r2, #4]!
 8027c5a:	6809      	ldr	r1, [r1, #0]
__STATIC_INLINE void XMC_VADC_GROUP_QueueInsertChannel(XMC_VADC_GROUP_t *const group_ptr,
                                                       const XMC_VADC_QUEUE_ENTRY_t entry)
{
  XMC_ASSERT("XMC_VADC_GROUP_QueueInsertChannel:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  /* Insert the channel physically and get the length of the queue*/
  group_ptr->QINR0 = entry.qinr0;
 8027c5c:	f8c0 1110 	str.w	r1, [r0, #272]	; 0x110
 8027c60:	7de9      	ldrb	r1, [r5, #23]
 8027c62:	3301      	adds	r3, #1
 8027c64:	428b      	cmp	r3, r1
 8027c66:	d3f6      	bcc.n	8027c56 <ADC_MEASUREMENT_ADV_Init+0x172>
/* Enables the arbiter of the selected request source*/
void ADC_MEASUREMENT_ADV_StartADC(const ADC_MEASUREMENT_ADV_t *const handle_ptr)
{
#ifdef ADC_MEASUREMENT_ADV_SCAN_USED
  #ifdef ADC_MEASUREMENT_ADV_QUEUE_USED
    if ( ADC_MEASUREMENT_ADV_REQUEST_SOURCE_LOCAL_SCAN >= handle_ptr->req_src)
 8027c68:	7d2b      	ldrb	r3, [r5, #20]
 8027c6a:	2b01      	cmp	r3, #1
 8027c6c:	f240 813c 	bls.w	8027ee8 <ADC_MEASUREMENT_ADV_Init+0x404>
 8027c70:	7dab      	ldrb	r3, [r5, #22]
 8027c72:	f856 0023 	ldr.w	r0, [r6, r3, lsl #2]
 *  XMC_VADC_GROUP_QueueDisableArbitrationSlot()<BR>
 */
__STATIC_INLINE void XMC_VADC_GROUP_QueueEnableArbitrationSlot(XMC_VADC_GROUP_t *const group_ptr)
{
  XMC_ASSERT("XMC_VADC_GROUP_QueueEnableArbitrationSlot:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr));
  group_ptr->ARBPR |= (uint32_t)((uint32_t)1 << VADC_G_ARBPR_ASEN0_Pos);
 8027c76:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
 8027c7a:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8027c7e:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
    {
      ADC_MEASUREMENT_ADV_StartADC(handle_ptr);
    }
#endif

    *handle_ptr->init_state = status;
 8027c82:	692a      	ldr	r2, [r5, #16]
  }
  return (*handle_ptr->init_state);
}
 8027c84:	4640      	mov	r0, r8
    {
      ADC_MEASUREMENT_ADV_StartADC(handle_ptr);
    }
#endif

    *handle_ptr->init_state = status;
 8027c86:	f882 8000 	strb.w	r8, [r2]
  }
  return (*handle_ptr->init_state);
}
 8027c8a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8027c8e:	7d2b      	ldrb	r3, [r5, #20]
 8027c90:	e7d6      	b.n	8027c40 <ADC_MEASUREMENT_ADV_Init+0x15c>
{
  ADC_MEASUREMENT_ADV_STATUS_t status;

#ifdef ADC_MEASUREMENT_ADV_SCAN_USED
  #ifdef ADC_MEASUREMENT_ADV_QUEUE_USED
    if ( ADC_MEASUREMENT_ADV_REQUEST_SOURCE_LOCAL_SCAN >= handle_ptr->req_src)
 8027c92:	7d2b      	ldrb	r3, [r5, #20]
 8027c94:	4e30      	ldr	r6, [pc, #192]	; (8027d58 <ADC_MEASUREMENT_ADV_Init+0x274>)
 8027c96:	7daa      	ldrb	r2, [r5, #22]
 8027c98:	2b01      	cmp	r3, #1
 8027c9a:	f856 4022 	ldr.w	r4, [r6, r2, lsl #2]
  bool arbitration_status;

#if !defined(CLOCK_GATING_SUPPORTED) || !defined(ADC_MEASUREMENT_ADV_CHECK_CLOCK_GATING)
  clock_reset_check = (bool)false;
#endif
  arbitration_status = (bool)false;
 8027c9e:	f04f 0900 	mov.w	r9, #0
{
  ADC_MEASUREMENT_ADV_STATUS_t status;

#ifdef ADC_MEASUREMENT_ADV_SCAN_USED
  #ifdef ADC_MEASUREMENT_ADV_QUEUE_USED
    if ( ADC_MEASUREMENT_ADV_REQUEST_SOURCE_LOCAL_SCAN >= handle_ptr->req_src)
 8027ca2:	f63f af3a 	bhi.w	8027b1a <ADC_MEASUREMENT_ADV_Init+0x36>
                                                           uint8_t group_index)
{
  ADC_MEASUREMENT_ADV_STATUS_t status;

  /*Initialization of APP 'ADCGroup'*/
  status = (ADC_MEASUREMENT_ADV_STATUS_t) GLOBAL_ADC_Init(ADC_MEASUREMENT_ADV_GLOBAL_HANDLE);
 8027ca6:	482d      	ldr	r0, [pc, #180]	; (8027d5c <ADC_MEASUREMENT_ADV_Init+0x278>)
#ifdef ADC_MEASUREMENT_ADV_LOCAL_SCAN_USED
  #ifdef ADC_MEASUREMENT_ADV_ADC_SCAN_USED
      if ( ADC_MEASUREMENT_ADV_REQUEST_SOURCE_SCAN != handle_ptr->req_src)
  #endif
      {
        status = ADC_MEASUREMENT_ADV_lScanInit(handle_ptr->local_scan_handle,handle_ptr->group_index);
 8027ca8:	68ef      	ldr	r7, [r5, #12]
                                                           uint8_t group_index)
{
  ADC_MEASUREMENT_ADV_STATUS_t status;

  /*Initialization of APP 'ADCGroup'*/
  status = (ADC_MEASUREMENT_ADV_STATUS_t) GLOBAL_ADC_Init(ADC_MEASUREMENT_ADV_GLOBAL_HANDLE);
 8027caa:	f7fe fcf1 	bl	8026690 <GLOBAL_ADC_Init>

  XMC_VADC_GROUP_InputClassInit(group_ptrs[group_index], handle_ptr->iclass_config_handle,
 8027cae:	f897 3020 	ldrb.w	r3, [r7, #32]
 8027cb2:	6939      	ldr	r1, [r7, #16]
 8027cb4:	2200      	movs	r2, #0
                                                           uint8_t group_index)
{
  ADC_MEASUREMENT_ADV_STATUS_t status;

  /*Initialization of APP 'ADCGroup'*/
  status = (ADC_MEASUREMENT_ADV_STATUS_t) GLOBAL_ADC_Init(ADC_MEASUREMENT_ADV_GLOBAL_HANDLE);
 8027cb6:	4680      	mov	r8, r0

  XMC_VADC_GROUP_InputClassInit(group_ptrs[group_index], handle_ptr->iclass_config_handle,
 8027cb8:	4620      	mov	r0, r4
 8027cba:	f7fb fc63 	bl	8023584 <XMC_VADC_GROUP_InputClassInit>
                                XMC_VADC_GROUP_CONV_STD, (uint32_t)handle_ptr->iclass_num);


  /*Initialization of scan request source*/
  XMC_VADC_GROUP_ScanInit(group_ptrs[group_index], handle_ptr->scan_config_handle);
 8027cbe:	4620      	mov	r0, r4
 8027cc0:	6979      	ldr	r1, [r7, #20]
 8027cc2:	f7fb fccd 	bl	8023660 <XMC_VADC_GROUP_ScanInit>
{
  XMC_ASSERT("XMC_VADC_GROUP_ScanSetGatingMode:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  XMC_ASSERT("XMC_VADC_GROUP_ScanSetGatingMode:Wrong mode selected", (mode_sel <= XMC_VADC_GATEMODE_ACTIVELOW))

  /* Clear the existing gate configuration */
  group_ptr->ASMR &= (uint32_t) (~((uint32_t)VADC_G_ASMR_ENGT_Msk));
 8027cc6:	f8d4 2124 	ldr.w	r2, [r4, #292]	; 0x124

  /* Configure the gating mode for Scan*/
  XMC_VADC_GROUP_ScanSetGatingMode(group_ptrs[group_index], handle_ptr->gating_mode);
 8027cca:	7e38      	ldrb	r0, [r7, #24]

  /*Interrupt Configuration*/
  if ((bool)true == handle_ptr->rs_intr_handle.interrupt_enable)
 8027ccc:	7b39      	ldrb	r1, [r7, #12]
 8027cce:	f022 0203 	bic.w	r2, r2, #3
 8027cd2:	f8c4 2124 	str.w	r2, [r4, #292]	; 0x124
  /* Set the new gating mode */
  group_ptr->ASMR |= (uint32_t)((uint32_t)mode_sel << VADC_G_ASMR_ENGT_Pos);
 8027cd6:	f8d4 3124 	ldr.w	r3, [r4, #292]	; 0x124
 8027cda:	4303      	orrs	r3, r0
 8027cdc:	f8c4 3124 	str.w	r3, [r4, #292]	; 0x124
 8027ce0:	2900      	cmp	r1, #0
 8027ce2:	f43f af69 	beq.w	8027bb8 <ADC_MEASUREMENT_ADV_Init+0xd4>
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8027ce6:	4b1e      	ldr	r3, [pc, #120]	; (8027d60 <ADC_MEASUREMENT_ADV_Init+0x27c>)
  {
#if (UC_FAMILY == XMC1)
    NVIC_SetPriority((IRQn_Type)handle_ptr->rs_intr_handle.node_id, handle_ptr->rs_intr_handle.priority);
#else
    NVIC_SetPriority((IRQn_Type)handle_ptr->rs_intr_handle.node_id,
 8027ce8:	f8d7 e000 	ldr.w	lr, [r7]
 8027cec:	68db      	ldr	r3, [r3, #12]
 8027cee:	6878      	ldr	r0, [r7, #4]
 8027cf0:	f8d7 c008 	ldr.w	ip, [r7, #8]
 8027cf4:	f3c3 2302 	ubfx	r3, r3, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8027cf8:	f1c3 0a07 	rsb	sl, r3, #7
 8027cfc:	f1ba 0f06 	cmp.w	sl, #6
 8027d00:	bf28      	it	cs
 8027d02:	f04f 0a06 	movcs.w	sl, #6
 8027d06:	fa5f f18e 	uxtb.w	r1, lr
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8027d0a:	2b00      	cmp	r3, #0
 8027d0c:	f000 8101 	beq.w	8027f12 <ADC_MEASUREMENT_ADV_Init+0x42e>
 8027d10:	1e5a      	subs	r2, r3, #1
 8027d12:	2301      	movs	r3, #1
 8027d14:	4093      	lsls	r3, r2
 8027d16:	3b01      	subs	r3, #1
 8027d18:	ea03 030c 	and.w	r3, r3, ip

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8027d1c:	f04f 0c01 	mov.w	ip, #1
 8027d20:	fa0c fc0a 	lsl.w	ip, ip, sl
 8027d24:	f10c 3cff 	add.w	ip, ip, #4294967295
 8027d28:	ea0c 0000 	and.w	r0, ip, r0
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
 8027d2c:	b249      	sxtb	r1, r1

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8027d2e:	fa00 f202 	lsl.w	r2, r0, r2
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
 8027d32:	2900      	cmp	r1, #0
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
 8027d34:	ea43 0302 	orr.w	r3, r3, r2
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
 8027d38:	f2c0 811c 	blt.w	8027f74 <ADC_MEASUREMENT_ADV_Init+0x490>
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8027d3c:	f101 4260 	add.w	r2, r1, #3758096384	; 0xe0000000
 8027d40:	f502 4261 	add.w	r2, r2, #57600	; 0xe100
 8027d44:	009b      	lsls	r3, r3, #2
 8027d46:	b2db      	uxtb	r3, r3
 8027d48:	f882 3300 	strb.w	r3, [r2, #768]	; 0x300
    XMC_SCU_SetInterruptControl(handle_ptr->rs_intr_handle.node_id,
                                ((handle_ptr->rs_intr_handle.node_id << 8) | handle_ptr->rs_intr_handle.irqctrl));
#endif

    /* Connect RS Events to NVIC nodes */
    XMC_VADC_GROUP_ScanSetReqSrcEventInterruptNode(group_ptrs[group_index], handle_ptr->srv_req_node);
 8027d4c:	4620      	mov	r0, r4
 8027d4e:	7e79      	ldrb	r1, [r7, #25]
 8027d50:	f7fb fcca 	bl	80236e8 <XMC_VADC_GROUP_ScanSetReqSrcEventInterruptNode>
 8027d54:	e730      	b.n	8027bb8 <ADC_MEASUREMENT_ADV_Init+0xd4>
 8027d56:	bf00      	nop
 8027d58:	0802fc4c 	.word	0x0802fc4c
 8027d5c:	1ffe9364 	.word	0x1ffe9364
 8027d60:	e000ed00 	.word	0xe000ed00
__STATIC_INLINE void ADC_MEASUREMENT_ADV_lSyncInit(const ADC_MEASUREMENT_ADV_t *const handle_ptr)
{
  uint8_t sync_group;

  /* shift to get the 4 bit position needed to or it with the slave groups */
  sync_group = handle_ptr->sync_slaves | ( 1 << handle_ptr->group_index);
 8027d64:	7daa      	ldrb	r2, [r5, #22]
 8027d66:	2701      	movs	r7, #1
 8027d68:	4097      	lsls	r7, r2
 8027d6a:	433b      	orrs	r3, r7
  ADC_MEASUREMENT_ADV_lSyncSequencer(handle_ptr, sync_group, ADC_MEASUREMENT_ADV_SYNC_SEQ_POWER_DOWN);
 8027d6c:	b2df      	uxtb	r7, r3
 8027d6e:	2403      	movs	r4, #3
                                        ADC_MEASUREMENT_ADV_SYNC_SEQ_t sequence)
{
  int8_t group_index;
  for( group_index = XMC_VADC_MAXIMUM_NUM_GROUPS - (int32_t)1; group_index >= (int32_t)0  ; group_index--)
  {
    if ( (bool)false != (bool)((sync_group >> group_index) & 0x1 ))
 8027d70:	fa27 f304 	lsr.w	r3, r7, r4
 8027d74:	f013 0f01 	tst.w	r3, #1
    {
      switch( sequence)
      {
        case ADC_MEASUREMENT_ADV_SYNC_SEQ_POWER_DOWN:
             XMC_VADC_GROUP_SetPowerMode(group_ptrs[group_index],XMC_VADC_GROUP_POWERMODE_OFF);
 8027d78:	f04f 0100 	mov.w	r1, #0
                                        ADC_MEASUREMENT_ADV_SYNC_SEQ_t sequence)
{
  int8_t group_index;
  for( group_index = XMC_VADC_MAXIMUM_NUM_GROUPS - (int32_t)1; group_index >= (int32_t)0  ; group_index--)
  {
    if ( (bool)false != (bool)((sync_group >> group_index) & 0x1 ))
 8027d7c:	d003      	beq.n	8027d86 <ADC_MEASUREMENT_ADV_Init+0x2a2>
    {
      switch( sequence)
      {
        case ADC_MEASUREMENT_ADV_SYNC_SEQ_POWER_DOWN:
             XMC_VADC_GROUP_SetPowerMode(group_ptrs[group_index],XMC_VADC_GROUP_POWERMODE_OFF);
 8027d7e:	f856 0024 	ldr.w	r0, [r6, r4, lsl #2]
 8027d82:	f7fb fc25 	bl	80235d0 <XMC_VADC_GROUP_SetPowerMode>
void ADC_MEASUREMENT_ADV_lSyncSequencer(const ADC_MEASUREMENT_ADV_t *const handle_ptr,
                                        uint32_t sync_group,
                                        ADC_MEASUREMENT_ADV_SYNC_SEQ_t sequence)
{
  int8_t group_index;
  for( group_index = XMC_VADC_MAXIMUM_NUM_GROUPS - (int32_t)1; group_index >= (int32_t)0  ; group_index--)
 8027d86:	f114 34ff 	adds.w	r4, r4, #4294967295
 8027d8a:	d2f1      	bcs.n	8027d70 <ADC_MEASUREMENT_ADV_Init+0x28c>

  /* shift to get the 4 bit position needed to or it with the slave groups */
  sync_group = handle_ptr->sync_slaves | ( 1 << handle_ptr->group_index);
  ADC_MEASUREMENT_ADV_lSyncSequencer(handle_ptr, sync_group, ADC_MEASUREMENT_ADV_SYNC_SEQ_POWER_DOWN);

  sync_group = handle_ptr->sync_slaves;
 8027d8c:	7d6f      	ldrb	r7, [r5, #21]
  ADC_MEASUREMENT_ADV_lSyncSequencer(handle_ptr, sync_group, ADC_MEASUREMENT_ADV_SYNC_SEQ_STSEL_CONFIG);
 8027d8e:	2403      	movs	r4, #3
                                        ADC_MEASUREMENT_ADV_SYNC_SEQ_t sequence)
{
  int8_t group_index;
  for( group_index = XMC_VADC_MAXIMUM_NUM_GROUPS - (int32_t)1; group_index >= (int32_t)0  ; group_index--)
  {
    if ( (bool)false != (bool)((sync_group >> group_index) & 0x1 ))
 8027d90:	fa27 f304 	lsr.w	r3, r7, r4
 8027d94:	07d8      	lsls	r0, r3, #31
      {
        case ADC_MEASUREMENT_ADV_SYNC_SEQ_POWER_DOWN:
             XMC_VADC_GROUP_SetPowerMode(group_ptrs[group_index],XMC_VADC_GROUP_POWERMODE_OFF);
             break;
        case ADC_MEASUREMENT_ADV_SYNC_SEQ_STSEL_CONFIG:
             XMC_VADC_GROUP_SetSyncSlave(group_ptrs[group_index], handle_ptr->group_index, group_index);
 8027d96:	4622      	mov	r2, r4
                                        ADC_MEASUREMENT_ADV_SYNC_SEQ_t sequence)
{
  int8_t group_index;
  for( group_index = XMC_VADC_MAXIMUM_NUM_GROUPS - (int32_t)1; group_index >= (int32_t)0  ; group_index--)
  {
    if ( (bool)false != (bool)((sync_group >> group_index) & 0x1 ))
 8027d98:	d50a      	bpl.n	8027db0 <ADC_MEASUREMENT_ADV_Init+0x2cc>
      {
        case ADC_MEASUREMENT_ADV_SYNC_SEQ_POWER_DOWN:
             XMC_VADC_GROUP_SetPowerMode(group_ptrs[group_index],XMC_VADC_GROUP_POWERMODE_OFF);
             break;
        case ADC_MEASUREMENT_ADV_SYNC_SEQ_STSEL_CONFIG:
             XMC_VADC_GROUP_SetSyncSlave(group_ptrs[group_index], handle_ptr->group_index, group_index);
 8027d9a:	f856 0024 	ldr.w	r0, [r6, r4, lsl #2]
 8027d9e:	7da9      	ldrb	r1, [r5, #22]
 8027da0:	f7fb fc1e 	bl	80235e0 <XMC_VADC_GROUP_SetSyncSlave>
             XMC_VADC_GROUP_CheckSlaveReadiness(group_ptrs[handle_ptr->group_index],group_index);
 8027da4:	7dab      	ldrb	r3, [r5, #22]
 8027da6:	4621      	mov	r1, r4
 8027da8:	f856 0023 	ldr.w	r0, [r6, r3, lsl #2]
 8027dac:	f7fb fc2c 	bl	8023608 <XMC_VADC_GROUP_CheckSlaveReadiness>
void ADC_MEASUREMENT_ADV_lSyncSequencer(const ADC_MEASUREMENT_ADV_t *const handle_ptr,
                                        uint32_t sync_group,
                                        ADC_MEASUREMENT_ADV_SYNC_SEQ_t sequence)
{
  int8_t group_index;
  for( group_index = XMC_VADC_MAXIMUM_NUM_GROUPS - (int32_t)1; group_index >= (int32_t)0  ; group_index--)
 8027db0:	f114 34ff 	adds.w	r4, r4, #4294967295
 8027db4:	d2ec      	bcs.n	8027d90 <ADC_MEASUREMENT_ADV_Init+0x2ac>
  {
    if ( (bool)false != (bool)((sync_group >> group_index) & 0x1 ))
 8027db6:	0739      	lsls	r1, r7, #28
 8027db8:	d510      	bpl.n	8027ddc <ADC_MEASUREMENT_ADV_Init+0x2f8>
/* Helper function to configure the eval bits in the slave*/
void ADC_MEASUREMENT_ADV_lSyncEvalConfig(uint32_t master_group, uint32_t slave_selected,
                                         uint32_t sync_group)
{
  int8_t group_index;
  sync_group |= (1U << master_group);
 8027dba:	7dab      	ldrb	r3, [r5, #22]
 8027dbc:	2401      	movs	r4, #1
 8027dbe:	409c      	lsls	r4, r3
 8027dc0:	433c      	orrs	r4, r7
  sync_group &= ~(1U << slave_selected);
  for( group_index = XMC_VADC_MAXIMUM_NUM_GROUPS - (int32_t)1; group_index >= (int32_t)0  ; group_index--)
  {
    if ( (bool)false != (bool)((sync_group >> group_index) & 0x1 ))
 8027dc2:	0762      	lsls	r2, r4, #29
 8027dc4:	f100 80b8 	bmi.w	8027f38 <ADC_MEASUREMENT_ADV_Init+0x454>
 8027dc8:	07a3      	lsls	r3, r4, #30
 8027dca:	f100 80af 	bmi.w	8027f2c <ADC_MEASUREMENT_ADV_Init+0x448>
 8027dce:	07e0      	lsls	r0, r4, #31
 8027dd0:	d504      	bpl.n	8027ddc <ADC_MEASUREMENT_ADV_Init+0x2f8>
    {
      XMC_VADC_GROUP_SetSyncSlaveReadySignal(group_ptrs[slave_selected], slave_selected, group_index);
 8027dd2:	486c      	ldr	r0, [pc, #432]	; (8027f84 <ADC_MEASUREMENT_ADV_Init+0x4a0>)
 8027dd4:	2103      	movs	r1, #3
 8027dd6:	2200      	movs	r2, #0
 8027dd8:	f7fb fc36 	bl	8023648 <XMC_VADC_GROUP_SetSyncSlaveReadySignal>
                                        ADC_MEASUREMENT_ADV_SYNC_SEQ_t sequence)
{
  int8_t group_index;
  for( group_index = XMC_VADC_MAXIMUM_NUM_GROUPS - (int32_t)1; group_index >= (int32_t)0  ; group_index--)
  {
    if ( (bool)false != (bool)((sync_group >> group_index) & 0x1 ))
 8027ddc:	0779      	lsls	r1, r7, #29
 8027dde:	d510      	bpl.n	8027e02 <ADC_MEASUREMENT_ADV_Init+0x31e>
/* Helper function to configure the eval bits in the slave*/
void ADC_MEASUREMENT_ADV_lSyncEvalConfig(uint32_t master_group, uint32_t slave_selected,
                                         uint32_t sync_group)
{
  int8_t group_index;
  sync_group |= (1U << master_group);
 8027de0:	7dab      	ldrb	r3, [r5, #22]
 8027de2:	2401      	movs	r4, #1
 8027de4:	409c      	lsls	r4, r3
 8027de6:	433c      	orrs	r4, r7
  sync_group &= ~(1U << slave_selected);
  for( group_index = XMC_VADC_MAXIMUM_NUM_GROUPS - (int32_t)1; group_index >= (int32_t)0  ; group_index--)
  {
    if ( (bool)false != (bool)((sync_group >> group_index) & 0x1 ))
 8027de8:	0722      	lsls	r2, r4, #28
 8027dea:	f100 80bd 	bmi.w	8027f68 <ADC_MEASUREMENT_ADV_Init+0x484>
 8027dee:	07a3      	lsls	r3, r4, #30
 8027df0:	f100 80b4 	bmi.w	8027f5c <ADC_MEASUREMENT_ADV_Init+0x478>
 8027df4:	07e0      	lsls	r0, r4, #31
 8027df6:	d504      	bpl.n	8027e02 <ADC_MEASUREMENT_ADV_Init+0x31e>
    {
      XMC_VADC_GROUP_SetSyncSlaveReadySignal(group_ptrs[slave_selected], slave_selected, group_index);
 8027df8:	4863      	ldr	r0, [pc, #396]	; (8027f88 <ADC_MEASUREMENT_ADV_Init+0x4a4>)
 8027dfa:	2102      	movs	r1, #2
 8027dfc:	2200      	movs	r2, #0
 8027dfe:	f7fb fc23 	bl	8023648 <XMC_VADC_GROUP_SetSyncSlaveReadySignal>
                                        ADC_MEASUREMENT_ADV_SYNC_SEQ_t sequence)
{
  int8_t group_index;
  for( group_index = XMC_VADC_MAXIMUM_NUM_GROUPS - (int32_t)1; group_index >= (int32_t)0  ; group_index--)
  {
    if ( (bool)false != (bool)((sync_group >> group_index) & 0x1 ))
 8027e02:	07b9      	lsls	r1, r7, #30
 8027e04:	d510      	bpl.n	8027e28 <ADC_MEASUREMENT_ADV_Init+0x344>
/* Helper function to configure the eval bits in the slave*/
void ADC_MEASUREMENT_ADV_lSyncEvalConfig(uint32_t master_group, uint32_t slave_selected,
                                         uint32_t sync_group)
{
  int8_t group_index;
  sync_group |= (1U << master_group);
 8027e06:	7dab      	ldrb	r3, [r5, #22]
 8027e08:	2101      	movs	r1, #1
 8027e0a:	fa01 f403 	lsl.w	r4, r1, r3
 8027e0e:	433c      	orrs	r4, r7
  sync_group &= ~(1U << slave_selected);
  for( group_index = XMC_VADC_MAXIMUM_NUM_GROUPS - (int32_t)1; group_index >= (int32_t)0  ; group_index--)
  {
    if ( (bool)false != (bool)((sync_group >> group_index) & 0x1 ))
 8027e10:	0722      	lsls	r2, r4, #28
 8027e12:	f100 8086 	bmi.w	8027f22 <ADC_MEASUREMENT_ADV_Init+0x43e>
 8027e16:	0763      	lsls	r3, r4, #29
 8027e18:	d47d      	bmi.n	8027f16 <ADC_MEASUREMENT_ADV_Init+0x432>
 8027e1a:	07e4      	lsls	r4, r4, #31
 8027e1c:	d504      	bpl.n	8027e28 <ADC_MEASUREMENT_ADV_Init+0x344>
    {
      XMC_VADC_GROUP_SetSyncSlaveReadySignal(group_ptrs[slave_selected], slave_selected, group_index);
 8027e1e:	485b      	ldr	r0, [pc, #364]	; (8027f8c <ADC_MEASUREMENT_ADV_Init+0x4a8>)
 8027e20:	2101      	movs	r1, #1
 8027e22:	2200      	movs	r2, #0
 8027e24:	f7fb fc10 	bl	8023648 <XMC_VADC_GROUP_SetSyncSlaveReadySignal>
                                        ADC_MEASUREMENT_ADV_SYNC_SEQ_t sequence)
{
  int8_t group_index;
  for( group_index = XMC_VADC_MAXIMUM_NUM_GROUPS - (int32_t)1; group_index >= (int32_t)0  ; group_index--)
  {
    if ( (bool)false != (bool)((sync_group >> group_index) & 0x1 ))
 8027e28:	07f8      	lsls	r0, r7, #31
 8027e2a:	d510      	bpl.n	8027e4e <ADC_MEASUREMENT_ADV_Init+0x36a>
/* Helper function to configure the eval bits in the slave*/
void ADC_MEASUREMENT_ADV_lSyncEvalConfig(uint32_t master_group, uint32_t slave_selected,
                                         uint32_t sync_group)
{
  int8_t group_index;
  sync_group |= (1U << master_group);
 8027e2c:	7daa      	ldrb	r2, [r5, #22]
 8027e2e:	2301      	movs	r3, #1
 8027e30:	4093      	lsls	r3, r2
 8027e32:	431f      	orrs	r7, r3
  sync_group &= ~(1U << slave_selected);
  for( group_index = XMC_VADC_MAXIMUM_NUM_GROUPS - (int32_t)1; group_index >= (int32_t)0  ; group_index--)
  {
    if ( (bool)false != (bool)((sync_group >> group_index) & 0x1 ))
 8027e34:	0739      	lsls	r1, r7, #28
 8027e36:	f100 808b 	bmi.w	8027f50 <ADC_MEASUREMENT_ADV_Init+0x46c>
 8027e3a:	077a      	lsls	r2, r7, #29
 8027e3c:	f100 8082 	bmi.w	8027f44 <ADC_MEASUREMENT_ADV_Init+0x460>
 8027e40:	07bb      	lsls	r3, r7, #30
 8027e42:	d504      	bpl.n	8027e4e <ADC_MEASUREMENT_ADV_Init+0x36a>
    {
      XMC_VADC_GROUP_SetSyncSlaveReadySignal(group_ptrs[slave_selected], slave_selected, group_index);
 8027e44:	4852      	ldr	r0, [pc, #328]	; (8027f90 <ADC_MEASUREMENT_ADV_Init+0x4ac>)
 8027e46:	2100      	movs	r1, #0
 8027e48:	2201      	movs	r2, #1
 8027e4a:	f7fb fbfd 	bl	8023648 <XMC_VADC_GROUP_SetSyncSlaveReadySignal>
  sync_group = handle_ptr->sync_slaves;
  ADC_MEASUREMENT_ADV_lSyncSequencer(handle_ptr, sync_group, ADC_MEASUREMENT_ADV_SYNC_SEQ_STSEL_CONFIG);
  ADC_MEASUREMENT_ADV_lSyncSequencer(handle_ptr, sync_group, ADC_MEASUREMENT_ADV_SYNC_SEQ_EVAL_CONFIG);

  /* Configure the iclass settings needed for the sync slaves*/
  if( (bool) false != handle_ptr->configure_globiclass1)
 8027e4e:	7eab      	ldrb	r3, [r5, #26]
 8027e50:	b1b3      	cbz	r3, 8027e80 <ADC_MEASUREMENT_ADV_Init+0x39c>
{
  XMC_VADC_CHANNEL_CONV_t req_iclass;

#ifdef ADC_MEASUREMENT_ADV_SCAN_USED
  #ifdef ADC_MEASUREMENT_ADV_QUEUE_USED
    if ( ADC_MEASUREMENT_ADV_REQUEST_SOURCE_LOCAL_SCAN >= handle_ptr->req_src)
 8027e52:	7d2b      	ldrb	r3, [r5, #20]
  XMC_VADC_GLOBAL_CLASS_t conv_class_global;

  XMC_ASSERT("ADC_MEASUREMENT_ADV_SetIclass:Invalid handle_ptr", (handle_ptr != NULL))

  req_iclass = ADC_MEASUREMENT_ADV_lGetIclass(handle_ptr);
  conv_class = XMC_VADC_GROUP_GetInputClass(group_ptrs[handle_ptr->group_index], req_iclass);
 8027e54:	7daa      	ldrb	r2, [r5, #22]
{
  XMC_VADC_CHANNEL_CONV_t req_iclass;

#ifdef ADC_MEASUREMENT_ADV_SCAN_USED
  #ifdef ADC_MEASUREMENT_ADV_QUEUE_USED
    if ( ADC_MEASUREMENT_ADV_REQUEST_SOURCE_LOCAL_SCAN >= handle_ptr->req_src)
 8027e56:	2b01      	cmp	r3, #1
#ifdef ADC_MEASUREMENT_ADV_LOCAL_SCAN_USED
  #ifdef ADC_MEASUREMENT_ADV_ADC_SCAN_USED
      if ( ADC_MEASUREMENT_ADV_REQUEST_SOURCE_SCAN != handle_ptr->req_src)
  #endif
      {
        req_iclass = (XMC_VADC_CHANNEL_CONV_t)handle_ptr->local_scan_handle->iclass_num;
 8027e58:	68eb      	ldr	r3, [r5, #12]
  XMC_VADC_GLOBAL_CLASS_t conv_class_global;

  XMC_ASSERT("ADC_MEASUREMENT_ADV_SetIclass:Invalid handle_ptr", (handle_ptr != NULL))

  req_iclass = ADC_MEASUREMENT_ADV_lGetIclass(handle_ptr);
  conv_class = XMC_VADC_GROUP_GetInputClass(group_ptrs[handle_ptr->group_index], req_iclass);
 8027e5a:	f856 2022 	ldr.w	r2, [r6, r2, lsl #2]
#ifdef ADC_MEASUREMENT_ADV_LOCAL_SCAN_USED
  #ifdef ADC_MEASUREMENT_ADV_ADC_SCAN_USED
      if ( ADC_MEASUREMENT_ADV_REQUEST_SOURCE_SCAN != handle_ptr->req_src)
  #endif
      {
        req_iclass = (XMC_VADC_CHANNEL_CONV_t)handle_ptr->local_scan_handle->iclass_num;
 8027e5e:	bf94      	ite	ls
 8027e60:	f893 3020 	ldrbls.w	r3, [r3, #32]
#ifdef ADC_MEASUREMENT_ADV_LOCAL_QUEUE_USED
  #ifdef ADC_MEASUREMENT_ADV_ADC_QUEUE_USED
      if ( ADC_MEASUREMENT_ADV_REQUEST_SOURCE_QUEUE != handle_ptr->req_src)
  #endif
      {
        req_iclass = (XMC_VADC_CHANNEL_CONV_t)handle_ptr->local_queue_handle->iclass_num;
 8027e64:	7e9b      	ldrbhi	r3, [r3, #26]
  XMC_ASSERT("XMC_VADC_GROUP_GetInputClass:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  XMC_ASSERT("XMC_VADC_GROUP_GetInputClass:Wrong conv_class selected", 
             (XMC_VADC_CHANNEL_CONV_GROUP_CLASS0 == conv_class) || (XMC_VADC_CHANNEL_CONV_GROUP_CLASS1 == conv_class))

  input_value.g_iclass0 = (uint32_t) 0xFFFFFFFF;
  if ((XMC_VADC_CHANNEL_CONV_GROUP_CLASS0 == conv_class) || (XMC_VADC_CHANNEL_CONV_GROUP_CLASS1 == conv_class))
 8027e66:	2b01      	cmp	r3, #1
  {
    input_value.g_iclass0 = group_ptr->ICLASS[(uint32_t)conv_class];
 8027e68:	bf96      	itet	ls
 8027e6a:	3328      	addls	r3, #40	; 0x28
  XMC_VADC_GROUP_CLASS_t input_value;
  XMC_ASSERT("XMC_VADC_GROUP_GetInputClass:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  XMC_ASSERT("XMC_VADC_GROUP_GetInputClass:Wrong conv_class selected", 
             (XMC_VADC_CHANNEL_CONV_GROUP_CLASS0 == conv_class) || (XMC_VADC_CHANNEL_CONV_GROUP_CLASS1 == conv_class))

  input_value.g_iclass0 = (uint32_t) 0xFFFFFFFF;
 8027e6c:	f04f 31ff 	movhi.w	r1, #4294967295
  if ((XMC_VADC_CHANNEL_CONV_GROUP_CLASS0 == conv_class) || (XMC_VADC_CHANNEL_CONV_GROUP_CLASS1 == conv_class))
  {
    input_value.g_iclass0 = group_ptr->ICLASS[(uint32_t)conv_class];
 8027e70:	f852 1023 	ldrls.w	r1, [r2, r3, lsl #2]
  XMC_ASSERT("ADC_MEASUREMENT_ADV_SetIclass:Invalid handle_ptr", (handle_ptr != NULL))

  req_iclass = ADC_MEASUREMENT_ADV_lGetIclass(handle_ptr);
  conv_class = XMC_VADC_GROUP_GetInputClass(group_ptrs[handle_ptr->group_index], req_iclass);
  conv_class_global.globiclass = conv_class.g_iclass0;
  XMC_VADC_GLOBAL_InputClassInit(ADC_MEASUREMENT_ADV_GLOBAL_PTR, conv_class_global,
 8027e74:	f04f 2040 	mov.w	r0, #1073758208	; 0x40004000
 8027e78:	2200      	movs	r2, #0
 8027e7a:	2301      	movs	r3, #1
 8027e7c:	f7fb fadc 	bl	8023438 <XMC_VADC_GLOBAL_InputClassInit>
  if( (bool) false != handle_ptr->configure_globiclass1)
  {
    ADC_MEASUREMENT_ADV_SetIclass(handle_ptr);
  }

  XMC_VADC_GROUP_SetSyncMaster(group_ptrs[handle_ptr->group_index]);
 8027e80:	7dab      	ldrb	r3, [r5, #22]
 8027e82:	f856 0023 	ldr.w	r0, [r6, r3, lsl #2]
 8027e86:	f7fb fbb7 	bl	80235f8 <XMC_VADC_GROUP_SetSyncMaster>

  XMC_VADC_GROUP_SetPowerMode(group_ptrs[handle_ptr->group_index],XMC_VADC_GROUP_POWERMODE_NORMAL);
 8027e8a:	7dab      	ldrb	r3, [r5, #22]
 8027e8c:	2103      	movs	r1, #3
 8027e8e:	f856 0023 	ldr.w	r0, [r6, r3, lsl #2]
 8027e92:	f7fb fb9d 	bl	80235d0 <XMC_VADC_GROUP_SetPowerMode>
 8027e96:	e6a4      	b.n	8027be2 <ADC_MEASUREMENT_ADV_Init+0xfe>
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8027e98:	1e5a      	subs	r2, r3, #1
 8027e9a:	2301      	movs	r3, #1
 8027e9c:	4093      	lsls	r3, r2
 8027e9e:	3b01      	subs	r3, #1
 8027ea0:	ea03 030c 	and.w	r3, r3, ip
 8027ea4:	e66c      	b.n	8027b80 <ADC_MEASUREMENT_ADV_Init+0x9c>
#endif
#ifdef ADC_MEASUREMENT_ADV_LOCAL_QUEUE_USED
    if (((bool)true == handle_ptr->local_queue_handle->rs_intr_handle.interrupt_enable) &&
        (ADC_MEASUREMENT_ADV_REQUEST_SOURCE_LOCAL_QUEUE == handle_ptr->req_src))
    {
      NVIC_EnableIRQ((IRQn_Type)handle_ptr->local_queue_handle->rs_intr_handle.node_id);
 8027ea6:	6812      	ldr	r2, [r2, #0]
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
 8027ea8:	b253      	sxtb	r3, r2
 8027eaa:	2b00      	cmp	r3, #0
 8027eac:	f6ff aecb 	blt.w	8027c46 <ADC_MEASUREMENT_ADV_Init+0x162>
  {
    NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8027eb0:	f002 021f 	and.w	r2, r2, #31
 8027eb4:	095b      	lsrs	r3, r3, #5
 8027eb6:	2101      	movs	r1, #1
 8027eb8:	4836      	ldr	r0, [pc, #216]	; (8027f94 <ADC_MEASUREMENT_ADV_Init+0x4b0>)
 8027eba:	fa01 f202 	lsl.w	r2, r1, r2
 8027ebe:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
 8027ec2:	e6c0      	b.n	8027c46 <ADC_MEASUREMENT_ADV_Init+0x162>
{
#ifdef ADC_MEASUREMENT_ADV_LOCAL_SCAN_USED
    if (((bool)true == handle_ptr->local_scan_handle->rs_intr_handle.interrupt_enable) &&
        (ADC_MEASUREMENT_ADV_REQUEST_SOURCE_LOCAL_SCAN == handle_ptr->req_src))
    {
      NVIC_EnableIRQ((IRQn_Type)handle_ptr->local_scan_handle->rs_intr_handle.node_id);
 8027ec4:	6810      	ldr	r0, [r2, #0]
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
 8027ec6:	b241      	sxtb	r1, r0
 8027ec8:	2900      	cmp	r1, #0
 8027eca:	db07      	blt.n	8027edc <ADC_MEASUREMENT_ADV_Init+0x3f8>
  {
    NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8027ecc:	4a31      	ldr	r2, [pc, #196]	; (8027f94 <ADC_MEASUREMENT_ADV_Init+0x4b0>)
 8027ece:	f000 001f 	and.w	r0, r0, #31
 8027ed2:	0949      	lsrs	r1, r1, #5
 8027ed4:	4083      	lsls	r3, r0
 8027ed6:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
 8027eda:	68ea      	ldr	r2, [r5, #12]
#ifdef ADC_MEASUREMENT_ADV_LOCAL_SCAN_USED
  #ifdef ADC_MEASUREMENT_ADV_ADC_SCAN_USED
      if ( ADC_MEASUREMENT_ADV_REQUEST_SOURCE_SCAN != handle_ptr->req_src)
  #endif
      {
        XMC_VADC_GROUP_ScanAddMultipleChannels(group_ptrs[handle_ptr->group_index], handle_ptr->local_scan_handle->insert_mask);
 8027edc:	7dab      	ldrb	r3, [r5, #22]
 8027ede:	69d2      	ldr	r2, [r2, #28]
 8027ee0:	f856 3023 	ldr.w	r3, [r6, r3, lsl #2]
 *  XMC_VADC_GROUP_ScanAddChannelToSequence()<BR>
 */
__STATIC_INLINE void XMC_VADC_GROUP_ScanAddMultipleChannels(XMC_VADC_GROUP_t *const group_ptr, const uint32_t ch_mask)
{
  XMC_ASSERT("XMC_VADC_GROUP_ScanAddMultipleChannels:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  group_ptr->ASSEL = ch_mask;
 8027ee4:	f8c3 2128 	str.w	r2, [r3, #296]	; 0x128
#ifdef ADC_MEASUREMENT_ADV_SCAN_USED
  #ifdef ADC_MEASUREMENT_ADV_QUEUE_USED
    if ( ADC_MEASUREMENT_ADV_REQUEST_SOURCE_LOCAL_SCAN >= handle_ptr->req_src)
  #endif
      {
        XMC_VADC_GROUP_ScanEnableArbitrationSlot(group_ptrs[handle_ptr->group_index]);
 8027ee8:	7dab      	ldrb	r3, [r5, #22]
 8027eea:	f856 2023 	ldr.w	r2, [r6, r3, lsl #2]
 *  XMC_VADC_GROUP_ScanDisableArbitrationSlot()<BR>
 */
__STATIC_INLINE void XMC_VADC_GROUP_ScanEnableArbitrationSlot(XMC_VADC_GROUP_t *const group_ptr)
{
  XMC_ASSERT("XMC_VADC_GROUP_ScanEnableArbitrationSlot:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  group_ptr->ARBPR |= (uint32_t)VADC_G_ARBPR_ASEN1_Msk;
 8027eee:	f8d2 3084 	ldr.w	r3, [r2, #132]	; 0x84
 8027ef2:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 8027ef6:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
 8027efa:	e6c2      	b.n	8027c82 <ADC_MEASUREMENT_ADV_Init+0x19e>
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
  else
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8027efc:	4a26      	ldr	r2, [pc, #152]	; (8027f98 <ADC_MEASUREMENT_ADV_Init+0x4b4>)
 8027efe:	f00e 0e0f 	and.w	lr, lr, #15
 8027f02:	009b      	lsls	r3, r3, #2
 8027f04:	4472      	add	r2, lr
 8027f06:	b2db      	uxtb	r3, r3
 8027f08:	7613      	strb	r3, [r2, #24]
 8027f0a:	e651      	b.n	8027bb0 <ADC_MEASUREMENT_ADV_Init+0xcc>
 */
__STATIC_INLINE bool XMC_VADC_GROUP_ScanIsArbitrationSlotEnabled(XMC_VADC_GROUP_t *const group_ptr)
{
  XMC_ASSERT("XMC_VADC_GROUP_ScanIsArbitrationSlotEnabled:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))

  return ((group_ptr->ARBPR & (uint32_t)VADC_G_ARBPR_ASEN1_Msk) >> VADC_G_ARBPR_ASEN1_Pos);
 8027f0c:	f3c3 6940 	ubfx	r9, r3, #25, #1
 8027f10:	e6c9      	b.n	8027ca6 <ADC_MEASUREMENT_ADV_Init+0x1c2>
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8027f12:	461a      	mov	r2, r3
 8027f14:	e702      	b.n	8027d1c <ADC_MEASUREMENT_ADV_Init+0x238>
  sync_group &= ~(1U << slave_selected);
  for( group_index = XMC_VADC_MAXIMUM_NUM_GROUPS - (int32_t)1; group_index >= (int32_t)0  ; group_index--)
  {
    if ( (bool)false != (bool)((sync_group >> group_index) & 0x1 ))
    {
      XMC_VADC_GROUP_SetSyncSlaveReadySignal(group_ptrs[slave_selected], slave_selected, group_index);
 8027f16:	481d      	ldr	r0, [pc, #116]	; (8027f8c <ADC_MEASUREMENT_ADV_Init+0x4a8>)
 8027f18:	2101      	movs	r1, #1
 8027f1a:	2202      	movs	r2, #2
 8027f1c:	f7fb fb94 	bl	8023648 <XMC_VADC_GROUP_SetSyncSlaveReadySignal>
 8027f20:	e77b      	b.n	8027e1a <ADC_MEASUREMENT_ADV_Init+0x336>
 8027f22:	481a      	ldr	r0, [pc, #104]	; (8027f8c <ADC_MEASUREMENT_ADV_Init+0x4a8>)
 8027f24:	2203      	movs	r2, #3
 8027f26:	f7fb fb8f 	bl	8023648 <XMC_VADC_GROUP_SetSyncSlaveReadySignal>
 8027f2a:	e774      	b.n	8027e16 <ADC_MEASUREMENT_ADV_Init+0x332>
 8027f2c:	4815      	ldr	r0, [pc, #84]	; (8027f84 <ADC_MEASUREMENT_ADV_Init+0x4a0>)
 8027f2e:	2103      	movs	r1, #3
 8027f30:	2201      	movs	r2, #1
 8027f32:	f7fb fb89 	bl	8023648 <XMC_VADC_GROUP_SetSyncSlaveReadySignal>
 8027f36:	e74a      	b.n	8027dce <ADC_MEASUREMENT_ADV_Init+0x2ea>
 8027f38:	4812      	ldr	r0, [pc, #72]	; (8027f84 <ADC_MEASUREMENT_ADV_Init+0x4a0>)
 8027f3a:	2103      	movs	r1, #3
 8027f3c:	2202      	movs	r2, #2
 8027f3e:	f7fb fb83 	bl	8023648 <XMC_VADC_GROUP_SetSyncSlaveReadySignal>
 8027f42:	e741      	b.n	8027dc8 <ADC_MEASUREMENT_ADV_Init+0x2e4>
 8027f44:	4812      	ldr	r0, [pc, #72]	; (8027f90 <ADC_MEASUREMENT_ADV_Init+0x4ac>)
 8027f46:	2100      	movs	r1, #0
 8027f48:	2202      	movs	r2, #2
 8027f4a:	f7fb fb7d 	bl	8023648 <XMC_VADC_GROUP_SetSyncSlaveReadySignal>
 8027f4e:	e777      	b.n	8027e40 <ADC_MEASUREMENT_ADV_Init+0x35c>
 8027f50:	480f      	ldr	r0, [pc, #60]	; (8027f90 <ADC_MEASUREMENT_ADV_Init+0x4ac>)
 8027f52:	2100      	movs	r1, #0
 8027f54:	2203      	movs	r2, #3
 8027f56:	f7fb fb77 	bl	8023648 <XMC_VADC_GROUP_SetSyncSlaveReadySignal>
 8027f5a:	e76e      	b.n	8027e3a <ADC_MEASUREMENT_ADV_Init+0x356>
 8027f5c:	480a      	ldr	r0, [pc, #40]	; (8027f88 <ADC_MEASUREMENT_ADV_Init+0x4a4>)
 8027f5e:	2102      	movs	r1, #2
 8027f60:	2201      	movs	r2, #1
 8027f62:	f7fb fb71 	bl	8023648 <XMC_VADC_GROUP_SetSyncSlaveReadySignal>
 8027f66:	e745      	b.n	8027df4 <ADC_MEASUREMENT_ADV_Init+0x310>
 8027f68:	4807      	ldr	r0, [pc, #28]	; (8027f88 <ADC_MEASUREMENT_ADV_Init+0x4a4>)
 8027f6a:	2102      	movs	r1, #2
 8027f6c:	2203      	movs	r2, #3
 8027f6e:	f7fb fb6b 	bl	8023648 <XMC_VADC_GROUP_SetSyncSlaveReadySignal>
 8027f72:	e73c      	b.n	8027dee <ADC_MEASUREMENT_ADV_Init+0x30a>
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
  else
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8027f74:	4a08      	ldr	r2, [pc, #32]	; (8027f98 <ADC_MEASUREMENT_ADV_Init+0x4b4>)
 8027f76:	f00e 0e0f 	and.w	lr, lr, #15
 8027f7a:	009b      	lsls	r3, r3, #2
 8027f7c:	4472      	add	r2, lr
 8027f7e:	b2db      	uxtb	r3, r3
 8027f80:	7613      	strb	r3, [r2, #24]
 8027f82:	e6e3      	b.n	8027d4c <ADC_MEASUREMENT_ADV_Init+0x268>
 8027f84:	40005000 	.word	0x40005000
 8027f88:	40004c00 	.word	0x40004c00
 8027f8c:	40004800 	.word	0x40004800
 8027f90:	40004400 	.word	0x40004400
 8027f94:	e000e100 	.word	0xe000e100
 8027f98:	e000ecfc 	.word	0xe000ecfc

08027f9c <ADC_MEASUREMENT_ADV_G0_event_config>:
 */
static void ADC_MEASUREMENT_ADV_G0_event_config(void)
{

	/* Result Event Node Mux Configuration for CH_G0 (Group-0 channel-0 Result_Register-15)*/
	XMC_VADC_GROUP_SetResultInterruptNode(VADC_G0, 15U, XMC_VADC_SR_SHARED_SR0);
 8027f9c:	4802      	ldr	r0, [pc, #8]	; (8027fa8 <ADC_MEASUREMENT_ADV_G0_event_config+0xc>)
 8027f9e:	210f      	movs	r1, #15
 8027fa0:	2204      	movs	r2, #4
 8027fa2:	f7fb bc35 	b.w	8023810 <XMC_VADC_GROUP_SetResultInterruptNode>
 8027fa6:	bf00      	nop
 8027fa8:	40004400 	.word	0x40004400

08027fac <ADC_MEASUREMENT_ADV_G1_event_config>:
 */
static void ADC_MEASUREMENT_ADV_G1_event_config(void)
{

	/* Result Event Node Mux Configuration for CH_G1 (Group-1 channel-3 Result_Register-3)*/
	XMC_VADC_GROUP_SetResultInterruptNode(VADC_G1, 3U, XMC_VADC_SR_SHARED_SR1);
 8027fac:	4802      	ldr	r0, [pc, #8]	; (8027fb8 <ADC_MEASUREMENT_ADV_G1_event_config+0xc>)
 8027fae:	2103      	movs	r1, #3
 8027fb0:	2205      	movs	r2, #5
 8027fb2:	f7fb bc2d 	b.w	8023810 <XMC_VADC_GROUP_SetResultInterruptNode>
 8027fb6:	bf00      	nop
 8027fb8:	40004800 	.word	0x40004800

08027fbc <ADC_MEASUREMENT_ADV_G2_event_config>:
 */
static void ADC_MEASUREMENT_ADV_G2_event_config(void)
{

	/* Result Event Node Mux Configuration for CH_G2 (Group-2 channel-3 Result_Register-0)*/
	XMC_VADC_GROUP_SetResultInterruptNode(VADC_G2, 0U, XMC_VADC_SR_SHARED_SR3);
 8027fbc:	4802      	ldr	r0, [pc, #8]	; (8027fc8 <ADC_MEASUREMENT_ADV_G2_event_config+0xc>)
 8027fbe:	2100      	movs	r1, #0
 8027fc0:	2207      	movs	r2, #7
 8027fc2:	f7fb bc25 	b.w	8023810 <XMC_VADC_GROUP_SetResultInterruptNode>
 8027fc6:	bf00      	nop
 8027fc8:	40004c00 	.word	0x40004c00

08027fcc <ADC_MEASUREMENT_ADV_G3_event_config>:
 */
static void ADC_MEASUREMENT_ADV_G3_event_config(void)
{

	/* Result Event Node Mux Configuration for CH_G3 (Group-3 channel-1 Result_Register-4)*/
	XMC_VADC_GROUP_SetResultInterruptNode(VADC_G3, 4U, XMC_VADC_SR_GROUP_SR2);
 8027fcc:	4802      	ldr	r0, [pc, #8]	; (8027fd8 <ADC_MEASUREMENT_ADV_G3_event_config+0xc>)
 8027fce:	2104      	movs	r1, #4
 8027fd0:	2202      	movs	r2, #2
 8027fd2:	f7fb bc1d 	b.w	8023810 <XMC_VADC_GROUP_SetResultInterruptNode>
 8027fd6:	bf00      	nop
 8027fd8:	40005000 	.word	0x40005000

08027fdc <DAVE_Init>:
 * @param[in]  None
 *
 * @return  DAVE_STATUS_t <BR>
 ******************************************************************************/
DAVE_STATUS_t DAVE_Init(void)
{
 8027fdc:	b508      	push	{r3, lr}
  DAVE_STATUS_t init_status;
  
  init_status = DAVE_STATUS_SUCCESS;
     /** @Initialization of APPs Init Functions */
     init_status = (DAVE_STATUS_t)CLOCK_XMC4_Init(&CLOCK_XMC4_0);
 8027fde:	486a      	ldr	r0, [pc, #424]	; (8028188 <DAVE_Init+0x1ac>)
 8027fe0:	f7ff fd52 	bl	8027a88 <CLOCK_XMC4_Init>

  if (init_status == DAVE_STATUS_SUCCESS)
 8027fe4:	b100      	cbz	r0, 8027fe8 <DAVE_Init+0xc>
  {
	 /**  Initialization of TIMER APP instance TIMER_ERROR_TOGGLE */
	 init_status = (DAVE_STATUS_t)TIMER_Init(&TIMER_ERROR_TOGGLE); 
   }  
  return init_status;
} /**  End of function DAVE_Init */
 8027fe6:	bd08      	pop	{r3, pc}
     init_status = (DAVE_STATUS_t)CLOCK_XMC4_Init(&CLOCK_XMC4_0);

  if (init_status == DAVE_STATUS_SUCCESS)
  {
	 /**  Initialization of ADC_MEASUREMENT_ADV APP instance ADC_MEASUREMENT_ADV_G0 */
	 init_status = (DAVE_STATUS_t)ADC_MEASUREMENT_ADV_Init(&ADC_MEASUREMENT_ADV_G0); 
 8027fe8:	4868      	ldr	r0, [pc, #416]	; (802818c <DAVE_Init+0x1b0>)
 8027fea:	f7ff fd7b 	bl	8027ae4 <ADC_MEASUREMENT_ADV_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8027fee:	2800      	cmp	r0, #0
 8027ff0:	d1f9      	bne.n	8027fe6 <DAVE_Init+0xa>
  {
	 /**  Initialization of INTERRUPT APP instance INTERRUPT_FRAME */
	 init_status = (DAVE_STATUS_t)INTERRUPT_Init(&INTERRUPT_FRAME); 
 8027ff2:	4867      	ldr	r0, [pc, #412]	; (8028190 <DAVE_Init+0x1b4>)
 8027ff4:	f7fe fa80 	bl	80264f8 <INTERRUPT_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8027ff8:	2800      	cmp	r0, #0
 8027ffa:	d1f4      	bne.n	8027fe6 <DAVE_Init+0xa>
  {
	 /**  Initialization of TIMER APP instance TIMER_FRAME_TRIG */
	 init_status = (DAVE_STATUS_t)TIMER_Init(&TIMER_FRAME_TRIG); 
 8027ffc:	4865      	ldr	r0, [pc, #404]	; (8028194 <DAVE_Init+0x1b8>)
 8027ffe:	f7fd fef3 	bl	8025de8 <TIMER_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8028002:	2800      	cmp	r0, #0
 8028004:	d1ef      	bne.n	8027fe6 <DAVE_Init+0xa>
  {
	 /**  Initialization of USBD_VCOM APP instance USBD_VCOM_0 */
	 init_status = (DAVE_STATUS_t)USBD_VCOM_Init(&USBD_VCOM_0); 
 8028006:	4864      	ldr	r0, [pc, #400]	; (8028198 <DAVE_Init+0x1bc>)
 8028008:	f7fc ff68 	bl	8024edc <USBD_VCOM_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802800c:	2800      	cmp	r0, #0
 802800e:	d1ea      	bne.n	8027fe6 <DAVE_Init+0xa>
  {
	 /**  Initialization of GLOBAL_CCU8 APP instance GLOBAL_CCU8_0 */
	 init_status = (DAVE_STATUS_t)GLOBAL_CCU8_Init(&GLOBAL_CCU8_0); 
 8028010:	4862      	ldr	r0, [pc, #392]	; (802819c <DAVE_Init+0x1c0>)
 8028012:	f7fe fb15 	bl	8026640 <GLOBAL_CCU8_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8028016:	2800      	cmp	r0, #0
 8028018:	d1e5      	bne.n	8027fe6 <DAVE_Init+0xa>
  {
	 /**  Initialization of ADC_MEASUREMENT_ADV APP instance ADC_MEASUREMENT_ADV_G1 */
	 init_status = (DAVE_STATUS_t)ADC_MEASUREMENT_ADV_Init(&ADC_MEASUREMENT_ADV_G1); 
 802801a:	4861      	ldr	r0, [pc, #388]	; (80281a0 <DAVE_Init+0x1c4>)
 802801c:	f7ff fd62 	bl	8027ae4 <ADC_MEASUREMENT_ADV_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8028020:	2800      	cmp	r0, #0
 8028022:	d1e0      	bne.n	8027fe6 <DAVE_Init+0xa>
  {
	 /**  Initialization of DMA_CH APP instance DMA_CH_G0 */
	 init_status = (DAVE_STATUS_t)DMA_CH_Init(&DMA_CH_G0); 
 8028024:	485f      	ldr	r0, [pc, #380]	; (80281a4 <DAVE_Init+0x1c8>)
 8028026:	f7fe fb69 	bl	80266fc <DMA_CH_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802802a:	2800      	cmp	r0, #0
 802802c:	d1db      	bne.n	8027fe6 <DAVE_Init+0xa>
  {
	 /**  Initialization of DMA_CH APP instance DMA_CH_G1 */
	 init_status = (DAVE_STATUS_t)DMA_CH_Init(&DMA_CH_G1); 
 802802e:	485e      	ldr	r0, [pc, #376]	; (80281a8 <DAVE_Init+0x1cc>)
 8028030:	f7fe fb64 	bl	80266fc <DMA_CH_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8028034:	2800      	cmp	r0, #0
 8028036:	d1d6      	bne.n	8027fe6 <DAVE_Init+0xa>
  {
	 /**  Initialization of ADC_MEASUREMENT_ADV APP instance ADC_MEASUREMENT_SCAN */
	 init_status = (DAVE_STATUS_t)ADC_MEASUREMENT_ADV_Init(&ADC_MEASUREMENT_SCAN); 
 8028038:	485c      	ldr	r0, [pc, #368]	; (80281ac <DAVE_Init+0x1d0>)
 802803a:	f7ff fd53 	bl	8027ae4 <ADC_MEASUREMENT_ADV_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802803e:	2800      	cmp	r0, #0
 8028040:	d1d1      	bne.n	8027fe6 <DAVE_Init+0xa>
  {
	 /**  Initialization of DIGITAL_IO APP instance DIGITAL_IO_BGT_VCC_PTAT */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_BGT_VCC_PTAT); 
 8028042:	485b      	ldr	r0, [pc, #364]	; (80281b0 <DAVE_Init+0x1d4>)
 8028044:	f7fe fbee 	bl	8026824 <DIGITAL_IO_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8028048:	2800      	cmp	r0, #0
 802804a:	d1cc      	bne.n	8027fe6 <DAVE_Init+0xa>
  {
	 /**  Initialization of PWM_CCU8 APP instance PWM_CCU8_BGT_VCC */
	 init_status = (DAVE_STATUS_t)PWM_CCU8_Init(&PWM_CCU8_BGT_VCC); 
 802804c:	4859      	ldr	r0, [pc, #356]	; (80281b4 <DAVE_Init+0x1d8>)
 802804e:	f7fd ffbb 	bl	8025fc8 <PWM_CCU8_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8028052:	2800      	cmp	r0, #0
 8028054:	d1c7      	bne.n	8027fe6 <DAVE_Init+0xa>
  {
	 /**  Initialization of PWM_CCU8 APP instance PWM_CCU8_BGT_TX_ON */
	 init_status = (DAVE_STATUS_t)PWM_CCU8_Init(&PWM_CCU8_BGT_TX_ON); 
 8028056:	4858      	ldr	r0, [pc, #352]	; (80281b8 <DAVE_Init+0x1dc>)
 8028058:	f7fd ffb6 	bl	8025fc8 <PWM_CCU8_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802805c:	2800      	cmp	r0, #0
 802805e:	d1c2      	bne.n	8027fe6 <DAVE_Init+0xa>
  {
	 /**  Initialization of PWM_CCU8 APP instance PWM_CCU8_SAMPLE_HOLD */
	 init_status = (DAVE_STATUS_t)PWM_CCU8_Init(&PWM_CCU8_SAMPLE_HOLD); 
 8028060:	4856      	ldr	r0, [pc, #344]	; (80281bc <DAVE_Init+0x1e0>)
 8028062:	f7fd ffb1 	bl	8025fc8 <PWM_CCU8_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8028066:	2800      	cmp	r0, #0
 8028068:	d1bd      	bne.n	8027fe6 <DAVE_Init+0xa>
  {
	 /**  Initialization of PWM_CCU8 APP instance PWM_CCU8_ADC_SAMPLE */
	 init_status = (DAVE_STATUS_t)PWM_CCU8_Init(&PWM_CCU8_ADC_SAMPLE); 
 802806a:	4855      	ldr	r0, [pc, #340]	; (80281c0 <DAVE_Init+0x1e4>)
 802806c:	f7fd ffac 	bl	8025fc8 <PWM_CCU8_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8028070:	2800      	cmp	r0, #0
 8028072:	d1b8      	bne.n	8027fe6 <DAVE_Init+0xa>
  {
	 /**  Initialization of DIGITAL_IO APP instance DIGITAL_IO_RED_LED */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_RED_LED); 
 8028074:	4853      	ldr	r0, [pc, #332]	; (80281c4 <DAVE_Init+0x1e8>)
 8028076:	f7fe fbd5 	bl	8026824 <DIGITAL_IO_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802807a:	2800      	cmp	r0, #0
 802807c:	d1b3      	bne.n	8027fe6 <DAVE_Init+0xa>
  {
	 /**  Initialization of DIGITAL_IO APP instance DIGITAL_IO_BLUE_LED */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_BLUE_LED); 
 802807e:	4852      	ldr	r0, [pc, #328]	; (80281c8 <DAVE_Init+0x1ec>)
 8028080:	f7fe fbd0 	bl	8026824 <DIGITAL_IO_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8028084:	2800      	cmp	r0, #0
 8028086:	d1ae      	bne.n	8027fe6 <DAVE_Init+0xa>
  {
	 /**  Initialization of DIGITAL_IO APP instance DIGITAL_IO_GREEN_LED */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_GREEN_LED); 
 8028088:	4850      	ldr	r0, [pc, #320]	; (80281cc <DAVE_Init+0x1f0>)
 802808a:	f7fe fbcb 	bl	8026824 <DIGITAL_IO_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802808e:	2800      	cmp	r0, #0
 8028090:	d1a9      	bne.n	8027fe6 <DAVE_Init+0xa>
  {
	 /**  Initialization of TIMER APP instance TIMER_PTAT_DELAY */
	 init_status = (DAVE_STATUS_t)TIMER_Init(&TIMER_PTAT_DELAY); 
 8028092:	484f      	ldr	r0, [pc, #316]	; (80281d0 <DAVE_Init+0x1f4>)
 8028094:	f7fd fea8 	bl	8025de8 <TIMER_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8028098:	2800      	cmp	r0, #0
 802809a:	d1a4      	bne.n	8027fe6 <DAVE_Init+0xa>
  {
	 /**  Initialization of INTERRUPT APP instance INTERRUPT_PTAT_TIMER */
	 init_status = (DAVE_STATUS_t)INTERRUPT_Init(&INTERRUPT_PTAT_TIMER); 
 802809c:	484d      	ldr	r0, [pc, #308]	; (80281d4 <DAVE_Init+0x1f8>)
 802809e:	f7fe fa2b 	bl	80264f8 <INTERRUPT_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 80280a2:	2800      	cmp	r0, #0
 80280a4:	d19f      	bne.n	8027fe6 <DAVE_Init+0xa>
  {
	 /**  Initialization of ADC_MEASUREMENT_ADV APP instance ADC_MEASUREMENT_ADV_G2 */
	 init_status = (DAVE_STATUS_t)ADC_MEASUREMENT_ADV_Init(&ADC_MEASUREMENT_ADV_G2); 
 80280a6:	484c      	ldr	r0, [pc, #304]	; (80281d8 <DAVE_Init+0x1fc>)
 80280a8:	f7ff fd1c 	bl	8027ae4 <ADC_MEASUREMENT_ADV_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 80280ac:	2800      	cmp	r0, #0
 80280ae:	d19a      	bne.n	8027fe6 <DAVE_Init+0xa>
  {
	 /**  Initialization of ADC_MEASUREMENT_ADV APP instance ADC_MEASUREMENT_ADV_G3 */
	 init_status = (DAVE_STATUS_t)ADC_MEASUREMENT_ADV_Init(&ADC_MEASUREMENT_ADV_G3); 
 80280b0:	484a      	ldr	r0, [pc, #296]	; (80281dc <DAVE_Init+0x200>)
 80280b2:	f7ff fd17 	bl	8027ae4 <ADC_MEASUREMENT_ADV_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 80280b6:	2800      	cmp	r0, #0
 80280b8:	d195      	bne.n	8027fe6 <DAVE_Init+0xa>
  {
	 /**  Initialization of DMA_CH APP instance DMA_CH_G3 */
	 init_status = (DAVE_STATUS_t)DMA_CH_Init(&DMA_CH_G3); 
 80280ba:	4849      	ldr	r0, [pc, #292]	; (80281e0 <DAVE_Init+0x204>)
 80280bc:	f7fe fb1e 	bl	80266fc <DMA_CH_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 80280c0:	2800      	cmp	r0, #0
 80280c2:	d190      	bne.n	8027fe6 <DAVE_Init+0xa>
  {
	 /**  Initialization of DMA_CH APP instance DMA_CH_G2 */
	 init_status = (DAVE_STATUS_t)DMA_CH_Init(&DMA_CH_G2); 
 80280c4:	4847      	ldr	r0, [pc, #284]	; (80281e4 <DAVE_Init+0x208>)
 80280c6:	f7fe fb19 	bl	80266fc <DMA_CH_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 80280ca:	2800      	cmp	r0, #0
 80280cc:	d18b      	bne.n	8027fe6 <DAVE_Init+0xa>
  {
	 /**  Initialization of I2C_MASTER APP instance I2C_MASTER_EEPROM */
	 init_status = (DAVE_STATUS_t)I2C_MASTER_Init(&I2C_MASTER_EEPROM); 
 80280ce:	4846      	ldr	r0, [pc, #280]	; (80281e8 <DAVE_Init+0x20c>)
 80280d0:	f000 fe7c 	bl	8028dcc <I2C_MASTER_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 80280d4:	2800      	cmp	r0, #0
 80280d6:	d186      	bne.n	8027fe6 <DAVE_Init+0xa>
  {
	 /**  Initialization of TIMER APP instance EEPROM_TIMER_DELAY */
	 init_status = (DAVE_STATUS_t)TIMER_Init(&EEPROM_TIMER_DELAY); 
 80280d8:	4844      	ldr	r0, [pc, #272]	; (80281ec <DAVE_Init+0x210>)
 80280da:	f7fd fe85 	bl	8025de8 <TIMER_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 80280de:	2800      	cmp	r0, #0
 80280e0:	d181      	bne.n	8027fe6 <DAVE_Init+0xa>
  {
	 /**  Initialization of DIGITAL_IO APP instance DIGITAL_IO_ARD_D4 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_ARD_D4); 
 80280e2:	4843      	ldr	r0, [pc, #268]	; (80281f0 <DAVE_Init+0x214>)
 80280e4:	f7fe fb9e 	bl	8026824 <DIGITAL_IO_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 80280e8:	2800      	cmp	r0, #0
 80280ea:	f47f af7c 	bne.w	8027fe6 <DAVE_Init+0xa>
  {
	 /**  Initialization of DIGITAL_IO APP instance DIGITAL_IO_ARD_D7 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_ARD_D7); 
 80280ee:	4841      	ldr	r0, [pc, #260]	; (80281f4 <DAVE_Init+0x218>)
 80280f0:	f7fe fb98 	bl	8026824 <DIGITAL_IO_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 80280f4:	2800      	cmp	r0, #0
 80280f6:	f47f af76 	bne.w	8027fe6 <DAVE_Init+0xa>
  {
	 /**  Initialization of DIGITAL_IO APP instance DIGITAL_IO_ARD_D6 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_ARD_D6); 
 80280fa:	483f      	ldr	r0, [pc, #252]	; (80281f8 <DAVE_Init+0x21c>)
 80280fc:	f7fe fb92 	bl	8026824 <DIGITAL_IO_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8028100:	2800      	cmp	r0, #0
 8028102:	f47f af70 	bne.w	8027fe6 <DAVE_Init+0xa>
  {
	 /**  Initialization of CRC_SW APP instance CRC_SW_EEPROM */
	 init_status = (DAVE_STATUS_t)CRC_SW_Init(&CRC_SW_EEPROM); 
 8028106:	483d      	ldr	r0, [pc, #244]	; (80281fc <DAVE_Init+0x220>)
 8028108:	f7fe fb9a 	bl	8026840 <CRC_SW_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802810c:	2800      	cmp	r0, #0
 802810e:	f47f af6a 	bne.w	8027fe6 <DAVE_Init+0xa>
  {
	 /**  Initialization of DIGITAL_IO APP instance DIGITAL_IO_V_PTAT_SH_EN */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_V_PTAT_SH_EN); 
 8028112:	483b      	ldr	r0, [pc, #236]	; (8028200 <DAVE_Init+0x224>)
 8028114:	f7fe fb86 	bl	8026824 <DIGITAL_IO_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8028118:	2800      	cmp	r0, #0
 802811a:	f47f af64 	bne.w	8027fe6 <DAVE_Init+0xa>
  {
	 /**  Initialization of TIMER APP instance TIMER_PTAT_S_H_DELAY */
	 init_status = (DAVE_STATUS_t)TIMER_Init(&TIMER_PTAT_S_H_DELAY); 
 802811e:	4839      	ldr	r0, [pc, #228]	; (8028204 <DAVE_Init+0x228>)
 8028120:	f7fd fe62 	bl	8025de8 <TIMER_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8028124:	2800      	cmp	r0, #0
 8028126:	f47f af5e 	bne.w	8027fe6 <DAVE_Init+0xa>
  {
	 /**  Initialization of INTERRUPT APP instance INTERRUPT_PTAT_S_H_DELAY */
	 init_status = (DAVE_STATUS_t)INTERRUPT_Init(&INTERRUPT_PTAT_S_H_DELAY); 
 802812a:	4837      	ldr	r0, [pc, #220]	; (8028208 <DAVE_Init+0x22c>)
 802812c:	f7fe f9e4 	bl	80264f8 <INTERRUPT_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8028130:	2800      	cmp	r0, #0
 8028132:	f47f af58 	bne.w	8027fe6 <DAVE_Init+0xa>
  {
	 /**  Initialization of INTERRUPT APP instance INTERRUPT_BGT_VCC_ON */
	 init_status = (DAVE_STATUS_t)INTERRUPT_Init(&INTERRUPT_BGT_VCC_ON); 
 8028136:	4835      	ldr	r0, [pc, #212]	; (802820c <DAVE_Init+0x230>)
 8028138:	f7fe f9de 	bl	80264f8 <INTERRUPT_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802813c:	2800      	cmp	r0, #0
 802813e:	f47f af52 	bne.w	8027fe6 <DAVE_Init+0xa>
  {
	 /**  Initialization of DIGITAL_IO APP instance DIGITAL_IO_BB1_EN */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_BB1_EN); 
 8028142:	4833      	ldr	r0, [pc, #204]	; (8028210 <DAVE_Init+0x234>)
 8028144:	f7fe fb6e 	bl	8026824 <DIGITAL_IO_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8028148:	2800      	cmp	r0, #0
 802814a:	f47f af4c 	bne.w	8027fe6 <DAVE_Init+0xa>
  {
	 /**  Initialization of DIGITAL_IO APP instance DIGITAL_IO_BB2_EN */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_BB2_EN); 
 802814e:	4831      	ldr	r0, [pc, #196]	; (8028214 <DAVE_Init+0x238>)
 8028150:	f7fe fb68 	bl	8026824 <DIGITAL_IO_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8028154:	2800      	cmp	r0, #0
 8028156:	f47f af46 	bne.w	8027fe6 <DAVE_Init+0xa>
  {
	 /**  Initialization of INTERRUPT APP instance INTERRUPT_BB_PRE_TRIGGER */
	 init_status = (DAVE_STATUS_t)INTERRUPT_Init(&INTERRUPT_BB_PRE_TRIGGER); 
 802815a:	482f      	ldr	r0, [pc, #188]	; (8028218 <DAVE_Init+0x23c>)
 802815c:	f7fe f9cc 	bl	80264f8 <INTERRUPT_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8028160:	2800      	cmp	r0, #0
 8028162:	f47f af40 	bne.w	8027fe6 <DAVE_Init+0xa>
  {
	 /**  Initialization of TIMER APP instance TIMER_BB_PRE_TRIGGER */
	 init_status = (DAVE_STATUS_t)TIMER_Init(&TIMER_BB_PRE_TRIGGER); 
 8028166:	482d      	ldr	r0, [pc, #180]	; (802821c <DAVE_Init+0x240>)
 8028168:	f7fd fe3e 	bl	8025de8 <TIMER_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802816c:	2800      	cmp	r0, #0
 802816e:	f47f af3a 	bne.w	8027fe6 <DAVE_Init+0xa>
  {
	 /**  Initialization of INTERRUPT APP instance INTERRUPT_ERROR_TOGGLE */
	 init_status = (DAVE_STATUS_t)INTERRUPT_Init(&INTERRUPT_ERROR_TOGGLE); 
 8028172:	482b      	ldr	r0, [pc, #172]	; (8028220 <DAVE_Init+0x244>)
 8028174:	f7fe f9c0 	bl	80264f8 <INTERRUPT_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8028178:	2800      	cmp	r0, #0
 802817a:	f47f af34 	bne.w	8027fe6 <DAVE_Init+0xa>
  {
	 /**  Initialization of TIMER APP instance TIMER_ERROR_TOGGLE */
	 init_status = (DAVE_STATUS_t)TIMER_Init(&TIMER_ERROR_TOGGLE); 
 802817e:	4829      	ldr	r0, [pc, #164]	; (8028224 <DAVE_Init+0x248>)
   }  
  return init_status;
} /**  End of function DAVE_Init */
 8028180:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	 init_status = (DAVE_STATUS_t)INTERRUPT_Init(&INTERRUPT_ERROR_TOGGLE); 
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
  {
	 /**  Initialization of TIMER APP instance TIMER_ERROR_TOGGLE */
	 init_status = (DAVE_STATUS_t)TIMER_Init(&TIMER_ERROR_TOGGLE); 
 8028184:	f7fd be30 	b.w	8025de8 <TIMER_Init>
 8028188:	1ffeb44c 	.word	0x1ffeb44c
 802818c:	0802fdf4 	.word	0x0802fdf4
 8028190:	0802dd20 	.word	0x0802dd20
 8028194:	1ffe9210 	.word	0x1ffe9210
 8028198:	1ffeb408 	.word	0x1ffeb408
 802819c:	1ffe9318 	.word	0x1ffe9318
 80281a0:	0802fe10 	.word	0x0802fe10
 80281a4:	1ffe93d0 	.word	0x1ffe93d0
 80281a8:	1ffe93e0 	.word	0x1ffe93e0
 80281ac:	0802fcf4 	.word	0x0802fcf4
 80281b0:	0802ddbc 	.word	0x0802ddbc
 80281b4:	1ffe9238 	.word	0x1ffe9238
 80281b8:	1ffe926c 	.word	0x1ffe926c
 80281bc:	1ffe92a0 	.word	0x1ffe92a0
 80281c0:	1ffe92d4 	.word	0x1ffe92d4
 80281c4:	0802de20 	.word	0x0802de20
 80281c8:	0802de34 	.word	0x0802de34
 80281cc:	0802de0c 	.word	0x0802de0c
 80281d0:	1ffe9130 	.word	0x1ffe9130
 80281d4:	0802dd1c 	.word	0x0802dd1c
 80281d8:	0802fe2c 	.word	0x0802fe2c
 80281dc:	0802fe48 	.word	0x0802fe48
 80281e0:	1ffe9400 	.word	0x1ffe9400
 80281e4:	1ffe93f0 	.word	0x1ffe93f0
 80281e8:	1ffe9600 	.word	0x1ffe9600
 80281ec:	1ffe9198 	.word	0x1ffe9198
 80281f0:	0802ddd0 	.word	0x0802ddd0
 80281f4:	0802ddf8 	.word	0x0802ddf8
 80281f8:	0802dde4 	.word	0x0802dde4
 80281fc:	1ffe9494 	.word	0x1ffe9494
 8028200:	0802de48 	.word	0x0802de48
 8028204:	1ffe91c0 	.word	0x1ffe91c0
 8028208:	0802dd24 	.word	0x0802dd24
 802820c:	0802dd28 	.word	0x0802dd28
 8028210:	0802dd94 	.word	0x0802dd94
 8028214:	0802dda8 	.word	0x0802dda8
 8028218:	0802dd18 	.word	0x0802dd18
 802821c:	1ffe9168 	.word	0x1ffe9168
 8028220:	0802dd14 	.word	0x0802dd14
 8028224:	1ffe91e8 	.word	0x1ffe91e8

08028228 <fft_window_gen>:
==============================================================================
 */

/*-------------------------- fft_init() ------------------------------------*/
uint8_t fft_window_gen(FFT_Window_Struct_t *fft_window)
{
 8028228:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802822c:	ed2d 8b08 	vpush	{d8-d11}
  if ((fft_window->fft_window_buffer == NULL) ||
 8028230:	f8d0 a00c 	ldr.w	sl, [r0, #12]
==============================================================================
 */

/*-------------------------- fft_init() ------------------------------------*/
uint8_t fft_window_gen(FFT_Window_Struct_t *fft_window)
{
 8028234:	b087      	sub	sp, #28
  if ((fft_window->fft_window_buffer == NULL) ||
 8028236:	f1ba 0f00 	cmp.w	sl, #0
 802823a:	d01b      	beq.n	8028274 <fft_window_gen+0x4c>
	   (fft_window->fft_window_length == 0) ||
 802823c:	f8d0 9004 	ldr.w	r9, [r0, #4]
 */

/*-------------------------- fft_init() ------------------------------------*/
uint8_t fft_window_gen(FFT_Window_Struct_t *fft_window)
{
  if ((fft_window->fft_window_buffer == NULL) ||
 8028240:	f109 34ff 	add.w	r4, r9, #4294967295
 8028244:	2cff      	cmp	r4, #255	; 0xff
 8028246:	d815      	bhi.n	8028274 <fft_window_gen+0x4c>
	   (fft_window->fft_window_length > MAX_FFT_WIN_LEN))
  {
    return 0;
  }

  switch (fft_window->fft_size)
 8028248:	8843      	ldrh	r3, [r0, #2]
 802824a:	2b40      	cmp	r3, #64	; 0x40
 802824c:	d020      	beq.n	8028290 <fft_window_gen+0x68>
 802824e:	d817      	bhi.n	8028280 <fft_window_gen+0x58>
 8028250:	2b10      	cmp	r3, #16
 8028252:	d020      	beq.n	8028296 <fft_window_gen+0x6e>
 8028254:	2b20      	cmp	r3, #32
 8028256:	d10d      	bne.n	8028274 <fft_window_gen+0x4c>
  case FFT_SIZE_16:
	  fft_window->fft_time_twiddle_table = &arm_cfft_sR_f32_len16;		/* as FFT_SIZE = 16 points */
	  break;

  case FFT_SIZE_32:
	  fft_window->fft_time_twiddle_table = &arm_cfft_sR_f32_len32;		/* as FFT_SIZE = 32 points */
 8028258:	4bb1      	ldr	r3, [pc, #708]	; (8028520 <fft_window_gen+0x2f8>)
 802825a:	6103      	str	r3, [r0, #16]
  if ((window_buffer == NULL) || (window_size == 0) || (window_size > MAX_FFT_WIN_LEN))
  {
    return 0;
  }

  switch (window_type)
 802825c:	7803      	ldrb	r3, [r0, #0]
  default:
	  return 0;
	  break;
  }

  return(fft_window_init(fft_window->fft_window_type,fft_window->fft_window_length,
 802825e:	edd0 7a02 	vldr	s15, [r0, #8]
  if ((window_buffer == NULL) || (window_size == 0) || (window_size > MAX_FFT_WIN_LEN))
  {
    return 0;
  }

  switch (window_type)
 8028262:	3b01      	subs	r3, #1
 8028264:	2b03      	cmp	r3, #3
 8028266:	d805      	bhi.n	8028274 <fft_window_gen+0x4c>
 8028268:	e8df f013 	tbh	[pc, r3, lsl #1]
 802826c:	00e7011d 	.word	0x00e7011d
 8028270:	001b0172 	.word	0x001b0172
  case FFT_WINDOW_CHEBYSHEV:
	  return fft_window_init_chebyshev(window_size, window_buffer, at_dB);
	  break;

  default:
	  return 0;
 8028274:	2000      	movs	r0, #0
	  break;
  }

  return(fft_window_init(fft_window->fft_window_type,fft_window->fft_window_length,
		 fft_window->fft_chebyshev_at_dB, fft_window->fft_window_buffer));
}
 8028276:	b007      	add	sp, #28
 8028278:	ecbd 8b08 	vpop	{d8-d11}
 802827c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	   (fft_window->fft_window_length > MAX_FFT_WIN_LEN))
  {
    return 0;
  }

  switch (fft_window->fft_size)
 8028280:	2b80      	cmp	r3, #128	; 0x80
 8028282:	d00b      	beq.n	802829c <fft_window_gen+0x74>
 8028284:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8028288:	d1f4      	bne.n	8028274 <fft_window_gen+0x4c>
  case FFT_SIZE_128:
	  fft_window->fft_time_twiddle_table  = &arm_cfft_sR_f32_len128;	/* as FFT_SIZE = 128 points */
	  break;

  case FFT_SIZE_256:
	  fft_window->fft_time_twiddle_table  = &arm_cfft_sR_f32_len256;	/* as FFT_SIZE = 256 points */
 802828a:	4ba6      	ldr	r3, [pc, #664]	; (8028524 <fft_window_gen+0x2fc>)
 802828c:	6103      	str	r3, [r0, #16]
	  break;
 802828e:	e7e5      	b.n	802825c <fft_window_gen+0x34>
  case FFT_SIZE_32:
	  fft_window->fft_time_twiddle_table = &arm_cfft_sR_f32_len32;		/* as FFT_SIZE = 32 points */
	  break;

  case FFT_SIZE_64:
	  fft_window->fft_time_twiddle_table  = &arm_cfft_sR_f32_len64;		/* as FFT_SIZE = 64 points */
 8028290:	4ba5      	ldr	r3, [pc, #660]	; (8028528 <fft_window_gen+0x300>)
 8028292:	6103      	str	r3, [r0, #16]
	  break;
 8028294:	e7e2      	b.n	802825c <fft_window_gen+0x34>
  }

  switch (fft_window->fft_size)
  {
  case FFT_SIZE_16:
	  fft_window->fft_time_twiddle_table = &arm_cfft_sR_f32_len16;		/* as FFT_SIZE = 16 points */
 8028296:	4ba5      	ldr	r3, [pc, #660]	; (802852c <fft_window_gen+0x304>)
 8028298:	6103      	str	r3, [r0, #16]
	  break;
 802829a:	e7df      	b.n	802825c <fft_window_gen+0x34>
  case FFT_SIZE_64:
	  fft_window->fft_time_twiddle_table  = &arm_cfft_sR_f32_len64;		/* as FFT_SIZE = 64 points */
	  break;

  case FFT_SIZE_128:
	  fft_window->fft_time_twiddle_table  = &arm_cfft_sR_f32_len128;	/* as FFT_SIZE = 128 points */
 802829c:	4ba4      	ldr	r3, [pc, #656]	; (8028530 <fft_window_gen+0x308>)
 802829e:	6103      	str	r3, [r0, #16]
	  break;
 80282a0:	e7dc      	b.n	802825c <fft_window_gen+0x34>
}

/*-------------------- fft_window_init_chebyshev() -----------------------*/
static uint8_t fft_window_init_chebyshev(uint32_t window_size, float *window_buffer, float at_dB)
{
  if (window_size == 1)
 80282a2:	f1b9 0f01 	cmp.w	r9, #1
 80282a6:	f000 81dc 	beq.w	8028662 <fft_window_gen+0x43a>
  {
	window_buffer[0] = 1;
  }
  else
  {
    float pssbnd_ripple = powf(10.0f, at_dB / 20.0f);
 80282aa:	eeb3 7a04 	vmov.f32	s14, #52	; 0x34
 80282ae:	eec7 7a87 	vdiv.f32	s15, s15, s14
 80282b2:	48a0      	ldr	r0, [pc, #640]	; (8028534 <fft_window_gen+0x30c>)
    {
      win_even = win_even + 0.5f;
    }

    float max_val = 0;
    for (uint32_t j = 0; j < (window_size / 2 + 1); ++j)
 80282b4:	ed9f baa0 	vldr	s22, [pc, #640]	; 8028538 <fft_window_gen+0x310>
  {
	window_buffer[0] = 1;
  }
  else
  {
    float pssbnd_ripple = powf(10.0f, at_dB / 20.0f);
 80282b8:	ee17 1a90 	vmov	r1, s15
 80282bc:	f002 fca8 	bl	802ac10 <powf>
    float alpha = coshf((1.0f / (float)(window_size - 1)) * acoshf(pssbnd_ripple));
 80282c0:	ee07 4a90 	vmov	s15, r4
 80282c4:	eeb8 aae7 	vcvt.f32.s32	s20, s15
  {
	window_buffer[0] = 1;
  }
  else
  {
    float pssbnd_ripple = powf(10.0f, at_dB / 20.0f);
 80282c8:	ee0b 0a90 	vmov	s23, r0
    float alpha = coshf((1.0f / (float)(window_size - 1)) * acoshf(pssbnd_ripple));
 80282cc:	f002 fbf0 	bl	802aab0 <acoshf>
 80282d0:	eef7 7a00 	vmov.f32	s15, #112	; 0x70
 80282d4:	eec7 7a8a 	vdiv.f32	s15, s15, s20
    float win_even = (float)((window_size - 1) / 2);
 80282d8:	0864      	lsrs	r4, r4, #1
	window_buffer[0] = 1;
  }
  else
  {
    float pssbnd_ripple = powf(10.0f, at_dB / 20.0f);
    float alpha = coshf((1.0f / (float)(window_size - 1)) * acoshf(pssbnd_ripple));
 80282da:	ee07 0a10 	vmov	s14, r0
 80282de:	ee67 7a87 	vmul.f32	s15, s15, s14
    for (uint32_t j = 0; j < (window_size / 2 + 1); ++j)
    {
      float n = j - win_even;
      float sum = 0;

      for (uint32_t i = 1; i <= win_even; ++i)
 80282e2:	eef7 9a00 	vmov.f32	s19, #112	; 0x70
	window_buffer[0] = 1;
  }
  else
  {
    float pssbnd_ripple = powf(10.0f, at_dB / 20.0f);
    float alpha = coshf((1.0f / (float)(window_size - 1)) * acoshf(pssbnd_ripple));
 80282e6:	ee17 0a90 	vmov	r0, s15
 80282ea:	f002 fc39 	bl	802ab60 <coshf>
    float win_even = (float)((window_size - 1) / 2);
 80282ee:	ee07 4a90 	vmov	s15, r4
    {
      win_even = win_even + 0.5f;
    }

    float max_val = 0;
    for (uint32_t j = 0; j < (window_size / 2 + 1); ++j)
 80282f2:	ea4f 0359 	mov.w	r3, r9, lsr #1
  {
    float pssbnd_ripple = powf(10.0f, at_dB / 20.0f);
    float alpha = coshf((1.0f / (float)(window_size - 1)) * acoshf(pssbnd_ripple));
    float win_even = (float)((window_size - 1) / 2);

    if (window_size % 2 == 0)
 80282f6:	f019 0f01 	tst.w	r9, #1
 80282fa:	ea4f 0289 	mov.w	r2, r9, lsl #2
  }
  else
  {
    float pssbnd_ripple = powf(10.0f, at_dB / 20.0f);
    float alpha = coshf((1.0f / (float)(window_size - 1)) * acoshf(pssbnd_ripple));
    float win_even = (float)((window_size - 1) / 2);
 80282fe:	eeb8 8ae7 	vcvt.f32.s32	s16, s15
    {
      win_even = win_even + 0.5f;
    }

    float max_val = 0;
    for (uint32_t j = 0; j < (window_size / 2 + 1); ++j)
 8028302:	f103 0301 	add.w	r3, r3, #1
    float alpha = coshf((1.0f / (float)(window_size - 1)) * acoshf(pssbnd_ripple));
    float win_even = (float)((window_size - 1) / 2);

    if (window_size % 2 == 0)
    {
      win_even = win_even + 0.5f;
 8028306:	bf08      	it	eq
 8028308:	eef6 7a00 	vmoveq.f32	s15, #96	; 0x60
    }

    float max_val = 0;
    for (uint32_t j = 0; j < (window_size / 2 + 1); ++j)
 802830c:	9302      	str	r3, [sp, #8]
 802830e:	eb0a 0302 	add.w	r3, sl, r2
 8028312:	9300      	str	r3, [sp, #0]
	window_buffer[0] = 1;
  }
  else
  {
    float pssbnd_ripple = powf(10.0f, at_dB / 20.0f);
    float alpha = coshf((1.0f / (float)(window_size - 1)) * acoshf(pssbnd_ripple));
 8028314:	ee0a 0a90 	vmov	s21, r0
    {
      win_even = win_even + 0.5f;
    }

    float max_val = 0;
    for (uint32_t j = 0; j < (window_size / 2 + 1); ++j)
 8028318:	f04f 0300 	mov.w	r3, #0
    float alpha = coshf((1.0f / (float)(window_size - 1)) * acoshf(pssbnd_ripple));
    float win_even = (float)((window_size - 1) / 2);

    if (window_size % 2 == 0)
    {
      win_even = win_even + 0.5f;
 802831c:	bf08      	it	eq
 802831e:	ee38 8a27 	vaddeq.f32	s16, s16, s15
    for (uint32_t j = 0; j < (window_size / 2 + 1); ++j)
    {
      float n = j - win_even;
      float sum = 0;

      for (uint32_t i = 1; i <= win_even; ++i)
 8028322:	f8cd 900c 	str.w	r9, [sp, #12]
 8028326:	9204      	str	r2, [sp, #16]
 8028328:	f8cd a014 	str.w	sl, [sp, #20]
 802832c:	4699      	mov	r9, r3
 802832e:	f8cd a004 	str.w	sl, [sp, #4]
    }

    float max_val = 0;
    for (uint32_t j = 0; j < (window_size / 2 + 1); ++j)
    {
      float n = j - win_even;
 8028332:	ee07 9a90 	vmov	s15, r9
      float sum = 0;

      for (uint32_t i = 1; i <= win_even; ++i)
 8028336:	eeb4 8ae9 	vcmpe.f32	s16, s19
    }

    float max_val = 0;
    for (uint32_t j = 0; j < (window_size / 2 + 1); ++j)
    {
      float n = j - win_even;
 802833a:	eeb8 9ae7 	vcvt.f32.s32	s18, s15
      float sum = 0;

      for (uint32_t i = 1; i <= win_even; ++i)
 802833e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    }

    float max_val = 0;
    for (uint32_t j = 0; j < (window_size / 2 + 1); ++j)
    {
      float n = j - win_even;
 8028342:	ee39 9a48 	vsub.f32	s18, s18, s16
      float sum = 0;

      for (uint32_t i = 1; i <= win_even; ++i)
 8028346:	f2c0 8192 	blt.w	802866e <fft_window_gen+0x446>
 802834a:	9c03      	ldr	r4, [sp, #12]
 802834c:	eddf 8a7a 	vldr	s17, [pc, #488]	; 8028538 <fft_window_gen+0x310>
 8028350:	4620      	mov	r0, r4
 8028352:	f004 fa93 	bl	802c87c <__aeabi_ui2d>
 8028356:	ee79 7a09 	vadd.f32	s15, s18, s18
 802835a:	4682      	mov	sl, r0
 802835c:	ee17 5a90 	vmov	r5, s15
 8028360:	ee07 4a90 	vmov	s15, r4
 8028364:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8028368:	468b      	mov	fp, r1
 802836a:	ee17 8a90 	vmov	r8, s15
 802836e:	2401      	movs	r4, #1
 8028370:	e037      	b.n	80283e2 <fft_window_gen+0x1ba>
  {
    ret = arm_cos_f32( size * acosf(poly_order));
  }
  else
  {
   	  ret = coshf( size * acoshf(poly_order)); 
 8028372:	f002 fb9d 	bl	802aab0 <acoshf>
 8028376:	ee07 0a90 	vmov	s15, r0
 802837a:	ee6a 7a27 	vmul.f32	s15, s20, s15
 802837e:	ee17 0a90 	vmov	r0, s15
 8028382:	f002 fbed 	bl	802ab60 <coshf>
 8028386:	ee09 0a10 	vmov	s18, r0

      for (uint32_t i = 1; i <= win_even; ++i)
      {
       	float poly_order = alpha * arm_cos_f32( (M_PI * i) / window_size);
       	float res = cheby_poly( window_size - 1, poly_order);
        sum += res * arm_cos_f32( 2.0f * n * M_PI * i / (float)window_size );
 802838a:	4628      	mov	r0, r5
 802838c:	f004 fa98 	bl	802c8c0 <__aeabi_f2d>
 8028390:	a35f      	add	r3, pc, #380	; (adr r3, 8028510 <fft_window_gen+0x2e8>)
 8028392:	e9d3 2300 	ldrd	r2, r3, [r3]
 8028396:	f004 fae7 	bl	802c968 <__aeabi_dmul>
 802839a:	4602      	mov	r2, r0
 802839c:	460b      	mov	r3, r1
 802839e:	4630      	mov	r0, r6
 80283a0:	4639      	mov	r1, r7
 80283a2:	f004 fae1 	bl	802c968 <__aeabi_dmul>
 80283a6:	4606      	mov	r6, r0
 80283a8:	4640      	mov	r0, r8
 80283aa:	460f      	mov	r7, r1
 80283ac:	f004 fa88 	bl	802c8c0 <__aeabi_f2d>
 80283b0:	4602      	mov	r2, r0
 80283b2:	460b      	mov	r3, r1
 80283b4:	4630      	mov	r0, r6
 80283b6:	4639      	mov	r1, r7
 80283b8:	f004 fc00 	bl	802cbbc <__aeabi_ddiv>
 80283bc:	f004 fd8e 	bl	802cedc <__aeabi_d2f>
    for (uint32_t j = 0; j < (window_size / 2 + 1); ++j)
    {
      float n = j - win_even;
      float sum = 0;

      for (uint32_t i = 1; i <= win_even; ++i)
 80283c0:	3401      	adds	r4, #1
      {
       	float poly_order = alpha * arm_cos_f32( (M_PI * i) / window_size);
       	float res = cheby_poly( window_size - 1, poly_order);
        sum += res * arm_cos_f32( 2.0f * n * M_PI * i / (float)window_size );
 80283c2:	f7ff fa3b 	bl	802783c <arm_cos_f32>
    for (uint32_t j = 0; j < (window_size / 2 + 1); ++j)
    {
      float n = j - win_even;
      float sum = 0;

      for (uint32_t i = 1; i <= win_even; ++i)
 80283c6:	ee07 4a90 	vmov	s15, r4
 80283ca:	eef8 7a67 	vcvt.f32.u32	s15, s15
      {
       	float poly_order = alpha * arm_cos_f32( (M_PI * i) / window_size);
       	float res = cheby_poly( window_size - 1, poly_order);
        sum += res * arm_cos_f32( 2.0f * n * M_PI * i / (float)window_size );
 80283ce:	ee07 0a10 	vmov	s14, r0
    for (uint32_t j = 0; j < (window_size / 2 + 1); ++j)
    {
      float n = j - win_even;
      float sum = 0;

      for (uint32_t i = 1; i <= win_even; ++i)
 80283d2:	eeb4 8ae7 	vcmpe.f32	s16, s15
 80283d6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
      {
       	float poly_order = alpha * arm_cos_f32( (M_PI * i) / window_size);
       	float res = cheby_poly( window_size - 1, poly_order);
        sum += res * arm_cos_f32( 2.0f * n * M_PI * i / (float)window_size );
 80283da:	eee7 8a09 	vfma.f32	s17, s14, s18
    for (uint32_t j = 0; j < (window_size / 2 + 1); ++j)
    {
      float n = j - win_even;
      float sum = 0;

      for (uint32_t i = 1; i <= win_even; ++i)
 80283de:	f2c0 8116 	blt.w	802860e <fft_window_gen+0x3e6>
      {
       	float poly_order = alpha * arm_cos_f32( (M_PI * i) / window_size);
 80283e2:	4620      	mov	r0, r4
 80283e4:	f004 fa4a 	bl	802c87c <__aeabi_ui2d>
 80283e8:	a349      	add	r3, pc, #292	; (adr r3, 8028510 <fft_window_gen+0x2e8>)
 80283ea:	e9d3 2300 	ldrd	r2, r3, [r3]
 80283ee:	4606      	mov	r6, r0
 80283f0:	460f      	mov	r7, r1
 80283f2:	f004 fab9 	bl	802c968 <__aeabi_dmul>
 80283f6:	4652      	mov	r2, sl
 80283f8:	465b      	mov	r3, fp
 80283fa:	f004 fbdf 	bl	802cbbc <__aeabi_ddiv>
 80283fe:	f004 fd6d 	bl	802cedc <__aeabi_d2f>
 8028402:	f7ff fa1b 	bl	802783c <arm_cos_f32>
 8028406:	ee07 0a90 	vmov	s15, r0
 802840a:	ee6a 7aa7 	vmul.f32	s15, s21, s15
/*----------------------------- cheby_poly() -----------------------------*/
static float cheby_poly(const uint32_t size, const float poly_order)
{
  float ret = 0;

  if (fabsf(poly_order) <= 1)
 802840e:	eeb0 7ae7 	vabs.f32	s14, s15
 8028412:	eeb4 7ae9 	vcmpe.f32	s14, s19
 8028416:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  {
    ret = arm_cos_f32( size * acosf(poly_order));
  }
  else
  {
   	  ret = coshf( size * acoshf(poly_order)); 
 802841a:	ee17 0a90 	vmov	r0, s15
/*----------------------------- cheby_poly() -----------------------------*/
static float cheby_poly(const uint32_t size, const float poly_order)
{
  float ret = 0;

  if (fabsf(poly_order) <= 1)
 802841e:	d8a8      	bhi.n	8028372 <fft_window_gen+0x14a>
  {
    ret = arm_cos_f32( size * acosf(poly_order));
 8028420:	f002 faf4 	bl	802aa0c <acosf>
 8028424:	ee07 0a90 	vmov	s15, r0
 8028428:	ee6a 7a27 	vmul.f32	s15, s20, s15
 802842c:	ee17 0a90 	vmov	r0, s15
 8028430:	f7ff fa04 	bl	802783c <arm_cos_f32>
 8028434:	ee09 0a10 	vmov	s18, r0
 8028438:	e7a7      	b.n	802838a <fft_window_gen+0x162>
}

/*----------------------- fft_window_init_hanning() ----------------------*/
static uint8_t fft_window_init_hanning(uint32_t window_size, float *window_buffer)
{
  if (window_size == 1)
 802843a:	f1b9 0f01 	cmp.w	r9, #1
 802843e:	f000 8110 	beq.w	8028662 <fft_window_gen+0x43a>
 8028442:	ee07 4a90 	vmov	s15, r4
 8028446:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 802844a:	4655      	mov	r5, sl
 802844c:	ee17 0a90 	vmov	r0, s15
 8028450:	f004 fa36 	bl	802c8c0 <__aeabi_f2d>
 8028454:	2400      	movs	r4, #0
 8028456:	4606      	mov	r6, r0
 8028458:	460f      	mov	r7, r1
  }
  else
  {
    for (uint32_t i = 0; i < window_size; ++i)
    {
      window_buffer[i] = 0.5f * (1.0f - arm_cos_f32(2 * M_PI * (float)i / (float)(window_size - 1)));
 802845a:	eef7 8a00 	vmov.f32	s17, #112	; 0x70
 802845e:	eeb6 8a00 	vmov.f32	s16, #96	; 0x60
 8028462:	ee07 4a90 	vmov	s15, r4
 8028466:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  {
	window_buffer[0] = 1;
  }
  else
  {
    for (uint32_t i = 0; i < window_size; ++i)
 802846a:	3401      	adds	r4, #1
    {
      window_buffer[i] = 0.5f * (1.0f - arm_cos_f32(2 * M_PI * (float)i / (float)(window_size - 1)));
 802846c:	ee17 0a90 	vmov	r0, s15
 8028470:	f004 fa26 	bl	802c8c0 <__aeabi_f2d>
 8028474:	a328      	add	r3, pc, #160	; (adr r3, 8028518 <fft_window_gen+0x2f0>)
 8028476:	e9d3 2300 	ldrd	r2, r3, [r3]
 802847a:	f004 fa75 	bl	802c968 <__aeabi_dmul>
 802847e:	4632      	mov	r2, r6
 8028480:	463b      	mov	r3, r7
 8028482:	f004 fb9b 	bl	802cbbc <__aeabi_ddiv>
 8028486:	f004 fd29 	bl	802cedc <__aeabi_d2f>
 802848a:	f7ff f9d7 	bl	802783c <arm_cos_f32>
 802848e:	ee07 0a90 	vmov	s15, r0
 8028492:	ee78 7ae7 	vsub.f32	s15, s17, s15
  {
	window_buffer[0] = 1;
  }
  else
  {
    for (uint32_t i = 0; i < window_size; ++i)
 8028496:	454c      	cmp	r4, r9
    {
      window_buffer[i] = 0.5f * (1.0f - arm_cos_f32(2 * M_PI * (float)i / (float)(window_size - 1)));
 8028498:	ee67 7a88 	vmul.f32	s15, s15, s16
 802849c:	ece5 7a01 	vstmia	r5!, {s15}
  {
	window_buffer[0] = 1;
  }
  else
  {
    for (uint32_t i = 0; i < window_size; ++i)
 80284a0:	d1df      	bne.n	8028462 <fft_window_gen+0x23a>
  }

  switch (window_type)
  {
  case FFT_WINDOW_HAMM:
	  return fft_window_init_hamming(window_size, window_buffer);
 80284a2:	2001      	movs	r0, #1
 80284a4:	e6e7      	b.n	8028276 <fft_window_gen+0x4e>
 */

/*--------------------- fft_window_init_hamming() ------------------------*/
static uint8_t fft_window_init_hamming(uint32_t window_size, float *window_buffer)
{
  if (window_size == 1)
 80284a6:	f1b9 0f01 	cmp.w	r9, #1
 80284aa:	f000 80da 	beq.w	8028662 <fft_window_gen+0x43a>
 80284ae:	ee07 4a90 	vmov	s15, r4
 80284b2:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  }
  else
  {
    for (uint32_t i = 0; i < window_size; ++i)
    {
      window_buffer[i] = 0.54f - 0.46f * arm_cos_f32(2.0f * M_PI * (float)i / (float)(window_size - 1));
 80284b6:	eddf 8a21 	vldr	s17, [pc, #132]	; 802853c <fft_window_gen+0x314>
 80284ba:	ed9f 8a21 	vldr	s16, [pc, #132]	; 8028540 <fft_window_gen+0x318>
 80284be:	ee17 0a90 	vmov	r0, s15
 80284c2:	f004 f9fd 	bl	802c8c0 <__aeabi_f2d>
 80284c6:	4655      	mov	r5, sl
 80284c8:	4606      	mov	r6, r0
 80284ca:	460f      	mov	r7, r1
 */

/*--------------------- fft_window_init_hamming() ------------------------*/
static uint8_t fft_window_init_hamming(uint32_t window_size, float *window_buffer)
{
  if (window_size == 1)
 80284cc:	2400      	movs	r4, #0
  }
  else
  {
    for (uint32_t i = 0; i < window_size; ++i)
    {
      window_buffer[i] = 0.54f - 0.46f * arm_cos_f32(2.0f * M_PI * (float)i / (float)(window_size - 1));
 80284ce:	ee07 4a90 	vmov	s15, r4
 80284d2:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  {
	window_buffer[0] = 1;
  }
  else
  {
    for (uint32_t i = 0; i < window_size; ++i)
 80284d6:	3401      	adds	r4, #1
    {
      window_buffer[i] = 0.54f - 0.46f * arm_cos_f32(2.0f * M_PI * (float)i / (float)(window_size - 1));
 80284d8:	ee17 0a90 	vmov	r0, s15
 80284dc:	f004 f9f0 	bl	802c8c0 <__aeabi_f2d>
 80284e0:	a30d      	add	r3, pc, #52	; (adr r3, 8028518 <fft_window_gen+0x2f0>)
 80284e2:	e9d3 2300 	ldrd	r2, r3, [r3]
 80284e6:	f004 fa3f 	bl	802c968 <__aeabi_dmul>
 80284ea:	4632      	mov	r2, r6
 80284ec:	463b      	mov	r3, r7
 80284ee:	f004 fb65 	bl	802cbbc <__aeabi_ddiv>
 80284f2:	f004 fcf3 	bl	802cedc <__aeabi_d2f>
 80284f6:	f7ff f9a1 	bl	802783c <arm_cos_f32>
 80284fa:	ee07 0a10 	vmov	s14, r0
 80284fe:	eef0 7a48 	vmov.f32	s15, s16
 8028502:	eee7 7a68 	vfms.f32	s15, s14, s17
  {
	window_buffer[0] = 1;
  }
  else
  {
    for (uint32_t i = 0; i < window_size; ++i)
 8028506:	454c      	cmp	r4, r9
    {
      window_buffer[i] = 0.54f - 0.46f * arm_cos_f32(2.0f * M_PI * (float)i / (float)(window_size - 1));
 8028508:	ece5 7a01 	vstmia	r5!, {s15}
  {
	window_buffer[0] = 1;
  }
  else
  {
    for (uint32_t i = 0; i < window_size; ++i)
 802850c:	d1df      	bne.n	80284ce <fft_window_gen+0x2a6>
 802850e:	e7c8      	b.n	80284a2 <fft_window_gen+0x27a>
 8028510:	54442d18 	.word	0x54442d18
 8028514:	400921fb 	.word	0x400921fb
 8028518:	54442d18 	.word	0x54442d18
 802851c:	401921fb 	.word	0x401921fb
 8028520:	0802fc28 	.word	0x0802fc28
 8028524:	0802fc18 	.word	0x0802fc18
 8028528:	0802fbe8 	.word	0x0802fbe8
 802852c:	0802fc08 	.word	0x0802fc08
 8028530:	0802fbf8 	.word	0x0802fbf8
 8028534:	41200000 	.word	0x41200000
 8028538:	00000000 	.word	0x00000000
 802853c:	3eeb851f 	.word	0x3eeb851f
 8028540:	3f0a3d71 	.word	0x3f0a3d71
 8028544:	3efa0126 	.word	0x3efa0126
 8028548:	3eb7ae14 	.word	0x3eb7ae14
 802854c:	3e10abb4 	.word	0x3e10abb4
}

/*----------------- fft_window_init_blackmanharris() ---------------------*/
static uint8_t fft_window_init_blackmanharris(uint32_t window_size, float *window_buffer)
{
  if (window_size == 1)
 8028550:	f1b9 0f01 	cmp.w	r9, #1
 8028554:	f000 8085 	beq.w	8028662 <fft_window_gen+0x43a>
 8028558:	4620      	mov	r0, r4
 802855a:	f004 f98f 	bl	802c87c <__aeabi_ui2d>
    const float a3 = 0.01168f;

   for (uint32_t i = 0; i < window_size; ++i)
   {
	 window_buffer[i] = a0
                        - (a1 * arm_cos_f32( (2.0f * M_PI * (float)i) / (window_size - 1) ))
 802855e:	ed5f 9a07 	vldr	s19, [pc, #-28]	; 8028544 <fft_window_gen+0x31c>
 8028562:	ed1f 9a07 	vldr	s18, [pc, #-28]	; 8028548 <fft_window_gen+0x320>
                        + (a2 * arm_cos_f32( (4.0f * M_PI * (float)i) / (window_size - 1) ))
 8028566:	ed5f 8a07 	vldr	s17, [pc, #-28]	; 802854c <fft_window_gen+0x324>
 802856a:	4604      	mov	r4, r0
 802856c:	460d      	mov	r5, r1
}

/*----------------- fft_window_init_blackmanharris() ---------------------*/
static uint8_t fft_window_init_blackmanharris(uint32_t window_size, float *window_buffer)
{
  if (window_size == 1)
 802856e:	f04f 0800 	mov.w	r8, #0
    const float a3 = 0.01168f;

   for (uint32_t i = 0; i < window_size; ++i)
   {
	 window_buffer[i] = a0
                        - (a1 * arm_cos_f32( (2.0f * M_PI * (float)i) / (window_size - 1) ))
 8028572:	ee07 8a90 	vmov	s15, r8
 8028576:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    const float a0 = 0.35875f;
    const float a1 = 0.48829f;
    const float a2 = 0.14128f;
    const float a3 = 0.01168f;

   for (uint32_t i = 0; i < window_size; ++i)
 802857a:	f108 0801 	add.w	r8, r8, #1
   {
	 window_buffer[i] = a0
                        - (a1 * arm_cos_f32( (2.0f * M_PI * (float)i) / (window_size - 1) ))
 802857e:	ee17 0a90 	vmov	r0, s15
 8028582:	f004 f99d 	bl	802c8c0 <__aeabi_f2d>
 8028586:	a33e      	add	r3, pc, #248	; (adr r3, 8028680 <fft_window_gen+0x458>)
 8028588:	e9d3 2300 	ldrd	r2, r3, [r3]
 802858c:	4606      	mov	r6, r0
 802858e:	460f      	mov	r7, r1
 8028590:	f004 f9ea 	bl	802c968 <__aeabi_dmul>
 8028594:	4622      	mov	r2, r4
 8028596:	462b      	mov	r3, r5
 8028598:	f004 fb10 	bl	802cbbc <__aeabi_ddiv>
 802859c:	f004 fc9e 	bl	802cedc <__aeabi_d2f>
 80285a0:	f7ff f94c 	bl	802783c <arm_cos_f32>
                        + (a2 * arm_cos_f32( (4.0f * M_PI * (float)i) / (window_size - 1) ))
 80285a4:	a338      	add	r3, pc, #224	; (adr r3, 8028688 <fft_window_gen+0x460>)
 80285a6:	e9d3 2300 	ldrd	r2, r3, [r3]
    const float a3 = 0.01168f;

   for (uint32_t i = 0; i < window_size; ++i)
   {
	 window_buffer[i] = a0
                        - (a1 * arm_cos_f32( (2.0f * M_PI * (float)i) / (window_size - 1) ))
 80285aa:	ee08 0a10 	vmov	s16, r0
                        + (a2 * arm_cos_f32( (4.0f * M_PI * (float)i) / (window_size - 1) ))
 80285ae:	4639      	mov	r1, r7
 80285b0:	4630      	mov	r0, r6
 80285b2:	f004 f9d9 	bl	802c968 <__aeabi_dmul>
 80285b6:	4622      	mov	r2, r4
 80285b8:	462b      	mov	r3, r5
 80285ba:	f004 faff 	bl	802cbbc <__aeabi_ddiv>
 80285be:	f004 fc8d 	bl	802cedc <__aeabi_d2f>
 80285c2:	f7ff f93b 	bl	802783c <arm_cos_f32>
    const float a3 = 0.01168f;

   for (uint32_t i = 0; i < window_size; ++i)
   {
	 window_buffer[i] = a0
                        - (a1 * arm_cos_f32( (2.0f * M_PI * (float)i) / (window_size - 1) ))
 80285c6:	eef0 7a49 	vmov.f32	s15, s18
 80285ca:	eee8 7a69 	vfms.f32	s15, s16, s19
                        + (a2 * arm_cos_f32( (4.0f * M_PI * (float)i) / (window_size - 1) ))
                        - (a3 * arm_cos_f32( (6.0f * M_PI * (float)i) / (window_size - 1) ));
 80285ce:	a330      	add	r3, pc, #192	; (adr r3, 8028690 <fft_window_gen+0x468>)
 80285d0:	e9d3 2300 	ldrd	r2, r3, [r3]
    const float a3 = 0.01168f;

   for (uint32_t i = 0; i < window_size; ++i)
   {
	 window_buffer[i] = a0
                        - (a1 * arm_cos_f32( (2.0f * M_PI * (float)i) / (window_size - 1) ))
 80285d4:	eeb0 8a67 	vmov.f32	s16, s15
                        + (a2 * arm_cos_f32( (4.0f * M_PI * (float)i) / (window_size - 1) ))
 80285d8:	ee07 0a90 	vmov	s15, r0
                        - (a3 * arm_cos_f32( (6.0f * M_PI * (float)i) / (window_size - 1) ));
 80285dc:	4639      	mov	r1, r7
 80285de:	4630      	mov	r0, r6

   for (uint32_t i = 0; i < window_size; ++i)
   {
	 window_buffer[i] = a0
                        - (a1 * arm_cos_f32( (2.0f * M_PI * (float)i) / (window_size - 1) ))
                        + (a2 * arm_cos_f32( (4.0f * M_PI * (float)i) / (window_size - 1) ))
 80285e0:	eea7 8aa8 	vfma.f32	s16, s15, s17
                        - (a3 * arm_cos_f32( (6.0f * M_PI * (float)i) / (window_size - 1) ));
 80285e4:	f004 f9c0 	bl	802c968 <__aeabi_dmul>
 80285e8:	4622      	mov	r2, r4
 80285ea:	462b      	mov	r3, r5
 80285ec:	f004 fae6 	bl	802cbbc <__aeabi_ddiv>
 80285f0:	f004 fc74 	bl	802cedc <__aeabi_d2f>
 80285f4:	f7ff f922 	bl	802783c <arm_cos_f32>
 80285f8:	eddf 7a1f 	vldr	s15, [pc, #124]	; 8028678 <fft_window_gen+0x450>
 80285fc:	ee07 0a10 	vmov	s14, r0
 8028600:	eea7 8a67 	vfms.f32	s16, s14, s15
    const float a0 = 0.35875f;
    const float a1 = 0.48829f;
    const float a2 = 0.14128f;
    const float a3 = 0.01168f;

   for (uint32_t i = 0; i < window_size; ++i)
 8028604:	45c8      	cmp	r8, r9
   {
	 window_buffer[i] = a0
 8028606:	ecaa 8a01 	vstmia	sl!, {s16}
    const float a0 = 0.35875f;
    const float a1 = 0.48829f;
    const float a2 = 0.14128f;
    const float a3 = 0.01168f;

   for (uint32_t i = 0; i < window_size; ++i)
 802860a:	d1b2      	bne.n	8028572 <fft_window_gen+0x34a>
 802860c:	e749      	b.n	80284a2 <fft_window_gen+0x27a>
 802860e:	ee78 8aa8 	vadd.f32	s17, s17, s17
       	float poly_order = alpha * arm_cos_f32( (M_PI * i) / window_size);
       	float res = cheby_poly( window_size - 1, poly_order);
        sum += res * arm_cos_f32( 2.0f * n * M_PI * i / (float)window_size );
      }

      window_buffer[j] = pssbnd_ripple + 2 * sum;
 8028612:	9a01      	ldr	r2, [sp, #4]
      window_buffer[window_size - j - 1] = window_buffer[j];
 8028614:	9b00      	ldr	r3, [sp, #0]
       	float poly_order = alpha * arm_cos_f32( (M_PI * i) / window_size);
       	float res = cheby_poly( window_size - 1, poly_order);
        sum += res * arm_cos_f32( 2.0f * n * M_PI * i / (float)window_size );
      }

      window_buffer[j] = pssbnd_ripple + 2 * sum;
 8028616:	ee7b 8aa8 	vadd.f32	s17, s23, s17
    {
      win_even = win_even + 0.5f;
    }

    float max_val = 0;
    for (uint32_t j = 0; j < (window_size / 2 + 1); ++j)
 802861a:	f109 0901 	add.w	r9, r9, #1
       	float poly_order = alpha * arm_cos_f32( (M_PI * i) / window_size);
       	float res = cheby_poly( window_size - 1, poly_order);
        sum += res * arm_cos_f32( 2.0f * n * M_PI * i / (float)window_size );
      }

      window_buffer[j] = pssbnd_ripple + 2 * sum;
 802861e:	edc2 8a00 	vstr	s17, [r2]
      window_buffer[window_size - j - 1] = window_buffer[j];
 8028622:	ed63 8a01 	vstmdb	r3!, {s17}
 8028626:	9300      	str	r3, [sp, #0]

      if (window_buffer[j] > max_val)
 8028628:	4613      	mov	r3, r2
 802862a:	ecf3 7a01 	vldmia	r3!, {s15}
      {
        max_val = window_buffer[j];
 802862e:	eeb4 ba67 	vcmp.f32	s22, s15
      }

      window_buffer[j] = pssbnd_ripple + 2 * sum;
      window_buffer[window_size - j - 1] = window_buffer[j];

      if (window_buffer[j] > max_val)
 8028632:	9301      	str	r3, [sp, #4]
    {
      win_even = win_even + 0.5f;
    }

    float max_val = 0;
    for (uint32_t j = 0; j < (window_size / 2 + 1); ++j)
 8028634:	9b02      	ldr	r3, [sp, #8]
      window_buffer[j] = pssbnd_ripple + 2 * sum;
      window_buffer[window_size - j - 1] = window_buffer[j];

      if (window_buffer[j] > max_val)
      {
        max_val = window_buffer[j];
 8028636:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802863a:	bf48      	it	mi
 802863c:	eeb0 ba67 	vmovmi.f32	s22, s15
    {
      win_even = win_even + 0.5f;
    }

    float max_val = 0;
    for (uint32_t j = 0; j < (window_size / 2 + 1); ++j)
 8028640:	4599      	cmp	r9, r3
 8028642:	f47f ae76 	bne.w	8028332 <fft_window_gen+0x10a>
 8028646:	f8dd a014 	ldr.w	sl, [sp, #20]
 802864a:	9a04      	ldr	r2, [sp, #16]
 802864c:	4653      	mov	r3, sl
 802864e:	4452      	add	r2, sl
      }
    }

    for (uint32_t j = 0; j < window_size; ++j)
    {
      window_buffer[j] /= max_val;
 8028650:	edd3 7a00 	vldr	s15, [r3]
 8028654:	eec7 7a8b 	vdiv.f32	s15, s15, s22
 8028658:	ece3 7a01 	vstmia	r3!, {s15}
      {
        max_val = window_buffer[j];
      }
    }

    for (uint32_t j = 0; j < window_size; ++j)
 802865c:	4293      	cmp	r3, r2
 802865e:	d1f7      	bne.n	8028650 <fft_window_gen+0x428>
 8028660:	e71f      	b.n	80284a2 <fft_window_gen+0x27a>
/*-------------------- fft_window_init_chebyshev() -----------------------*/
static uint8_t fft_window_init_chebyshev(uint32_t window_size, float *window_buffer, float at_dB)
{
  if (window_size == 1)
  {
	window_buffer[0] = 1;
 8028662:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
  case FFT_WINDOW_BLACKMANHARRIS:
	  return fft_window_init_blackmanharris(window_size, window_buffer);
	  break;

  case FFT_WINDOW_CHEBYSHEV:
	  return fft_window_init_chebyshev(window_size, window_buffer, at_dB);
 8028666:	4648      	mov	r0, r9
/*-------------------- fft_window_init_chebyshev() -----------------------*/
static uint8_t fft_window_init_chebyshev(uint32_t window_size, float *window_buffer, float at_dB)
{
  if (window_size == 1)
  {
	window_buffer[0] = 1;
 8028668:	f8ca 3000 	str.w	r3, [sl]
 802866c:	e603      	b.n	8028276 <fft_window_gen+0x4e>
    for (uint32_t j = 0; j < (window_size / 2 + 1); ++j)
    {
      float n = j - win_even;
      float sum = 0;

      for (uint32_t i = 1; i <= win_even; ++i)
 802866e:	eddf 8a03 	vldr	s17, [pc, #12]	; 802867c <fft_window_gen+0x454>
 8028672:	e7ce      	b.n	8028612 <fft_window_gen+0x3ea>
 8028674:	f3af 8000 	nop.w
 8028678:	3c3f5d79 	.word	0x3c3f5d79
 802867c:	00000000 	.word	0x00000000
 8028680:	54442d18 	.word	0x54442d18
 8028684:	401921fb 	.word	0x401921fb
 8028688:	54442d18 	.word	0x54442d18
 802868c:	402921fb 	.word	0x402921fb
 8028690:	7f3321d2 	.word	0x7f3321d2
 8028694:	4032d97c 	.word	0x4032d97c

08028698 <compute_fft_signal>:

/*-------------------------- compute_fft_signal() --------------------------*/
void compute_fft_signal(FFT_Window_Struct_t fft_window, float* i_data, float* q_data, uint16_t Nd,
		                uint16_t Nf, float if_scale, FFT_Input_t fft_type,
						float* p_i_mean, float* p_q_mean, float* complex_fft_signal)
{
 8028698:	b084      	sub	sp, #16
 802869a:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802869e:	ed2d 8b02 	vpush	{d8}
 80286a2:	b087      	sub	sp, #28
 80286a4:	ac12      	add	r4, sp, #72	; 0x48
 80286a6:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
 80286aa:	9e1f      	ldr	r6, [sp, #124]	; 0x7c
	float i_mean = 0.0f;
	float q_mean = 0.0f;
	uint32_t idx;
	float *fft_window_buffer = fft_window.fft_window_buffer;
 80286ac:	f8dd b054 	ldr.w	fp, [sp, #84]	; 0x54

/*-------------------------- compute_fft_signal() --------------------------*/
void compute_fft_signal(FFT_Window_Struct_t fft_window, float* i_data, float* q_data, uint16_t Nd,
		                uint16_t Nf, float if_scale, FFT_Input_t fft_type,
						float* p_i_mean, float* p_q_mean, float* complex_fft_signal)
{
 80286b0:	f8bd 4064 	ldrh.w	r4, [sp, #100]	; 0x64
 80286b4:	f8bd 7068 	ldrh.w	r7, [sp, #104]	; 0x68
 80286b8:	ed9d 8a1b 	vldr	s16, [sp, #108]	; 0x6c
 80286bc:	f89d 3070 	ldrb.w	r3, [sp, #112]	; 0x70
	float i_mean = 0.0f;
 80286c0:	2500      	movs	r5, #0
 80286c2:	9504      	str	r5, [sp, #16]
	float q_mean = 0.0f;
 80286c4:	9505      	str	r5, [sp, #20]
	uint32_t idx;
	float *fft_window_buffer = fft_window.fft_window_buffer;

	if (!complex_fft_signal)
 80286c6:	2e00      	cmp	r6, #0
 80286c8:	d054      	beq.n	8028774 <compute_fft_signal+0xdc>
		return;

	if (!fft_window_buffer)
 80286ca:	f1bb 0f00 	cmp.w	fp, #0
 80286ce:	d051      	beq.n	8028774 <compute_fft_signal+0xdc>
		return;

	if (fft_type == FFT_INPUT_REAL_I)
 80286d0:	2b01      	cmp	r3, #1
 80286d2:	f000 8098 	beq.w	8028806 <compute_fft_signal+0x16e>
		{
			complex_fft_signal[2 * idx + 0] = 2.0 * (float)(i_data[idx] - i_mean) * if_scale * fft_window_buffer[idx];	// additional scaling by 2 for real input FFT
			complex_fft_signal[2 * idx + 1] = 0;
		}
	}
	else if (fft_type == FFT_INPUT_REAL_Q)
 80286d6:	2b02      	cmp	r3, #2
	{
		/* Find the mean in q_data */
		arm_mean_f32(q_data, Nd, &q_mean);
 80286d8:	9818      	ldr	r0, [sp, #96]	; 0x60
 80286da:	4621      	mov	r1, r4
 80286dc:	aa05      	add	r2, sp, #20
		{
			complex_fft_signal[2 * idx + 0] = 2.0 * (float)(i_data[idx] - i_mean) * if_scale * fft_window_buffer[idx];	// additional scaling by 2 for real input FFT
			complex_fft_signal[2 * idx + 1] = 0;
		}
	}
	else if (fft_type == FFT_INPUT_REAL_Q)
 80286de:	d050      	beq.n	8028782 <compute_fft_signal+0xea>
		}
	}
	else
	{
		/* Find the mean in q_data */
		arm_mean_f32(q_data, Nd, &q_mean);
 80286e0:	f7ff f878 	bl	80277d4 <arm_mean_f32>

		/* Find the mean in i_data */
		arm_mean_f32(i_data, Nd, &i_mean);
 80286e4:	9817      	ldr	r0, [sp, #92]	; 0x5c
 80286e6:	4621      	mov	r1, r4
 80286e8:	aa04      	add	r2, sp, #16
 80286ea:	f7ff f873 	bl	80277d4 <arm_mean_f32>

		/* Interleaved (re = I & im = Q) samples as {re[0], im[0], re[1], im[1], ...} */
		for (idx = 0; idx < Nd; idx++)
 80286ee:	b32c      	cbz	r4, 802873c <compute_fft_signal+0xa4>
 80286f0:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 80286f2:	ed9d 6a04 	vldr	s12, [sp, #16]
 80286f6:	eddd 6a05 	vldr	s13, [sp, #20]
 80286fa:	9918      	ldr	r1, [sp, #96]	; 0x60
 80286fc:	eb02 0584 	add.w	r5, r2, r4, lsl #2
 8028700:	4633      	mov	r3, r6
		{
			complex_fft_signal[2 * idx + 0] = (float)(i_data[idx] - i_mean) * if_scale * fft_window_buffer[idx];
 8028702:	ecf2 7a01 	vldmia	r2!, {s15}
 8028706:	ee77 7ac6 	vsub.f32	s15, s15, s12
 802870a:	4658      	mov	r0, fp
 802870c:	ee27 7a88 	vmul.f32	s14, s15, s16
 8028710:	ecfb 7a01 	vldmia	fp!, {s15}
 8028714:	ee67 7a27 	vmul.f32	s15, s14, s15

		/* Find the mean in i_data */
		arm_mean_f32(i_data, Nd, &i_mean);

		/* Interleaved (re = I & im = Q) samples as {re[0], im[0], re[1], im[1], ...} */
		for (idx = 0; idx < Nd; idx++)
 8028718:	42aa      	cmp	r2, r5
		{
			complex_fft_signal[2 * idx + 0] = (float)(i_data[idx] - i_mean) * if_scale * fft_window_buffer[idx];
 802871a:	edc3 7a00 	vstr	s15, [r3]
			complex_fft_signal[2 * idx + 1] = (float)(q_data[idx] - q_mean) * if_scale * fft_window_buffer[idx];
 802871e:	ecf1 7a01 	vldmia	r1!, {s15}
 8028722:	ed90 7a00 	vldr	s14, [r0]
 8028726:	ee77 7ae6 	vsub.f32	s15, s15, s13
 802872a:	f103 0308 	add.w	r3, r3, #8
 802872e:	ee67 7a88 	vmul.f32	s15, s15, s16
 8028732:	ee67 7a87 	vmul.f32	s15, s15, s14
 8028736:	ed43 7a01 	vstr	s15, [r3, #-4]

		/* Find the mean in i_data */
		arm_mean_f32(i_data, Nd, &i_mean);

		/* Interleaved (re = I & im = Q) samples as {re[0], im[0], re[1], im[1], ...} */
		for (idx = 0; idx < Nd; idx++)
 802873a:	d1e2      	bne.n	8028702 <compute_fft_signal+0x6a>
			complex_fft_signal[2 * idx + 1] = (float)(q_data[idx] - q_mean) * if_scale * fft_window_buffer[idx];
		}
	}

	/* Zero Padding */
	for (uint16_t idx = Nd; idx < Nf; idx++)
 802873c:	42bc      	cmp	r4, r7
	{
		complex_fft_signal[2 * idx + 0] = 0;
 802873e:	bf38      	it	cc
 8028740:	2200      	movcc	r2, #0
			complex_fft_signal[2 * idx + 1] = (float)(q_data[idx] - q_mean) * if_scale * fft_window_buffer[idx];
		}
	}

	/* Zero Padding */
	for (uint16_t idx = Nd; idx < Nf; idx++)
 8028742:	d207      	bcs.n	8028754 <compute_fft_signal+0xbc>
 8028744:	1c61      	adds	r1, r4, #1
	{
		complex_fft_signal[2 * idx + 0] = 0;
 8028746:	eb06 03c4 	add.w	r3, r6, r4, lsl #3
			complex_fft_signal[2 * idx + 1] = (float)(q_data[idx] - q_mean) * if_scale * fft_window_buffer[idx];
		}
	}

	/* Zero Padding */
	for (uint16_t idx = Nd; idx < Nf; idx++)
 802874a:	b28c      	uxth	r4, r1
 802874c:	42bc      	cmp	r4, r7
	{
		complex_fft_signal[2 * idx + 0] = 0;
 802874e:	601a      	str	r2, [r3, #0]
		complex_fft_signal[2 * idx + 1] = 0;
 8028750:	605a      	str	r2, [r3, #4]
			complex_fft_signal[2 * idx + 1] = (float)(q_data[idx] - q_mean) * if_scale * fft_window_buffer[idx];
		}
	}

	/* Zero Padding */
	for (uint16_t idx = Nd; idx < Nf; idx++)
 8028752:	d1f7      	bne.n	8028744 <compute_fft_signal+0xac>
		complex_fft_signal[2 * idx + 0] = 0;
		complex_fft_signal[2 * idx + 1] = 0;
	}

	/* copy mean values into output pointers */
	if ( p_i_mean )
 8028754:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 8028756:	b113      	cbz	r3, 802875e <compute_fft_signal+0xc6>
 8028758:	461a      	mov	r2, r3
		*p_i_mean = i_mean;
 802875a:	9b04      	ldr	r3, [sp, #16]
 802875c:	6013      	str	r3, [r2, #0]

	if ( p_q_mean )
 802875e:	9b1e      	ldr	r3, [sp, #120]	; 0x78
 8028760:	b113      	cbz	r3, 8028768 <compute_fft_signal+0xd0>
 8028762:	461a      	mov	r2, r3
		*p_q_mean = q_mean;
 8028764:	9b05      	ldr	r3, [sp, #20]
 8028766:	6013      	str	r3, [r2, #0]

	/* Processing the floating-point complex FFT. */
	arm_cfft_f32(fft_window.fft_time_twiddle_table, complex_fft_signal, 0, 1);
 8028768:	4631      	mov	r1, r6
 802876a:	9816      	ldr	r0, [sp, #88]	; 0x58
 802876c:	2200      	movs	r2, #0
 802876e:	2301      	movs	r3, #1
 8028770:	f7fe fc86 	bl	8027080 <arm_cfft_f32>
}
 8028774:	b007      	add	sp, #28
 8028776:	ecbd 8b02 	vpop	{d8}
 802877a:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802877e:	b004      	add	sp, #16
 8028780:	4770      	bx	lr
		}
	}
	else if (fft_type == FFT_INPUT_REAL_Q)
	{
		/* Find the mean in q_data */
		arm_mean_f32(q_data, Nd, &q_mean);
 8028782:	f7ff f827 	bl	80277d4 <arm_mean_f32>

		/* Interleaved (re = Q & im = 0) samples as {re[0], im[0], re[1], im[1], ...} */
		for (idx = 0; idx < Nd; idx++)
 8028786:	2c00      	cmp	r4, #0
 8028788:	d0d8      	beq.n	802873c <compute_fft_signal+0xa4>
 802878a:	ee18 0a10 	vmov	r0, s16
 802878e:	f004 f897 	bl	802c8c0 <__aeabi_f2d>
		{
			complex_fft_signal[2 * idx + 0] = 2.0 * (float)(q_data[idx] - q_mean) * if_scale * fft_window_buffer[idx];	// additional scaling by 2 for real input FFT
			complex_fft_signal[2 * idx + 1] = 0;
 8028792:	ee08 5a10 	vmov	s16, r5
 8028796:	9d18      	ldr	r5, [sp, #96]	; 0x60
 8028798:	eddd 8a05 	vldr	s17, [sp, #20]
 802879c:	9703      	str	r7, [sp, #12]
 802879e:	eb05 0384 	add.w	r3, r5, r4, lsl #2
 80287a2:	46b2      	mov	sl, r6
 80287a4:	961f      	str	r6, [sp, #124]	; 0x7c
 80287a6:	9301      	str	r3, [sp, #4]
 80287a8:	9402      	str	r4, [sp, #8]
 80287aa:	4606      	mov	r6, r0
 80287ac:	460f      	mov	r7, r1
		arm_mean_f32(q_data, Nd, &q_mean);

		/* Interleaved (re = Q & im = 0) samples as {re[0], im[0], re[1], im[1], ...} */
		for (idx = 0; idx < Nd; idx++)
		{
			complex_fft_signal[2 * idx + 0] = 2.0 * (float)(q_data[idx] - q_mean) * if_scale * fft_window_buffer[idx];	// additional scaling by 2 for real input FFT
 80287ae:	ecf5 7a01 	vldmia	r5!, {s15}
 80287b2:	f85b 4b04 	ldr.w	r4, [fp], #4
 80287b6:	ee77 7ae8 	vsub.f32	s15, s15, s17
 80287ba:	f10a 0a08 	add.w	sl, sl, #8
 80287be:	ee17 0a90 	vmov	r0, s15
 80287c2:	f004 f87d 	bl	802c8c0 <__aeabi_f2d>
 80287c6:	4602      	mov	r2, r0
 80287c8:	460b      	mov	r3, r1
 80287ca:	f003 ff1b 	bl	802c604 <__adddf3>
 80287ce:	4632      	mov	r2, r6
 80287d0:	463b      	mov	r3, r7
 80287d2:	f004 f8c9 	bl	802c968 <__aeabi_dmul>
 80287d6:	4680      	mov	r8, r0
 80287d8:	4620      	mov	r0, r4
 80287da:	4689      	mov	r9, r1
 80287dc:	f004 f870 	bl	802c8c0 <__aeabi_f2d>
 80287e0:	460b      	mov	r3, r1
 80287e2:	4602      	mov	r2, r0
 80287e4:	4649      	mov	r1, r9
 80287e6:	4640      	mov	r0, r8
 80287e8:	f004 f8be 	bl	802c968 <__aeabi_dmul>
 80287ec:	f004 fb76 	bl	802cedc <__aeabi_d2f>
	{
		/* Find the mean in q_data */
		arm_mean_f32(q_data, Nd, &q_mean);

		/* Interleaved (re = Q & im = 0) samples as {re[0], im[0], re[1], im[1], ...} */
		for (idx = 0; idx < Nd; idx++)
 80287f0:	9b01      	ldr	r3, [sp, #4]
		{
			complex_fft_signal[2 * idx + 0] = 2.0 * (float)(q_data[idx] - q_mean) * if_scale * fft_window_buffer[idx];	// additional scaling by 2 for real input FFT
			complex_fft_signal[2 * idx + 1] = 0;
 80287f2:	ed0a 8a01 	vstr	s16, [sl, #-4]
	{
		/* Find the mean in q_data */
		arm_mean_f32(q_data, Nd, &q_mean);

		/* Interleaved (re = Q & im = 0) samples as {re[0], im[0], re[1], im[1], ...} */
		for (idx = 0; idx < Nd; idx++)
 80287f6:	429d      	cmp	r5, r3
		{
			complex_fft_signal[2 * idx + 0] = 2.0 * (float)(q_data[idx] - q_mean) * if_scale * fft_window_buffer[idx];	// additional scaling by 2 for real input FFT
 80287f8:	f84a 0c08 	str.w	r0, [sl, #-8]
	{
		/* Find the mean in q_data */
		arm_mean_f32(q_data, Nd, &q_mean);

		/* Interleaved (re = Q & im = 0) samples as {re[0], im[0], re[1], im[1], ...} */
		for (idx = 0; idx < Nd; idx++)
 80287fc:	d1d7      	bne.n	80287ae <compute_fft_signal+0x116>
 80287fe:	9c02      	ldr	r4, [sp, #8]
 8028800:	9f03      	ldr	r7, [sp, #12]
 8028802:	9e1f      	ldr	r6, [sp, #124]	; 0x7c
 8028804:	e79a      	b.n	802873c <compute_fft_signal+0xa4>
		return;

	if (fft_type == FFT_INPUT_REAL_I)
	{
		/* Find the mean in i_data */
		arm_mean_f32(i_data, Nd, &i_mean);
 8028806:	9817      	ldr	r0, [sp, #92]	; 0x5c
 8028808:	4621      	mov	r1, r4
 802880a:	aa04      	add	r2, sp, #16
 802880c:	f7fe ffe2 	bl	80277d4 <arm_mean_f32>

		/* Interleaved (re = I & im = 0) samples as {re[0], im[0], re[1], im[1], ...} */
		for (idx = 0; idx < Nd; idx++)
 8028810:	2c00      	cmp	r4, #0
 8028812:	d093      	beq.n	802873c <compute_fft_signal+0xa4>
 8028814:	ee18 0a10 	vmov	r0, s16
 8028818:	f004 f852 	bl	802c8c0 <__aeabi_f2d>
		{
			complex_fft_signal[2 * idx + 0] = 2.0 * (float)(i_data[idx] - i_mean) * if_scale * fft_window_buffer[idx];	// additional scaling by 2 for real input FFT
			complex_fft_signal[2 * idx + 1] = 0;
 802881c:	ee08 5a10 	vmov	s16, r5
 8028820:	9d17      	ldr	r5, [sp, #92]	; 0x5c
 8028822:	eddd 8a04 	vldr	s17, [sp, #16]
 8028826:	9703      	str	r7, [sp, #12]
 8028828:	eb05 0384 	add.w	r3, r5, r4, lsl #2
 802882c:	46b2      	mov	sl, r6
 802882e:	961f      	str	r6, [sp, #124]	; 0x7c
 8028830:	9301      	str	r3, [sp, #4]
 8028832:	9402      	str	r4, [sp, #8]
 8028834:	4606      	mov	r6, r0
 8028836:	460f      	mov	r7, r1
		arm_mean_f32(i_data, Nd, &i_mean);

		/* Interleaved (re = I & im = 0) samples as {re[0], im[0], re[1], im[1], ...} */
		for (idx = 0; idx < Nd; idx++)
		{
			complex_fft_signal[2 * idx + 0] = 2.0 * (float)(i_data[idx] - i_mean) * if_scale * fft_window_buffer[idx];	// additional scaling by 2 for real input FFT
 8028838:	ecf5 7a01 	vldmia	r5!, {s15}
 802883c:	f85b 4b04 	ldr.w	r4, [fp], #4
 8028840:	ee77 7ae8 	vsub.f32	s15, s15, s17
 8028844:	f10a 0a08 	add.w	sl, sl, #8
 8028848:	ee17 0a90 	vmov	r0, s15
 802884c:	f004 f838 	bl	802c8c0 <__aeabi_f2d>
 8028850:	4602      	mov	r2, r0
 8028852:	460b      	mov	r3, r1
 8028854:	f003 fed6 	bl	802c604 <__adddf3>
 8028858:	4632      	mov	r2, r6
 802885a:	463b      	mov	r3, r7
 802885c:	f004 f884 	bl	802c968 <__aeabi_dmul>
 8028860:	4680      	mov	r8, r0
 8028862:	4620      	mov	r0, r4
 8028864:	4689      	mov	r9, r1
 8028866:	f004 f82b 	bl	802c8c0 <__aeabi_f2d>
 802886a:	460b      	mov	r3, r1
 802886c:	4602      	mov	r2, r0
 802886e:	4649      	mov	r1, r9
 8028870:	4640      	mov	r0, r8
 8028872:	f004 f879 	bl	802c968 <__aeabi_dmul>
 8028876:	f004 fb31 	bl	802cedc <__aeabi_d2f>
	{
		/* Find the mean in i_data */
		arm_mean_f32(i_data, Nd, &i_mean);

		/* Interleaved (re = I & im = 0) samples as {re[0], im[0], re[1], im[1], ...} */
		for (idx = 0; idx < Nd; idx++)
 802887a:	9b01      	ldr	r3, [sp, #4]
		{
			complex_fft_signal[2 * idx + 0] = 2.0 * (float)(i_data[idx] - i_mean) * if_scale * fft_window_buffer[idx];	// additional scaling by 2 for real input FFT
			complex_fft_signal[2 * idx + 1] = 0;
 802887c:	ed0a 8a01 	vstr	s16, [sl, #-4]
	{
		/* Find the mean in i_data */
		arm_mean_f32(i_data, Nd, &i_mean);

		/* Interleaved (re = I & im = 0) samples as {re[0], im[0], re[1], im[1], ...} */
		for (idx = 0; idx < Nd; idx++)
 8028880:	429d      	cmp	r5, r3
		{
			complex_fft_signal[2 * idx + 0] = 2.0 * (float)(i_data[idx] - i_mean) * if_scale * fft_window_buffer[idx];	// additional scaling by 2 for real input FFT
 8028882:	f84a 0c08 	str.w	r0, [sl, #-8]
	{
		/* Find the mean in i_data */
		arm_mean_f32(i_data, Nd, &i_mean);

		/* Interleaved (re = I & im = 0) samples as {re[0], im[0], re[1], im[1], ...} */
		for (idx = 0; idx < Nd; idx++)
 8028886:	d1d7      	bne.n	8028838 <compute_fft_signal+0x1a0>
 8028888:	e7b9      	b.n	80287fe <compute_fft_signal+0x166>
 802888a:	bf00      	nop

0802888c <compute_fft_spectrum>:
	arm_cfft_f32(fft_window.fft_time_twiddle_table, complex_fft_signal, 0, 1);
}

/*-------------------------- compute_fft_spectrum() ------------------------*/
void compute_fft_spectrum(float* fft_input_signal, uint32_t Nf, float* fft_output_spectrum)
{
 802888c:	460b      	mov	r3, r1
	/* Convert to real magnitude data */
	arm_cmplx_mag_f32(fft_input_signal, fft_output_spectrum, Nf);
 802888e:	4611      	mov	r1, r2
 8028890:	461a      	mov	r2, r3
 8028892:	f7ff b813 	b.w	80278bc <arm_cmplx_mag_f32>
 8028896:	bf00      	nop

08028898 <bsp_eeprom_24cw128x_write_data>:

/* Function to write data into EEPROM in case of write operation in multi-page, within more then one page */
/* ==> For many write operations we have to wait at least 5ms between each operation
       This is needed only for write operation, there is no need to have this delay for the read operation */
EEPROM_STATUS_t bsp_eeprom_24cw128x_write_data(const uint16_t mem_address, uint8_t *tx_data, uint32_t tx_size)
{
 8028898:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  uint32_t tmp_tx_size = tx_size;
  uint16_t tmp_mem_address = mem_address;

  /* Check for valid start address and valid data size */
  if ((tmp_mem_address >= EEPROM_24CW128X_START_MEM_ADDR) &&
	 ((tmp_mem_address + tmp_tx_size) <= EEPROM_24CW128X_MAX_SIZE) &&
 802889c:	1883      	adds	r3, r0, r2
  uint32_t written_data = 0;
  uint32_t tmp_tx_size = tx_size;
  uint16_t tmp_mem_address = mem_address;

  /* Check for valid start address and valid data size */
  if ((tmp_mem_address >= EEPROM_24CW128X_START_MEM_ADDR) &&
 802889e:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000

/* Function to write data into EEPROM in case of write operation in multi-page, within more then one page */
/* ==> For many write operations we have to wait at least 5ms between each operation
       This is needed only for write operation, there is no need to have this delay for the read operation */
EEPROM_STATUS_t bsp_eeprom_24cw128x_write_data(const uint16_t mem_address, uint8_t *tx_data, uint32_t tx_size)
{
 80288a2:	b084      	sub	sp, #16
 80288a4:	4605      	mov	r5, r0
 80288a6:	4614      	mov	r4, r2
  uint32_t written_data = 0;
  uint32_t tmp_tx_size = tx_size;
  uint16_t tmp_mem_address = mem_address;

  /* Check for valid start address and valid data size */
  if ((tmp_mem_address >= EEPROM_24CW128X_START_MEM_ADDR) &&
 80288a8:	d81c      	bhi.n	80288e4 <bsp_eeprom_24cw128x_write_data+0x4c>
	 ((tmp_mem_address + tmp_tx_size) <= EEPROM_24CW128X_MAX_SIZE) &&
 80288aa:	b1da      	cbz	r2, 80288e4 <bsp_eeprom_24cw128x_write_data+0x4c>
  {
	/* The start write address is located in page : */
	nb_of_start_page = (tmp_mem_address / EEPROM_24CW128X_PAGE_SIZE) + 1;

	/* The last write address is located in page : */
	nb_of_end_page = ((tmp_mem_address + tmp_tx_size - 1) / EEPROM_24CW128X_PAGE_SIZE) + 1;
 80288ac:	3b01      	subs	r3, #1
 80288ae:	095b      	lsrs	r3, r3, #5
  if ((tmp_mem_address >= EEPROM_24CW128X_START_MEM_ADDR) &&
	 ((tmp_mem_address + tmp_tx_size) <= EEPROM_24CW128X_MAX_SIZE) &&
	 (tmp_tx_size > 0))
  {
	/* The start write address is located in page : */
	nb_of_start_page = (tmp_mem_address / EEPROM_24CW128X_PAGE_SIZE) + 1;
 80288b0:	0947      	lsrs	r7, r0, #5

	/* The last write address is located in page : */
	nb_of_end_page = ((tmp_mem_address + tmp_tx_size - 1) / EEPROM_24CW128X_PAGE_SIZE) + 1;
 80288b2:	3301      	adds	r3, #1
  if ((tmp_mem_address >= EEPROM_24CW128X_START_MEM_ADDR) &&
	 ((tmp_mem_address + tmp_tx_size) <= EEPROM_24CW128X_MAX_SIZE) &&
	 (tmp_tx_size > 0))
  {
	/* The start write address is located in page : */
	nb_of_start_page = (tmp_mem_address / EEPROM_24CW128X_PAGE_SIZE) + 1;
 80288b4:	3701      	adds	r7, #1

	/* The last write address is located in page : */
	nb_of_end_page = ((tmp_mem_address + tmp_tx_size - 1) / EEPROM_24CW128X_PAGE_SIZE) + 1;

	/* Write operation in multi-page */
	if ((nb_of_end_page - nb_of_start_page) > 0)
 80288b6:	42bb      	cmp	r3, r7
 80288b8:	4689      	mov	r9, r1
 80288ba:	f000 80e6 	beq.w	8028a8a <bsp_eeprom_24cw128x_write_data+0x1f2>
	{
	  /* Write the first part of data */
	  written_data = (nb_of_start_page * EEPROM_24CW128X_PAGE_SIZE) - tmp_mem_address;

	  /* Write the first chunk of data */
	  if (written_data > 0)
 80288be:	ebd0 1747 	rsbs	r7, r0, r7, lsl #5
 80288c2:	d113      	bne.n	80288ec <bsp_eeprom_24cw128x_write_data+0x54>
/* Function to write data into EEPROM in case of write operation in multi-page, within more then one page */
/* ==> For many write operations we have to wait at least 5ms between each operation
       This is needed only for write operation, there is no need to have this delay for the read operation */
EEPROM_STATUS_t bsp_eeprom_24cw128x_write_data(const uint16_t mem_address, uint8_t *tx_data, uint32_t tx_size)
{
  I2C_MASTER_STATUS_t status = I2C_MASTER_STATUS_FAILURE;
 80288c4:	2601      	movs	r6, #1
		  /* EEPROM start write address */
          mem_add[0] = (tmp_mem_address & 0x3F00) >> 8;
          mem_add[1] = tmp_mem_address & 0x00FF;

          /* Send memory address */
          status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, mem_add, 2, false);
 80288c6:	f8df 8238 	ldr.w	r8, [pc, #568]	; 8028b00 <bsp_eeprom_24cw128x_write_data+0x268>
	  }

	  /* Loop for the number of pages to be written */
	  do
	  {
		if (tmp_tx_size >= EEPROM_24CW128X_PAGE_SIZE) /* Write one page data */
 80288ca:	2c1f      	cmp	r4, #31
 80288cc:	d852      	bhi.n	8028974 <bsp_eeprom_24cw128x_write_data+0xdc>

			/* Wait for the EEPROM internal write cycle, minimum for 5ms */
			bsp_time_delay(6, BSP_TIMER_DELAY_MILLISECOND);
		  }
		}
		else if ((tmp_tx_size > 0) && (tmp_tx_size < EEPROM_24CW128X_PAGE_SIZE)) /* Write the last chunk of data */
 80288ce:	1e63      	subs	r3, r4, #1
 80288d0:	2b1e      	cmp	r3, #30
 80288d2:	f240 8097 	bls.w	8028a04 <bsp_eeprom_24cw128x_write_data+0x16c>
  {
    return EEPROM_STATUS_SUCCESS;
  }
  else
  {
    return EEPROM_STATUS_WRITE_ERROR;
 80288d6:	2e00      	cmp	r6, #0
 80288d8:	bf0c      	ite	eq
 80288da:	2001      	moveq	r0, #1
 80288dc:	2004      	movne	r0, #4
  }
}
 80288de:	b004      	add	sp, #16
 80288e0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  {
    return EEPROM_STATUS_SUCCESS;
  }
  else
  {
    return EEPROM_STATUS_WRITE_ERROR;
 80288e4:	2004      	movs	r0, #4
  }
}
 80288e6:	b004      	add	sp, #16
 80288e8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	    /* EEPROM start write address */
        mem_add[0] = (tmp_mem_address & 0x3F00) >> 8;
        mem_add[1] = tmp_mem_address & 0x00FF;

        /* Send memory address */
        status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, mem_add, 2, false);
 80288ec:	f8df a210 	ldr.w	sl, [pc, #528]	; 8028b00 <bsp_eeprom_24cw128x_write_data+0x268>
	  /* Write the first chunk of data */
	  if (written_data > 0)
	  {
	    /* EEPROM start write address */
        mem_add[0] = (tmp_mem_address & 0x3F00) >> 8;
        mem_add[1] = tmp_mem_address & 0x00FF;
 80288f0:	f88d 000d 	strb.w	r0, [sp, #13]

        /* Send memory address */
        status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, mem_add, 2, false);
 80288f4:	2202      	movs	r2, #2
 80288f6:	2300      	movs	r3, #0
 80288f8:	e88d 000c 	stmia.w	sp, {r2, r3}

	  /* Write the first chunk of data */
	  if (written_data > 0)
	  {
	    /* EEPROM start write address */
        mem_add[0] = (tmp_mem_address & 0x3F00) >> 8;
 80288fc:	f3c5 2605 	ubfx	r6, r5, #8, #6
        mem_add[1] = tmp_mem_address & 0x00FF;

        /* Send memory address */
        status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, mem_add, 2, false);
 8028900:	22a0      	movs	r2, #160	; 0xa0
 8028902:	4650      	mov	r0, sl
 8028904:	2101      	movs	r1, #1
 8028906:	ab03      	add	r3, sp, #12

	  /* Write the first chunk of data */
	  if (written_data > 0)
	  {
	    /* EEPROM start write address */
        mem_add[0] = (tmp_mem_address & 0x3F00) >> 8;
 8028908:	f88d 600c 	strb.w	r6, [sp, #12]
        mem_add[1] = tmp_mem_address & 0x00FF;

        /* Send memory address */
        status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, mem_add, 2, false);
 802890c:	f000 fa68 	bl	8028de0 <I2C_MASTER_Transmit>
 8028910:	f8da 2008 	ldr.w	r2, [sl, #8]
 8028914:	4606      	mov	r6, r0
 *
 */
__STATIC_INLINE bool I2C_MASTER_IsTxBusy(I2C_MASTER_t * const handle)
{
  XMC_ASSERT("I2C_MASTER_IsTxBusy: invalid handle", (handle != NULL))	
  return handle->runtime->tx_busy;
 8028916:	f892 3026 	ldrb.w	r3, [r2, #38]	; 0x26
        while(I2C_MASTER_IsTxBusy(&I2C_MASTER_EEPROM));
 802891a:	2b00      	cmp	r3, #0
 802891c:	d1fb      	bne.n	8028916 <bsp_eeprom_24cw128x_write_data+0x7e>

        if (status == I2C_MASTER_STATUS_SUCCESS)
 802891e:	2e00      	cmp	r6, #0
 8028920:	d1d1      	bne.n	80288c6 <bsp_eeprom_24cw128x_write_data+0x2e>
	    {
          /* Start sending data */
          status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, false, EEPROM_24CW128X_I2C_ADDRESS, tx_data, written_data, true);
 8028922:	2301      	movs	r3, #1
 8028924:	4631      	mov	r1, r6
 8028926:	9301      	str	r3, [sp, #4]
 8028928:	22a0      	movs	r2, #160	; 0xa0
 802892a:	9700      	str	r7, [sp, #0]
 802892c:	4874      	ldr	r0, [pc, #464]	; (8028b00 <bsp_eeprom_24cw128x_write_data+0x268>)
 802892e:	464b      	mov	r3, r9
 8028930:	f000 fa56 	bl	8028de0 <I2C_MASTER_Transmit>
 8028934:	f8da 2008 	ldr.w	r2, [sl, #8]
 8028938:	4606      	mov	r6, r0
 802893a:	f892 3026 	ldrb.w	r3, [r2, #38]	; 0x26
          while(I2C_MASTER_IsTxBusy(&I2C_MASTER_EEPROM));
 802893e:	2b00      	cmp	r3, #0
 8028940:	d1fb      	bne.n	802893a <bsp_eeprom_24cw128x_write_data+0xa2>
/* Function used to generate a time in units of microseconds or milliseconds */
void bsp_time_delay(uint32_t delay_value, BSP_TIMER_DELAY_t time_unit)
{
  uint32_t delay_cnt;

  TIMER_ClearEvent(&EEPROM_TIMER_DELAY);
 8028942:	4870      	ldr	r0, [pc, #448]	; (8028b04 <bsp_eeprom_24cw128x_write_data+0x26c>)
 8028944:	f7fd fb24 	bl	8025f90 <TIMER_ClearEvent>
  {
	/* Time in units of microseconds */
    delay_cnt = delay_value;
  }

  TIMER_SetTimeInterval(&EEPROM_TIMER_DELAY, delay_cnt);
 8028948:	486e      	ldr	r0, [pc, #440]	; (8028b04 <bsp_eeprom_24cw128x_write_data+0x26c>)
 802894a:	496f      	ldr	r1, [pc, #444]	; (8028b08 <bsp_eeprom_24cw128x_write_data+0x270>)
          status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, false, EEPROM_24CW128X_I2C_ADDRESS, tx_data, written_data, true);
          while(I2C_MASTER_IsTxBusy(&I2C_MASTER_EEPROM));

		  /* Remaining data */
		  tmp_tx_size = tmp_tx_size - written_data;
		  tmp_mem_address = tmp_mem_address + written_data;
 802894c:	443d      	add	r5, r7
  {
	/* Time in units of microseconds */
    delay_cnt = delay_value;
  }

  TIMER_SetTimeInterval(&EEPROM_TIMER_DELAY, delay_cnt);
 802894e:	f7fd fab3 	bl	8025eb8 <TIMER_SetTimeInterval>

  TIMER_Start(&EEPROM_TIMER_DELAY);
 8028952:	486c      	ldr	r0, [pc, #432]	; (8028b04 <bsp_eeprom_24cw128x_write_data+0x26c>)
          status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, false, EEPROM_24CW128X_I2C_ADDRESS, tx_data, written_data, true);
          while(I2C_MASTER_IsTxBusy(&I2C_MASTER_EEPROM));

		  /* Remaining data */
		  tmp_tx_size = tmp_tx_size - written_data;
		  tmp_mem_address = tmp_mem_address + written_data;
 8028954:	b2ad      	uxth	r5, r5
          /* Start sending data */
          status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, false, EEPROM_24CW128X_I2C_ADDRESS, tx_data, written_data, true);
          while(I2C_MASTER_IsTxBusy(&I2C_MASTER_EEPROM));

		  /* Remaining data */
		  tmp_tx_size = tmp_tx_size - written_data;
 8028956:	1be4      	subs	r4, r4, r7
    delay_cnt = delay_value;
  }

  TIMER_SetTimeInterval(&EEPROM_TIMER_DELAY, delay_cnt);

  TIMER_Start(&EEPROM_TIMER_DELAY);
 8028958:	f7fd fa8c 	bl	8025e74 <TIMER_Start>

  while(!TIMER_GetInterruptStatus(&EEPROM_TIMER_DELAY));
 802895c:	4869      	ldr	r0, [pc, #420]	; (8028b04 <bsp_eeprom_24cw128x_write_data+0x26c>)
 802895e:	f7fd fb0b 	bl	8025f78 <TIMER_GetInterruptStatus>
 8028962:	2800      	cmp	r0, #0
 8028964:	d0fa      	beq.n	802895c <bsp_eeprom_24cw128x_write_data+0xc4>

  TIMER_Stop(&EEPROM_TIMER_DELAY);
 8028966:	4867      	ldr	r0, [pc, #412]	; (8028b04 <bsp_eeprom_24cw128x_write_data+0x26c>)
 8028968:	f7fd fa94 	bl	8025e94 <TIMER_Stop>

  TIMER_Clear(&EEPROM_TIMER_DELAY);
 802896c:	4865      	ldr	r0, [pc, #404]	; (8028b04 <bsp_eeprom_24cw128x_write_data+0x26c>)
 802896e:	f7fd fb1b 	bl	8025fa8 <TIMER_Clear>
 8028972:	e7a8      	b.n	80288c6 <bsp_eeprom_24cw128x_write_data+0x2e>
		  /* EEPROM start write address */
          mem_add[0] = (tmp_mem_address & 0x3F00) >> 8;
          mem_add[1] = tmp_mem_address & 0x00FF;

          /* Send memory address */
          status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, mem_add, 2, false);
 8028974:	2202      	movs	r2, #2
 8028976:	2300      	movs	r3, #0
 8028978:	e88d 000c 	stmia.w	sp, {r2, r3}
	  do
	  {
		if (tmp_tx_size >= EEPROM_24CW128X_PAGE_SIZE) /* Write one page data */
		{
		  /* EEPROM start write address */
          mem_add[0] = (tmp_mem_address & 0x3F00) >> 8;
 802897c:	f3c5 2605 	ubfx	r6, r5, #8, #6
          mem_add[1] = tmp_mem_address & 0x00FF;

          /* Send memory address */
          status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, mem_add, 2, false);
 8028980:	22a0      	movs	r2, #160	; 0xa0
 8028982:	485f      	ldr	r0, [pc, #380]	; (8028b00 <bsp_eeprom_24cw128x_write_data+0x268>)
	  do
	  {
		if (tmp_tx_size >= EEPROM_24CW128X_PAGE_SIZE) /* Write one page data */
		{
		  /* EEPROM start write address */
          mem_add[0] = (tmp_mem_address & 0x3F00) >> 8;
 8028984:	f88d 600c 	strb.w	r6, [sp, #12]
          mem_add[1] = tmp_mem_address & 0x00FF;

          /* Send memory address */
          status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, mem_add, 2, false);
 8028988:	2101      	movs	r1, #1
 802898a:	ab03      	add	r3, sp, #12
	  {
		if (tmp_tx_size >= EEPROM_24CW128X_PAGE_SIZE) /* Write one page data */
		{
		  /* EEPROM start write address */
          mem_add[0] = (tmp_mem_address & 0x3F00) >> 8;
          mem_add[1] = tmp_mem_address & 0x00FF;
 802898c:	f88d 500d 	strb.w	r5, [sp, #13]

          /* Send memory address */
          status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, mem_add, 2, false);
 8028990:	f000 fa26 	bl	8028de0 <I2C_MASTER_Transmit>
 8028994:	f8d8 2008 	ldr.w	r2, [r8, #8]
 8028998:	4606      	mov	r6, r0
 802899a:	f892 3026 	ldrb.w	r3, [r2, #38]	; 0x26
          while(I2C_MASTER_IsTxBusy(&I2C_MASTER_EEPROM));
 802899e:	2b00      	cmp	r3, #0
 80289a0:	d1fb      	bne.n	802899a <bsp_eeprom_24cw128x_write_data+0x102>

          if (status == I2C_MASTER_STATUS_SUCCESS)
 80289a2:	2e00      	cmp	r6, #0
 80289a4:	d191      	bne.n	80288ca <bsp_eeprom_24cw128x_write_data+0x32>
	      {
            /* Start sending data */
            status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, false, EEPROM_24CW128X_I2C_ADDRESS, (tx_data + written_data), EEPROM_24CW128X_PAGE_SIZE, true);
 80289a6:	2220      	movs	r2, #32
 80289a8:	2301      	movs	r3, #1
 80289aa:	e88d 000c 	stmia.w	sp, {r2, r3}
 80289ae:	4631      	mov	r1, r6
 80289b0:	22a0      	movs	r2, #160	; 0xa0
 80289b2:	4853      	ldr	r0, [pc, #332]	; (8028b00 <bsp_eeprom_24cw128x_write_data+0x268>)
 80289b4:	eb09 0307 	add.w	r3, r9, r7
 80289b8:	f000 fa12 	bl	8028de0 <I2C_MASTER_Transmit>
 80289bc:	f8d8 2008 	ldr.w	r2, [r8, #8]
 80289c0:	4606      	mov	r6, r0
 80289c2:	f892 3026 	ldrb.w	r3, [r2, #38]	; 0x26
            while(I2C_MASTER_IsTxBusy(&I2C_MASTER_EEPROM));
 80289c6:	2b00      	cmp	r3, #0
 80289c8:	d1fb      	bne.n	80289c2 <bsp_eeprom_24cw128x_write_data+0x12a>
/* Function used to generate a time in units of microseconds or milliseconds */
void bsp_time_delay(uint32_t delay_value, BSP_TIMER_DELAY_t time_unit)
{
  uint32_t delay_cnt;

  TIMER_ClearEvent(&EEPROM_TIMER_DELAY);
 80289ca:	484e      	ldr	r0, [pc, #312]	; (8028b04 <bsp_eeprom_24cw128x_write_data+0x26c>)
 80289cc:	f7fd fae0 	bl	8025f90 <TIMER_ClearEvent>
  {
	/* Time in units of microseconds */
    delay_cnt = delay_value;
  }

  TIMER_SetTimeInterval(&EEPROM_TIMER_DELAY, delay_cnt);
 80289d0:	484c      	ldr	r0, [pc, #304]	; (8028b04 <bsp_eeprom_24cw128x_write_data+0x26c>)
 80289d2:	494d      	ldr	r1, [pc, #308]	; (8028b08 <bsp_eeprom_24cw128x_write_data+0x270>)
            /* Start sending data */
            status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, false, EEPROM_24CW128X_I2C_ADDRESS, (tx_data + written_data), EEPROM_24CW128X_PAGE_SIZE, true);
            while(I2C_MASTER_IsTxBusy(&I2C_MASTER_EEPROM));

		    /* Remaining data */
            tmp_mem_address = tmp_mem_address + EEPROM_24CW128X_PAGE_SIZE;
 80289d4:	3520      	adds	r5, #32
  {
	/* Time in units of microseconds */
    delay_cnt = delay_value;
  }

  TIMER_SetTimeInterval(&EEPROM_TIMER_DELAY, delay_cnt);
 80289d6:	f7fd fa6f 	bl	8025eb8 <TIMER_SetTimeInterval>

  TIMER_Start(&EEPROM_TIMER_DELAY);
 80289da:	484a      	ldr	r0, [pc, #296]	; (8028b04 <bsp_eeprom_24cw128x_write_data+0x26c>)
            /* Start sending data */
            status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, false, EEPROM_24CW128X_I2C_ADDRESS, (tx_data + written_data), EEPROM_24CW128X_PAGE_SIZE, true);
            while(I2C_MASTER_IsTxBusy(&I2C_MASTER_EEPROM));

		    /* Remaining data */
            tmp_mem_address = tmp_mem_address + EEPROM_24CW128X_PAGE_SIZE;
 80289dc:	b2ad      	uxth	r5, r5
		    tmp_tx_size = tmp_tx_size - EEPROM_24CW128X_PAGE_SIZE;
 80289de:	3c20      	subs	r4, #32
			written_data = written_data + EEPROM_24CW128X_PAGE_SIZE;
 80289e0:	3720      	adds	r7, #32
    delay_cnt = delay_value;
  }

  TIMER_SetTimeInterval(&EEPROM_TIMER_DELAY, delay_cnt);

  TIMER_Start(&EEPROM_TIMER_DELAY);
 80289e2:	f7fd fa47 	bl	8025e74 <TIMER_Start>

  while(!TIMER_GetInterruptStatus(&EEPROM_TIMER_DELAY));
 80289e6:	4847      	ldr	r0, [pc, #284]	; (8028b04 <bsp_eeprom_24cw128x_write_data+0x26c>)
 80289e8:	f7fd fac6 	bl	8025f78 <TIMER_GetInterruptStatus>
 80289ec:	2800      	cmp	r0, #0
 80289ee:	d0fa      	beq.n	80289e6 <bsp_eeprom_24cw128x_write_data+0x14e>

  TIMER_Stop(&EEPROM_TIMER_DELAY);
 80289f0:	4844      	ldr	r0, [pc, #272]	; (8028b04 <bsp_eeprom_24cw128x_write_data+0x26c>)
 80289f2:	f7fd fa4f 	bl	8025e94 <TIMER_Stop>

  TIMER_Clear(&EEPROM_TIMER_DELAY);
 80289f6:	4843      	ldr	r0, [pc, #268]	; (8028b04 <bsp_eeprom_24cw128x_write_data+0x26c>)
 80289f8:	f7fd fad6 	bl	8025fa8 <TIMER_Clear>

			/* Wait for the EEPROM internal write cycle, minimum for 5ms */
		    bsp_time_delay(6, BSP_TIMER_DELAY_MILLISECOND);
		  }
		}
	  }while(tmp_tx_size > 0);
 80289fc:	2c00      	cmp	r4, #0
 80289fe:	f47f af64 	bne.w	80288ca <bsp_eeprom_24cw128x_write_data+0x32>
 8028a02:	e768      	b.n	80288d6 <bsp_eeprom_24cw128x_write_data+0x3e>
		  /* EEPROM start write address */
          mem_add[0] = (tmp_mem_address & 0x3F00) >> 8;
          mem_add[1] = tmp_mem_address & 0x00FF;

          /* Send memory address */
          status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, mem_add, 2, false);
 8028a04:	f8df a0f8 	ldr.w	sl, [pc, #248]	; 8028b00 <bsp_eeprom_24cw128x_write_data+0x268>
		}
		else if ((tmp_tx_size > 0) && (tmp_tx_size < EEPROM_24CW128X_PAGE_SIZE)) /* Write the last chunk of data */
		{
		  /* EEPROM start write address */
          mem_add[0] = (tmp_mem_address & 0x3F00) >> 8;
          mem_add[1] = tmp_mem_address & 0x00FF;
 8028a08:	f88d 500d 	strb.w	r5, [sp, #13]

          /* Send memory address */
          status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, mem_add, 2, false);
 8028a0c:	2202      	movs	r2, #2
 8028a0e:	2300      	movs	r3, #0
 8028a10:	e88d 000c 	stmia.w	sp, {r2, r3}
		  }
		}
		else if ((tmp_tx_size > 0) && (tmp_tx_size < EEPROM_24CW128X_PAGE_SIZE)) /* Write the last chunk of data */
		{
		  /* EEPROM start write address */
          mem_add[0] = (tmp_mem_address & 0x3F00) >> 8;
 8028a14:	f3c5 2605 	ubfx	r6, r5, #8, #6
          mem_add[1] = tmp_mem_address & 0x00FF;

          /* Send memory address */
          status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, mem_add, 2, false);
 8028a18:	22a0      	movs	r2, #160	; 0xa0
 8028a1a:	4650      	mov	r0, sl
 8028a1c:	2101      	movs	r1, #1
 8028a1e:	ab03      	add	r3, sp, #12
		  }
		}
		else if ((tmp_tx_size > 0) && (tmp_tx_size < EEPROM_24CW128X_PAGE_SIZE)) /* Write the last chunk of data */
		{
		  /* EEPROM start write address */
          mem_add[0] = (tmp_mem_address & 0x3F00) >> 8;
 8028a20:	f88d 600c 	strb.w	r6, [sp, #12]
          mem_add[1] = tmp_mem_address & 0x00FF;

          /* Send memory address */
          status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, mem_add, 2, false);
 8028a24:	f000 f9dc 	bl	8028de0 <I2C_MASTER_Transmit>
 8028a28:	f8d8 2008 	ldr.w	r2, [r8, #8]
 8028a2c:	4606      	mov	r6, r0
 8028a2e:	f892 3026 	ldrb.w	r3, [r2, #38]	; 0x26
          while(I2C_MASTER_IsTxBusy(&I2C_MASTER_EEPROM));
 8028a32:	2b00      	cmp	r3, #0
 8028a34:	d1fb      	bne.n	8028a2e <bsp_eeprom_24cw128x_write_data+0x196>

          if (status == I2C_MASTER_STATUS_SUCCESS)
 8028a36:	2e00      	cmp	r6, #0
 8028a38:	f47f af47 	bne.w	80288ca <bsp_eeprom_24cw128x_write_data+0x32>
	      {
            /* Start sending data */
            status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, false, EEPROM_24CW128X_I2C_ADDRESS, (void *)(tx_data + written_data), tmp_tx_size, true);
 8028a3c:	2201      	movs	r2, #1
 8028a3e:	4631      	mov	r1, r6
 8028a40:	9201      	str	r2, [sp, #4]
 8028a42:	9400      	str	r4, [sp, #0]
 8028a44:	22a0      	movs	r2, #160	; 0xa0
 8028a46:	eb09 0307 	add.w	r3, r9, r7
 8028a4a:	482d      	ldr	r0, [pc, #180]	; (8028b00 <bsp_eeprom_24cw128x_write_data+0x268>)
 8028a4c:	f000 f9c8 	bl	8028de0 <I2C_MASTER_Transmit>
 8028a50:	f8da 2008 	ldr.w	r2, [sl, #8]
 8028a54:	4606      	mov	r6, r0
 8028a56:	f892 3026 	ldrb.w	r3, [r2, #38]	; 0x26
            while(I2C_MASTER_IsTxBusy(&I2C_MASTER_EEPROM));
 8028a5a:	2b00      	cmp	r3, #0
 8028a5c:	d1fb      	bne.n	8028a56 <bsp_eeprom_24cw128x_write_data+0x1be>
/* Function used to generate a time in units of microseconds or milliseconds */
void bsp_time_delay(uint32_t delay_value, BSP_TIMER_DELAY_t time_unit)
{
  uint32_t delay_cnt;

  TIMER_ClearEvent(&EEPROM_TIMER_DELAY);
 8028a5e:	4829      	ldr	r0, [pc, #164]	; (8028b04 <bsp_eeprom_24cw128x_write_data+0x26c>)
 8028a60:	f7fd fa96 	bl	8025f90 <TIMER_ClearEvent>
  {
	/* Time in units of microseconds */
    delay_cnt = delay_value;
  }

  TIMER_SetTimeInterval(&EEPROM_TIMER_DELAY, delay_cnt);
 8028a64:	4827      	ldr	r0, [pc, #156]	; (8028b04 <bsp_eeprom_24cw128x_write_data+0x26c>)
 8028a66:	4928      	ldr	r1, [pc, #160]	; (8028b08 <bsp_eeprom_24cw128x_write_data+0x270>)
 8028a68:	f7fd fa26 	bl	8025eb8 <TIMER_SetTimeInterval>

  TIMER_Start(&EEPROM_TIMER_DELAY);
 8028a6c:	4825      	ldr	r0, [pc, #148]	; (8028b04 <bsp_eeprom_24cw128x_write_data+0x26c>)
 8028a6e:	f7fd fa01 	bl	8025e74 <TIMER_Start>

  while(!TIMER_GetInterruptStatus(&EEPROM_TIMER_DELAY));
 8028a72:	4824      	ldr	r0, [pc, #144]	; (8028b04 <bsp_eeprom_24cw128x_write_data+0x26c>)
 8028a74:	f7fd fa80 	bl	8025f78 <TIMER_GetInterruptStatus>
 8028a78:	2800      	cmp	r0, #0
 8028a7a:	d0fa      	beq.n	8028a72 <bsp_eeprom_24cw128x_write_data+0x1da>

  TIMER_Stop(&EEPROM_TIMER_DELAY);
 8028a7c:	4821      	ldr	r0, [pc, #132]	; (8028b04 <bsp_eeprom_24cw128x_write_data+0x26c>)
 8028a7e:	f7fd fa09 	bl	8025e94 <TIMER_Stop>

  TIMER_Clear(&EEPROM_TIMER_DELAY);
 8028a82:	4820      	ldr	r0, [pc, #128]	; (8028b04 <bsp_eeprom_24cw128x_write_data+0x26c>)
 8028a84:	f7fd fa90 	bl	8025fa8 <TIMER_Clear>
 8028a88:	e725      	b.n	80288d6 <bsp_eeprom_24cw128x_write_data+0x3e>
	  /* EEPROM start write address */
      mem_add[0] = (mem_address & 0x3F00) >> 8;
      mem_add[1] = mem_address & 0x00FF;

      /* Send memory address */
      status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, mem_add, 2, false);
 8028a8a:	f8df a074 	ldr.w	sl, [pc, #116]	; 8028b00 <bsp_eeprom_24cw128x_write_data+0x268>
	}
	else /* Write operation within the same page */
	{
	  /* EEPROM start write address */
      mem_add[0] = (mem_address & 0x3F00) >> 8;
      mem_add[1] = mem_address & 0x00FF;
 8028a8e:	f88d 000d 	strb.w	r0, [sp, #13]

      /* Send memory address */
      status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, mem_add, 2, false);
 8028a92:	2202      	movs	r2, #2
 8028a94:	2300      	movs	r3, #0
 8028a96:	e88d 000c 	stmia.w	sp, {r2, r3}
	  }while(tmp_tx_size > 0);
	}
	else /* Write operation within the same page */
	{
	  /* EEPROM start write address */
      mem_add[0] = (mem_address & 0x3F00) >> 8;
 8028a9a:	f3c0 2505 	ubfx	r5, r0, #8, #6
      mem_add[1] = mem_address & 0x00FF;

      /* Send memory address */
      status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, mem_add, 2, false);
 8028a9e:	22a0      	movs	r2, #160	; 0xa0
 8028aa0:	4650      	mov	r0, sl
 8028aa2:	2101      	movs	r1, #1
 8028aa4:	ab03      	add	r3, sp, #12
	  }while(tmp_tx_size > 0);
	}
	else /* Write operation within the same page */
	{
	  /* EEPROM start write address */
      mem_add[0] = (mem_address & 0x3F00) >> 8;
 8028aa6:	f88d 500c 	strb.w	r5, [sp, #12]
      mem_add[1] = mem_address & 0x00FF;

      /* Send memory address */
      status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, mem_add, 2, false);
 8028aaa:	f000 f999 	bl	8028de0 <I2C_MASTER_Transmit>
 8028aae:	f8da 2008 	ldr.w	r2, [sl, #8]
 8028ab2:	4606      	mov	r6, r0
 8028ab4:	f892 3026 	ldrb.w	r3, [r2, #38]	; 0x26
      while(I2C_MASTER_IsTxBusy(&I2C_MASTER_EEPROM));
 8028ab8:	2b00      	cmp	r3, #0
 8028aba:	d1fb      	bne.n	8028ab4 <bsp_eeprom_24cw128x_write_data+0x21c>

      if (status == I2C_MASTER_STATUS_SUCCESS)
 8028abc:	b17e      	cbz	r6, 8028ade <bsp_eeprom_24cw128x_write_data+0x246>
/* Function used to generate a time in units of microseconds or milliseconds */
void bsp_time_delay(uint32_t delay_value, BSP_TIMER_DELAY_t time_unit)
{
  uint32_t delay_cnt;

  TIMER_ClearEvent(&EEPROM_TIMER_DELAY);
 8028abe:	4811      	ldr	r0, [pc, #68]	; (8028b04 <bsp_eeprom_24cw128x_write_data+0x26c>)
 8028ac0:	f7fd fa66 	bl	8025f90 <TIMER_ClearEvent>
  {
	/* Time in units of microseconds */
    delay_cnt = delay_value;
  }

  TIMER_SetTimeInterval(&EEPROM_TIMER_DELAY, delay_cnt);
 8028ac4:	480f      	ldr	r0, [pc, #60]	; (8028b04 <bsp_eeprom_24cw128x_write_data+0x26c>)
 8028ac6:	4910      	ldr	r1, [pc, #64]	; (8028b08 <bsp_eeprom_24cw128x_write_data+0x270>)
 8028ac8:	f7fd f9f6 	bl	8025eb8 <TIMER_SetTimeInterval>

  TIMER_Start(&EEPROM_TIMER_DELAY);
 8028acc:	480d      	ldr	r0, [pc, #52]	; (8028b04 <bsp_eeprom_24cw128x_write_data+0x26c>)
 8028ace:	f7fd f9d1 	bl	8025e74 <TIMER_Start>

  while(!TIMER_GetInterruptStatus(&EEPROM_TIMER_DELAY));
 8028ad2:	480c      	ldr	r0, [pc, #48]	; (8028b04 <bsp_eeprom_24cw128x_write_data+0x26c>)
 8028ad4:	f7fd fa50 	bl	8025f78 <TIMER_GetInterruptStatus>
 8028ad8:	2800      	cmp	r0, #0
 8028ada:	d0fa      	beq.n	8028ad2 <bsp_eeprom_24cw128x_write_data+0x23a>
 8028adc:	e7ce      	b.n	8028a7c <bsp_eeprom_24cw128x_write_data+0x1e4>
      while(I2C_MASTER_IsTxBusy(&I2C_MASTER_EEPROM));

      if (status == I2C_MASTER_STATUS_SUCCESS)
	  {
        /* Start sending data */
        status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, false, EEPROM_24CW128X_I2C_ADDRESS, (void*) tx_data, tx_size, true);
 8028ade:	2201      	movs	r2, #1
 8028ae0:	4631      	mov	r1, r6
 8028ae2:	9201      	str	r2, [sp, #4]
 8028ae4:	9400      	str	r4, [sp, #0]
 8028ae6:	22a0      	movs	r2, #160	; 0xa0
 8028ae8:	464b      	mov	r3, r9
 8028aea:	4805      	ldr	r0, [pc, #20]	; (8028b00 <bsp_eeprom_24cw128x_write_data+0x268>)
 8028aec:	f000 f978 	bl	8028de0 <I2C_MASTER_Transmit>
 8028af0:	f8da 2008 	ldr.w	r2, [sl, #8]
 8028af4:	4606      	mov	r6, r0
 8028af6:	f892 3026 	ldrb.w	r3, [r2, #38]	; 0x26
        while(I2C_MASTER_IsTxBusy(&I2C_MASTER_EEPROM));
 8028afa:	2b00      	cmp	r3, #0
 8028afc:	d1fb      	bne.n	8028af6 <bsp_eeprom_24cw128x_write_data+0x25e>
 8028afe:	e7de      	b.n	8028abe <bsp_eeprom_24cw128x_write_data+0x226>
 8028b00:	1ffe9600 	.word	0x1ffe9600
 8028b04:	1ffe9198 	.word	0x1ffe9198
 8028b08:	000927c0 	.word	0x000927c0

08028b0c <bsp_eeprom_24cw128x_read_data>:

//============================================================================

/* Function to read data from EEPROM in case of read operation in multi-page, within more then one page */
EEPROM_STATUS_t bsp_eeprom_24cw128x_read_data(const uint16_t mem_address, uint8_t *rx_data, uint32_t rx_size)
{
 8028b0c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  uint32_t tmp_rx_size = rx_size;
  uint16_t tmp_mem_address = mem_address;

  /* Check for valid start address and valid data size */
  if ((tmp_mem_address >= EEPROM_24CW128X_START_MEM_ADDR) &&
	 ((tmp_mem_address + tmp_rx_size) <= EEPROM_24CW128X_MAX_SIZE) &&
 8028b10:	1883      	adds	r3, r0, r2
  uint32_t read_data = 0;
  uint32_t tmp_rx_size = rx_size;
  uint16_t tmp_mem_address = mem_address;

  /* Check for valid start address and valid data size */
  if ((tmp_mem_address >= EEPROM_24CW128X_START_MEM_ADDR) &&
 8028b12:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000

//============================================================================

/* Function to read data from EEPROM in case of read operation in multi-page, within more then one page */
EEPROM_STATUS_t bsp_eeprom_24cw128x_read_data(const uint16_t mem_address, uint8_t *rx_data, uint32_t rx_size)
{
 8028b16:	b086      	sub	sp, #24
 8028b18:	4681      	mov	r9, r0
 8028b1a:	4614      	mov	r4, r2
  uint32_t read_data = 0;
  uint32_t tmp_rx_size = rx_size;
  uint16_t tmp_mem_address = mem_address;

  /* Check for valid start address and valid data size */
  if ((tmp_mem_address >= EEPROM_24CW128X_START_MEM_ADDR) &&
 8028b1c:	d819      	bhi.n	8028b52 <bsp_eeprom_24cw128x_read_data+0x46>
	 ((tmp_mem_address + tmp_rx_size) <= EEPROM_24CW128X_MAX_SIZE) &&
 8028b1e:	b1c2      	cbz	r2, 8028b52 <bsp_eeprom_24cw128x_read_data+0x46>
  {
	/* The start read address is located in page : */
	nb_of_start_page = (tmp_mem_address / EEPROM_24CW128X_PAGE_SIZE) + 1;

	/* The last read address is located in page : */
	nb_of_end_page = ((tmp_mem_address + tmp_rx_size - 1) / EEPROM_24CW128X_PAGE_SIZE) + 1;
 8028b20:	3b01      	subs	r3, #1
 8028b22:	095b      	lsrs	r3, r3, #5
  if ((tmp_mem_address >= EEPROM_24CW128X_START_MEM_ADDR) &&
	 ((tmp_mem_address + tmp_rx_size) <= EEPROM_24CW128X_MAX_SIZE) &&
	 (tmp_rx_size > 0))
  {
	/* The start read address is located in page : */
	nb_of_start_page = (tmp_mem_address / EEPROM_24CW128X_PAGE_SIZE) + 1;
 8028b24:	0945      	lsrs	r5, r0, #5

	/* The last read address is located in page : */
	nb_of_end_page = ((tmp_mem_address + tmp_rx_size - 1) / EEPROM_24CW128X_PAGE_SIZE) + 1;
 8028b26:	3301      	adds	r3, #1
  if ((tmp_mem_address >= EEPROM_24CW128X_START_MEM_ADDR) &&
	 ((tmp_mem_address + tmp_rx_size) <= EEPROM_24CW128X_MAX_SIZE) &&
	 (tmp_rx_size > 0))
  {
	/* The start read address is located in page : */
	nb_of_start_page = (tmp_mem_address / EEPROM_24CW128X_PAGE_SIZE) + 1;
 8028b28:	3501      	adds	r5, #1

	/* The last read address is located in page : */
	nb_of_end_page = ((tmp_mem_address + tmp_rx_size - 1) / EEPROM_24CW128X_PAGE_SIZE) + 1;

	/* Read operation from multi-pages */
	if ((nb_of_end_page - nb_of_start_page) > 0)
 8028b2a:	42ab      	cmp	r3, r5
 8028b2c:	4688      	mov	r8, r1
 8028b2e:	f000 809b 	beq.w	8028c68 <bsp_eeprom_24cw128x_read_data+0x15c>
	{
	  /* Read the first part of data */
		read_data = (nb_of_start_page * EEPROM_24CW128X_PAGE_SIZE) - tmp_mem_address;

	  /* Write the first chunk of data */
	  if (read_data > 0)
 8028b32:	ebd0 1545 	rsbs	r5, r0, r5, lsl #5
 8028b36:	d139      	bne.n	8028bac <bsp_eeprom_24cw128x_read_data+0xa0>
//============================================================================

/* Function to read data from EEPROM in case of read operation in multi-page, within more then one page */
EEPROM_STATUS_t bsp_eeprom_24cw128x_read_data(const uint16_t mem_address, uint8_t *rx_data, uint32_t rx_size)
{
  I2C_MASTER_STATUS_t status = I2C_MASTER_STATUS_FAILURE;
 8028b38:	2001      	movs	r0, #1
		  /* EEPROM start read address */
          mem_add[0] = (tmp_mem_address & 0x3F00) >> 8;
          mem_add[1] = tmp_mem_address & 0x00FF;

          /* Send memory address */
          status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, mem_add, 2, false);
 8028b3a:	4e61      	ldr	r6, [pc, #388]	; (8028cc0 <bsp_eeprom_24cw128x_read_data+0x1b4>)
 8028b3c:	2702      	movs	r7, #2
	  }

	  /* Loop for the number of pages to be read */
	  do
	  {
		if (tmp_rx_size >= EEPROM_24CW128X_PAGE_SIZE) /* read one page data */
 8028b3e:	2c1f      	cmp	r4, #31
 8028b40:	d862      	bhi.n	8028c08 <bsp_eeprom_24cw128x_read_data+0xfc>
            tmp_mem_address = tmp_mem_address + EEPROM_24CW128X_PAGE_SIZE;
			tmp_rx_size = tmp_rx_size - EEPROM_24CW128X_PAGE_SIZE;
			read_data = read_data + EEPROM_24CW128X_PAGE_SIZE;
		  }
		}
		else if ((tmp_rx_size > 0) && (tmp_rx_size < EEPROM_24CW128X_PAGE_SIZE)) /* read the last chunk of data */
 8028b42:	1e63      	subs	r3, r4, #1
 8028b44:	2b1e      	cmp	r3, #30
 8028b46:	d908      	bls.n	8028b5a <bsp_eeprom_24cw128x_read_data+0x4e>
        while(I2C_MASTER_IsRxBusy(&I2C_MASTER_EEPROM));
      }
	}
  }

  if (status == I2C_MASTER_STATUS_SUCCESS)
 8028b48:	b918      	cbnz	r0, 8028b52 <bsp_eeprom_24cw128x_read_data+0x46>
  {
    return EEPROM_STATUS_SUCCESS;
 8028b4a:	2001      	movs	r0, #1
  }
  else
  {
    return EEPROM_STATUS_READ_ERROR;
  }
}
 8028b4c:	b006      	add	sp, #24
 8028b4e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  {
    return EEPROM_STATUS_SUCCESS;
  }
  else
  {
    return EEPROM_STATUS_READ_ERROR;
 8028b52:	2003      	movs	r0, #3
  }
}
 8028b54:	b006      	add	sp, #24
 8028b56:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		  /* EEPROM start read address */
          mem_add[0] = (tmp_mem_address & 0x3F00) >> 8;
          mem_add[1] = tmp_mem_address & 0x00FF;

          /* Send memory address */
          status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, mem_add, 2, false);
 8028b5a:	f8df a164 	ldr.w	sl, [pc, #356]	; 8028cc0 <bsp_eeprom_24cw128x_read_data+0x1b4>
 8028b5e:	9700      	str	r7, [sp, #0]
 8028b60:	2300      	movs	r3, #0
 8028b62:	9301      	str	r3, [sp, #4]
		  }
		}
		else if ((tmp_rx_size > 0) && (tmp_rx_size < EEPROM_24CW128X_PAGE_SIZE)) /* read the last chunk of data */
		{
		  /* EEPROM start read address */
          mem_add[0] = (tmp_mem_address & 0x3F00) >> 8;
 8028b64:	f3c9 2e05 	ubfx	lr, r9, #8, #6
          mem_add[1] = tmp_mem_address & 0x00FF;

          /* Send memory address */
          status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, mem_add, 2, false);
 8028b68:	22a0      	movs	r2, #160	; 0xa0
 8028b6a:	4650      	mov	r0, sl
 8028b6c:	2101      	movs	r1, #1
 8028b6e:	ab05      	add	r3, sp, #20
		}
		else if ((tmp_rx_size > 0) && (tmp_rx_size < EEPROM_24CW128X_PAGE_SIZE)) /* read the last chunk of data */
		{
		  /* EEPROM start read address */
          mem_add[0] = (tmp_mem_address & 0x3F00) >> 8;
          mem_add[1] = tmp_mem_address & 0x00FF;
 8028b70:	f88d 9015 	strb.w	r9, [sp, #21]
		  }
		}
		else if ((tmp_rx_size > 0) && (tmp_rx_size < EEPROM_24CW128X_PAGE_SIZE)) /* read the last chunk of data */
		{
		  /* EEPROM start read address */
          mem_add[0] = (tmp_mem_address & 0x3F00) >> 8;
 8028b74:	f88d e014 	strb.w	lr, [sp, #20]
          mem_add[1] = tmp_mem_address & 0x00FF;

          /* Send memory address */
          status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, mem_add, 2, false);
 8028b78:	f000 f932 	bl	8028de0 <I2C_MASTER_Transmit>
 8028b7c:	68b2      	ldr	r2, [r6, #8]
 8028b7e:	f892 3026 	ldrb.w	r3, [r2, #38]	; 0x26
          while(I2C_MASTER_IsTxBusy(&I2C_MASTER_EEPROM));
 8028b82:	2b00      	cmp	r3, #0
 8028b84:	d1fb      	bne.n	8028b7e <bsp_eeprom_24cw128x_read_data+0x72>

          if (status == I2C_MASTER_STATUS_SUCCESS)
 8028b86:	2800      	cmp	r0, #0
 8028b88:	d1d9      	bne.n	8028b3e <bsp_eeprom_24cw128x_read_data+0x32>
	      {
            /* Start reading data */
            status = I2C_MASTER_Receive(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, (rx_data + read_data), tmp_rx_size, true, true);
 8028b8a:	2101      	movs	r1, #1
 8028b8c:	22a0      	movs	r2, #160	; 0xa0
 8028b8e:	9400      	str	r4, [sp, #0]
 8028b90:	eb08 0305 	add.w	r3, r8, r5
 8028b94:	9101      	str	r1, [sp, #4]
 8028b96:	9102      	str	r1, [sp, #8]
 8028b98:	4849      	ldr	r0, [pc, #292]	; (8028cc0 <bsp_eeprom_24cw128x_read_data+0x1b4>)
 8028b9a:	f000 fa27 	bl	8028fec <I2C_MASTER_Receive>
 8028b9e:	f8da 2008 	ldr.w	r2, [sl, #8]
 *
 */
__STATIC_INLINE bool I2C_MASTER_IsRxBusy(I2C_MASTER_t * const handle)
{
  XMC_ASSERT("I2C_MASTER_IsRxBusy: invalid handle", (handle != NULL))	
  return handle->runtime->rx_busy;
 8028ba2:	f892 3027 	ldrb.w	r3, [r2, #39]	; 0x27
            while(I2C_MASTER_IsRxBusy(&I2C_MASTER_EEPROM));
 8028ba6:	2b00      	cmp	r3, #0
 8028ba8:	d1fb      	bne.n	8028ba2 <bsp_eeprom_24cw128x_read_data+0x96>
 8028baa:	e7cd      	b.n	8028b48 <bsp_eeprom_24cw128x_read_data+0x3c>
	    /* EEPROM start read address */
        mem_add[0] = (tmp_mem_address & 0x3F00) >> 8;
        mem_add[1] = tmp_mem_address & 0x00FF;

        /* Send memory address */
        status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, mem_add, 2, false);
 8028bac:	f8df a110 	ldr.w	sl, [pc, #272]	; 8028cc0 <bsp_eeprom_24cw128x_read_data+0x1b4>
	  /* Write the first chunk of data */
	  if (read_data > 0)
	  {
	    /* EEPROM start read address */
        mem_add[0] = (tmp_mem_address & 0x3F00) >> 8;
        mem_add[1] = tmp_mem_address & 0x00FF;
 8028bb0:	f88d 0015 	strb.w	r0, [sp, #21]

        /* Send memory address */
        status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, mem_add, 2, false);
 8028bb4:	2202      	movs	r2, #2
 8028bb6:	2300      	movs	r3, #0
 8028bb8:	e88d 000c 	stmia.w	sp, {r2, r3}
 8028bbc:	4650      	mov	r0, sl
 8028bbe:	22a0      	movs	r2, #160	; 0xa0

	  /* Write the first chunk of data */
	  if (read_data > 0)
	  {
	    /* EEPROM start read address */
        mem_add[0] = (tmp_mem_address & 0x3F00) >> 8;
 8028bc0:	f3c9 2605 	ubfx	r6, r9, #8, #6
        mem_add[1] = tmp_mem_address & 0x00FF;

        /* Send memory address */
        status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, mem_add, 2, false);
 8028bc4:	2101      	movs	r1, #1
 8028bc6:	ab05      	add	r3, sp, #20

	  /* Write the first chunk of data */
	  if (read_data > 0)
	  {
	    /* EEPROM start read address */
        mem_add[0] = (tmp_mem_address & 0x3F00) >> 8;
 8028bc8:	f88d 6014 	strb.w	r6, [sp, #20]
        mem_add[1] = tmp_mem_address & 0x00FF;

        /* Send memory address */
        status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, mem_add, 2, false);
 8028bcc:	f000 f908 	bl	8028de0 <I2C_MASTER_Transmit>
 8028bd0:	f8da 2008 	ldr.w	r2, [sl, #8]
 *
 */
__STATIC_INLINE bool I2C_MASTER_IsTxBusy(I2C_MASTER_t * const handle)
{
  XMC_ASSERT("I2C_MASTER_IsTxBusy: invalid handle", (handle != NULL))	
  return handle->runtime->tx_busy;
 8028bd4:	f892 3026 	ldrb.w	r3, [r2, #38]	; 0x26
        while(I2C_MASTER_IsTxBusy(&I2C_MASTER_EEPROM));
 8028bd8:	2b00      	cmp	r3, #0
 8028bda:	d1fb      	bne.n	8028bd4 <bsp_eeprom_24cw128x_read_data+0xc8>

        if (status == I2C_MASTER_STATUS_SUCCESS)
 8028bdc:	2800      	cmp	r0, #0
 8028bde:	d1ac      	bne.n	8028b3a <bsp_eeprom_24cw128x_read_data+0x2e>
	    {
          /* Start reading data */
          status = I2C_MASTER_Receive(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, rx_data, read_data, true, true);
 8028be0:	2101      	movs	r1, #1
 8028be2:	22a0      	movs	r2, #160	; 0xa0
 8028be4:	9500      	str	r5, [sp, #0]
 8028be6:	9101      	str	r1, [sp, #4]
 8028be8:	9102      	str	r1, [sp, #8]
 8028bea:	4835      	ldr	r0, [pc, #212]	; (8028cc0 <bsp_eeprom_24cw128x_read_data+0x1b4>)
 8028bec:	4643      	mov	r3, r8
 8028bee:	f000 f9fd 	bl	8028fec <I2C_MASTER_Receive>
 8028bf2:	f8da 2008 	ldr.w	r2, [sl, #8]
 *
 */
__STATIC_INLINE bool I2C_MASTER_IsRxBusy(I2C_MASTER_t * const handle)
{
  XMC_ASSERT("I2C_MASTER_IsRxBusy: invalid handle", (handle != NULL))	
  return handle->runtime->rx_busy;
 8028bf6:	f892 3027 	ldrb.w	r3, [r2, #39]	; 0x27
          while(I2C_MASTER_IsRxBusy(&I2C_MASTER_EEPROM));
 8028bfa:	2b00      	cmp	r3, #0
 8028bfc:	d1fb      	bne.n	8028bf6 <bsp_eeprom_24cw128x_read_data+0xea>

		  /* Remaining data */
          tmp_rx_size = tmp_rx_size - read_data;
          tmp_mem_address = tmp_mem_address + read_data;
 8028bfe:	44a9      	add	r9, r5
 8028c00:	fa1f f989 	uxth.w	r9, r9
          /* Start reading data */
          status = I2C_MASTER_Receive(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, rx_data, read_data, true, true);
          while(I2C_MASTER_IsRxBusy(&I2C_MASTER_EEPROM));

		  /* Remaining data */
          tmp_rx_size = tmp_rx_size - read_data;
 8028c04:	1b64      	subs	r4, r4, r5
 8028c06:	e798      	b.n	8028b3a <bsp_eeprom_24cw128x_read_data+0x2e>
		  /* EEPROM start read address */
          mem_add[0] = (tmp_mem_address & 0x3F00) >> 8;
          mem_add[1] = tmp_mem_address & 0x00FF;

          /* Send memory address */
          status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, mem_add, 2, false);
 8028c08:	2300      	movs	r3, #0
 8028c0a:	9301      	str	r3, [sp, #4]
	  do
	  {
		if (tmp_rx_size >= EEPROM_24CW128X_PAGE_SIZE) /* read one page data */
		{
		  /* EEPROM start read address */
          mem_add[0] = (tmp_mem_address & 0x3F00) >> 8;
 8028c0c:	f3c9 2e05 	ubfx	lr, r9, #8, #6
          mem_add[1] = tmp_mem_address & 0x00FF;

          /* Send memory address */
          status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, mem_add, 2, false);
 8028c10:	22a0      	movs	r2, #160	; 0xa0
 8028c12:	9700      	str	r7, [sp, #0]
 8028c14:	482a      	ldr	r0, [pc, #168]	; (8028cc0 <bsp_eeprom_24cw128x_read_data+0x1b4>)
	  {
		if (tmp_rx_size >= EEPROM_24CW128X_PAGE_SIZE) /* read one page data */
		{
		  /* EEPROM start read address */
          mem_add[0] = (tmp_mem_address & 0x3F00) >> 8;
          mem_add[1] = tmp_mem_address & 0x00FF;
 8028c16:	f88d 9015 	strb.w	r9, [sp, #21]

          /* Send memory address */
          status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, mem_add, 2, false);
 8028c1a:	2101      	movs	r1, #1
 8028c1c:	ab05      	add	r3, sp, #20
	  do
	  {
		if (tmp_rx_size >= EEPROM_24CW128X_PAGE_SIZE) /* read one page data */
		{
		  /* EEPROM start read address */
          mem_add[0] = (tmp_mem_address & 0x3F00) >> 8;
 8028c1e:	f88d e014 	strb.w	lr, [sp, #20]
          mem_add[1] = tmp_mem_address & 0x00FF;

          /* Send memory address */
          status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, mem_add, 2, false);
 8028c22:	f000 f8dd 	bl	8028de0 <I2C_MASTER_Transmit>
 8028c26:	68b2      	ldr	r2, [r6, #8]
 *
 */
__STATIC_INLINE bool I2C_MASTER_IsTxBusy(I2C_MASTER_t * const handle)
{
  XMC_ASSERT("I2C_MASTER_IsTxBusy: invalid handle", (handle != NULL))	
  return handle->runtime->tx_busy;
 8028c28:	f892 3026 	ldrb.w	r3, [r2, #38]	; 0x26
          while(I2C_MASTER_IsTxBusy(&I2C_MASTER_EEPROM));
 8028c2c:	2b00      	cmp	r3, #0
 8028c2e:	d1fb      	bne.n	8028c28 <bsp_eeprom_24cw128x_read_data+0x11c>

          if (status == I2C_MASTER_STATUS_SUCCESS)
 8028c30:	2800      	cmp	r0, #0
 8028c32:	d184      	bne.n	8028b3e <bsp_eeprom_24cw128x_read_data+0x32>
	      {
            /* Start reading data */
            status = I2C_MASTER_Receive(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, (rx_data + read_data), EEPROM_24CW128X_PAGE_SIZE, true, true);
 8028c34:	2101      	movs	r1, #1
 8028c36:	2320      	movs	r3, #32
 8028c38:	9300      	str	r3, [sp, #0]
 8028c3a:	22a0      	movs	r2, #160	; 0xa0
 8028c3c:	9101      	str	r1, [sp, #4]
 8028c3e:	9102      	str	r1, [sp, #8]
 8028c40:	481f      	ldr	r0, [pc, #124]	; (8028cc0 <bsp_eeprom_24cw128x_read_data+0x1b4>)
 8028c42:	eb08 0305 	add.w	r3, r8, r5
 8028c46:	f000 f9d1 	bl	8028fec <I2C_MASTER_Receive>
 8028c4a:	68b2      	ldr	r2, [r6, #8]
 *
 */
__STATIC_INLINE bool I2C_MASTER_IsRxBusy(I2C_MASTER_t * const handle)
{
  XMC_ASSERT("I2C_MASTER_IsRxBusy: invalid handle", (handle != NULL))	
  return handle->runtime->rx_busy;
 8028c4c:	f892 3027 	ldrb.w	r3, [r2, #39]	; 0x27
            while(I2C_MASTER_IsRxBusy(&I2C_MASTER_EEPROM));
 8028c50:	2b00      	cmp	r3, #0
 8028c52:	d1fb      	bne.n	8028c4c <bsp_eeprom_24cw128x_read_data+0x140>

		    /* Remaining data */
            tmp_mem_address = tmp_mem_address + EEPROM_24CW128X_PAGE_SIZE;
 8028c54:	f109 0920 	add.w	r9, r9, #32

		    /* No remaining data */
            tmp_rx_size = 0;
		  }
		}
	  }while(tmp_rx_size > 0);
 8028c58:	3c20      	subs	r4, #32
            /* Start reading data */
            status = I2C_MASTER_Receive(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, (rx_data + read_data), EEPROM_24CW128X_PAGE_SIZE, true, true);
            while(I2C_MASTER_IsRxBusy(&I2C_MASTER_EEPROM));

		    /* Remaining data */
            tmp_mem_address = tmp_mem_address + EEPROM_24CW128X_PAGE_SIZE;
 8028c5a:	fa1f f989 	uxth.w	r9, r9
			tmp_rx_size = tmp_rx_size - EEPROM_24CW128X_PAGE_SIZE;
			read_data = read_data + EEPROM_24CW128X_PAGE_SIZE;
 8028c5e:	f105 0520 	add.w	r5, r5, #32

		    /* No remaining data */
            tmp_rx_size = 0;
		  }
		}
	  }while(tmp_rx_size > 0);
 8028c62:	f47f af6c 	bne.w	8028b3e <bsp_eeprom_24cw128x_read_data+0x32>
 8028c66:	e76f      	b.n	8028b48 <bsp_eeprom_24cw128x_read_data+0x3c>
	  /* EEPROM start write address */
      mem_add[0] = (mem_address & 0x3F00) >> 8;
      mem_add[1] = mem_address & 0x00FF;

      /* Send memory address */
      status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, mem_add, 2, false);
 8028c68:	f8df a054 	ldr.w	sl, [pc, #84]	; 8028cc0 <bsp_eeprom_24cw128x_read_data+0x1b4>
	}
	else /* Read operation within the same page */
	{
	  /* EEPROM start write address */
      mem_add[0] = (mem_address & 0x3F00) >> 8;
      mem_add[1] = mem_address & 0x00FF;
 8028c6c:	f88d 0015 	strb.w	r0, [sp, #21]

      /* Send memory address */
      status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, mem_add, 2, false);
 8028c70:	2202      	movs	r2, #2
 8028c72:	2300      	movs	r3, #0
 8028c74:	e88d 000c 	stmia.w	sp, {r2, r3}
	  }while(tmp_rx_size > 0);
	}
	else /* Read operation within the same page */
	{
	  /* EEPROM start write address */
      mem_add[0] = (mem_address & 0x3F00) >> 8;
 8028c78:	f3c0 2905 	ubfx	r9, r0, #8, #6
      mem_add[1] = mem_address & 0x00FF;

      /* Send memory address */
      status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, mem_add, 2, false);
 8028c7c:	22a0      	movs	r2, #160	; 0xa0
 8028c7e:	4650      	mov	r0, sl
 8028c80:	2101      	movs	r1, #1
 8028c82:	ab05      	add	r3, sp, #20
	  }while(tmp_rx_size > 0);
	}
	else /* Read operation within the same page */
	{
	  /* EEPROM start write address */
      mem_add[0] = (mem_address & 0x3F00) >> 8;
 8028c84:	f88d 9014 	strb.w	r9, [sp, #20]
      mem_add[1] = mem_address & 0x00FF;

      /* Send memory address */
      status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, mem_add, 2, false);
 8028c88:	f000 f8aa 	bl	8028de0 <I2C_MASTER_Transmit>
 8028c8c:	f8da 2008 	ldr.w	r2, [sl, #8]
 *
 */
__STATIC_INLINE bool I2C_MASTER_IsTxBusy(I2C_MASTER_t * const handle)
{
  XMC_ASSERT("I2C_MASTER_IsTxBusy: invalid handle", (handle != NULL))	
  return handle->runtime->tx_busy;
 8028c90:	f892 3026 	ldrb.w	r3, [r2, #38]	; 0x26
      while(I2C_MASTER_IsTxBusy(&I2C_MASTER_EEPROM));
 8028c94:	2b00      	cmp	r3, #0
 8028c96:	d1fb      	bne.n	8028c90 <bsp_eeprom_24cw128x_read_data+0x184>

      if (status == I2C_MASTER_STATUS_SUCCESS)
 8028c98:	2800      	cmp	r0, #0
 8028c9a:	f47f af5a 	bne.w	8028b52 <bsp_eeprom_24cw128x_read_data+0x46>
	  {
        /* Start reading data */
        status = I2C_MASTER_Receive(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, rx_data, rx_size, true, true);
 8028c9e:	2101      	movs	r1, #1
 8028ca0:	22a0      	movs	r2, #160	; 0xa0
 8028ca2:	9400      	str	r4, [sp, #0]
 8028ca4:	4643      	mov	r3, r8
 8028ca6:	9101      	str	r1, [sp, #4]
 8028ca8:	9102      	str	r1, [sp, #8]
 8028caa:	4805      	ldr	r0, [pc, #20]	; (8028cc0 <bsp_eeprom_24cw128x_read_data+0x1b4>)
 8028cac:	f000 f99e 	bl	8028fec <I2C_MASTER_Receive>
 8028cb0:	f8da 2008 	ldr.w	r2, [sl, #8]
 *
 */
__STATIC_INLINE bool I2C_MASTER_IsRxBusy(I2C_MASTER_t * const handle)
{
  XMC_ASSERT("I2C_MASTER_IsRxBusy: invalid handle", (handle != NULL))	
  return handle->runtime->rx_busy;
 8028cb4:	f892 3027 	ldrb.w	r3, [r2, #39]	; 0x27
        while(I2C_MASTER_IsRxBusy(&I2C_MASTER_EEPROM));
 8028cb8:	2b00      	cmp	r3, #0
 8028cba:	d1fb      	bne.n	8028cb4 <bsp_eeprom_24cw128x_read_data+0x1a8>
 8028cbc:	e744      	b.n	8028b48 <bsp_eeprom_24cw128x_read_data+0x3c>
 8028cbe:	bf00      	nop
 8028cc0:	1ffe9600 	.word	0x1ffe9600

08028cc4 <bsp_time_delay>:

//============================================================================

/* Function used to generate a time in units of microseconds or milliseconds */
void bsp_time_delay(uint32_t delay_value, BSP_TIMER_DELAY_t time_unit)
{
 8028cc4:	b538      	push	{r3, r4, r5, lr}
 8028cc6:	4604      	mov	r4, r0
 8028cc8:	460d      	mov	r5, r1
  uint32_t delay_cnt;

  TIMER_ClearEvent(&EEPROM_TIMER_DELAY);
 8028cca:	480e      	ldr	r0, [pc, #56]	; (8028d04 <bsp_time_delay+0x40>)
 8028ccc:	f7fd f960 	bl	8025f90 <TIMER_ClearEvent>

  if (time_unit == BSP_TIMER_DELAY_MILLISECOND)
 8028cd0:	2d01      	cmp	r5, #1
  {
	/* Time in units of milliseconds */
	delay_cnt = (1000U * 100U) * delay_value;
 8028cd2:	bf08      	it	eq
 8028cd4:	4b0c      	ldreq	r3, [pc, #48]	; (8028d08 <bsp_time_delay+0x44>)
  {
	/* Time in units of microseconds */
    delay_cnt = delay_value;
  }

  TIMER_SetTimeInterval(&EEPROM_TIMER_DELAY, delay_cnt);
 8028cd6:	480b      	ldr	r0, [pc, #44]	; (8028d04 <bsp_time_delay+0x40>)
  TIMER_ClearEvent(&EEPROM_TIMER_DELAY);

  if (time_unit == BSP_TIMER_DELAY_MILLISECOND)
  {
	/* Time in units of milliseconds */
	delay_cnt = (1000U * 100U) * delay_value;
 8028cd8:	bf08      	it	eq
 8028cda:	435c      	muleq	r4, r3
  {
	/* Time in units of microseconds */
    delay_cnt = delay_value;
  }

  TIMER_SetTimeInterval(&EEPROM_TIMER_DELAY, delay_cnt);
 8028cdc:	4621      	mov	r1, r4
 8028cde:	f7fd f8eb 	bl	8025eb8 <TIMER_SetTimeInterval>

  TIMER_Start(&EEPROM_TIMER_DELAY);
 8028ce2:	4808      	ldr	r0, [pc, #32]	; (8028d04 <bsp_time_delay+0x40>)
 8028ce4:	f7fd f8c6 	bl	8025e74 <TIMER_Start>

  while(!TIMER_GetInterruptStatus(&EEPROM_TIMER_DELAY));
 8028ce8:	4806      	ldr	r0, [pc, #24]	; (8028d04 <bsp_time_delay+0x40>)
 8028cea:	f7fd f945 	bl	8025f78 <TIMER_GetInterruptStatus>
 8028cee:	2800      	cmp	r0, #0
 8028cf0:	d0fa      	beq.n	8028ce8 <bsp_time_delay+0x24>

  TIMER_Stop(&EEPROM_TIMER_DELAY);
 8028cf2:	4804      	ldr	r0, [pc, #16]	; (8028d04 <bsp_time_delay+0x40>)
 8028cf4:	f7fd f8ce 	bl	8025e94 <TIMER_Stop>

  TIMER_Clear(&EEPROM_TIMER_DELAY);
 8028cf8:	4802      	ldr	r0, [pc, #8]	; (8028d04 <bsp_time_delay+0x40>)
}
 8028cfa:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}

  while(!TIMER_GetInterruptStatus(&EEPROM_TIMER_DELAY));

  TIMER_Stop(&EEPROM_TIMER_DELAY);

  TIMER_Clear(&EEPROM_TIMER_DELAY);
 8028cfe:	f7fd b953 	b.w	8025fa8 <TIMER_Clear>
 8028d02:	bf00      	nop
 8028d04:	1ffe9198 	.word	0x1ffe9198
 8028d08:	000186a0 	.word	0x000186a0

08028d0c <bsp_led_green_on>:
#if !defined(BUILD_FOR_ARDUINO)

//============================================================================

void bsp_led_green_on(void)
{
 8028d0c:	4b03      	ldr	r3, [pc, #12]	; (8028d1c <bsp_led_green_on+0x10>)

__STATIC_INLINE void XMC_GPIO_SetOutputLow(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputLow: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = 0x10000U << pin;
 8028d0e:	7c19      	ldrb	r1, [r3, #16]
 8028d10:	681a      	ldr	r2, [r3, #0]
 8028d12:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8028d16:	408b      	lsls	r3, r1
 8028d18:	6053      	str	r3, [r2, #4]
 8028d1a:	4770      	bx	lr
 8028d1c:	0802de0c 	.word	0x0802de0c

08028d20 <bsp_led_green_off>:
}

//============================================================================

void bsp_led_green_off(void)
{
 8028d20:	4b03      	ldr	r3, [pc, #12]	; (8028d30 <bsp_led_green_off+0x10>)

__STATIC_INLINE void XMC_GPIO_SetOutputHigh(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputHigh: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = (uint32_t)0x1U << pin;
 8028d22:	7c19      	ldrb	r1, [r3, #16]
 8028d24:	681a      	ldr	r2, [r3, #0]
 8028d26:	2301      	movs	r3, #1
 8028d28:	408b      	lsls	r3, r1
 8028d2a:	6053      	str	r3, [r2, #4]
 8028d2c:	4770      	bx	lr
 8028d2e:	bf00      	nop
 8028d30:	0802de0c 	.word	0x0802de0c

08028d34 <bsp_led_blue_on>:
  DIGITAL_IO_ToggleOutput(&DIGITAL_IO_GREEN_LED);
}
//============================================================================

void bsp_led_blue_on(void)
{
 8028d34:	4b03      	ldr	r3, [pc, #12]	; (8028d44 <bsp_led_blue_on+0x10>)

__STATIC_INLINE void XMC_GPIO_SetOutputLow(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputLow: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = 0x10000U << pin;
 8028d36:	7c19      	ldrb	r1, [r3, #16]
 8028d38:	681a      	ldr	r2, [r3, #0]
 8028d3a:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8028d3e:	408b      	lsls	r3, r1
 8028d40:	6053      	str	r3, [r2, #4]
 8028d42:	4770      	bx	lr
 8028d44:	0802de34 	.word	0x0802de34

08028d48 <bsp_led_blue_off>:
}

//============================================================================

void bsp_led_blue_off(void)
{
 8028d48:	4b03      	ldr	r3, [pc, #12]	; (8028d58 <bsp_led_blue_off+0x10>)

__STATIC_INLINE void XMC_GPIO_SetOutputHigh(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputHigh: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = (uint32_t)0x1U << pin;
 8028d4a:	7c19      	ldrb	r1, [r3, #16]
 8028d4c:	681a      	ldr	r2, [r3, #0]
 8028d4e:	2301      	movs	r3, #1
 8028d50:	408b      	lsls	r3, r1
 8028d52:	6053      	str	r3, [r2, #4]
 8028d54:	4770      	bx	lr
 8028d56:	bf00      	nop
 8028d58:	0802de34 	.word	0x0802de34

08028d5c <bsp_led_red_on>:
}

//============================================================================

void bsp_led_red_on(void)
{
 8028d5c:	4b03      	ldr	r3, [pc, #12]	; (8028d6c <bsp_led_red_on+0x10>)

__STATIC_INLINE void XMC_GPIO_SetOutputLow(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputLow: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = 0x10000U << pin;
 8028d5e:	7c19      	ldrb	r1, [r3, #16]
 8028d60:	681a      	ldr	r2, [r3, #0]
 8028d62:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8028d66:	408b      	lsls	r3, r1
 8028d68:	6053      	str	r3, [r2, #4]
 8028d6a:	4770      	bx	lr
 8028d6c:	0802de20 	.word	0x0802de20

08028d70 <bsp_led_red_off>:
}

//============================================================================

void bsp_led_red_off(void)
{
 8028d70:	4b03      	ldr	r3, [pc, #12]	; (8028d80 <bsp_led_red_off+0x10>)

__STATIC_INLINE void XMC_GPIO_SetOutputHigh(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputHigh: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = (uint32_t)0x1U << pin;
 8028d72:	7c19      	ldrb	r1, [r3, #16]
 8028d74:	681a      	ldr	r2, [r3, #0]
 8028d76:	2301      	movs	r3, #1
 8028d78:	408b      	lsls	r3, r1
 8028d7a:	6053      	str	r3, [r2, #4]
 8028d7c:	4770      	bx	lr
 8028d7e:	bf00      	nop
 8028d80:	0802de20 	.word	0x0802de20

08028d84 <bsp_led_red_toggle>:
}

//============================================================================

void bsp_led_red_toggle(void)
{
 8028d84:	4b03      	ldr	r3, [pc, #12]	; (8028d94 <bsp_led_red_toggle+0x10>)

__STATIC_INLINE void XMC_GPIO_ToggleOutput(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_ToggleOutput: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = 0x10001U << pin;
 8028d86:	7c19      	ldrb	r1, [r3, #16]
 8028d88:	681a      	ldr	r2, [r3, #0]
 8028d8a:	f04f 1301 	mov.w	r3, #65537	; 0x10001
 8028d8e:	408b      	lsls	r3, r1
 8028d90:	6053      	str	r3, [r2, #4]
 8028d92:	4770      	bx	lr
 8028d94:	0802de20 	.word	0x0802de20

08028d98 <com_init>:
   6. EXPORTED FUNCTIONS
==============================================================================
 */
   
   void com_init(void)
   {
 8028d98:	4770      	bx	lr
 8028d9a:	bf00      	nop

08028d9c <com_send_data>:

//============================================================================

void com_send_data(const void* pData, uint16_t uNumBytes)
{
  USBD_VCOM_SendData(pData,uNumBytes);
 8028d9c:	f7fc b900 	b.w	8024fa0 <USBD_VCOM_SendData>

08028da0 <com_get_data>:
}

//============================================================================

uint16_t com_get_data(void* pData, uint16_t uNumBytes)
{
 8028da0:	b538      	push	{r3, r4, r5, lr}
 8028da2:	460c      	mov	r4, r1
 8028da4:	4605      	mov	r5, r0
  uint16_t bytes = 0;
  
  bytes = USBD_VCOM_BytesReceived();
 8028da6:	f7fc f939 	bl	802501c <USBD_VCOM_BytesReceived>
  
  bytes = (bytes > uNumBytes) ? uNumBytes : bytes;
 8028daa:	42a0      	cmp	r0, r4
 8028dac:	bf28      	it	cs
 8028dae:	4620      	movcs	r0, r4
 8028db0:	b284      	uxth	r4, r0
  
  if (bytes)
 8028db2:	b11c      	cbz	r4, 8028dbc <com_get_data+0x1c>
  {
    USBD_VCOM_ReceiveData((int8_t*)pData, bytes);
 8028db4:	4628      	mov	r0, r5
 8028db6:	4621      	mov	r1, r4
 8028db8:	f7fc f90c 	bl	8024fd4 <USBD_VCOM_ReceiveData>
  }
  
  return (bytes);
}
 8028dbc:	4620      	mov	r0, r4
 8028dbe:	bd38      	pop	{r3, r4, r5, pc}

08028dc0 <com_flush>:

//============================================================================

void com_flush(void)
{
  CDC_Device_USBTask(&USBD_VCOM_cdc_interface);	/* Do nothing as USBD VCOM already flushes the data that is sent */
 8028dc0:	4801      	ldr	r0, [pc, #4]	; (8028dc8 <com_flush+0x8>)
 8028dc2:	f7fb bf35 	b.w	8024c30 <CDC_Device_USBTask>
 8028dc6:	bf00      	nop
 8028dc8:	1fff0368 	.word	0x1fff0368

08028dcc <I2C_MASTER_Init>:
/* Function to initialize the USIC Channel with GUI configured values.*/
I2C_MASTER_STATUS_t I2C_MASTER_Init(const I2C_MASTER_t *const handle)
{
  I2C_MASTER_STATUS_t status;

  if (handle != NULL)
 8028dcc:	b128      	cbz	r0, 8028dda <I2C_MASTER_Init+0xe>
  return (version);
}

/* Function to initialize the USIC Channel with GUI configured values.*/
I2C_MASTER_STATUS_t I2C_MASTER_Init(const I2C_MASTER_t *const handle)
{
 8028dce:	b508      	push	{r3, lr}
  I2C_MASTER_STATUS_t status;

  if (handle != NULL)
  {
    /*Initialize the multiplexers required for I2C_MASTER configuration*/
    handle->config->fptr_i2c_config();
 8028dd0:	6843      	ldr	r3, [r0, #4]
 8028dd2:	685b      	ldr	r3, [r3, #4]
 8028dd4:	4798      	blx	r3

    status = I2C_MASTER_STATUS_SUCCESS;
 8028dd6:	2000      	movs	r0, #0
 8028dd8:	bd08      	pop	{r3, pc}
  }
  else
  {
    status = I2C_MASTER_STATUS_FAILURE;
 8028dda:	2001      	movs	r0, #1
 8028ddc:	4770      	bx	lr
 8028dde:	bf00      	nop

08028de0 <I2C_MASTER_Transmit>:
}

/* Function to transmit the data to slave device */
I2C_MASTER_STATUS_t I2C_MASTER_Transmit(I2C_MASTER_t *handle, bool send_start, const uint32_t address,
                                        uint8_t *data, const uint32_t size, bool send_stop)
{
 8028de0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8028de4:	4605      	mov	r5, r0
  I2C_MASTER_STATUS_t status;

  status = I2C_MASTER_STATUS_BUSY;

  if (handle->config->transmit_mode == I2C_MASTER_TRANSFER_MODE_INTERRUPT)
 8028de6:	6840      	ldr	r0, [r0, #4]
}

/* Function to transmit the data to slave device */
I2C_MASTER_STATUS_t I2C_MASTER_Transmit(I2C_MASTER_t *handle, bool send_start, const uint32_t address,
                                        uint8_t *data, const uint32_t size, bool send_stop)
{
 8028de8:	9f08      	ldr	r7, [sp, #32]
  I2C_MASTER_STATUS_t status;

  status = I2C_MASTER_STATUS_BUSY;

  if (handle->config->transmit_mode == I2C_MASTER_TRANSFER_MODE_INTERRUPT)
 8028dea:	f890 4024 	ldrb.w	r4, [r0, #36]	; 0x24
}

/* Function to transmit the data to slave device */
I2C_MASTER_STATUS_t I2C_MASTER_Transmit(I2C_MASTER_t *handle, bool send_start, const uint32_t address,
                                        uint8_t *data, const uint32_t size, bool send_stop)
{
 8028dee:	f89d 8024 	ldrb.w	r8, [sp, #36]	; 0x24
  I2C_MASTER_STATUS_t status;

  status = I2C_MASTER_STATUS_BUSY;

  if (handle->config->transmit_mode == I2C_MASTER_TRANSFER_MODE_INTERRUPT)
 8028df2:	2c01      	cmp	r4, #1
 8028df4:	d802      	bhi.n	8028dfc <I2C_MASTER_Transmit+0x1c>
I2C_MASTER_STATUS_t I2C_MASTER_Transmit(I2C_MASTER_t *handle, bool send_start, const uint32_t address,
                                        uint8_t *data, const uint32_t size, bool send_stop)
{
  I2C_MASTER_STATUS_t status;

  status = I2C_MASTER_STATUS_BUSY;
 8028df6:	2002      	movs	r0, #2
 8028df8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8028dfc:	4699      	mov	r9, r3

  status = I2C_MASTER_STATUS_BUSY;

  buffer_index = 0U;

  if ((((send_start == false) && (handle->runtime->bus_acquired == false)) || (data == NULL) || (size == 0U)))
 8028dfe:	b921      	cbnz	r1, 8028e0a <I2C_MASTER_Transmit+0x2a>
 8028e00:	68ab      	ldr	r3, [r5, #8]
 8028e02:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8028e06:	2b00      	cmp	r3, #0
 8028e08:	d04c      	beq.n	8028ea4 <I2C_MASTER_Transmit+0xc4>
 8028e0a:	f1b9 0f00 	cmp.w	r9, #0
 8028e0e:	d049      	beq.n	8028ea4 <I2C_MASTER_Transmit+0xc4>
 8028e10:	2f00      	cmp	r7, #0
 8028e12:	d047      	beq.n	8028ea4 <I2C_MASTER_Transmit+0xc4>
  {
    status = I2C_MASTER_STATUS_FAILURE;
  }
  else
  {
    if (send_start == true)
 8028e14:	2900      	cmp	r1, #0
 8028e16:	d04a      	beq.n	8028eae <I2C_MASTER_Transmit+0xce>
    {
      if (handle->runtime->bus_acquired == false)
 8028e18:	68a9      	ldr	r1, [r5, #8]
 8028e1a:	f891 3028 	ldrb.w	r3, [r1, #40]	; 0x28
 8028e1e:	f003 04ff 	and.w	r4, r3, #255	; 0xff
 8028e22:	2b00      	cmp	r3, #0
 8028e24:	f000 8089 	beq.w	8028f3a <I2C_MASTER_Transmit+0x15a>
 8028e28:	4602      	mov	r2, r0
 8028e2a:	6828      	ldr	r0, [r5, #0]
        }

        I2C_MASTER_ClearFlag(handle, (uint32_t)XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED);
      }
    }
    if (handle->config->txFIFO_size == XMC_USIC_CH_FIFO_DISABLED)
 8028e2c:	f892 3026 	ldrb.w	r3, [r2, #38]	; 0x26
 8028e30:	2b00      	cmp	r3, #0
 8028e32:	d042      	beq.n	8028eba <I2C_MASTER_Transmit+0xda>
    else
    {
      while (buffer_index < size)
      {
        /* Fill the transmit FIFO */
        while (I2C_MASTER_IsTXFIFOFull(handle) == false)
 8028e34:	2400      	movs	r4, #0
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_TXFIFO_IsEmpty(), XMC_USIC_CH_TXFIFO_Flush() \n\n\n
 */
__STATIC_INLINE bool XMC_USIC_CH_TXFIFO_IsFull(XMC_USIC_CH_t *const channel)
{
  return (bool)(channel->TRBSR & USIC_CH_TRBSR_TFULL_Msk);
 8028e36:	f8d0 3114 	ldr.w	r3, [r0, #276]	; 0x114
 8028e3a:	04da      	lsls	r2, r3, #19
 8028e3c:	d411      	bmi.n	8028e62 <I2C_MASTER_Transmit+0x82>
        {
          /* transmit each byte till index reaches to the last byte */
          if (buffer_index < size)
 8028e3e:	42a7      	cmp	r7, r4
 8028e40:	d933      	bls.n	8028eaa <I2C_MASTER_Transmit+0xca>
 8028e42:	eb09 0604 	add.w	r6, r9, r4
 8028e46:	e001      	b.n	8028e4c <I2C_MASTER_Transmit+0x6c>
 8028e48:	42a7      	cmp	r7, r4
 8028e4a:	d92e      	bls.n	8028eaa <I2C_MASTER_Transmit+0xca>
 * @endcode
 */
__STATIC_INLINE void I2C_MASTER_TransmitByte(I2C_MASTER_t * const handle, uint8_t byte)
{
  XMC_ASSERT("I2C_MASTER_TransmitByte: invalid handle", (handle != NULL))
  XMC_I2C_CH_MasterTransmit(handle->channel, byte);
 8028e4c:	f816 1b01 	ldrb.w	r1, [r6], #1
 8028e50:	f7f9 f88c 	bl	8021f6c <XMC_I2C_CH_MasterTransmit>
 8028e54:	6828      	ldr	r0, [r5, #0]
 8028e56:	f8d0 3114 	ldr.w	r3, [r0, #276]	; 0x114
    else
    {
      while (buffer_index < size)
      {
        /* Fill the transmit FIFO */
        while (I2C_MASTER_IsTXFIFOFull(handle) == false)
 8028e5a:	04d9      	lsls	r1, r3, #19
          /* transmit each byte till index reaches to the last byte */
          if (buffer_index < size)
          {
            /* load the FIFO, byte by byte till either FIFO is full or all data is loaded*/
            I2C_MASTER_TransmitByte(handle, data[buffer_index]);
            buffer_index++;
 8028e5c:	f104 0401 	add.w	r4, r4, #1
    else
    {
      while (buffer_index < size)
      {
        /* Fill the transmit FIFO */
        while (I2C_MASTER_IsTXFIFOFull(handle) == false)
 8028e60:	d5f2      	bpl.n	8028e48 <I2C_MASTER_Transmit+0x68>
        buffer_index++;
      }
    }
    else
    {
      while (buffer_index < size)
 8028e62:	42a7      	cmp	r7, r4
      {
        /* Fill the transmit FIFO */
        while (I2C_MASTER_IsTXFIFOFull(handle) == false)
 8028e64:	4602      	mov	r2, r0
        buffer_index++;
      }
    }
    else
    {
      while (buffer_index < size)
 8028e66:	d8e6      	bhi.n	8028e36 <I2C_MASTER_Transmit+0x56>
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_TXFIFO_Flush(), XMC_USIC_CH_TXFIFO_PutData() \n\n\n
 */
__STATIC_INLINE bool XMC_USIC_CH_TXFIFO_IsEmpty(XMC_USIC_CH_t *const channel)
{
  return (bool)(channel->TRBSR & USIC_CH_TRBSR_TEMPTY_Msk);
 8028e68:	f8d0 3114 	ldr.w	r3, [r0, #276]	; 0x114
            break;
          }
        }
      }
      /*make sure data is transmitted from FIFO*/
      while (!XMC_USIC_CH_TXFIFO_IsEmpty(handle->channel)){}
 8028e6c:	051b      	lsls	r3, r3, #20
 8028e6e:	d5fb      	bpl.n	8028e68 <I2C_MASTER_Transmit+0x88>
    }

    if (send_stop == true)
 8028e70:	f1b8 0f00 	cmp.w	r8, #0
 8028e74:	f040 8094 	bne.w	8028fa0 <I2C_MASTER_Transmit+0x1c0>
    {
      handle->runtime->bus_acquired = false;
      I2C_MASTER_SendStop(handle);
    }

    status = I2C_MASTER_STATUS_SUCCESS;
 8028e78:	4640      	mov	r0, r8
 8028e7a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
                            (uint32_t)XMC_I2C_CH_STATUS_FLAG_ARBITRATION_LOST |
                            (uint32_t)XMC_I2C_CH_STATUS_FLAG_ERROR |
                            (uint32_t)XMC_I2C_CH_STATUS_FLAG_WRONG_TDF_CODE_FOUND))
          {
   	        /* Check for NACK event */
    	    if (psr_status & (uint32_t)XMC_I2C_CH_STATUS_FLAG_NACK_RECEIVED)
 8028e7e:	0690      	lsls	r0, r2, #26
 8028e80:	d503      	bpl.n	8028e8a <I2C_MASTER_Transmit+0xaa>
 8028e82:	6cd9      	ldr	r1, [r3, #76]	; 0x4c
 8028e84:	f041 0120 	orr.w	r1, r1, #32
 8028e88:	64d9      	str	r1, [r3, #76]	; 0x4c
    	    {
    	      I2C_MASTER_ClearFlag(handle,(uint32_t)XMC_I2C_CH_STATUS_FLAG_NACK_RECEIVED);
    	    }

    	    /* Check for arbitration lost */
    	    if (psr_status & (uint32_t)XMC_I2C_CH_STATUS_FLAG_ARBITRATION_LOST)
 8028e8a:	0651      	lsls	r1, r2, #25
 8028e8c:	d503      	bpl.n	8028e96 <I2C_MASTER_Transmit+0xb6>
 8028e8e:	6cd9      	ldr	r1, [r3, #76]	; 0x4c
 8028e90:	f041 0140 	orr.w	r1, r1, #64	; 0x40
 8028e94:	64d9      	str	r1, [r3, #76]	; 0x4c
    	    {
    	      I2C_MASTER_ClearFlag(handle,(uint32_t)XMC_I2C_CH_STATUS_FLAG_ARBITRATION_LOST);
    	    }

    	    /* Check for error detected */
    	    if (psr_status & ((uint32_t)XMC_I2C_CH_STATUS_FLAG_ERROR | (uint32_t)XMC_I2C_CH_STATUS_FLAG_WRONG_TDF_CODE_FOUND))
 8028e96:	f412 7f81 	tst.w	r2, #258	; 0x102
 8028e9a:	d003      	beq.n	8028ea4 <I2C_MASTER_Transmit+0xc4>
 8028e9c:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8028e9e:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8028ea2:	64da      	str	r2, [r3, #76]	; 0x4c
    	    {
    	      I2C_MASTER_ClearFlag(handle,(uint32_t)XMC_I2C_CH_STATUS_FLAG_ERROR);
    	    }

            status = I2C_MASTER_STATUS_FAILURE;
            return (status);
 8028ea4:	2001      	movs	r0, #1
 8028ea6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      {
        /* Fill the transmit FIFO */
        while (I2C_MASTER_IsTXFIFOFull(handle) == false)
        {
          /* transmit each byte till index reaches to the last byte */
          if (buffer_index < size)
 8028eaa:	4602      	mov	r2, r0
 8028eac:	e7dc      	b.n	8028e68 <I2C_MASTER_Transmit+0x88>
        }

        I2C_MASTER_ClearFlag(handle, (uint32_t)XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED);
      }
    }
    if (handle->config->txFIFO_size == XMC_USIC_CH_FIFO_DISABLED)
 8028eae:	f890 3026 	ldrb.w	r3, [r0, #38]	; 0x26
 8028eb2:	2b00      	cmp	r3, #0
 8028eb4:	d03f      	beq.n	8028f36 <I2C_MASTER_Transmit+0x156>
 8028eb6:	6828      	ldr	r0, [r5, #0]
 8028eb8:	e7bc      	b.n	8028e34 <I2C_MASTER_Transmit+0x54>
 8028eba:	4602      	mov	r2, r0
 8028ebc:	4e48      	ldr	r6, [pc, #288]	; (8028fe0 <I2C_MASTER_Transmit+0x200>)
      while (buffer_index < size)
      {
        I2C_MASTER_TransmitByte(handle, data[buffer_index]);

        /* Wait for ACK or timeout */
        I2C_Timeout = 0X2FFFFF;
 8028ebe:	4c49      	ldr	r4, [pc, #292]	; (8028fe4 <I2C_MASTER_Transmit+0x204>)
 8028ec0:	444f      	add	r7, r9
 8028ec2:	46b2      	mov	sl, r6
 8028ec4:	4610      	mov	r0, r2
 8028ec6:	f819 1b01 	ldrb.w	r1, [r9], #1
 8028eca:	f7f9 f84f 	bl	8021f6c <XMC_I2C_CH_MasterTransmit>
/* Function to get flag status of the requested parameter */
uint32_t I2C_MASTER_GetFlagStatus(const I2C_MASTER_t *handle, uint32_t flagtype)
{
  uint32_t status;

  status = XMC_I2C_CH_GetStatusFlag(handle->channel);
 8028ece:	682a      	ldr	r2, [r5, #0]
      while (buffer_index < size)
      {
        I2C_MASTER_TransmitByte(handle, data[buffer_index]);

        /* Wait for ACK or timeout */
        I2C_Timeout = 0X2FFFFF;
 8028ed0:	6034      	str	r4, [r6, #0]
 * \par<b>Related APIs:</b><br>
 * XMC_I2C_CH_ClearStatusFlag()\n\n
 */
__STATIC_INLINE uint32_t XMC_I2C_CH_GetStatusFlag(XMC_USIC_CH_t *const channel)
{
  return (channel->PSR_IICMode);
 8028ed2:	6c93      	ldr	r3, [r2, #72]	; 0x48
        psr_status = 0;
        while ((I2C_MASTER_GetFlagStatus(handle, (uint32_t)XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED) == 0U) && (I2C_Timeout > 0))
 8028ed4:	059b      	lsls	r3, r3, #22
 8028ed6:	d50a      	bpl.n	8028eee <I2C_MASTER_Transmit+0x10e>
 8028ed8:	e00d      	b.n	8028ef6 <I2C_MASTER_Transmit+0x116>
 8028eda:	6c93      	ldr	r3, [r2, #72]	; 0x48
        {
          /* Get flag status */
          psr_status = XMC_I2C_CH_GetStatusFlag(handle->channel);

          /* Check if an error flag is set */
          if (psr_status & ((uint32_t)XMC_I2C_CH_STATUS_FLAG_NACK_RECEIVED |
 8028edc:	f413 7fb1 	tst.w	r3, #354	; 0x162
 8028ee0:	d113      	bne.n	8028f0a <I2C_MASTER_Transmit+0x12a>

            status = I2C_MASTER_STATUS_FAILURE;
            return (status);
          }

          I2C_Timeout--;
 8028ee2:	6833      	ldr	r3, [r6, #0]
 8028ee4:	3b01      	subs	r3, #1
 8028ee6:	6033      	str	r3, [r6, #0]
 8028ee8:	6c93      	ldr	r3, [r2, #72]	; 0x48
        I2C_MASTER_TransmitByte(handle, data[buffer_index]);

        /* Wait for ACK or timeout */
        I2C_Timeout = 0X2FFFFF;
        psr_status = 0;
        while ((I2C_MASTER_GetFlagStatus(handle, (uint32_t)XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED) == 0U) && (I2C_Timeout > 0))
 8028eea:	0598      	lsls	r0, r3, #22
 8028eec:	d403      	bmi.n	8028ef6 <I2C_MASTER_Transmit+0x116>
 8028eee:	f8da 3000 	ldr.w	r3, [sl]
 8028ef2:	2b00      	cmp	r3, #0
 8028ef4:	d1f1      	bne.n	8028eda <I2C_MASTER_Transmit+0xfa>

          I2C_Timeout--;
        }

        /* Undefined error, return Timeout */
        if (I2C_Timeout == 0)
 8028ef6:	6833      	ldr	r3, [r6, #0]
 8028ef8:	2b00      	cmp	r3, #0
 8028efa:	d04e      	beq.n	8028f9a <I2C_MASTER_Transmit+0x1ba>
 * \par<b>Related APIs:</b><br>
 * XMC_I2C_CH_GetStatusFlag()\n\n
 */
__STATIC_INLINE void XMC_I2C_CH_ClearStatusFlag(XMC_USIC_CH_t *const channel, uint32_t flag)
{
  channel->PSCR |= flag;
 8028efc:	6cd3      	ldr	r3, [r2, #76]	; 0x4c
      }
    }
    if (handle->config->txFIFO_size == XMC_USIC_CH_FIFO_DISABLED)
    {
      /* send data, byte by byte */
      while (buffer_index < size)
 8028efe:	45b9      	cmp	r9, r7
 8028f00:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8028f04:	64d3      	str	r3, [r2, #76]	; 0x4c
 8028f06:	d1dd      	bne.n	8028ec4 <I2C_MASTER_Transmit+0xe4>
 8028f08:	e7b2      	b.n	8028e70 <I2C_MASTER_Transmit+0x90>
                            (uint32_t)XMC_I2C_CH_STATUS_FLAG_ARBITRATION_LOST |
                            (uint32_t)XMC_I2C_CH_STATUS_FLAG_ERROR |
                            (uint32_t)XMC_I2C_CH_STATUS_FLAG_WRONG_TDF_CODE_FOUND))
          {
	        /* Check for NACK event */
	        if (psr_status & (uint32_t)XMC_I2C_CH_STATUS_FLAG_NACK_RECEIVED)
 8028f0a:	069d      	lsls	r5, r3, #26
 8028f0c:	d503      	bpl.n	8028f16 <I2C_MASTER_Transmit+0x136>
 8028f0e:	6cd1      	ldr	r1, [r2, #76]	; 0x4c
 8028f10:	f041 0120 	orr.w	r1, r1, #32
 8028f14:	64d1      	str	r1, [r2, #76]	; 0x4c
	        {
	          I2C_MASTER_ClearFlag(handle,(uint32_t)XMC_I2C_CH_STATUS_FLAG_NACK_RECEIVED);
	        }

	        /* Check for arbitration lost */
	        if (psr_status & (uint32_t)XMC_I2C_CH_STATUS_FLAG_ARBITRATION_LOST)
 8028f16:	065c      	lsls	r4, r3, #25
 8028f18:	d503      	bpl.n	8028f22 <I2C_MASTER_Transmit+0x142>
 8028f1a:	6cd1      	ldr	r1, [r2, #76]	; 0x4c
 8028f1c:	f041 0140 	orr.w	r1, r1, #64	; 0x40
 8028f20:	64d1      	str	r1, [r2, #76]	; 0x4c
	        {
	          I2C_MASTER_ClearFlag(handle,(uint32_t)XMC_I2C_CH_STATUS_FLAG_ARBITRATION_LOST);
	        }

	        /* Check for error detected */
	        if (psr_status & ((uint32_t)XMC_I2C_CH_STATUS_FLAG_ERROR | (uint32_t)XMC_I2C_CH_STATUS_FLAG_WRONG_TDF_CODE_FOUND))
 8028f22:	f413 7f81 	tst.w	r3, #258	; 0x102
 8028f26:	d0bd      	beq.n	8028ea4 <I2C_MASTER_Transmit+0xc4>
 8028f28:	6cd3      	ldr	r3, [r2, #76]	; 0x4c
 8028f2a:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8028f2e:	64d3      	str	r3, [r2, #76]	; 0x4c
	        {
	          I2C_MASTER_ClearFlag(handle,(uint32_t)XMC_I2C_CH_STATUS_FLAG_ERROR);
	        }

            status = I2C_MASTER_STATUS_FAILURE;
            return (status);
 8028f30:	2001      	movs	r0, #1
 8028f32:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8028f36:	682a      	ldr	r2, [r5, #0]
 8028f38:	e7c0      	b.n	8028ebc <I2C_MASTER_Transmit+0xdc>
    (I2C_MASTER_DIRECT_TX_ENABLED == 1) || (I2C_MASTER_DIRECT_RX_ENABLED == 1))
/* Function to issue Send Start/Repeated Start command */
static void I2C_MASTER_lSendStart_Or_RepeatedStart(I2C_MASTER_t * handle,const uint32_t address,
                                               const XMC_I2C_CH_CMD_t cmd)
{
  if (handle->runtime->bus_acquired == true)
 8028f3a:	f891 3028 	ldrb.w	r3, [r1, #40]	; 0x28
 8028f3e:	f003 06ff 	and.w	r6, r3, #255	; 0xff
 8028f42:	2b00      	cmp	r3, #0
 8028f44:	d13b      	bne.n	8028fbe <I2C_MASTER_Transmit+0x1de>
 8028f46:	6828      	ldr	r0, [r5, #0]
  {
  I2C_MASTER_SendRepeatedStart(handle, (uint16_t)address, cmd);
  }
  else
  {
    handle->runtime->bus_acquired = true;
 8028f48:	2301      	movs	r3, #1
 8028f4a:	f881 3028 	strb.w	r3, [r1, #40]	; 0x28
 8028f4e:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 8028f50:	f043 0304 	orr.w	r3, r3, #4
__STATIC_INLINE void I2C_MASTER_SendStart(I2C_MASTER_t * const handle, const uint32_t address,
		                                  const XMC_I2C_CH_CMD_t cmd)
{
  XMC_ASSERT("I2C_MASTER_SendStart: invalid handle", (handle != NULL))
  XMC_I2C_CH_ClearStatusFlag(handle->channel, XMC_I2C_CH_STATUS_FLAG_START_CONDITION_RECEIVED);
  XMC_I2C_CH_MasterStart(handle->channel, (uint16_t)address, cmd);
 8028f54:	b291      	uxth	r1, r2
 8028f56:	64c3      	str	r3, [r0, #76]	; 0x4c
 8028f58:	4632      	mov	r2, r6
 8028f5a:	f7f8 ffc1 	bl	8021ee0 <XMC_I2C_CH_MasterStart>
      if (handle->runtime->bus_acquired == false)
      {
        I2C_MASTER_lSendStart_Or_RepeatedStart(handle, slave_address, XMC_I2C_CH_CMD_WRITE);

        /* Wait for ACK or timeout */
        I2C_Timeout = 0X1FFFFF;
 8028f5e:	4e20      	ldr	r6, [pc, #128]	; (8028fe0 <I2C_MASTER_Transmit+0x200>)
 8028f60:	4a21      	ldr	r2, [pc, #132]	; (8028fe8 <I2C_MASTER_Transmit+0x208>)
/* Function to get flag status of the requested parameter */
uint32_t I2C_MASTER_GetFlagStatus(const I2C_MASTER_t *handle, uint32_t flagtype)
{
  uint32_t status;

  status = XMC_I2C_CH_GetStatusFlag(handle->channel);
 8028f62:	682b      	ldr	r3, [r5, #0]
      if (handle->runtime->bus_acquired == false)
      {
        I2C_MASTER_lSendStart_Or_RepeatedStart(handle, slave_address, XMC_I2C_CH_CMD_WRITE);

        /* Wait for ACK or timeout */
        I2C_Timeout = 0X1FFFFF;
 8028f64:	6032      	str	r2, [r6, #0]
 * \par<b>Related APIs:</b><br>
 * XMC_I2C_CH_ClearStatusFlag()\n\n
 */
__STATIC_INLINE uint32_t XMC_I2C_CH_GetStatusFlag(XMC_USIC_CH_t *const channel)
{
  return (channel->PSR_IICMode);
 8028f66:	6c9a      	ldr	r2, [r3, #72]	; 0x48
        while ((I2C_MASTER_GetFlagStatus(handle, (uint32_t)XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED) == 0U) && (I2C_Timeout > 0))
 8028f68:	0594      	lsls	r4, r2, #22
 8028f6a:	d414      	bmi.n	8028f96 <I2C_MASTER_Transmit+0x1b6>
 8028f6c:	6832      	ldr	r2, [r6, #0]
 8028f6e:	b192      	cbz	r2, 8028f96 <I2C_MASTER_Transmit+0x1b6>
 8028f70:	6c9a      	ldr	r2, [r3, #72]	; 0x48
        {
          /* Get flag status */
          psr_status = XMC_I2C_CH_GetStatusFlag(handle->channel);

          /* Check if an error flag is set */
          if (psr_status & ((uint32_t)XMC_I2C_CH_STATUS_FLAG_NACK_RECEIVED |
 8028f72:	f412 7fb1 	tst.w	r2, #354	; 0x162
 8028f76:	d182      	bne.n	8028e7e <I2C_MASTER_Transmit+0x9e>

            status = I2C_MASTER_STATUS_FAILURE;
            return (status);
          }

          I2C_Timeout--;
 8028f78:	4631      	mov	r1, r6
 8028f7a:	e006      	b.n	8028f8a <I2C_MASTER_Transmit+0x1aa>
      {
        I2C_MASTER_lSendStart_Or_RepeatedStart(handle, slave_address, XMC_I2C_CH_CMD_WRITE);

        /* Wait for ACK or timeout */
        I2C_Timeout = 0X1FFFFF;
        while ((I2C_MASTER_GetFlagStatus(handle, (uint32_t)XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED) == 0U) && (I2C_Timeout > 0))
 8028f7c:	680a      	ldr	r2, [r1, #0]
 8028f7e:	b152      	cbz	r2, 8028f96 <I2C_MASTER_Transmit+0x1b6>
 8028f80:	6c9a      	ldr	r2, [r3, #72]	; 0x48
        {
          /* Get flag status */
          psr_status = XMC_I2C_CH_GetStatusFlag(handle->channel);

          /* Check if an error flag is set */
          if (psr_status & ((uint32_t)XMC_I2C_CH_STATUS_FLAG_NACK_RECEIVED |
 8028f82:	f412 7fb1 	tst.w	r2, #354	; 0x162
 8028f86:	f47f af7a 	bne.w	8028e7e <I2C_MASTER_Transmit+0x9e>

            status = I2C_MASTER_STATUS_FAILURE;
            return (status);
          }

          I2C_Timeout--;
 8028f8a:	6832      	ldr	r2, [r6, #0]
 8028f8c:	3a01      	subs	r2, #1
 8028f8e:	6032      	str	r2, [r6, #0]
 8028f90:	6c9a      	ldr	r2, [r3, #72]	; 0x48
      {
        I2C_MASTER_lSendStart_Or_RepeatedStart(handle, slave_address, XMC_I2C_CH_CMD_WRITE);

        /* Wait for ACK or timeout */
        I2C_Timeout = 0X1FFFFF;
        while ((I2C_MASTER_GetFlagStatus(handle, (uint32_t)XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED) == 0U) && (I2C_Timeout > 0))
 8028f92:	0592      	lsls	r2, r2, #22
 8028f94:	d5f2      	bpl.n	8028f7c <I2C_MASTER_Transmit+0x19c>

          I2C_Timeout--;
        }

        /* Undefined error, return Timeout */
        if (I2C_Timeout == 0)
 8028f96:	6832      	ldr	r2, [r6, #0]
 8028f98:	b9da      	cbnz	r2, 8028fd2 <I2C_MASTER_Transmit+0x1f2>
        {
          status = I2C_MASTER_STATUS_TIMEOUT;
          return (status);
 8028f9a:	2004      	movs	r0, #4
 8028f9c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      while (!XMC_USIC_CH_TXFIFO_IsEmpty(handle->channel)){}
    }

    if (send_stop == true)
    {
      handle->runtime->bus_acquired = false;
 8028fa0:	68ab      	ldr	r3, [r5, #8]
 8028fa2:	f04f 0800 	mov.w	r8, #0
 8028fa6:	f883 8028 	strb.w	r8, [r3, #40]	; 0x28
 * \par<b>Related APIs:</b><br>
 * XMC_I2C_CH_GetStatusFlag()\n\n
 */
__STATIC_INLINE void XMC_I2C_CH_ClearStatusFlag(XMC_USIC_CH_t *const channel, uint32_t flag)
{
  channel->PSCR |= flag;
 8028faa:	6cd3      	ldr	r3, [r2, #76]	; 0x4c
 8028fac:	f043 0310 	orr.w	r3, r3, #16
*/
__STATIC_INLINE void I2C_MASTER_SendStop(I2C_MASTER_t * const handle)
{
  XMC_ASSERT("I2C_MASTER_SendStop: invalid handle", (handle != NULL))
  XMC_I2C_CH_ClearStatusFlag(handle->channel, XMC_I2C_CH_STATUS_FLAG_STOP_CONDITION_RECEIVED);
  XMC_I2C_CH_MasterStop(handle->channel);
 8028fb0:	4610      	mov	r0, r2
 8028fb2:	64d3      	str	r3, [r2, #76]	; 0x4c
 8028fb4:	f7f8 ffc4 	bl	8021f40 <XMC_I2C_CH_MasterStop>
      I2C_MASTER_SendStop(handle);
    }

    status = I2C_MASTER_STATUS_SUCCESS;
 8028fb8:	4640      	mov	r0, r8
 8028fba:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8028fbe:	6828      	ldr	r0, [r5, #0]
 8028fc0:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 8028fc2:	f043 0308 	orr.w	r3, r3, #8
__STATIC_INLINE void I2C_MASTER_SendRepeatedStart(I2C_MASTER_t * const handle, const uint32_t address,
		                                          const XMC_I2C_CH_CMD_t cmd)
{
  XMC_ASSERT("I2C_MASTER_SendRepeatedStart: invalid handle", (handle != NULL))
  XMC_I2C_CH_ClearStatusFlag(handle->channel, XMC_I2C_CH_STATUS_FLAG_REPEATED_START_CONDITION_RECEIVED);
  XMC_I2C_CH_MasterRepeatedStart(handle->channel, (uint16_t)address, cmd);
 8028fc6:	b291      	uxth	r1, r2
 8028fc8:	64c3      	str	r3, [r0, #76]	; 0x4c
 8028fca:	4622      	mov	r2, r4
 8028fcc:	f7f8 ffa0 	bl	8021f10 <XMC_I2C_CH_MasterRepeatedStart>
 8028fd0:	e7c5      	b.n	8028f5e <I2C_MASTER_Transmit+0x17e>
 8028fd2:	6cd9      	ldr	r1, [r3, #76]	; 0x4c
 8028fd4:	686a      	ldr	r2, [r5, #4]
 8028fd6:	f441 7100 	orr.w	r1, r1, #512	; 0x200
 8028fda:	64d9      	str	r1, [r3, #76]	; 0x4c
 8028fdc:	4618      	mov	r0, r3
 8028fde:	e725      	b.n	8028e2c <I2C_MASTER_Transmit+0x4c>
 8028fe0:	1ffeb450 	.word	0x1ffeb450
 8028fe4:	002fffff 	.word	0x002fffff
 8028fe8:	001fffff 	.word	0x001fffff

08028fec <I2C_MASTER_Receive>:
 *
 *
 **********************************************************************************************************************/
I2C_MASTER_STATUS_t I2C_MASTER_Receive(I2C_MASTER_t *handle, bool send_start, const uint32_t address, uint8_t * data,
                                   const uint32_t count, bool send_stop, bool send_nack)
{
 8028fec:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8028ff0:	4604      	mov	r4, r0
  I2C_MASTER_STATUS_t status;

  status = I2C_MASTER_STATUS_BUSY;

  if (handle->config->receive_mode == I2C_MASTER_TRANSFER_MODE_INTERRUPT)
 8028ff2:	6840      	ldr	r0, [r0, #4]
 *
 *
 **********************************************************************************************************************/
I2C_MASTER_STATUS_t I2C_MASTER_Receive(I2C_MASTER_t *handle, bool send_start, const uint32_t address, uint8_t * data,
                                   const uint32_t count, bool send_stop, bool send_nack)
{
 8028ff4:	9d0a      	ldr	r5, [sp, #40]	; 0x28
  I2C_MASTER_STATUS_t status;

  status = I2C_MASTER_STATUS_BUSY;

  if (handle->config->receive_mode == I2C_MASTER_TRANSFER_MODE_INTERRUPT)
 8028ff6:	f890 e025 	ldrb.w	lr, [r0, #37]	; 0x25
 *
 *
 **********************************************************************************************************************/
I2C_MASTER_STATUS_t I2C_MASTER_Receive(I2C_MASTER_t *handle, bool send_start, const uint32_t address, uint8_t * data,
                                   const uint32_t count, bool send_stop, bool send_nack)
{
 8028ffa:	f89d 602c 	ldrb.w	r6, [sp, #44]	; 0x2c
 8028ffe:	f89d 8030 	ldrb.w	r8, [sp, #48]	; 0x30
  I2C_MASTER_STATUS_t status;

  status = I2C_MASTER_STATUS_BUSY;

  if (handle->config->receive_mode == I2C_MASTER_TRANSFER_MODE_INTERRUPT)
 8029002:	f1be 0f01 	cmp.w	lr, #1
 8029006:	d802      	bhi.n	802900e <I2C_MASTER_Receive+0x22>
I2C_MASTER_STATUS_t I2C_MASTER_Receive(I2C_MASTER_t *handle, bool send_start, const uint32_t address, uint8_t * data,
                                   const uint32_t count, bool send_stop, bool send_nack)
{
  I2C_MASTER_STATUS_t status;

  status = I2C_MASTER_STATUS_BUSY;
 8029008:	2002      	movs	r0, #2
 802900a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802900e:	461f      	mov	r7, r3
  I2C_MASTER_STATUS_t status;
  uint32_t buffer_index;
  uint32_t temp_index;

  status = I2C_MASTER_STATUS_BUSY;
  if ((((send_start == false) && (handle->runtime->bus_acquired == false)) || (data == NULL) || (count == 0U)))
 8029010:	b919      	cbnz	r1, 802901a <I2C_MASTER_Receive+0x2e>
 8029012:	68a3      	ldr	r3, [r4, #8]
 8029014:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8029018:	b383      	cbz	r3, 802907c <I2C_MASTER_Receive+0x90>
 802901a:	b37f      	cbz	r7, 802907c <I2C_MASTER_Receive+0x90>
 802901c:	b375      	cbz	r5, 802907c <I2C_MASTER_Receive+0x90>
  }
  else
  {
  buffer_index = 0U;
  temp_index = 0U;
    if (send_start == true)
 802901e:	2900      	cmp	r1, #0
 8029020:	d143      	bne.n	80290aa <I2C_MASTER_Receive+0xbe>
      /* wait for ACK */
    }
    I2C_MASTER_ClearFlag(handle, (uint32_t)XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED);
  }

  if (handle->config->txFIFO_size == XMC_USIC_CH_FIFO_DISABLED)
 8029022:	f890 3026 	ldrb.w	r3, [r0, #38]	; 0x26
 8029026:	2b00      	cmp	r3, #0
 8029028:	f000 808a 	beq.w	8029140 <I2C_MASTER_Receive+0x154>
 802902c:	6822      	ldr	r2, [r4, #0]
 * @endcode
*/
__STATIC_INLINE void I2C_MASTER_ReceiveNACK(I2C_MASTER_t * const handle)
{
  XMC_ASSERT("I2C_MASTER_ReceiveNACK: invalid handle", (handle != NULL))
  XMC_I2C_CH_MasterReceiveNack(handle->channel);
 802902e:	f04f 0900 	mov.w	r9, #0
 8029032:	46ca      	mov	sl, r9
 8029034:	f1b8 0f00 	cmp.w	r8, #0
 8029038:	d007      	beq.n	802904a <I2C_MASTER_Receive+0x5e>
 802903a:	e027      	b.n	802908c <I2C_MASTER_Receive+0xa0>
    while (temp_index < count)
    {
      while (I2C_MASTER_IsTXFIFOFull(handle) == false)
    {
      /* transmit each byte till index reaches to the last byte */
      if (temp_index < count)
 802903c:	4555      	cmp	r5, sl
 802903e:	d979      	bls.n	8029134 <I2C_MASTER_Receive+0x148>
 * @endcode
*/
__STATIC_INLINE void I2C_MASTER_ReceiveACK(I2C_MASTER_t * const handle)
{
  XMC_ASSERT("I2C_MASTER_ReceiveACK: invalid handle", (handle != NULL))
  XMC_I2C_CH_MasterReceiveAck(handle->channel);
 8029040:	f7f8 ffa6 	bl	8021f90 <XMC_I2C_CH_MasterReceiveAck>
 8029044:	6822      	ldr	r2, [r4, #0]
      {
        /* load the FIFO, byte by byte till either FIFO is full or all data is loaded*/
        if (((temp_index + 1U) == count) && (send_nack == true))
 8029046:	f10a 0a01 	add.w	sl, sl, #1
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_TXFIFO_IsEmpty(), XMC_USIC_CH_TXFIFO_Flush() \n\n\n
 */
__STATIC_INLINE bool XMC_USIC_CH_TXFIFO_IsFull(XMC_USIC_CH_t *const channel)
{
  return (bool)(channel->TRBSR & USIC_CH_TRBSR_TFULL_Msk);
 802904a:	f8d2 3114 	ldr.w	r3, [r2, #276]	; 0x114
  else
  {
    temp_index = buffer_index;
    while (temp_index < count)
    {
      while (I2C_MASTER_IsTXFIFOFull(handle) == false)
 802904e:	f413 5f80 	tst.w	r3, #4096	; 0x1000
 8029052:	4610      	mov	r0, r2
 8029054:	d0f2      	beq.n	802903c <I2C_MASTER_Receive+0x50>
      {
        break;
      }
    } /* end of while (I2C_MASTER_IsTXFIFOFull(handle) == false) */

    while (buffer_index < temp_index)
 8029056:	45ca      	cmp	sl, r9
 8029058:	d968      	bls.n	802912c <I2C_MASTER_Receive+0x140>
 802905a:	eb07 0b09 	add.w	fp, r7, r9
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_RXFIFO_Flush(), XMC_USIC_CH_RXFIFO_PutData() \n\n\n
 */
__STATIC_INLINE bool XMC_USIC_CH_RXFIFO_IsEmpty(XMC_USIC_CH_t *const channel)
{
  return (bool)(channel->TRBSR & USIC_CH_TRBSR_REMPTY_Msk);
 802905e:	f8d2 3114 	ldr.w	r3, [r2, #276]	; 0x114
    {
      /* wait for data to come in RX fifo */
      while (I2C_MASTER_IsRXFIFOEmpty(handle)){}
 8029062:	071b      	lsls	r3, r3, #28
 8029064:	d4fb      	bmi.n	802905e <I2C_MASTER_Receive+0x72>
 */
/* Wrapper to the LLD API for reading back the value of the RBUF or OUTR register */
__STATIC_INLINE uint8_t I2C_MASTER_GetReceivedByte(I2C_MASTER_t * const handle)
{
  XMC_ASSERT("I2C_MASTER_GetReceivedByte: invalid handle", (handle != NULL))
  return (uint8_t)XMC_I2C_CH_GetReceivedData(handle->channel);
 8029066:	4610      	mov	r0, r2
 8029068:	f7f8 ffbe 	bl	8021fe8 <XMC_I2C_CH_GetReceivedData>
      data[buffer_index++] = I2C_MASTER_GetReceivedByte(handle);
 802906c:	f109 0901 	add.w	r9, r9, #1
      {
        break;
      }
    } /* end of while (I2C_MASTER_IsTXFIFOFull(handle) == false) */

    while (buffer_index < temp_index)
 8029070:	45d1      	cmp	r9, sl
    {
      /* wait for data to come in RX fifo */
      while (I2C_MASTER_IsRXFIFOEmpty(handle)){}
      data[buffer_index++] = I2C_MASTER_GetReceivedByte(handle);
 8029072:	f80b 0b01 	strb.w	r0, [fp], #1
      {
        break;
      }
    } /* end of while (I2C_MASTER_IsTXFIFOFull(handle) == false) */

    while (buffer_index < temp_index)
 8029076:	d259      	bcs.n	802912c <I2C_MASTER_Receive+0x140>
 8029078:	6822      	ldr	r2, [r4, #0]
 802907a:	e7f0      	b.n	802905e <I2C_MASTER_Receive+0x72>
  uint32_t temp_index;

  status = I2C_MASTER_STATUS_BUSY;
  if ((((send_start == false) && (handle->runtime->bus_acquired == false)) || (data == NULL) || (count == 0U)))
  {
    status = I2C_MASTER_STATUS_FAILURE;
 802907c:	2001      	movs	r0, #1
 802907e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 * @endcode
*/
__STATIC_INLINE void I2C_MASTER_ReceiveNACK(I2C_MASTER_t * const handle)
{
  XMC_ASSERT("I2C_MASTER_ReceiveNACK: invalid handle", (handle != NULL))
  XMC_I2C_CH_MasterReceiveNack(handle->channel);
 8029082:	4610      	mov	r0, r2
 8029084:	f7f8 ff9a 	bl	8021fbc <XMC_I2C_CH_MasterReceiveNack>
 8029088:	46aa      	mov	sl, r5
 802908a:	6822      	ldr	r2, [r4, #0]
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_TXFIFO_IsEmpty(), XMC_USIC_CH_TXFIFO_Flush() \n\n\n
 */
__STATIC_INLINE bool XMC_USIC_CH_TXFIFO_IsFull(XMC_USIC_CH_t *const channel)
{
  return (bool)(channel->TRBSR & USIC_CH_TRBSR_TFULL_Msk);
 802908c:	f8d2 3114 	ldr.w	r3, [r2, #276]	; 0x114
  else
  {
    temp_index = buffer_index;
    while (temp_index < count)
    {
      while (I2C_MASTER_IsTXFIFOFull(handle) == false)
 8029090:	f413 5f80 	tst.w	r3, #4096	; 0x1000
 * @endcode
*/
__STATIC_INLINE void I2C_MASTER_ReceiveACK(I2C_MASTER_t * const handle)
{
  XMC_ASSERT("I2C_MASTER_ReceiveACK: invalid handle", (handle != NULL))
  XMC_I2C_CH_MasterReceiveAck(handle->channel);
 8029094:	4610      	mov	r0, r2
 8029096:	d1de      	bne.n	8029056 <I2C_MASTER_Receive+0x6a>
    {
      /* transmit each byte till index reaches to the last byte */
      if (temp_index < count)
 8029098:	4555      	cmp	r5, sl
 802909a:	d94b      	bls.n	8029134 <I2C_MASTER_Receive+0x148>
      {
        /* load the FIFO, byte by byte till either FIFO is full or all data is loaded*/
        if (((temp_index + 1U) == count) && (send_nack == true))
 802909c:	f10a 0a01 	add.w	sl, sl, #1
 80290a0:	4555      	cmp	r5, sl
 80290a2:	d0ee      	beq.n	8029082 <I2C_MASTER_Receive+0x96>
 80290a4:	f7f8 ff74 	bl	8021f90 <XMC_I2C_CH_MasterReceiveAck>
 80290a8:	e7ef      	b.n	802908a <I2C_MASTER_Receive+0x9e>
    (I2C_MASTER_DIRECT_TX_ENABLED == 1) || (I2C_MASTER_DIRECT_RX_ENABLED == 1))
/* Function to issue Send Start/Repeated Start command */
static void I2C_MASTER_lSendStart_Or_RepeatedStart(I2C_MASTER_t * handle,const uint32_t address,
                                               const XMC_I2C_CH_CMD_t cmd)
{
  if (handle->runtime->bus_acquired == true)
 80290aa:	68a3      	ldr	r3, [r4, #8]
 80290ac:	f893 1028 	ldrb.w	r1, [r3, #40]	; 0x28
 80290b0:	2900      	cmp	r1, #0
 80290b2:	d155      	bne.n	8029160 <I2C_MASTER_Receive+0x174>
 80290b4:	6820      	ldr	r0, [r4, #0]
  {
  I2C_MASTER_SendRepeatedStart(handle, (uint16_t)address, cmd);
  }
  else
  {
    handle->runtime->bus_acquired = true;
 80290b6:	f04f 0e01 	mov.w	lr, #1
 80290ba:	f883 e028 	strb.w	lr, [r3, #40]	; 0x28
 80290be:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 80290c0:	f043 0304 	orr.w	r3, r3, #4
__STATIC_INLINE void I2C_MASTER_SendStart(I2C_MASTER_t * const handle, const uint32_t address,
		                                  const XMC_I2C_CH_CMD_t cmd)
{
  XMC_ASSERT("I2C_MASTER_SendStart: invalid handle", (handle != NULL))
  XMC_I2C_CH_ClearStatusFlag(handle->channel, XMC_I2C_CH_STATUS_FLAG_START_CONDITION_RECEIVED);
  XMC_I2C_CH_MasterStart(handle->channel, (uint16_t)address, cmd);
 80290c4:	b291      	uxth	r1, r2
 80290c6:	64c3      	str	r3, [r0, #76]	; 0x4c
 80290c8:	4672      	mov	r2, lr
 80290ca:	f7f8 ff09 	bl	8021ee0 <XMC_I2C_CH_MasterStart>
 80290ce:	6822      	ldr	r2, [r4, #0]
 * \par<b>Related APIs:</b><br>
 * XMC_I2C_CH_ClearStatusFlag()\n\n
 */
__STATIC_INLINE uint32_t XMC_I2C_CH_GetStatusFlag(XMC_USIC_CH_t *const channel)
{
  return (channel->PSR_IICMode);
 80290d0:	6c93      	ldr	r3, [r2, #72]	; 0x48
  buffer_index = 0U;
  temp_index = 0U;
    if (send_start == true)
    {
      I2C_MASTER_lSendStart_Or_RepeatedStart(handle, slave_address, XMC_I2C_CH_CMD_READ);
      while (I2C_MASTER_GetFlagStatus(handle, (uint32_t)XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED) == 0U)
 80290d2:	0598      	lsls	r0, r3, #22
 80290d4:	d5fc      	bpl.n	80290d0 <I2C_MASTER_Receive+0xe4>
      /* wait for ACK */
    }
    I2C_MASTER_ClearFlag(handle, (uint32_t)XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED);
  }

  if (handle->config->txFIFO_size == XMC_USIC_CH_FIFO_DISABLED)
 80290d6:	6861      	ldr	r1, [r4, #4]
 * \par<b>Related APIs:</b><br>
 * XMC_I2C_CH_GetStatusFlag()\n\n
 */
__STATIC_INLINE void XMC_I2C_CH_ClearStatusFlag(XMC_USIC_CH_t *const channel, uint32_t flag)
{
  channel->PSCR |= flag;
 80290d8:	6cd3      	ldr	r3, [r2, #76]	; 0x4c
 80290da:	f891 1026 	ldrb.w	r1, [r1, #38]	; 0x26
 80290de:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 80290e2:	64d3      	str	r3, [r2, #76]	; 0x4c
 80290e4:	2900      	cmp	r1, #0
 80290e6:	d1a2      	bne.n	802902e <I2C_MASTER_Receive+0x42>
 80290e8:	4610      	mov	r0, r2
 80290ea:	3f01      	subs	r7, #1
 80290ec:	f04f 0900 	mov.w	r9, #0
  {
    while (buffer_index < count)
    {
      if (((buffer_index + 1U) == count) && (send_nack == true))
 80290f0:	f109 0901 	add.w	r9, r9, #1
 80290f4:	454d      	cmp	r5, r9
 80290f6:	d03d      	beq.n	8029174 <I2C_MASTER_Receive+0x188>
 * @endcode
*/
__STATIC_INLINE void I2C_MASTER_ReceiveACK(I2C_MASTER_t * const handle)
{
  XMC_ASSERT("I2C_MASTER_ReceiveACK: invalid handle", (handle != NULL))
  XMC_I2C_CH_MasterReceiveAck(handle->channel);
 80290f8:	f7f8 ff4a 	bl	8021f90 <XMC_I2C_CH_MasterReceiveAck>
 80290fc:	6820      	ldr	r0, [r4, #0]
 80290fe:	e002      	b.n	8029106 <I2C_MASTER_Receive+0x11a>
 * \par<b>Related APIs:</b><br>
 * XMC_I2C_CH_ClearStatusFlag()\n\n
 */
__STATIC_INLINE uint32_t XMC_I2C_CH_GetStatusFlag(XMC_USIC_CH_t *const channel)
{
  return (channel->PSR_IICMode);
 8029100:	6c83      	ldr	r3, [r0, #72]	; 0x48
    else
    {
      I2C_MASTER_ReceiveACK(handle);
    }

      while ((I2C_MASTER_GetFlagStatus(handle, (uint32_t)XMC_I2C_CH_STATUS_FLAG_ALTERNATIVE_RECEIVE_INDICATION) == 0U) &&
 8029102:	045a      	lsls	r2, r3, #17
 8029104:	d402      	bmi.n	802910c <I2C_MASTER_Receive+0x120>
 8029106:	6c83      	ldr	r3, [r0, #72]	; 0x48
 8029108:	0419      	lsls	r1, r3, #16
 802910a:	d5f9      	bpl.n	8029100 <I2C_MASTER_Receive+0x114>
 * \par<b>Related APIs:</b><br>
 * XMC_I2C_CH_GetStatusFlag()\n\n
 */
__STATIC_INLINE void XMC_I2C_CH_ClearStatusFlag(XMC_USIC_CH_t *const channel, uint32_t flag)
{
  channel->PSCR |= flag;
 802910c:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 802910e:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8029112:	64c3      	str	r3, [r0, #76]	; 0x4c
 8029114:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 8029116:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 802911a:	64c3      	str	r3, [r0, #76]	; 0x4c
 */
/* Wrapper to the LLD API for reading back the value of the RBUF or OUTR register */
__STATIC_INLINE uint8_t I2C_MASTER_GetReceivedByte(I2C_MASTER_t * const handle)
{
  XMC_ASSERT("I2C_MASTER_GetReceivedByte: invalid handle", (handle != NULL))
  return (uint8_t)XMC_I2C_CH_GetReceivedData(handle->channel);
 802911c:	f7f8 ff64 	bl	8021fe8 <XMC_I2C_CH_GetReceivedData>
    I2C_MASTER_ClearFlag(handle, (uint32_t)XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED);
  }

  if (handle->config->txFIFO_size == XMC_USIC_CH_FIFO_DISABLED)
  {
    while (buffer_index < count)
 8029120:	45a9      	cmp	r9, r5
    }

    I2C_MASTER_ClearFlag(handle, (uint32_t)XMC_I2C_CH_STATUS_FLAG_ALTERNATIVE_RECEIVE_INDICATION);
    I2C_MASTER_ClearFlag(handle, (uint32_t)XMC_I2C_CH_STATUS_FLAG_RECEIVE_INDICATION);

    data[buffer_index++] = I2C_MASTER_GetReceivedByte(handle);
 8029122:	f807 0f01 	strb.w	r0, [r7, #1]!
    I2C_MASTER_ClearFlag(handle, (uint32_t)XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED);
  }

  if (handle->config->txFIFO_size == XMC_USIC_CH_FIFO_DISABLED)
  {
    while (buffer_index < count)
 8029126:	d007      	beq.n	8029138 <I2C_MASTER_Receive+0x14c>
 8029128:	6820      	ldr	r0, [r4, #0]
 802912a:	e7e1      	b.n	80290f0 <I2C_MASTER_Receive+0x104>
    }
  } /* end of if (handle->config->txFIFO_size == XMC_USIC_CH_FIFO_DISABLED) */
  else
  {
    temp_index = buffer_index;
    while (temp_index < count)
 802912c:	4555      	cmp	r5, sl
 802912e:	d903      	bls.n	8029138 <I2C_MASTER_Receive+0x14c>
 8029130:	6822      	ldr	r2, [r4, #0]
 8029132:	e77f      	b.n	8029034 <I2C_MASTER_Receive+0x48>
      {
        break;
      }
    } /* end of while (I2C_MASTER_IsTXFIFOFull(handle) == false) */

    while (buffer_index < temp_index)
 8029134:	45ca      	cmp	sl, r9
 8029136:	d890      	bhi.n	802905a <I2C_MASTER_Receive+0x6e>
      data[buffer_index++] = I2C_MASTER_GetReceivedByte(handle);
    }
    } /* end of while (temp_index < count) */
  } /* end of else */

    if (send_stop == true)
 8029138:	b926      	cbnz	r6, 8029144 <I2C_MASTER_Receive+0x158>
    {
      handle->runtime->bus_acquired = false;
      I2C_MASTER_SendStop(handle);
    }

    status = I2C_MASTER_STATUS_SUCCESS;
 802913a:	4630      	mov	r0, r6
 802913c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8029140:	6820      	ldr	r0, [r4, #0]
 8029142:	e7d2      	b.n	80290ea <I2C_MASTER_Receive+0xfe>
    } /* end of while (temp_index < count) */
  } /* end of else */

    if (send_stop == true)
    {
      handle->runtime->bus_acquired = false;
 8029144:	68a3      	ldr	r3, [r4, #8]
 8029146:	6820      	ldr	r0, [r4, #0]
 8029148:	2600      	movs	r6, #0
 802914a:	f883 6028 	strb.w	r6, [r3, #40]	; 0x28
 802914e:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 8029150:	f043 0310 	orr.w	r3, r3, #16
 8029154:	64c3      	str	r3, [r0, #76]	; 0x4c
*/
__STATIC_INLINE void I2C_MASTER_SendStop(I2C_MASTER_t * const handle)
{
  XMC_ASSERT("I2C_MASTER_SendStop: invalid handle", (handle != NULL))
  XMC_I2C_CH_ClearStatusFlag(handle->channel, XMC_I2C_CH_STATUS_FLAG_STOP_CONDITION_RECEIVED);
  XMC_I2C_CH_MasterStop(handle->channel);
 8029156:	f7f8 fef3 	bl	8021f40 <XMC_I2C_CH_MasterStop>
      I2C_MASTER_SendStop(handle);
    }

    status = I2C_MASTER_STATUS_SUCCESS;
 802915a:	4630      	mov	r0, r6
 802915c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8029160:	6820      	ldr	r0, [r4, #0]
 8029162:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 8029164:	f043 0308 	orr.w	r3, r3, #8
__STATIC_INLINE void I2C_MASTER_SendRepeatedStart(I2C_MASTER_t * const handle, const uint32_t address,
		                                          const XMC_I2C_CH_CMD_t cmd)
{
  XMC_ASSERT("I2C_MASTER_SendRepeatedStart: invalid handle", (handle != NULL))
  XMC_I2C_CH_ClearStatusFlag(handle->channel, XMC_I2C_CH_STATUS_FLAG_REPEATED_START_CONDITION_RECEIVED);
  XMC_I2C_CH_MasterRepeatedStart(handle->channel, (uint16_t)address, cmd);
 8029168:	b291      	uxth	r1, r2
 802916a:	64c3      	str	r3, [r0, #76]	; 0x4c
 802916c:	2201      	movs	r2, #1
 802916e:	f7f8 fecf 	bl	8021f10 <XMC_I2C_CH_MasterRepeatedStart>
 8029172:	e7ac      	b.n	80290ce <I2C_MASTER_Receive+0xe2>

  if (handle->config->txFIFO_size == XMC_USIC_CH_FIFO_DISABLED)
  {
    while (buffer_index < count)
    {
      if (((buffer_index + 1U) == count) && (send_nack == true))
 8029174:	f1b8 0f00 	cmp.w	r8, #0
 8029178:	d0be      	beq.n	80290f8 <I2C_MASTER_Receive+0x10c>
 * @endcode
*/
__STATIC_INLINE void I2C_MASTER_ReceiveNACK(I2C_MASTER_t * const handle)
{
  XMC_ASSERT("I2C_MASTER_ReceiveNACK: invalid handle", (handle != NULL))
  XMC_I2C_CH_MasterReceiveNack(handle->channel);
 802917a:	f7f8 ff1f 	bl	8021fbc <XMC_I2C_CH_MasterReceiveNack>
 802917e:	e7bd      	b.n	80290fc <I2C_MASTER_Receive+0x110>

08029180 <I2C_MASTER_EEPROM_disable_io>:
  .baudrate = (uint32_t)(400000U),
  .address  = 0
};

static void I2C_MASTER_EEPROM_disable_io(void)
{
 8029180:	b510      	push	{r4, lr}
  XMC_GPIO_SetMode((XMC_GPIO_PORT_t *)PORT2_BASE, (uint8_t)5, XMC_GPIO_MODE_INPUT_TRISTATE);
 8029182:	4c06      	ldr	r4, [pc, #24]	; (802919c <I2C_MASTER_EEPROM_disable_io+0x1c>)
 8029184:	2105      	movs	r1, #5
 8029186:	4620      	mov	r0, r4
 8029188:	2200      	movs	r2, #0
 802918a:	f7f8 fe47 	bl	8021e1c <XMC_GPIO_SetMode>
  XMC_GPIO_SetMode((XMC_GPIO_PORT_t *)PORT2_BASE, (uint8_t)4, XMC_GPIO_MODE_INPUT_TRISTATE);
 802918e:	4620      	mov	r0, r4
 8029190:	2104      	movs	r1, #4
 8029192:	2200      	movs	r2, #0
}
 8029194:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
};

static void I2C_MASTER_EEPROM_disable_io(void)
{
  XMC_GPIO_SetMode((XMC_GPIO_PORT_t *)PORT2_BASE, (uint8_t)5, XMC_GPIO_MODE_INPUT_TRISTATE);
  XMC_GPIO_SetMode((XMC_GPIO_PORT_t *)PORT2_BASE, (uint8_t)4, XMC_GPIO_MODE_INPUT_TRISTATE);
 8029198:	f7f8 be40 	b.w	8021e1c <XMC_GPIO_SetMode>
 802919c:	48028200 	.word	0x48028200

080291a0 <I2C_MASTER_EEPROM_enable_io>:
}

static void I2C_MASTER_EEPROM_enable_io(void)
{
 80291a0:	b510      	push	{r4, lr}
  XMC_GPIO_SetMode((XMC_GPIO_PORT_t *)PORT2_BASE, (uint8_t)5, I2C_MASTER_EEPROM_sda_pin_config.mode);
 80291a2:	4c06      	ldr	r4, [pc, #24]	; (80291bc <I2C_MASTER_EEPROM_enable_io+0x1c>)
 80291a4:	2105      	movs	r1, #5
 80291a6:	4620      	mov	r0, r4
 80291a8:	22d0      	movs	r2, #208	; 0xd0
 80291aa:	f7f8 fe37 	bl	8021e1c <XMC_GPIO_SetMode>
  XMC_GPIO_SetMode((XMC_GPIO_PORT_t *)PORT2_BASE, (uint8_t)4, I2C_MASTER_EEPROM_scl_pin_config.mode);
 80291ae:	4620      	mov	r0, r4
 80291b0:	2104      	movs	r1, #4
 80291b2:	22d0      	movs	r2, #208	; 0xd0
}
 80291b4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
}

static void I2C_MASTER_EEPROM_enable_io(void)
{
  XMC_GPIO_SetMode((XMC_GPIO_PORT_t *)PORT2_BASE, (uint8_t)5, I2C_MASTER_EEPROM_sda_pin_config.mode);
  XMC_GPIO_SetMode((XMC_GPIO_PORT_t *)PORT2_BASE, (uint8_t)4, I2C_MASTER_EEPROM_scl_pin_config.mode);
 80291b8:	f7f8 be30 	b.w	8021e1c <XMC_GPIO_SetMode>
 80291bc:	48028200 	.word	0x48028200

080291c0 <I2C_MASTER_EEPROM_init>:
  .config = &I2C_MASTER_EEPROM_config,
  .runtime = &I2C_MASTER_EEPROM_runtime,
};

void I2C_MASTER_EEPROM_init(void)
{
 80291c0:	b538      	push	{r3, r4, r5, lr}
 
  XMC_I2C_CH_Init(XMC_I2C0_CH1, &I2C_MASTER_EEPROM_channel_config);
 80291c2:	4c19      	ldr	r4, [pc, #100]	; (8029228 <I2C_MASTER_EEPROM_init+0x68>)
 80291c4:	4919      	ldr	r1, [pc, #100]	; (802922c <I2C_MASTER_EEPROM_init+0x6c>)
  XMC_USIC_CH_EnableInputDigitalFilter(XMC_I2C0_CH1, XMC_USIC_CH_INPUT_DX1);
  XMC_USIC_CH_EnableInputSync(XMC_I2C0_CH1, XMC_USIC_CH_INPUT_DX1);
    
  XMC_I2C_CH_Start(XMC_I2C0_CH1);

  XMC_GPIO_Init((XMC_GPIO_PORT_t *)PORT2_BASE, (uint8_t)5, &I2C_MASTER_EEPROM_sda_pin_config);
 80291c6:	4d1a      	ldr	r5, [pc, #104]	; (8029230 <I2C_MASTER_EEPROM_init+0x70>)
};

void I2C_MASTER_EEPROM_init(void)
{
 
  XMC_I2C_CH_Init(XMC_I2C0_CH1, &I2C_MASTER_EEPROM_channel_config);
 80291c8:	4620      	mov	r0, r4
 80291ca:	f7f8 fe4b 	bl	8021e64 <XMC_I2C_CH_Init>
 * XMC_USIC_CH_EnableInputInversion(), XMC_USIC_CH_EnableInputDigitalFilter(), XMC_USIC_CH_EnableInputSync(),
 * XMC_USIC_CH_SetInputSamplingFreq()\n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_SetInputSource(XMC_USIC_CH_t *const channel, const XMC_USIC_CH_INPUT_t input, const uint8_t source)
{
  channel->DXCR[input] = (uint32_t)((channel->DXCR[input] & (uint32_t)(~USIC_CH_DXCR_DSEL_Msk)) |
 80291ce:	69e3      	ldr	r3, [r4, #28]
  XMC_USIC_CH_EnableInputDigitalFilter(XMC_I2C0_CH1, XMC_USIC_CH_INPUT_DX1);
  XMC_USIC_CH_EnableInputSync(XMC_I2C0_CH1, XMC_USIC_CH_INPUT_DX1);
    
  XMC_I2C_CH_Start(XMC_I2C0_CH1);

  XMC_GPIO_Init((XMC_GPIO_PORT_t *)PORT2_BASE, (uint8_t)5, &I2C_MASTER_EEPROM_sda_pin_config);
 80291d0:	4a18      	ldr	r2, [pc, #96]	; (8029234 <I2C_MASTER_EEPROM_init+0x74>)
 80291d2:	f023 0307 	bic.w	r3, r3, #7
 80291d6:	f043 0301 	orr.w	r3, r3, #1
 80291da:	61e3      	str	r3, [r4, #28]
 80291dc:	6a23      	ldr	r3, [r4, #32]
 80291de:	f023 0307 	bic.w	r3, r3, #7
 80291e2:	6223      	str	r3, [r4, #32]
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_DisableInputDigitalFilter()\n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_EnableInputDigitalFilter(XMC_USIC_CH_t *const channel, const XMC_USIC_CH_INPUT_t input)
{
  channel->DXCR[input] |= (uint32_t)USIC_CH_DXCR_DFEN_Msk;
 80291e4:	69e3      	ldr	r3, [r4, #28]
 80291e6:	f043 0320 	orr.w	r3, r3, #32
 80291ea:	61e3      	str	r3, [r4, #28]
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_DisableInputSync(), XMC_USIC_CH_EnableInputDigitalFilter()\n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_EnableInputSync(XMC_USIC_CH_t *const channel, const XMC_USIC_CH_INPUT_t input)
{
  channel->DXCR[input] |=(uint32_t)USIC_CH_DXCR_DSEN_Msk;
 80291ec:	69e3      	ldr	r3, [r4, #28]
 80291ee:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80291f2:	61e3      	str	r3, [r4, #28]
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_DisableInputDigitalFilter()\n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_EnableInputDigitalFilter(XMC_USIC_CH_t *const channel, const XMC_USIC_CH_INPUT_t input)
{
  channel->DXCR[input] |= (uint32_t)USIC_CH_DXCR_DFEN_Msk;
 80291f4:	6a23      	ldr	r3, [r4, #32]
 80291f6:	f043 0320 	orr.w	r3, r3, #32
 80291fa:	6223      	str	r3, [r4, #32]
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_DisableInputSync(), XMC_USIC_CH_EnableInputDigitalFilter()\n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_EnableInputSync(XMC_USIC_CH_t *const channel, const XMC_USIC_CH_INPUT_t input)
{
  channel->DXCR[input] |=(uint32_t)USIC_CH_DXCR_DSEN_Msk;
 80291fc:	6a23      	ldr	r3, [r4, #32]
 80291fe:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8029202:	6223      	str	r3, [r4, #32]
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_Enable(), XMC_USIC_CH_Enable() \n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_SetMode(XMC_USIC_CH_t *const channel, const XMC_USIC_CH_OPERATING_MODE_t mode)
{
  channel->CCR = (uint32_t)(channel->CCR & (~(USIC_CH_CCR_MODE_Msk))) | (uint32_t)mode;
 8029204:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8029206:	f023 030f 	bic.w	r3, r3, #15
 802920a:	f043 0304 	orr.w	r3, r3, #4
 802920e:	4628      	mov	r0, r5
 8029210:	6423      	str	r3, [r4, #64]	; 0x40
 8029212:	2105      	movs	r1, #5
 8029214:	f7f7 feae 	bl	8020f74 <XMC_GPIO_Init>
  XMC_GPIO_Init((XMC_GPIO_PORT_t *)PORT2_BASE, (uint8_t)4, &I2C_MASTER_EEPROM_scl_pin_config);
 8029218:	4628      	mov	r0, r5
 802921a:	2104      	movs	r1, #4
 802921c:	4a06      	ldr	r2, [pc, #24]	; (8029238 <I2C_MASTER_EEPROM_init+0x78>)
}
 802921e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  XMC_USIC_CH_EnableInputSync(XMC_I2C0_CH1, XMC_USIC_CH_INPUT_DX1);
    
  XMC_I2C_CH_Start(XMC_I2C0_CH1);

  XMC_GPIO_Init((XMC_GPIO_PORT_t *)PORT2_BASE, (uint8_t)5, &I2C_MASTER_EEPROM_sda_pin_config);
  XMC_GPIO_Init((XMC_GPIO_PORT_t *)PORT2_BASE, (uint8_t)4, &I2C_MASTER_EEPROM_scl_pin_config);
 8029222:	f7f7 bea7 	b.w	8020f74 <XMC_GPIO_Init>
 8029226:	bf00      	nop
 8029228:	40030200 	.word	0x40030200
 802922c:	0802ff0c 	.word	0x0802ff0c
 8029230:	48028200 	.word	0x48028200
 8029234:	0802fec8 	.word	0x0802fec8
 8029238:	0802fed4 	.word	0x0802fed4

0802923c <helper_switch_pwm_on.isra.10>:

//============================================================================

static void helper_switch_pwm_on(PWM_CCU8_t *handle_ptr)
{
	if ((bool)true == handle_ptr->config_ptr->gpio_ch1_out0_enable)
 802923c:	6803      	ldr	r3, [r0, #0]
 802923e:	f893 204c 	ldrb.w	r2, [r3, #76]	; 0x4c
	}
}

//============================================================================

static void helper_switch_pwm_on(PWM_CCU8_t *handle_ptr)
 8029242:	b510      	push	{r4, lr}
 8029244:	4604      	mov	r4, r0
{
	if ((bool)true == handle_ptr->config_ptr->gpio_ch1_out0_enable)
 8029246:	bb32      	cbnz	r2, 8029296 <helper_switch_pwm_on.isra.10+0x5a>
	{
		XMC_GPIO_MODE_t new_mode = handle_ptr->config_ptr->gpio_ch1_out0_config_ptr->mode;
		XMC_GPIO_SetMode(handle_ptr->config_ptr->gpio_ch1_out0_ptr, handle_ptr->config_ptr->gpio_ch1_out0_pin, new_mode);
	}

	if ((bool)true == handle_ptr->config_ptr->gpio_ch1_out1_enable)
 8029248:	f893 205c 	ldrb.w	r2, [r3, #92]	; 0x5c
 802924c:	b9d2      	cbnz	r2, 8029284 <helper_switch_pwm_on.isra.10+0x48>
	{
		XMC_GPIO_MODE_t new_mode = handle_ptr->config_ptr->gpio_ch1_out1_config_ptr->mode;
		XMC_GPIO_SetMode(handle_ptr->config_ptr->gpio_ch1_out1_ptr, handle_ptr->config_ptr->gpio_ch1_out1_pin, new_mode);
	}

	if ((bool)true == handle_ptr->config_ptr->gpio_ch2_out2_enable)
 802924e:	f893 206c 	ldrb.w	r2, [r3, #108]	; 0x6c
 8029252:	b972      	cbnz	r2, 8029272 <helper_switch_pwm_on.isra.10+0x36>
	{
		XMC_GPIO_MODE_t new_mode = handle_ptr->config_ptr->gpio_ch2_out2_config_ptr->mode;
		XMC_GPIO_SetMode(handle_ptr->config_ptr->gpio_ch2_out2_ptr, handle_ptr->config_ptr->gpio_ch2_out2_pin, new_mode);
	}

	if ((bool)true == handle_ptr->config_ptr->gpio_ch2_out3_enable)
 8029254:	f893 207c 	ldrb.w	r2, [r3, #124]	; 0x7c
 8029258:	b902      	cbnz	r2, 802925c <helper_switch_pwm_on.isra.10+0x20>
 802925a:	bd10      	pop	{r4, pc}
	{
		XMC_GPIO_MODE_t new_mode = handle_ptr->config_ptr->gpio_ch2_out3_config_ptr->mode;
 802925c:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
		XMC_GPIO_SetMode(handle_ptr->config_ptr->gpio_ch2_out3_ptr, handle_ptr->config_ptr->gpio_ch2_out3_pin, new_mode);
 8029260:	f8d3 0080 	ldr.w	r0, [r3, #128]	; 0x80
 8029264:	7812      	ldrb	r2, [r2, #0]
 8029266:	f893 1084 	ldrb.w	r1, [r3, #132]	; 0x84
	}
}
 802926a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	}

	if ((bool)true == handle_ptr->config_ptr->gpio_ch2_out3_enable)
	{
		XMC_GPIO_MODE_t new_mode = handle_ptr->config_ptr->gpio_ch2_out3_config_ptr->mode;
		XMC_GPIO_SetMode(handle_ptr->config_ptr->gpio_ch2_out3_ptr, handle_ptr->config_ptr->gpio_ch2_out3_pin, new_mode);
 802926e:	f7f8 bdd5 	b.w	8021e1c <XMC_GPIO_SetMode>
		XMC_GPIO_SetMode(handle_ptr->config_ptr->gpio_ch1_out1_ptr, handle_ptr->config_ptr->gpio_ch1_out1_pin, new_mode);
	}

	if ((bool)true == handle_ptr->config_ptr->gpio_ch2_out2_enable)
	{
		XMC_GPIO_MODE_t new_mode = handle_ptr->config_ptr->gpio_ch2_out2_config_ptr->mode;
 8029272:	6f9a      	ldr	r2, [r3, #120]	; 0x78
		XMC_GPIO_SetMode(handle_ptr->config_ptr->gpio_ch2_out2_ptr, handle_ptr->config_ptr->gpio_ch2_out2_pin, new_mode);
 8029274:	6f18      	ldr	r0, [r3, #112]	; 0x70
 8029276:	f893 1074 	ldrb.w	r1, [r3, #116]	; 0x74
 802927a:	7812      	ldrb	r2, [r2, #0]
 802927c:	f7f8 fdce 	bl	8021e1c <XMC_GPIO_SetMode>
 8029280:	6823      	ldr	r3, [r4, #0]
 8029282:	e7e7      	b.n	8029254 <helper_switch_pwm_on.isra.10+0x18>
		XMC_GPIO_SetMode(handle_ptr->config_ptr->gpio_ch1_out0_ptr, handle_ptr->config_ptr->gpio_ch1_out0_pin, new_mode);
	}

	if ((bool)true == handle_ptr->config_ptr->gpio_ch1_out1_enable)
	{
		XMC_GPIO_MODE_t new_mode = handle_ptr->config_ptr->gpio_ch1_out1_config_ptr->mode;
 8029284:	6e9a      	ldr	r2, [r3, #104]	; 0x68
		XMC_GPIO_SetMode(handle_ptr->config_ptr->gpio_ch1_out1_ptr, handle_ptr->config_ptr->gpio_ch1_out1_pin, new_mode);
 8029286:	6e18      	ldr	r0, [r3, #96]	; 0x60
 8029288:	f893 1064 	ldrb.w	r1, [r3, #100]	; 0x64
 802928c:	7812      	ldrb	r2, [r2, #0]
 802928e:	f7f8 fdc5 	bl	8021e1c <XMC_GPIO_SetMode>
 8029292:	6823      	ldr	r3, [r4, #0]
 8029294:	e7db      	b.n	802924e <helper_switch_pwm_on.isra.10+0x12>

static void helper_switch_pwm_on(PWM_CCU8_t *handle_ptr)
{
	if ((bool)true == handle_ptr->config_ptr->gpio_ch1_out0_enable)
	{
		XMC_GPIO_MODE_t new_mode = handle_ptr->config_ptr->gpio_ch1_out0_config_ptr->mode;
 8029296:	6d9a      	ldr	r2, [r3, #88]	; 0x58
		XMC_GPIO_SetMode(handle_ptr->config_ptr->gpio_ch1_out0_ptr, handle_ptr->config_ptr->gpio_ch1_out0_pin, new_mode);
 8029298:	6d18      	ldr	r0, [r3, #80]	; 0x50
 802929a:	f893 1054 	ldrb.w	r1, [r3, #84]	; 0x54
 802929e:	7812      	ldrb	r2, [r2, #0]
 80292a0:	f7f8 fdbc 	bl	8021e1c <XMC_GPIO_SetMode>
 80292a4:	6823      	ldr	r3, [r4, #0]
 80292a6:	e7cf      	b.n	8029248 <helper_switch_pwm_on.isra.10+0xc>

080292a8 <bsp_update>:
}

//============================================================================

uint8_t bsp_update(device_settings_t *p_dev)
{
 80292a8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint32_t duty_ch1_bgt_vcc;								  /* BGT VCC */
	uint32_t bgt_tx_on_duty, bgt_tx_on_shift, bgt_tx_on_freq; /* BGT TX ON */
	uint32_t hold_duty, hold_shift, sample_hold_freq;		  /* Sample and hold */
	uint32_t sample_duty, sample_adc_freq;					  /* ADC sampling */

	uint32_t doppler_sampling_freq_hz = p_dev->adc_sampling_freq_Hz;
 80292ac:	f8d0 b014 	ldr.w	fp, [r0, #20]
	uint32_t pulse_width_usec = p_dev->pulse_width_usec;
 80292b0:	6b05      	ldr	r5, [r0, #48]	; 0x30
	uint32_t sample_hold_on_time_nsec = p_dev->sample_hold_on_time_nsec;
 80292b2:	f8d0 8034 	ldr.w	r8, [r0, #52]	; 0x34

	if (doppler_sampling_freq_hz > BSP_MAX_DOPPLER_SAMPLING_FREQ_HZ || doppler_sampling_freq_hz < BSP_MIN_DOPPLER_SAMPLING_FREQ_HZ)
 80292b6:	f5ab 737a 	sub.w	r3, fp, #1000	; 0x3e8
 80292ba:	f5b3 6f7a 	cmp.w	r3, #4000	; 0xfa0
 80292be:	f200 810e 	bhi.w	80294de <bsp_update+0x236>
		return 1;

	if (pulse_width_usec > BSP_MAX_PULSE_WIDTH_USEC || pulse_width_usec < BSP_MIN_PULSE_WIDTH_USEC)
 80292c2:	1f2b      	subs	r3, r5, #4
 80292c4:	2b06      	cmp	r3, #6
 80292c6:	f200 810a 	bhi.w	80294de <bsp_update+0x236>
		return 1;

	// !!! Maximum value must be (1000 * PULSE_WIDTH_USEC - SAMPLE_HOLD_ON_DELAY_TIME_NSEC) */
	if (sample_hold_on_time_nsec > (1000 * pulse_width_usec - SAMPLE_HOLD_ON_DELAY_TIME_NSEC))
 80292ca:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80292ce:	fb03 f305 	mul.w	r3, r3, r5
 80292d2:	f5a3 73f0 	sub.w	r3, r3, #480	; 0x1e0
 80292d6:	4598      	cmp	r8, r3
 80292d8:	f200 8101 	bhi.w	80294de <bsp_update+0x236>
 80292dc:	4604      	mov	r4, r0
	/* Sample and hold's period in microsecond */
	sample_and_hold_periodic_time_usec = 1000000 / doppler_sampling_freq_hz;

	uint32_t min_int = bsp_calc_min_frame_interval_usec(p_dev);

	if (!pwm_bgt_enabled) // if false!
 80292de:	489e      	ldr	r0, [pc, #632]	; (8029558 <bsp_update+0x2b0>)

//============================================================================

uint32_t bsp_calc_min_frame_interval_usec(device_settings_t *p_dev)
{
	uint32_t min_frame_interval_usec = p_dev->num_of_chirps_per_frame * (((p_dev->num_samples_per_chirp + p_dev->num_sample_skip_count) * 1000U * 1000U) / p_dev->adc_sampling_freq_Hz); // units in us
 80292e0:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 80292e2:	6a62      	ldr	r2, [r4, #36]	; 0x24
	// !!! Maximum value must be (1000 * PULSE_WIDTH_USEC - SAMPLE_HOLD_ON_DELAY_TIME_NSEC) */
	if (sample_hold_on_time_nsec > (1000 * pulse_width_usec - SAMPLE_HOLD_ON_DELAY_TIME_NSEC))
		return 1;

	/* Sample and hold's period in microsecond */
	sample_and_hold_periodic_time_usec = 1000000 / doppler_sampling_freq_hz;
 80292e4:	4b9d      	ldr	r3, [pc, #628]	; (802955c <bsp_update+0x2b4>)

//============================================================================

uint32_t bsp_calc_min_frame_interval_usec(device_settings_t *p_dev)
{
	uint32_t min_frame_interval_usec = p_dev->num_of_chirps_per_frame * (((p_dev->num_samples_per_chirp + p_dev->num_sample_skip_count) * 1000U * 1000U) / p_dev->adc_sampling_freq_Hz); // units in us
 80292e6:	69e7      	ldr	r7, [r4, #28]
	/* Sample and hold's period in microsecond */
	sample_and_hold_periodic_time_usec = 1000000 / doppler_sampling_freq_hz;

	uint32_t min_int = bsp_calc_min_frame_interval_usec(p_dev);

	if (!pwm_bgt_enabled) // if false!
 80292e8:	7800      	ldrb	r0, [r0, #0]
	// !!! Maximum value must be (1000 * PULSE_WIDTH_USEC - SAMPLE_HOLD_ON_DELAY_TIME_NSEC) */
	if (sample_hold_on_time_nsec > (1000 * pulse_width_usec - SAMPLE_HOLD_ON_DELAY_TIME_NSEC))
		return 1;

	/* Sample and hold's period in microsecond */
	sample_and_hold_periodic_time_usec = 1000000 / doppler_sampling_freq_hz;
 80292ea:	fbb3 f6fb 	udiv	r6, r3, fp

//============================================================================

uint32_t bsp_calc_min_frame_interval_usec(device_settings_t *p_dev)
{
	uint32_t min_frame_interval_usec = p_dev->num_of_chirps_per_frame * (((p_dev->num_samples_per_chirp + p_dev->num_sample_skip_count) * 1000U * 1000U) / p_dev->adc_sampling_freq_Hz); // units in us
 80292ee:	440a      	add	r2, r1
 80292f0:	fb03 f302 	mul.w	r3, r3, r2
 80292f4:	fbb3 f3fb 	udiv	r3, r3, fp
 80292f8:	fb07 f703 	mul.w	r7, r7, r3
	/* Sample and hold's period in microsecond */
	sample_and_hold_periodic_time_usec = 1000000 / doppler_sampling_freq_hz;

	uint32_t min_int = bsp_calc_min_frame_interval_usec(p_dev);

	if (!pwm_bgt_enabled) // if false!
 80292fc:	2800      	cmp	r0, #0
 80292fe:	f000 814f 	beq.w	80295a0 <bsp_update+0x2f8>
 8029302:	4897      	ldr	r0, [pc, #604]	; (8029560 <bsp_update+0x2b8>)
 8029304:	f8df 9268 	ldr.w	r9, [pc, #616]	; 8029570 <bsp_update+0x2c8>
 8029308:	6801      	ldr	r1, [r0, #0]
 802930a:	f8d9 3000 	ldr.w	r3, [r9]

static void switch_passive_PWM_GPIO(PWM_CCU8_t *handle_ptr)
{
	XMC_GPIO_OUTPUT_LEVEL_t output_level;

	output_level = (handle_ptr->config_ptr->ccu8_cc8_slice_timer_ptr->passive_level_out0 == (uint32_t)XMC_CCU8_SLICE_OUTPUT_PASSIVE_LEVEL_LOW)
 802930e:	6c8a      	ldr	r2, [r1, #72]	; 0x48
__STATIC_INLINE void XMC_GPIO_SetOutputLevel(XMC_GPIO_PORT_t *const port, const uint8_t pin, const XMC_GPIO_OUTPUT_LEVEL_t level)
{
  XMC_ASSERT("XMC_GPIO_SetOutputLevel: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));
  XMC_ASSERT("XMC_GPIO_SetOutputLevel: Invalid output level", XMC_GPIO_CHECK_OUTPUT_LEVEL(level));
  
  port->OMR = (uint32_t)level << pin;
 8029310:	f891 e054 	ldrb.w	lr, [r1, #84]	; 0x54
 8029314:	f892 c004 	ldrb.w	ip, [r2, #4]
 8029318:	6c9a      	ldr	r2, [r3, #72]	; 0x48
					   ? XMC_GPIO_OUTPUT_LEVEL_LOW
					   : XMC_GPIO_OUTPUT_LEVEL_HIGH;
	XMC_GPIO_SetOutputLevel(handle_ptr->config_ptr->gpio_ch1_out0_ptr, handle_ptr->config_ptr->gpio_ch1_out0_pin, output_level);
 802931a:	6d09      	ldr	r1, [r1, #80]	; 0x50

static void switch_passive_PWM_GPIO(PWM_CCU8_t *handle_ptr)
{
	XMC_GPIO_OUTPUT_LEVEL_t output_level;

	output_level = (handle_ptr->config_ptr->ccu8_cc8_slice_timer_ptr->passive_level_out0 == (uint32_t)XMC_CCU8_SLICE_OUTPUT_PASSIVE_LEVEL_LOW)
 802931c:	f892 a004 	ldrb.w	sl, [r2, #4]
					   ? XMC_GPIO_OUTPUT_LEVEL_LOW
					   : XMC_GPIO_OUTPUT_LEVEL_HIGH;
	XMC_GPIO_SetOutputLevel(handle_ptr->config_ptr->gpio_ch1_out0_ptr, handle_ptr->config_ptr->gpio_ch1_out0_pin, output_level);
 8029320:	6d1a      	ldr	r2, [r3, #80]	; 0x50

static void switch_passive_PWM_GPIO(PWM_CCU8_t *handle_ptr)
{
	XMC_GPIO_OUTPUT_LEVEL_t output_level;

	output_level = (handle_ptr->config_ptr->ccu8_cc8_slice_timer_ptr->passive_level_out0 == (uint32_t)XMC_CCU8_SLICE_OUTPUT_PASSIVE_LEVEL_LOW)
 8029322:	f01c 0f01 	tst.w	ip, #1
 8029326:	bf0c      	ite	eq
 8029328:	f44f 3c80 	moveq.w	ip, #65536	; 0x10000
 802932c:	f04f 0c01 	movne.w	ip, #1
 8029330:	fa0c fe0e 	lsl.w	lr, ip, lr
 8029334:	f8c1 e004 	str.w	lr, [r1, #4]
 8029338:	f893 1054 	ldrb.w	r1, [r3, #84]	; 0x54
 802933c:	f01a 0f01 	tst.w	sl, #1
 8029340:	bf0c      	ite	eq
 8029342:	f44f 3380 	moveq.w	r3, #65536	; 0x10000
 8029346:	2301      	movne	r3, #1
 8029348:	408b      	lsls	r3, r1
 802934a:	6053      	str	r3, [r2, #4]
	{
		/* turn on duty cycling of TX_ON and BGT_VCC, and assign "active" level */
		switch_passive_PWM_GPIO(&PWM_CCU8_BGT_TX_ON);
		switch_passive_PWM_GPIO(&PWM_CCU8_BGT_VCC);

		helper_switch_pwm_on(&PWM_CCU8_BGT_TX_ON);
 802934c:	f7ff ff76 	bl	802923c <helper_switch_pwm_on.isra.10>
		helper_switch_pwm_on(&PWM_CCU8_BGT_VCC);
 8029350:	4648      	mov	r0, r9
 8029352:	f7ff ff73 	bl	802923c <helper_switch_pwm_on.isra.10>
	}

	Radar_Data_Acq_Mode_t mode = radar_get_data_acq_mode();
 8029356:	f7f7 fc31 	bl	8020bbc <radar_get_data_acq_mode>
	if (mode != RADAR_DATA_CONTINUOUS_MODE)
 802935a:	2802      	cmp	r0, #2
 802935c:	f000 80e9 	beq.w	8029532 <bsp_update+0x28a>
	{
		use_vptag_sh_duty_cycle = PTAT_S_H_SWITCHING;
		if (p_dev->frame_period_usec <= min_int + 2 * p_dev->ptat_delay_usec + BB_PRE_TRIGGER_ADVANCE_USEC - (p_dev->num_sample_skip_count * sample_and_hold_periodic_time_usec))
 8029360:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8029362:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8029364:	f8d4 e020 	ldr.w	lr, [r4, #32]
	}

	Radar_Data_Acq_Mode_t mode = radar_get_data_acq_mode();
	if (mode != RADAR_DATA_CONTINUOUS_MODE)
	{
		use_vptag_sh_duty_cycle = PTAT_S_H_SWITCHING;
 8029368:	f8df 922c 	ldr.w	r9, [pc, #556]	; 8029598 <bsp_update+0x2f0>
		if (p_dev->frame_period_usec <= min_int + 2 * p_dev->ptat_delay_usec + BB_PRE_TRIGGER_ADVANCE_USEC - (p_dev->num_sample_skip_count * sample_and_hold_periodic_time_usec))
 802936c:	0050      	lsls	r0, r2, #1
 802936e:	f500 419c 	add.w	r1, r0, #19968	; 0x4e00
 8029372:	fb03 fc06 	mul.w	ip, r3, r6
 8029376:	3120      	adds	r1, #32
 8029378:	ebcc 0101 	rsb	r1, ip, r1
 802937c:	4439      	add	r1, r7
	}

	Radar_Data_Acq_Mode_t mode = radar_get_data_acq_mode();
	if (mode != RADAR_DATA_CONTINUOUS_MODE)
	{
		use_vptag_sh_duty_cycle = PTAT_S_H_SWITCHING;
 802937e:	2301      	movs	r3, #1
		if (p_dev->frame_period_usec <= min_int + 2 * p_dev->ptat_delay_usec + BB_PRE_TRIGGER_ADVANCE_USEC - (p_dev->num_sample_skip_count * sample_and_hold_periodic_time_usec))
 8029380:	458e      	cmp	lr, r1
	}

	Radar_Data_Acq_Mode_t mode = radar_get_data_acq_mode();
	if (mode != RADAR_DATA_CONTINUOUS_MODE)
	{
		use_vptag_sh_duty_cycle = PTAT_S_H_SWITCHING;
 8029382:	f8c9 3000 	str.w	r3, [r9]
		if (p_dev->frame_period_usec <= min_int + 2 * p_dev->ptat_delay_usec + BB_PRE_TRIGGER_ADVANCE_USEC - (p_dev->num_sample_skip_count * sample_and_hold_periodic_time_usec))
 8029386:	f240 80af 	bls.w	80294e8 <bsp_update+0x240>
 802938a:	f502 439c 	add.w	r3, r2, #19968	; 0x4e00
 802938e:	3320      	adds	r3, #32
		{
			bb_pre_trigger_advance_usec = 0;
		}
		else
		{
			bb_pre_trigger_advance_usec = BB_PRE_TRIGGER_ADVANCE_USEC - (p_dev->num_sample_skip_count * sample_and_hold_periodic_time_usec) + p_dev->ptat_delay_usec;
 8029390:	f8df 9208 	ldr.w	r9, [pc, #520]	; 802959c <bsp_update+0x2f4>
 8029394:	ebcc 0303 	rsb	r3, ip, r3
 8029398:	f8c9 3000 	str.w	r3, [r9]
	else
	{
		bb_pre_trigger_advance_usec = 0;
	}

	if (p_dev->frame_period_usec <= min_int + 2 * p_dev->ptat_delay_usec)
 802939c:	4438      	add	r0, r7
 802939e:	4570      	cmp	r0, lr
	{
		ptat_switching_status = 0;
 80293a0:	4b70      	ldr	r3, [pc, #448]	; (8029564 <bsp_update+0x2bc>)
	else
	{
		bb_pre_trigger_advance_usec = 0;
	}

	if (p_dev->frame_period_usec <= min_int + 2 * p_dev->ptat_delay_usec)
 80293a2:	f0c0 80ab 	bcc.w	80294fc <bsp_update+0x254>
	{
		ptat_switching_status = 0;
 80293a6:	2200      	movs	r2, #0
 80293a8:	601a      	str	r2, [r3, #0]
 80293aa:	4b6f      	ldr	r3, [pc, #444]	; (8029568 <bsp_update+0x2c0>)
 80293ac:	4a6f      	ldr	r2, [pc, #444]	; (802956c <bsp_update+0x2c4>)

__STATIC_INLINE void XMC_GPIO_SetOutputHigh(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputHigh: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = (uint32_t)0x1U << pin;
 80293ae:	7c1f      	ldrb	r7, [r3, #16]
 80293b0:	7c10      	ldrb	r0, [r2, #16]
 80293b2:	6819      	ldr	r1, [r3, #0]
 80293b4:	6812      	ldr	r2, [r2, #0]
 80293b6:	2301      	movs	r3, #1
 80293b8:	fa03 f000 	lsl.w	r0, r3, r0
 80293bc:	40bb      	lsls	r3, r7
 80293be:	6050      	str	r0, [r2, #4]
 80293c0:	604b      	str	r3, [r1, #4]
		/* Enabled BBx_EN */
		enable_Baseband(true);
	}

	/* stop PWM timers for setting new parameters */
	PWM_CCU8_Stop(&PWM_CCU8_BGT_VCC);
 80293c2:	486b      	ldr	r0, [pc, #428]	; (8029570 <bsp_update+0x2c8>)
 80293c4:	f7fc ffc8 	bl	8026358 <PWM_CCU8_Stop>
	PWM_CCU8_Stop(&PWM_CCU8_BGT_TX_ON);
 80293c8:	4865      	ldr	r0, [pc, #404]	; (8029560 <bsp_update+0x2b8>)
 80293ca:	f7fc ffc5 	bl	8026358 <PWM_CCU8_Stop>
	PWM_CCU8_Stop(&PWM_CCU8_SAMPLE_HOLD);
 80293ce:	4869      	ldr	r0, [pc, #420]	; (8029574 <bsp_update+0x2cc>)
 80293d0:	f7fc ffc2 	bl	8026358 <PWM_CCU8_Stop>
	PWM_CCU8_Stop(&PWM_CCU8_ADC_SAMPLE);
 80293d4:	4868      	ldr	r0, [pc, #416]	; (8029578 <bsp_update+0x2d0>)
 80293d6:	f7fc ffbf 	bl	8026358 <PWM_CCU8_Stop>

TIMER_STATUS_t bsp_timer_stop_clear(TIMER_t *const handle_timer)
{
	TIMER_STATUS_t status;

	status = TIMER_Stop(handle_timer);
 80293da:	4868      	ldr	r0, [pc, #416]	; (802957c <bsp_update+0x2d4>)
 80293dc:	f7fc fd5a 	bl	8025e94 <TIMER_Stop>

	status |= TIMER_Clear(handle_timer);
 80293e0:	4866      	ldr	r0, [pc, #408]	; (802957c <bsp_update+0x2d4>)
 80293e2:	f7fc fde1 	bl	8025fa8 <TIMER_Clear>

TIMER_STATUS_t bsp_timer_stop_clear(TIMER_t *const handle_timer)
{
	TIMER_STATUS_t status;

	status = TIMER_Stop(handle_timer);
 80293e6:	4866      	ldr	r0, [pc, #408]	; (8029580 <bsp_update+0x2d8>)
 80293e8:	f7fc fd54 	bl	8025e94 <TIMER_Stop>

	status |= TIMER_Clear(handle_timer);
 80293ec:	4864      	ldr	r0, [pc, #400]	; (8029580 <bsp_update+0x2d8>)
 80293ee:	f7fc fddb 	bl	8025fa8 <TIMER_Clear>
    PWM_CCU8_SetFreqAndDutyCycleSymmetric(&PWM_CCU8_BGT_VCC, 2000, 50 * 100, 20 * 100);
  */

	/* Configure PWM master for BGT VCC and BGT TX On control signals */
	/* For example, for 5us On time and a period of 500us the duty_ch1_bgt_vcc will be ((5us / 500us) * 100) * 100 */
	duty_ch1_bgt_vcc = ((100 * 100 * pulse_width_usec) / sample_and_hold_periodic_time_usec);
 80293f2:	f242 7310 	movw	r3, #10000	; 0x2710
 80293f6:	fb03 f705 	mul.w	r7, r3, r5

	//TODO: Check the returning error!
	/* Configure PWM BGT control signals */
	PWM_CCU8_SetFreqAndDutyCycleSymmetric(&PWM_CCU8_BGT_VCC, doppler_sampling_freq_hz,
 80293fa:	4659      	mov	r1, fp
    PWM_CCU8_SetFreqAndDutyCycleSymmetric(&PWM_CCU8_BGT_VCC, 2000, 50 * 100, 20 * 100);
  */

	/* Configure PWM master for BGT VCC and BGT TX On control signals */
	/* For example, for 5us On time and a period of 500us the duty_ch1_bgt_vcc will be ((5us / 500us) * 100) * 100 */
	duty_ch1_bgt_vcc = ((100 * 100 * pulse_width_usec) / sample_and_hold_periodic_time_usec);
 80293fc:	fbb7 f2f6 	udiv	r2, r7, r6

	//TODO: Check the returning error!
	/* Configure PWM BGT control signals */
	PWM_CCU8_SetFreqAndDutyCycleSymmetric(&PWM_CCU8_BGT_VCC, doppler_sampling_freq_hz,
 8029400:	485b      	ldr	r0, [pc, #364]	; (8029570 <bsp_update+0x2c8>)
 8029402:	4613      	mov	r3, r2
 8029404:	f7fc ffba 	bl	802637c <PWM_CCU8_SetFreqAndDutyCycleSymmetric>
										  duty_ch1_bgt_vcc, duty_ch1_bgt_vcc);

	/* Configure PWM of BGT TX ON */
	/* Slightly shift the start of BGT TX On signal versus the BGT VCC signal */
	bgt_tx_on_freq = (1000 * 1000) / pulse_width_usec; /* In Hz */
 8029408:	4a54      	ldr	r2, [pc, #336]	; (802955c <bsp_update+0x2b4>)
	bgt_tx_on_duty = ((100 * 100 * pulse_width_usec) - 10 * BGT_TX_ON_DELAY_TIME_NSEC) / pulse_width_usec;
	bgt_tx_on_shift = (10 * BGT_TX_ON_START_DELAY_TIME_NSEC) / pulse_width_usec;
	PWM_CCU8_SetFreqAndDutyCycleAsymmetric(&PWM_CCU8_BGT_TX_ON, bgt_tx_on_freq,
 802940a:	4855      	ldr	r0, [pc, #340]	; (8029560 <bsp_update+0x2b8>)
	PWM_CCU8_SetFreqAndDutyCycleSymmetric(&PWM_CCU8_BGT_VCC, doppler_sampling_freq_hz,
										  duty_ch1_bgt_vcc, duty_ch1_bgt_vcc);

	/* Configure PWM of BGT TX ON */
	/* Slightly shift the start of BGT TX On signal versus the BGT VCC signal */
	bgt_tx_on_freq = (1000 * 1000) / pulse_width_usec; /* In Hz */
 802940c:	fbb2 faf5 	udiv	sl, r2, r5
	bgt_tx_on_duty = ((100 * 100 * pulse_width_usec) - 10 * BGT_TX_ON_DELAY_TIME_NSEC) / pulse_width_usec;
 8029410:	f5a7 637a 	sub.w	r3, r7, #4000	; 0xfa0
	bgt_tx_on_shift = (10 * BGT_TX_ON_START_DELAY_TIME_NSEC) / pulse_width_usec;
	PWM_CCU8_SetFreqAndDutyCycleAsymmetric(&PWM_CCU8_BGT_TX_ON, bgt_tx_on_freq,
 8029414:	4651      	mov	r1, sl
 8029416:	fbb3 f3f5 	udiv	r3, r3, r5

	/* Configure PWM of BGT TX ON */
	/* Slightly shift the start of BGT TX On signal versus the BGT VCC signal */
	bgt_tx_on_freq = (1000 * 1000) / pulse_width_usec; /* In Hz */
	bgt_tx_on_duty = ((100 * 100 * pulse_width_usec) - 10 * BGT_TX_ON_DELAY_TIME_NSEC) / pulse_width_usec;
	bgt_tx_on_shift = (10 * BGT_TX_ON_START_DELAY_TIME_NSEC) / pulse_width_usec;
 802941a:	f640 32b8 	movw	r2, #3000	; 0xbb8
	PWM_CCU8_SetFreqAndDutyCycleAsymmetric(&PWM_CCU8_BGT_TX_ON, bgt_tx_on_freq,
 802941e:	fbb2 f2f5 	udiv	r2, r2, r5
 8029422:	f7fc fff7 	bl	8026414 <PWM_CCU8_SetFreqAndDutyCycleAsymmetric>

	/* Configure PWM of start and holding time */
	/* Slightly shift the start of BGT TX On signal versus the BGT VCC signal */
	sample_hold_freq = (1000 * 1000) / pulse_width_usec; /* In Hz */

	hold_duty = ((100 * 100 * pulse_width_usec) - 10 * (SAMPLE_HOLD_ON_DELAY_TIME_NSEC + sample_hold_on_time_nsec)) / pulse_width_usec;
 8029426:	eb08 0888 	add.w	r8, r8, r8, lsl #2
 802942a:	f5a7 5396 	sub.w	r3, r7, #4800	; 0x12c0
	hold_shift = (10 * SAMPLE_HOLD_START_DELAY_TIME_NSEC) / pulse_width_usec;
	PWM_CCU8_SetFreqAndDutyCycleAsymmetric(&PWM_CCU8_SAMPLE_HOLD, sample_hold_freq,
 802942e:	4651      	mov	r1, sl

	/* Configure PWM of start and holding time */
	/* Slightly shift the start of BGT TX On signal versus the BGT VCC signal */
	sample_hold_freq = (1000 * 1000) / pulse_width_usec; /* In Hz */

	hold_duty = ((100 * 100 * pulse_width_usec) - 10 * (SAMPLE_HOLD_ON_DELAY_TIME_NSEC + sample_hold_on_time_nsec)) / pulse_width_usec;
 8029430:	eba3 0348 	sub.w	r3, r3, r8, lsl #1
	hold_shift = (10 * SAMPLE_HOLD_START_DELAY_TIME_NSEC) / pulse_width_usec;
 8029434:	f44f 627a 	mov.w	r2, #4000	; 0xfa0
	PWM_CCU8_SetFreqAndDutyCycleAsymmetric(&PWM_CCU8_SAMPLE_HOLD, sample_hold_freq,
 8029438:	fbb3 f3f5 	udiv	r3, r3, r5
 802943c:	fbb2 f2f5 	udiv	r2, r2, r5
 8029440:	484c      	ldr	r0, [pc, #304]	; (8029574 <bsp_update+0x2cc>)
 8029442:	f7fc ffe7 	bl	8026414 <PWM_CCU8_SetFreqAndDutyCycleAsymmetric>
										   hold_shift, hold_duty);

	/* Configure start of sampling: trigger ADC to acquire I and Q signals data */
	sample_duty = 500;
	sample_adc_freq = (1000 * 1000) / ((float)pulse_width_usec + 0.4); /* In Hz */
 8029446:	ee07 5a90 	vmov	s15, r5
 802944a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 802944e:	ee17 0a90 	vmov	r0, s15
 8029452:	f003 fa35 	bl	802c8c0 <__aeabi_f2d>
 8029456:	a33c      	add	r3, pc, #240	; (adr r3, 8029548 <bsp_update+0x2a0>)
 8029458:	e9d3 2300 	ldrd	r2, r3, [r3]
 802945c:	f003 f8d2 	bl	802c604 <__adddf3>
 8029460:	4602      	mov	r2, r0
 8029462:	460b      	mov	r3, r1
 8029464:	a13a      	add	r1, pc, #232	; (adr r1, 8029550 <bsp_update+0x2a8>)
 8029466:	e9d1 0100 	ldrd	r0, r1, [r1]
 802946a:	f003 fba7 	bl	802cbbc <__aeabi_ddiv>
 802946e:	f003 fd15 	bl	802ce9c <__aeabi_d2uiz>
	PWM_CCU8_SetFreqAndDutyCycleSymmetric(&PWM_CCU8_ADC_SAMPLE, sample_adc_freq,
 8029472:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
	PWM_CCU8_SetFreqAndDutyCycleAsymmetric(&PWM_CCU8_SAMPLE_HOLD, sample_hold_freq,
										   hold_shift, hold_duty);

	/* Configure start of sampling: trigger ADC to acquire I and Q signals data */
	sample_duty = 500;
	sample_adc_freq = (1000 * 1000) / ((float)pulse_width_usec + 0.4); /* In Hz */
 8029476:	4601      	mov	r1, r0
	PWM_CCU8_SetFreqAndDutyCycleSymmetric(&PWM_CCU8_ADC_SAMPLE, sample_adc_freq,
 8029478:	4613      	mov	r3, r2
 802947a:	483f      	ldr	r0, [pc, #252]	; (8029578 <bsp_update+0x2d0>)
 802947c:	f7fc ff7e 	bl	802637c <PWM_CCU8_SetFreqAndDutyCycleSymmetric>
										  sample_duty, sample_duty);

	/* Set additional timers: */
	uint32_t delay_usec = sample_and_hold_periodic_time_usec - vptag_sh_release_delay_usec;
 8029480:	4b40      	ldr	r3, [pc, #256]	; (8029584 <bsp_update+0x2dc>)
	if (vptag_sh_release_delay_usec > sample_and_hold_periodic_time_usec)
	{
		delay_usec = PTAT_S_H_PULSE_WIDTH_USEC;
	}

	TIMER_SetTimeInterval(&TIMER_PTAT_S_H_DELAY, delay_usec * 100U);
 8029482:	483e      	ldr	r0, [pc, #248]	; (802957c <bsp_update+0x2d4>)
	sample_adc_freq = (1000 * 1000) / ((float)pulse_width_usec + 0.4); /* In Hz */
	PWM_CCU8_SetFreqAndDutyCycleSymmetric(&PWM_CCU8_ADC_SAMPLE, sample_adc_freq,
										  sample_duty, sample_duty);

	/* Set additional timers: */
	uint32_t delay_usec = sample_and_hold_periodic_time_usec - vptag_sh_release_delay_usec;
 8029484:	681b      	ldr	r3, [r3, #0]

	/* Ensure to set something reasonable! */
	if (vptag_sh_release_delay_usec > sample_and_hold_periodic_time_usec)
 8029486:	429e      	cmp	r6, r3
	sample_adc_freq = (1000 * 1000) / ((float)pulse_width_usec + 0.4); /* In Hz */
	PWM_CCU8_SetFreqAndDutyCycleSymmetric(&PWM_CCU8_ADC_SAMPLE, sample_adc_freq,
										  sample_duty, sample_duty);

	/* Set additional timers: */
	uint32_t delay_usec = sample_and_hold_periodic_time_usec - vptag_sh_release_delay_usec;
 8029488:	bf23      	ittte	cs
 802948a:	1af6      	subcs	r6, r6, r3
 802948c:	2164      	movcs	r1, #100	; 0x64
 802948e:	4371      	mulcs	r1, r6
 8029490:	f44f 61fa 	movcc.w	r1, #2000	; 0x7d0
	if (vptag_sh_release_delay_usec > sample_and_hold_periodic_time_usec)
	{
		delay_usec = PTAT_S_H_PULSE_WIDTH_USEC;
	}

	TIMER_SetTimeInterval(&TIMER_PTAT_S_H_DELAY, delay_usec * 100U);
 8029494:	f7fc fd10 	bl	8025eb8 <TIMER_SetTimeInterval>

	if (bb_pre_trigger_advance_usec > 0)
 8029498:	f8d9 2000 	ldr.w	r2, [r9]
 802949c:	2a00      	cmp	r2, #0
 802949e:	dd3c      	ble.n	802951a <bsp_update+0x272>
	{
		if (TIMER_SetTimeInterval(&TIMER_BB_PRE_TRIGGER, bb_pre_trigger_advance_usec * 100U) != TIMER_STATUS_SUCCESS)
 80294a0:	2164      	movs	r1, #100	; 0x64
 80294a2:	fb01 f102 	mul.w	r1, r1, r2
 80294a6:	4836      	ldr	r0, [pc, #216]	; (8029580 <bsp_update+0x2d8>)
 80294a8:	f7fc fd06 	bl	8025eb8 <TIMER_SetTimeInterval>
 80294ac:	b9d0      	cbnz	r0, 80294e4 <bsp_update+0x23c>
		{
			while (1);
		}
	}

	if (ptat_switch_delay_usec > 0)
 80294ae:	4b36      	ldr	r3, [pc, #216]	; (8029588 <bsp_update+0x2e0>)
 80294b0:	681b      	ldr	r3, [r3, #0]
 80294b2:	b133      	cbz	r3, 80294c2 <bsp_update+0x21a>
	{
		if (TIMER_SetTimeInterval(&TIMER_PTAT_DELAY, ptat_switch_delay_usec * 100U) != TIMER_STATUS_SUCCESS)
 80294b4:	2164      	movs	r1, #100	; 0x64
 80294b6:	fb01 f103 	mul.w	r1, r1, r3
 80294ba:	4834      	ldr	r0, [pc, #208]	; (802958c <bsp_update+0x2e4>)
 80294bc:	f7fc fcfc 	bl	8025eb8 <TIMER_SetTimeInterval>
 80294c0:	b988      	cbnz	r0, 80294e6 <bsp_update+0x23e>
			while (1);
		}
	}

	/* TX ON: Get ready to wait master's trigger signal */
	PWM_CCU8_Start(&PWM_CCU8_BGT_TX_ON);
 80294c2:	4827      	ldr	r0, [pc, #156]	; (8029560 <bsp_update+0x2b8>)
 80294c4:	f7fc ff2e 	bl	8026324 <PWM_CCU8_Start>

	/* Sample and hold: Get ready to wait master's trigger signal */
	PWM_CCU8_Start(&PWM_CCU8_SAMPLE_HOLD);
 80294c8:	482a      	ldr	r0, [pc, #168]	; (8029574 <bsp_update+0x2cc>)
 80294ca:	f7fc ff2b 	bl	8026324 <PWM_CCU8_Start>

	/* ADC sampling: Get ready to wait master's trigger signal */
	PWM_CCU8_Start(&PWM_CCU8_ADC_SAMPLE);
 80294ce:	482a      	ldr	r0, [pc, #168]	; (8029578 <bsp_update+0x2d0>)
 80294d0:	f7fc ff28 	bl	8026324 <PWM_CCU8_Start>

//============================================================================

void bsp_reset_frame_counter(void)
{
	bsp_frame_counter = 0;
 80294d4:	4b2e      	ldr	r3, [pc, #184]	; (8029590 <bsp_update+0x2e8>)
 80294d6:	2000      	movs	r0, #0
 80294d8:	6018      	str	r0, [r3, #0]
	PWM_CCU8_Start(&PWM_CCU8_ADC_SAMPLE);

	/* Reset the current frame counter */
	bsp_reset_frame_counter();

	return (0);
 80294da:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	uint32_t doppler_sampling_freq_hz = p_dev->adc_sampling_freq_Hz;
	uint32_t pulse_width_usec = p_dev->pulse_width_usec;
	uint32_t sample_hold_on_time_nsec = p_dev->sample_hold_on_time_nsec;

	if (doppler_sampling_freq_hz > BSP_MAX_DOPPLER_SAMPLING_FREQ_HZ || doppler_sampling_freq_hz < BSP_MIN_DOPPLER_SAMPLING_FREQ_HZ)
		return 1;
 80294de:	2001      	movs	r0, #1

	/* Reset the current frame counter */
	bsp_reset_frame_counter();

	return (0);
}
 80294e0:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

	if (bb_pre_trigger_advance_usec > 0)
	{
		if (TIMER_SetTimeInterval(&TIMER_BB_PRE_TRIGGER, bb_pre_trigger_advance_usec * 100U) != TIMER_STATUS_SUCCESS)
		{
			while (1);
 80294e4:	e7fe      	b.n	80294e4 <bsp_update+0x23c>

	if (ptat_switch_delay_usec > 0)
	{
		if (TIMER_SetTimeInterval(&TIMER_PTAT_DELAY, ptat_switch_delay_usec * 100U) != TIMER_STATUS_SUCCESS)
		{
			while (1);
 80294e6:	e7fe      	b.n	80294e6 <bsp_update+0x23e>
	if (mode != RADAR_DATA_CONTINUOUS_MODE)
	{
		use_vptag_sh_duty_cycle = PTAT_S_H_SWITCHING;
		if (p_dev->frame_period_usec <= min_int + 2 * p_dev->ptat_delay_usec + BB_PRE_TRIGGER_ADVANCE_USEC - (p_dev->num_sample_skip_count * sample_and_hold_periodic_time_usec))
		{
			bb_pre_trigger_advance_usec = 0;
 80294e8:	f8df 90b0 	ldr.w	r9, [pc, #176]	; 802959c <bsp_update+0x2f4>
	else
	{
		bb_pre_trigger_advance_usec = 0;
	}

	if (p_dev->frame_period_usec <= min_int + 2 * p_dev->ptat_delay_usec)
 80294ec:	4438      	add	r0, r7
	if (mode != RADAR_DATA_CONTINUOUS_MODE)
	{
		use_vptag_sh_duty_cycle = PTAT_S_H_SWITCHING;
		if (p_dev->frame_period_usec <= min_int + 2 * p_dev->ptat_delay_usec + BB_PRE_TRIGGER_ADVANCE_USEC - (p_dev->num_sample_skip_count * sample_and_hold_periodic_time_usec))
		{
			bb_pre_trigger_advance_usec = 0;
 80294ee:	2300      	movs	r3, #0
	else
	{
		bb_pre_trigger_advance_usec = 0;
	}

	if (p_dev->frame_period_usec <= min_int + 2 * p_dev->ptat_delay_usec)
 80294f0:	4570      	cmp	r0, lr
	if (mode != RADAR_DATA_CONTINUOUS_MODE)
	{
		use_vptag_sh_duty_cycle = PTAT_S_H_SWITCHING;
		if (p_dev->frame_period_usec <= min_int + 2 * p_dev->ptat_delay_usec + BB_PRE_TRIGGER_ADVANCE_USEC - (p_dev->num_sample_skip_count * sample_and_hold_periodic_time_usec))
		{
			bb_pre_trigger_advance_usec = 0;
 80294f2:	f8c9 3000 	str.w	r3, [r9]
		bb_pre_trigger_advance_usec = 0;
	}

	if (p_dev->frame_period_usec <= min_int + 2 * p_dev->ptat_delay_usec)
	{
		ptat_switching_status = 0;
 80294f6:	4b1b      	ldr	r3, [pc, #108]	; (8029564 <bsp_update+0x2bc>)
	else
	{
		bb_pre_trigger_advance_usec = 0;
	}

	if (p_dev->frame_period_usec <= min_int + 2 * p_dev->ptat_delay_usec)
 80294f8:	f4bf af55 	bcs.w	80293a6 <bsp_update+0xfe>
	{
		ptat_switching_status = 0;
	}

	if (ptat_switching_status != 0)
 80294fc:	681b      	ldr	r3, [r3, #0]
 80294fe:	2b00      	cmp	r3, #0
 8029500:	f43f af53 	beq.w	80293aa <bsp_update+0x102>
 8029504:	4b23      	ldr	r3, [pc, #140]	; (8029594 <bsp_update+0x2ec>)
	{
		// if ptag is switched on before the acquisition
		DIGITAL_IO_SetOutputLow(&DIGITAL_IO_BGT_VCC_PTAT);
		use_vptag_sh_duty_cycle = 1;
 8029506:	4a24      	ldr	r2, [pc, #144]	; (8029598 <bsp_update+0x2f0>)

__STATIC_INLINE void XMC_GPIO_SetOutputLow(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputLow: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = 0x10000U << pin;
 8029508:	7c18      	ldrb	r0, [r3, #16]
 802950a:	6819      	ldr	r1, [r3, #0]
 802950c:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8029510:	4083      	lsls	r3, r0
 8029512:	2001      	movs	r0, #1
 8029514:	604b      	str	r3, [r1, #4]
 8029516:	6010      	str	r0, [r2, #0]
 8029518:	e753      	b.n	80293c2 <bsp_update+0x11a>
		if (TIMER_SetTimeInterval(&TIMER_BB_PRE_TRIGGER, bb_pre_trigger_advance_usec * 100U) != TIMER_STATUS_SUCCESS)
		{
			while (1);
		}
	}
	else if (bb_pre_trigger_advance_usec < 0)
 802951a:	d0c8      	beq.n	80294ae <bsp_update+0x206>
	{

		uint32_t bb_delay_usec = abs(bb_pre_trigger_advance_usec) + p_dev->ptat_delay_usec;
 802951c:	6be3      	ldr	r3, [r4, #60]	; 0x3c

		if (TIMER_SetTimeInterval(&TIMER_BB_PRE_TRIGGER, bb_delay_usec * 100U) != TIMER_STATUS_SUCCESS)
 802951e:	4818      	ldr	r0, [pc, #96]	; (8029580 <bsp_update+0x2d8>)
		}
	}
	else if (bb_pre_trigger_advance_usec < 0)
	{

		uint32_t bb_delay_usec = abs(bb_pre_trigger_advance_usec) + p_dev->ptat_delay_usec;
 8029520:	1a9b      	subs	r3, r3, r2

		if (TIMER_SetTimeInterval(&TIMER_BB_PRE_TRIGGER, bb_delay_usec * 100U) != TIMER_STATUS_SUCCESS)
 8029522:	2164      	movs	r1, #100	; 0x64
 8029524:	fb01 f103 	mul.w	r1, r1, r3
 8029528:	f7fc fcc6 	bl	8025eb8 <TIMER_SetTimeInterval>
 802952c:	2800      	cmp	r0, #0
 802952e:	d0be      	beq.n	80294ae <bsp_update+0x206>
		{
			while (1);
 8029530:	e7fe      	b.n	8029530 <bsp_update+0x288>
			bb_pre_trigger_advance_usec = BB_PRE_TRIGGER_ADVANCE_USEC - (p_dev->num_sample_skip_count * sample_and_hold_periodic_time_usec) + p_dev->ptat_delay_usec;
		}
	}
	else
	{
		bb_pre_trigger_advance_usec = 0;
 8029532:	f8df 9068 	ldr.w	r9, [pc, #104]	; 802959c <bsp_update+0x2f4>
 8029536:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 8029538:	f8d4 e020 	ldr.w	lr, [r4, #32]
 802953c:	2300      	movs	r3, #0
 802953e:	f8c9 3000 	str.w	r3, [r9]
 8029542:	0040      	lsls	r0, r0, #1
 8029544:	e72a      	b.n	802939c <bsp_update+0xf4>
 8029546:	bf00      	nop
 8029548:	9999999a 	.word	0x9999999a
 802954c:	3fd99999 	.word	0x3fd99999
 8029550:	00000000 	.word	0x00000000
 8029554:	412e8480 	.word	0x412e8480
 8029558:	1ffe9610 	.word	0x1ffe9610
 802955c:	000f4240 	.word	0x000f4240
 8029560:	1ffe926c 	.word	0x1ffe926c
 8029564:	1ffeb494 	.word	0x1ffeb494
 8029568:	0802dda8 	.word	0x0802dda8
 802956c:	0802dd94 	.word	0x0802dd94
 8029570:	1ffe9238 	.word	0x1ffe9238
 8029574:	1ffe92a0 	.word	0x1ffe92a0
 8029578:	1ffe92d4 	.word	0x1ffe92d4
 802957c:	1ffe91c0 	.word	0x1ffe91c0
 8029580:	1ffe9168 	.word	0x1ffe9168
 8029584:	1ffe9614 	.word	0x1ffe9614
 8029588:	1ffeb490 	.word	0x1ffeb490
 802958c:	1ffe9130 	.word	0x1ffe9130
 8029590:	1ffeb48c 	.word	0x1ffeb48c
 8029594:	0802ddbc 	.word	0x0802ddbc
 8029598:	1ffe9618 	.word	0x1ffe9618
 802959c:	1ffe960c 	.word	0x1ffe960c

static void helper_switch_pwm_off(PWM_CCU8_t *handle_ptr)
{
	XMC_GPIO_MODE_t new_mode = XMC_GPIO_MODE_OUTPUT_PUSH_PULL;

	if ((bool)true == handle_ptr->config_ptr->gpio_ch1_out0_enable)
 80295a0:	f8df 911c 	ldr.w	r9, [pc, #284]	; 80296c0 <bsp_update+0x418>
 80295a4:	f8d9 3000 	ldr.w	r3, [r9]
 80295a8:	f893 204c 	ldrb.w	r2, [r3, #76]	; 0x4c
 80295ac:	2a00      	cmp	r2, #0
 80295ae:	d13f      	bne.n	8029630 <bsp_update+0x388>
	{
		XMC_GPIO_SetMode(handle_ptr->config_ptr->gpio_ch1_out0_ptr, handle_ptr->config_ptr->gpio_ch1_out0_pin, new_mode);
	}

	if ((bool)true == handle_ptr->config_ptr->gpio_ch1_out1_enable)
 80295b0:	f893 205c 	ldrb.w	r2, [r3, #92]	; 0x5c
 80295b4:	2a00      	cmp	r2, #0
 80295b6:	d17a      	bne.n	80296ae <bsp_update+0x406>
	{
		XMC_GPIO_SetMode(handle_ptr->config_ptr->gpio_ch1_out1_ptr, handle_ptr->config_ptr->gpio_ch1_out1_pin, new_mode);
	}

	if ((bool)true == handle_ptr->config_ptr->gpio_ch2_out2_enable)
 80295b8:	f893 206c 	ldrb.w	r2, [r3, #108]	; 0x6c
 80295bc:	2a00      	cmp	r2, #0
 80295be:	d16d      	bne.n	802969c <bsp_update+0x3f4>
	{
		XMC_GPIO_SetMode(handle_ptr->config_ptr->gpio_ch2_out2_ptr, handle_ptr->config_ptr->gpio_ch2_out2_pin, new_mode);
	}

	if ((bool)true == handle_ptr->config_ptr->gpio_ch2_out3_enable)
 80295c0:	f893 207c 	ldrb.w	r2, [r3, #124]	; 0x7c
 80295c4:	2a00      	cmp	r2, #0
 80295c6:	d161      	bne.n	802968c <bsp_update+0x3e4>

static void helper_switch_pwm_off(PWM_CCU8_t *handle_ptr)
{
	XMC_GPIO_MODE_t new_mode = XMC_GPIO_MODE_OUTPUT_PUSH_PULL;

	if ((bool)true == handle_ptr->config_ptr->gpio_ch1_out0_enable)
 80295c8:	f8df a0f8 	ldr.w	sl, [pc, #248]	; 80296c4 <bsp_update+0x41c>
 80295cc:	f8da 3000 	ldr.w	r3, [sl]
 80295d0:	f893 204c 	ldrb.w	r2, [r3, #76]	; 0x4c
 80295d4:	2a00      	cmp	r2, #0
 80295d6:	d150      	bne.n	802967a <bsp_update+0x3d2>
	{
		XMC_GPIO_SetMode(handle_ptr->config_ptr->gpio_ch1_out0_ptr, handle_ptr->config_ptr->gpio_ch1_out0_pin, new_mode);
	}

	if ((bool)true == handle_ptr->config_ptr->gpio_ch1_out1_enable)
 80295d8:	f893 205c 	ldrb.w	r2, [r3, #92]	; 0x5c
 80295dc:	2a00      	cmp	r2, #0
 80295de:	d143      	bne.n	8029668 <bsp_update+0x3c0>
	{
		XMC_GPIO_SetMode(handle_ptr->config_ptr->gpio_ch1_out1_ptr, handle_ptr->config_ptr->gpio_ch1_out1_pin, new_mode);
	}

	if ((bool)true == handle_ptr->config_ptr->gpio_ch2_out2_enable)
 80295e0:	f893 206c 	ldrb.w	r2, [r3, #108]	; 0x6c
 80295e4:	2a00      	cmp	r2, #0
 80295e6:	d136      	bne.n	8029656 <bsp_update+0x3ae>
	{
		XMC_GPIO_SetMode(handle_ptr->config_ptr->gpio_ch2_out2_ptr, handle_ptr->config_ptr->gpio_ch2_out2_pin, new_mode);
	}

	if ((bool)true == handle_ptr->config_ptr->gpio_ch2_out3_enable)
 80295e8:	f893 207c 	ldrb.w	r2, [r3, #124]	; 0x7c
 80295ec:	bb4a      	cbnz	r2, 8029642 <bsp_update+0x39a>

static void switch_active_PWM_GPIO(PWM_CCU8_t *handle_ptr)
{
	XMC_GPIO_OUTPUT_LEVEL_t output_level;

	output_level = (handle_ptr->config_ptr->ccu8_cc8_slice_timer_ptr->passive_level_out0 == (uint32_t)XMC_CCU8_SLICE_OUTPUT_PASSIVE_LEVEL_LOW)
 80295ee:	6c99      	ldr	r1, [r3, #72]	; 0x48
 80295f0:	f8d9 2000 	ldr.w	r2, [r9]
 80295f4:	f891 9004 	ldrb.w	r9, [r1, #4]
__STATIC_INLINE void XMC_GPIO_SetOutputLevel(XMC_GPIO_PORT_t *const port, const uint8_t pin, const XMC_GPIO_OUTPUT_LEVEL_t level)
{
  XMC_ASSERT("XMC_GPIO_SetOutputLevel: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));
  XMC_ASSERT("XMC_GPIO_SetOutputLevel: Invalid output level", XMC_GPIO_CHECK_OUTPUT_LEVEL(level));
  
  port->OMR = (uint32_t)level << pin;
 80295f8:	f893 c054 	ldrb.w	ip, [r3, #84]	; 0x54
 80295fc:	6c91      	ldr	r1, [r2, #72]	; 0x48
					   ? XMC_GPIO_OUTPUT_LEVEL_HIGH
					   : XMC_GPIO_OUTPUT_LEVEL_LOW;

	XMC_GPIO_SetOutputLevel(handle_ptr->config_ptr->gpio_ch1_out0_ptr, handle_ptr->config_ptr->gpio_ch1_out0_pin, output_level);
 80295fe:	f8d3 e050 	ldr.w	lr, [r3, #80]	; 0x50

static void switch_active_PWM_GPIO(PWM_CCU8_t *handle_ptr)
{
	XMC_GPIO_OUTPUT_LEVEL_t output_level;

	output_level = (handle_ptr->config_ptr->ccu8_cc8_slice_timer_ptr->passive_level_out0 == (uint32_t)XMC_CCU8_SLICE_OUTPUT_PASSIVE_LEVEL_LOW)
 8029602:	7908      	ldrb	r0, [r1, #4]
					   ? XMC_GPIO_OUTPUT_LEVEL_HIGH
					   : XMC_GPIO_OUTPUT_LEVEL_LOW;

	XMC_GPIO_SetOutputLevel(handle_ptr->config_ptr->gpio_ch1_out0_ptr, handle_ptr->config_ptr->gpio_ch1_out0_pin, output_level);
 8029604:	6d11      	ldr	r1, [r2, #80]	; 0x50

static void switch_active_PWM_GPIO(PWM_CCU8_t *handle_ptr)
{
	XMC_GPIO_OUTPUT_LEVEL_t output_level;

	output_level = (handle_ptr->config_ptr->ccu8_cc8_slice_timer_ptr->passive_level_out0 == (uint32_t)XMC_CCU8_SLICE_OUTPUT_PASSIVE_LEVEL_LOW)
 8029606:	f019 0f01 	tst.w	r9, #1
 802960a:	bf0c      	ite	eq
 802960c:	2301      	moveq	r3, #1
 802960e:	f44f 3380 	movne.w	r3, #65536	; 0x10000
 8029612:	fa03 f30c 	lsl.w	r3, r3, ip
 8029616:	f8ce 3004 	str.w	r3, [lr, #4]
 802961a:	f892 2054 	ldrb.w	r2, [r2, #84]	; 0x54
 802961e:	f010 0f01 	tst.w	r0, #1
 8029622:	bf0c      	ite	eq
 8029624:	2301      	moveq	r3, #1
 8029626:	f44f 3380 	movne.w	r3, #65536	; 0x10000
 802962a:	4093      	lsls	r3, r2
 802962c:	604b      	str	r3, [r1, #4]
 802962e:	e692      	b.n	8029356 <bsp_update+0xae>
{
	XMC_GPIO_MODE_t new_mode = XMC_GPIO_MODE_OUTPUT_PUSH_PULL;

	if ((bool)true == handle_ptr->config_ptr->gpio_ch1_out0_enable)
	{
		XMC_GPIO_SetMode(handle_ptr->config_ptr->gpio_ch1_out0_ptr, handle_ptr->config_ptr->gpio_ch1_out0_pin, new_mode);
 8029630:	6d18      	ldr	r0, [r3, #80]	; 0x50
 8029632:	f893 1054 	ldrb.w	r1, [r3, #84]	; 0x54
 8029636:	2280      	movs	r2, #128	; 0x80
 8029638:	f7f8 fbf0 	bl	8021e1c <XMC_GPIO_SetMode>
 802963c:	f8d9 3000 	ldr.w	r3, [r9]
 8029640:	e7b6      	b.n	80295b0 <bsp_update+0x308>
		XMC_GPIO_SetMode(handle_ptr->config_ptr->gpio_ch2_out2_ptr, handle_ptr->config_ptr->gpio_ch2_out2_pin, new_mode);
	}

	if ((bool)true == handle_ptr->config_ptr->gpio_ch2_out3_enable)
	{
		XMC_GPIO_SetMode(handle_ptr->config_ptr->gpio_ch2_out3_ptr, handle_ptr->config_ptr->gpio_ch2_out3_pin, new_mode);
 8029642:	f8d3 0080 	ldr.w	r0, [r3, #128]	; 0x80
 8029646:	f893 1084 	ldrb.w	r1, [r3, #132]	; 0x84
 802964a:	2280      	movs	r2, #128	; 0x80
 802964c:	f7f8 fbe6 	bl	8021e1c <XMC_GPIO_SetMode>
 8029650:	f8da 3000 	ldr.w	r3, [sl]
 8029654:	e7cb      	b.n	80295ee <bsp_update+0x346>
		XMC_GPIO_SetMode(handle_ptr->config_ptr->gpio_ch1_out1_ptr, handle_ptr->config_ptr->gpio_ch1_out1_pin, new_mode);
	}

	if ((bool)true == handle_ptr->config_ptr->gpio_ch2_out2_enable)
	{
		XMC_GPIO_SetMode(handle_ptr->config_ptr->gpio_ch2_out2_ptr, handle_ptr->config_ptr->gpio_ch2_out2_pin, new_mode);
 8029656:	6f18      	ldr	r0, [r3, #112]	; 0x70
 8029658:	f893 1074 	ldrb.w	r1, [r3, #116]	; 0x74
 802965c:	2280      	movs	r2, #128	; 0x80
 802965e:	f7f8 fbdd 	bl	8021e1c <XMC_GPIO_SetMode>
 8029662:	f8da 3000 	ldr.w	r3, [sl]
 8029666:	e7bf      	b.n	80295e8 <bsp_update+0x340>
		XMC_GPIO_SetMode(handle_ptr->config_ptr->gpio_ch1_out0_ptr, handle_ptr->config_ptr->gpio_ch1_out0_pin, new_mode);
	}

	if ((bool)true == handle_ptr->config_ptr->gpio_ch1_out1_enable)
	{
		XMC_GPIO_SetMode(handle_ptr->config_ptr->gpio_ch1_out1_ptr, handle_ptr->config_ptr->gpio_ch1_out1_pin, new_mode);
 8029668:	6e18      	ldr	r0, [r3, #96]	; 0x60
 802966a:	f893 1064 	ldrb.w	r1, [r3, #100]	; 0x64
 802966e:	2280      	movs	r2, #128	; 0x80
 8029670:	f7f8 fbd4 	bl	8021e1c <XMC_GPIO_SetMode>
 8029674:	f8da 3000 	ldr.w	r3, [sl]
 8029678:	e7b2      	b.n	80295e0 <bsp_update+0x338>
{
	XMC_GPIO_MODE_t new_mode = XMC_GPIO_MODE_OUTPUT_PUSH_PULL;

	if ((bool)true == handle_ptr->config_ptr->gpio_ch1_out0_enable)
	{
		XMC_GPIO_SetMode(handle_ptr->config_ptr->gpio_ch1_out0_ptr, handle_ptr->config_ptr->gpio_ch1_out0_pin, new_mode);
 802967a:	6d18      	ldr	r0, [r3, #80]	; 0x50
 802967c:	f893 1054 	ldrb.w	r1, [r3, #84]	; 0x54
 8029680:	2280      	movs	r2, #128	; 0x80
 8029682:	f7f8 fbcb 	bl	8021e1c <XMC_GPIO_SetMode>
 8029686:	f8da 3000 	ldr.w	r3, [sl]
 802968a:	e7a5      	b.n	80295d8 <bsp_update+0x330>
		XMC_GPIO_SetMode(handle_ptr->config_ptr->gpio_ch2_out2_ptr, handle_ptr->config_ptr->gpio_ch2_out2_pin, new_mode);
	}

	if ((bool)true == handle_ptr->config_ptr->gpio_ch2_out3_enable)
	{
		XMC_GPIO_SetMode(handle_ptr->config_ptr->gpio_ch2_out3_ptr, handle_ptr->config_ptr->gpio_ch2_out3_pin, new_mode);
 802968c:	f8d3 0080 	ldr.w	r0, [r3, #128]	; 0x80
 8029690:	f893 1084 	ldrb.w	r1, [r3, #132]	; 0x84
 8029694:	2280      	movs	r2, #128	; 0x80
 8029696:	f7f8 fbc1 	bl	8021e1c <XMC_GPIO_SetMode>
 802969a:	e795      	b.n	80295c8 <bsp_update+0x320>
		XMC_GPIO_SetMode(handle_ptr->config_ptr->gpio_ch1_out1_ptr, handle_ptr->config_ptr->gpio_ch1_out1_pin, new_mode);
	}

	if ((bool)true == handle_ptr->config_ptr->gpio_ch2_out2_enable)
	{
		XMC_GPIO_SetMode(handle_ptr->config_ptr->gpio_ch2_out2_ptr, handle_ptr->config_ptr->gpio_ch2_out2_pin, new_mode);
 802969c:	6f18      	ldr	r0, [r3, #112]	; 0x70
 802969e:	f893 1074 	ldrb.w	r1, [r3, #116]	; 0x74
 80296a2:	2280      	movs	r2, #128	; 0x80
 80296a4:	f7f8 fbba 	bl	8021e1c <XMC_GPIO_SetMode>
 80296a8:	f8d9 3000 	ldr.w	r3, [r9]
 80296ac:	e788      	b.n	80295c0 <bsp_update+0x318>
		XMC_GPIO_SetMode(handle_ptr->config_ptr->gpio_ch1_out0_ptr, handle_ptr->config_ptr->gpio_ch1_out0_pin, new_mode);
	}

	if ((bool)true == handle_ptr->config_ptr->gpio_ch1_out1_enable)
	{
		XMC_GPIO_SetMode(handle_ptr->config_ptr->gpio_ch1_out1_ptr, handle_ptr->config_ptr->gpio_ch1_out1_pin, new_mode);
 80296ae:	6e18      	ldr	r0, [r3, #96]	; 0x60
 80296b0:	f893 1064 	ldrb.w	r1, [r3, #100]	; 0x64
 80296b4:	2280      	movs	r2, #128	; 0x80
 80296b6:	f7f8 fbb1 	bl	8021e1c <XMC_GPIO_SetMode>
 80296ba:	f8d9 3000 	ldr.w	r3, [r9]
 80296be:	e77b      	b.n	80295b8 <bsp_update+0x310>
 80296c0:	1ffe926c 	.word	0x1ffe926c
 80296c4:	1ffe9238 	.word	0x1ffe9238

080296c8 <bsp_init>:
    6. EXPORTED FUNCTIONS
==============================================================================
 */

uint8_t bsp_init(device_settings_t *p_dev)
{
 80296c8:	b538      	push	{r3, r4, r5, lr}
 80296ca:	4a11      	ldr	r2, [pc, #68]	; (8029710 <bsp_init+0x48>)
	/* Set all data acquisition functions callback to NULL */
	bsp_cb.bsp_acq_started_cb = NULL;
 80296cc:	4b11      	ldr	r3, [pc, #68]	; (8029714 <bsp_init+0x4c>)
 */
__STATIC_INLINE void DMA_CH_Disable(DMA_CH_t *const obj)
{
  XMC_ASSERT("DMA_CH_Disable: NULL DMA_CH_t object", (obj != NULL));

  XMC_DMA_CH_Disable(obj->dma_global->dma, obj->ch_num);
 80296ce:	6815      	ldr	r5, [r2, #0]
 80296d0:	7b11      	ldrb	r1, [r2, #12]
    6. EXPORTED FUNCTIONS
==============================================================================
 */

uint8_t bsp_init(device_settings_t *p_dev)
{
 80296d2:	4604      	mov	r4, r0
	/* Set all data acquisition functions callback to NULL */
	bsp_cb.bsp_acq_started_cb = NULL;
 80296d4:	2200      	movs	r2, #0
 80296d6:	6828      	ldr	r0, [r5, #0]
 80296d8:	601a      	str	r2, [r3, #0]
	bsp_cb.bsp_acq_done_cb = NULL;
 80296da:	605a      	str	r2, [r3, #4]
 80296dc:	f7f8 f948 	bl	8021970 <XMC_DMA_CH_Disable>
 80296e0:	4b0d      	ldr	r3, [pc, #52]	; (8029718 <bsp_init+0x50>)
 80296e2:	681a      	ldr	r2, [r3, #0]
 80296e4:	7b19      	ldrb	r1, [r3, #12]
 80296e6:	6810      	ldr	r0, [r2, #0]
 80296e8:	f7f8 f942 	bl	8021970 <XMC_DMA_CH_Disable>
 80296ec:	4b0b      	ldr	r3, [pc, #44]	; (802971c <bsp_init+0x54>)
 80296ee:	681a      	ldr	r2, [r3, #0]
 80296f0:	7b19      	ldrb	r1, [r3, #12]
 80296f2:	6810      	ldr	r0, [r2, #0]
 80296f4:	f7f8 f93c 	bl	8021970 <XMC_DMA_CH_Disable>
 80296f8:	4b09      	ldr	r3, [pc, #36]	; (8029720 <bsp_init+0x58>)
 80296fa:	681a      	ldr	r2, [r3, #0]
 80296fc:	7b19      	ldrb	r1, [r3, #12]
 80296fe:	6810      	ldr	r0, [r2, #0]
 8029700:	f7f8 f936 	bl	8021970 <XMC_DMA_CH_Disable>

	/* Disable DMA */
	dma_disable();

	return bsp_update(p_dev);
 8029704:	4620      	mov	r0, r4
}
 8029706:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	bsp_cb.bsp_acq_done_cb = NULL;

	/* Disable DMA */
	dma_disable();

	return bsp_update(p_dev);
 802970a:	f7ff bdcd 	b.w	80292a8 <bsp_update>
 802970e:	bf00      	nop
 8029710:	1ffe93d0 	.word	0x1ffe93d0
 8029714:	1ffedbf4 	.word	0x1ffedbf4
 8029718:	1ffe93e0 	.word	0x1ffe93e0
 802971c:	1ffe93f0 	.word	0x1ffe93f0
 8029720:	1ffe9400 	.word	0x1ffe9400

08029724 <CCU80_3_IRQHandler>:

//============================================================================

void INTERRUPT_BGT_VCC_ON_handler(void)
{
	if (l_acq_started)
 8029724:	4b12      	ldr	r3, [pc, #72]	; (8029770 <CCU80_3_IRQHandler+0x4c>)
 8029726:	681b      	ldr	r3, [r3, #0]
 8029728:	b183      	cbz	r3, 802974c <CCU80_3_IRQHandler+0x28>
	{
		if (use_vptag_sh_duty_cycle)
 802972a:	4b12      	ldr	r3, [pc, #72]	; (8029774 <CCU80_3_IRQHandler+0x50>)
 802972c:	681b      	ldr	r3, [r3, #0]
}

//============================================================================

void INTERRUPT_BGT_VCC_ON_handler(void)
{
 802972e:	b430      	push	{r4, r5}
	if (l_acq_started)
	{
		if (use_vptag_sh_duty_cycle)
 8029730:	b96b      	cbnz	r3, 802974e <CCU80_3_IRQHandler+0x2a>
 8029732:	4a11      	ldr	r2, [pc, #68]	; (8029778 <CCU80_3_IRQHandler+0x54>)
 8029734:	4b11      	ldr	r3, [pc, #68]	; (802977c <CCU80_3_IRQHandler+0x58>)

__STATIC_INLINE void XMC_GPIO_SetOutputHigh(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputHigh: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = (uint32_t)0x1U << pin;
 8029736:	7c10      	ldrb	r0, [r2, #16]
 8029738:	7c1c      	ldrb	r4, [r3, #16]
 802973a:	6811      	ldr	r1, [r2, #0]
 802973c:	681a      	ldr	r2, [r3, #0]
 802973e:	2301      	movs	r3, #1
 8029740:	fa03 f000 	lsl.w	r0, r3, r0
 8029744:	40a3      	lsls	r3, r4
			DIGITAL_IO_SetOutputHigh(&DIGITAL_IO_BGT_VCC_PTAT);
			/* ensure V_PTAT_SH_EN is enabled */
			DIGITAL_IO_SetOutputHigh(&DIGITAL_IO_V_PTAT_SH_EN);
		}
	}
}
 8029746:	bc30      	pop	{r4, r5}
 8029748:	6048      	str	r0, [r1, #4]
 802974a:	6053      	str	r3, [r2, #4]
 802974c:	4770      	bx	lr
 802974e:	4a0b      	ldr	r2, [pc, #44]	; (802977c <CCU80_3_IRQHandler+0x58>)
 8029750:	4b09      	ldr	r3, [pc, #36]	; (8029778 <CCU80_3_IRQHandler+0x54>)

__STATIC_INLINE void XMC_GPIO_SetOutputLow(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputLow: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = 0x10000U << pin;
 8029752:	7c14      	ldrb	r4, [r2, #16]
 8029754:	7c1d      	ldrb	r5, [r3, #16]
 8029756:	6811      	ldr	r1, [r2, #0]
 8029758:	681a      	ldr	r2, [r3, #0]

TIMER_STATUS_t bsp_timer_start(TIMER_t *const handle_timer)
{
	TIMER_STATUS_t status;

	status = TIMER_Start(handle_timer);
 802975a:	4809      	ldr	r0, [pc, #36]	; (8029780 <CCU80_3_IRQHandler+0x5c>)
 802975c:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8029760:	fa03 f404 	lsl.w	r4, r3, r4
 8029764:	40ab      	lsls	r3, r5
 8029766:	604c      	str	r4, [r1, #4]
 8029768:	6053      	str	r3, [r2, #4]
			DIGITAL_IO_SetOutputHigh(&DIGITAL_IO_BGT_VCC_PTAT);
			/* ensure V_PTAT_SH_EN is enabled */
			DIGITAL_IO_SetOutputHigh(&DIGITAL_IO_V_PTAT_SH_EN);
		}
	}
}
 802976a:	bc30      	pop	{r4, r5}

TIMER_STATUS_t bsp_timer_start(TIMER_t *const handle_timer)
{
	TIMER_STATUS_t status;

	status = TIMER_Start(handle_timer);
 802976c:	f7fc bb82 	b.w	8025e74 <TIMER_Start>
 8029770:	1ffeb488 	.word	0x1ffeb488
 8029774:	1ffe9618 	.word	0x1ffe9618
 8029778:	0802ddbc 	.word	0x0802ddbc
 802977c:	0802de48 	.word	0x0802de48
 8029780:	1ffe91c0 	.word	0x1ffe91c0

08029784 <CCU43_0_IRQHandler>:

//============================================================================

void INTERRUPT_PTAT_S_H_DELAY_handler(void)
{
	if (l_acq_started)
 8029784:	4b0b      	ldr	r3, [pc, #44]	; (80297b4 <CCU43_0_IRQHandler+0x30>)
 8029786:	681b      	ldr	r3, [r3, #0]
}

//============================================================================

void INTERRUPT_PTAT_S_H_DELAY_handler(void)
{
 8029788:	b510      	push	{r4, lr}
	if (l_acq_started)
 802978a:	b15b      	cbz	r3, 80297a4 <CCU43_0_IRQHandler+0x20>
 802978c:	4a0a      	ldr	r2, [pc, #40]	; (80297b8 <CCU43_0_IRQHandler+0x34>)
 802978e:	4b0b      	ldr	r3, [pc, #44]	; (80297bc <CCU43_0_IRQHandler+0x38>)

__STATIC_INLINE void XMC_GPIO_SetOutputHigh(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputHigh: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = (uint32_t)0x1U << pin;
 8029790:	7c10      	ldrb	r0, [r2, #16]
 8029792:	7c1c      	ldrb	r4, [r3, #16]
 8029794:	6811      	ldr	r1, [r2, #0]
 8029796:	681a      	ldr	r2, [r3, #0]
 8029798:	2301      	movs	r3, #1
 802979a:	fa03 f000 	lsl.w	r0, r3, r0
 802979e:	40a3      	lsls	r3, r4
 80297a0:	6048      	str	r0, [r1, #4]
 80297a2:	6053      	str	r3, [r2, #4]

TIMER_STATUS_t bsp_timer_stop_clear(TIMER_t *const handle_timer)
{
	TIMER_STATUS_t status;

	status = TIMER_Stop(handle_timer);
 80297a4:	4806      	ldr	r0, [pc, #24]	; (80297c0 <CCU43_0_IRQHandler+0x3c>)
 80297a6:	f7fc fb75 	bl	8025e94 <TIMER_Stop>

	status |= TIMER_Clear(handle_timer);
 80297aa:	4805      	ldr	r0, [pc, #20]	; (80297c0 <CCU43_0_IRQHandler+0x3c>)

		/* ensure V_PTAT_SH_EN is set to sample */
		DIGITAL_IO_SetOutputHigh(&DIGITAL_IO_V_PTAT_SH_EN);
	}
	bsp_timer_stop_clear(&TIMER_PTAT_S_H_DELAY);
}
 80297ac:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
{
	TIMER_STATUS_t status;

	status = TIMER_Stop(handle_timer);

	status |= TIMER_Clear(handle_timer);
 80297b0:	f7fc bbfa 	b.w	8025fa8 <TIMER_Clear>
 80297b4:	1ffeb488 	.word	0x1ffeb488
 80297b8:	0802ddbc 	.word	0x0802ddbc
 80297bc:	0802de48 	.word	0x0802de48
 80297c0:	1ffe91c0 	.word	0x1ffe91c0

080297c4 <CCU43_2_IRQHandler>:
}

//============================================================================

void INTERRUPT_BB_PRE_TRIGGER_handler(void)
{
 80297c4:	b510      	push	{r4, lr}

TIMER_STATUS_t bsp_timer_stop_clear(TIMER_t *const handle_timer)
{
	TIMER_STATUS_t status;

	status = TIMER_Stop(handle_timer);
 80297c6:	4810      	ldr	r0, [pc, #64]	; (8029808 <CCU43_2_IRQHandler+0x44>)
 80297c8:	f7fc fb64 	bl	8025e94 <TIMER_Stop>

	status |= TIMER_Clear(handle_timer);
 80297cc:	480e      	ldr	r0, [pc, #56]	; (8029808 <CCU43_2_IRQHandler+0x44>)
 80297ce:	f7fc fbeb 	bl	8025fa8 <TIMER_Clear>

void INTERRUPT_BB_PRE_TRIGGER_handler(void)
{
	bsp_timer_stop_clear(&TIMER_BB_PRE_TRIGGER);

	if (ptat_switch_delay_usec > 0 && (bb_pre_trigger_advance_usec > (int32_t)ptat_switch_delay_usec))
 80297d2:	4b0e      	ldr	r3, [pc, #56]	; (802980c <CCU43_2_IRQHandler+0x48>)
 80297d4:	681b      	ldr	r3, [r3, #0]
 80297d6:	b11b      	cbz	r3, 80297e0 <CCU43_2_IRQHandler+0x1c>
 80297d8:	4a0d      	ldr	r2, [pc, #52]	; (8029810 <CCU43_2_IRQHandler+0x4c>)
 80297da:	6812      	ldr	r2, [r2, #0]
 80297dc:	4293      	cmp	r3, r2
 80297de:	db0c      	blt.n	80297fa <CCU43_2_IRQHandler+0x36>
 80297e0:	4a0c      	ldr	r2, [pc, #48]	; (8029814 <CCU43_2_IRQHandler+0x50>)
 80297e2:	4b0d      	ldr	r3, [pc, #52]	; (8029818 <CCU43_2_IRQHandler+0x54>)
 80297e4:	7c10      	ldrb	r0, [r2, #16]
 80297e6:	7c1c      	ldrb	r4, [r3, #16]
 80297e8:	6811      	ldr	r1, [r2, #0]
 80297ea:	681a      	ldr	r2, [r3, #0]
 80297ec:	2301      	movs	r3, #1
 80297ee:	fa03 f000 	lsl.w	r0, r3, r0
 80297f2:	40a3      	lsls	r3, r4
 80297f4:	6048      	str	r0, [r1, #4]
 80297f6:	6053      	str	r3, [r2, #4]
 80297f8:	bd10      	pop	{r4, pc}

TIMER_STATUS_t bsp_timer_start(TIMER_t *const handle_timer)
{
	TIMER_STATUS_t status;

	status = TIMER_Start(handle_timer);
 80297fa:	4808      	ldr	r0, [pc, #32]	; (802981c <CCU43_2_IRQHandler+0x58>)
 80297fc:	f7fc fb3a 	bl	8025e74 <TIMER_Start>
 8029800:	4a07      	ldr	r2, [pc, #28]	; (8029820 <CCU43_2_IRQHandler+0x5c>)
 8029802:	4b08      	ldr	r3, [pc, #32]	; (8029824 <CCU43_2_IRQHandler+0x60>)
 8029804:	e7ee      	b.n	80297e4 <CCU43_2_IRQHandler+0x20>
 8029806:	bf00      	nop
 8029808:	1ffe9168 	.word	0x1ffe9168
 802980c:	1ffeb490 	.word	0x1ffeb490
 8029810:	1ffe960c 	.word	0x1ffe960c
 8029814:	0802dd94 	.word	0x0802dd94
 8029818:	0802dda8 	.word	0x0802dda8
 802981c:	1ffe9130 	.word	0x1ffe9130
 8029820:	0802ddbc 	.word	0x0802ddbc
 8029824:	0802de48 	.word	0x0802de48

08029828 <bsp_bgt_shut_down>:
//============================================================================

static void bgt24ltr1x_shut_down(void)
{
	/* Stop BGT */
	PWM_CCU8_Stop(&PWM_CCU8_BGT_VCC);
 8029828:	4801      	ldr	r0, [pc, #4]	; (8029830 <bsp_bgt_shut_down+0x8>)
 802982a:	f7fc bd95 	b.w	8026358 <PWM_CCU8_Stop>
 802982e:	bf00      	nop
 8029830:	1ffe9238 	.word	0x1ffe9238

08029834 <bsp_timer_stop_clear>:
}

//============================================================================

TIMER_STATUS_t bsp_timer_stop_clear(TIMER_t *const handle_timer)
{
 8029834:	b538      	push	{r3, r4, r5, lr}
 8029836:	4605      	mov	r5, r0
	TIMER_STATUS_t status;

	status = TIMER_Stop(handle_timer);
 8029838:	f7fc fb2c 	bl	8025e94 <TIMER_Stop>
 802983c:	4604      	mov	r4, r0

	status |= TIMER_Clear(handle_timer);
 802983e:	4628      	mov	r0, r5
 8029840:	f7fc fbb2 	bl	8025fa8 <TIMER_Clear>
 8029844:	4320      	orrs	r0, r4

	return (status);
}
 8029846:	b2c0      	uxtb	r0, r0
 8029848:	bd38      	pop	{r3, r4, r5, pc}
 802984a:	bf00      	nop

0802984c <bsp_timer_start>:

TIMER_STATUS_t bsp_timer_start(TIMER_t *const handle_timer)
{
	TIMER_STATUS_t status;

	status = TIMER_Start(handle_timer);
 802984c:	f7fc bb12 	b.w	8025e74 <TIMER_Start>

08029850 <bsp_dma_set_adc_control_from_acq_buf_obj>:
}

//============================================================================

void bsp_dma_set_adc_control_from_acq_buf_obj(acq_buf_obj *acq_buf)
{
 8029850:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	pDMA_src_G1 = (uint32_t *)&ADC_MEASUREMENT_ADV_G1_CH_G1_RES;
	pDMA_src_G2 = (uint32_t *)&ADC_MEASUREMENT_ADV_G2_CH_G2_RES;
	pDMA_src_G3 = (uint32_t *)&ADC_MEASUREMENT_ADV_G3_CH_G3_RES;

	/* Set the source address pointers for each DMA transfer */
	XMC_DMA_CH_SetSourceAddress(DMA_CH_G0.dma_global->dma, DMA_CH_G0.ch_num, (uint32_t)pDMA_src_G0);
 8029854:	4b36      	ldr	r3, [pc, #216]	; (8029930 <bsp_dma_set_adc_control_from_acq_buf_obj+0xe0>)
//============================================================================

static void dma_set_source_addr(void)
{
	/* DMA Source/Destination Address setup */
	pDMA_src_G0 = (uint32_t *)&ADC_MEASUREMENT_ADV_G0_CH_G0_RES;
 8029856:	4c37      	ldr	r4, [pc, #220]	; (8029934 <bsp_dma_set_adc_control_from_acq_buf_obj+0xe4>)
	pDMA_src_G1 = (uint32_t *)&ADC_MEASUREMENT_ADV_G1_CH_G1_RES;
	pDMA_src_G2 = (uint32_t *)&ADC_MEASUREMENT_ADV_G2_CH_G2_RES;
	pDMA_src_G3 = (uint32_t *)&ADC_MEASUREMENT_ADV_G3_CH_G3_RES;

	/* Set the source address pointers for each DMA transfer */
	XMC_DMA_CH_SetSourceAddress(DMA_CH_G0.dma_global->dma, DMA_CH_G0.ch_num, (uint32_t)pDMA_src_G0);
 8029858:	6819      	ldr	r1, [r3, #0]
 * \par<b>Related API: </b><br>
 * ::XMC_DMA_CH_SetDestinationAddress() <br>
 */
__STATIC_INLINE void XMC_DMA_CH_SetSourceAddress(XMC_DMA_t *const dma, const uint8_t channel, uint32_t addr)
{
  dma->CH[channel].SAR = addr;
 802985a:	7b1a      	ldrb	r2, [r3, #12]
 802985c:	f8d1 8000 	ldr.w	r8, [r1]
//============================================================================

static void dma_set_source_addr(void)
{
	/* DMA Source/Destination Address setup */
	pDMA_src_G0 = (uint32_t *)&ADC_MEASUREMENT_ADV_G0_CH_G0_RES;
 8029860:	4935      	ldr	r1, [pc, #212]	; (8029938 <bsp_dma_set_adc_control_from_acq_buf_obj+0xe8>)
 8029862:	6021      	str	r1, [r4, #0]
 8029864:	2458      	movs	r4, #88	; 0x58
 8029866:	fb04 f202 	mul.w	r2, r4, r2
	pDMA_src_G1 = (uint32_t *)&ADC_MEASUREMENT_ADV_G1_CH_G1_RES;
 802986a:	4f34      	ldr	r7, [pc, #208]	; (802993c <bsp_dma_set_adc_control_from_acq_buf_obj+0xec>)
	pDMA_src_G2 = (uint32_t *)&ADC_MEASUREMENT_ADV_G2_CH_G2_RES;
 802986c:	4e34      	ldr	r6, [pc, #208]	; (8029940 <bsp_dma_set_adc_control_from_acq_buf_obj+0xf0>)
	pDMA_src_G3 = (uint32_t *)&ADC_MEASUREMENT_ADV_G3_CH_G3_RES;
 802986e:	4b35      	ldr	r3, [pc, #212]	; (8029944 <bsp_dma_set_adc_control_from_acq_buf_obj+0xf4>)

static void dma_set_source_addr(void)
{
	/* DMA Source/Destination Address setup */
	pDMA_src_G0 = (uint32_t *)&ADC_MEASUREMENT_ADV_G0_CH_G0_RES;
	pDMA_src_G1 = (uint32_t *)&ADC_MEASUREMENT_ADV_G1_CH_G1_RES;
 8029870:	f8df a0e0 	ldr.w	sl, [pc, #224]	; 8029954 <bsp_dma_set_adc_control_from_acq_buf_obj+0x104>
	pDMA_src_G2 = (uint32_t *)&ADC_MEASUREMENT_ADV_G2_CH_G2_RES;
 8029874:	f8df c0e0 	ldr.w	ip, [pc, #224]	; 8029958 <bsp_dma_set_adc_control_from_acq_buf_obj+0x108>
	pDMA_src_G3 = (uint32_t *)&ADC_MEASUREMENT_ADV_G3_CH_G3_RES;
 8029878:	4d33      	ldr	r5, [pc, #204]	; (8029948 <bsp_dma_set_adc_control_from_acq_buf_obj+0xf8>)

static void dma_set_source_addr(void)
{
	/* DMA Source/Destination Address setup */
	pDMA_src_G0 = (uint32_t *)&ADC_MEASUREMENT_ADV_G0_CH_G0_RES;
	pDMA_src_G1 = (uint32_t *)&ADC_MEASUREMENT_ADV_G1_CH_G1_RES;
 802987a:	f8c7 a000 	str.w	sl, [r7]
	pDMA_src_G2 = (uint32_t *)&ADC_MEASUREMENT_ADV_G2_CH_G2_RES;
 802987e:	f8c6 c000 	str.w	ip, [r6]
	pDMA_src_G3 = (uint32_t *)&ADC_MEASUREMENT_ADV_G3_CH_G3_RES;
 8029882:	601d      	str	r5, [r3, #0]
 8029884:	f848 1002 	str.w	r1, [r8, r2]

	/* Set the source address pointers for each DMA transfer */
	XMC_DMA_CH_SetSourceAddress(DMA_CH_G0.dma_global->dma, DMA_CH_G0.ch_num, (uint32_t)pDMA_src_G0);
	XMC_DMA_CH_SetSourceAddress(DMA_CH_G1.dma_global->dma, DMA_CH_G1.ch_num, (uint32_t)pDMA_src_G1);
 8029888:	4b30      	ldr	r3, [pc, #192]	; (802994c <bsp_dma_set_adc_control_from_acq_buf_obj+0xfc>)
	XMC_DMA_CH_SetSourceAddress(DMA_CH_G2.dma_global->dma, DMA_CH_G2.ch_num, (uint32_t)pDMA_src_G2);
	XMC_DMA_CH_SetSourceAddress(DMA_CH_G3.dma_global->dma, DMA_CH_G3.ch_num, (uint32_t)pDMA_src_G3);
 802988a:	f8df e0d0 	ldr.w	lr, [pc, #208]	; 802995c <bsp_dma_set_adc_control_from_acq_buf_obj+0x10c>
	pDMA_src_G2 = (uint32_t *)&ADC_MEASUREMENT_ADV_G2_CH_G2_RES;
	pDMA_src_G3 = (uint32_t *)&ADC_MEASUREMENT_ADV_G3_CH_G3_RES;

	/* Set the source address pointers for each DMA transfer */
	XMC_DMA_CH_SetSourceAddress(DMA_CH_G0.dma_global->dma, DMA_CH_G0.ch_num, (uint32_t)pDMA_src_G0);
	XMC_DMA_CH_SetSourceAddress(DMA_CH_G1.dma_global->dma, DMA_CH_G1.ch_num, (uint32_t)pDMA_src_G1);
 802988e:	6819      	ldr	r1, [r3, #0]
	XMC_DMA_CH_SetSourceAddress(DMA_CH_G2.dma_global->dma, DMA_CH_G2.ch_num, (uint32_t)pDMA_src_G2);
 8029890:	f8df 90cc 	ldr.w	r9, [pc, #204]	; 8029960 <bsp_dma_set_adc_control_from_acq_buf_obj+0x110>
 8029894:	7b1b      	ldrb	r3, [r3, #12]
	pDMA_src_G2 = (uint32_t *)&ADC_MEASUREMENT_ADV_G2_CH_G2_RES;
	pDMA_src_G3 = (uint32_t *)&ADC_MEASUREMENT_ADV_G3_CH_G3_RES;

	/* Set the source address pointers for each DMA transfer */
	XMC_DMA_CH_SetSourceAddress(DMA_CH_G0.dma_global->dma, DMA_CH_G0.ch_num, (uint32_t)pDMA_src_G0);
	XMC_DMA_CH_SetSourceAddress(DMA_CH_G1.dma_global->dma, DMA_CH_G1.ch_num, (uint32_t)pDMA_src_G1);
 8029896:	680e      	ldr	r6, [r1, #0]
	XMC_DMA_CH_SetSourceAddress(DMA_CH_G2.dma_global->dma, DMA_CH_G2.ch_num, (uint32_t)pDMA_src_G2);
 8029898:	f8d9 7000 	ldr.w	r7, [r9]
	XMC_DMA_CH_SetSourceAddress(DMA_CH_G3.dma_global->dma, DMA_CH_G3.ch_num, (uint32_t)pDMA_src_G3);
 802989c:	f8de 1000 	ldr.w	r1, [lr]
	pDMA_src_G3 = (uint32_t *)&ADC_MEASUREMENT_ADV_G3_CH_G3_RES;

	/* Set the source address pointers for each DMA transfer */
	XMC_DMA_CH_SetSourceAddress(DMA_CH_G0.dma_global->dma, DMA_CH_G0.ch_num, (uint32_t)pDMA_src_G0);
	XMC_DMA_CH_SetSourceAddress(DMA_CH_G1.dma_global->dma, DMA_CH_G1.ch_num, (uint32_t)pDMA_src_G1);
	XMC_DMA_CH_SetSourceAddress(DMA_CH_G2.dma_global->dma, DMA_CH_G2.ch_num, (uint32_t)pDMA_src_G2);
 80298a0:	683f      	ldr	r7, [r7, #0]
	XMC_DMA_CH_SetSourceAddress(DMA_CH_G3.dma_global->dma, DMA_CH_G3.ch_num, (uint32_t)pDMA_src_G3);
 80298a2:	f8d1 b000 	ldr.w	fp, [r1]
void bsp_dma_set_adc_control_from_acq_buf_obj(acq_buf_obj *acq_buf)
{
	dma_set_source_addr();

	/* We use a 2nd buffer here, to be able to run the signal processing in parallel to the data acquisition */
	pDMA_dst_G0 = (uint32_t *)&data_buffer[0][0];
 80298a6:	492a      	ldr	r1, [pc, #168]	; (8029950 <bsp_dma_set_adc_control_from_acq_buf_obj+0x100>)
 80298a8:	fb04 f303 	mul.w	r3, r4, r3
 80298ac:	4442      	add	r2, r8
 80298ae:	f846 a003 	str.w	sl, [r6, r3]
 80298b2:	f899 900c 	ldrb.w	r9, [r9, #12]
	XMC_DMA_CH_SetDestinationAddress(DMA_CH_G0.dma_global->dma, DMA_CH_G0.ch_num, (uint32_t)pDMA_dst_G0);
	XMC_DMA_CH_SetDestinationAddress(DMA_CH_G1.dma_global->dma, DMA_CH_G1.ch_num, (uint32_t)pDMA_dst_G1);
	XMC_DMA_CH_SetDestinationAddress(DMA_CH_G2.dma_global->dma, DMA_CH_G2.ch_num, (uint32_t)pDMA_dst_G2);
	XMC_DMA_CH_SetDestinationAddress(DMA_CH_G3.dma_global->dma, DMA_CH_G3.ch_num, (uint32_t)pDMA_dst_G3);

	uint32_t block_size = acq_buf->internals.skip_count + acq_buf->params.num_of_samples_per_chirp;
 80298b6:	f8b0 a002 	ldrh.w	sl, [r0, #2]
 80298ba:	69c0      	ldr	r0, [r0, #28]
 80298bc:	fb04 f909 	mul.w	r9, r4, r9
 80298c0:	4433      	add	r3, r6
 80298c2:	f847 c009 	str.w	ip, [r7, r9]
 80298c6:	f89e 800c 	ldrb.w	r8, [lr, #12]

	/* We use a 2nd buffer here, to be able to run the signal processing in parallel to the data acquisition */
	pDMA_dst_G0 = (uint32_t *)&data_buffer[0][0];
	pDMA_dst_G1 = (uint32_t *)&data_buffer[1][0];
	pDMA_dst_G2 = (uint32_t *)&data_buffer[2][0];
	pDMA_dst_G3 = (uint32_t *)&data_buffer[3][0];
 80298ca:	f8df c098 	ldr.w	ip, [pc, #152]	; 8029964 <bsp_dma_set_adc_control_from_acq_buf_obj+0x114>
{
	dma_set_source_addr();

	/* We use a 2nd buffer here, to be able to run the signal processing in parallel to the data acquisition */
	pDMA_dst_G0 = (uint32_t *)&data_buffer[0][0];
	pDMA_dst_G1 = (uint32_t *)&data_buffer[1][0];
 80298ce:	f8df e098 	ldr.w	lr, [pc, #152]	; 8029968 <bsp_dma_set_adc_control_from_acq_buf_obj+0x118>
 80298d2:	fb04 f408 	mul.w	r4, r4, r8
 80298d6:	44b9      	add	r9, r7
 80298d8:	f84b 5004 	str.w	r5, [fp, r4]
 * see ::XMC_DMA_CH_Enable() for more information.
 *
 */
__STATIC_INLINE void XMC_DMA_CH_SetBlockSize(XMC_DMA_t *const dma, const uint8_t channel, uint32_t block_size)
{
  dma->CH[channel].CTLH = block_size;
 80298dc:	f102 0718 	add.w	r7, r2, #24
 * \par<b>Related API: </b><br>
 * ::XMC_DMA_CH_SetSourceAddress() <br>
 */
__STATIC_INLINE void XMC_DMA_CH_SetDestinationAddress(XMC_DMA_t *const dma, const uint8_t channel, uint32_t addr)
{
  dma->CH[channel].DAR = addr;
 80298e0:	6091      	str	r1, [r2, #8]
 80298e2:	f501 621d 	add.w	r2, r1, #2512	; 0x9d0
 80298e6:	609a      	str	r2, [r3, #8]
 * see ::XMC_DMA_CH_Enable() for more information.
 *
 */
__STATIC_INLINE void XMC_DMA_CH_SetBlockSize(XMC_DMA_t *const dma, const uint8_t channel, uint32_t block_size)
{
  dma->CH[channel].CTLH = block_size;
 80298e8:	f103 0618 	add.w	r6, r3, #24
	pDMA_dst_G2 = (uint32_t *)&data_buffer[2][0];
 80298ec:	f501 539d 	add.w	r3, r1, #5024	; 0x13a0
 * \par<b>Related API: </b><br>
 * ::XMC_DMA_CH_SetSourceAddress() <br>
 */
__STATIC_INLINE void XMC_DMA_CH_SetDestinationAddress(XMC_DMA_t *const dma, const uint8_t channel, uint32_t addr)
{
  dma->CH[channel].DAR = addr;
 80298f0:	f8c9 3008 	str.w	r3, [r9, #8]
	XMC_DMA_CH_SetDestinationAddress(DMA_CH_G0.dma_global->dma, DMA_CH_G0.ch_num, (uint32_t)pDMA_dst_G0);
	XMC_DMA_CH_SetDestinationAddress(DMA_CH_G1.dma_global->dma, DMA_CH_G1.ch_num, (uint32_t)pDMA_dst_G1);
	XMC_DMA_CH_SetDestinationAddress(DMA_CH_G2.dma_global->dma, DMA_CH_G2.ch_num, (uint32_t)pDMA_dst_G2);
	XMC_DMA_CH_SetDestinationAddress(DMA_CH_G3.dma_global->dma, DMA_CH_G3.ch_num, (uint32_t)pDMA_dst_G3);

	uint32_t block_size = acq_buf->internals.skip_count + acq_buf->params.num_of_samples_per_chirp;
 80298f4:	4450      	add	r0, sl
 * \par<b>Related API: </b><br>
 * ::XMC_DMA_CH_SetDestinationAddress() <br>
 */
__STATIC_INLINE void XMC_DMA_CH_SetSourceAddress(XMC_DMA_t *const dma, const uint8_t channel, uint32_t addr)
{
  dma->CH[channel].SAR = addr;
 80298f6:	eb0b 0804 	add.w	r8, fp, r4
 * see ::XMC_DMA_CH_Enable() for more information.
 *
 */
__STATIC_INLINE void XMC_DMA_CH_SetBlockSize(XMC_DMA_t *const dma, const uint8_t channel, uint32_t block_size)
{
  dma->CH[channel].CTLH = block_size;
 80298fa:	f109 0a18 	add.w	sl, r9, #24

	/* We use a 2nd buffer here, to be able to run the signal processing in parallel to the data acquisition */
	pDMA_dst_G0 = (uint32_t *)&data_buffer[0][0];
	pDMA_dst_G1 = (uint32_t *)&data_buffer[1][0];
	pDMA_dst_G2 = (uint32_t *)&data_buffer[2][0];
	pDMA_dst_G3 = (uint32_t *)&data_buffer[3][0];
 80298fe:	f501 54eb 	add.w	r4, r1, #7520	; 0x1d60
	dma_set_source_addr();

	/* We use a 2nd buffer here, to be able to run the signal processing in parallel to the data acquisition */
	pDMA_dst_G0 = (uint32_t *)&data_buffer[0][0];
	pDMA_dst_G1 = (uint32_t *)&data_buffer[1][0];
	pDMA_dst_G2 = (uint32_t *)&data_buffer[2][0];
 8029902:	f8df b068 	ldr.w	fp, [pc, #104]	; 802996c <bsp_dma_set_adc_control_from_acq_buf_obj+0x11c>
void bsp_dma_set_adc_control_from_acq_buf_obj(acq_buf_obj *acq_buf)
{
	dma_set_source_addr();

	/* We use a 2nd buffer here, to be able to run the signal processing in parallel to the data acquisition */
	pDMA_dst_G0 = (uint32_t *)&data_buffer[0][0];
 8029906:	f8df 9068 	ldr.w	r9, [pc, #104]	; 8029970 <bsp_dma_set_adc_control_from_acq_buf_obj+0x120>
	pDMA_dst_G1 = (uint32_t *)&data_buffer[1][0];
 802990a:	f8ce 2000 	str.w	r2, [lr]
	pDMA_dst_G2 = (uint32_t *)&data_buffer[2][0];
	pDMA_dst_G3 = (uint32_t *)&data_buffer[3][0];
 802990e:	3410      	adds	r4, #16
 * \par<b>Related API: </b><br>
 * ::XMC_DMA_CH_SetSourceAddress() <br>
 */
__STATIC_INLINE void XMC_DMA_CH_SetDestinationAddress(XMC_DMA_t *const dma, const uint8_t channel, uint32_t addr)
{
  dma->CH[channel].DAR = addr;
 8029910:	f8c8 4008 	str.w	r4, [r8, #8]
 8029914:	f8cc 4000 	str.w	r4, [ip]
 * see ::XMC_DMA_CH_Enable() for more information.
 *
 */
__STATIC_INLINE void XMC_DMA_CH_SetBlockSize(XMC_DMA_t *const dma, const uint8_t channel, uint32_t block_size)
{
  dma->CH[channel].CTLH = block_size;
 8029918:	6078      	str	r0, [r7, #4]
	dma_set_source_addr();

	/* We use a 2nd buffer here, to be able to run the signal processing in parallel to the data acquisition */
	pDMA_dst_G0 = (uint32_t *)&data_buffer[0][0];
	pDMA_dst_G1 = (uint32_t *)&data_buffer[1][0];
	pDMA_dst_G2 = (uint32_t *)&data_buffer[2][0];
 802991a:	f8cb 3000 	str.w	r3, [fp]
 802991e:	6070      	str	r0, [r6, #4]
 8029920:	f8ca 0004 	str.w	r0, [sl, #4]
void bsp_dma_set_adc_control_from_acq_buf_obj(acq_buf_obj *acq_buf)
{
	dma_set_source_addr();

	/* We use a 2nd buffer here, to be able to run the signal processing in parallel to the data acquisition */
	pDMA_dst_G0 = (uint32_t *)&data_buffer[0][0];
 8029924:	f8c9 1000 	str.w	r1, [r9]
 8029928:	f8c8 001c 	str.w	r0, [r8, #28]
 802992c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8029930:	1ffe93d0 	.word	0x1ffe93d0
 8029934:	1ffedbdc 	.word	0x1ffedbdc
 8029938:	4000473c 	.word	0x4000473c
 802993c:	1ffedbe0 	.word	0x1ffedbe0
 8029940:	1ffedbe4 	.word	0x1ffedbe4
 8029944:	1ffedbe8 	.word	0x1ffedbe8
 8029948:	40005310 	.word	0x40005310
 802994c:	1ffe93e0 	.word	0x1ffe93e0
 8029950:	1ffeb498 	.word	0x1ffeb498
 8029954:	40004b0c 	.word	0x40004b0c
 8029958:	40004f00 	.word	0x40004f00
 802995c:	1ffe9400 	.word	0x1ffe9400
 8029960:	1ffe93f0 	.word	0x1ffe93f0
 8029964:	1ffeb480 	.word	0x1ffeb480
 8029968:	1ffedbf0 	.word	0x1ffedbf0
 802996c:	1ffedbd8 	.word	0x1ffedbd8
 8029970:	1ffedbec 	.word	0x1ffedbec

08029974 <bsp_trigger_new_frame>:
}

//============================================================================

void bsp_trigger_new_frame(void)
{
 8029974:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8029978:	4f2c      	ldr	r7, [pc, #176]	; (8029a2c <bsp_trigger_new_frame+0xb8>)
 802997a:	4e2d      	ldr	r6, [pc, #180]	; (8029a30 <bsp_trigger_new_frame+0xbc>)
 802997c:	683a      	ldr	r2, [r7, #0]
==============================================================================
 */

static void trigger_dma_start(void)
{
	watchdog_status = 0;
 802997e:	4b2d      	ldr	r3, [pc, #180]	; (8029a34 <bsp_trigger_new_frame+0xc0>)
 8029980:	6810      	ldr	r0, [r2, #0]
 8029982:	7b39      	ldrb	r1, [r7, #12]
 8029984:	4d2c      	ldr	r5, [pc, #176]	; (8029a38 <bsp_trigger_new_frame+0xc4>)
 8029986:	4c2d      	ldr	r4, [pc, #180]	; (8029a3c <bsp_trigger_new_frame+0xc8>)
}

//============================================================================

void bsp_trigger_new_frame(void)
{
 8029988:	b081      	sub	sp, #4
==============================================================================
 */

static void trigger_dma_start(void)
{
	watchdog_status = 0;
 802998a:	f04f 0800 	mov.w	r8, #0
 802998e:	f883 8000 	strb.w	r8, [r3]
 8029992:	f7f7 ffed 	bl	8021970 <XMC_DMA_CH_Disable>
 8029996:	6833      	ldr	r3, [r6, #0]
 8029998:	7b31      	ldrb	r1, [r6, #12]
 802999a:	6818      	ldr	r0, [r3, #0]
 802999c:	f7f7 ffe8 	bl	8021970 <XMC_DMA_CH_Disable>
 80299a0:	682b      	ldr	r3, [r5, #0]
 80299a2:	7b29      	ldrb	r1, [r5, #12]
 80299a4:	6818      	ldr	r0, [r3, #0]
 80299a6:	f7f7 ffe3 	bl	8021970 <XMC_DMA_CH_Disable>
 80299aa:	6823      	ldr	r3, [r4, #0]
 80299ac:	7b21      	ldrb	r1, [r4, #12]
 80299ae:	6818      	ldr	r0, [r3, #0]
 80299b0:	f7f7 ffde 	bl	8021970 <XMC_DMA_CH_Disable>

	/* DMA Reconfiguration */
	dma_disable();

	acq_buf_obj *p_acq_buf = ds_get_active_acq_buf();
 80299b4:	f7f6 fda0 	bl	80204f8 <ds_get_active_acq_buf>

	bsp_dma_set_adc_control_from_acq_buf_obj(p_acq_buf);
 80299b8:	f7ff ff4a 	bl	8029850 <bsp_dma_set_adc_control_from_acq_buf_obj>
//============================================================================

static void bgt24ltr1x_start_up(void)
{
	/* Start BGT */
	PWM_CCU8_Start(&PWM_CCU8_BGT_VCC);
 80299bc:	4820      	ldr	r0, [pc, #128]	; (8029a40 <bsp_trigger_new_frame+0xcc>)
 80299be:	f7fc fcb1 	bl	8026324 <PWM_CCU8_Start>
 */
__STATIC_INLINE void DMA_CH_Enable(DMA_CH_t *const obj)
{
  XMC_ASSERT("DMA_CH_Enable: NULL DMA_CH_t object", (obj != NULL));

  XMC_DMA_CH_Enable(obj->dma_global->dma, obj->ch_num);
 80299c2:	6830      	ldr	r0, [r6, #0]
 80299c4:	6829      	ldr	r1, [r5, #0]
 80299c6:	6822      	ldr	r2, [r4, #0]
{
	/* Get the raw ADC data */
	trigger_dma_start();

	/* This callback is used to inform upper layers about the beginning of data acquisition process */
	if (bsp_cb.bsp_acq_started_cb != NULL)
 80299c8:	4b1e      	ldr	r3, [pc, #120]	; (8029a44 <bsp_trigger_new_frame+0xd0>)
 80299ca:	f8d7 b000 	ldr.w	fp, [r7]
 * ensure that the GPDMA module itself is enabled before calling this function.
 * See ::XMC_DMA_Enable() for details.
 */
__STATIC_INLINE void XMC_DMA_CH_Enable(XMC_DMA_t *const dma, const uint8_t channel)
{
  dma->CHENREG = (uint32_t)(0x101UL << channel);   
 80299ce:	f894 c00c 	ldrb.w	ip, [r4, #12]
 80299d2:	f897 e00c 	ldrb.w	lr, [r7, #12]
 80299d6:	f896 900c 	ldrb.w	r9, [r6, #12]
 80299da:	f895 a00c 	ldrb.w	sl, [r5, #12]
 80299de:	f8db 7000 	ldr.w	r7, [fp]
 80299e2:	6805      	ldr	r5, [r0, #0]
	bsp_bgt_start_up();

	/* Enable DMA */
	dma_enable();

	l_acq_started = 1;
 80299e4:	4e18      	ldr	r6, [pc, #96]	; (8029a48 <bsp_trigger_new_frame+0xd4>)
 80299e6:	6808      	ldr	r0, [r1, #0]
 80299e8:	6811      	ldr	r1, [r2, #0]
{
	/* Get the raw ADC data */
	trigger_dma_start();

	/* This callback is used to inform upper layers about the beginning of data acquisition process */
	if (bsp_cb.bsp_acq_started_cb != NULL)
 80299ea:	681a      	ldr	r2, [r3, #0]
 80299ec:	f240 1301 	movw	r3, #257	; 0x101
 80299f0:	fa03 fe0e 	lsl.w	lr, r3, lr
 80299f4:	fa03 f909 	lsl.w	r9, r3, r9
 80299f8:	fa03 f40a 	lsl.w	r4, r3, sl
 80299fc:	fa03 f30c 	lsl.w	r3, r3, ip
	bsp_bgt_start_up();

	/* Enable DMA */
	dma_enable();

	l_acq_started = 1;
 8029a00:	f04f 0c01 	mov.w	ip, #1
 8029a04:	f8c7 e3a0 	str.w	lr, [r7, #928]	; 0x3a0
 8029a08:	f8c6 c000 	str.w	ip, [r6]
 8029a0c:	f8c5 93a0 	str.w	r9, [r5, #928]	; 0x3a0
 8029a10:	f8c0 43a0 	str.w	r4, [r0, #928]	; 0x3a0
 8029a14:	f8c1 33a0 	str.w	r3, [r1, #928]	; 0x3a0
{
	/* Get the raw ADC data */
	trigger_dma_start();

	/* This callback is used to inform upper layers about the beginning of data acquisition process */
	if (bsp_cb.bsp_acq_started_cb != NULL)
 8029a18:	b122      	cbz	r2, 8029a24 <bsp_trigger_new_frame+0xb0>
	{
		bsp_cb.bsp_acq_started_cb(NULL);
 8029a1a:	4640      	mov	r0, r8
	}
}
 8029a1c:	b001      	add	sp, #4
 8029a1e:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	trigger_dma_start();

	/* This callback is used to inform upper layers about the beginning of data acquisition process */
	if (bsp_cb.bsp_acq_started_cb != NULL)
	{
		bsp_cb.bsp_acq_started_cb(NULL);
 8029a22:	4710      	bx	r2
	}
}
 8029a24:	b001      	add	sp, #4
 8029a26:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8029a2a:	bf00      	nop
 8029a2c:	1ffe93d0 	.word	0x1ffe93d0
 8029a30:	1ffe93e0 	.word	0x1ffe93e0
 8029a34:	1ffeb484 	.word	0x1ffeb484
 8029a38:	1ffe93f0 	.word	0x1ffe93f0
 8029a3c:	1ffe9400 	.word	0x1ffe9400
 8029a40:	1ffe9238 	.word	0x1ffe9238
 8029a44:	1ffedbf4 	.word	0x1ffedbf4
 8029a48:	1ffeb488 	.word	0x1ffeb488

08029a4c <DMA_Event_Handler>:

//============================================================================

void DMA_Event_Handler(XMC_DMA_CH_EVENT_t dma_event)
{
	if ((dma_event & XMC_DMA_CH_EVENT_BLOCK_TRANSFER_COMPLETE) != 0)
 8029a4c:	0783      	lsls	r3, r0, #30
 8029a4e:	d400      	bmi.n	8029a52 <DMA_Event_Handler+0x6>
 8029a50:	4770      	bx	lr
}

//============================================================================

void DMA_Event_Handler(XMC_DMA_CH_EVENT_t dma_event)
{
 8029a52:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8029a56:	b087      	sub	sp, #28
	if ((dma_event & XMC_DMA_CH_EVENT_BLOCK_TRANSFER_COMPLETE) != 0)
	{
		/* In case of continuous mode */
		if (radar_get_data_acq_mode() == RADAR_DATA_CONTINUOUS_MODE)
 8029a58:	f7f7 f8b0 	bl	8020bbc <radar_get_data_acq_mode>
 8029a5c:	2802      	cmp	r0, #2
 8029a5e:	4681      	mov	r9, r0
 8029a60:	f000 80bb 	beq.w	8029bda <DMA_Event_Handler+0x18e>
			bsp_frame_counter++;
		}
		else /* In normal mode */
		{

			l_acq_started = 0;
 8029a64:	4baf      	ldr	r3, [pc, #700]	; (8029d24 <DMA_Event_Handler+0x2d8>)

TIMER_STATUS_t bsp_timer_stop_clear(TIMER_t *const handle_timer)
{
	TIMER_STATUS_t status;

	status = TIMER_Stop(handle_timer);
 8029a66:	48b0      	ldr	r0, [pc, #704]	; (8029d28 <DMA_Event_Handler+0x2dc>)
			bsp_frame_counter++;
		}
		else /* In normal mode */
		{

			l_acq_started = 0;
 8029a68:	2200      	movs	r2, #0
 8029a6a:	601a      	str	r2, [r3, #0]

TIMER_STATUS_t bsp_timer_stop_clear(TIMER_t *const handle_timer)
{
	TIMER_STATUS_t status;

	status = TIMER_Stop(handle_timer);
 8029a6c:	f7fc fa12 	bl	8025e94 <TIMER_Stop>

	status |= TIMER_Clear(handle_timer);
 8029a70:	48ad      	ldr	r0, [pc, #692]	; (8029d28 <DMA_Event_Handler+0x2dc>)
 8029a72:	f7fc fa99 	bl	8025fa8 <TIMER_Clear>

			l_acq_started = 0;

			bsp_timer_stop_clear(&TIMER_PTAT_S_H_DELAY);

			if (ptat_switching_status != 0)
 8029a76:	4bad      	ldr	r3, [pc, #692]	; (8029d2c <DMA_Event_Handler+0x2e0>)
 8029a78:	681b      	ldr	r3, [r3, #0]
 8029a7a:	b163      	cbz	r3, 8029a96 <DMA_Event_Handler+0x4a>
 8029a7c:	4aac      	ldr	r2, [pc, #688]	; (8029d30 <DMA_Event_Handler+0x2e4>)
 8029a7e:	4bad      	ldr	r3, [pc, #692]	; (8029d34 <DMA_Event_Handler+0x2e8>)

__STATIC_INLINE void XMC_GPIO_SetOutputLow(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputLow: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = 0x10000U << pin;
 8029a80:	7c10      	ldrb	r0, [r2, #16]
 8029a82:	7c1c      	ldrb	r4, [r3, #16]
 8029a84:	6811      	ldr	r1, [r2, #0]
 8029a86:	681a      	ldr	r2, [r3, #0]
 8029a88:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8029a8c:	fa03 f000 	lsl.w	r0, r3, r0
 8029a90:	40a3      	lsls	r3, r4
 8029a92:	6048      	str	r0, [r1, #4]
 8029a94:	6053      	str	r3, [r2, #4]

				/* Disable ptat straight after acquisition */
				DIGITAL_IO_SetOutputLow(&DIGITAL_IO_BGT_VCC_PTAT);
			}

			if (bb_pre_trigger_advance_usec != 0)
 8029a96:	4ba8      	ldr	r3, [pc, #672]	; (8029d38 <DMA_Event_Handler+0x2ec>)
 8029a98:	681b      	ldr	r3, [r3, #0]
 8029a9a:	2b00      	cmp	r3, #0
 8029a9c:	f040 808f 	bne.w	8029bbe <DMA_Event_Handler+0x172>
 8029aa0:	f8df 92c4 	ldr.w	r9, [pc, #708]	; 8029d68 <DMA_Event_Handler+0x31c>
//============================================================================

static void bgt24ltr1x_shut_down(void)
{
	/* Stop BGT */
	PWM_CCU8_Stop(&PWM_CCU8_BGT_VCC);
 8029aa4:	48a5      	ldr	r0, [pc, #660]	; (8029d3c <DMA_Event_Handler+0x2f0>)
 8029aa6:	4ea6      	ldr	r6, [pc, #664]	; (8029d40 <DMA_Event_Handler+0x2f4>)
 8029aa8:	4da6      	ldr	r5, [pc, #664]	; (8029d44 <DMA_Event_Handler+0x2f8>)
 8029aaa:	4ca7      	ldr	r4, [pc, #668]	; (8029d48 <DMA_Event_Handler+0x2fc>)
			dma_reset_dlr();

			acq_buf_obj *p_acq_buf = ds_get_active_acq_buf();

			/* copy data buffer into target buffer, if skip count is active*/
			copyDataBuffer2AcqBuffer(p_acq_buf, bsp_frame_counter);
 8029aac:	f8df 82b4 	ldr.w	r8, [pc, #692]	; 8029d64 <DMA_Event_Handler+0x318>
	  uint16_t *p_dst_Ch3 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 3, 0);

	  uint32_t skip_count = p_acq_buf->internals.skip_count;
	  uint32_t byte_count = p_acq_buf->params.num_of_samples_per_chirp*sizeof(uint16_t);

	  memcpy(p_dst_Ch0, &data_buffer[0][skip_count], byte_count);
 8029ab0:	4fa6      	ldr	r7, [pc, #664]	; (8029d4c <DMA_Event_Handler+0x300>)
//============================================================================

static void bgt24ltr1x_shut_down(void)
{
	/* Stop BGT */
	PWM_CCU8_Stop(&PWM_CCU8_BGT_VCC);
 8029ab2:	f7fc fc51 	bl	8026358 <PWM_CCU8_Stop>
 */
__STATIC_INLINE void DMA_CH_Disable(DMA_CH_t *const obj)
{
  XMC_ASSERT("DMA_CH_Disable: NULL DMA_CH_t object", (obj != NULL));

  XMC_DMA_CH_Disable(obj->dma_global->dma, obj->ch_num);
 8029ab6:	f8d9 3000 	ldr.w	r3, [r9]
 8029aba:	f899 100c 	ldrb.w	r1, [r9, #12]
 8029abe:	6818      	ldr	r0, [r3, #0]
 8029ac0:	f7f7 ff56 	bl	8021970 <XMC_DMA_CH_Disable>
 8029ac4:	6833      	ldr	r3, [r6, #0]
 8029ac6:	7b31      	ldrb	r1, [r6, #12]
 8029ac8:	6818      	ldr	r0, [r3, #0]
 8029aca:	f7f7 ff51 	bl	8021970 <XMC_DMA_CH_Disable>
 8029ace:	682b      	ldr	r3, [r5, #0]
 8029ad0:	7b29      	ldrb	r1, [r5, #12]
 8029ad2:	6818      	ldr	r0, [r3, #0]
 8029ad4:	f7f7 ff4c 	bl	8021970 <XMC_DMA_CH_Disable>
 8029ad8:	6823      	ldr	r3, [r4, #0]
 8029ada:	7b21      	ldrb	r1, [r4, #12]
 8029adc:	6818      	ldr	r0, [r3, #0]
 8029ade:	f7f7 ff47 	bl	8021970 <XMC_DMA_CH_Disable>

//============================================================================

static void dma_reset_dlr(void)
{
	XMC_DMA_CH_ClearSourcePeripheralRequest(DMA_CH_G0.dma_global->dma, DMA_CH_G0.ch_num);
 8029ae2:	f8d9 3000 	ldr.w	r3, [r9]
 8029ae6:	f899 100c 	ldrb.w	r1, [r9, #12]
 8029aea:	6818      	ldr	r0, [r3, #0]
 8029aec:	f7f8 f8be 	bl	8021c6c <XMC_DMA_CH_ClearSourcePeripheralRequest>
	XMC_DMA_CH_ClearSourcePeripheralRequest(DMA_CH_G1.dma_global->dma, DMA_CH_G1.ch_num);
 8029af0:	6833      	ldr	r3, [r6, #0]
 8029af2:	7b31      	ldrb	r1, [r6, #12]
 8029af4:	6818      	ldr	r0, [r3, #0]
 8029af6:	f7f8 f8b9 	bl	8021c6c <XMC_DMA_CH_ClearSourcePeripheralRequest>
	XMC_DMA_CH_ClearSourcePeripheralRequest(DMA_CH_G2.dma_global->dma, DMA_CH_G2.ch_num);
 8029afa:	682b      	ldr	r3, [r5, #0]
 8029afc:	7b29      	ldrb	r1, [r5, #12]
 8029afe:	6818      	ldr	r0, [r3, #0]
 8029b00:	f7f8 f8b4 	bl	8021c6c <XMC_DMA_CH_ClearSourcePeripheralRequest>
	XMC_DMA_CH_ClearSourcePeripheralRequest(DMA_CH_G3.dma_global->dma, DMA_CH_G3.ch_num);
 8029b04:	6823      	ldr	r3, [r4, #0]
 8029b06:	7b21      	ldrb	r1, [r4, #12]
 8029b08:	6818      	ldr	r0, [r3, #0]
 8029b0a:	f7f8 f8af 	bl	8021c6c <XMC_DMA_CH_ClearSourcePeripheralRequest>

			/* Clear the request from source peripheral even though DMA was disabled by itself.
	         * We should consider the pending request from external peripheral. */
			dma_reset_dlr();

			acq_buf_obj *p_acq_buf = ds_get_active_acq_buf();
 8029b0e:	f7f6 fcf3 	bl	80204f8 <ds_get_active_acq_buf>

//============================================================================

void copyDataBuffer2AcqBuffer(acq_buf_obj *p_acq_buf, uint32_t frame_counter)
{
	  uint16_t *p_dst_Ch0 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 0, 0);
 8029b12:	2100      	movs	r1, #0
			dma_reset_dlr();

			acq_buf_obj *p_acq_buf = ds_get_active_acq_buf();

			/* copy data buffer into target buffer, if skip count is active*/
			copyDataBuffer2AcqBuffer(p_acq_buf, bsp_frame_counter);
 8029b14:	f8d8 3000 	ldr.w	r3, [r8]
 8029b18:	9301      	str	r3, [sp, #4]

//============================================================================

void copyDataBuffer2AcqBuffer(acq_buf_obj *p_acq_buf, uint32_t frame_counter)
{
	  uint16_t *p_dst_Ch0 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 0, 0);
 8029b1a:	460a      	mov	r2, r1

			/* Clear the request from source peripheral even though DMA was disabled by itself.
	         * We should consider the pending request from external peripheral. */
			dma_reset_dlr();

			acq_buf_obj *p_acq_buf = ds_get_active_acq_buf();
 8029b1c:	4604      	mov	r4, r0

//============================================================================

void copyDataBuffer2AcqBuffer(acq_buf_obj *p_acq_buf, uint32_t frame_counter)
{
	  uint16_t *p_dst_Ch0 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 0, 0);
 8029b1e:	f7f6 fe95 	bl	802084c <get_buffer_address_by_chirp>
	  uint16_t *p_dst_Ch1 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 1, 0);
 8029b22:	2101      	movs	r1, #1

//============================================================================

void copyDataBuffer2AcqBuffer(acq_buf_obj *p_acq_buf, uint32_t frame_counter)
{
	  uint16_t *p_dst_Ch0 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 0, 0);
 8029b24:	9002      	str	r0, [sp, #8]
	  uint16_t *p_dst_Ch1 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 1, 0);
 8029b26:	2200      	movs	r2, #0
 8029b28:	4620      	mov	r0, r4
 8029b2a:	f7f6 fe8f 	bl	802084c <get_buffer_address_by_chirp>
	  uint16_t *p_dst_Ch2 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 2, 0);
 8029b2e:	2102      	movs	r1, #2
//============================================================================

void copyDataBuffer2AcqBuffer(acq_buf_obj *p_acq_buf, uint32_t frame_counter)
{
	  uint16_t *p_dst_Ch0 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 0, 0);
	  uint16_t *p_dst_Ch1 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 1, 0);
 8029b30:	4681      	mov	r9, r0
	  uint16_t *p_dst_Ch2 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 2, 0);
 8029b32:	2200      	movs	r2, #0
 8029b34:	4620      	mov	r0, r4
 8029b36:	f7f6 fe89 	bl	802084c <get_buffer_address_by_chirp>
	  uint16_t *p_dst_Ch3 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 3, 0);
 8029b3a:	2103      	movs	r1, #3

void copyDataBuffer2AcqBuffer(acq_buf_obj *p_acq_buf, uint32_t frame_counter)
{
	  uint16_t *p_dst_Ch0 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 0, 0);
	  uint16_t *p_dst_Ch1 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 1, 0);
	  uint16_t *p_dst_Ch2 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 2, 0);
 8029b3c:	4683      	mov	fp, r0
	  uint16_t *p_dst_Ch3 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 3, 0);
 8029b3e:	2200      	movs	r2, #0
 8029b40:	4620      	mov	r0, r4
 8029b42:	f7f6 fe83 	bl	802084c <get_buffer_address_by_chirp>

	  uint32_t skip_count = p_acq_buf->internals.skip_count;
	  uint32_t byte_count = p_acq_buf->params.num_of_samples_per_chirp*sizeof(uint16_t);
 8029b46:	8866      	ldrh	r6, [r4, #2]
	  uint16_t *p_dst_Ch0 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 0, 0);
	  uint16_t *p_dst_Ch1 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 1, 0);
	  uint16_t *p_dst_Ch2 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 2, 0);
	  uint16_t *p_dst_Ch3 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 3, 0);

	  uint32_t skip_count = p_acq_buf->internals.skip_count;
 8029b48:	69e5      	ldr	r5, [r4, #28]
	  uint32_t byte_count = p_acq_buf->params.num_of_samples_per_chirp*sizeof(uint16_t);

	  memcpy(p_dst_Ch0, &data_buffer[0][skip_count], byte_count);
 8029b4a:	f8dd c008 	ldr.w	ip, [sp, #8]
	  uint16_t *p_dst_Ch1 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 1, 0);
	  uint16_t *p_dst_Ch2 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 2, 0);
	  uint16_t *p_dst_Ch3 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 3, 0);

	  uint32_t skip_count = p_acq_buf->internals.skip_count;
	  uint32_t byte_count = p_acq_buf->params.num_of_samples_per_chirp*sizeof(uint16_t);
 8029b4e:	0076      	lsls	r6, r6, #1
void copyDataBuffer2AcqBuffer(acq_buf_obj *p_acq_buf, uint32_t frame_counter)
{
	  uint16_t *p_dst_Ch0 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 0, 0);
	  uint16_t *p_dst_Ch1 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 1, 0);
	  uint16_t *p_dst_Ch2 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 2, 0);
	  uint16_t *p_dst_Ch3 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 3, 0);
 8029b50:	4682      	mov	sl, r0

	  uint32_t skip_count = p_acq_buf->internals.skip_count;
	  uint32_t byte_count = p_acq_buf->params.num_of_samples_per_chirp*sizeof(uint16_t);

	  memcpy(p_dst_Ch0, &data_buffer[0][skip_count], byte_count);
 8029b52:	4632      	mov	r2, r6
 8029b54:	4660      	mov	r0, ip
 8029b56:	eb07 0145 	add.w	r1, r7, r5, lsl #1
 8029b5a:	f003 fcf1 	bl	802d540 <memcpy>
	  memcpy(p_dst_Ch1, &data_buffer[1][skip_count], byte_count);
 8029b5e:	f505 619d 	add.w	r1, r5, #1256	; 0x4e8
 8029b62:	4632      	mov	r2, r6
 8029b64:	eb07 0141 	add.w	r1, r7, r1, lsl #1
 8029b68:	4648      	mov	r0, r9
 8029b6a:	f003 fce9 	bl	802d540 <memcpy>
	  memcpy(p_dst_Ch2, &data_buffer[2][skip_count], byte_count);
 8029b6e:	f505 611d 	add.w	r1, r5, #2512	; 0x9d0
 8029b72:	4632      	mov	r2, r6
 8029b74:	eb07 0141 	add.w	r1, r7, r1, lsl #1
 8029b78:	4658      	mov	r0, fp
 8029b7a:	f003 fce1 	bl	802d540 <memcpy>
	  memcpy(p_dst_Ch3, &data_buffer[3][skip_count], byte_count);
 8029b7e:	f605 61b8 	addw	r1, r5, #3768	; 0xeb8
 8029b82:	4632      	mov	r2, r6
 8029b84:	eb07 0141 	add.w	r1, r7, r1, lsl #1
 8029b88:	4650      	mov	r0, sl
 8029b8a:	f003 fcd9 	bl	802d540 <memcpy>
			acq_buf_obj *p_acq_buf = ds_get_active_acq_buf();

			/* copy data buffer into target buffer, if skip count is active*/
			copyDataBuffer2AcqBuffer(p_acq_buf, bsp_frame_counter);

			bsp_frame_counter++;
 8029b8e:	f8d8 3000 	ldr.w	r3, [r8]
	  memcpy(p_dst_Ch0, &data_buffer[0][skip_count], byte_count);
	  memcpy(p_dst_Ch1, &data_buffer[1][skip_count], byte_count);
	  memcpy(p_dst_Ch2, &data_buffer[2][skip_count], byte_count);
	  memcpy(p_dst_Ch3, &data_buffer[3][skip_count], byte_count);

	  p_acq_buf->frame_counter = frame_counter;
 8029b92:	9a01      	ldr	r2, [sp, #4]
 8029b94:	6362      	str	r2, [r4, #52]	; 0x34
			acq_buf_obj *p_acq_buf = ds_get_active_acq_buf();

			/* copy data buffer into target buffer, if skip count is active*/
			copyDataBuffer2AcqBuffer(p_acq_buf, bsp_frame_counter);

			bsp_frame_counter++;
 8029b96:	3301      	adds	r3, #1
 8029b98:	f8c8 3000 	str.w	r3, [r8]

		g_adc_sampling_completed = true;

		/* One frame is ready */
		/* This callback is used to inform upper layers that a valid data is available and ADC sampling is completed */
		if ((bsp_cb.bsp_acq_done_cb != NULL) & (watchdog_status == 0))
 8029b9c:	4b6c      	ldr	r3, [pc, #432]	; (8029d50 <DMA_Event_Handler+0x304>)
			copyDataBuffer2AcqBuffer(p_acq_buf, bsp_frame_counter);

			bsp_frame_counter++;
		}

		g_adc_sampling_completed = true;
 8029b9e:	496d      	ldr	r1, [pc, #436]	; (8029d54 <DMA_Event_Handler+0x308>)

		/* One frame is ready */
		/* This callback is used to inform upper layers that a valid data is available and ADC sampling is completed */
		if ((bsp_cb.bsp_acq_done_cb != NULL) & (watchdog_status == 0))
 8029ba0:	781a      	ldrb	r2, [r3, #0]
 8029ba2:	4b6d      	ldr	r3, [pc, #436]	; (8029d58 <DMA_Event_Handler+0x30c>)
			copyDataBuffer2AcqBuffer(p_acq_buf, bsp_frame_counter);

			bsp_frame_counter++;
		}

		g_adc_sampling_completed = true;
 8029ba4:	2001      	movs	r0, #1
 8029ba6:	6008      	str	r0, [r1, #0]

		/* One frame is ready */
		/* This callback is used to inform upper layers that a valid data is available and ADC sampling is completed */
		if ((bsp_cb.bsp_acq_done_cb != NULL) & (watchdog_status == 0))
 8029ba8:	685b      	ldr	r3, [r3, #4]
 8029baa:	b92a      	cbnz	r2, 8029bb8 <DMA_Event_Handler+0x16c>
 8029bac:	b123      	cbz	r3, 8029bb8 <DMA_Event_Handler+0x16c>
		{
			bsp_cb.bsp_acq_done_cb(NULL);
 8029bae:	2000      	movs	r0, #0
		}
	}
}
 8029bb0:	b007      	add	sp, #28
 8029bb2:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

		/* One frame is ready */
		/* This callback is used to inform upper layers that a valid data is available and ADC sampling is completed */
		if ((bsp_cb.bsp_acq_done_cb != NULL) & (watchdog_status == 0))
		{
			bsp_cb.bsp_acq_done_cb(NULL);
 8029bb6:	4718      	bx	r3
		}
	}
}
 8029bb8:	b007      	add	sp, #28
 8029bba:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8029bbe:	4a67      	ldr	r2, [pc, #412]	; (8029d5c <DMA_Event_Handler+0x310>)
 8029bc0:	4b67      	ldr	r3, [pc, #412]	; (8029d60 <DMA_Event_Handler+0x314>)
 8029bc2:	7c10      	ldrb	r0, [r2, #16]
 8029bc4:	7c1c      	ldrb	r4, [r3, #16]
 8029bc6:	6811      	ldr	r1, [r2, #0]
 8029bc8:	681a      	ldr	r2, [r3, #0]
 8029bca:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8029bce:	fa03 f000 	lsl.w	r0, r3, r0
 8029bd2:	40a3      	lsls	r3, r4
 8029bd4:	6048      	str	r0, [r1, #4]
 8029bd6:	6053      	str	r3, [r2, #4]
 8029bd8:	e762      	b.n	8029aa0 <DMA_Event_Handler+0x54>
 8029bda:	f8df 818c 	ldr.w	r8, [pc, #396]	; 8029d68 <DMA_Event_Handler+0x31c>
 8029bde:	4f58      	ldr	r7, [pc, #352]	; (8029d40 <DMA_Event_Handler+0x2f4>)
 8029be0:	f8d8 3000 	ldr.w	r3, [r8]
 8029be4:	f898 100c 	ldrb.w	r1, [r8, #12]
 8029be8:	6818      	ldr	r0, [r3, #0]
 8029bea:	4e56      	ldr	r6, [pc, #344]	; (8029d44 <DMA_Event_Handler+0x2f8>)
 8029bec:	4d56      	ldr	r5, [pc, #344]	; (8029d48 <DMA_Event_Handler+0x2fc>)
	  uint16_t *p_dst_Ch3 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 3, 0);

	  uint32_t skip_count = p_acq_buf->internals.skip_count;
	  uint32_t byte_count = p_acq_buf->params.num_of_samples_per_chirp*sizeof(uint16_t);

	  memcpy(p_dst_Ch0, &data_buffer[0][skip_count], byte_count);
 8029bee:	f8df b15c 	ldr.w	fp, [pc, #348]	; 8029d4c <DMA_Event_Handler+0x300>
 8029bf2:	f7f7 febd 	bl	8021970 <XMC_DMA_CH_Disable>
 8029bf6:	683b      	ldr	r3, [r7, #0]
 8029bf8:	7b39      	ldrb	r1, [r7, #12]
 8029bfa:	6818      	ldr	r0, [r3, #0]
 8029bfc:	f7f7 feb8 	bl	8021970 <XMC_DMA_CH_Disable>
 8029c00:	6833      	ldr	r3, [r6, #0]
 8029c02:	7b31      	ldrb	r1, [r6, #12]
 8029c04:	6818      	ldr	r0, [r3, #0]
 8029c06:	f7f7 feb3 	bl	8021970 <XMC_DMA_CH_Disable>
 8029c0a:	682b      	ldr	r3, [r5, #0]
 8029c0c:	7b29      	ldrb	r1, [r5, #12]
 8029c0e:	6818      	ldr	r0, [r3, #0]
 8029c10:	f7f7 feae 	bl	8021970 <XMC_DMA_CH_Disable>

//============================================================================

static void dma_reset_dlr(void)
{
	XMC_DMA_CH_ClearSourcePeripheralRequest(DMA_CH_G0.dma_global->dma, DMA_CH_G0.ch_num);
 8029c14:	f8d8 3000 	ldr.w	r3, [r8]
 8029c18:	f898 100c 	ldrb.w	r1, [r8, #12]
 8029c1c:	6818      	ldr	r0, [r3, #0]
 8029c1e:	f7f8 f825 	bl	8021c6c <XMC_DMA_CH_ClearSourcePeripheralRequest>
	XMC_DMA_CH_ClearSourcePeripheralRequest(DMA_CH_G1.dma_global->dma, DMA_CH_G1.ch_num);
 8029c22:	683b      	ldr	r3, [r7, #0]
 8029c24:	7b39      	ldrb	r1, [r7, #12]
 8029c26:	6818      	ldr	r0, [r3, #0]
 8029c28:	f7f8 f820 	bl	8021c6c <XMC_DMA_CH_ClearSourcePeripheralRequest>
	XMC_DMA_CH_ClearSourcePeripheralRequest(DMA_CH_G2.dma_global->dma, DMA_CH_G2.ch_num);
 8029c2c:	6833      	ldr	r3, [r6, #0]
 8029c2e:	7b31      	ldrb	r1, [r6, #12]
 8029c30:	6818      	ldr	r0, [r3, #0]
 8029c32:	f7f8 f81b 	bl	8021c6c <XMC_DMA_CH_ClearSourcePeripheralRequest>
	XMC_DMA_CH_ClearSourcePeripheralRequest(DMA_CH_G3.dma_global->dma, DMA_CH_G3.ch_num);
 8029c36:	682b      	ldr	r3, [r5, #0]
 8029c38:	7b29      	ldrb	r1, [r5, #12]
 8029c3a:	6818      	ldr	r0, [r3, #0]
 8029c3c:	f7f8 f816 	bl	8021c6c <XMC_DMA_CH_ClearSourcePeripheralRequest>

			/* Clear the request from source peripheral even though DMA was disabled by itself.
	         * We should consider the pending request from external peripheral. */
			dma_reset_dlr();

			acq_buf_obj *p_acq_buf = ds_get_active_acq_buf();
 8029c40:	f7f6 fc5a 	bl	80204f8 <ds_get_active_acq_buf>

			/* copy data buffer into target buffer, if skip count is active*/
			copyDataBuffer2AcqBuffer(p_acq_buf, bsp_frame_counter);
 8029c44:	4b47      	ldr	r3, [pc, #284]	; (8029d64 <DMA_Event_Handler+0x318>)

//============================================================================

void copyDataBuffer2AcqBuffer(acq_buf_obj *p_acq_buf, uint32_t frame_counter)
{
	  uint16_t *p_dst_Ch0 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 0, 0);
 8029c46:	2100      	movs	r1, #0
			dma_reset_dlr();

			acq_buf_obj *p_acq_buf = ds_get_active_acq_buf();

			/* copy data buffer into target buffer, if skip count is active*/
			copyDataBuffer2AcqBuffer(p_acq_buf, bsp_frame_counter);
 8029c48:	681b      	ldr	r3, [r3, #0]
 8029c4a:	9301      	str	r3, [sp, #4]

//============================================================================

void copyDataBuffer2AcqBuffer(acq_buf_obj *p_acq_buf, uint32_t frame_counter)
{
	  uint16_t *p_dst_Ch0 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 0, 0);
 8029c4c:	460a      	mov	r2, r1

			/* Clear the request from source peripheral even though DMA was disabled by itself.
	         * We should consider the pending request from external peripheral. */
			dma_reset_dlr();

			acq_buf_obj *p_acq_buf = ds_get_active_acq_buf();
 8029c4e:	4604      	mov	r4, r0

//============================================================================

void copyDataBuffer2AcqBuffer(acq_buf_obj *p_acq_buf, uint32_t frame_counter)
{
	  uint16_t *p_dst_Ch0 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 0, 0);
 8029c50:	f7f6 fdfc 	bl	802084c <get_buffer_address_by_chirp>
	  uint16_t *p_dst_Ch1 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 1, 0);
 8029c54:	2101      	movs	r1, #1

//============================================================================

void copyDataBuffer2AcqBuffer(acq_buf_obj *p_acq_buf, uint32_t frame_counter)
{
	  uint16_t *p_dst_Ch0 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 0, 0);
 8029c56:	9005      	str	r0, [sp, #20]
	  uint16_t *p_dst_Ch1 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 1, 0);
 8029c58:	2200      	movs	r2, #0
 8029c5a:	4620      	mov	r0, r4
 8029c5c:	f7f6 fdf6 	bl	802084c <get_buffer_address_by_chirp>
	  uint16_t *p_dst_Ch2 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 2, 0);
 8029c60:	4649      	mov	r1, r9
//============================================================================

void copyDataBuffer2AcqBuffer(acq_buf_obj *p_acq_buf, uint32_t frame_counter)
{
	  uint16_t *p_dst_Ch0 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 0, 0);
	  uint16_t *p_dst_Ch1 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 1, 0);
 8029c62:	9004      	str	r0, [sp, #16]
	  uint16_t *p_dst_Ch2 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 2, 0);
 8029c64:	2200      	movs	r2, #0
 8029c66:	4620      	mov	r0, r4
 8029c68:	f7f6 fdf0 	bl	802084c <get_buffer_address_by_chirp>
	  uint16_t *p_dst_Ch3 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 3, 0);
 8029c6c:	2103      	movs	r1, #3

void copyDataBuffer2AcqBuffer(acq_buf_obj *p_acq_buf, uint32_t frame_counter)
{
	  uint16_t *p_dst_Ch0 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 0, 0);
	  uint16_t *p_dst_Ch1 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 1, 0);
	  uint16_t *p_dst_Ch2 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 2, 0);
 8029c6e:	9002      	str	r0, [sp, #8]
	  uint16_t *p_dst_Ch3 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 3, 0);
 8029c70:	2200      	movs	r2, #0
 8029c72:	4620      	mov	r0, r4
 8029c74:	f7f6 fdea 	bl	802084c <get_buffer_address_by_chirp>

	  uint32_t skip_count = p_acq_buf->internals.skip_count;
	  uint32_t byte_count = p_acq_buf->params.num_of_samples_per_chirp*sizeof(uint16_t);
 8029c78:	f8b4 a002 	ldrh.w	sl, [r4, #2]

	  memcpy(p_dst_Ch0, &data_buffer[0][skip_count], byte_count);
 8029c7c:	f8dd c014 	ldr.w	ip, [sp, #20]
	  uint16_t *p_dst_Ch0 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 0, 0);
	  uint16_t *p_dst_Ch1 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 1, 0);
	  uint16_t *p_dst_Ch2 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 2, 0);
	  uint16_t *p_dst_Ch3 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 3, 0);

	  uint32_t skip_count = p_acq_buf->internals.skip_count;
 8029c80:	f8d4 901c 	ldr.w	r9, [r4, #28]
void copyDataBuffer2AcqBuffer(acq_buf_obj *p_acq_buf, uint32_t frame_counter)
{
	  uint16_t *p_dst_Ch0 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 0, 0);
	  uint16_t *p_dst_Ch1 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 1, 0);
	  uint16_t *p_dst_Ch2 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 2, 0);
	  uint16_t *p_dst_Ch3 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 3, 0);
 8029c84:	9003      	str	r0, [sp, #12]

	  uint32_t skip_count = p_acq_buf->internals.skip_count;
	  uint32_t byte_count = p_acq_buf->params.num_of_samples_per_chirp*sizeof(uint16_t);
 8029c86:	ea4f 0a4a 	mov.w	sl, sl, lsl #1

	  memcpy(p_dst_Ch0, &data_buffer[0][skip_count], byte_count);
 8029c8a:	4660      	mov	r0, ip
 8029c8c:	4652      	mov	r2, sl
 8029c8e:	eb0b 0149 	add.w	r1, fp, r9, lsl #1
 8029c92:	f003 fc55 	bl	802d540 <memcpy>
	  memcpy(p_dst_Ch1, &data_buffer[1][skip_count], byte_count);
 8029c96:	9b04      	ldr	r3, [sp, #16]
 8029c98:	f509 619d 	add.w	r1, r9, #1256	; 0x4e8
 8029c9c:	4618      	mov	r0, r3
 8029c9e:	4652      	mov	r2, sl
 8029ca0:	eb0b 0141 	add.w	r1, fp, r1, lsl #1
 8029ca4:	f003 fc4c 	bl	802d540 <memcpy>
	  memcpy(p_dst_Ch2, &data_buffer[2][skip_count], byte_count);
 8029ca8:	f509 611d 	add.w	r1, r9, #2512	; 0x9d0
 8029cac:	4652      	mov	r2, sl
 8029cae:	eb0b 0141 	add.w	r1, fp, r1, lsl #1
 8029cb2:	9802      	ldr	r0, [sp, #8]
 8029cb4:	f003 fc44 	bl	802d540 <memcpy>
	  memcpy(p_dst_Ch3, &data_buffer[3][skip_count], byte_count);
 8029cb8:	f609 61b8 	addw	r1, r9, #3768	; 0xeb8
 8029cbc:	4652      	mov	r2, sl
 8029cbe:	eb0b 0141 	add.w	r1, fp, r1, lsl #1
 8029cc2:	9803      	ldr	r0, [sp, #12]
 8029cc4:	f003 fc3c 	bl	802d540 <memcpy>

	  p_acq_buf->frame_counter = frame_counter;
 8029cc8:	9b01      	ldr	r3, [sp, #4]
 8029cca:	6363      	str	r3, [r4, #52]	; 0x34

			/* copy data buffer into target buffer, if skip count is active*/
			copyDataBuffer2AcqBuffer(p_acq_buf, bsp_frame_counter);

			/* DMA Reconfiguration */
			bsp_dma_set_adc_control_from_acq_buf_obj(p_acq_buf);
 8029ccc:	4620      	mov	r0, r4
 8029cce:	f7ff fdbf 	bl	8029850 <bsp_dma_set_adc_control_from_acq_buf_obj>
 */
__STATIC_INLINE void DMA_CH_Enable(DMA_CH_t *const obj)
{
  XMC_ASSERT("DMA_CH_Enable: NULL DMA_CH_t object", (obj != NULL));

  XMC_DMA_CH_Enable(obj->dma_global->dma, obj->ch_num);
 8029cd2:	f8d8 4000 	ldr.w	r4, [r8]
 8029cd6:	6839      	ldr	r1, [r7, #0]
 8029cd8:	6832      	ldr	r2, [r6, #0]
 8029cda:	682b      	ldr	r3, [r5, #0]
 8029cdc:	f897 c00c 	ldrb.w	ip, [r7, #12]
 8029ce0:	7b30      	ldrb	r0, [r6, #12]
 8029ce2:	f895 e00c 	ldrb.w	lr, [r5, #12]
 8029ce6:	f898 800c 	ldrb.w	r8, [r8, #12]
 8029cea:	6826      	ldr	r6, [r4, #0]
 8029cec:	680c      	ldr	r4, [r1, #0]
 8029cee:	6811      	ldr	r1, [r2, #0]
 8029cf0:	681a      	ldr	r2, [r3, #0]
 8029cf2:	f240 1301 	movw	r3, #257	; 0x101
 8029cf6:	fa03 f708 	lsl.w	r7, r3, r8
 8029cfa:	fa03 f50c 	lsl.w	r5, r3, ip
 8029cfe:	fa03 f000 	lsl.w	r0, r3, r0
 8029d02:	fa03 f30e 	lsl.w	r3, r3, lr
 8029d06:	f8c6 73a0 	str.w	r7, [r6, #928]	; 0x3a0
 8029d0a:	f8c4 53a0 	str.w	r5, [r4, #928]	; 0x3a0
 8029d0e:	f8c1 03a0 	str.w	r0, [r1, #928]	; 0x3a0
 8029d12:	f8c2 33a0 	str.w	r3, [r2, #928]	; 0x3a0

			/* Enable DMA */
			dma_enable();

			bsp_frame_counter++;
 8029d16:	4b13      	ldr	r3, [pc, #76]	; (8029d64 <DMA_Event_Handler+0x318>)
 8029d18:	4a12      	ldr	r2, [pc, #72]	; (8029d64 <DMA_Event_Handler+0x318>)
 8029d1a:	681b      	ldr	r3, [r3, #0]
 8029d1c:	3301      	adds	r3, #1
 8029d1e:	6013      	str	r3, [r2, #0]
 8029d20:	e73c      	b.n	8029b9c <DMA_Event_Handler+0x150>
 8029d22:	bf00      	nop
 8029d24:	1ffeb488 	.word	0x1ffeb488
 8029d28:	1ffe91c0 	.word	0x1ffe91c0
 8029d2c:	1ffeb494 	.word	0x1ffeb494
 8029d30:	0802de48 	.word	0x0802de48
 8029d34:	0802ddbc 	.word	0x0802ddbc
 8029d38:	1ffe960c 	.word	0x1ffe960c
 8029d3c:	1ffe9238 	.word	0x1ffe9238
 8029d40:	1ffe93e0 	.word	0x1ffe93e0
 8029d44:	1ffe93f0 	.word	0x1ffe93f0
 8029d48:	1ffe9400 	.word	0x1ffe9400
 8029d4c:	1ffeb498 	.word	0x1ffeb498
 8029d50:	1ffeb484 	.word	0x1ffeb484
 8029d54:	1ffe976c 	.word	0x1ffe976c
 8029d58:	1ffedbf4 	.word	0x1ffedbf4
 8029d5c:	0802dd94 	.word	0x0802dd94
 8029d60:	0802dda8 	.word	0x0802dda8
 8029d64:	1ffeb48c 	.word	0x1ffeb48c
 8029d68:	1ffe93d0 	.word	0x1ffe93d0

08029d6c <CCU43_1_IRQHandler>:
}

//============================================================================

void trigger_ptat_delay(void)
{
 8029d6c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

TIMER_STATUS_t bsp_timer_stop_clear(TIMER_t *const handle_timer)
{
	TIMER_STATUS_t status;

	status = TIMER_Stop(handle_timer);
 8029d70:	482f      	ldr	r0, [pc, #188]	; (8029e30 <CCU43_1_IRQHandler+0xc4>)
 8029d72:	4f30      	ldr	r7, [pc, #192]	; (8029e34 <CCU43_1_IRQHandler+0xc8>)
 8029d74:	4e30      	ldr	r6, [pc, #192]	; (8029e38 <CCU43_1_IRQHandler+0xcc>)
 8029d76:	4d31      	ldr	r5, [pc, #196]	; (8029e3c <CCU43_1_IRQHandler+0xd0>)
 8029d78:	4c31      	ldr	r4, [pc, #196]	; (8029e40 <CCU43_1_IRQHandler+0xd4>)
}

//============================================================================

void trigger_ptat_delay(void)
{
 8029d7a:	b081      	sub	sp, #4

TIMER_STATUS_t bsp_timer_stop_clear(TIMER_t *const handle_timer)
{
	TIMER_STATUS_t status;

	status = TIMER_Stop(handle_timer);
 8029d7c:	f7fc f88a 	bl	8025e94 <TIMER_Stop>

	status |= TIMER_Clear(handle_timer);
 8029d80:	482b      	ldr	r0, [pc, #172]	; (8029e30 <CCU43_1_IRQHandler+0xc4>)
 8029d82:	f7fc f911 	bl	8025fa8 <TIMER_Clear>
 */
__STATIC_INLINE void DMA_CH_Disable(DMA_CH_t *const obj)
{
  XMC_ASSERT("DMA_CH_Disable: NULL DMA_CH_t object", (obj != NULL));

  XMC_DMA_CH_Disable(obj->dma_global->dma, obj->ch_num);
 8029d86:	683a      	ldr	r2, [r7, #0]
==============================================================================
 */

static void trigger_dma_start(void)
{
	watchdog_status = 0;
 8029d88:	4b2e      	ldr	r3, [pc, #184]	; (8029e44 <CCU43_1_IRQHandler+0xd8>)
 8029d8a:	6810      	ldr	r0, [r2, #0]
 8029d8c:	7b39      	ldrb	r1, [r7, #12]
 8029d8e:	f04f 0800 	mov.w	r8, #0
 8029d92:	f883 8000 	strb.w	r8, [r3]
 8029d96:	f7f7 fdeb 	bl	8021970 <XMC_DMA_CH_Disable>
 8029d9a:	6833      	ldr	r3, [r6, #0]
 8029d9c:	7b31      	ldrb	r1, [r6, #12]
 8029d9e:	6818      	ldr	r0, [r3, #0]
 8029da0:	f7f7 fde6 	bl	8021970 <XMC_DMA_CH_Disable>
 8029da4:	682b      	ldr	r3, [r5, #0]
 8029da6:	7b29      	ldrb	r1, [r5, #12]
 8029da8:	6818      	ldr	r0, [r3, #0]
 8029daa:	f7f7 fde1 	bl	8021970 <XMC_DMA_CH_Disable>
 8029dae:	6823      	ldr	r3, [r4, #0]
 8029db0:	7b21      	ldrb	r1, [r4, #12]
 8029db2:	6818      	ldr	r0, [r3, #0]
 8029db4:	f7f7 fddc 	bl	8021970 <XMC_DMA_CH_Disable>

	/* DMA Reconfiguration */
	dma_disable();

	acq_buf_obj *p_acq_buf = ds_get_active_acq_buf();
 8029db8:	f7f6 fb9e 	bl	80204f8 <ds_get_active_acq_buf>

	bsp_dma_set_adc_control_from_acq_buf_obj(p_acq_buf);
 8029dbc:	f7ff fd48 	bl	8029850 <bsp_dma_set_adc_control_from_acq_buf_obj>
//============================================================================

static void bgt24ltr1x_start_up(void)
{
	/* Start BGT */
	PWM_CCU8_Start(&PWM_CCU8_BGT_VCC);
 8029dc0:	4821      	ldr	r0, [pc, #132]	; (8029e48 <CCU43_1_IRQHandler+0xdc>)
 8029dc2:	f7fc faaf 	bl	8026324 <PWM_CCU8_Start>
 */
__STATIC_INLINE void DMA_CH_Enable(DMA_CH_t *const obj)
{
  XMC_ASSERT("DMA_CH_Enable: NULL DMA_CH_t object", (obj != NULL));

  XMC_DMA_CH_Enable(obj->dma_global->dma, obj->ch_num);
 8029dc6:	6830      	ldr	r0, [r6, #0]
 8029dc8:	6829      	ldr	r1, [r5, #0]
 8029dca:	6822      	ldr	r2, [r4, #0]
{
	/* Get the raw ADC data */
	trigger_dma_start();

	/* This callback is used to inform upper layers about the beginning of data acquisition process */
	if (bsp_cb.bsp_acq_started_cb != NULL)
 8029dcc:	4b1f      	ldr	r3, [pc, #124]	; (8029e4c <CCU43_1_IRQHandler+0xe0>)
 8029dce:	f8d7 b000 	ldr.w	fp, [r7]
 8029dd2:	f894 c00c 	ldrb.w	ip, [r4, #12]
 8029dd6:	f897 e00c 	ldrb.w	lr, [r7, #12]
 8029dda:	f896 900c 	ldrb.w	r9, [r6, #12]
 8029dde:	f895 a00c 	ldrb.w	sl, [r5, #12]
 8029de2:	f8db 7000 	ldr.w	r7, [fp]
 8029de6:	6805      	ldr	r5, [r0, #0]
	bsp_bgt_start_up();

	/* Enable DMA */
	dma_enable();

	l_acq_started = 1;
 8029de8:	4e19      	ldr	r6, [pc, #100]	; (8029e50 <CCU43_1_IRQHandler+0xe4>)
 8029dea:	6808      	ldr	r0, [r1, #0]
 8029dec:	6811      	ldr	r1, [r2, #0]
{
	/* Get the raw ADC data */
	trigger_dma_start();

	/* This callback is used to inform upper layers about the beginning of data acquisition process */
	if (bsp_cb.bsp_acq_started_cb != NULL)
 8029dee:	681a      	ldr	r2, [r3, #0]
 8029df0:	f240 1301 	movw	r3, #257	; 0x101
 8029df4:	fa03 fe0e 	lsl.w	lr, r3, lr
 8029df8:	fa03 f909 	lsl.w	r9, r3, r9
 8029dfc:	fa03 f40a 	lsl.w	r4, r3, sl
 8029e00:	fa03 f30c 	lsl.w	r3, r3, ip
	bsp_bgt_start_up();

	/* Enable DMA */
	dma_enable();

	l_acq_started = 1;
 8029e04:	f04f 0c01 	mov.w	ip, #1
 8029e08:	f8c7 e3a0 	str.w	lr, [r7, #928]	; 0x3a0
 8029e0c:	f8c6 c000 	str.w	ip, [r6]
 8029e10:	f8c5 93a0 	str.w	r9, [r5, #928]	; 0x3a0
 8029e14:	f8c0 43a0 	str.w	r4, [r0, #928]	; 0x3a0
 8029e18:	f8c1 33a0 	str.w	r3, [r1, #928]	; 0x3a0
{
	/* Get the raw ADC data */
	trigger_dma_start();

	/* This callback is used to inform upper layers about the beginning of data acquisition process */
	if (bsp_cb.bsp_acq_started_cb != NULL)
 8029e1c:	b122      	cbz	r2, 8029e28 <CCU43_1_IRQHandler+0xbc>
	{
		bsp_cb.bsp_acq_started_cb(NULL);
 8029e1e:	4640      	mov	r0, r8
void trigger_ptat_delay(void)
{
	bsp_timer_stop_clear(&TIMER_PTAT_DELAY);
	// ptat delay expired, start the actual acquisition
	bsp_trigger_new_frame();
}
 8029e20:	b001      	add	sp, #4
 8029e22:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	trigger_dma_start();

	/* This callback is used to inform upper layers about the beginning of data acquisition process */
	if (bsp_cb.bsp_acq_started_cb != NULL)
	{
		bsp_cb.bsp_acq_started_cb(NULL);
 8029e26:	4710      	bx	r2
void trigger_ptat_delay(void)
{
	bsp_timer_stop_clear(&TIMER_PTAT_DELAY);
	// ptat delay expired, start the actual acquisition
	bsp_trigger_new_frame();
}
 8029e28:	b001      	add	sp, #4
 8029e2a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8029e2e:	bf00      	nop
 8029e30:	1ffe9130 	.word	0x1ffe9130
 8029e34:	1ffe93d0 	.word	0x1ffe93d0
 8029e38:	1ffe93e0 	.word	0x1ffe93e0
 8029e3c:	1ffe93f0 	.word	0x1ffe93f0
 8029e40:	1ffe9400 	.word	0x1ffe9400
 8029e44:	1ffeb484 	.word	0x1ffeb484
 8029e48:	1ffe9238 	.word	0x1ffe9238
 8029e4c:	1ffedbf4 	.word	0x1ffedbf4
 8029e50:	1ffeb488 	.word	0x1ffeb488

08029e54 <CCU41_1_IRQHandler>:
}

//============================================================================

void triggerFrameISR(void)
{
 8029e54:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8029e58:	b083      	sub	sp, #12
	Radar_Data_Acq_Mode_t mode = radar_get_data_acq_mode();
 8029e5a:	f7f6 feaf 	bl	8020bbc <radar_get_data_acq_mode>

	if (mode == RADAR_DATA_CONTINUOUS_MODE)
 8029e5e:	2802      	cmp	r0, #2
 8029e60:	f000 80bf 	beq.w	8029fe2 <CCU41_1_IRQHandler+0x18e>
		/* ensure V_PTAT_SH_EN is enabled */
		DIGITAL_IO_SetOutputHigh(&DIGITAL_IO_V_PTAT_SH_EN);

		bsp_trigger_new_frame();
	}
	else if (bb_pre_trigger_advance_usec > 0)
 8029e64:	4c6f      	ldr	r4, [pc, #444]	; (802a024 <CCU41_1_IRQHandler+0x1d0>)
 8029e66:	6823      	ldr	r3, [r4, #0]
 8029e68:	2b00      	cmp	r3, #0
 8029e6a:	f300 80a2 	bgt.w	8029fb2 <CCU41_1_IRQHandler+0x15e>
		DIGITAL_IO_SetOutputHigh(&DIGITAL_IO_BB1_EN);
		DIGITAL_IO_SetOutputHigh(&DIGITAL_IO_BB2_EN);

		bsp_timer_start(&TIMER_BB_PRE_TRIGGER);
	}
	else if (ptat_switching_status != 0 && ptat_switch_delay_usec > 0)
 8029e6e:	4a6e      	ldr	r2, [pc, #440]	; (802a028 <CCU41_1_IRQHandler+0x1d4>)
 8029e70:	6812      	ldr	r2, [r2, #0]
 8029e72:	2a00      	cmp	r2, #0
 8029e74:	d178      	bne.n	8029f68 <CCU41_1_IRQHandler+0x114>
			enable_Baseband(true);
		}
	}
	else
	{
		if (bb_pre_trigger_advance_usec < 0)
 8029e76:	2b00      	cmp	r3, #0
 8029e78:	f040 80af 	bne.w	8029fda <CCU41_1_IRQHandler+0x186>
 8029e7c:	4a6b      	ldr	r2, [pc, #428]	; (802a02c <CCU41_1_IRQHandler+0x1d8>)
 8029e7e:	4b6c      	ldr	r3, [pc, #432]	; (802a030 <CCU41_1_IRQHandler+0x1dc>)

__STATIC_INLINE void XMC_GPIO_SetOutputHigh(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputHigh: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = (uint32_t)0x1U << pin;
 8029e80:	7c10      	ldrb	r0, [r2, #16]
 8029e82:	7c1c      	ldrb	r4, [r3, #16]
 8029e84:	6811      	ldr	r1, [r2, #0]
 8029e86:	681a      	ldr	r2, [r3, #0]
 8029e88:	2301      	movs	r3, #1
 8029e8a:	fa03 f000 	lsl.w	r0, r3, r0
 8029e8e:	40a3      	lsls	r3, r4
 8029e90:	6048      	str	r0, [r1, #4]
 8029e92:	6053      	str	r3, [r2, #4]
 8029e94:	4a67      	ldr	r2, [pc, #412]	; (802a034 <CCU41_1_IRQHandler+0x1e0>)
 8029e96:	4b68      	ldr	r3, [pc, #416]	; (802a038 <CCU41_1_IRQHandler+0x1e4>)

__STATIC_INLINE void XMC_GPIO_SetOutputLow(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputLow: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = 0x10000U << pin;
 8029e98:	f892 e010 	ldrb.w	lr, [r2, #16]
 8029e9c:	f893 c010 	ldrb.w	ip, [r3, #16]
 8029ea0:	681b      	ldr	r3, [r3, #0]
 8029ea2:	6811      	ldr	r1, [r2, #0]
 8029ea4:	9301      	str	r3, [sp, #4]
 8029ea6:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8029eaa:	fa03 f20e 	lsl.w	r2, r3, lr
 8029eae:	604a      	str	r2, [r1, #4]
 8029eb0:	9a01      	ldr	r2, [sp, #4]
 8029eb2:	4f62      	ldr	r7, [pc, #392]	; (802a03c <CCU41_1_IRQHandler+0x1e8>)

TIMER_STATUS_t bsp_timer_start(TIMER_t *const handle_timer)
{
	TIMER_STATUS_t status;

	status = TIMER_Start(handle_timer);
 8029eb4:	4862      	ldr	r0, [pc, #392]	; (802a040 <CCU41_1_IRQHandler+0x1ec>)
 8029eb6:	4e63      	ldr	r6, [pc, #396]	; (802a044 <CCU41_1_IRQHandler+0x1f0>)
 8029eb8:	4d63      	ldr	r5, [pc, #396]	; (802a048 <CCU41_1_IRQHandler+0x1f4>)
 8029eba:	4c64      	ldr	r4, [pc, #400]	; (802a04c <CCU41_1_IRQHandler+0x1f8>)
 8029ebc:	fa03 f30c 	lsl.w	r3, r3, ip
 8029ec0:	6053      	str	r3, [r2, #4]
 8029ec2:	f7fb ffd7 	bl	8025e74 <TIMER_Start>
 */
__STATIC_INLINE void DMA_CH_Disable(DMA_CH_t *const obj)
{
  XMC_ASSERT("DMA_CH_Disable: NULL DMA_CH_t object", (obj != NULL));

  XMC_DMA_CH_Disable(obj->dma_global->dma, obj->ch_num);
 8029ec6:	683a      	ldr	r2, [r7, #0]
==============================================================================
 */

static void trigger_dma_start(void)
{
	watchdog_status = 0;
 8029ec8:	4b61      	ldr	r3, [pc, #388]	; (802a050 <CCU41_1_IRQHandler+0x1fc>)
 8029eca:	6810      	ldr	r0, [r2, #0]
 8029ecc:	7b39      	ldrb	r1, [r7, #12]
 8029ece:	f04f 0800 	mov.w	r8, #0
 8029ed2:	f883 8000 	strb.w	r8, [r3]
 8029ed6:	f7f7 fd4b 	bl	8021970 <XMC_DMA_CH_Disable>
 8029eda:	6833      	ldr	r3, [r6, #0]
 8029edc:	7b31      	ldrb	r1, [r6, #12]
 8029ede:	6818      	ldr	r0, [r3, #0]
 8029ee0:	f7f7 fd46 	bl	8021970 <XMC_DMA_CH_Disable>
 8029ee4:	682b      	ldr	r3, [r5, #0]
 8029ee6:	7b29      	ldrb	r1, [r5, #12]
 8029ee8:	6818      	ldr	r0, [r3, #0]
 8029eea:	f7f7 fd41 	bl	8021970 <XMC_DMA_CH_Disable>
 8029eee:	6823      	ldr	r3, [r4, #0]
 8029ef0:	7b21      	ldrb	r1, [r4, #12]
 8029ef2:	6818      	ldr	r0, [r3, #0]
 8029ef4:	f7f7 fd3c 	bl	8021970 <XMC_DMA_CH_Disable>

	/* DMA Reconfiguration */
	dma_disable();

	acq_buf_obj *p_acq_buf = ds_get_active_acq_buf();
 8029ef8:	f7f6 fafe 	bl	80204f8 <ds_get_active_acq_buf>

	bsp_dma_set_adc_control_from_acq_buf_obj(p_acq_buf);
 8029efc:	f7ff fca8 	bl	8029850 <bsp_dma_set_adc_control_from_acq_buf_obj>
//============================================================================

static void bgt24ltr1x_start_up(void)
{
	/* Start BGT */
	PWM_CCU8_Start(&PWM_CCU8_BGT_VCC);
 8029f00:	4854      	ldr	r0, [pc, #336]	; (802a054 <CCU41_1_IRQHandler+0x200>)
 8029f02:	f7fc fa0f 	bl	8026324 <PWM_CCU8_Start>
 */
__STATIC_INLINE void DMA_CH_Enable(DMA_CH_t *const obj)
{
  XMC_ASSERT("DMA_CH_Enable: NULL DMA_CH_t object", (obj != NULL));

  XMC_DMA_CH_Enable(obj->dma_global->dma, obj->ch_num);
 8029f06:	6830      	ldr	r0, [r6, #0]
 8029f08:	6829      	ldr	r1, [r5, #0]
 8029f0a:	6822      	ldr	r2, [r4, #0]
{
	/* Get the raw ADC data */
	trigger_dma_start();

	/* This callback is used to inform upper layers about the beginning of data acquisition process */
	if (bsp_cb.bsp_acq_started_cb != NULL)
 8029f0c:	4b52      	ldr	r3, [pc, #328]	; (802a058 <CCU41_1_IRQHandler+0x204>)
 8029f0e:	f8d7 b000 	ldr.w	fp, [r7]
 8029f12:	f894 c00c 	ldrb.w	ip, [r4, #12]
 8029f16:	f897 e00c 	ldrb.w	lr, [r7, #12]
 8029f1a:	f896 900c 	ldrb.w	r9, [r6, #12]
 8029f1e:	f895 a00c 	ldrb.w	sl, [r5, #12]
 8029f22:	f8db 7000 	ldr.w	r7, [fp]
 8029f26:	6805      	ldr	r5, [r0, #0]
	bsp_bgt_start_up();

	/* Enable DMA */
	dma_enable();

	l_acq_started = 1;
 8029f28:	4e4c      	ldr	r6, [pc, #304]	; (802a05c <CCU41_1_IRQHandler+0x208>)
 8029f2a:	6808      	ldr	r0, [r1, #0]
 8029f2c:	6811      	ldr	r1, [r2, #0]
{
	/* Get the raw ADC data */
	trigger_dma_start();

	/* This callback is used to inform upper layers about the beginning of data acquisition process */
	if (bsp_cb.bsp_acq_started_cb != NULL)
 8029f2e:	681a      	ldr	r2, [r3, #0]
 8029f30:	f240 1301 	movw	r3, #257	; 0x101
 8029f34:	fa03 fe0e 	lsl.w	lr, r3, lr
 8029f38:	fa03 f909 	lsl.w	r9, r3, r9
 8029f3c:	fa03 f40a 	lsl.w	r4, r3, sl
 8029f40:	fa03 f30c 	lsl.w	r3, r3, ip
	bsp_bgt_start_up();

	/* Enable DMA */
	dma_enable();

	l_acq_started = 1;
 8029f44:	f04f 0c01 	mov.w	ip, #1
 8029f48:	f8c7 e3a0 	str.w	lr, [r7, #928]	; 0x3a0
 8029f4c:	f8c6 c000 	str.w	ip, [r6]
 8029f50:	f8c5 93a0 	str.w	r9, [r5, #928]	; 0x3a0
 8029f54:	f8c0 43a0 	str.w	r4, [r0, #928]	; 0x3a0
 8029f58:	f8c1 33a0 	str.w	r3, [r1, #928]	; 0x3a0
{
	/* Get the raw ADC data */
	trigger_dma_start();

	/* This callback is used to inform upper layers about the beginning of data acquisition process */
	if (bsp_cb.bsp_acq_started_cb != NULL)
 8029f5c:	b332      	cbz	r2, 8029fac <CCU41_1_IRQHandler+0x158>
	{
		bsp_cb.bsp_acq_started_cb(NULL);
 8029f5e:	4640      	mov	r0, r8

		bsp_timer_start(&TIMER_PTAT_S_H_DELAY);

		bsp_trigger_new_frame();
	}
}
 8029f60:	b003      	add	sp, #12
 8029f62:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	trigger_dma_start();

	/* This callback is used to inform upper layers about the beginning of data acquisition process */
	if (bsp_cb.bsp_acq_started_cb != NULL)
	{
		bsp_cb.bsp_acq_started_cb(NULL);
 8029f66:	4710      	bx	r2
		DIGITAL_IO_SetOutputHigh(&DIGITAL_IO_BB1_EN);
		DIGITAL_IO_SetOutputHigh(&DIGITAL_IO_BB2_EN);

		bsp_timer_start(&TIMER_BB_PRE_TRIGGER);
	}
	else if (ptat_switching_status != 0 && ptat_switch_delay_usec > 0)
 8029f68:	4a3d      	ldr	r2, [pc, #244]	; (802a060 <CCU41_1_IRQHandler+0x20c>)
 8029f6a:	6812      	ldr	r2, [r2, #0]
 8029f6c:	2a00      	cmp	r2, #0
 8029f6e:	d082      	beq.n	8029e76 <CCU41_1_IRQHandler+0x22>

TIMER_STATUS_t bsp_timer_start(TIMER_t *const handle_timer)
{
	TIMER_STATUS_t status;

	status = TIMER_Start(handle_timer);
 8029f70:	483c      	ldr	r0, [pc, #240]	; (802a064 <CCU41_1_IRQHandler+0x210>)
 8029f72:	f7fb ff7f 	bl	8025e74 <TIMER_Start>
 8029f76:	4a2f      	ldr	r2, [pc, #188]	; (802a034 <CCU41_1_IRQHandler+0x1e0>)
 8029f78:	4b2f      	ldr	r3, [pc, #188]	; (802a038 <CCU41_1_IRQHandler+0x1e4>)

__STATIC_INLINE void XMC_GPIO_SetOutputHigh(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputHigh: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = (uint32_t)0x1U << pin;
 8029f7a:	7c15      	ldrb	r5, [r2, #16]
 8029f7c:	7c18      	ldrb	r0, [r3, #16]

		/* ensure V_PTAT_SH_EN is enabled */
		DIGITAL_IO_SetOutputHigh(&DIGITAL_IO_V_PTAT_SH_EN);

		/* if bb_pre_trigger advance is negative or smaller then ptat_switch delay, then it is actually a delay */
		if (bb_pre_trigger_advance_usec < 0)
 8029f7e:	6821      	ldr	r1, [r4, #0]
 8029f80:	6814      	ldr	r4, [r2, #0]
 8029f82:	681a      	ldr	r2, [r3, #0]
 8029f84:	2301      	movs	r3, #1
 8029f86:	fa03 f505 	lsl.w	r5, r3, r5
 8029f8a:	fa03 f000 	lsl.w	r0, r3, r0
 8029f8e:	2900      	cmp	r1, #0
 8029f90:	6065      	str	r5, [r4, #4]
 8029f92:	6050      	str	r0, [r2, #4]
 8029f94:	db44      	blt.n	802a020 <CCU41_1_IRQHandler+0x1cc>
 8029f96:	4925      	ldr	r1, [pc, #148]	; (802a02c <CCU41_1_IRQHandler+0x1d8>)
 8029f98:	4a25      	ldr	r2, [pc, #148]	; (802a030 <CCU41_1_IRQHandler+0x1dc>)
 8029f9a:	7c08      	ldrb	r0, [r1, #16]
 8029f9c:	7c14      	ldrb	r4, [r2, #16]
 8029f9e:	6809      	ldr	r1, [r1, #0]
 8029fa0:	6812      	ldr	r2, [r2, #0]
 8029fa2:	fa03 f000 	lsl.w	r0, r3, r0
 8029fa6:	40a3      	lsls	r3, r4
 8029fa8:	6048      	str	r0, [r1, #4]
 8029faa:	6053      	str	r3, [r2, #4]

		bsp_timer_start(&TIMER_PTAT_S_H_DELAY);

		bsp_trigger_new_frame();
	}
}
 8029fac:	b003      	add	sp, #12
 8029fae:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8029fb2:	4a1e      	ldr	r2, [pc, #120]	; (802a02c <CCU41_1_IRQHandler+0x1d8>)
 8029fb4:	4b1e      	ldr	r3, [pc, #120]	; (802a030 <CCU41_1_IRQHandler+0x1dc>)
 8029fb6:	7c14      	ldrb	r4, [r2, #16]
 8029fb8:	7c1d      	ldrb	r5, [r3, #16]
 8029fba:	6811      	ldr	r1, [r2, #0]
 8029fbc:	681a      	ldr	r2, [r3, #0]

TIMER_STATUS_t bsp_timer_start(TIMER_t *const handle_timer)
{
	TIMER_STATUS_t status;

	status = TIMER_Start(handle_timer);
 8029fbe:	482a      	ldr	r0, [pc, #168]	; (802a068 <CCU41_1_IRQHandler+0x214>)
 8029fc0:	2301      	movs	r3, #1
 8029fc2:	fa03 f404 	lsl.w	r4, r3, r4
 8029fc6:	40ab      	lsls	r3, r5
 8029fc8:	604c      	str	r4, [r1, #4]
 8029fca:	6053      	str	r3, [r2, #4]
 8029fcc:	604c      	str	r4, [r1, #4]
 8029fce:	6053      	str	r3, [r2, #4]

		bsp_timer_start(&TIMER_PTAT_S_H_DELAY);

		bsp_trigger_new_frame();
	}
}
 8029fd0:	b003      	add	sp, #12
 8029fd2:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

TIMER_STATUS_t bsp_timer_start(TIMER_t *const handle_timer)
{
	TIMER_STATUS_t status;

	status = TIMER_Start(handle_timer);
 8029fd6:	f7fb bf4d 	b.w	8025e74 <TIMER_Start>
 8029fda:	4823      	ldr	r0, [pc, #140]	; (802a068 <CCU41_1_IRQHandler+0x214>)
 8029fdc:	f7fb ff4a 	bl	8025e74 <TIMER_Start>
 8029fe0:	e758      	b.n	8029e94 <CCU41_1_IRQHandler+0x40>
 8029fe2:	4913      	ldr	r1, [pc, #76]	; (802a030 <CCU41_1_IRQHandler+0x1dc>)
 8029fe4:	4a13      	ldr	r2, [pc, #76]	; (802a034 <CCU41_1_IRQHandler+0x1e0>)
 8029fe6:	4b14      	ldr	r3, [pc, #80]	; (802a038 <CCU41_1_IRQHandler+0x1e4>)
 8029fe8:	4810      	ldr	r0, [pc, #64]	; (802a02c <CCU41_1_IRQHandler+0x1d8>)
 8029fea:	7c0e      	ldrb	r6, [r1, #16]
 8029fec:	7c07      	ldrb	r7, [r0, #16]
 8029fee:	7c15      	ldrb	r5, [r2, #16]
 8029ff0:	f893 e010 	ldrb.w	lr, [r3, #16]
 8029ff4:	680c      	ldr	r4, [r1, #0]
 8029ff6:	6800      	ldr	r0, [r0, #0]
 8029ff8:	6811      	ldr	r1, [r2, #0]
 8029ffa:	681a      	ldr	r2, [r3, #0]
 8029ffc:	2301      	movs	r3, #1
 8029ffe:	fa03 f707 	lsl.w	r7, r3, r7
 802a002:	fa03 f606 	lsl.w	r6, r3, r6
 802a006:	fa03 f505 	lsl.w	r5, r3, r5
 802a00a:	fa03 f30e 	lsl.w	r3, r3, lr
 802a00e:	6047      	str	r7, [r0, #4]
 802a010:	6066      	str	r6, [r4, #4]
 802a012:	604d      	str	r5, [r1, #4]
 802a014:	6053      	str	r3, [r2, #4]

		bsp_timer_start(&TIMER_PTAT_S_H_DELAY);

		bsp_trigger_new_frame();
	}
}
 802a016:	b003      	add	sp, #12
 802a018:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		DIGITAL_IO_SetOutputHigh(&DIGITAL_IO_BGT_VCC_PTAT);

		/* ensure V_PTAT_SH_EN is enabled */
		DIGITAL_IO_SetOutputHigh(&DIGITAL_IO_V_PTAT_SH_EN);

		bsp_trigger_new_frame();
 802a01c:	f7ff bcaa 	b.w	8029974 <bsp_trigger_new_frame>

TIMER_STATUS_t bsp_timer_start(TIMER_t *const handle_timer)
{
	TIMER_STATUS_t status;

	status = TIMER_Start(handle_timer);
 802a020:	4811      	ldr	r0, [pc, #68]	; (802a068 <CCU41_1_IRQHandler+0x214>)
 802a022:	e7d5      	b.n	8029fd0 <CCU41_1_IRQHandler+0x17c>
 802a024:	1ffe960c 	.word	0x1ffe960c
 802a028:	1ffeb494 	.word	0x1ffeb494
 802a02c:	0802dd94 	.word	0x0802dd94
 802a030:	0802dda8 	.word	0x0802dda8
 802a034:	0802ddbc 	.word	0x0802ddbc
 802a038:	0802de48 	.word	0x0802de48
 802a03c:	1ffe93d0 	.word	0x1ffe93d0
 802a040:	1ffe91c0 	.word	0x1ffe91c0
 802a044:	1ffe93e0 	.word	0x1ffe93e0
 802a048:	1ffe93f0 	.word	0x1ffe93f0
 802a04c:	1ffe9400 	.word	0x1ffe9400
 802a050:	1ffeb484 	.word	0x1ffeb484
 802a054:	1ffe9238 	.word	0x1ffe9238
 802a058:	1ffedbf4 	.word	0x1ffedbf4
 802a05c:	1ffeb488 	.word	0x1ffeb488
 802a060:	1ffeb490 	.word	0x1ffeb490
 802a064:	1ffe9130 	.word	0x1ffe9130
 802a068:	1ffe9168 	.word	0x1ffe9168

0802a06c <bsp_reset_frame_counter>:

//============================================================================

void bsp_reset_frame_counter(void)
{
	bsp_frame_counter = 0;
 802a06c:	4b01      	ldr	r3, [pc, #4]	; (802a074 <bsp_reset_frame_counter+0x8>)
 802a06e:	2200      	movs	r2, #0
 802a070:	601a      	str	r2, [r3, #0]
 802a072:	4770      	bx	lr
 802a074:	1ffeb48c 	.word	0x1ffeb48c

0802a078 <bsp_register_callback>:
uint8_t bsp_register_callback(Bsp_Callback_ID_t cb_id, void (*pcallback)(void *parameter))
{
	uint8_t status = 0;

	/* Check if he callback function is valid */
	if (pcallback == NULL)
 802a078:	b139      	cbz	r1, 802a08a <bsp_register_callback+0x12>
	{
		return (1);
	}

	/* Register user callback function based on callback ID */
	switch (cb_id)
 802a07a:	2801      	cmp	r0, #1
 802a07c:	d007      	beq.n	802a08e <bsp_register_callback+0x16>
 802a07e:	2802      	cmp	r0, #2
 802a080:	d103      	bne.n	802a08a <bsp_register_callback+0x12>
	case BSP_ACQUISITION_STARTED_CB_ID:
		bsp_cb.bsp_acq_started_cb = pcallback;
		break;

	case BSP_ACQUISITION_DONE_CB_ID:
		bsp_cb.bsp_acq_done_cb = pcallback;
 802a082:	4b05      	ldr	r3, [pc, #20]	; (802a098 <bsp_register_callback+0x20>)

//============================================================================

uint8_t bsp_register_callback(Bsp_Callback_ID_t cb_id, void (*pcallback)(void *parameter))
{
	uint8_t status = 0;
 802a084:	2000      	movs	r0, #0
	case BSP_ACQUISITION_STARTED_CB_ID:
		bsp_cb.bsp_acq_started_cb = pcallback;
		break;

	case BSP_ACQUISITION_DONE_CB_ID:
		bsp_cb.bsp_acq_done_cb = pcallback;
 802a086:	6059      	str	r1, [r3, #4]
		break;
 802a088:	4770      	bx	lr

	default:
		/* Return error status */
		status = 1;
 802a08a:	2001      	movs	r0, #1
		break;
	}

	return (status);
}
 802a08c:	4770      	bx	lr

	/* Register user callback function based on callback ID */
	switch (cb_id)
	{
	case BSP_ACQUISITION_STARTED_CB_ID:
		bsp_cb.bsp_acq_started_cb = pcallback;
 802a08e:	4b02      	ldr	r3, [pc, #8]	; (802a098 <bsp_register_callback+0x20>)

//============================================================================

uint8_t bsp_register_callback(Bsp_Callback_ID_t cb_id, void (*pcallback)(void *parameter))
{
	uint8_t status = 0;
 802a090:	2000      	movs	r0, #0

	/* Register user callback function based on callback ID */
	switch (cb_id)
	{
	case BSP_ACQUISITION_STARTED_CB_ID:
		bsp_cb.bsp_acq_started_cb = pcallback;
 802a092:	6019      	str	r1, [r3, #0]
		break;
 802a094:	4770      	bx	lr
 802a096:	bf00      	nop
 802a098:	1ffedbf4 	.word	0x1ffedbf4

0802a09c <bsp_start_frame_intervall_timer>:
}

//============================================================================

uint32_t bsp_start_frame_intervall_timer(uint32_t frame_interval_usec)
{
 802a09c:	b508      	push	{r3, lr}

	/* Update time period of Automatic Trigger */
	if (TIMER_SetTimeInterval(&TIMER_FRAME_TRIG, frame_interval_usec * 100U) != TIMER_STATUS_SUCCESS)
 802a09e:	2164      	movs	r1, #100	; 0x64
 802a0a0:	fb01 f100 	mul.w	r1, r1, r0
 802a0a4:	4803      	ldr	r0, [pc, #12]	; (802a0b4 <bsp_start_frame_intervall_timer+0x18>)
 802a0a6:	f7fb ff07 	bl	8025eb8 <TIMER_SetTimeInterval>
	{
		return 0;
	}
	return 1;
}
 802a0aa:	fab0 f080 	clz	r0, r0
 802a0ae:	0940      	lsrs	r0, r0, #5
 802a0b0:	bd08      	pop	{r3, pc}
 802a0b2:	bf00      	nop
 802a0b4:	1ffe9210 	.word	0x1ffe9210

0802a0b8 <bsp_calc_min_frame_interval_usec>:

//============================================================================

uint32_t bsp_calc_min_frame_interval_usec(device_settings_t *p_dev)
{
	uint32_t min_frame_interval_usec = p_dev->num_of_chirps_per_frame * (((p_dev->num_samples_per_chirp + p_dev->num_sample_skip_count) * 1000U * 1000U) / p_dev->adc_sampling_freq_Hz); // units in us
 802a0b8:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 802a0ba:	6a41      	ldr	r1, [r0, #36]	; 0x24
 802a0bc:	4a06      	ldr	r2, [pc, #24]	; (802a0d8 <bsp_calc_min_frame_interval_usec+0x20>)
}

//============================================================================

uint32_t bsp_calc_min_frame_interval_usec(device_settings_t *p_dev)
{
 802a0be:	b410      	push	{r4}
	uint32_t min_frame_interval_usec = p_dev->num_of_chirps_per_frame * (((p_dev->num_samples_per_chirp + p_dev->num_sample_skip_count) * 1000U * 1000U) / p_dev->adc_sampling_freq_Hz); // units in us
 802a0c0:	69c4      	ldr	r4, [r0, #28]
 802a0c2:	6940      	ldr	r0, [r0, #20]
 802a0c4:	440b      	add	r3, r1
 802a0c6:	fb02 f303 	mul.w	r3, r2, r3
 802a0ca:	fbb3 f0f0 	udiv	r0, r3, r0

	return min_frame_interval_usec;
}
 802a0ce:	fb04 f000 	mul.w	r0, r4, r0
 802a0d2:	f85d 4b04 	ldr.w	r4, [sp], #4
 802a0d6:	4770      	bx	lr
 802a0d8:	000f4240 	.word	0x000f4240

0802a0dc <bsp_set_ptat_switch_status>:

//============================================================================

void bsp_set_ptat_switch_status(uint32_t new_status, uint32_t new_delay_usec)
{
	ptat_switching_status  = new_status;
 802a0dc:	4a02      	ldr	r2, [pc, #8]	; (802a0e8 <bsp_set_ptat_switch_status+0xc>)
	ptat_switch_delay_usec = new_delay_usec;
 802a0de:	4b03      	ldr	r3, [pc, #12]	; (802a0ec <bsp_set_ptat_switch_status+0x10>)

//============================================================================

void bsp_set_ptat_switch_status(uint32_t new_status, uint32_t new_delay_usec)
{
	ptat_switching_status  = new_status;
 802a0e0:	6010      	str	r0, [r2, #0]
	ptat_switch_delay_usec = new_delay_usec;
 802a0e2:	6019      	str	r1, [r3, #0]
 802a0e4:	4770      	bx	lr
 802a0e6:	bf00      	nop
 802a0e8:	1ffeb494 	.word	0x1ffeb494
 802a0ec:	1ffeb490 	.word	0x1ffeb490

0802a0f0 <bsp_usb_init>:
    6. EXPORTED FUNCTIONS
==============================================================================
 */

uint8_t bsp_usb_init(uint32_t timeout_delay)
{
 802a0f0:	b538      	push	{r3, r4, r5, lr}
 802a0f2:	4605      	mov	r5, r0
	uint32_t timeout_cnt = 0;

	if (USBD_VCOM_Connect() != USBD_VCOM_STATUS_SUCCESS)
 802a0f4:	f7fa ffa6 	bl	8025044 <USBD_VCOM_Connect>
 802a0f8:	b958      	cbnz	r0, 802a112 <bsp_usb_init+0x22>
	{
		return (1); /* Fail */
	}

	while (timeout_cnt < timeout_delay)
 802a0fa:	b155      	cbz	r5, 802a112 <bsp_usb_init+0x22>
 802a0fc:	4604      	mov	r4, r0
 802a0fe:	e001      	b.n	802a104 <bsp_usb_init+0x14>
 802a100:	42ac      	cmp	r4, r5
 802a102:	d006      	beq.n	802a112 <bsp_usb_init+0x22>
	{
		if (USBD_VCOM_IsEnumDone())
 802a104:	f7fa ff3e 	bl	8024f84 <USBD_VCOM_IsEnumDone>
		{
			return (0); /* Success */
		}

		timeout_cnt++;
 802a108:	3401      	adds	r4, #1
		return (1); /* Fail */
	}

	while (timeout_cnt < timeout_delay)
	{
		if (USBD_VCOM_IsEnumDone())
 802a10a:	2800      	cmp	r0, #0
 802a10c:	d0f8      	beq.n	802a100 <bsp_usb_init+0x10>
		{
			return (0); /* Success */
 802a10e:	2000      	movs	r0, #0

		timeout_cnt++;
	}

	return (1); /* Fail */
}
 802a110:	bd38      	pop	{r3, r4, r5, pc}
{
	uint32_t timeout_cnt = 0;

	if (USBD_VCOM_Connect() != USBD_VCOM_STATUS_SUCCESS)
	{
		return (1); /* Fail */
 802a112:	2001      	movs	r0, #1
 802a114:	bd38      	pop	{r3, r4, r5, pc}
 802a116:	bf00      	nop

0802a118 <app_data_acq_started_cb>:
/* This callback function will be executed by radar control when starting data acquisition process
 *   it can be used to get information about the beginning of data acquisition
 */
void app_data_acq_started_cb(void *parameter)
{
	acq_started += 1;
 802a118:	4a02      	ldr	r2, [pc, #8]	; (802a124 <app_data_acq_started_cb+0xc>)
 802a11a:	6813      	ldr	r3, [r2, #0]
 802a11c:	3301      	adds	r3, #1
 802a11e:	6013      	str	r3, [r2, #0]
 802a120:	4770      	bx	lr
 802a122:	bf00      	nop
 802a124:	1ffedc38 	.word	0x1ffedc38

0802a128 <system_reset>:

//============================================================================

/* This function yet to be filled in case of software reset */
void system_reset(void)
{
 802a128:	4770      	bx	lr
 802a12a:	bf00      	nop

0802a12c <app_data_acq_done_cb>:
/* This callback function will be executed by radar control at the end of data acquisition,
 * it is used to inform upper layers that data sampling is done and data is ready in user buffer
 */
void app_data_acq_done_cb(void *parameter)
{
	acq_completed += 1;
 802a12c:	4a02      	ldr	r2, [pc, #8]	; (802a138 <app_data_acq_done_cb+0xc>)
 802a12e:	6813      	ldr	r3, [r2, #0]
 802a130:	3301      	adds	r3, #1
 802a132:	6013      	str	r3, [r2, #0]
	acq_completed_cb();
 802a134:	f000 bc0c 	b.w	802a950 <acq_completed_cb>
 802a138:	1ffedc2c 	.word	0x1ffedc2c

0802a13c <app_init>:
==============================================================================
 */

/* Initialize all firmware and algorithm parameters and start communication protocol */
void app_init(void)
{
 802a13c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  /* Initialize USB */
  if (bsp_usb_init(BSP_USB_TIMEOUT) == 0)
 802a140:	f640 70ff 	movw	r0, #4095	; 0xfff
==============================================================================
 */

/* Initialize all firmware and algorithm parameters and start communication protocol */
void app_init(void)
{
 802a144:	b09d      	sub	sp, #116	; 0x74
  /* Initialize USB */
  if (bsp_usb_init(BSP_USB_TIMEOUT) == 0)
 802a146:	f7ff ffd3 	bl	802a0f0 <bsp_usb_init>
 802a14a:	b910      	cbnz	r0, 802a152 <app_init+0x16>
  {
    g_usb_init = true;
 802a14c:	4b34      	ldr	r3, [pc, #208]	; (802a220 <app_init+0xe4>)
 802a14e:	2201      	movs	r2, #1
 802a150:	701a      	strb	r2, [r3, #0]
  }

  /* Register all endpoints to the communication protocol */
  Endpoint_t ep_list[NUMBER_SUPPORTED_ENDPOINTS] =
 802a152:	4d34      	ldr	r5, [pc, #208]	; (802a224 <app_init+0xe8>)
  {
    EP_RADAR_MCUBASE_LIST_ENTRY(h_radar_device),
  	EP_RADAR_DEVICE_STATUS_LIST_ENTRY(h_radar_device)
  };

  app_initalized = 0;
 802a154:	4e34      	ldr	r6, [pc, #208]	; (802a228 <app_init+0xec>)
  {
    g_usb_init = true;
  }

  /* Register all endpoints to the communication protocol */
  Endpoint_t ep_list[NUMBER_SUPPORTED_ENDPOINTS] =
 802a156:	6828      	ldr	r0, [r5, #0]
 802a158:	f8df 80f0 	ldr.w	r8, [pc, #240]	; 802a24c <app_init+0x110>
 802a15c:	f8df c0f0 	ldr.w	ip, [pc, #240]	; 802a250 <app_init+0x114>
 802a160:	f8df e0f0 	ldr.w	lr, [pc, #240]	; 802a254 <app_init+0x118>
 802a164:	4f31      	ldr	r7, [pc, #196]	; (802a22c <app_init+0xf0>)
 802a166:	4a32      	ldr	r2, [pc, #200]	; (802a230 <app_init+0xf4>)
 802a168:	4b32      	ldr	r3, [pc, #200]	; (802a234 <app_init+0xf8>)
 802a16a:	f8df b0ec 	ldr.w	fp, [pc, #236]	; 802a258 <app_init+0x11c>
 802a16e:	f8df a0ec 	ldr.w	sl, [pc, #236]	; 802a25c <app_init+0x120>
 802a172:	f8df 90ec 	ldr.w	r9, [pc, #236]	; 802a260 <app_init+0x124>
 802a176:	9010      	str	r0, [sp, #64]	; 0x40
  {
    EP_RADAR_MCUBASE_LIST_ENTRY(h_radar_device),
  	EP_RADAR_DEVICE_STATUS_LIST_ENTRY(h_radar_device)
  };

  app_initalized = 0;
 802a178:	2400      	movs	r4, #0
  {
    g_usb_init = true;
  }

  /* Register all endpoints to the communication protocol */
  Endpoint_t ep_list[NUMBER_SUPPORTED_ENDPOINTS] =
 802a17a:	9015      	str	r0, [sp, #84]	; 0x54
 802a17c:	901a      	str	r0, [sp, #104]	; 0x68
	EP_RADAR_S2GLPULSE_LIST_ENTRY(h_radar_device),
  	EP_RADAR_DEVICE_STATUS_LIST_ENTRY(h_radar_device)
  };

  /* Register all endpoints in case of init error to the communication protocol */
  Endpoint_t ep_err_list[2] =
 802a17e:	9006      	str	r0, [sp, #24]
 802a180:	900b      	str	r0, [sp, #44]	; 0x2c
  {
    EP_RADAR_MCUBASE_LIST_ENTRY(h_radar_device),
  	EP_RADAR_DEVICE_STATUS_LIST_ENTRY(h_radar_device)
  };

  app_initalized = 0;
 802a182:	6034      	str	r4, [r6, #0]
  uint8_t num_of_ep = sizeof(ep_err_list)/sizeof(ep_err_list[0]);
  Endpoint_t *pEndPoints = &ep_err_list[0];

  /* Open the available radar device */
  if (radar_open_device(0, &h_radar_device) == RADAR_ERR_OK)
 802a184:	4620      	mov	r0, r4
 802a186:	4629      	mov	r1, r5
  {
    g_usb_init = true;
  }

  /* Register all endpoints to the communication protocol */
  Endpoint_t ep_list[NUMBER_SUPPORTED_ENDPOINTS] =
 802a188:	2401      	movs	r4, #1
 802a18a:	f8cd 8034 	str.w	r8, [sp, #52]	; 0x34
	EP_RADAR_S2GLPULSE_LIST_ENTRY(h_radar_device),
  	EP_RADAR_DEVICE_STATUS_LIST_ENTRY(h_radar_device)
  };

  /* Register all endpoints in case of init error to the communication protocol */
  Endpoint_t ep_err_list[2] =
 802a18e:	f8cd 800c 	str.w	r8, [sp, #12]
  {
    g_usb_init = true;
  }

  /* Register all endpoints to the communication protocol */
  Endpoint_t ep_list[NUMBER_SUPPORTED_ENDPOINTS] =
 802a192:	f8ad 4038 	strh.w	r4, [sp, #56]	; 0x38
 802a196:	f8ad 404c 	strh.w	r4, [sp, #76]	; 0x4c
 802a19a:	f8ad 4060 	strh.w	r4, [sp, #96]	; 0x60
	EP_RADAR_S2GLPULSE_LIST_ENTRY(h_radar_device),
  	EP_RADAR_DEVICE_STATUS_LIST_ENTRY(h_radar_device)
  };

  /* Register all endpoints in case of init error to the communication protocol */
  Endpoint_t ep_err_list[2] =
 802a19e:	f8ad 4010 	strh.w	r4, [sp, #16]
 802a1a2:	f8ad 4024 	strh.w	r4, [sp, #36]	; 0x24
  {
    g_usb_init = true;
  }

  /* Register all endpoints to the communication protocol */
  Endpoint_t ep_list[NUMBER_SUPPORTED_ENDPOINTS] =
 802a1a6:	f8cd c03c 	str.w	ip, [sp, #60]	; 0x3c
	EP_RADAR_S2GLPULSE_LIST_ENTRY(h_radar_device),
  	EP_RADAR_DEVICE_STATUS_LIST_ENTRY(h_radar_device)
  };

  /* Register all endpoints in case of init error to the communication protocol */
  Endpoint_t ep_err_list[2] =
 802a1aa:	f8cd c014 	str.w	ip, [sp, #20]
  {
    g_usb_init = true;
  }

  /* Register all endpoints to the communication protocol */
  Endpoint_t ep_list[NUMBER_SUPPORTED_ENDPOINTS] =
 802a1ae:	f8cd e044 	str.w	lr, [sp, #68]	; 0x44
	EP_RADAR_S2GLPULSE_LIST_ENTRY(h_radar_device),
  	EP_RADAR_DEVICE_STATUS_LIST_ENTRY(h_radar_device)
  };

  /* Register all endpoints in case of init error to the communication protocol */
  Endpoint_t ep_err_list[2] =
 802a1b2:	f8cd e01c 	str.w	lr, [sp, #28]
  {
    g_usb_init = true;
  }

  /* Register all endpoints to the communication protocol */
  Endpoint_t ep_list[NUMBER_SUPPORTED_ENDPOINTS] =
 802a1b6:	f8cd b048 	str.w	fp, [sp, #72]	; 0x48
 802a1ba:	f8cd a050 	str.w	sl, [sp, #80]	; 0x50
 802a1be:	f8cd 9058 	str.w	r9, [sp, #88]	; 0x58
 802a1c2:	9717      	str	r7, [sp, #92]	; 0x5c
	EP_RADAR_S2GLPULSE_LIST_ENTRY(h_radar_device),
  	EP_RADAR_DEVICE_STATUS_LIST_ENTRY(h_radar_device)
  };

  /* Register all endpoints in case of init error to the communication protocol */
  Endpoint_t ep_err_list[2] =
 802a1c4:	9708      	str	r7, [sp, #32]
  {
    g_usb_init = true;
  }

  /* Register all endpoints to the communication protocol */
  Endpoint_t ep_list[NUMBER_SUPPORTED_ENDPOINTS] =
 802a1c6:	9219      	str	r2, [sp, #100]	; 0x64
	EP_RADAR_S2GLPULSE_LIST_ENTRY(h_radar_device),
  	EP_RADAR_DEVICE_STATUS_LIST_ENTRY(h_radar_device)
  };

  /* Register all endpoints in case of init error to the communication protocol */
  Endpoint_t ep_err_list[2] =
 802a1c8:	920a      	str	r2, [sp, #40]	; 0x28
  {
    g_usb_init = true;
  }

  /* Register all endpoints to the communication protocol */
  Endpoint_t ep_list[NUMBER_SUPPORTED_ENDPOINTS] =
 802a1ca:	931b      	str	r3, [sp, #108]	; 0x6c
	EP_RADAR_S2GLPULSE_LIST_ENTRY(h_radar_device),
  	EP_RADAR_DEVICE_STATUS_LIST_ENTRY(h_radar_device)
  };

  /* Register all endpoints in case of init error to the communication protocol */
  Endpoint_t ep_err_list[2] =
 802a1cc:	930c      	str	r3, [sp, #48]	; 0x30
  app_initalized = 0;
  uint8_t num_of_ep = sizeof(ep_err_list)/sizeof(ep_err_list[0]);
  Endpoint_t *pEndPoints = &ep_err_list[0];

  /* Open the available radar device */
  if (radar_open_device(0, &h_radar_device) == RADAR_ERR_OK)
 802a1ce:	f7f6 fbb5 	bl	802093c <radar_open_device>
 802a1d2:	b1c0      	cbz	r0, 802a206 <app_init+0xca>
 802a1d4:	2228      	movs	r2, #40	; 0x28
  	EP_RADAR_DEVICE_STATUS_LIST_ENTRY(h_radar_device)
  };

  app_initalized = 0;
  uint8_t num_of_ep = sizeof(ep_err_list)/sizeof(ep_err_list[0]);
  Endpoint_t *pEndPoints = &ep_err_list[0];
 802a1d6:	a903      	add	r1, sp, #12
    EP_RADAR_MCUBASE_LIST_ENTRY(h_radar_device),
  	EP_RADAR_DEVICE_STATUS_LIST_ENTRY(h_radar_device)
  };

  app_initalized = 0;
  uint8_t num_of_ep = sizeof(ep_err_list)/sizeof(ep_err_list[0]);
 802a1d8:	2402      	movs	r4, #2
	  radar_register_callback(RADAR_ACQUISITION_DONE_CB_ID, app_data_acq_done_cb);

	  num_of_ep = sizeof(ep_list)/sizeof(ep_list[0]);
	  pEndPoints = &ep_list[0];
  }
  memcpy(endpoint_list, pEndPoints, num_of_ep * sizeof(Endpoint_t));
 802a1da:	4817      	ldr	r0, [pc, #92]	; (802a238 <app_init+0xfc>)
 802a1dc:	f003 f9b0 	bl	802d540 <memcpy>

  /* Initialize the internal protocol state and the communication interface */
  protocol_init(endpoint_list, num_of_ep, NULL, BSP_HOST_TIMEOUT_USEC, system_reset);
 802a1e0:	4b16      	ldr	r3, [pc, #88]	; (802a23c <app_init+0x100>)
 802a1e2:	9300      	str	r3, [sp, #0]
 802a1e4:	4621      	mov	r1, r4
 802a1e6:	4b16      	ldr	r3, [pc, #88]	; (802a240 <app_init+0x104>)
 802a1e8:	4813      	ldr	r0, [pc, #76]	; (802a238 <app_init+0xfc>)
 802a1ea:	2200      	movs	r2, #0
 802a1ec:	f7fa f910 	bl	8024410 <protocol_init>

  /* Initialize the internal protocol state and the communication interface */
  if (app_initalized)
 802a1f0:	6833      	ldr	r3, [r6, #0]
 802a1f2:	b913      	cbnz	r3, 802a1fa <app_init+0xbe>
	  {
		XMC_DEBUG("Starting Radar data acquisition failed\n");
		while (1U);
	  }
  }
}
 802a1f4:	b01d      	add	sp, #116	; 0x74
 802a1f6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

  /* Initialize the internal protocol state and the communication interface */
  if (app_initalized)
  {
	  /* Start data acquisition at the defined frame interval */
	  if (radar_start_acquisition(h_radar_device) != RADAR_ERR_OK)
 802a1fa:	6828      	ldr	r0, [r5, #0]
 802a1fc:	f7f6 fc8e 	bl	8020b1c <radar_start_acquisition>
 802a200:	2800      	cmp	r0, #0
 802a202:	d0f7      	beq.n	802a1f4 <app_init+0xb8>
	  {
		XMC_DEBUG("Starting Radar data acquisition failed\n");
		while (1U);
 802a204:	e7fe      	b.n	802a204 <app_init+0xc8>
  /* Open the available radar device */
  if (radar_open_device(0, &h_radar_device) == RADAR_ERR_OK)
  {
	  app_initalized = 1;
	  /* Register user callback functions */
	  radar_register_callback(RADAR_ACQUISITION_STARTED_CB_ID, app_data_acq_started_cb);
 802a206:	4620      	mov	r0, r4
 802a208:	490e      	ldr	r1, [pc, #56]	; (802a244 <app_init+0x108>)
  Endpoint_t *pEndPoints = &ep_err_list[0];

  /* Open the available radar device */
  if (radar_open_device(0, &h_radar_device) == RADAR_ERR_OK)
  {
	  app_initalized = 1;
 802a20a:	6034      	str	r4, [r6, #0]
	  /* Register user callback functions */
	  radar_register_callback(RADAR_ACQUISITION_STARTED_CB_ID, app_data_acq_started_cb);
 802a20c:	f7f6 fc96 	bl	8020b3c <radar_register_callback>
	  radar_register_callback(RADAR_ACQUISITION_DONE_CB_ID, app_data_acq_done_cb);
 802a210:	490d      	ldr	r1, [pc, #52]	; (802a248 <app_init+0x10c>)
 802a212:	2002      	movs	r0, #2
 802a214:	f7f6 fc92 	bl	8020b3c <radar_register_callback>

	  num_of_ep = sizeof(ep_list)/sizeof(ep_list[0]);
 802a218:	2403      	movs	r4, #3
  if (radar_open_device(0, &h_radar_device) == RADAR_ERR_OK)
  {
	  app_initalized = 1;
	  /* Register user callback functions */
	  radar_register_callback(RADAR_ACQUISITION_STARTED_CB_ID, app_data_acq_started_cb);
	  radar_register_callback(RADAR_ACQUISITION_DONE_CB_ID, app_data_acq_done_cb);
 802a21a:	223c      	movs	r2, #60	; 0x3c

	  num_of_ep = sizeof(ep_list)/sizeof(ep_list[0]);
	  pEndPoints = &ep_list[0];
 802a21c:	a90d      	add	r1, sp, #52	; 0x34
 802a21e:	e7dc      	b.n	802a1da <app_init+0x9e>
 802a220:	1ffedbfc 	.word	0x1ffedbfc
 802a224:	1ffedc34 	.word	0x1ffedc34
 802a228:	1ffedc3c 	.word	0x1ffedc3c
 802a22c:	44455653 	.word	0x44455653
 802a230:	08023a11 	.word	0x08023a11
 802a234:	08023a35 	.word	0x08023a35
 802a238:	1fff06d8 	.word	0x1fff06d8
 802a23c:	0802a129 	.word	0x0802a129
 802a240:	00989680 	.word	0x00989680
 802a244:	0802a119 	.word	0x0802a119
 802a248:	0802a12d 	.word	0x0802a12d
 802a24c:	544a4241 	.word	0x544a4241
 802a250:	08023b01 	.word	0x08023b01
 802a254:	08023c85 	.word	0x08023c85
 802a258:	544a5055 	.word	0x544a5055
 802a25c:	08023f81 	.word	0x08023f81
 802a260:	080243a1 	.word	0x080243a1

0802a264 <app_register_algo_process>:

/* Register algorithm processing function */
void app_register_algo_process(algorithm algo_processor)
{
  /* Register algo processing function */
  algo_processing_function = algo_processor;
 802a264:	4b01      	ldr	r3, [pc, #4]	; (802a26c <app_register_algo_process+0x8>)
 802a266:	6018      	str	r0, [r3, #0]
 802a268:	4770      	bx	lr
 802a26a:	bf00      	nop
 802a26c:	1ffedc30 	.word	0x1ffedc30

0802a270 <calcCurrentConsumption_mA>:
float calcCurrentConsumption_mA(device_settings_t *pDev)
{
	float retval = 0.0F;
	extern bool pwm_bgt_enabled;

	if (!pwm_bgt_enabled)
 802a270:	4b5b      	ldr	r3, [pc, #364]	; (802a3e0 <calcCurrentConsumption_mA+0x170>)
 802a272:	781b      	ldrb	r3, [r3, #0]
 802a274:	b923      	cbnz	r3, 802a280 <calcCurrentConsumption_mA+0x10>
		return 0.0F; /* invalid! */
 802a276:	eddf 7a5b 	vldr	s15, [pc, #364]	; 802a3e4 <calcCurrentConsumption_mA+0x174>

		retval = (bgt_duty_cycle * bgt_on_current_mA) + (ptat_duty_cycle * ptat_on_current_mA) + (bbf_duty_cycle * bbf_on_current_mA);
	}

	return retval;
}
 802a27a:	ee17 0a90 	vmov	r0, s15
 802a27e:	4770      	bx	lr
}

//============================================================================

float calcCurrentConsumption_mA(device_settings_t *pDev)
{
 802a280:	b510      	push	{r4, lr}
 802a282:	4604      	mov	r4, r0
	extern bool pwm_bgt_enabled;

	if (!pwm_bgt_enabled)
		return 0.0F; /* invalid! */

	if (ds_get_board_variant() == 1)
 802a284:	f7f5 febc 	bl	8020000 <ds_get_board_variant>
 802a288:	2801      	cmp	r0, #1
 802a28a:	d063      	beq.n	802a354 <calcCurrentConsumption_mA+0xe4>
	{
		float bgt_on_current_mA   = BSP_BGT_ON_CURRENT_mA;
		float ptat_on_current_mA  = BSP_PTAT_ON_CURRENT_mA;
		float bbf_on_current_mA   = BSP_BBF_ON_CURRENT_mA;

		float f_sample            = (float)pDev->adc_sampling_freq_Hz;
 802a28c:	edd4 3a05 	vldr	s7, [r4, #20]
		float frame_period_sec    = (float)pDev->frame_period_usec / 1000000.0F;
		float pulse_width_sec     = (float)pDev->pulse_width_usec / 1000000.0F;
		float skipped_samples     = (float)pDev->num_sample_skip_count;
		float samples             = (float)pDev->num_samples_per_chirp;
 802a290:	edd4 6a09 	vldr	s13, [r4, #36]	; 0x24
		float bgt_on_current_mA   = BSP_BGT_ON_CURRENT_mA;
		float ptat_on_current_mA  = BSP_PTAT_ON_CURRENT_mA;
		float bbf_on_current_mA   = BSP_BBF_ON_CURRENT_mA;

		float f_sample            = (float)pDev->adc_sampling_freq_Hz;
		float frame_period_sec    = (float)pDev->frame_period_usec / 1000000.0F;
 802a294:	ed94 7a08 	vldr	s14, [r4, #32]
 802a298:	ed9f 3a53 	vldr	s6, [pc, #332]	; 802a3e8 <calcCurrentConsumption_mA+0x178>
		float ptat_pulse_time_sec = (float)PTAT_S_H_PULSE_WIDTH_USEC / 1000000.0F;
		float bbf_advance_sec     = (float)BB_PRE_TRIGGER_ADVANCE_USEC / 1000000.0F;

		float total_samples       = (skipped_samples + samples);

		if (fabs(samples / f_sample - frame_period_sec) < 0.001F) // equidistant mode
 802a29c:	eddf 7a53 	vldr	s15, [pc, #332]	; 802a3ec <calcCurrentConsumption_mA+0x17c>
		float f_sample            = (float)pDev->adc_sampling_freq_Hz;
		float frame_period_sec    = (float)pDev->frame_period_usec / 1000000.0F;
		float pulse_width_sec     = (float)pDev->pulse_width_usec / 1000000.0F;
		float skipped_samples     = (float)pDev->num_sample_skip_count;
		float samples             = (float)pDev->num_samples_per_chirp;
		float ptat_delay_sec      = (float)pDev->ptat_delay_usec / 1000000.0F;
 802a2a0:	6be3      	ldr	r3, [r4, #60]	; 0x3c
		float bbf_on_current_mA   = BSP_BBF_ON_CURRENT_mA;

		float f_sample            = (float)pDev->adc_sampling_freq_Hz;
		float frame_period_sec    = (float)pDev->frame_period_usec / 1000000.0F;
		float pulse_width_sec     = (float)pDev->pulse_width_usec / 1000000.0F;
		float skipped_samples     = (float)pDev->num_sample_skip_count;
 802a2a2:	edd4 5a0b 	vldr	s11, [r4, #44]	; 0x2c
		float ptat_on_current_mA  = BSP_PTAT_ON_CURRENT_mA;
		float bbf_on_current_mA   = BSP_BBF_ON_CURRENT_mA;

		float f_sample            = (float)pDev->adc_sampling_freq_Hz;
		float frame_period_sec    = (float)pDev->frame_period_usec / 1000000.0F;
		float pulse_width_sec     = (float)pDev->pulse_width_usec / 1000000.0F;
 802a2a6:	edd4 4a0c 	vldr	s9, [r4, #48]	; 0x30

		if (fabs(samples / f_sample - frame_period_sec) < 0.001F) // equidistant mode
			ptat_delay_sec = 0.0F;

		float bgt_on_time_sec     = total_samples * pulse_width_sec;
		float ptat_on_time_sec    = total_samples * ptat_pulse_time_sec + ptat_delay_sec;
 802a2aa:	ed9f 2a51 	vldr	s4, [pc, #324]	; 802a3f0 <calcCurrentConsumption_mA+0x180>

		float DMA_TRANSFER_SEC    = 2.0F / 1000.0F;
		float bbf_on_time_sec     = bbf_advance_sec + (samples - 1) / f_sample + DMA_TRANSFER_SEC; // baseband filter is now switched
 802a2ae:	eddf 2a51 	vldr	s5, [pc, #324]	; 802a3f4 <calcCurrentConsumption_mA+0x184>

		float f_sample            = (float)pDev->adc_sampling_freq_Hz;
		float frame_period_sec    = (float)pDev->frame_period_usec / 1000000.0F;
		float pulse_width_sec     = (float)pDev->pulse_width_usec / 1000000.0F;
		float skipped_samples     = (float)pDev->num_sample_skip_count;
		float samples             = (float)pDev->num_samples_per_chirp;
 802a2b2:	eef8 6a66 	vcvt.f32.u32	s13, s13
	{
		float bgt_on_current_mA   = BSP_BGT_ON_CURRENT_mA;
		float ptat_on_current_mA  = BSP_PTAT_ON_CURRENT_mA;
		float bbf_on_current_mA   = BSP_BBF_ON_CURRENT_mA;

		float f_sample            = (float)pDev->adc_sampling_freq_Hz;
 802a2b6:	eef8 3a63 	vcvt.f32.u32	s7, s7
		float frame_period_sec    = (float)pDev->frame_period_usec / 1000000.0F;
 802a2ba:	eeb8 7a47 	vcvt.f32.u32	s14, s14
		float ptat_pulse_time_sec = (float)PTAT_S_H_PULSE_WIDTH_USEC / 1000000.0F;
		float bbf_advance_sec     = (float)BB_PRE_TRIGGER_ADVANCE_USEC / 1000000.0F;

		float total_samples       = (skipped_samples + samples);

		if (fabs(samples / f_sample - frame_period_sec) < 0.001F) // equidistant mode
 802a2be:	ee86 4aa3 	vdiv.f32	s8, s13, s7
		float bgt_on_current_mA   = BSP_BGT_ON_CURRENT_mA;
		float ptat_on_current_mA  = BSP_PTAT_ON_CURRENT_mA;
		float bbf_on_current_mA   = BSP_BBF_ON_CURRENT_mA;

		float f_sample            = (float)pDev->adc_sampling_freq_Hz;
		float frame_period_sec    = (float)pDev->frame_period_usec / 1000000.0F;
 802a2c2:	ee87 5a03 	vdiv.f32	s10, s14, s6
		float pulse_width_sec     = (float)pDev->pulse_width_usec / 1000000.0F;
		float skipped_samples     = (float)pDev->num_sample_skip_count;
 802a2c6:	eeb8 6a65 	vcvt.f32.u32	s12, s11
		float ptat_pulse_time_sec = (float)PTAT_S_H_PULSE_WIDTH_USEC / 1000000.0F;
		float bbf_advance_sec     = (float)BB_PRE_TRIGGER_ADVANCE_USEC / 1000000.0F;

		float total_samples       = (skipped_samples + samples);

		if (fabs(samples / f_sample - frame_period_sec) < 0.001F) // equidistant mode
 802a2ca:	ee34 4a45 	vsub.f32	s8, s8, s10
		float samples             = (float)pDev->num_samples_per_chirp;
		float ptat_delay_sec      = (float)pDev->ptat_delay_usec / 1000000.0F;
		float ptat_pulse_time_sec = (float)PTAT_S_H_PULSE_WIDTH_USEC / 1000000.0F;
		float bbf_advance_sec     = (float)BB_PRE_TRIGGER_ADVANCE_USEC / 1000000.0F;

		float total_samples       = (skipped_samples + samples);
 802a2ce:	ee76 5a26 	vadd.f32	s11, s12, s13

		if (fabs(samples / f_sample - frame_period_sec) < 0.001F) // equidistant mode
 802a2d2:	eeb0 4ac4 	vabs.f32	s8, s8
 802a2d6:	eeb4 4ae7 	vcmpe.f32	s8, s15
 802a2da:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
		float f_sample            = (float)pDev->adc_sampling_freq_Hz;
		float frame_period_sec    = (float)pDev->frame_period_usec / 1000000.0F;
		float pulse_width_sec     = (float)pDev->pulse_width_usec / 1000000.0F;
		float skipped_samples     = (float)pDev->num_sample_skip_count;
		float samples             = (float)pDev->num_samples_per_chirp;
		float ptat_delay_sec      = (float)pDev->ptat_delay_usec / 1000000.0F;
 802a2de:	bf5c      	itt	pl
 802a2e0:	ee07 3a90 	vmovpl	s15, r3
 802a2e4:	eef8 7a67 	vcvtpl.f32.u32	s15, s15

		float bgt_on_time_sec     = total_samples * pulse_width_sec;
		float ptat_on_time_sec    = total_samples * ptat_pulse_time_sec + ptat_delay_sec;

		float DMA_TRANSFER_SEC    = 2.0F / 1000.0F;
		float bbf_on_time_sec     = bbf_advance_sec + (samples - 1) / f_sample + DMA_TRANSFER_SEC; // baseband filter is now switched
 802a2e8:	eeb7 6a00 	vmov.f32	s12, #112	; 0x70
		float f_sample            = (float)pDev->adc_sampling_freq_Hz;
		float frame_period_sec    = (float)pDev->frame_period_usec / 1000000.0F;
		float pulse_width_sec     = (float)pDev->pulse_width_usec / 1000000.0F;
		float skipped_samples     = (float)pDev->num_sample_skip_count;
		float samples             = (float)pDev->num_samples_per_chirp;
		float ptat_delay_sec      = (float)pDev->ptat_delay_usec / 1000000.0F;
 802a2ec:	bf58      	it	pl
 802a2ee:	eec7 7a83 	vdivpl.f32	s15, s15, s6

		float bgt_on_time_sec     = total_samples * pulse_width_sec;
		float ptat_on_time_sec    = total_samples * ptat_pulse_time_sec + ptat_delay_sec;

		float DMA_TRANSFER_SEC    = 2.0F / 1000.0F;
		float bbf_on_time_sec     = bbf_advance_sec + (samples - 1) / f_sample + DMA_TRANSFER_SEC; // baseband filter is now switched
 802a2f2:	ee36 6ac6 	vsub.f32	s12, s13, s12
		float ptat_on_current_mA  = BSP_PTAT_ON_CURRENT_mA;
		float bbf_on_current_mA   = BSP_BBF_ON_CURRENT_mA;

		float f_sample            = (float)pDev->adc_sampling_freq_Hz;
		float frame_period_sec    = (float)pDev->frame_period_usec / 1000000.0F;
		float pulse_width_sec     = (float)pDev->pulse_width_usec / 1000000.0F;
 802a2f6:	eef8 4a64 	vcvt.f32.u32	s9, s9

		float bgt_on_time_sec     = total_samples * pulse_width_sec;
		float ptat_on_time_sec    = total_samples * ptat_pulse_time_sec + ptat_delay_sec;

		float DMA_TRANSFER_SEC    = 2.0F / 1000.0F;
		float bbf_on_time_sec     = bbf_advance_sec + (samples - 1) / f_sample + DMA_TRANSFER_SEC; // baseband filter is now switched
 802a2fa:	eec6 6a23 	vdiv.f32	s13, s12, s7
		float ptat_on_current_mA  = BSP_PTAT_ON_CURRENT_mA;
		float bbf_on_current_mA   = BSP_BBF_ON_CURRENT_mA;

		float f_sample            = (float)pDev->adc_sampling_freq_Hz;
		float frame_period_sec    = (float)pDev->frame_period_usec / 1000000.0F;
		float pulse_width_sec     = (float)pDev->pulse_width_usec / 1000000.0F;
 802a2fe:	eec4 4a83 	vdiv.f32	s9, s9, s6
		float bbf_advance_sec     = (float)BB_PRE_TRIGGER_ADVANCE_USEC / 1000000.0F;

		float total_samples       = (skipped_samples + samples);

		if (fabs(samples / f_sample - frame_period_sec) < 0.001F) // equidistant mode
			ptat_delay_sec = 0.0F;
 802a302:	bf48      	it	mi
 802a304:	eddf 7a37 	vldrmi	s15, [pc, #220]	; 802a3e4 <calcCurrentConsumption_mA+0x174>

		float bgt_on_time_sec     = total_samples * pulse_width_sec;
		float ptat_on_time_sec    = total_samples * ptat_pulse_time_sec + ptat_delay_sec;

		float DMA_TRANSFER_SEC    = 2.0F / 1000.0F;
		float bbf_on_time_sec     = bbf_advance_sec + (samples - 1) / f_sample + DMA_TRANSFER_SEC; // baseband filter is now switched
 802a308:	ed9f 7a3b 	vldr	s14, [pc, #236]	; 802a3f8 <calcCurrentConsumption_mA+0x188>

		float bgt_duty_cycle  = bgt_on_time_sec / frame_period_sec;
		float ptat_duty_cycle = ptat_on_time_sec / frame_period_sec;
		float bbf_duty_cycle  = bbf_on_time_sec / frame_period_sec;

		retval = (bgt_duty_cycle * bgt_on_current_mA) + (ptat_duty_cycle * ptat_on_current_mA) + (bbf_duty_cycle * bbf_on_current_mA);
 802a30c:	ed9f 3a3b 	vldr	s6, [pc, #236]	; 802a3fc <calcCurrentConsumption_mA+0x18c>
 802a310:	ed9f 4a3b 	vldr	s8, [pc, #236]	; 802a400 <calcCurrentConsumption_mA+0x190>

		if (fabs(samples / f_sample - frame_period_sec) < 0.001F) // equidistant mode
			ptat_delay_sec = 0.0F;

		float bgt_on_time_sec     = total_samples * pulse_width_sec;
		float ptat_on_time_sec    = total_samples * ptat_pulse_time_sec + ptat_delay_sec;
 802a314:	eee5 7a82 	vfma.f32	s15, s11, s4

		float DMA_TRANSFER_SEC    = 2.0F / 1000.0F;
		float bbf_on_time_sec     = bbf_advance_sec + (samples - 1) / f_sample + DMA_TRANSFER_SEC; // baseband filter is now switched
 802a318:	ee76 6a87 	vadd.f32	s13, s13, s14
		float total_samples       = (skipped_samples + samples);

		if (fabs(samples / f_sample - frame_period_sec) < 0.001F) // equidistant mode
			ptat_delay_sec = 0.0F;

		float bgt_on_time_sec     = total_samples * pulse_width_sec;
 802a31c:	ee65 5aa4 	vmul.f32	s11, s11, s9
		float bbf_on_time_sec     = bbf_advance_sec + (samples - 1) / f_sample + DMA_TRANSFER_SEC; // baseband filter is now switched
		if (bbf_on_time_sec > frame_period_sec)
			bbf_on_time_sec = frame_period_sec;

		float bgt_duty_cycle  = bgt_on_time_sec / frame_period_sec;
		float ptat_duty_cycle = ptat_on_time_sec / frame_period_sec;
 802a320:	eec7 7a85 	vdiv.f32	s15, s15, s10

		float bgt_on_time_sec     = total_samples * pulse_width_sec;
		float ptat_on_time_sec    = total_samples * ptat_pulse_time_sec + ptat_delay_sec;

		float DMA_TRANSFER_SEC    = 2.0F / 1000.0F;
		float bbf_on_time_sec     = bbf_advance_sec + (samples - 1) / f_sample + DMA_TRANSFER_SEC; // baseband filter is now switched
 802a324:	ee36 7aa2 	vadd.f32	s14, s13, s5
		if (bbf_on_time_sec > frame_period_sec)
			bbf_on_time_sec = frame_period_sec;

		float bgt_duty_cycle  = bgt_on_time_sec / frame_period_sec;
 802a328:	eec5 5a85 	vdiv.f32	s11, s11, s10
		float ptat_on_time_sec    = total_samples * ptat_pulse_time_sec + ptat_delay_sec;

		float DMA_TRANSFER_SEC    = 2.0F / 1000.0F;
		float bbf_on_time_sec     = bbf_advance_sec + (samples - 1) / f_sample + DMA_TRANSFER_SEC; // baseband filter is now switched
		if (bbf_on_time_sec > frame_period_sec)
			bbf_on_time_sec = frame_period_sec;
 802a32c:	eeb4 5a47 	vcmp.f32	s10, s14
 802a330:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802a334:	bf48      	it	mi
 802a336:	eeb0 7a45 	vmovmi.f32	s14, s10

		float bgt_duty_cycle  = bgt_on_time_sec / frame_period_sec;
		float ptat_duty_cycle = ptat_on_time_sec / frame_period_sec;
		float bbf_duty_cycle  = bbf_on_time_sec / frame_period_sec;
 802a33a:	ee87 7a05 	vdiv.f32	s14, s14, s10

		retval = (bgt_duty_cycle * bgt_on_current_mA) + (ptat_duty_cycle * ptat_on_current_mA) + (bbf_duty_cycle * bbf_on_current_mA);
 802a33e:	eef7 6a08 	vmov.f32	s13, #120	; 0x78
 802a342:	ee67 7aa6 	vmul.f32	s15, s15, s13
 802a346:	eee5 7a83 	vfma.f32	s15, s11, s6
 802a34a:	eee7 7a04 	vfma.f32	s15, s14, s8
	}

	return retval;
}
 802a34e:	ee17 0a90 	vmov	r0, s15
 802a352:	bd10      	pop	{r4, pc}
		float bbf_on_current_mA   = BSP_BBF_ON_CURRENT_mA;

		float f_sample            = (float)pDev->adc_sampling_freq_Hz;
		float frame_period_sec    = (float)pDev->frame_period_usec / 1000000.0F;
		float pulse_width_sec     = (float)pDev->pulse_width_usec / 1000000.0F;
		float skipped_samples     = (float)pDev->num_sample_skip_count;
 802a354:	edd4 5a0b 	vldr	s11, [r4, #44]	; 0x2c
		float samples             = (float)pDev->num_samples_per_chirp;
 802a358:	ed94 6a09 	vldr	s12, [r4, #36]	; 0x24
		float ptat_on_current_mA  = BSP_PTAT_ON_CURRENT_mA;
		float bbf_on_current_mA   = BSP_BBF_ON_CURRENT_mA;

		float f_sample            = (float)pDev->adc_sampling_freq_Hz;
		float frame_period_sec    = (float)pDev->frame_period_usec / 1000000.0F;
		float pulse_width_sec     = (float)pDev->pulse_width_usec / 1000000.0F;
 802a35c:	6b22      	ldr	r2, [r4, #48]	; 0x30
	{
		float bgt_on_current_mA   = BSP_BGT_ON_CURRENT_mA;
		float ptat_on_current_mA  = BSP_PTAT_ON_CURRENT_mA;
		float bbf_on_current_mA   = BSP_BBF_ON_CURRENT_mA;

		float f_sample            = (float)pDev->adc_sampling_freq_Hz;
 802a35e:	edd4 7a05 	vldr	s15, [r4, #20]
		float frame_period_sec    = (float)pDev->frame_period_usec / 1000000.0F;
 802a362:	eddf 4a21 	vldr	s9, [pc, #132]	; 802a3e8 <calcCurrentConsumption_mA+0x178>
		float pulse_width_sec     = (float)pDev->pulse_width_usec / 1000000.0F;
		float skipped_samples     = (float)pDev->num_sample_skip_count;
		float samples             = (float)pDev->num_samples_per_chirp;
		float ptat_delay_sec      = (float)pDev->ptat_delay_usec / 1000000.0F;
 802a366:	ed94 5a0f 	vldr	s10, [r4, #60]	; 0x3c
		float bgt_on_current_mA   = BSP_BGT_ON_CURRENT_mA;
		float ptat_on_current_mA  = BSP_PTAT_ON_CURRENT_mA;
		float bbf_on_current_mA   = BSP_BBF_ON_CURRENT_mA;

		float f_sample            = (float)pDev->adc_sampling_freq_Hz;
		float frame_period_sec    = (float)pDev->frame_period_usec / 1000000.0F;
 802a36a:	6a23      	ldr	r3, [r4, #32]

		float bgt_duty_cycle      = bgt_on_time_sec / frame_period_sec;
		float ptat_duty_cycle     = ptat_on_time_sec / frame_period_sec;
		float bbf_duty_cycle      = bbf_on_time_sec / frame_period_sec;

		retval = (bgt_duty_cycle * bgt_on_current_mA) + (ptat_duty_cycle * ptat_on_current_mA) + (bbf_duty_cycle * bbf_on_current_mA);
 802a36c:	eddf 3a23 	vldr	s7, [pc, #140]	; 802a3fc <calcCurrentConsumption_mA+0x18c>
 802a370:	ed9f 4a23 	vldr	s8, [pc, #140]	; 802a400 <calcCurrentConsumption_mA+0x190>
		float bbf_on_current_mA   = BSP_BBF_ON_CURRENT_mA;

		float f_sample            = (float)pDev->adc_sampling_freq_Hz;
		float frame_period_sec    = (float)pDev->frame_period_usec / 1000000.0F;
		float pulse_width_sec     = (float)pDev->pulse_width_usec / 1000000.0F;
		float skipped_samples     = (float)pDev->num_sample_skip_count;
 802a374:	eef8 5a65 	vcvt.f32.u32	s11, s11
		float samples             = (float)pDev->num_samples_per_chirp;
 802a378:	eeb8 6a46 	vcvt.f32.u32	s12, s12
		float ptat_delay_sec      = (float)pDev->ptat_delay_usec / 1000000.0F;

		float total_samples       = (skipped_samples + samples);

		float frame_on_time_sec   = (total_samples - 1) / f_sample + pulse_width_sec;
 802a37c:	eef7 6a00 	vmov.f32	s13, #112	; 0x70
		float pulse_width_sec     = (float)pDev->pulse_width_usec / 1000000.0F;
		float skipped_samples     = (float)pDev->num_sample_skip_count;
		float samples             = (float)pDev->num_samples_per_chirp;
		float ptat_delay_sec      = (float)pDev->ptat_delay_usec / 1000000.0F;

		float total_samples       = (skipped_samples + samples);
 802a380:	ee35 6a86 	vadd.f32	s12, s11, s12
	{
		float bgt_on_current_mA   = BSP_BGT_ON_CURRENT_mA;
		float ptat_on_current_mA  = BSP_PTAT_ON_CURRENT_mA;
		float bbf_on_current_mA   = BSP_BBF_ON_CURRENT_mA;

		float f_sample            = (float)pDev->adc_sampling_freq_Hz;
 802a384:	eef8 7a67 	vcvt.f32.u32	s15, s15
		float samples             = (float)pDev->num_samples_per_chirp;
		float ptat_delay_sec      = (float)pDev->ptat_delay_usec / 1000000.0F;

		float total_samples       = (skipped_samples + samples);

		float frame_on_time_sec   = (total_samples - 1) / f_sample + pulse_width_sec;
 802a388:	ee36 7a66 	vsub.f32	s14, s12, s13
		float ptat_on_current_mA  = BSP_PTAT_ON_CURRENT_mA;
		float bbf_on_current_mA   = BSP_BBF_ON_CURRENT_mA;

		float f_sample            = (float)pDev->adc_sampling_freq_Hz;
		float frame_period_sec    = (float)pDev->frame_period_usec / 1000000.0F;
		float pulse_width_sec     = (float)pDev->pulse_width_usec / 1000000.0F;
 802a38c:	ee06 2a90 	vmov	s13, r2
 802a390:	eef8 5a66 	vcvt.f32.u32	s11, s13
		float samples             = (float)pDev->num_samples_per_chirp;
		float ptat_delay_sec      = (float)pDev->ptat_delay_usec / 1000000.0F;

		float total_samples       = (skipped_samples + samples);

		float frame_on_time_sec   = (total_samples - 1) / f_sample + pulse_width_sec;
 802a394:	ee87 7a27 	vdiv.f32	s14, s14, s15
		float ptat_on_current_mA  = BSP_PTAT_ON_CURRENT_mA;
		float bbf_on_current_mA   = BSP_BBF_ON_CURRENT_mA;

		float f_sample            = (float)pDev->adc_sampling_freq_Hz;
		float frame_period_sec    = (float)pDev->frame_period_usec / 1000000.0F;
		float pulse_width_sec     = (float)pDev->pulse_width_usec / 1000000.0F;
 802a398:	eec5 5aa4 	vdiv.f32	s11, s11, s9
		float skipped_samples     = (float)pDev->num_sample_skip_count;
		float samples             = (float)pDev->num_samples_per_chirp;
		float ptat_delay_sec      = (float)pDev->ptat_delay_usec / 1000000.0F;
 802a39c:	eef8 7a45 	vcvt.f32.u32	s15, s10
		float bgt_on_current_mA   = BSP_BGT_ON_CURRENT_mA;
		float ptat_on_current_mA  = BSP_PTAT_ON_CURRENT_mA;
		float bbf_on_current_mA   = BSP_BBF_ON_CURRENT_mA;

		float f_sample            = (float)pDev->adc_sampling_freq_Hz;
		float frame_period_sec    = (float)pDev->frame_period_usec / 1000000.0F;
 802a3a0:	ee06 3a90 	vmov	s13, r3
		float pulse_width_sec     = (float)pDev->pulse_width_usec / 1000000.0F;
		float skipped_samples     = (float)pDev->num_sample_skip_count;
		float samples             = (float)pDev->num_samples_per_chirp;
		float ptat_delay_sec      = (float)pDev->ptat_delay_usec / 1000000.0F;
 802a3a4:	ee87 5aa4 	vdiv.f32	s10, s15, s9
		float bgt_on_current_mA   = BSP_BGT_ON_CURRENT_mA;
		float ptat_on_current_mA  = BSP_PTAT_ON_CURRENT_mA;
		float bbf_on_current_mA   = BSP_BBF_ON_CURRENT_mA;

		float f_sample            = (float)pDev->adc_sampling_freq_Hz;
		float frame_period_sec    = (float)pDev->frame_period_usec / 1000000.0F;
 802a3a8:	eef8 6a66 	vcvt.f32.u32	s13, s13
		float samples             = (float)pDev->num_samples_per_chirp;
		float ptat_delay_sec      = (float)pDev->ptat_delay_usec / 1000000.0F;

		float total_samples       = (skipped_samples + samples);

		float frame_on_time_sec   = (total_samples - 1) / f_sample + pulse_width_sec;
 802a3ac:	ee77 7a25 	vadd.f32	s15, s14, s11
		float bgt_on_current_mA   = BSP_BGT_ON_CURRENT_mA;
		float ptat_on_current_mA  = BSP_PTAT_ON_CURRENT_mA;
		float bbf_on_current_mA   = BSP_BBF_ON_CURRENT_mA;

		float f_sample            = (float)pDev->adc_sampling_freq_Hz;
		float frame_period_sec    = (float)pDev->frame_period_usec / 1000000.0F;
 802a3b0:	eec6 6aa4 	vdiv.f32	s13, s13, s9

		float total_samples       = (skipped_samples + samples);

		float frame_on_time_sec   = (total_samples - 1) / f_sample + pulse_width_sec;
		float bgt_on_time_sec     = total_samples * pulse_width_sec;
		float ptat_on_time_sec    = frame_on_time_sec + ptat_delay_sec;
 802a3b4:	ee77 7a85 	vadd.f32	s15, s15, s10
		float ptat_delay_sec      = (float)pDev->ptat_delay_usec / 1000000.0F;

		float total_samples       = (skipped_samples + samples);

		float frame_on_time_sec   = (total_samples - 1) / f_sample + pulse_width_sec;
		float bgt_on_time_sec     = total_samples * pulse_width_sec;
 802a3b8:	ee26 6a25 	vmul.f32	s12, s12, s11
		float ptat_on_time_sec    = frame_on_time_sec + ptat_delay_sec;
		float bbf_on_time_sec     = frame_period_sec; // baseband filter is not switched, but always on!

		float bgt_duty_cycle      = bgt_on_time_sec / frame_period_sec;
		float ptat_duty_cycle     = ptat_on_time_sec / frame_period_sec;
 802a3bc:	eec7 7aa6 	vdiv.f32	s15, s15, s13
		float frame_on_time_sec   = (total_samples - 1) / f_sample + pulse_width_sec;
		float bgt_on_time_sec     = total_samples * pulse_width_sec;
		float ptat_on_time_sec    = frame_on_time_sec + ptat_delay_sec;
		float bbf_on_time_sec     = frame_period_sec; // baseband filter is not switched, but always on!

		float bgt_duty_cycle      = bgt_on_time_sec / frame_period_sec;
 802a3c0:	ee86 6a26 	vdiv.f32	s12, s12, s13
		float ptat_duty_cycle     = ptat_on_time_sec / frame_period_sec;
		float bbf_duty_cycle      = bbf_on_time_sec / frame_period_sec;
 802a3c4:	eec6 6aa6 	vdiv.f32	s13, s13, s13

		retval = (bgt_duty_cycle * bgt_on_current_mA) + (ptat_duty_cycle * ptat_on_current_mA) + (bbf_duty_cycle * bbf_on_current_mA);
 802a3c8:	eeb7 7a08 	vmov.f32	s14, #120	; 0x78
 802a3cc:	ee67 7a87 	vmul.f32	s15, s15, s14
 802a3d0:	eee6 7a23 	vfma.f32	s15, s12, s7
 802a3d4:	eee6 7a84 	vfma.f32	s15, s13, s8

		retval = (bgt_duty_cycle * bgt_on_current_mA) + (ptat_duty_cycle * ptat_on_current_mA) + (bbf_duty_cycle * bbf_on_current_mA);
	}

	return retval;
}
 802a3d8:	ee17 0a90 	vmov	r0, s15
 802a3dc:	bd10      	pop	{r4, pc}
 802a3de:	bf00      	nop
 802a3e0:	1ffe9610 	.word	0x1ffe9610
 802a3e4:	00000000 	.word	0x00000000
 802a3e8:	49742400 	.word	0x49742400
 802a3ec:	3a83126f 	.word	0x3a83126f
 802a3f0:	37a7c5ac 	.word	0x37a7c5ac
 802a3f4:	3b03126f 	.word	0x3b03126f
 802a3f8:	3ca3d70a 	.word	0x3ca3d70a
 802a3fc:	42340000 	.word	0x42340000
 802a400:	3eab851f 	.word	0x3eab851f

0802a404 <CCU43_3_IRQHandler>:
}

//============================================================================

void IRQ_ERROR_TOGGLE_Handler(void)
{
 802a404:	b508      	push	{r3, lr}
	bsp_led_red_toggle();
 802a406:	f7fe fcbd 	bl	8028d84 <bsp_led_red_toggle>
	bsp_timer_start(&TIMER_ERROR_TOGGLE);
 802a40a:	4802      	ldr	r0, [pc, #8]	; (802a414 <CCU43_3_IRQHandler+0x10>)
}
 802a40c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
//============================================================================

void IRQ_ERROR_TOGGLE_Handler(void)
{
	bsp_led_red_toggle();
	bsp_timer_start(&TIMER_ERROR_TOGGLE);
 802a410:	f7ff ba1c 	b.w	802984c <bsp_timer_start>
 802a414:	1ffe91e8 	.word	0x1ffe91e8

0802a418 <app_reset_protocol>:
static uint32_t app_connected = 0;
static uint32_t delayCount = 0;

void app_reset_protocol(void)
{
	delayCount = 0;
 802a418:	4902      	ldr	r1, [pc, #8]	; (802a424 <app_reset_protocol+0xc>)
	app_connected = 0;
 802a41a:	4a03      	ldr	r2, [pc, #12]	; (802a428 <app_reset_protocol+0x10>)
static uint32_t app_connected = 0;
static uint32_t delayCount = 0;

void app_reset_protocol(void)
{
	delayCount = 0;
 802a41c:	2300      	movs	r3, #0
 802a41e:	600b      	str	r3, [r1, #0]
	app_connected = 0;
 802a420:	6013      	str	r3, [r2, #0]
 802a422:	4770      	bx	lr
 802a424:	1ffedc28 	.word	0x1ffedc28
 802a428:	1ffedc20 	.word	0x1ffedc20

0802a42c <update_leds>:
}

//============================================================================

void update_leds(algo_result_t *pResult)
{
 802a42c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (pResult->target_approaching)
 802a42e:	7a43      	ldrb	r3, [r0, #9]
 802a430:	2b00      	cmp	r3, #0
 802a432:	d138      	bne.n	802a4a6 <update_leds+0x7a>
		/* Arduino status IO */
		DIGITAL_IO_SetOutputHigh(&DIGITAL_IO_ARD_D6);
		DIGITAL_IO_SetOutputLow(&DIGITAL_IO_ARD_D4);
		DIGITAL_IO_SetOutputLow(&DIGITAL_IO_ARD_D7);
	}
	else if (pResult->target_departing)
 802a434:	7a03      	ldrb	r3, [r0, #8]
 802a436:	2b00      	cmp	r3, #0
 802a438:	d13e      	bne.n	802a4b8 <update_leds+0x8c>
		/* Arduino IO */
		DIGITAL_IO_SetOutputHigh(&DIGITAL_IO_ARD_D7);
		DIGITAL_IO_SetOutputLow(&DIGITAL_IO_ARD_D4);
		DIGITAL_IO_SetOutputLow(&DIGITAL_IO_ARD_D6);
	}
	else if (pResult->motion_detected)
 802a43a:	7a83      	ldrb	r3, [r0, #10]
 802a43c:	b9cb      	cbnz	r3, 802a472 <update_leds+0x46>
		DIGITAL_IO_SetOutputLow(&DIGITAL_IO_ARD_D6);
		DIGITAL_IO_SetOutputLow(&DIGITAL_IO_ARD_D7);
	}
	else
	{
		bsp_led_red_off();
 802a43e:	f7fe fc97 	bl	8028d70 <bsp_led_red_off>
		bsp_led_blue_off();
 802a442:	f7fe fc81 	bl	8028d48 <bsp_led_blue_off>
		bsp_led_green_off();
 802a446:	f7fe fc6b 	bl	8028d20 <bsp_led_green_off>
 802a44a:	4920      	ldr	r1, [pc, #128]	; (802a4cc <update_leds+0xa0>)
 802a44c:	4a20      	ldr	r2, [pc, #128]	; (802a4d0 <update_leds+0xa4>)
 802a44e:	4b21      	ldr	r3, [pc, #132]	; (802a4d4 <update_leds+0xa8>)

__STATIC_INLINE void XMC_GPIO_SetOutputLow(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputLow: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = 0x10000U << pin;
 802a450:	7c0d      	ldrb	r5, [r1, #16]
 802a452:	7c10      	ldrb	r0, [r2, #16]
 802a454:	7c1e      	ldrb	r6, [r3, #16]
 802a456:	680c      	ldr	r4, [r1, #0]
 802a458:	6811      	ldr	r1, [r2, #0]
 802a45a:	681a      	ldr	r2, [r3, #0]
 802a45c:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 802a460:	fa03 f505 	lsl.w	r5, r3, r5
 802a464:	fa03 f000 	lsl.w	r0, r3, r0
 802a468:	40b3      	lsls	r3, r6
 802a46a:	6065      	str	r5, [r4, #4]
 802a46c:	6048      	str	r0, [r1, #4]
 802a46e:	6053      	str	r3, [r2, #4]
 802a470:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		DIGITAL_IO_SetOutputLow(&DIGITAL_IO_ARD_D4);
		DIGITAL_IO_SetOutputLow(&DIGITAL_IO_ARD_D6);
	}
	else if (pResult->motion_detected)
	{
		bsp_led_red_off();
 802a472:	f7fe fc7d 	bl	8028d70 <bsp_led_red_off>
		bsp_led_blue_on();
 802a476:	f7fe fc5d 	bl	8028d34 <bsp_led_blue_on>
		bsp_led_green_off();
 802a47a:	f7fe fc51 	bl	8028d20 <bsp_led_green_off>
 802a47e:	4913      	ldr	r1, [pc, #76]	; (802a4cc <update_leds+0xa0>)
 802a480:	4a13      	ldr	r2, [pc, #76]	; (802a4d0 <update_leds+0xa4>)
 802a482:	4b14      	ldr	r3, [pc, #80]	; (802a4d4 <update_leds+0xa8>)

__STATIC_INLINE void XMC_GPIO_SetOutputHigh(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputHigh: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = (uint32_t)0x1U << pin;
 802a484:	7c0f      	ldrb	r7, [r1, #16]

__STATIC_INLINE void XMC_GPIO_SetOutputLow(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputLow: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = 0x10000U << pin;
 802a486:	7c15      	ldrb	r5, [r2, #16]
 802a488:	7c1e      	ldrb	r6, [r3, #16]
 802a48a:	6808      	ldr	r0, [r1, #0]
 802a48c:	6814      	ldr	r4, [r2, #0]
 802a48e:	6819      	ldr	r1, [r3, #0]

__STATIC_INLINE void XMC_GPIO_SetOutputHigh(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputHigh: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = (uint32_t)0x1U << pin;
 802a490:	2201      	movs	r2, #1

__STATIC_INLINE void XMC_GPIO_SetOutputLow(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputLow: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = 0x10000U << pin;
 802a492:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 802a496:	fa03 f505 	lsl.w	r5, r3, r5

__STATIC_INLINE void XMC_GPIO_SetOutputHigh(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputHigh: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = (uint32_t)0x1U << pin;
 802a49a:	40ba      	lsls	r2, r7

__STATIC_INLINE void XMC_GPIO_SetOutputLow(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputLow: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = 0x10000U << pin;
 802a49c:	40b3      	lsls	r3, r6

__STATIC_INLINE void XMC_GPIO_SetOutputHigh(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputHigh: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = (uint32_t)0x1U << pin;
 802a49e:	6042      	str	r2, [r0, #4]

__STATIC_INLINE void XMC_GPIO_SetOutputLow(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputLow: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = 0x10000U << pin;
 802a4a0:	6065      	str	r5, [r4, #4]
 802a4a2:	604b      	str	r3, [r1, #4]
 802a4a4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	{
		/*bsp_led_red_off();
		bsp_led_blue_off();
		bsp_led_green_on();*/

		bsp_led_red_on();
 802a4a6:	f7fe fc59 	bl	8028d5c <bsp_led_red_on>
		bsp_led_blue_off();
 802a4aa:	f7fe fc4d 	bl	8028d48 <bsp_led_blue_off>
		bsp_led_green_off();
 802a4ae:	f7fe fc37 	bl	8028d20 <bsp_led_green_off>
 802a4b2:	4907      	ldr	r1, [pc, #28]	; (802a4d0 <update_leds+0xa4>)
 802a4b4:	4a05      	ldr	r2, [pc, #20]	; (802a4cc <update_leds+0xa0>)
 802a4b6:	e7e4      	b.n	802a482 <update_leds+0x56>
	{
		/*bsp_led_red_on();
		bsp_led_blue_off();
		bsp_led_green_off();*/

		bsp_led_red_off();
 802a4b8:	f7fe fc5a 	bl	8028d70 <bsp_led_red_off>
		bsp_led_blue_off();
 802a4bc:	f7fe fc44 	bl	8028d48 <bsp_led_blue_off>
		bsp_led_green_on();
 802a4c0:	f7fe fc24 	bl	8028d0c <bsp_led_green_on>
 802a4c4:	4903      	ldr	r1, [pc, #12]	; (802a4d4 <update_leds+0xa8>)
 802a4c6:	4a01      	ldr	r2, [pc, #4]	; (802a4cc <update_leds+0xa0>)
 802a4c8:	4b01      	ldr	r3, [pc, #4]	; (802a4d0 <update_leds+0xa4>)
 802a4ca:	e7db      	b.n	802a484 <update_leds+0x58>
 802a4cc:	0802ddd0 	.word	0x0802ddd0
 802a4d0:	0802dde4 	.word	0x0802dde4
 802a4d4:	0802ddf8 	.word	0x0802ddf8

0802a4d8 <app_process>:

//============================================================================

/* Main application process */
void app_process(void)
{
 802a4d8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if (g_usb_init == true)
 802a4dc:	4c57      	ldr	r4, [pc, #348]	; (802a63c <app_process+0x164>)
 802a4de:	7823      	ldrb	r3, [r4, #0]
 802a4e0:	2b01      	cmp	r3, #1
 802a4e2:	f000 808b 	beq.w	802a5fc <app_process+0x124>
    protocol_run();
  }
  else
  {
    /* Initialize the USB low layer driver and start USB data communication */
    if (bsp_usb_init(BSP_USB_TIMEOUT) == 0)
 802a4e6:	f640 70ff 	movw	r0, #4095	; 0xfff
 802a4ea:	f7ff fe01 	bl	802a0f0 <bsp_usb_init>
 802a4ee:	b908      	cbnz	r0, 802a4f4 <app_process+0x1c>
    {
      g_usb_init = true;
 802a4f0:	2301      	movs	r3, #1
 802a4f2:	7023      	strb	r3, [r4, #0]
//============================================================================

/* Main radar application process */
void radar_app_process(void)
{
	if (acq_started)
 802a4f4:	4b52      	ldr	r3, [pc, #328]	; (802a640 <app_process+0x168>)
 802a4f6:	681a      	ldr	r2, [r3, #0]
 802a4f8:	b10a      	cbz	r2, 802a4fe <app_process+0x26>
	{
		/* ... */
		acq_started = 0;
 802a4fa:	2200      	movs	r2, #0
 802a4fc:	601a      	str	r2, [r3, #0]
	}

	if (acq_completed)
 802a4fe:	4d51      	ldr	r5, [pc, #324]	; (802a644 <app_process+0x16c>)
 802a500:	682b      	ldr	r3, [r5, #0]
 802a502:	b9cb      	cbnz	r3, 802a538 <app_process+0x60>
 802a504:	4c50      	ldr	r4, [pc, #320]	; (802a648 <app_process+0x170>)
 802a506:	6823      	ldr	r3, [r4, #0]
		}
#endif
		acq_completed = 0;
	}

	if (algo_completed)
 802a508:	2b00      	cmp	r3, #0
 802a50a:	d13e      	bne.n	802a58a <app_process+0xb2>
	{
		algo_completed_cb();
		algo_completed = 0;
	}

	if (app_initalized)
 802a50c:	4b4f      	ldr	r3, [pc, #316]	; (802a64c <app_process+0x174>)
	{
		switch (radar_app_state)
 802a50e:	4c50      	ldr	r4, [pc, #320]	; (802a650 <app_process+0x178>)
	{
		algo_completed_cb();
		algo_completed = 0;
	}

	if (app_initalized)
 802a510:	681b      	ldr	r3, [r3, #0]
 802a512:	b143      	cbz	r3, 802a526 <app_process+0x4e>
	{
		switch (radar_app_state)
 802a514:	7823      	ldrb	r3, [r4, #0]
 802a516:	3b01      	subs	r3, #1
 802a518:	2b04      	cmp	r3, #4
 802a51a:	d80b      	bhi.n	802a534 <app_process+0x5c>
 802a51c:	e8df f003 	tbb	[pc, r3]
 802a520:	3a604945 	.word	0x3a604945
 802a524:	67          	.byte	0x67
 802a525:	00          	.byte	0x00
			break;
		}
	}
	else
	{
		switch (radar_app_state)
 802a526:	7823      	ldrb	r3, [r4, #0]
 802a528:	2b04      	cmp	r3, #4
 802a52a:	d033      	beq.n	802a594 <app_process+0xbc>
 802a52c:	2b05      	cmp	r3, #5
 802a52e:	d068      	beq.n	802a602 <app_process+0x12a>
 802a530:	2b01      	cmp	r3, #1
 802a532:	d02f      	beq.n	802a594 <app_process+0xbc>
 802a534:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (acq_completed)
	{

#if defined(FMCW_SUPPORTED) || defined(DOPPLER_SUPPORTED)
		/* Start the processing of the algorithm assigned in the function pointer 'algo_processor' */
		if (algo_processing_function != NULL)
 802a538:	4c46      	ldr	r4, [pc, #280]	; (802a654 <app_process+0x17c>)
 802a53a:	6823      	ldr	r3, [r4, #0]
 802a53c:	b393      	cbz	r3, 802a5a4 <app_process+0xcc>

static algo_result_t algo_result;

void do_algo_helper(void)
{
	acq_buf_obj *p_acq_buf = ds_get_active_acq_buf();
 802a53e:	f7f5 ffdb 	bl	80204f8 <ds_get_active_acq_buf>
 802a542:	4607      	mov	r7, r0
	algo_settings_t *p_algo_settings = ds_algo_get_settings();
 802a544:	f7f5 fd68 	bl	8020018 <ds_algo_get_settings>
 802a548:	4680      	mov	r8, r0
	device_settings_t *p_dev_settings = ds_device_get_shadow_settings();
 802a54a:	f7f5 fddb 	bl	8020104 <ds_device_get_shadow_settings>
 802a54e:	4606      	mov	r6, r0
	algo_result_t *p_algo_result = &algo_result;

	/* this is the async raw data streaming to host device */
	radar_pulse_raw_data(p_acq_buf, p_dev_settings);
 802a550:	4631      	mov	r1, r6
 802a552:	4638      	mov	r0, r7
 802a554:	f7f6 fbe2 	bl	8020d1c <radar_pulse_raw_data>

	algo_processing_function(p_acq_buf, p_algo_settings, p_dev_settings, p_algo_result);
 802a558:	4632      	mov	r2, r6
 802a55a:	4b3f      	ldr	r3, [pc, #252]	; (802a658 <app_process+0x180>)
 802a55c:	6826      	ldr	r6, [r4, #0]
#if defined(FMCW_SUPPORTED) || defined(DOPPLER_SUPPORTED)
		/* Start the processing of the algorithm assigned in the function pointer 'algo_processor' */
		if (algo_processing_function != NULL)
		{
			do_algo_helper();
			algo_completed += 1;
 802a55e:	4c3a      	ldr	r4, [pc, #232]	; (802a648 <app_process+0x170>)
	algo_result_t *p_algo_result = &algo_result;

	/* this is the async raw data streaming to host device */
	radar_pulse_raw_data(p_acq_buf, p_dev_settings);

	algo_processing_function(p_acq_buf, p_algo_settings, p_dev_settings, p_algo_result);
 802a560:	4641      	mov	r1, r8
 802a562:	4638      	mov	r0, r7
 802a564:	47b0      	blx	r6

	ds_store_algo_result_ptr(p_algo_result);
 802a566:	483c      	ldr	r0, [pc, #240]	; (802a658 <app_process+0x180>)
 802a568:	f7f5 fd50 	bl	802000c <ds_store_algo_result_ptr>

	radar_pulse_results_updates(p_algo_result);
 802a56c:	483a      	ldr	r0, [pc, #232]	; (802a658 <app_process+0x180>)
 802a56e:	f7f6 fbe7 	bl	8020d40 <radar_pulse_results_updates>

	mcu_base_updates();
 802a572:	f7f6 fba3 	bl	8020cbc <mcu_base_updates>

	update_leds(p_algo_result);
 802a576:	4838      	ldr	r0, [pc, #224]	; (802a658 <app_process+0x180>)
 802a578:	f7ff ff58 	bl	802a42c <update_leds>
#if defined(FMCW_SUPPORTED) || defined(DOPPLER_SUPPORTED)
		/* Start the processing of the algorithm assigned in the function pointer 'algo_processor' */
		if (algo_processing_function != NULL)
		{
			do_algo_helper();
			algo_completed += 1;
 802a57c:	6823      	ldr	r3, [r4, #0]
 802a57e:	3301      	adds	r3, #1
 802a580:	6023      	str	r3, [r4, #0]
		}
#endif
		acq_completed = 0;
 802a582:	2200      	movs	r2, #0
 802a584:	602a      	str	r2, [r5, #0]
	}

	if (algo_completed)
 802a586:	2b00      	cmp	r3, #0
 802a588:	d0c0      	beq.n	802a50c <app_process+0x34>
	{
		algo_completed_cb();
 802a58a:	f000 f9e3 	bl	802a954 <algo_completed_cb>
		algo_completed = 0;
 802a58e:	2300      	movs	r3, #0
 802a590:	6023      	str	r3, [r4, #0]
 802a592:	e7bb      	b.n	802a50c <app_process+0x34>
			radar_app_state = APP_CHECK_FOR_ERROR;
			break;

		case APP_CHECK_FOR_ERROR:
		{
			int status = device_status_check();
 802a594:	f7f6 fb6c 	bl	8020c70 <device_status_check>
			if (status < 0)
 802a598:	2800      	cmp	r0, #0
 802a59a:	db2b      	blt.n	802a5f4 <app_process+0x11c>
		}
		break;

		case APP_HANDLE_ERROR:
			send_device_status_response();
			radar_app_state = APP_IDLE;
 802a59c:	2301      	movs	r3, #1
 802a59e:	7023      	strb	r3, [r4, #0]
 802a5a0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802a5a4:	4c28      	ldr	r4, [pc, #160]	; (802a648 <app_process+0x170>)
 802a5a6:	6823      	ldr	r3, [r4, #0]
 802a5a8:	e7eb      	b.n	802a582 <app_process+0xaa>
	if (app_initalized)
	{
		switch (radar_app_state)
		{
		case APP_IDLE:
			radar_app_state = APP_CHECK_FOR_SETTINGS_UPDATE;
 802a5aa:	2303      	movs	r3, #3
 802a5ac:	7023      	strb	r3, [r4, #0]
 802a5ae:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

//============================================================================

static uint32_t helper_do_hw_settings(void)
{
	device_settings_t *p_dev_settings = ds_device_get_settings();
 802a5b2:	f7f5 fda3 	bl	80200fc <ds_device_get_settings>

	uint32_t error = radar_apply_hw_settings(h_radar_device, p_dev_settings);
 802a5b6:	4e29      	ldr	r6, [pc, #164]	; (802a65c <app_process+0x184>)

//============================================================================

static uint32_t helper_do_hw_settings(void)
{
	device_settings_t *p_dev_settings = ds_device_get_settings();
 802a5b8:	4605      	mov	r5, r0

	uint32_t error = radar_apply_hw_settings(h_radar_device, p_dev_settings);
 802a5ba:	4601      	mov	r1, r0
 802a5bc:	6830      	ldr	r0, [r6, #0]
 802a5be:	f7f6 facb 	bl	8020b58 <radar_apply_hw_settings>
	if (error == RADAR_ERR_OK)
 802a5c2:	b368      	cbz	r0, 802a620 <app_process+0x148>
		ds_device_settings_copy_to_shadow();
		/* add com-lib callback to send-out updated parameters!!! */
	}
	else
	{
		ds_device_settings_revert_from_shadow();
 802a5c4:	f7f5 fdc4 	bl	8020150 <ds_device_settings_revert_from_shadow>
		// current and new parameter differs, if an error occurred, tell to the application
	}
	radar_app_state = APP_IDLE;
 802a5c8:	2301      	movs	r3, #1
 802a5ca:	7023      	strb	r3, [r4, #0]
	ds_clear_device_parameter_changed();
 802a5cc:	f7f6 f80e 	bl	80205ec <ds_clear_device_parameter_changed>

	error = radar_set_automatic_frame_trigger(h_radar_device, p_dev_settings->frame_period_usec);
 802a5d0:	6830      	ldr	r0, [r6, #0]
 802a5d2:	6a29      	ldr	r1, [r5, #32]
 802a5d4:	f7f6 fa14 	bl	8020a00 <radar_set_automatic_frame_trigger>
			}
			break;

		case APP_APPLY_DEVICE_SETTINGS:
			helper_do_hw_settings();
			radar_app_state = APP_CHECK_FOR_ERROR;
 802a5d8:	2304      	movs	r3, #4
 802a5da:	7023      	strb	r3, [r4, #0]
 802a5dc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			radar_app_state = APP_CHECK_FOR_SETTINGS_UPDATE;
			break;

		case APP_CHECK_FOR_SETTINGS_UPDATE:
			/* Check if a new hardware settings are required */
			if (ds_is_device_parameter_changed() || ds_is_device_settings_updated())
 802a5e0:	f7f6 f80a 	bl	80205f8 <ds_is_device_parameter_changed>
 802a5e4:	b1f8      	cbz	r0, 802a626 <app_process+0x14e>
			{
				radar_app_state = APP_APPLY_DEVICE_SETTINGS;
 802a5e6:	2302      	movs	r3, #2
 802a5e8:	7023      	strb	r3, [r4, #0]
 802a5ea:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			}
		}
		break;

		case APP_HANDLE_ERROR:
			send_device_status_response();
 802a5ee:	f7f9 fa05 	bl	80239fc <send_device_status_response>
 802a5f2:	e7d3      	b.n	802a59c <app_process+0xc4>
		case APP_CHECK_FOR_ERROR:
		{
			int status = device_status_check();
			if (status < 0)
			{
				radar_app_state = APP_HANDLE_ERROR;
 802a5f4:	2305      	movs	r3, #5
 802a5f6:	7023      	strb	r3, [r4, #0]
 802a5f8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
void app_process(void)
{
  if (g_usb_init == true)
  {
    /* Run communication protocol */
    protocol_run();
 802a5fc:	f7f9 ff2e 	bl	802445c <protocol_run>
 802a600:	e778      	b.n	802a4f4 <app_process+0x1c>
		break;

		case APP_HANDLE_ERROR:
		{
			/* Send out error only once, if PC app is not requesting it! */
			if (!app_connected)
 802a602:	4d17      	ldr	r5, [pc, #92]	; (802a660 <app_process+0x188>)
 802a604:	682e      	ldr	r6, [r5, #0]
 802a606:	2e00      	cmp	r6, #0
 802a608:	d1e6      	bne.n	802a5d8 <app_process+0x100>
			{

				delayCount += 1;
 802a60a:	4f16      	ldr	r7, [pc, #88]	; (802a664 <app_process+0x18c>)
 802a60c:	683b      	ldr	r3, [r7, #0]
 802a60e:	3301      	adds	r3, #1
				if (delayCount == 100)
 802a610:	2b64      	cmp	r3, #100	; 0x64
		{
			/* Send out error only once, if PC app is not requesting it! */
			if (!app_connected)
			{

				delayCount += 1;
 802a612:	603b      	str	r3, [r7, #0]
				if (delayCount == 100)
 802a614:	d00c      	beq.n	802a630 <app_process+0x158>
				{
					send_device_status_response();
					app_connected = 1;
					delayCount = 0;
				}
				bsp_time_delay(20, BSP_TIMER_DELAY_MILLISECOND);
 802a616:	2014      	movs	r0, #20
 802a618:	2101      	movs	r1, #1
 802a61a:	f7fe fb53 	bl	8028cc4 <bsp_time_delay>
 802a61e:	e7db      	b.n	802a5d8 <app_process+0x100>
	device_settings_t *p_dev_settings = ds_device_get_settings();

	uint32_t error = radar_apply_hw_settings(h_radar_device, p_dev_settings);
	if (error == RADAR_ERR_OK)
	{
		ds_device_settings_copy_to_shadow();
 802a620:	f7f5 fd82 	bl	8020128 <ds_device_settings_copy_to_shadow>
 802a624:	e7d0      	b.n	802a5c8 <app_process+0xf0>
			radar_app_state = APP_CHECK_FOR_SETTINGS_UPDATE;
			break;

		case APP_CHECK_FOR_SETTINGS_UPDATE:
			/* Check if a new hardware settings are required */
			if (ds_is_device_parameter_changed() || ds_is_device_settings_updated())
 802a626:	f7f5 fd71 	bl	802010c <ds_is_device_settings_updated>
 802a62a:	2800      	cmp	r0, #0
 802a62c:	d1db      	bne.n	802a5e6 <app_process+0x10e>
 802a62e:	e7d3      	b.n	802a5d8 <app_process+0x100>
			{

				delayCount += 1;
				if (delayCount == 100)
				{
					send_device_status_response();
 802a630:	f7f9 f9e4 	bl	80239fc <send_device_status_response>
					app_connected = 1;
 802a634:	2301      	movs	r3, #1
					delayCount = 0;
 802a636:	603e      	str	r6, [r7, #0]

				delayCount += 1;
				if (delayCount == 100)
				{
					send_device_status_response();
					app_connected = 1;
 802a638:	602b      	str	r3, [r5, #0]
 802a63a:	e7ec      	b.n	802a616 <app_process+0x13e>
 802a63c:	1ffedbfc 	.word	0x1ffedbfc
 802a640:	1ffedc38 	.word	0x1ffedc38
 802a644:	1ffedc2c 	.word	0x1ffedc2c
 802a648:	1ffedc24 	.word	0x1ffedc24
 802a64c:	1ffedc3c 	.word	0x1ffedc3c
 802a650:	1ffe9628 	.word	0x1ffe9628
 802a654:	1ffedc30 	.word	0x1ffedc30
 802a658:	1ffedc00 	.word	0x1ffedc00
 802a65c:	1ffedc34 	.word	0x1ffedc34
 802a660:	1ffedc20 	.word	0x1ffedc20
 802a664:	1ffedc28 	.word	0x1ffedc28

0802a668 <doppler_calc_speed>:

//============================================================================

void doppler_calc_speed(FFT_Window_Struct_t fft_window, float* if1_i, float* if1_q, uint16_t number_samples,
		                const algo_settings_t  *cp_algo_settings, const device_settings_t *cp_dev_settings, algo_result_t *p_algo_result)
{
 802a668:	b084      	sub	sp, #16
 802a66a:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 802a66e:	ed2d 8b04 	vpush	{d8-d9}
 802a672:	b08e      	sub	sp, #56	; 0x38
 802a674:	ac1a      	add	r4, sp, #104	; 0x68
 802a676:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
	uint8_t motion_approaching = 0U;
	float   doppler_frequency  = 0.0f;
	float   doppler_velocity   = 0.0f;
	float   doppler_level = 0.0f;

	compute_fft_signal(fft_window, if1_i, if1_q, number_samples, FFT_SIZE, 1.0,
 802a67a:	4c66      	ldr	r4, [pc, #408]	; (802a814 <doppler_calc_speed+0x1ac>)
 802a67c:	9409      	str	r4, [sp, #36]	; 0x24
 802a67e:	ad0d      	add	r5, sp, #52	; 0x34
 802a680:	ab1a      	add	r3, sp, #104	; 0x68
 802a682:	cb0f      	ldmia	r3, {r0, r1, r2, r3}

void doppler_calc_speed(FFT_Window_Struct_t fft_window, float* if1_i, float* if1_q, uint16_t number_samples,
		                const algo_settings_t  *cp_algo_settings, const device_settings_t *cp_dev_settings, algo_result_t *p_algo_result)
{
	uint32_t maxBin = 0;
	float maxVal = 0;
 802a684:	ed9f 8a64 	vldr	s16, [pc, #400]	; 802a818 <doppler_calc_speed+0x1b0>
	uint8_t motion_approaching = 0U;
	float   doppler_frequency  = 0.0f;
	float   doppler_velocity   = 0.0f;
	float   doppler_level = 0.0f;

	compute_fft_signal(fft_window, if1_i, if1_q, number_samples, FFT_SIZE, 1.0,
 802a688:	9508      	str	r5, [sp, #32]
 802a68a:	2703      	movs	r7, #3

//============================================================================

void doppler_calc_speed(FFT_Window_Struct_t fft_window, float* if1_i, float* if1_q, uint16_t number_samples,
		                const algo_settings_t  *cp_algo_settings, const device_settings_t *cp_dev_settings, algo_result_t *p_algo_result)
{
 802a68c:	f8bd 5084 	ldrh.w	r5, [sp, #132]	; 0x84
	uint8_t motion_approaching = 0U;
	float   doppler_frequency  = 0.0f;
	float   doppler_velocity   = 0.0f;
	float   doppler_level = 0.0f;

	compute_fft_signal(fft_window, if1_i, if1_q, number_samples, FFT_SIZE, 1.0,
 802a690:	9706      	str	r7, [sp, #24]
 802a692:	ae0c      	add	r6, sp, #48	; 0x30
 802a694:	f04f 5e7e 	mov.w	lr, #1065353216	; 0x3f800000
 802a698:	f44f 7a80 	mov.w	sl, #256	; 0x100

//============================================================================

void doppler_calc_speed(FFT_Window_Struct_t fft_window, float* if1_i, float* if1_q, uint16_t number_samples,
		                const algo_settings_t  *cp_algo_settings, const device_settings_t *cp_dev_settings, algo_result_t *p_algo_result)
{
 802a69c:	9f1f      	ldr	r7, [sp, #124]	; 0x7c
	uint8_t motion_approaching = 0U;
	float   doppler_frequency  = 0.0f;
	float   doppler_velocity   = 0.0f;
	float   doppler_level = 0.0f;

	compute_fft_signal(fft_window, if1_i, if1_q, number_samples, FFT_SIZE, 1.0,
 802a69e:	9607      	str	r6, [sp, #28]
 802a6a0:	9503      	str	r5, [sp, #12]

//============================================================================

void doppler_calc_speed(FFT_Window_Struct_t fft_window, float* if1_i, float* if1_q, uint16_t number_samples,
		                const algo_settings_t  *cp_algo_settings, const device_settings_t *cp_dev_settings, algo_result_t *p_algo_result)
{
 802a6a2:	9e20      	ldr	r6, [sp, #128]	; 0x80
	uint8_t motion_approaching = 0U;
	float   doppler_frequency  = 0.0f;
	float   doppler_velocity   = 0.0f;
	float   doppler_level = 0.0f;

	compute_fft_signal(fft_window, if1_i, if1_q, number_samples, FFT_SIZE, 1.0,
 802a6a4:	9d1e      	ldr	r5, [sp, #120]	; 0x78
 802a6a6:	f8cd e014 	str.w	lr, [sp, #20]
//============================================================================

void doppler_calc_speed(FFT_Window_Struct_t fft_window, float* if1_i, float* if1_q, uint16_t number_samples,
		                const algo_settings_t  *cp_algo_settings, const device_settings_t *cp_dev_settings, algo_result_t *p_algo_result)
{
	uint32_t maxBin = 0;
 802a6aa:	f04f 0800 	mov.w	r8, #0

//============================================================================

void doppler_calc_speed(FFT_Window_Struct_t fft_window, float* if1_i, float* if1_q, uint16_t number_samples,
		                const algo_settings_t  *cp_algo_settings, const device_settings_t *cp_dev_settings, algo_result_t *p_algo_result)
{
 802a6ae:	f8dd 908c 	ldr.w	r9, [sp, #140]	; 0x8c
	uint8_t motion_approaching = 0U;
	float   doppler_frequency  = 0.0f;
	float   doppler_velocity   = 0.0f;
	float   doppler_level = 0.0f;

	compute_fft_signal(fft_window, if1_i, if1_q, number_samples, FFT_SIZE, 1.0,
 802a6b2:	9701      	str	r7, [sp, #4]
 802a6b4:	9602      	str	r6, [sp, #8]
 802a6b6:	9500      	str	r5, [sp, #0]

//============================================================================

void doppler_calc_speed(FFT_Window_Struct_t fft_window, float* if1_i, float* if1_q, uint16_t number_samples,
		                const algo_settings_t  *cp_algo_settings, const device_settings_t *cp_dev_settings, algo_result_t *p_algo_result)
{
 802a6b8:	9e22      	ldr	r6, [sp, #136]	; 0x88
	uint8_t motion_approaching = 0U;
	float   doppler_frequency  = 0.0f;
	float   doppler_velocity   = 0.0f;
	float   doppler_level = 0.0f;

	compute_fft_signal(fft_window, if1_i, if1_q, number_samples, FFT_SIZE, 1.0,
 802a6ba:	f8cd a010 	str.w	sl, [sp, #16]

void doppler_calc_speed(FFT_Window_Struct_t fft_window, float* if1_i, float* if1_q, uint16_t number_samples,
		                const algo_settings_t  *cp_algo_settings, const device_settings_t *cp_dev_settings, algo_result_t *p_algo_result)
{
	uint32_t maxBin = 0;
	float maxVal = 0;
 802a6be:	ed8d 8a0b 	vstr	s16, [sp, #44]	; 0x2c
//============================================================================

void doppler_calc_speed(FFT_Window_Struct_t fft_window, float* if1_i, float* if1_q, uint16_t number_samples,
		                const algo_settings_t  *cp_algo_settings, const device_settings_t *cp_dev_settings, algo_result_t *p_algo_result)
{
	uint32_t maxBin = 0;
 802a6c2:	f8cd 8028 	str.w	r8, [sp, #40]	; 0x28

//============================================================================

void doppler_calc_speed(FFT_Window_Struct_t fft_window, float* if1_i, float* if1_q, uint16_t number_samples,
		                const algo_settings_t  *cp_algo_settings, const device_settings_t *cp_dev_settings, algo_result_t *p_algo_result)
{
 802a6c6:	9d24      	ldr	r5, [sp, #144]	; 0x90
	uint8_t motion_approaching = 0U;
	float   doppler_frequency  = 0.0f;
	float   doppler_velocity   = 0.0f;
	float   doppler_level = 0.0f;

	compute_fft_signal(fft_window, if1_i, if1_q, number_samples, FFT_SIZE, 1.0,
 802a6c8:	f7fd ffe6 	bl	8028698 <compute_fft_signal>
			           FFT_INPUT_COMPLEX, &if1_real, &if1_imag, doppler_fft_signal);

	compute_fft_spectrum(doppler_fft_signal, FFT_SIZE, doppler_spectrum);
 802a6cc:	4651      	mov	r1, sl
 802a6ce:	4622      	mov	r2, r4
 802a6d0:	4620      	mov	r0, r4
 802a6d2:	f7fe f8db 	bl	802888c <compute_fft_spectrum>

	doppler_spectrum[0] = 0; // remove DC from spectrum
 802a6d6:	ed84 8a00 	vstr	s16, [r4]
	doppler_spectrum[FFT_SIZE/2] = 0; // remove DC from middle bin
 802a6da:	ed84 8a80 	vstr	s16, [r4, #512]	; 0x200

	uint32_t fft_min_check = (uint32_t) ceilf(cp_algo_settings->min_speed_kmph*44.4f*FFT_SIZE/cp_dev_settings->adc_sampling_freq_Hz);
 802a6de:	ed96 7a03 	vldr	s14, [r6, #12]
 802a6e2:	eddf 7a4e 	vldr	s15, [pc, #312]	; 802a81c <doppler_calc_speed+0x1b4>
 802a6e6:	eddf 6a4e 	vldr	s13, [pc, #312]	; 802a820 <doppler_calc_speed+0x1b8>
 802a6ea:	ee67 7a27 	vmul.f32	s15, s14, s15
 802a6ee:	ed99 7a05 	vldr	s14, [r9, #20]
 802a6f2:	ee67 7aa6 	vmul.f32	s15, s15, s13
 802a6f6:	eeb8 7a47 	vcvt.f32.u32	s14, s14
 802a6fa:	eec7 7a87 	vdiv.f32	s15, s15, s14
 802a6fe:	ee17 0a90 	vmov	r0, s15
 802a702:	f000 f929 	bl	802a958 <ceilf>
 802a706:	ee07 0a90 	vmov	s15, r0
 802a70a:	eefc 7ae7 	vcvt.u32.f32	s15, s15

	uint32_t size_check = FFT_SIZE - 2*fft_min_check + 1;

	/* Calculates maxValue and returns corresponding BIN value */
	arm_max_f32(&doppler_spectrum[fft_min_check], size_check, &maxVal, &maxBin);
 802a70e:	aa0b      	add	r2, sp, #44	; 0x2c
	compute_fft_spectrum(doppler_fft_signal, FFT_SIZE, doppler_spectrum);

	doppler_spectrum[0] = 0; // remove DC from spectrum
	doppler_spectrum[FFT_SIZE/2] = 0; // remove DC from middle bin

	uint32_t fft_min_check = (uint32_t) ceilf(cp_algo_settings->min_speed_kmph*44.4f*FFT_SIZE/cp_dev_settings->adc_sampling_freq_Hz);
 802a710:	ee17 7a90 	vmov	r7, s15

	uint32_t size_check = FFT_SIZE - 2*fft_min_check + 1;
 802a714:	0079      	lsls	r1, r7, #1

	/* Calculates maxValue and returns corresponding BIN value */
	arm_max_f32(&doppler_spectrum[fft_min_check], size_check, &maxVal, &maxBin);
 802a716:	ebc1 010a 	rsb	r1, r1, sl
 802a71a:	ab0a      	add	r3, sp, #40	; 0x28
 802a71c:	eb04 0087 	add.w	r0, r4, r7, lsl #2
 802a720:	3101      	adds	r1, #1
 802a722:	f7fc ffef 	bl	8027704 <arm_max_f32>

	doppler_Hz_per_bin =  cp_dev_settings->adc_sampling_freq_Hz / (float)FFT_SIZE;

	doppler_level = maxVal;

	if (maxVal > (float) cp_algo_settings->speed_detection_threshold) // if the threshold is exceeded, we have a doppler event
 802a726:	edd6 7a02 	vldr	s15, [r6, #8]
	arm_max_f32(&doppler_spectrum[fft_min_check], size_check, &maxVal, &maxBin);
	maxBin += fft_min_check;

	doppler_Hz_per_bin =  cp_dev_settings->adc_sampling_freq_Hz / (float)FFT_SIZE;

	doppler_level = maxVal;
 802a72a:	ed9d 9a0b 	vldr	s18, [sp, #44]	; 0x2c

	uint32_t size_check = FFT_SIZE - 2*fft_min_check + 1;

	/* Calculates maxValue and returns corresponding BIN value */
	arm_max_f32(&doppler_spectrum[fft_min_check], size_check, &maxVal, &maxBin);
	maxBin += fft_min_check;
 802a72e:	9b0a      	ldr	r3, [sp, #40]	; 0x28

	doppler_Hz_per_bin =  cp_dev_settings->adc_sampling_freq_Hz / (float)FFT_SIZE;
 802a730:	f8d9 2014 	ldr.w	r2, [r9, #20]

	doppler_level = maxVal;

	if (maxVal > (float) cp_algo_settings->speed_detection_threshold) // if the threshold is exceeded, we have a doppler event
 802a734:	eeb4 9ae7 	vcmpe.f32	s18, s15

	uint32_t size_check = FFT_SIZE - 2*fft_min_check + 1;

	/* Calculates maxValue and returns corresponding BIN value */
	arm_max_f32(&doppler_spectrum[fft_min_check], size_check, &maxVal, &maxBin);
	maxBin += fft_min_check;
 802a738:	443b      	add	r3, r7

	doppler_Hz_per_bin =  cp_dev_settings->adc_sampling_freq_Hz / (float)FFT_SIZE;

	doppler_level = maxVal;

	if (maxVal > (float) cp_algo_settings->speed_detection_threshold) // if the threshold is exceeded, we have a doppler event
 802a73a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr

	uint32_t size_check = FFT_SIZE - 2*fft_min_check + 1;

	/* Calculates maxValue and returns corresponding BIN value */
	arm_max_f32(&doppler_spectrum[fft_min_check], size_check, &maxVal, &maxBin);
	maxBin += fft_min_check;
 802a73e:	930a      	str	r3, [sp, #40]	; 0x28

	doppler_Hz_per_bin =  cp_dev_settings->adc_sampling_freq_Hz / (float)FFT_SIZE;

	doppler_level = maxVal;

	if (maxVal > (float) cp_algo_settings->speed_detection_threshold) // if the threshold is exceeded, we have a doppler event
 802a740:	dd2c      	ble.n	802a79c <doppler_calc_speed+0x134>
	{
		if (maxBin < FFT_SIZE / 2)
 802a742:	2b7f      	cmp	r3, #127	; 0x7f
 802a744:	d85d      	bhi.n	802a802 <doppler_calc_speed+0x19a>
	    {
			motion_departing = 1;
 802a746:	2701      	movs	r7, #1

	/* Calculates maxValue and returns corresponding BIN value */
	arm_max_f32(&doppler_spectrum[fft_min_check], size_check, &maxVal, &maxBin);
	maxBin += fft_min_check;

	doppler_Hz_per_bin =  cp_dev_settings->adc_sampling_freq_Hz / (float)FFT_SIZE;
 802a748:	ee08 2a90 	vmov	s17, r2
	    	motion_approaching = 1;

	    	maxBin = FFT_SIZE - maxBin;
	    }

		doppler_frequency =  maxBin * doppler_Hz_per_bin;
 802a74c:	ee07 3a90 	vmov	s15, r3

	/* Calculates maxValue and returns corresponding BIN value */
	arm_max_f32(&doppler_spectrum[fft_min_check], size_check, &maxVal, &maxBin);
	maxBin += fft_min_check;

	doppler_Hz_per_bin =  cp_dev_settings->adc_sampling_freq_Hz / (float)FFT_SIZE;
 802a750:	eefb 8acc 	vcvt.f32.u32	s17, s17, #8
	    	motion_approaching = 1;

	    	maxBin = FFT_SIZE - maxBin;
	    }

		doppler_frequency =  maxBin * doppler_Hz_per_bin;
 802a754:	eef8 7a67 	vcvt.f32.u32	s15, s15

		doppler_velocity  =  doppler_frequency / 44.4f;
 802a758:	ed9f 8a30 	vldr	s16, [pc, #192]	; 802a81c <doppler_calc_speed+0x1b4>

		if (doppler_velocity < cp_algo_settings->min_speed_kmph || doppler_velocity > cp_algo_settings->max_speed_kmph)
 802a75c:	ed96 7a03 	vldr	s14, [r6, #12]
	    	motion_approaching = 1;

	    	maxBin = FFT_SIZE - maxBin;
	    }

		doppler_frequency =  maxBin * doppler_Hz_per_bin;
 802a760:	ee67 8aa8 	vmul.f32	s17, s15, s17

		doppler_velocity  =  doppler_frequency / 44.4f;
 802a764:	ee88 8a88 	vdiv.f32	s16, s17, s16

		if (doppler_velocity < cp_algo_settings->min_speed_kmph || doppler_velocity > cp_algo_settings->max_speed_kmph)
 802a768:	eeb4 8ac7 	vcmpe.f32	s16, s14
 802a76c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802a770:	d410      	bmi.n	802a794 <doppler_calc_speed+0x12c>
 802a772:	edd6 7a04 	vldr	s15, [r6, #16]
 802a776:	eeb4 8ae7 	vcmpe.f32	s16, s15
 802a77a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802a77e:	dc09      	bgt.n	802a794 <doppler_calc_speed+0x12c>
			doppler_velocity = 0.0;
			motion_departing = 0;
			motion_approaching = 0;
		}

		if (motion_departing == 1 && doppler_velocity > 0)
 802a780:	2f00      	cmp	r7, #0
 802a782:	d045      	beq.n	802a810 <doppler_calc_speed+0x1a8>
 802a784:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 802a788:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802a78c:	dd09      	ble.n	802a7a2 <doppler_calc_speed+0x13a>
		{
			doppler_velocity  =  -doppler_velocity; // negate  speed for departing targets
 802a78e:	eeb1 8a48 	vneg.f32	s16, s16
 802a792:	e006      	b.n	802a7a2 <doppler_calc_speed+0x13a>
 802a794:	ed9f 8a20 	vldr	s16, [pc, #128]	; 802a818 <doppler_calc_speed+0x1b0>
 802a798:	f04f 0800 	mov.w	r8, #0
 802a79c:	eef0 8a48 	vmov.f32	s17, s16
 802a7a0:	4647      	mov	r7, r8

		doppler_frequency = 0.0;
		doppler_velocity = 0.0;
	}

	if (maxVal > (float) cp_algo_settings->motion_detection_threshold) // if the threshold is exceeded, we have a doppler event
 802a7a2:	edd6 7a0a 	vldr	s15, [r6, #40]	; 0x28
 802a7a6:	eeb4 9ae7 	vcmpe.f32	s18, s15
 802a7aa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
	uint32_t maxBin = 0;
	float maxVal = 0;
	float doppler_Hz_per_bin;
	float if1_real, if1_imag;

	uint8_t motion_detected    = 0U;
 802a7ae:	bfcc      	ite	gt
 802a7b0:	2201      	movgt	r2, #1
 802a7b2:	2200      	movle	r2, #0
	if (maxVal > (float) cp_algo_settings->motion_detection_threshold) // if the threshold is exceeded, we have a doppler event
	{
		motion_detected = 1;
	}

	if (p_algo_result)
 802a7b4:	b195      	cbz	r5, 802a7dc <doppler_calc_speed+0x174>
	{
		p_algo_result->motion_detected = motion_detected;
		/* Store processing results into result structure */

		if (p_algo_result->p_doppler_spectrum)
 802a7b6:	6968      	ldr	r0, [r5, #20]
		motion_detected = 1;
	}

	if (p_algo_result)
	{
		p_algo_result->motion_detected = motion_detected;
 802a7b8:	72aa      	strb	r2, [r5, #10]
		/* Store processing results into result structure */

		if (p_algo_result->p_doppler_spectrum)
 802a7ba:	b130      	cbz	r0, 802a7ca <doppler_calc_speed+0x162>
		{
			if (maxBin > FFT_SIZE / 2) {
 802a7bc:	2b80      	cmp	r3, #128	; 0x80
 802a7be:	d814      	bhi.n	802a7ea <doppler_calc_speed+0x182>
					doppler_spectrum[idx] = doppler_spectrum[FFT_SIZE - 1 - idx];
				}
			}

			/* transfer spectrum to result structure, if there is memory allocated for it */
			memcpy(p_algo_result->p_doppler_spectrum, doppler_spectrum, p_algo_result->doppler_spectrum_elems*sizeof(float));
 802a7c0:	69aa      	ldr	r2, [r5, #24]
 802a7c2:	4914      	ldr	r1, [pc, #80]	; (802a814 <doppler_calc_speed+0x1ac>)
 802a7c4:	0092      	lsls	r2, r2, #2
 802a7c6:	f002 febb 	bl	802d540 <memcpy>
		}

		p_algo_result->level 					= doppler_level;
 802a7ca:	ed85 9a01 	vstr	s18, [r5, #4]
		p_algo_result->doppler_frequency_hz		= doppler_frequency;
 802a7ce:	edc5 8a04 	vstr	s17, [r5, #16]

		p_algo_result->velocity_kmph 			= doppler_velocity;
 802a7d2:	ed85 8a00 	vstr	s16, [r5]
		p_algo_result->target_departing 		= motion_departing;
 802a7d6:	722f      	strb	r7, [r5, #8]
		p_algo_result->target_approaching   	= motion_approaching;
 802a7d8:	f885 8009 	strb.w	r8, [r5, #9]
	}
}
 802a7dc:	b00e      	add	sp, #56	; 0x38
 802a7de:	ecbd 8b04 	vpop	{d8-d9}
 802a7e2:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 802a7e6:	b004      	add	sp, #16
 802a7e8:	4770      	bx	lr
 802a7ea:	4b0e      	ldr	r3, [pc, #56]	; (802a824 <doppler_calc_speed+0x1bc>)
 802a7ec:	f5a3 6280 	sub.w	r2, r3, #1024	; 0x400
 802a7f0:	f502 7400 	add.w	r4, r2, #512	; 0x200
		{
			if (maxBin > FFT_SIZE / 2) {
				/* prepare spectrum to be copied to results */
				for (uint32_t idx = 0; idx < FFT_SIZE/2; idx++)
				{
					doppler_spectrum[idx] = doppler_spectrum[FFT_SIZE - 1 - idx];
 802a7f4:	f853 1d04 	ldr.w	r1, [r3, #-4]!
 802a7f8:	f842 1b04 	str.w	r1, [r2], #4

		if (p_algo_result->p_doppler_spectrum)
		{
			if (maxBin > FFT_SIZE / 2) {
				/* prepare spectrum to be copied to results */
				for (uint32_t idx = 0; idx < FFT_SIZE/2; idx++)
 802a7fc:	42a3      	cmp	r3, r4
 802a7fe:	d1f9      	bne.n	802a7f4 <doppler_calc_speed+0x18c>
 802a800:	e7de      	b.n	802a7c0 <doppler_calc_speed+0x158>
	    else
	    {
	    	motion_departing = 0;
	    	motion_approaching = 1;

	    	maxBin = FFT_SIZE - maxBin;
 802a802:	ebc3 030a 	rsb	r3, r3, sl
			motion_departing = 1;
			motion_approaching = 0;
	    }
	    else
	    {
	    	motion_departing = 0;
 802a806:	4647      	mov	r7, r8
	    	motion_approaching = 1;

	    	maxBin = FFT_SIZE - maxBin;
 802a808:	930a      	str	r3, [sp, #40]	; 0x28
			motion_approaching = 0;
	    }
	    else
	    {
	    	motion_departing = 0;
	    	motion_approaching = 1;
 802a80a:	f04f 0801 	mov.w	r8, #1
 802a80e:	e79b      	b.n	802a748 <doppler_calc_speed+0xe0>
 802a810:	2700      	movs	r7, #0
 802a812:	e7c6      	b.n	802a7a2 <doppler_calc_speed+0x13a>
 802a814:	1ffee040 	.word	0x1ffee040
 802a818:	00000000 	.word	0x00000000
 802a81c:	4231999a 	.word	0x4231999a
 802a820:	43800000 	.word	0x43800000
 802a824:	1ffee440 	.word	0x1ffee440

0802a828 <doppler_do>:
==============================================================================
 */

void doppler_do(acq_buf_obj *p_acq_buf, const algo_settings_t *cp_algo_settings,
				const device_settings_t *cp_dev_settings, algo_result_t *p_algo_result)
{
 802a828:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

	uint16_t *p_temp[BSP_NUM_OF_ADC_CHANNELS];
	uint16_t Ns = p_acq_buf->params.num_of_samples_per_chirp;

	/* Generate FFT window, it will be used for FFT calculation */
	if (fft_fast_window_flag != Ns)
 802a82c:	f8df a0fc 	ldr.w	sl, [pc, #252]	; 802a92c <doppler_do+0x104>
	/* allocated as static memory, not on call stack */
	static float raw_data_i1[BSP_MAX_NUM_SAMPLES_PER_CHIRP];
	static float raw_data_q1[BSP_MAX_NUM_SAMPLES_PER_CHIRP];

	uint16_t *p_temp[BSP_NUM_OF_ADC_CHANNELS];
	uint16_t Ns = p_acq_buf->params.num_of_samples_per_chirp;
 802a830:	8845      	ldrh	r5, [r0, #2]

	/* Generate FFT window, it will be used for FFT calculation */
	if (fft_fast_window_flag != Ns)
	{
		fft_fast_time_window.fft_window_length = Ns; /* Number of elements in the FFT window  */
 802a832:	4c3a      	ldr	r4, [pc, #232]	; (802a91c <doppler_do+0xf4>)
==============================================================================
 */

void doppler_do(acq_buf_obj *p_acq_buf, const algo_settings_t *cp_algo_settings,
				const device_settings_t *cp_dev_settings, algo_result_t *p_algo_result)
{
 802a834:	4606      	mov	r6, r0

	uint16_t *p_temp[BSP_NUM_OF_ADC_CHANNELS];
	uint16_t Ns = p_acq_buf->params.num_of_samples_per_chirp;

	/* Generate FFT window, it will be used for FFT calculation */
	if (fft_fast_window_flag != Ns)
 802a836:	f8da 0000 	ldr.w	r0, [sl]
 802a83a:	4285      	cmp	r5, r0
==============================================================================
 */

void doppler_do(acq_buf_obj *p_acq_buf, const algo_settings_t *cp_algo_settings,
				const device_settings_t *cp_dev_settings, algo_result_t *p_algo_result)
{
 802a83c:	b089      	sub	sp, #36	; 0x24
 802a83e:	460f      	mov	r7, r1
 802a840:	4691      	mov	r9, r2
 802a842:	4698      	mov	r8, r3

	uint16_t *p_temp[BSP_NUM_OF_ADC_CHANNELS];
	uint16_t Ns = p_acq_buf->params.num_of_samples_per_chirp;

	/* Generate FFT window, it will be used for FFT calculation */
	if (fft_fast_window_flag != Ns)
 802a844:	d007      	beq.n	802a856 <doppler_do+0x2e>
	{
		fft_fast_time_window.fft_window_length = Ns; /* Number of elements in the FFT window  */
		if (fft_window_gen(&fft_fast_time_window) == 0)
 802a846:	4620      	mov	r0, r4
	uint16_t Ns = p_acq_buf->params.num_of_samples_per_chirp;

	/* Generate FFT window, it will be used for FFT calculation */
	if (fft_fast_window_flag != Ns)
	{
		fft_fast_time_window.fft_window_length = Ns; /* Number of elements in the FFT window  */
 802a848:	6065      	str	r5, [r4, #4]
		if (fft_window_gen(&fft_fast_time_window) == 0)
 802a84a:	f7fd fced 	bl	8028228 <fft_window_gen>
 802a84e:	2800      	cmp	r0, #0
 802a850:	d057      	beq.n	802a902 <doppler_do+0xda>
		{
			XMC_DEBUG("Invalid FFT window parameters !\n");
			while (1);
		}
		fft_fast_window_flag = Ns;
 802a852:	f8ca 5000 	str.w	r5, [sl]
	}

	/* clear array values that are not acquired */
	memset(raw_data_i1, 0, sizeof(raw_data_i1));
 802a856:	2100      	movs	r1, #0
 802a858:	f44f 6280 	mov.w	r2, #1024	; 0x400
 802a85c:	4830      	ldr	r0, [pc, #192]	; (802a920 <doppler_do+0xf8>)
 802a85e:	f002 fe7a 	bl	802d556 <memset>
	memset(raw_data_q1, 0, sizeof(raw_data_q1));
 802a862:	4830      	ldr	r0, [pc, #192]	; (802a924 <doppler_do+0xfc>)
 802a864:	2100      	movs	r1, #0
 802a866:	f44f 6280 	mov.w	r2, #1024	; 0x400
 802a86a:	f002 fe74 	bl	802d556 <memset>

	if (cp_algo_settings->use_high_gain_doppler)
 802a86e:	f8d7 b024 	ldr.w	fp, [r7, #36]	; 0x24
 802a872:	f1bb 0f00 	cmp.w	fp, #0
 802a876:	d045      	beq.n	802a904 <doppler_do+0xdc>
	{
		/* Only one chirp for Doppler */
		p_temp[0] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 0, 0);
 802a878:	2100      	movs	r1, #0
 802a87a:	460a      	mov	r2, r1
 802a87c:	4630      	mov	r0, r6
 802a87e:	f7f5 ffe5 	bl	802084c <get_buffer_address_by_chirp>
		p_temp[1] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 1, 0);
 802a882:	2101      	movs	r1, #1
	memset(raw_data_q1, 0, sizeof(raw_data_q1));

	if (cp_algo_settings->use_high_gain_doppler)
	{
		/* Only one chirp for Doppler */
		p_temp[0] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 0, 0);
 802a884:	4682      	mov	sl, r0
		p_temp[1] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 1, 0);
 802a886:	2200      	movs	r2, #0
 802a888:	4630      	mov	r0, r6
 802a88a:	f7f5 ffdf 	bl	802084c <get_buffer_address_by_chirp>
 802a88e:	f8df c090 	ldr.w	ip, [pc, #144]	; 802a920 <doppler_do+0xf8>
 802a892:	f8df b090 	ldr.w	fp, [pc, #144]	; 802a924 <doppler_do+0xfc>
		/* Only one chirp for Doppler */
		p_temp[0] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 2, 0);
		p_temp[1] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 3, 0);
	}

	for (uint32_t i = 0; i < Ns; i++)
 802a896:	b1f5      	cbz	r5, 802a8d6 <doppler_do+0xae>
	{
		raw_data_i1[i] = (float)((p_temp[0])[i]) * if_scale;
 802a898:	eddf 6a23 	vldr	s13, [pc, #140]	; 802a928 <doppler_do+0x100>
 802a89c:	1e82      	subs	r2, r0, #2
 802a89e:	f1aa 0e02 	sub.w	lr, sl, #2
 802a8a2:	4663      	mov	r3, ip
 802a8a4:	eb0c 0085 	add.w	r0, ip, r5, lsl #2
 802a8a8:	4659      	mov	r1, fp
 802a8aa:	f83e af02 	ldrh.w	sl, [lr, #2]!
 802a8ae:	ee07 aa10 	vmov	s14, sl
		raw_data_q1[i] = (float)((p_temp[1])[i]) * if_scale;
 802a8b2:	f832 af02 	ldrh.w	sl, [r2, #2]!
		p_temp[1] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 3, 0);
	}

	for (uint32_t i = 0; i < Ns; i++)
	{
		raw_data_i1[i] = (float)((p_temp[0])[i]) * if_scale;
 802a8b6:	eeb8 7a47 	vcvt.f32.u32	s14, s14
		raw_data_q1[i] = (float)((p_temp[1])[i]) * if_scale;
 802a8ba:	ee07 aa90 	vmov	s15, sl
		p_temp[1] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 3, 0);
	}

	for (uint32_t i = 0; i < Ns; i++)
	{
		raw_data_i1[i] = (float)((p_temp[0])[i]) * if_scale;
 802a8be:	ee27 7a26 	vmul.f32	s14, s14, s13
		raw_data_q1[i] = (float)((p_temp[1])[i]) * if_scale;
 802a8c2:	eef8 7a67 	vcvt.f32.u32	s15, s15
		p_temp[1] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 3, 0);
	}

	for (uint32_t i = 0; i < Ns; i++)
	{
		raw_data_i1[i] = (float)((p_temp[0])[i]) * if_scale;
 802a8c6:	eca3 7a01 	vstmia	r3!, {s14}
		raw_data_q1[i] = (float)((p_temp[1])[i]) * if_scale;
 802a8ca:	ee67 7aa6 	vmul.f32	s15, s15, s13
		/* Only one chirp for Doppler */
		p_temp[0] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 2, 0);
		p_temp[1] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 3, 0);
	}

	for (uint32_t i = 0; i < Ns; i++)
 802a8ce:	4283      	cmp	r3, r0
	{
		raw_data_i1[i] = (float)((p_temp[0])[i]) * if_scale;
		raw_data_q1[i] = (float)((p_temp[1])[i]) * if_scale;
 802a8d0:	ece1 7a01 	vstmia	r1!, {s15}
		/* Only one chirp for Doppler */
		p_temp[0] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 2, 0);
		p_temp[1] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 3, 0);
	}

	for (uint32_t i = 0; i < Ns; i++)
 802a8d4:	d1e9      	bne.n	802a8aa <doppler_do+0x82>
	{
		raw_data_i1[i] = (float)((p_temp[0])[i]) * if_scale;
		raw_data_q1[i] = (float)((p_temp[1])[i]) * if_scale;
	}

	doppler_calc_speed(fft_fast_time_window, raw_data_i1, raw_data_q1, Ns, cp_algo_settings, cp_dev_settings, p_algo_result);
 802a8d6:	6923      	ldr	r3, [r4, #16]
 802a8d8:	9300      	str	r3, [sp, #0]
 802a8da:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
 802a8de:	f8cd c004 	str.w	ip, [sp, #4]
 802a8e2:	f8cd b008 	str.w	fp, [sp, #8]
 802a8e6:	9503      	str	r5, [sp, #12]
 802a8e8:	9704      	str	r7, [sp, #16]
 802a8ea:	f8cd 9014 	str.w	r9, [sp, #20]
 802a8ee:	f8cd 8018 	str.w	r8, [sp, #24]
 802a8f2:	f7ff feb9 	bl	802a668 <doppler_calc_speed>

	/* indicated, that the results are taken from dedicated frame */
	p_algo_result->frame_counter = p_acq_buf->frame_counter;
 802a8f6:	6b73      	ldr	r3, [r6, #52]	; 0x34
 802a8f8:	f8c8 301c 	str.w	r3, [r8, #28]
}
 802a8fc:	b009      	add	sp, #36	; 0x24
 802a8fe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	{
		fft_fast_time_window.fft_window_length = Ns; /* Number of elements in the FFT window  */
		if (fft_window_gen(&fft_fast_time_window) == 0)
		{
			XMC_DEBUG("Invalid FFT window parameters !\n");
			while (1);
 802a902:	e7fe      	b.n	802a902 <doppler_do+0xda>
		p_temp[1] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 1, 0);
	}
	else
	{
		/* Only one chirp for Doppler */
		p_temp[0] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 2, 0);
 802a904:	465a      	mov	r2, fp
 802a906:	4630      	mov	r0, r6
 802a908:	2102      	movs	r1, #2
 802a90a:	f7f5 ff9f 	bl	802084c <get_buffer_address_by_chirp>
		p_temp[1] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 3, 0);
 802a90e:	465a      	mov	r2, fp
		p_temp[1] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 1, 0);
	}
	else
	{
		/* Only one chirp for Doppler */
		p_temp[0] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 2, 0);
 802a910:	4682      	mov	sl, r0
		p_temp[1] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 3, 0);
 802a912:	2103      	movs	r1, #3
 802a914:	4630      	mov	r0, r6
 802a916:	f7f5 ff99 	bl	802084c <get_buffer_address_by_chirp>
 802a91a:	e7b8      	b.n	802a88e <doppler_do+0x66>
 802a91c:	1ffe962c 	.word	0x1ffe962c
 802a920:	1ffeec44 	.word	0x1ffeec44
 802a924:	1ffee840 	.word	0x1ffee840
 802a928:	3bd34067 	.word	0x3bd34067
 802a92c:	1ffeec40 	.word	0x1ffeec40

0802a930 <main>:
   2. MAIN METHOD
==============================================================================
 */

int main(void)
{
 802a930:	b508      	push	{r3, lr}
  DAVE_STATUS_t status;
  
  /* Initialize DAVE APPs */
  status = DAVE_Init();
 802a932:	f7fd fb53 	bl	8027fdc <DAVE_Init>
  
  if (status != DAVE_STATUS_SUCCESS)
 802a936:	b100      	cbz	r0, 802a93a <main+0xa>
  {
    /* Placeholder for error handler code. The while loop below can be replaced with an user error handler. */
    XMC_DEBUG("DAVE APPs initialization failed\n");
    while (1U);
 802a938:	e7fe      	b.n	802a938 <main+0x8>
  }
  
  /* Register algorithm processing function:
     Set the algorithm processing function pointer, it will
     be used by the application for algorithm data processing */
    app_register_algo_process(doppler_do);
 802a93a:	4804      	ldr	r0, [pc, #16]	; (802a94c <main+0x1c>)
 802a93c:	f7ff fc92 	bl	802a264 <app_register_algo_process>

  /* Initialize the application */
  app_init();
 802a940:	f7ff fbfc 	bl	802a13c <app_init>
  
  /* Infinite loop */
  while (1U)
  {
    /* Main application process */
    app_process();
 802a944:	f7ff fdc8 	bl	802a4d8 <app_process>
  }
 802a948:	e7fc      	b.n	802a944 <main+0x14>
 802a94a:	bf00      	nop
 802a94c:	0802a829 	.word	0x0802a829

0802a950 <acq_completed_cb>:
}

void acq_completed_cb(void)
{
 802a950:	4770      	bx	lr
 802a952:	bf00      	nop

0802a954 <algo_completed_cb>:
  
  */
}

void algo_completed_cb(void)
{
 802a954:	4770      	bx	lr
 802a956:	bf00      	nop

0802a958 <ceilf>:
 802a958:	b410      	push	{r4}
 802a95a:	b083      	sub	sp, #12
 802a95c:	9001      	str	r0, [sp, #4]
 802a95e:	9a01      	ldr	r2, [sp, #4]
 802a960:	f022 4100 	bic.w	r1, r2, #2147483648	; 0x80000000
 802a964:	0dcb      	lsrs	r3, r1, #23
 802a966:	3b7f      	subs	r3, #127	; 0x7f
 802a968:	2b16      	cmp	r3, #22
 802a96a:	dc1e      	bgt.n	802a9aa <ceilf+0x52>
 802a96c:	2b00      	cmp	r3, #0
 802a96e:	4614      	mov	r4, r2
 802a970:	db2d      	blt.n	802a9ce <ceilf+0x76>
 802a972:	4824      	ldr	r0, [pc, #144]	; (802aa04 <ceilf+0xac>)
 802a974:	4118      	asrs	r0, r3
 802a976:	4210      	tst	r0, r2
 802a978:	d01a      	beq.n	802a9b0 <ceilf+0x58>
 802a97a:	eddf 7a23 	vldr	s15, [pc, #140]	; 802aa08 <ceilf+0xb0>
 802a97e:	ed9d 7a01 	vldr	s14, [sp, #4]
 802a982:	ee77 7a27 	vadd.f32	s15, s14, s15
 802a986:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 802a98a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802a98e:	dd32      	ble.n	802a9f6 <ceilf+0x9e>
 802a990:	2a00      	cmp	r2, #0
 802a992:	dd04      	ble.n	802a99e <ceilf+0x46>
 802a994:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
 802a998:	fa42 f303 	asr.w	r3, r2, r3
 802a99c:	441c      	add	r4, r3
 802a99e:	ea24 0000 	bic.w	r0, r4, r0
 802a9a2:	b003      	add	sp, #12
 802a9a4:	f85d 4b04 	ldr.w	r4, [sp], #4
 802a9a8:	4770      	bx	lr
 802a9aa:	f1b1 4fff 	cmp.w	r1, #2139095040	; 0x7f800000
 802a9ae:	d204      	bcs.n	802a9ba <ceilf+0x62>
 802a9b0:	9801      	ldr	r0, [sp, #4]
 802a9b2:	b003      	add	sp, #12
 802a9b4:	f85d 4b04 	ldr.w	r4, [sp], #4
 802a9b8:	4770      	bx	lr
 802a9ba:	eddd 7a01 	vldr	s15, [sp, #4]
 802a9be:	ee77 7aa7 	vadd.f32	s15, s15, s15
 802a9c2:	ee17 0a90 	vmov	r0, s15
 802a9c6:	b003      	add	sp, #12
 802a9c8:	f85d 4b04 	ldr.w	r4, [sp], #4
 802a9cc:	4770      	bx	lr
 802a9ce:	eddf 7a0e 	vldr	s15, [pc, #56]	; 802aa08 <ceilf+0xb0>
 802a9d2:	ee07 0a10 	vmov	s14, r0
 802a9d6:	ee77 7a27 	vadd.f32	s15, s14, s15
 802a9da:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 802a9de:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802a9e2:	dde5      	ble.n	802a9b0 <ceilf+0x58>
 802a9e4:	2a00      	cmp	r2, #0
 802a9e6:	db09      	blt.n	802a9fc <ceilf+0xa4>
 802a9e8:	2900      	cmp	r1, #0
 802a9ea:	eef7 7a00 	vmov.f32	s15, #112	; 0x70
 802a9ee:	bf18      	it	ne
 802a9f0:	ee17 0a90 	vmovne	r0, s15
 802a9f4:	e7dd      	b.n	802a9b2 <ceilf+0x5a>
 802a9f6:	ee17 0a10 	vmov	r0, s14
 802a9fa:	e7da      	b.n	802a9b2 <ceilf+0x5a>
 802a9fc:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
 802aa00:	e7d7      	b.n	802a9b2 <ceilf+0x5a>
 802aa02:	bf00      	nop
 802aa04:	007fffff 	.word	0x007fffff
 802aa08:	7149f2ca 	.word	0x7149f2ca

0802aa0c <acosf>:
 802aa0c:	b570      	push	{r4, r5, r6, lr}
 802aa0e:	4d25      	ldr	r5, [pc, #148]	; (802aaa4 <acosf+0x98>)
 802aa10:	b08a      	sub	sp, #40	; 0x28
 802aa12:	4606      	mov	r6, r0
 802aa14:	f000 fae8 	bl	802afe8 <__ieee754_acosf>
 802aa18:	f995 3000 	ldrsb.w	r3, [r5]
 802aa1c:	3301      	adds	r3, #1
 802aa1e:	4604      	mov	r4, r0
 802aa20:	d003      	beq.n	802aa2a <acosf+0x1e>
 802aa22:	4630      	mov	r0, r6
 802aa24:	f001 fc24 	bl	802c270 <__fpclassifyf>
 802aa28:	b910      	cbnz	r0, 802aa30 <acosf+0x24>
 802aa2a:	4620      	mov	r0, r4
 802aa2c:	b00a      	add	sp, #40	; 0x28
 802aa2e:	bd70      	pop	{r4, r5, r6, pc}
 802aa30:	4630      	mov	r0, r6
 802aa32:	f001 fc11 	bl	802c258 <fabsf>
 802aa36:	ee07 0a10 	vmov	s14, r0
 802aa3a:	eef7 7a00 	vmov.f32	s15, #112	; 0x70
 802aa3e:	eeb4 7ae7 	vcmpe.f32	s14, s15
 802aa42:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802aa46:	ddf0      	ble.n	802aa2a <acosf+0x1e>
 802aa48:	2301      	movs	r3, #1
 802aa4a:	4a17      	ldr	r2, [pc, #92]	; (802aaa8 <acosf+0x9c>)
 802aa4c:	9300      	str	r3, [sp, #0]
 802aa4e:	4630      	mov	r0, r6
 802aa50:	2300      	movs	r3, #0
 802aa52:	9201      	str	r2, [sp, #4]
 802aa54:	9308      	str	r3, [sp, #32]
 802aa56:	f001 ff33 	bl	802c8c0 <__aeabi_f2d>
 802aa5a:	4602      	mov	r2, r0
 802aa5c:	460b      	mov	r3, r1
 802aa5e:	4813      	ldr	r0, [pc, #76]	; (802aaac <acosf+0xa0>)
 802aa60:	e9cd 2304 	strd	r2, r3, [sp, #16]
 802aa64:	e9cd 2302 	strd	r2, r3, [sp, #8]
 802aa68:	f001 fa20 	bl	802beac <nan>
 802aa6c:	f995 3000 	ldrsb.w	r3, [r5]
 802aa70:	2b02      	cmp	r3, #2
 802aa72:	e9cd 0106 	strd	r0, r1, [sp, #24]
 802aa76:	d00b      	beq.n	802aa90 <acosf+0x84>
 802aa78:	4668      	mov	r0, sp
 802aa7a:	f001 fa15 	bl	802bea8 <matherr>
 802aa7e:	b138      	cbz	r0, 802aa90 <acosf+0x84>
 802aa80:	9b08      	ldr	r3, [sp, #32]
 802aa82:	b953      	cbnz	r3, 802aa9a <acosf+0x8e>
 802aa84:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 802aa88:	f002 fa28 	bl	802cedc <__aeabi_d2f>
 802aa8c:	b00a      	add	sp, #40	; 0x28
 802aa8e:	bd70      	pop	{r4, r5, r6, pc}
 802aa90:	f002 fd40 	bl	802d514 <__errno>
 802aa94:	2321      	movs	r3, #33	; 0x21
 802aa96:	6003      	str	r3, [r0, #0]
 802aa98:	e7f2      	b.n	802aa80 <acosf+0x74>
 802aa9a:	f002 fd3b 	bl	802d514 <__errno>
 802aa9e:	9b08      	ldr	r3, [sp, #32]
 802aaa0:	6003      	str	r3, [r0, #0]
 802aaa2:	e7ef      	b.n	802aa84 <acosf+0x78>
 802aaa4:	1ffe9640 	.word	0x1ffe9640
 802aaa8:	0802ff14 	.word	0x0802ff14
 802aaac:	0802d86c 	.word	0x0802d86c

0802aab0 <acoshf>:
 802aab0:	b5f0      	push	{r4, r5, r6, r7, lr}
 802aab2:	ed2d 8b02 	vpush	{d8}
 802aab6:	4d28      	ldr	r5, [pc, #160]	; (802ab58 <acoshf+0xa8>)
 802aab8:	b08b      	sub	sp, #44	; 0x2c
 802aaba:	ee08 0a10 	vmov	s16, r0
 802aabe:	f000 fbbd 	bl	802b23c <__ieee754_acoshf>
 802aac2:	f995 3000 	ldrsb.w	r3, [r5]
 802aac6:	3301      	adds	r3, #1
 802aac8:	4604      	mov	r4, r0
 802aaca:	d00b      	beq.n	802aae4 <acoshf+0x34>
 802aacc:	ee18 0a10 	vmov	r0, s16
 802aad0:	f001 fbce 	bl	802c270 <__fpclassifyf>
 802aad4:	b130      	cbz	r0, 802aae4 <acoshf+0x34>
 802aad6:	eef7 7a00 	vmov.f32	s15, #112	; 0x70
 802aada:	eeb4 8ae7 	vcmpe.f32	s16, s15
 802aade:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802aae2:	d404      	bmi.n	802aaee <acoshf+0x3e>
 802aae4:	4620      	mov	r0, r4
 802aae6:	b00b      	add	sp, #44	; 0x2c
 802aae8:	ecbd 8b02 	vpop	{d8}
 802aaec:	bdf0      	pop	{r4, r5, r6, r7, pc}
 802aaee:	2301      	movs	r3, #1
 802aaf0:	4a1a      	ldr	r2, [pc, #104]	; (802ab5c <acoshf+0xac>)
 802aaf2:	9300      	str	r3, [sp, #0]
 802aaf4:	ee18 0a10 	vmov	r0, s16
 802aaf8:	2300      	movs	r3, #0
 802aafa:	9201      	str	r2, [sp, #4]
 802aafc:	9308      	str	r3, [sp, #32]
 802aafe:	f001 fedf 	bl	802c8c0 <__aeabi_f2d>
 802ab02:	4606      	mov	r6, r0
 802ab04:	460f      	mov	r7, r1
 802ab06:	2000      	movs	r0, #0
 802ab08:	2100      	movs	r1, #0
 802ab0a:	460b      	mov	r3, r1
 802ab0c:	4602      	mov	r2, r0
 802ab0e:	e9cd 6704 	strd	r6, r7, [sp, #16]
 802ab12:	e9cd 6702 	strd	r6, r7, [sp, #8]
 802ab16:	f002 f851 	bl	802cbbc <__aeabi_ddiv>
 802ab1a:	f995 3000 	ldrsb.w	r3, [r5]
 802ab1e:	2b02      	cmp	r3, #2
 802ab20:	e9cd 0106 	strd	r0, r1, [sp, #24]
 802ab24:	d00d      	beq.n	802ab42 <acoshf+0x92>
 802ab26:	4668      	mov	r0, sp
 802ab28:	f001 f9be 	bl	802bea8 <matherr>
 802ab2c:	b148      	cbz	r0, 802ab42 <acoshf+0x92>
 802ab2e:	9b08      	ldr	r3, [sp, #32]
 802ab30:	b963      	cbnz	r3, 802ab4c <acoshf+0x9c>
 802ab32:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 802ab36:	f002 f9d1 	bl	802cedc <__aeabi_d2f>
 802ab3a:	b00b      	add	sp, #44	; 0x2c
 802ab3c:	ecbd 8b02 	vpop	{d8}
 802ab40:	bdf0      	pop	{r4, r5, r6, r7, pc}
 802ab42:	f002 fce7 	bl	802d514 <__errno>
 802ab46:	2321      	movs	r3, #33	; 0x21
 802ab48:	6003      	str	r3, [r0, #0]
 802ab4a:	e7f0      	b.n	802ab2e <acoshf+0x7e>
 802ab4c:	f002 fce2 	bl	802d514 <__errno>
 802ab50:	9b08      	ldr	r3, [sp, #32]
 802ab52:	6003      	str	r3, [r0, #0]
 802ab54:	e7ed      	b.n	802ab32 <acoshf+0x82>
 802ab56:	bf00      	nop
 802ab58:	1ffe9640 	.word	0x1ffe9640
 802ab5c:	0802ff1c 	.word	0x0802ff1c

0802ab60 <coshf>:
 802ab60:	b570      	push	{r4, r5, r6, lr}
 802ab62:	4d26      	ldr	r5, [pc, #152]	; (802abfc <coshf+0x9c>)
 802ab64:	b08a      	sub	sp, #40	; 0x28
 802ab66:	4606      	mov	r6, r0
 802ab68:	f000 fbd2 	bl	802b310 <__ieee754_coshf>
 802ab6c:	f995 3000 	ldrsb.w	r3, [r5]
 802ab70:	3301      	adds	r3, #1
 802ab72:	4604      	mov	r4, r0
 802ab74:	d003      	beq.n	802ab7e <coshf+0x1e>
 802ab76:	4630      	mov	r0, r6
 802ab78:	f001 fb7a 	bl	802c270 <__fpclassifyf>
 802ab7c:	b910      	cbnz	r0, 802ab84 <coshf+0x24>
 802ab7e:	4620      	mov	r0, r4
 802ab80:	b00a      	add	sp, #40	; 0x28
 802ab82:	bd70      	pop	{r4, r5, r6, pc}
 802ab84:	4630      	mov	r0, r6
 802ab86:	f001 fb67 	bl	802c258 <fabsf>
 802ab8a:	eddf 7a1d 	vldr	s15, [pc, #116]	; 802ac00 <coshf+0xa0>
 802ab8e:	ee07 0a10 	vmov	s14, r0
 802ab92:	eeb4 7ae7 	vcmpe.f32	s14, s15
 802ab96:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802ab9a:	ddf0      	ble.n	802ab7e <coshf+0x1e>
 802ab9c:	2303      	movs	r3, #3
 802ab9e:	4a19      	ldr	r2, [pc, #100]	; (802ac04 <coshf+0xa4>)
 802aba0:	9300      	str	r3, [sp, #0]
 802aba2:	4630      	mov	r0, r6
 802aba4:	2300      	movs	r3, #0
 802aba6:	9308      	str	r3, [sp, #32]
 802aba8:	9201      	str	r2, [sp, #4]
 802abaa:	f001 fe89 	bl	802c8c0 <__aeabi_f2d>
 802abae:	782b      	ldrb	r3, [r5, #0]
 802abb0:	e9cd 0104 	strd	r0, r1, [sp, #16]
 802abb4:	e9cd 0102 	strd	r0, r1, [sp, #8]
 802abb8:	b983      	cbnz	r3, 802abdc <coshf+0x7c>
 802abba:	4b13      	ldr	r3, [pc, #76]	; (802ac08 <coshf+0xa8>)
 802abbc:	f04f 4260 	mov.w	r2, #3758096384	; 0xe0000000
 802abc0:	e9cd 2306 	strd	r2, r3, [sp, #24]
 802abc4:	4668      	mov	r0, sp
 802abc6:	f001 f96f 	bl	802bea8 <matherr>
 802abca:	b168      	cbz	r0, 802abe8 <coshf+0x88>
 802abcc:	9b08      	ldr	r3, [sp, #32]
 802abce:	b983      	cbnz	r3, 802abf2 <coshf+0x92>
 802abd0:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 802abd4:	f002 f982 	bl	802cedc <__aeabi_d2f>
 802abd8:	b00a      	add	sp, #40	; 0x28
 802abda:	bd70      	pop	{r4, r5, r6, pc}
 802abdc:	490b      	ldr	r1, [pc, #44]	; (802ac0c <coshf+0xac>)
 802abde:	2000      	movs	r0, #0
 802abe0:	2b02      	cmp	r3, #2
 802abe2:	e9cd 0106 	strd	r0, r1, [sp, #24]
 802abe6:	d1ed      	bne.n	802abc4 <coshf+0x64>
 802abe8:	f002 fc94 	bl	802d514 <__errno>
 802abec:	2322      	movs	r3, #34	; 0x22
 802abee:	6003      	str	r3, [r0, #0]
 802abf0:	e7ec      	b.n	802abcc <coshf+0x6c>
 802abf2:	f002 fc8f 	bl	802d514 <__errno>
 802abf6:	9b08      	ldr	r3, [sp, #32]
 802abf8:	6003      	str	r3, [r0, #0]
 802abfa:	e7e9      	b.n	802abd0 <coshf+0x70>
 802abfc:	1ffe9640 	.word	0x1ffe9640
 802ac00:	42b2d4fc 	.word	0x42b2d4fc
 802ac04:	0802ff24 	.word	0x0802ff24
 802ac08:	47efffff 	.word	0x47efffff
 802ac0c:	7ff00000 	.word	0x7ff00000

0802ac10 <powf>:
 802ac10:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 802ac14:	4d9f      	ldr	r5, [pc, #636]	; (802ae94 <powf+0x284>)
 802ac16:	b08a      	sub	sp, #40	; 0x28
 802ac18:	4607      	mov	r7, r0
 802ac1a:	460e      	mov	r6, r1
 802ac1c:	f000 fde8 	bl	802b7f0 <__ieee754_powf>
 802ac20:	f995 3000 	ldrsb.w	r3, [r5]
 802ac24:	3301      	adds	r3, #1
 802ac26:	4604      	mov	r4, r0
 802ac28:	d003      	beq.n	802ac32 <powf+0x22>
 802ac2a:	4630      	mov	r0, r6
 802ac2c:	f001 fb20 	bl	802c270 <__fpclassifyf>
 802ac30:	b918      	cbnz	r0, 802ac3a <powf+0x2a>
 802ac32:	4620      	mov	r0, r4
 802ac34:	b00a      	add	sp, #40	; 0x28
 802ac36:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802ac3a:	4638      	mov	r0, r7
 802ac3c:	f001 fb18 	bl	802c270 <__fpclassifyf>
 802ac40:	4603      	mov	r3, r0
 802ac42:	2800      	cmp	r0, #0
 802ac44:	d132      	bne.n	802acac <powf+0x9c>
 802ac46:	ee07 6a90 	vmov	s15, r6
 802ac4a:	eef5 7a40 	vcmp.f32	s15, #0.0
 802ac4e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802ac52:	d1ee      	bne.n	802ac32 <powf+0x22>
 802ac54:	4a90      	ldr	r2, [pc, #576]	; (802ae98 <powf+0x288>)
 802ac56:	9308      	str	r3, [sp, #32]
 802ac58:	4638      	mov	r0, r7
 802ac5a:	2101      	movs	r1, #1
 802ac5c:	e88d 0006 	stmia.w	sp, {r1, r2}
 802ac60:	f001 fe2e 	bl	802c8c0 <__aeabi_f2d>
 802ac64:	e9cd 0102 	strd	r0, r1, [sp, #8]
 802ac68:	4630      	mov	r0, r6
 802ac6a:	f001 fe29 	bl	802c8c0 <__aeabi_f2d>
 802ac6e:	f995 3000 	ldrsb.w	r3, [r5]
 802ac72:	4f8a      	ldr	r7, [pc, #552]	; (802ae9c <powf+0x28c>)
 802ac74:	2600      	movs	r6, #0
 802ac76:	1c5a      	adds	r2, r3, #1
 802ac78:	e9cd 0104 	strd	r0, r1, [sp, #16]
 802ac7c:	e9cd 6706 	strd	r6, r7, [sp, #24]
 802ac80:	d00d      	beq.n	802ac9e <powf+0x8e>
 802ac82:	2b02      	cmp	r3, #2
 802ac84:	d00b      	beq.n	802ac9e <powf+0x8e>
 802ac86:	4668      	mov	r0, sp
 802ac88:	f001 f90e 	bl	802bea8 <matherr>
 802ac8c:	2800      	cmp	r0, #0
 802ac8e:	f000 809e 	beq.w	802adce <powf+0x1be>
 802ac92:	9b08      	ldr	r3, [sp, #32]
 802ac94:	b11b      	cbz	r3, 802ac9e <powf+0x8e>
 802ac96:	f002 fc3d 	bl	802d514 <__errno>
 802ac9a:	9b08      	ldr	r3, [sp, #32]
 802ac9c:	6003      	str	r3, [r0, #0]
 802ac9e:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 802aca2:	f002 f91b 	bl	802cedc <__aeabi_d2f>
 802aca6:	b00a      	add	sp, #40	; 0x28
 802aca8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802acac:	ee07 7a90 	vmov	s15, r7
 802acb0:	eef5 7a40 	vcmp.f32	s15, #0.0
 802acb4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802acb8:	d123      	bne.n	802ad02 <powf+0xf2>
 802acba:	ee07 6a90 	vmov	s15, r6
 802acbe:	eef5 7a40 	vcmp.f32	s15, #0.0
 802acc2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802acc6:	d156      	bne.n	802ad76 <powf+0x166>
 802acc8:	2301      	movs	r3, #1
 802acca:	4a73      	ldr	r2, [pc, #460]	; (802ae98 <powf+0x288>)
 802accc:	9300      	str	r3, [sp, #0]
 802acce:	4638      	mov	r0, r7
 802acd0:	2300      	movs	r3, #0
 802acd2:	9308      	str	r3, [sp, #32]
 802acd4:	9201      	str	r2, [sp, #4]
 802acd6:	f001 fdf3 	bl	802c8c0 <__aeabi_f2d>
 802acda:	e9cd 0102 	strd	r0, r1, [sp, #8]
 802acde:	4630      	mov	r0, r6
 802ace0:	f001 fdee 	bl	802c8c0 <__aeabi_f2d>
 802ace4:	f995 3000 	ldrsb.w	r3, [r5]
 802ace8:	2600      	movs	r6, #0
 802acea:	2700      	movs	r7, #0
 802acec:	e9cd 0104 	strd	r0, r1, [sp, #16]
 802acf0:	e9cd 6706 	strd	r6, r7, [sp, #24]
 802acf4:	2b00      	cmp	r3, #0
 802acf6:	d0c6      	beq.n	802ac86 <powf+0x76>
 802acf8:	4b68      	ldr	r3, [pc, #416]	; (802ae9c <powf+0x28c>)
 802acfa:	2200      	movs	r2, #0
 802acfc:	e9cd 2306 	strd	r2, r3, [sp, #24]
 802ad00:	e7cd      	b.n	802ac9e <powf+0x8e>
 802ad02:	4620      	mov	r0, r4
 802ad04:	f001 faac 	bl	802c260 <finitef>
 802ad08:	4680      	mov	r8, r0
 802ad0a:	2800      	cmp	r0, #0
 802ad0c:	d064      	beq.n	802add8 <powf+0x1c8>
 802ad0e:	ee07 4a90 	vmov	s15, r4
 802ad12:	eef5 7a40 	vcmp.f32	s15, #0.0
 802ad16:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802ad1a:	d18a      	bne.n	802ac32 <powf+0x22>
 802ad1c:	4638      	mov	r0, r7
 802ad1e:	f001 fa9f 	bl	802c260 <finitef>
 802ad22:	2800      	cmp	r0, #0
 802ad24:	d085      	beq.n	802ac32 <powf+0x22>
 802ad26:	4630      	mov	r0, r6
 802ad28:	f001 fa9a 	bl	802c260 <finitef>
 802ad2c:	2800      	cmp	r0, #0
 802ad2e:	d080      	beq.n	802ac32 <powf+0x22>
 802ad30:	2304      	movs	r3, #4
 802ad32:	4a59      	ldr	r2, [pc, #356]	; (802ae98 <powf+0x288>)
 802ad34:	9300      	str	r3, [sp, #0]
 802ad36:	4638      	mov	r0, r7
 802ad38:	2300      	movs	r3, #0
 802ad3a:	9308      	str	r3, [sp, #32]
 802ad3c:	9201      	str	r2, [sp, #4]
 802ad3e:	f001 fdbf 	bl	802c8c0 <__aeabi_f2d>
 802ad42:	e9cd 0102 	strd	r0, r1, [sp, #8]
 802ad46:	4630      	mov	r0, r6
 802ad48:	f001 fdba 	bl	802c8c0 <__aeabi_f2d>
 802ad4c:	f995 3000 	ldrsb.w	r3, [r5]
 802ad50:	2600      	movs	r6, #0
 802ad52:	2700      	movs	r7, #0
 802ad54:	2b02      	cmp	r3, #2
 802ad56:	e9cd 0104 	strd	r0, r1, [sp, #16]
 802ad5a:	e9cd 6706 	strd	r6, r7, [sp, #24]
 802ad5e:	f000 8094 	beq.w	802ae8a <powf+0x27a>
 802ad62:	4668      	mov	r0, sp
 802ad64:	f001 f8a0 	bl	802bea8 <matherr>
 802ad68:	2800      	cmp	r0, #0
 802ad6a:	f000 808e 	beq.w	802ae8a <powf+0x27a>
 802ad6e:	9b08      	ldr	r3, [sp, #32]
 802ad70:	2b00      	cmp	r3, #0
 802ad72:	d094      	beq.n	802ac9e <powf+0x8e>
 802ad74:	e78f      	b.n	802ac96 <powf+0x86>
 802ad76:	4630      	mov	r0, r6
 802ad78:	f001 fa72 	bl	802c260 <finitef>
 802ad7c:	2800      	cmp	r0, #0
 802ad7e:	f43f af58 	beq.w	802ac32 <powf+0x22>
 802ad82:	ee07 6a90 	vmov	s15, r6
 802ad86:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 802ad8a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802ad8e:	f57f af50 	bpl.w	802ac32 <powf+0x22>
 802ad92:	2301      	movs	r3, #1
 802ad94:	4a40      	ldr	r2, [pc, #256]	; (802ae98 <powf+0x288>)
 802ad96:	9300      	str	r3, [sp, #0]
 802ad98:	4638      	mov	r0, r7
 802ad9a:	2300      	movs	r3, #0
 802ad9c:	9308      	str	r3, [sp, #32]
 802ad9e:	9201      	str	r2, [sp, #4]
 802ada0:	f001 fd8e 	bl	802c8c0 <__aeabi_f2d>
 802ada4:	e9cd 0102 	strd	r0, r1, [sp, #8]
 802ada8:	4630      	mov	r0, r6
 802adaa:	f001 fd89 	bl	802c8c0 <__aeabi_f2d>
 802adae:	782b      	ldrb	r3, [r5, #0]
 802adb0:	e9cd 0104 	strd	r0, r1, [sp, #16]
 802adb4:	2b00      	cmp	r3, #0
 802adb6:	d03f      	beq.n	802ae38 <powf+0x228>
 802adb8:	4939      	ldr	r1, [pc, #228]	; (802aea0 <powf+0x290>)
 802adba:	2000      	movs	r0, #0
 802adbc:	2b02      	cmp	r3, #2
 802adbe:	e9cd 0106 	strd	r0, r1, [sp, #24]
 802adc2:	d133      	bne.n	802ae2c <powf+0x21c>
 802adc4:	f002 fba6 	bl	802d514 <__errno>
 802adc8:	2321      	movs	r3, #33	; 0x21
 802adca:	6003      	str	r3, [r0, #0]
 802adcc:	e7cf      	b.n	802ad6e <powf+0x15e>
 802adce:	f002 fba1 	bl	802d514 <__errno>
 802add2:	2321      	movs	r3, #33	; 0x21
 802add4:	6003      	str	r3, [r0, #0]
 802add6:	e75c      	b.n	802ac92 <powf+0x82>
 802add8:	4638      	mov	r0, r7
 802adda:	f001 fa41 	bl	802c260 <finitef>
 802adde:	2800      	cmp	r0, #0
 802ade0:	d095      	beq.n	802ad0e <powf+0xfe>
 802ade2:	4630      	mov	r0, r6
 802ade4:	f001 fa3c 	bl	802c260 <finitef>
 802ade8:	2800      	cmp	r0, #0
 802adea:	d090      	beq.n	802ad0e <powf+0xfe>
 802adec:	4620      	mov	r0, r4
 802adee:	f001 fa3f 	bl	802c270 <__fpclassifyf>
 802adf2:	4603      	mov	r3, r0
 802adf4:	bb28      	cbnz	r0, 802ae42 <powf+0x232>
 802adf6:	4a28      	ldr	r2, [pc, #160]	; (802ae98 <powf+0x288>)
 802adf8:	9308      	str	r3, [sp, #32]
 802adfa:	2101      	movs	r1, #1
 802adfc:	4638      	mov	r0, r7
 802adfe:	e88d 0006 	stmia.w	sp, {r1, r2}
 802ae02:	f001 fd5d 	bl	802c8c0 <__aeabi_f2d>
 802ae06:	e9cd 0102 	strd	r0, r1, [sp, #8]
 802ae0a:	4630      	mov	r0, r6
 802ae0c:	f001 fd58 	bl	802c8c0 <__aeabi_f2d>
 802ae10:	782c      	ldrb	r4, [r5, #0]
 802ae12:	e9cd 0104 	strd	r0, r1, [sp, #16]
 802ae16:	b17c      	cbz	r4, 802ae38 <powf+0x228>
 802ae18:	2000      	movs	r0, #0
 802ae1a:	2100      	movs	r1, #0
 802ae1c:	4602      	mov	r2, r0
 802ae1e:	460b      	mov	r3, r1
 802ae20:	f001 fecc 	bl	802cbbc <__aeabi_ddiv>
 802ae24:	2c02      	cmp	r4, #2
 802ae26:	e9cd 0106 	strd	r0, r1, [sp, #24]
 802ae2a:	d0cb      	beq.n	802adc4 <powf+0x1b4>
 802ae2c:	4668      	mov	r0, sp
 802ae2e:	f001 f83b 	bl	802bea8 <matherr>
 802ae32:	2800      	cmp	r0, #0
 802ae34:	d19b      	bne.n	802ad6e <powf+0x15e>
 802ae36:	e7c5      	b.n	802adc4 <powf+0x1b4>
 802ae38:	2200      	movs	r2, #0
 802ae3a:	2300      	movs	r3, #0
 802ae3c:	e9cd 2306 	strd	r2, r3, [sp, #24]
 802ae40:	e7f4      	b.n	802ae2c <powf+0x21c>
 802ae42:	4b15      	ldr	r3, [pc, #84]	; (802ae98 <powf+0x288>)
 802ae44:	f8cd 8020 	str.w	r8, [sp, #32]
 802ae48:	2203      	movs	r2, #3
 802ae4a:	4638      	mov	r0, r7
 802ae4c:	e88d 000c 	stmia.w	sp, {r2, r3}
 802ae50:	f001 fd36 	bl	802c8c0 <__aeabi_f2d>
 802ae54:	e9cd 0102 	strd	r0, r1, [sp, #8]
 802ae58:	4630      	mov	r0, r6
 802ae5a:	f001 fd31 	bl	802c8c0 <__aeabi_f2d>
 802ae5e:	f995 3000 	ldrsb.w	r3, [r5]
 802ae62:	e9cd 0104 	strd	r0, r1, [sp, #16]
 802ae66:	b9fb      	cbnz	r3, 802aea8 <powf+0x298>
 802ae68:	ee07 7a90 	vmov	s15, r7
 802ae6c:	4b0d      	ldr	r3, [pc, #52]	; (802aea4 <powf+0x294>)
 802ae6e:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 802ae72:	f04f 4260 	mov.w	r2, #3758096384	; 0xe0000000
 802ae76:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802ae7a:	e9cd 2306 	strd	r2, r3, [sp, #24]
 802ae7e:	d439      	bmi.n	802aef4 <powf+0x2e4>
 802ae80:	f995 3000 	ldrsb.w	r3, [r5]
 802ae84:	2b02      	cmp	r3, #2
 802ae86:	f47f af6c 	bne.w	802ad62 <powf+0x152>
 802ae8a:	f002 fb43 	bl	802d514 <__errno>
 802ae8e:	2322      	movs	r3, #34	; 0x22
 802ae90:	6003      	str	r3, [r0, #0]
 802ae92:	e76c      	b.n	802ad6e <powf+0x15e>
 802ae94:	1ffe9640 	.word	0x1ffe9640
 802ae98:	0802ff2c 	.word	0x0802ff2c
 802ae9c:	3ff00000 	.word	0x3ff00000
 802aea0:	fff00000 	.word	0xfff00000
 802aea4:	47efffff 	.word	0x47efffff
 802aea8:	ee07 7a90 	vmov	s15, r7
 802aeac:	4b1f      	ldr	r3, [pc, #124]	; (802af2c <powf+0x31c>)
 802aeae:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 802aeb2:	2200      	movs	r2, #0
 802aeb4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802aeb8:	e9cd 2306 	strd	r2, r3, [sp, #24]
 802aebc:	d5e0      	bpl.n	802ae80 <powf+0x270>
 802aebe:	ee07 6a10 	vmov	s14, r6
 802aec2:	eef6 7a00 	vmov.f32	s15, #96	; 0x60
 802aec6:	ee67 7a27 	vmul.f32	s15, s14, s15
 802aeca:	ee17 0a90 	vmov	r0, s15
 802aece:	f001 fcf7 	bl	802c8c0 <__aeabi_f2d>
 802aed2:	4606      	mov	r6, r0
 802aed4:	460f      	mov	r7, r1
 802aed6:	f000 ffef 	bl	802beb8 <rint>
 802aeda:	4602      	mov	r2, r0
 802aedc:	460b      	mov	r3, r1
 802aede:	4630      	mov	r0, r6
 802aee0:	4639      	mov	r1, r7
 802aee2:	f001 ffa9 	bl	802ce38 <__aeabi_dcmpeq>
 802aee6:	2800      	cmp	r0, #0
 802aee8:	d1ca      	bne.n	802ae80 <powf+0x270>
 802aeea:	4b11      	ldr	r3, [pc, #68]	; (802af30 <powf+0x320>)
 802aeec:	2200      	movs	r2, #0
 802aeee:	e9cd 2306 	strd	r2, r3, [sp, #24]
 802aef2:	e7c5      	b.n	802ae80 <powf+0x270>
 802aef4:	ee07 6a10 	vmov	s14, r6
 802aef8:	eef6 7a00 	vmov.f32	s15, #96	; 0x60
 802aefc:	ee67 7a27 	vmul.f32	s15, s14, s15
 802af00:	ee17 0a90 	vmov	r0, s15
 802af04:	f001 fcdc 	bl	802c8c0 <__aeabi_f2d>
 802af08:	4606      	mov	r6, r0
 802af0a:	460f      	mov	r7, r1
 802af0c:	f000 ffd4 	bl	802beb8 <rint>
 802af10:	4602      	mov	r2, r0
 802af12:	460b      	mov	r3, r1
 802af14:	4630      	mov	r0, r6
 802af16:	4639      	mov	r1, r7
 802af18:	f001 ff8e 	bl	802ce38 <__aeabi_dcmpeq>
 802af1c:	2800      	cmp	r0, #0
 802af1e:	d1af      	bne.n	802ae80 <powf+0x270>
 802af20:	4b04      	ldr	r3, [pc, #16]	; (802af34 <powf+0x324>)
 802af22:	f04f 4260 	mov.w	r2, #3758096384	; 0xe0000000
 802af26:	e9cd 2306 	strd	r2, r3, [sp, #24]
 802af2a:	e7a9      	b.n	802ae80 <powf+0x270>
 802af2c:	7ff00000 	.word	0x7ff00000
 802af30:	fff00000 	.word	0xfff00000
 802af34:	c7efffff 	.word	0xc7efffff

0802af38 <sqrtf>:
 802af38:	b530      	push	{r4, r5, lr}
 802af3a:	ed2d 8b02 	vpush	{d8}
 802af3e:	4d28      	ldr	r5, [pc, #160]	; (802afe0 <sqrtf+0xa8>)
 802af40:	b08b      	sub	sp, #44	; 0x2c
 802af42:	ee08 0a10 	vmov	s16, r0
 802af46:	f000 ff59 	bl	802bdfc <__ieee754_sqrtf>
 802af4a:	f995 3000 	ldrsb.w	r3, [r5]
 802af4e:	3301      	adds	r3, #1
 802af50:	4604      	mov	r4, r0
 802af52:	d009      	beq.n	802af68 <sqrtf+0x30>
 802af54:	ee18 0a10 	vmov	r0, s16
 802af58:	f001 f98a 	bl	802c270 <__fpclassifyf>
 802af5c:	b120      	cbz	r0, 802af68 <sqrtf+0x30>
 802af5e:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 802af62:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802af66:	d404      	bmi.n	802af72 <sqrtf+0x3a>
 802af68:	4620      	mov	r0, r4
 802af6a:	b00b      	add	sp, #44	; 0x2c
 802af6c:	ecbd 8b02 	vpop	{d8}
 802af70:	bd30      	pop	{r4, r5, pc}
 802af72:	2301      	movs	r3, #1
 802af74:	4a1b      	ldr	r2, [pc, #108]	; (802afe4 <sqrtf+0xac>)
 802af76:	9300      	str	r3, [sp, #0]
 802af78:	ee18 0a10 	vmov	r0, s16
 802af7c:	2300      	movs	r3, #0
 802af7e:	9201      	str	r2, [sp, #4]
 802af80:	9308      	str	r3, [sp, #32]
 802af82:	f001 fc9d 	bl	802c8c0 <__aeabi_f2d>
 802af86:	782c      	ldrb	r4, [r5, #0]
 802af88:	e9cd 0104 	strd	r0, r1, [sp, #16]
 802af8c:	e9cd 0102 	strd	r0, r1, [sp, #8]
 802af90:	b98c      	cbnz	r4, 802afb6 <sqrtf+0x7e>
 802af92:	2200      	movs	r2, #0
 802af94:	2300      	movs	r3, #0
 802af96:	e9cd 2306 	strd	r2, r3, [sp, #24]
 802af9a:	4668      	mov	r0, sp
 802af9c:	f000 ff84 	bl	802bea8 <matherr>
 802afa0:	b198      	cbz	r0, 802afca <sqrtf+0x92>
 802afa2:	9b08      	ldr	r3, [sp, #32]
 802afa4:	b9b3      	cbnz	r3, 802afd4 <sqrtf+0x9c>
 802afa6:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 802afaa:	f001 ff97 	bl	802cedc <__aeabi_d2f>
 802afae:	b00b      	add	sp, #44	; 0x2c
 802afb0:	ecbd 8b02 	vpop	{d8}
 802afb4:	bd30      	pop	{r4, r5, pc}
 802afb6:	2000      	movs	r0, #0
 802afb8:	2100      	movs	r1, #0
 802afba:	4602      	mov	r2, r0
 802afbc:	460b      	mov	r3, r1
 802afbe:	f001 fdfd 	bl	802cbbc <__aeabi_ddiv>
 802afc2:	2c02      	cmp	r4, #2
 802afc4:	e9cd 0106 	strd	r0, r1, [sp, #24]
 802afc8:	d1e7      	bne.n	802af9a <sqrtf+0x62>
 802afca:	f002 faa3 	bl	802d514 <__errno>
 802afce:	2321      	movs	r3, #33	; 0x21
 802afd0:	6003      	str	r3, [r0, #0]
 802afd2:	e7e6      	b.n	802afa2 <sqrtf+0x6a>
 802afd4:	f002 fa9e 	bl	802d514 <__errno>
 802afd8:	9b08      	ldr	r3, [sp, #32]
 802afda:	6003      	str	r3, [r0, #0]
 802afdc:	e7e3      	b.n	802afa6 <sqrtf+0x6e>
 802afde:	bf00      	nop
 802afe0:	1ffe9640 	.word	0x1ffe9640
 802afe4:	0802ff34 	.word	0x0802ff34

0802afe8 <__ieee754_acosf>:
 802afe8:	b508      	push	{r3, lr}
 802afea:	f020 4300 	bic.w	r3, r0, #2147483648	; 0x80000000
 802afee:	f1b3 5f7e 	cmp.w	r3, #1065353216	; 0x3f800000
 802aff2:	ed2d 8b02 	vpush	{d8}
 802aff6:	ee07 0a90 	vmov	s15, r0
 802affa:	d016      	beq.n	802b02a <__ieee754_acosf+0x42>
 802affc:	dc0c      	bgt.n	802b018 <__ieee754_acosf+0x30>
 802affe:	f1b3 5f7c 	cmp.w	r3, #1056964608	; 0x3f000000
 802b002:	da1f      	bge.n	802b044 <__ieee754_acosf+0x5c>
 802b004:	f1b3 5f0c 	cmp.w	r3, #587202560	; 0x23000000
 802b008:	dc70      	bgt.n	802b0ec <__ieee754_acosf+0x104>
 802b00a:	ecbd 8b02 	vpop	{d8}
 802b00e:	eddf 7a7a 	vldr	s15, [pc, #488]	; 802b1f8 <__ieee754_acosf+0x210>
 802b012:	ee17 0a90 	vmov	r0, s15
 802b016:	bd08      	pop	{r3, pc}
 802b018:	ee77 7ae7 	vsub.f32	s15, s15, s15
 802b01c:	eec7 7aa7 	vdiv.f32	s15, s15, s15
 802b020:	ecbd 8b02 	vpop	{d8}
 802b024:	ee17 0a90 	vmov	r0, s15
 802b028:	bd08      	pop	{r3, pc}
 802b02a:	ecbd 8b02 	vpop	{d8}
 802b02e:	eddf 7a73 	vldr	s15, [pc, #460]	; 802b1fc <__ieee754_acosf+0x214>
 802b032:	ed9f 7a73 	vldr	s14, [pc, #460]	; 802b200 <__ieee754_acosf+0x218>
 802b036:	2800      	cmp	r0, #0
 802b038:	bfd8      	it	le
 802b03a:	eef0 7a47 	vmovle.f32	s15, s14
 802b03e:	ee17 0a90 	vmov	r0, s15
 802b042:	bd08      	pop	{r3, pc}
 802b044:	2800      	cmp	r0, #0
 802b046:	f2c0 808e 	blt.w	802b166 <__ieee754_acosf+0x17e>
 802b04a:	eef7 8a00 	vmov.f32	s17, #112	; 0x70
 802b04e:	ee78 7ae7 	vsub.f32	s15, s17, s15
 802b052:	eeb6 8a00 	vmov.f32	s16, #96	; 0x60
 802b056:	ee27 8a88 	vmul.f32	s16, s15, s16
 802b05a:	ee18 0a10 	vmov	r0, s16
 802b05e:	f000 fecd 	bl	802bdfc <__ieee754_sqrtf>
 802b062:	ed9f 7a68 	vldr	s14, [pc, #416]	; 802b204 <__ieee754_acosf+0x21c>
 802b066:	ed9f 3a68 	vldr	s6, [pc, #416]	; 802b208 <__ieee754_acosf+0x220>
 802b06a:	ed9f 4a68 	vldr	s8, [pc, #416]	; 802b20c <__ieee754_acosf+0x224>
 802b06e:	eddf 2a68 	vldr	s5, [pc, #416]	; 802b210 <__ieee754_acosf+0x228>
 802b072:	eddf 3a68 	vldr	s7, [pc, #416]	; 802b214 <__ieee754_acosf+0x22c>
 802b076:	ed9f 5a68 	vldr	s10, [pc, #416]	; 802b218 <__ieee754_acosf+0x230>
 802b07a:	eddf 4a68 	vldr	s9, [pc, #416]	; 802b21c <__ieee754_acosf+0x234>
 802b07e:	eddf 6a68 	vldr	s13, [pc, #416]	; 802b220 <__ieee754_acosf+0x238>
 802b082:	eddf 5a68 	vldr	s11, [pc, #416]	; 802b224 <__ieee754_acosf+0x23c>
 802b086:	eddf 7a68 	vldr	s15, [pc, #416]	; 802b228 <__ieee754_acosf+0x240>
 802b08a:	eea8 3a07 	vfma.f32	s6, s16, s14
 802b08e:	f420 637f 	bic.w	r3, r0, #4080	; 0xff0
 802b092:	f023 030f 	bic.w	r3, r3, #15
 802b096:	eee8 3a22 	vfma.f32	s7, s16, s5
 802b09a:	eea3 4a08 	vfma.f32	s8, s6, s16
 802b09e:	eee3 4a88 	vfma.f32	s9, s7, s16
 802b0a2:	eea4 5a08 	vfma.f32	s10, s8, s16
 802b0a6:	eee4 5a88 	vfma.f32	s11, s9, s16
 802b0aa:	eee5 6a08 	vfma.f32	s13, s10, s16
 802b0ae:	ee07 3a10 	vmov	s14, r3
 802b0b2:	eee6 7a88 	vfma.f32	s15, s13, s16
 802b0b6:	eef0 6a48 	vmov.f32	s13, s16
 802b0ba:	ee06 0a10 	vmov	s12, r0
 802b0be:	eee5 8a88 	vfma.f32	s17, s11, s16
 802b0c2:	eee7 6a47 	vfms.f32	s13, s14, s14
 802b0c6:	ee67 7a88 	vmul.f32	s15, s15, s16
 802b0ca:	ee76 5a07 	vadd.f32	s11, s12, s14
 802b0ce:	ee87 8aa8 	vdiv.f32	s16, s15, s17
 802b0d2:	eec6 7aa5 	vdiv.f32	s15, s13, s11
 802b0d6:	eee8 7a06 	vfma.f32	s15, s16, s12
 802b0da:	ecbd 8b02 	vpop	{d8}
 802b0de:	ee77 7a27 	vadd.f32	s15, s14, s15
 802b0e2:	ee77 7aa7 	vadd.f32	s15, s15, s15
 802b0e6:	ee17 0a90 	vmov	r0, s15
 802b0ea:	bd08      	pop	{r3, pc}
 802b0ec:	ee27 7aa7 	vmul.f32	s14, s15, s15
 802b0f0:	ed9f 1a44 	vldr	s2, [pc, #272]	; 802b204 <__ieee754_acosf+0x21c>
 802b0f4:	eddf 2a44 	vldr	s5, [pc, #272]	; 802b208 <__ieee754_acosf+0x220>
 802b0f8:	eddf 3a44 	vldr	s7, [pc, #272]	; 802b20c <__ieee754_acosf+0x224>
 802b0fc:	eddf 1a44 	vldr	s3, [pc, #272]	; 802b210 <__ieee754_acosf+0x228>
 802b100:	ed9f 3a44 	vldr	s6, [pc, #272]	; 802b214 <__ieee754_acosf+0x22c>
 802b104:	eddf 5a44 	vldr	s11, [pc, #272]	; 802b218 <__ieee754_acosf+0x230>
 802b108:	ed9f 4a44 	vldr	s8, [pc, #272]	; 802b21c <__ieee754_acosf+0x234>
 802b10c:	eddf 4a44 	vldr	s9, [pc, #272]	; 802b220 <__ieee754_acosf+0x238>
 802b110:	ed9f 5a44 	vldr	s10, [pc, #272]	; 802b224 <__ieee754_acosf+0x23c>
 802b114:	eddf 6a44 	vldr	s13, [pc, #272]	; 802b228 <__ieee754_acosf+0x240>
 802b118:	ed9f 6a44 	vldr	s12, [pc, #272]	; 802b22c <__ieee754_acosf+0x244>
 802b11c:	ed9f 2a44 	vldr	s4, [pc, #272]	; 802b230 <__ieee754_acosf+0x248>
 802b120:	eee7 2a01 	vfma.f32	s5, s14, s2
 802b124:	ecbd 8b02 	vpop	{d8}
 802b128:	eee2 3a87 	vfma.f32	s7, s5, s14
 802b12c:	eea7 3a21 	vfma.f32	s6, s14, s3
 802b130:	eee3 5a87 	vfma.f32	s11, s7, s14
 802b134:	eea3 4a07 	vfma.f32	s8, s6, s14
 802b138:	eee5 4a87 	vfma.f32	s9, s11, s14
 802b13c:	eea4 5a07 	vfma.f32	s10, s8, s14
 802b140:	eee4 6a87 	vfma.f32	s13, s9, s14
 802b144:	eef7 5a00 	vmov.f32	s11, #112	; 0x70
 802b148:	eee5 5a07 	vfma.f32	s11, s10, s14
 802b14c:	ee26 7a87 	vmul.f32	s14, s13, s14
 802b150:	ee87 7a25 	vdiv.f32	s14, s14, s11
 802b154:	eea7 6ac7 	vfms.f32	s12, s15, s14
 802b158:	ee77 7ac6 	vsub.f32	s15, s15, s12
 802b15c:	ee72 7a67 	vsub.f32	s15, s4, s15
 802b160:	ee17 0a90 	vmov	r0, s15
 802b164:	bd08      	pop	{r3, pc}
 802b166:	eeb7 8a00 	vmov.f32	s16, #112	; 0x70
 802b16a:	ee77 7a88 	vadd.f32	s15, s15, s16
 802b16e:	eeb6 7a00 	vmov.f32	s14, #96	; 0x60
 802b172:	ee67 7a87 	vmul.f32	s15, s15, s14
 802b176:	eddf 2a23 	vldr	s5, [pc, #140]	; 802b204 <__ieee754_acosf+0x21c>
 802b17a:	eddf 3a23 	vldr	s7, [pc, #140]	; 802b208 <__ieee754_acosf+0x220>
 802b17e:	ed9f 3a24 	vldr	s6, [pc, #144]	; 802b210 <__ieee754_acosf+0x228>
 802b182:	eddf 4a22 	vldr	s9, [pc, #136]	; 802b20c <__ieee754_acosf+0x224>
 802b186:	ed9f 4a23 	vldr	s8, [pc, #140]	; 802b214 <__ieee754_acosf+0x22c>
 802b18a:	eddf 5a23 	vldr	s11, [pc, #140]	; 802b218 <__ieee754_acosf+0x230>
 802b18e:	ed9f 5a23 	vldr	s10, [pc, #140]	; 802b21c <__ieee754_acosf+0x234>
 802b192:	eddf 6a23 	vldr	s13, [pc, #140]	; 802b220 <__ieee754_acosf+0x238>
 802b196:	ed9f 6a23 	vldr	s12, [pc, #140]	; 802b224 <__ieee754_acosf+0x23c>
 802b19a:	ed9f 7a23 	vldr	s14, [pc, #140]	; 802b228 <__ieee754_acosf+0x240>
 802b19e:	eee7 3aa2 	vfma.f32	s7, s15, s5
 802b1a2:	eea7 4a83 	vfma.f32	s8, s15, s6
 802b1a6:	eee3 4aa7 	vfma.f32	s9, s7, s15
 802b1aa:	eea4 5a27 	vfma.f32	s10, s8, s15
 802b1ae:	eee4 5aa7 	vfma.f32	s11, s9, s15
 802b1b2:	eea5 6a27 	vfma.f32	s12, s10, s15
 802b1b6:	eee5 6aa7 	vfma.f32	s13, s11, s15
 802b1ba:	eea6 8a27 	vfma.f32	s16, s12, s15
 802b1be:	eea6 7aa7 	vfma.f32	s14, s13, s15
 802b1c2:	eef0 8a48 	vmov.f32	s17, s16
 802b1c6:	ee27 8a27 	vmul.f32	s16, s14, s15
 802b1ca:	ee17 0a90 	vmov	r0, s15
 802b1ce:	f000 fe15 	bl	802bdfc <__ieee754_sqrtf>
 802b1d2:	ee88 8a28 	vdiv.f32	s16, s16, s17
 802b1d6:	ee06 0a90 	vmov	s13, r0
 802b1da:	ed9f 7a16 	vldr	s14, [pc, #88]	; 802b234 <__ieee754_acosf+0x24c>
 802b1de:	eddf 7a16 	vldr	s15, [pc, #88]	; 802b238 <__ieee754_acosf+0x250>
 802b1e2:	eea8 7a26 	vfma.f32	s14, s16, s13
 802b1e6:	ee06 0a10 	vmov	s12, r0
 802b1ea:	ee37 7a06 	vadd.f32	s14, s14, s12
 802b1ee:	eef0 6a00 	vmov.f32	s13, #0
 802b1f2:	eee7 7a66 	vfms.f32	s15, s14, s13
 802b1f6:	e713      	b.n	802b020 <__ieee754_acosf+0x38>
 802b1f8:	3fc90fdb 	.word	0x3fc90fdb
 802b1fc:	00000000 	.word	0x00000000
 802b200:	40490fdb 	.word	0x40490fdb
 802b204:	3811ef08 	.word	0x3811ef08
 802b208:	3a4f7f04 	.word	0x3a4f7f04
 802b20c:	bd241146 	.word	0xbd241146
 802b210:	3d9dc62e 	.word	0x3d9dc62e
 802b214:	bf303361 	.word	0xbf303361
 802b218:	3e4e0aa8 	.word	0x3e4e0aa8
 802b21c:	4001572d 	.word	0x4001572d
 802b220:	bea6b090 	.word	0xbea6b090
 802b224:	c019d139 	.word	0xc019d139
 802b228:	3e2aaaab 	.word	0x3e2aaaab
 802b22c:	33a22168 	.word	0x33a22168
 802b230:	3fc90fda 	.word	0x3fc90fda
 802b234:	b3a22168 	.word	0xb3a22168
 802b238:	40490fda 	.word	0x40490fda

0802b23c <__ieee754_acoshf>:
 802b23c:	b508      	push	{r3, lr}
 802b23e:	f1b0 5f7e 	cmp.w	r0, #1065353216	; 0x3f800000
 802b242:	ed2d 8b02 	vpush	{d8}
 802b246:	ee08 0a10 	vmov	s16, r0
 802b24a:	db2c      	blt.n	802b2a6 <__ieee754_acoshf+0x6a>
 802b24c:	f1b0 4f9b 	cmp.w	r0, #1300234240	; 0x4d800000
 802b250:	db09      	blt.n	802b266 <__ieee754_acoshf+0x2a>
 802b252:	f1b0 4fff 	cmp.w	r0, #2139095040	; 0x7f800000
 802b256:	db4b      	blt.n	802b2f0 <__ieee754_acoshf+0xb4>
 802b258:	ee38 8a08 	vadd.f32	s16, s16, s16
 802b25c:	ee18 0a10 	vmov	r0, s16
 802b260:	ecbd 8b02 	vpop	{d8}
 802b264:	bd08      	pop	{r3, pc}
 802b266:	f1b0 5f7e 	cmp.w	r0, #1065353216	; 0x3f800000
 802b26a:	d04a      	beq.n	802b302 <__ieee754_acoshf+0xc6>
 802b26c:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 802b270:	dc22      	bgt.n	802b2b8 <__ieee754_acoshf+0x7c>
 802b272:	eef7 7a00 	vmov.f32	s15, #112	; 0x70
 802b276:	ee38 8a67 	vsub.f32	s16, s16, s15
 802b27a:	eeb0 7a00 	vmov.f32	s14, #0
 802b27e:	ee68 7a08 	vmul.f32	s15, s16, s16
 802b282:	eee8 7a07 	vfma.f32	s15, s16, s14
 802b286:	ee17 0a90 	vmov	r0, s15
 802b28a:	f000 fdb7 	bl	802bdfc <__ieee754_sqrtf>
 802b28e:	ee07 0a90 	vmov	s15, r0
 802b292:	ee77 7a88 	vadd.f32	s15, s15, s16
 802b296:	ecbd 8b02 	vpop	{d8}
 802b29a:	ee17 0a90 	vmov	r0, s15
 802b29e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 802b2a2:	f000 bfff 	b.w	802c2a4 <log1pf>
 802b2a6:	ee38 8a48 	vsub.f32	s16, s16, s16
 802b2aa:	ee88 8a08 	vdiv.f32	s16, s16, s16
 802b2ae:	ee18 0a10 	vmov	r0, s16
 802b2b2:	ecbd 8b02 	vpop	{d8}
 802b2b6:	bd08      	pop	{r3, pc}
 802b2b8:	eeff 7a00 	vmov.f32	s15, #240	; 0xf0
 802b2bc:	eee8 7a08 	vfma.f32	s15, s16, s16
 802b2c0:	ee17 0a90 	vmov	r0, s15
 802b2c4:	f000 fd9a 	bl	802bdfc <__ieee754_sqrtf>
 802b2c8:	ee07 0a90 	vmov	s15, r0
 802b2cc:	ee37 7a88 	vadd.f32	s14, s15, s16
 802b2d0:	eef7 7a00 	vmov.f32	s15, #112	; 0x70
 802b2d4:	eec7 7a87 	vdiv.f32	s15, s15, s14
 802b2d8:	eeb0 7a00 	vmov.f32	s14, #0
 802b2dc:	eed8 7a07 	vfnms.f32	s15, s16, s14
 802b2e0:	ecbd 8b02 	vpop	{d8}
 802b2e4:	ee17 0a90 	vmov	r0, s15
 802b2e8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 802b2ec:	f000 b96c 	b.w	802b5c8 <__ieee754_logf>
 802b2f0:	f000 f96a 	bl	802b5c8 <__ieee754_logf>
 802b2f4:	ed9f 8a04 	vldr	s16, [pc, #16]	; 802b308 <__ieee754_acoshf+0xcc>
 802b2f8:	ee07 0a90 	vmov	s15, r0
 802b2fc:	ee37 8a88 	vadd.f32	s16, s15, s16
 802b300:	e7ac      	b.n	802b25c <__ieee754_acoshf+0x20>
 802b302:	ed9f 8a02 	vldr	s16, [pc, #8]	; 802b30c <__ieee754_acoshf+0xd0>
 802b306:	e7a9      	b.n	802b25c <__ieee754_acoshf+0x20>
 802b308:	3f317218 	.word	0x3f317218
 802b30c:	00000000 	.word	0x00000000

0802b310 <__ieee754_coshf>:
 802b310:	b510      	push	{r4, lr}
 802b312:	ed2d 8b02 	vpush	{d8}
 802b316:	b082      	sub	sp, #8
 802b318:	9001      	str	r0, [sp, #4]
 802b31a:	9c01      	ldr	r4, [sp, #4]
 802b31c:	f024 4400 	bic.w	r4, r4, #2147483648	; 0x80000000
 802b320:	f1b4 4fff 	cmp.w	r4, #2139095040	; 0x7f800000
 802b324:	da15      	bge.n	802b352 <__ieee754_coshf+0x42>
 802b326:	4b32      	ldr	r3, [pc, #200]	; (802b3f0 <__ieee754_coshf+0xe0>)
 802b328:	429c      	cmp	r4, r3
 802b32a:	dd1c      	ble.n	802b366 <__ieee754_coshf+0x56>
 802b32c:	4b31      	ldr	r3, [pc, #196]	; (802b3f4 <__ieee754_coshf+0xe4>)
 802b32e:	429c      	cmp	r4, r3
 802b330:	dd2f      	ble.n	802b392 <__ieee754_coshf+0x82>
 802b332:	4b31      	ldr	r3, [pc, #196]	; (802b3f8 <__ieee754_coshf+0xe8>)
 802b334:	429c      	cmp	r4, r3
 802b336:	dd3b      	ble.n	802b3b0 <__ieee754_coshf+0xa0>
 802b338:	4b30      	ldr	r3, [pc, #192]	; (802b3fc <__ieee754_coshf+0xec>)
 802b33a:	429c      	cmp	r4, r3
 802b33c:	dd43      	ble.n	802b3c6 <__ieee754_coshf+0xb6>
 802b33e:	eddf 7a30 	vldr	s15, [pc, #192]	; 802b400 <__ieee754_coshf+0xf0>
 802b342:	ee67 7aa7 	vmul.f32	s15, s15, s15
 802b346:	ee17 0a90 	vmov	r0, s15
 802b34a:	b002      	add	sp, #8
 802b34c:	ecbd 8b02 	vpop	{d8}
 802b350:	bd10      	pop	{r4, pc}
 802b352:	ee07 0a90 	vmov	s15, r0
 802b356:	ee67 7aa7 	vmul.f32	s15, s15, s15
 802b35a:	ee17 0a90 	vmov	r0, s15
 802b35e:	b002      	add	sp, #8
 802b360:	ecbd 8b02 	vpop	{d8}
 802b364:	bd10      	pop	{r4, pc}
 802b366:	f000 ff77 	bl	802c258 <fabsf>
 802b36a:	f000 fe31 	bl	802bfd0 <expm1f>
 802b36e:	ee07 0a10 	vmov	s14, r0
 802b372:	eef7 6a00 	vmov.f32	s13, #112	; 0x70
 802b376:	f1b4 5f10 	cmp.w	r4, #603979776	; 0x24000000
 802b37a:	ee77 7a26 	vadd.f32	s15, s14, s13
 802b37e:	dbe2      	blt.n	802b346 <__ieee754_coshf+0x36>
 802b380:	ee27 7a07 	vmul.f32	s14, s14, s14
 802b384:	ee77 7aa7 	vadd.f32	s15, s15, s15
 802b388:	eec7 7a27 	vdiv.f32	s15, s14, s15
 802b38c:	ee77 7aa6 	vadd.f32	s15, s15, s13
 802b390:	e7d9      	b.n	802b346 <__ieee754_coshf+0x36>
 802b392:	f000 ff61 	bl	802c258 <fabsf>
 802b396:	f000 f835 	bl	802b404 <__ieee754_expf>
 802b39a:	ee07 0a90 	vmov	s15, r0
 802b39e:	eeb6 7a00 	vmov.f32	s14, #96	; 0x60
 802b3a2:	eec7 7a27 	vdiv.f32	s15, s14, s15
 802b3a6:	ee06 0a90 	vmov	s13, r0
 802b3aa:	eee6 7a87 	vfma.f32	s15, s13, s14
 802b3ae:	e7ca      	b.n	802b346 <__ieee754_coshf+0x36>
 802b3b0:	f000 ff52 	bl	802c258 <fabsf>
 802b3b4:	f000 f826 	bl	802b404 <__ieee754_expf>
 802b3b8:	ee07 0a10 	vmov	s14, r0
 802b3bc:	eef6 7a00 	vmov.f32	s15, #96	; 0x60
 802b3c0:	ee67 7a27 	vmul.f32	s15, s14, s15
 802b3c4:	e7bf      	b.n	802b346 <__ieee754_coshf+0x36>
 802b3c6:	f000 ff47 	bl	802c258 <fabsf>
 802b3ca:	ee07 0a90 	vmov	s15, r0
 802b3ce:	eeb6 8a00 	vmov.f32	s16, #96	; 0x60
 802b3d2:	ee67 7a88 	vmul.f32	s15, s15, s16
 802b3d6:	ee17 0a90 	vmov	r0, s15
 802b3da:	f000 f813 	bl	802b404 <__ieee754_expf>
 802b3de:	ee07 0a90 	vmov	s15, r0
 802b3e2:	ee07 0a10 	vmov	s14, r0
 802b3e6:	ee67 7a88 	vmul.f32	s15, s15, s16
 802b3ea:	ee67 7a87 	vmul.f32	s15, s15, s14
 802b3ee:	e7aa      	b.n	802b346 <__ieee754_coshf+0x36>
 802b3f0:	3eb17217 	.word	0x3eb17217
 802b3f4:	41afffff 	.word	0x41afffff
 802b3f8:	42b17217 	.word	0x42b17217
 802b3fc:	42b2d4fc 	.word	0x42b2d4fc
 802b400:	7149f2ca 	.word	0x7149f2ca

0802b404 <__ieee754_expf>:
 802b404:	f020 4200 	bic.w	r2, r0, #2147483648	; 0x80000000
 802b408:	f1b2 4fff 	cmp.w	r2, #2139095040	; 0x7f800000
 802b40c:	ee07 0a90 	vmov	s15, r0
 802b410:	4603      	mov	r3, r0
 802b412:	d859      	bhi.n	802b4c8 <__ieee754_expf+0xc4>
 802b414:	ea4f 71d0 	mov.w	r1, r0, lsr #31
 802b418:	d05b      	beq.n	802b4d2 <__ieee754_expf+0xce>
 802b41a:	4859      	ldr	r0, [pc, #356]	; (802b580 <__ieee754_expf+0x17c>)
 802b41c:	4283      	cmp	r3, r0
 802b41e:	dc7a      	bgt.n	802b516 <__ieee754_expf+0x112>
 802b420:	2b00      	cmp	r3, #0
 802b422:	db70      	blt.n	802b506 <__ieee754_expf+0x102>
 802b424:	4b57      	ldr	r3, [pc, #348]	; (802b584 <__ieee754_expf+0x180>)
 802b426:	429a      	cmp	r2, r3
 802b428:	d95c      	bls.n	802b4e4 <__ieee754_expf+0xe0>
 802b42a:	4b57      	ldr	r3, [pc, #348]	; (802b588 <__ieee754_expf+0x184>)
 802b42c:	429a      	cmp	r2, r3
 802b42e:	f200 8086 	bhi.w	802b53e <__ieee754_expf+0x13a>
 802b432:	4856      	ldr	r0, [pc, #344]	; (802b58c <__ieee754_expf+0x188>)
 802b434:	4a56      	ldr	r2, [pc, #344]	; (802b590 <__ieee754_expf+0x18c>)
 802b436:	008b      	lsls	r3, r1, #2
 802b438:	4418      	add	r0, r3
 802b43a:	ed90 7a00 	vldr	s14, [r0]
 802b43e:	441a      	add	r2, r3
 802b440:	ee77 3ac7 	vsub.f32	s7, s15, s14
 802b444:	f1c1 0301 	rsb	r3, r1, #1
 802b448:	ed92 6a00 	vldr	s12, [r2]
 802b44c:	1a5b      	subs	r3, r3, r1
 802b44e:	ee73 7ac6 	vsub.f32	s15, s7, s12
 802b452:	ee67 6aa7 	vmul.f32	s13, s15, s15
 802b456:	ed9f 7a4f 	vldr	s14, [pc, #316]	; 802b594 <__ieee754_expf+0x190>
 802b45a:	ed9f 4a4f 	vldr	s8, [pc, #316]	; 802b598 <__ieee754_expf+0x194>
 802b45e:	eddf 4a4f 	vldr	s9, [pc, #316]	; 802b59c <__ieee754_expf+0x198>
 802b462:	ed9f 5a4f 	vldr	s10, [pc, #316]	; 802b5a0 <__ieee754_expf+0x19c>
 802b466:	eddf 5a4f 	vldr	s11, [pc, #316]	; 802b5a4 <__ieee754_expf+0x1a0>
 802b46a:	eea6 4a87 	vfma.f32	s8, s13, s14
 802b46e:	eeb0 7a67 	vmov.f32	s14, s15
 802b472:	eee4 4a26 	vfma.f32	s9, s8, s13
 802b476:	eea4 5aa6 	vfma.f32	s10, s9, s13
 802b47a:	eee5 5a26 	vfma.f32	s11, s10, s13
 802b47e:	eea5 7ae6 	vfms.f32	s14, s11, s13
 802b482:	eef0 6a47 	vmov.f32	s13, s14
 802b486:	eeb0 7a00 	vmov.f32	s14, #0
 802b48a:	2b00      	cmp	r3, #0
 802b48c:	d04a      	beq.n	802b524 <__ieee754_expf+0x120>
 802b48e:	ee67 7aa6 	vmul.f32	s15, s15, s13
 802b492:	ee77 6a66 	vsub.f32	s13, s14, s13
 802b496:	eef7 5a00 	vmov.f32	s11, #112	; 0x70
 802b49a:	ee87 7aa6 	vdiv.f32	s14, s15, s13
 802b49e:	f113 0f7d 	cmn.w	r3, #125	; 0x7d
 802b4a2:	ee36 6a47 	vsub.f32	s12, s12, s14
 802b4a6:	ee36 7a63 	vsub.f32	s14, s12, s7
 802b4aa:	ee75 7ac7 	vsub.f32	s15, s11, s14
 802b4ae:	da60      	bge.n	802b572 <__ieee754_expf+0x16e>
 802b4b0:	ee17 2a90 	vmov	r2, s15
 802b4b4:	3364      	adds	r3, #100	; 0x64
 802b4b6:	eb02 53c3 	add.w	r3, r2, r3, lsl #23
 802b4ba:	eddf 6a3b 	vldr	s13, [pc, #236]	; 802b5a8 <__ieee754_expf+0x1a4>
 802b4be:	ee07 3a90 	vmov	s15, r3
 802b4c2:	ee67 7aa6 	vmul.f32	s15, s15, s13
 802b4c6:	e001      	b.n	802b4cc <__ieee754_expf+0xc8>
 802b4c8:	ee77 7aa7 	vadd.f32	s15, s15, s15
 802b4cc:	ee17 0a90 	vmov	r0, s15
 802b4d0:	4770      	bx	lr
 802b4d2:	ed9f 7a36 	vldr	s14, [pc, #216]	; 802b5ac <__ieee754_expf+0x1a8>
 802b4d6:	2900      	cmp	r1, #0
 802b4d8:	bf18      	it	ne
 802b4da:	eef0 7a47 	vmovne.f32	s15, s14
 802b4de:	ee17 0a90 	vmov	r0, s15
 802b4e2:	4770      	bx	lr
 802b4e4:	f1b2 5f46 	cmp.w	r2, #830472192	; 0x31800000
 802b4e8:	d213      	bcs.n	802b512 <__ieee754_expf+0x10e>
 802b4ea:	ed9f 7a31 	vldr	s14, [pc, #196]	; 802b5b0 <__ieee754_expf+0x1ac>
 802b4ee:	ee37 7a87 	vadd.f32	s14, s15, s14
 802b4f2:	eef7 6a00 	vmov.f32	s13, #112	; 0x70
 802b4f6:	eeb4 7ae6 	vcmpe.f32	s14, s13
 802b4fa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802b4fe:	dd08      	ble.n	802b512 <__ieee754_expf+0x10e>
 802b500:	ee77 7aa6 	vadd.f32	s15, s15, s13
 802b504:	e7e2      	b.n	802b4cc <__ieee754_expf+0xc8>
 802b506:	4b2b      	ldr	r3, [pc, #172]	; (802b5b4 <__ieee754_expf+0x1b0>)
 802b508:	429a      	cmp	r2, r3
 802b50a:	d98b      	bls.n	802b424 <__ieee754_expf+0x20>
 802b50c:	eddf 7a27 	vldr	s15, [pc, #156]	; 802b5ac <__ieee754_expf+0x1a8>
 802b510:	e7dc      	b.n	802b4cc <__ieee754_expf+0xc8>
 802b512:	2300      	movs	r3, #0
 802b514:	e79d      	b.n	802b452 <__ieee754_expf+0x4e>
 802b516:	eddf 7a26 	vldr	s15, [pc, #152]	; 802b5b0 <__ieee754_expf+0x1ac>
 802b51a:	ee67 7aa7 	vmul.f32	s15, s15, s15
 802b51e:	ee17 0a90 	vmov	r0, s15
 802b522:	4770      	bx	lr
 802b524:	ee36 7ac7 	vsub.f32	s14, s13, s14
 802b528:	ee67 6aa6 	vmul.f32	s13, s15, s13
 802b52c:	eeb7 6a00 	vmov.f32	s12, #112	; 0x70
 802b530:	eec6 6a87 	vdiv.f32	s13, s13, s14
 802b534:	ee76 7ae7 	vsub.f32	s15, s13, s15
 802b538:	ee76 7a67 	vsub.f32	s15, s12, s15
 802b53c:	e7c6      	b.n	802b4cc <__ieee754_expf+0xc8>
 802b53e:	4b1e      	ldr	r3, [pc, #120]	; (802b5b8 <__ieee754_expf+0x1b4>)
 802b540:	eddf 6a1e 	vldr	s13, [pc, #120]	; 802b5bc <__ieee754_expf+0x1b8>
 802b544:	eddf 5a1e 	vldr	s11, [pc, #120]	; 802b5c0 <__ieee754_expf+0x1bc>
 802b548:	ed9f 6a1e 	vldr	s12, [pc, #120]	; 802b5c4 <__ieee754_expf+0x1c0>
 802b54c:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 802b550:	ed93 7a00 	vldr	s14, [r3]
 802b554:	eea7 7aa6 	vfma.f32	s14, s15, s13
 802b558:	eebd 7ac7 	vcvt.s32.f32	s14, s14
 802b55c:	eef8 6ac7 	vcvt.f32.s32	s13, s14
 802b560:	ee17 3a10 	vmov	r3, s14
 802b564:	eee6 7ae5 	vfms.f32	s15, s13, s11
 802b568:	ee26 6a86 	vmul.f32	s12, s13, s12
 802b56c:	eef0 3a67 	vmov.f32	s7, s15
 802b570:	e76d      	b.n	802b44e <__ieee754_expf+0x4a>
 802b572:	ee17 2a90 	vmov	r2, s15
 802b576:	eb02 53c3 	add.w	r3, r2, r3, lsl #23
 802b57a:	ee07 3a90 	vmov	s15, r3
 802b57e:	e7a5      	b.n	802b4cc <__ieee754_expf+0xc8>
 802b580:	42b17217 	.word	0x42b17217
 802b584:	3eb17218 	.word	0x3eb17218
 802b588:	3f851591 	.word	0x3f851591
 802b58c:	0802ff4c 	.word	0x0802ff4c
 802b590:	0802ff44 	.word	0x0802ff44
 802b594:	3331bb4c 	.word	0x3331bb4c
 802b598:	b5ddea0e 	.word	0xb5ddea0e
 802b59c:	388ab355 	.word	0x388ab355
 802b5a0:	bb360b61 	.word	0xbb360b61
 802b5a4:	3e2aaaab 	.word	0x3e2aaaab
 802b5a8:	0d800000 	.word	0x0d800000
 802b5ac:	00000000 	.word	0x00000000
 802b5b0:	7149f2ca 	.word	0x7149f2ca
 802b5b4:	42cff1b5 	.word	0x42cff1b5
 802b5b8:	0802ff3c 	.word	0x0802ff3c
 802b5bc:	3fb8aa3b 	.word	0x3fb8aa3b
 802b5c0:	3f317180 	.word	0x3f317180
 802b5c4:	3717f7d1 	.word	0x3717f7d1

0802b5c8 <__ieee754_logf>:
 802b5c8:	b430      	push	{r4, r5}
 802b5ca:	b082      	sub	sp, #8
 802b5cc:	9001      	str	r0, [sp, #4]
 802b5ce:	9b01      	ldr	r3, [sp, #4]
 802b5d0:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
 802b5d4:	b372      	cbz	r2, 802b634 <__ieee754_logf+0x6c>
 802b5d6:	2b00      	cmp	r3, #0
 802b5d8:	db42      	blt.n	802b660 <__ieee754_logf+0x98>
 802b5da:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
 802b5de:	da4c      	bge.n	802b67a <__ieee754_logf+0xb2>
 802b5e0:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 802b5e4:	db31      	blt.n	802b64a <__ieee754_logf+0x82>
 802b5e6:	2200      	movs	r2, #0
 802b5e8:	4972      	ldr	r1, [pc, #456]	; (802b7b4 <__ieee754_logf+0x1ec>)
 802b5ea:	f3c3 0516 	ubfx	r5, r3, #0, #23
 802b5ee:	4429      	add	r1, r5
 802b5f0:	f401 0100 	and.w	r1, r1, #8388608	; 0x800000
 802b5f4:	15db      	asrs	r3, r3, #23
 802b5f6:	3b7f      	subs	r3, #127	; 0x7f
 802b5f8:	f081 547e 	eor.w	r4, r1, #1065353216	; 0x3f800000
 802b5fc:	4413      	add	r3, r2
 802b5fe:	f105 000f 	add.w	r0, r5, #15
 802b602:	ea44 0205 	orr.w	r2, r4, r5
 802b606:	ee07 2a90 	vmov	s15, r2
 802b60a:	f3c0 0216 	ubfx	r2, r0, #0, #23
 802b60e:	eeb7 7a00 	vmov.f32	s14, #112	; 0x70
 802b612:	2a0f      	cmp	r2, #15
 802b614:	eb03 53d1 	add.w	r3, r3, r1, lsr #23
 802b618:	ee37 7ac7 	vsub.f32	s14, s15, s14
 802b61c:	dc36      	bgt.n	802b68c <__ieee754_logf+0xc4>
 802b61e:	eeb5 7a40 	vcmp.f32	s14, #0.0
 802b622:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802b626:	d172      	bne.n	802b70e <__ieee754_logf+0x146>
 802b628:	2b00      	cmp	r3, #0
 802b62a:	f040 809e 	bne.w	802b76a <__ieee754_logf+0x1a2>
 802b62e:	eddf 7a62 	vldr	s15, [pc, #392]	; 802b7b8 <__ieee754_logf+0x1f0>
 802b632:	e005      	b.n	802b640 <__ieee754_logf+0x78>
 802b634:	eddf 7a61 	vldr	s15, [pc, #388]	; 802b7bc <__ieee754_logf+0x1f4>
 802b638:	ed9f 7a5f 	vldr	s14, [pc, #380]	; 802b7b8 <__ieee754_logf+0x1f0>
 802b63c:	eec7 7a87 	vdiv.f32	s15, s15, s14
 802b640:	ee17 0a90 	vmov	r0, s15
 802b644:	b002      	add	sp, #8
 802b646:	bc30      	pop	{r4, r5}
 802b648:	4770      	bx	lr
 802b64a:	eddf 7a5d 	vldr	s15, [pc, #372]	; 802b7c0 <__ieee754_logf+0x1f8>
 802b64e:	ed9d 7a01 	vldr	s14, [sp, #4]
 802b652:	ee67 7a27 	vmul.f32	s15, s14, s15
 802b656:	f06f 0218 	mvn.w	r2, #24
 802b65a:	ee17 3a90 	vmov	r3, s15
 802b65e:	e7c3      	b.n	802b5e8 <__ieee754_logf+0x20>
 802b660:	eddd 7a01 	vldr	s15, [sp, #4]
 802b664:	ed9f 7a54 	vldr	s14, [pc, #336]	; 802b7b8 <__ieee754_logf+0x1f0>
 802b668:	ee77 7ae7 	vsub.f32	s15, s15, s15
 802b66c:	eec7 7a87 	vdiv.f32	s15, s15, s14
 802b670:	ee17 0a90 	vmov	r0, s15
 802b674:	b002      	add	sp, #8
 802b676:	bc30      	pop	{r4, r5}
 802b678:	4770      	bx	lr
 802b67a:	eddd 7a01 	vldr	s15, [sp, #4]
 802b67e:	ee77 7aa7 	vadd.f32	s15, s15, s15
 802b682:	ee17 0a90 	vmov	r0, s15
 802b686:	b002      	add	sp, #8
 802b688:	bc30      	pop	{r4, r5}
 802b68a:	4770      	bx	lr
 802b68c:	eeb0 6a00 	vmov.f32	s12, #0
 802b690:	ee37 6a06 	vadd.f32	s12, s14, s12
 802b694:	ee06 3a90 	vmov	s13, r3
 802b698:	ee87 6a06 	vdiv.f32	s12, s14, s12
 802b69c:	4a49      	ldr	r2, [pc, #292]	; (802b7c4 <__ieee754_logf+0x1fc>)
 802b69e:	f5c5 1157 	rsb	r1, r5, #3522560	; 0x35c000
 802b6a2:	442a      	add	r2, r5
 802b6a4:	f501 7122 	add.w	r1, r1, #648	; 0x288
 802b6a8:	430a      	orrs	r2, r1
 802b6aa:	2a00      	cmp	r2, #0
 802b6ac:	ed9f 2a46 	vldr	s4, [pc, #280]	; 802b7c8 <__ieee754_logf+0x200>
 802b6b0:	eddf 3a46 	vldr	s7, [pc, #280]	; 802b7cc <__ieee754_logf+0x204>
 802b6b4:	eddf 4a46 	vldr	s9, [pc, #280]	; 802b7d0 <__ieee754_logf+0x208>
 802b6b8:	eddf 2a46 	vldr	s5, [pc, #280]	; 802b7d4 <__ieee754_logf+0x20c>
 802b6bc:	ed9f 4a46 	vldr	s8, [pc, #280]	; 802b7d8 <__ieee754_logf+0x210>
 802b6c0:	eddf 7a46 	vldr	s15, [pc, #280]	; 802b7dc <__ieee754_logf+0x214>
 802b6c4:	eddf 5a46 	vldr	s11, [pc, #280]	; 802b7e0 <__ieee754_logf+0x218>
 802b6c8:	ee26 5a06 	vmul.f32	s10, s12, s12
 802b6cc:	eeb8 3ae6 	vcvt.f32.s32	s6, s13
 802b6d0:	ee65 6a05 	vmul.f32	s13, s10, s10
 802b6d4:	eee6 3a82 	vfma.f32	s7, s13, s4
 802b6d8:	eea6 4aa2 	vfma.f32	s8, s13, s5
 802b6dc:	eee3 4aa6 	vfma.f32	s9, s7, s13
 802b6e0:	eee4 5a26 	vfma.f32	s11, s8, s13
 802b6e4:	eee4 7aa6 	vfma.f32	s15, s9, s13
 802b6e8:	ee67 7a85 	vmul.f32	s15, s15, s10
 802b6ec:	eee5 7aa6 	vfma.f32	s15, s11, s13
 802b6f0:	dd48      	ble.n	802b784 <__ieee754_logf+0x1bc>
 802b6f2:	eef6 5a00 	vmov.f32	s11, #96	; 0x60
 802b6f6:	ee67 5a25 	vmul.f32	s11, s14, s11
 802b6fa:	ee65 5a87 	vmul.f32	s11, s11, s14
 802b6fe:	b9a3      	cbnz	r3, 802b72a <__ieee754_logf+0x162>
 802b700:	ee75 6aa7 	vadd.f32	s13, s11, s15
 802b704:	eee6 5ac6 	vfms.f32	s11, s13, s12
 802b708:	ee77 7a65 	vsub.f32	s15, s14, s11
 802b70c:	e798      	b.n	802b640 <__ieee754_logf+0x78>
 802b70e:	eddf 6a35 	vldr	s13, [pc, #212]	; 802b7e4 <__ieee754_logf+0x21c>
 802b712:	eef6 7a00 	vmov.f32	s15, #96	; 0x60
 802b716:	eee7 7a66 	vfms.f32	s15, s14, s13
 802b71a:	ee67 6a07 	vmul.f32	s13, s14, s14
 802b71e:	ee66 7aa7 	vmul.f32	s15, s13, s15
 802b722:	b99b      	cbnz	r3, 802b74c <__ieee754_logf+0x184>
 802b724:	ee77 7a67 	vsub.f32	s15, s14, s15
 802b728:	e78a      	b.n	802b640 <__ieee754_logf+0x78>
 802b72a:	ed9f 5a2f 	vldr	s10, [pc, #188]	; 802b7e8 <__ieee754_logf+0x220>
 802b72e:	eddf 4a2f 	vldr	s9, [pc, #188]	; 802b7ec <__ieee754_logf+0x224>
 802b732:	ee75 6aa7 	vadd.f32	s13, s11, s15
 802b736:	ee63 7a05 	vmul.f32	s15, s6, s10
 802b73a:	eee6 7a86 	vfma.f32	s15, s13, s12
 802b73e:	ee75 7ae7 	vsub.f32	s15, s11, s15
 802b742:	ee77 7ac7 	vsub.f32	s15, s15, s14
 802b746:	eed3 7a24 	vfnms.f32	s15, s6, s9
 802b74a:	e779      	b.n	802b640 <__ieee754_logf+0x78>
 802b74c:	ee06 3a90 	vmov	s13, r3
 802b750:	eddf 5a25 	vldr	s11, [pc, #148]	; 802b7e8 <__ieee754_logf+0x220>
 802b754:	ed9f 6a25 	vldr	s12, [pc, #148]	; 802b7ec <__ieee754_logf+0x224>
 802b758:	eef8 6ae6 	vcvt.f32.s32	s13, s13
 802b75c:	eee6 7ae5 	vfms.f32	s15, s13, s11
 802b760:	ee77 7ac7 	vsub.f32	s15, s15, s14
 802b764:	eed6 7a86 	vfnms.f32	s15, s13, s12
 802b768:	e76a      	b.n	802b640 <__ieee754_logf+0x78>
 802b76a:	ee07 3a90 	vmov	s15, r3
 802b76e:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 802b772:	eddf 7a1d 	vldr	s15, [pc, #116]	; 802b7e8 <__ieee754_logf+0x220>
 802b776:	eddf 6a1d 	vldr	s13, [pc, #116]	; 802b7ec <__ieee754_logf+0x224>
 802b77a:	ee67 7a27 	vmul.f32	s15, s14, s15
 802b77e:	eee7 7a26 	vfma.f32	s15, s14, s13
 802b782:	e75d      	b.n	802b640 <__ieee754_logf+0x78>
 802b784:	b173      	cbz	r3, 802b7a4 <__ieee754_logf+0x1dc>
 802b786:	eddf 5a18 	vldr	s11, [pc, #96]	; 802b7e8 <__ieee754_logf+0x220>
 802b78a:	ed9f 5a18 	vldr	s10, [pc, #96]	; 802b7ec <__ieee754_logf+0x224>
 802b78e:	ee77 6a67 	vsub.f32	s13, s14, s15
 802b792:	ee65 7ac3 	vnmul.f32	s15, s11, s6
 802b796:	eee6 7a86 	vfma.f32	s15, s13, s12
 802b79a:	ee77 7ac7 	vsub.f32	s15, s15, s14
 802b79e:	eed3 7a05 	vfnms.f32	s15, s6, s10
 802b7a2:	e74d      	b.n	802b640 <__ieee754_logf+0x78>
 802b7a4:	ee77 7a67 	vsub.f32	s15, s14, s15
 802b7a8:	eea7 7ac6 	vfms.f32	s14, s15, s12
 802b7ac:	eef0 7a47 	vmov.f32	s15, s14
 802b7b0:	e746      	b.n	802b640 <__ieee754_logf+0x78>
 802b7b2:	bf00      	nop
 802b7b4:	004afb20 	.word	0x004afb20
 802b7b8:	00000000 	.word	0x00000000
 802b7bc:	cc000000 	.word	0xcc000000
 802b7c0:	4c000000 	.word	0x4c000000
 802b7c4:	ffcf5c30 	.word	0xffcf5c30
 802b7c8:	3e178897 	.word	0x3e178897
 802b7cc:	3e3a3325 	.word	0x3e3a3325
 802b7d0:	3e924925 	.word	0x3e924925
 802b7d4:	3e1cd04f 	.word	0x3e1cd04f
 802b7d8:	3e638e29 	.word	0x3e638e29
 802b7dc:	3f2aaaab 	.word	0x3f2aaaab
 802b7e0:	3ecccccd 	.word	0x3ecccccd
 802b7e4:	3eaaaaab 	.word	0x3eaaaaab
 802b7e8:	3717f7d1 	.word	0x3717f7d1
 802b7ec:	3f317180 	.word	0x3f317180

0802b7f0 <__ieee754_powf>:
 802b7f0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 802b7f4:	ed2d 8b02 	vpush	{d8}
 802b7f8:	f031 4600 	bics.w	r6, r1, #2147483648	; 0x80000000
 802b7fc:	b083      	sub	sp, #12
 802b7fe:	460c      	mov	r4, r1
 802b800:	d014      	beq.n	802b82c <__ieee754_powf+0x3c>
 802b802:	f020 4700 	bic.w	r7, r0, #2147483648	; 0x80000000
 802b806:	f1b7 4fff 	cmp.w	r7, #2139095040	; 0x7f800000
 802b80a:	4605      	mov	r5, r0
 802b80c:	4680      	mov	r8, r0
 802b80e:	dd07      	ble.n	802b820 <__ieee754_powf+0x30>
 802b810:	4857      	ldr	r0, [pc, #348]	; (802b970 <__ieee754_powf+0x180>)
 802b812:	b003      	add	sp, #12
 802b814:	ecbd 8b02 	vpop	{d8}
 802b818:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
 802b81c:	f000 be62 	b.w	802c4e4 <nanf>
 802b820:	f1b6 4fff 	cmp.w	r6, #2139095040	; 0x7f800000
 802b824:	dd09      	ble.n	802b83a <__ieee754_powf+0x4a>
 802b826:	f1b7 5f7e 	cmp.w	r7, #1065353216	; 0x3f800000
 802b82a:	d1f1      	bne.n	802b810 <__ieee754_powf+0x20>
 802b82c:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 802b830:	b003      	add	sp, #12
 802b832:	ecbd 8b02 	vpop	{d8}
 802b836:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 802b83a:	2800      	cmp	r0, #0
 802b83c:	db5a      	blt.n	802b8f4 <__ieee754_powf+0x104>
 802b83e:	f04f 0900 	mov.w	r9, #0
 802b842:	f1b6 4fff 	cmp.w	r6, #2139095040	; 0x7f800000
 802b846:	d04d      	beq.n	802b8e4 <__ieee754_powf+0xf4>
 802b848:	f1b6 5f7e 	cmp.w	r6, #1065353216	; 0x3f800000
 802b84c:	d065      	beq.n	802b91a <__ieee754_powf+0x12a>
 802b84e:	f1b4 4f80 	cmp.w	r4, #1073741824	; 0x40000000
 802b852:	d06e      	beq.n	802b932 <__ieee754_powf+0x142>
 802b854:	f1b4 5f7c 	cmp.w	r4, #1056964608	; 0x3f000000
 802b858:	d01f      	beq.n	802b89a <__ieee754_powf+0xaa>
 802b85a:	4628      	mov	r0, r5
 802b85c:	9101      	str	r1, [sp, #4]
 802b85e:	f000 fcfb 	bl	802c258 <fabsf>
 802b862:	f1b7 4fff 	cmp.w	r7, #2139095040	; 0x7f800000
 802b866:	ee07 0a90 	vmov	s15, r0
 802b86a:	d031      	beq.n	802b8d0 <__ieee754_powf+0xe0>
 802b86c:	9901      	ldr	r1, [sp, #4]
 802b86e:	b37f      	cbz	r7, 802b8d0 <__ieee754_powf+0xe0>
 802b870:	f1b7 5f7e 	cmp.w	r7, #1065353216	; 0x3f800000
 802b874:	d02c      	beq.n	802b8d0 <__ieee754_powf+0xe0>
 802b876:	ea4f 73d8 	mov.w	r3, r8, lsr #31
 802b87a:	3b01      	subs	r3, #1
 802b87c:	ea59 0203 	orrs.w	r2, r9, r3
 802b880:	d066      	beq.n	802b950 <__ieee754_powf+0x160>
 802b882:	f1b6 4f9a 	cmp.w	r6, #1291845632	; 0x4d000000
 802b886:	dd79      	ble.n	802b97c <__ieee754_powf+0x18c>
 802b888:	4a3a      	ldr	r2, [pc, #232]	; (802b974 <__ieee754_powf+0x184>)
 802b88a:	4297      	cmp	r7, r2
 802b88c:	f300 81dc 	bgt.w	802bc48 <__ieee754_powf+0x458>
 802b890:	2c00      	cmp	r4, #0
 802b892:	f2c0 81e0 	blt.w	802bc56 <__ieee754_powf+0x466>
 802b896:	2000      	movs	r0, #0
 802b898:	e7ca      	b.n	802b830 <__ieee754_powf+0x40>
 802b89a:	f1b8 0f00 	cmp.w	r8, #0
 802b89e:	da4f      	bge.n	802b940 <__ieee754_powf+0x150>
 802b8a0:	4628      	mov	r0, r5
 802b8a2:	9101      	str	r1, [sp, #4]
 802b8a4:	f000 fcd8 	bl	802c258 <fabsf>
 802b8a8:	f1b7 4fff 	cmp.w	r7, #2139095040	; 0x7f800000
 802b8ac:	ee07 0a90 	vmov	s15, r0
 802b8b0:	9901      	ldr	r1, [sp, #4]
 802b8b2:	d001      	beq.n	802b8b8 <__ieee754_powf+0xc8>
 802b8b4:	2f00      	cmp	r7, #0
 802b8b6:	d1db      	bne.n	802b870 <__ieee754_powf+0x80>
 802b8b8:	f1a7 577e 	sub.w	r7, r7, #1065353216	; 0x3f800000
 802b8bc:	ea59 0307 	orrs.w	r3, r9, r7
 802b8c0:	d048      	beq.n	802b954 <__ieee754_powf+0x164>
 802b8c2:	f1b9 0f01 	cmp.w	r9, #1
 802b8c6:	f000 81ba 	beq.w	802bc3e <__ieee754_powf+0x44e>
 802b8ca:	ee17 0a90 	vmov	r0, s15
 802b8ce:	e7af      	b.n	802b830 <__ieee754_powf+0x40>
 802b8d0:	2c00      	cmp	r4, #0
 802b8d2:	bfbc      	itt	lt
 802b8d4:	eeb7 7a00 	vmovlt.f32	s14, #112	; 0x70
 802b8d8:	eec7 7a27 	vdivlt.f32	s15, s14, s15
 802b8dc:	f1b8 0f00 	cmp.w	r8, #0
 802b8e0:	daf3      	bge.n	802b8ca <__ieee754_powf+0xda>
 802b8e2:	e7e9      	b.n	802b8b8 <__ieee754_powf+0xc8>
 802b8e4:	f1b7 5f7e 	cmp.w	r7, #1065353216	; 0x3f800000
 802b8e8:	d0a0      	beq.n	802b82c <__ieee754_powf+0x3c>
 802b8ea:	dd1d      	ble.n	802b928 <__ieee754_powf+0x138>
 802b8ec:	2c00      	cmp	r4, #0
 802b8ee:	dbd2      	blt.n	802b896 <__ieee754_powf+0xa6>
 802b8f0:	4608      	mov	r0, r1
 802b8f2:	e79d      	b.n	802b830 <__ieee754_powf+0x40>
 802b8f4:	f1b6 4f97 	cmp.w	r6, #1266679808	; 0x4b800000
 802b8f8:	da13      	bge.n	802b922 <__ieee754_powf+0x132>
 802b8fa:	f1b6 5f7e 	cmp.w	r6, #1065353216	; 0x3f800000
 802b8fe:	db09      	blt.n	802b914 <__ieee754_powf+0x124>
 802b900:	15f3      	asrs	r3, r6, #23
 802b902:	f1c3 0396 	rsb	r3, r3, #150	; 0x96
 802b906:	fa46 f203 	asr.w	r2, r6, r3
 802b90a:	fa02 f303 	lsl.w	r3, r2, r3
 802b90e:	42b3      	cmp	r3, r6
 802b910:	f000 8190 	beq.w	802bc34 <__ieee754_powf+0x444>
 802b914:	f04f 0900 	mov.w	r9, #0
 802b918:	e796      	b.n	802b848 <__ieee754_powf+0x58>
 802b91a:	2c00      	cmp	r4, #0
 802b91c:	db1f      	blt.n	802b95e <__ieee754_powf+0x16e>
 802b91e:	4628      	mov	r0, r5
 802b920:	e786      	b.n	802b830 <__ieee754_powf+0x40>
 802b922:	f04f 0902 	mov.w	r9, #2
 802b926:	e78c      	b.n	802b842 <__ieee754_powf+0x52>
 802b928:	2c00      	cmp	r4, #0
 802b92a:	dab4      	bge.n	802b896 <__ieee754_powf+0xa6>
 802b92c:	f081 4000 	eor.w	r0, r1, #2147483648	; 0x80000000
 802b930:	e77e      	b.n	802b830 <__ieee754_powf+0x40>
 802b932:	ee07 5a90 	vmov	s15, r5
 802b936:	ee67 7aa7 	vmul.f32	s15, s15, s15
 802b93a:	ee17 0a90 	vmov	r0, s15
 802b93e:	e777      	b.n	802b830 <__ieee754_powf+0x40>
 802b940:	4628      	mov	r0, r5
 802b942:	b003      	add	sp, #12
 802b944:	ecbd 8b02 	vpop	{d8}
 802b948:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
 802b94c:	f000 ba56 	b.w	802bdfc <__ieee754_sqrtf>
 802b950:	ee07 5a90 	vmov	s15, r5
 802b954:	ee77 7ae7 	vsub.f32	s15, s15, s15
 802b958:	eec7 7aa7 	vdiv.f32	s15, s15, s15
 802b95c:	e7b5      	b.n	802b8ca <__ieee754_powf+0xda>
 802b95e:	ee07 5a10 	vmov	s14, r5
 802b962:	eef7 7a00 	vmov.f32	s15, #112	; 0x70
 802b966:	eec7 7a87 	vdiv.f32	s15, s15, s14
 802b96a:	ee17 0a90 	vmov	r0, s15
 802b96e:	e75f      	b.n	802b830 <__ieee754_powf+0x40>
 802b970:	0802d86c 	.word	0x0802d86c
 802b974:	3f7ffff7 	.word	0x3f7ffff7
 802b978:	4b800000 	.word	0x4b800000
 802b97c:	f5b7 0f00 	cmp.w	r7, #8388608	; 0x800000
 802b980:	f280 8173 	bge.w	802bc6a <__ieee754_powf+0x47a>
 802b984:	ed1f 7a04 	vldr	s14, [pc, #-16]	; 802b978 <__ieee754_powf+0x188>
 802b988:	ee67 7a87 	vmul.f32	s15, s15, s14
 802b98c:	f06f 0017 	mvn.w	r0, #23
 802b990:	ee17 7a90 	vmov	r7, s15
 802b994:	4dde      	ldr	r5, [pc, #888]	; (802bd10 <__ieee754_powf+0x520>)
 802b996:	15fa      	asrs	r2, r7, #23
 802b998:	f3c7 0716 	ubfx	r7, r7, #0, #23
 802b99c:	3a7f      	subs	r2, #127	; 0x7f
 802b99e:	42af      	cmp	r7, r5
 802b9a0:	4402      	add	r2, r0
 802b9a2:	f047 507e 	orr.w	r0, r7, #1065353216	; 0x3f800000
 802b9a6:	f340 815d 	ble.w	802bc64 <__ieee754_powf+0x474>
 802b9aa:	4dda      	ldr	r5, [pc, #872]	; (802bd14 <__ieee754_powf+0x524>)
 802b9ac:	42af      	cmp	r7, r5
 802b9ae:	f340 81ab 	ble.w	802bd08 <__ieee754_powf+0x518>
 802b9b2:	2600      	movs	r6, #0
 802b9b4:	3201      	adds	r2, #1
 802b9b6:	f5a0 0000 	sub.w	r0, r0, #8388608	; 0x800000
 802b9ba:	4635      	mov	r5, r6
 802b9bc:	f8df c3b4 	ldr.w	ip, [pc, #948]	; 802bd74 <__ieee754_powf+0x584>
 802b9c0:	eddf 2ad5 	vldr	s5, [pc, #852]	; 802bd18 <__ieee754_powf+0x528>
 802b9c4:	ed9f 0ad5 	vldr	s0, [pc, #852]	; 802bd1c <__ieee754_powf+0x52c>
 802b9c8:	eddf 0ad5 	vldr	s1, [pc, #852]	; 802bd20 <__ieee754_powf+0x530>
 802b9cc:	ed9f 1aeb 	vldr	s2, [pc, #940]	; 802bd7c <__ieee754_powf+0x58c>
 802b9d0:	eddf 1ad4 	vldr	s3, [pc, #848]	; 802bd24 <__ieee754_powf+0x534>
 802b9d4:	ed9f 2ad4 	vldr	s4, [pc, #848]	; 802bd28 <__ieee754_powf+0x538>
 802b9d8:	eddf 7ad4 	vldr	s15, [pc, #848]	; 802bd2c <__ieee754_powf+0x53c>
 802b9dc:	ed9f 3ad4 	vldr	s6, [pc, #848]	; 802bd30 <__ieee754_powf+0x540>
 802b9e0:	4fd4      	ldr	r7, [pc, #848]	; (802bd34 <__ieee754_powf+0x544>)
 802b9e2:	ed9f 4ad5 	vldr	s8, [pc, #852]	; 802bd38 <__ieee754_powf+0x548>
 802b9e6:	f8df e390 	ldr.w	lr, [pc, #912]	; 802bd78 <__ieee754_powf+0x588>
 802b9ea:	00ad      	lsls	r5, r5, #2
 802b9ec:	44ac      	add	ip, r5
 802b9ee:	ee07 0a10 	vmov	s14, r0
 802b9f2:	ed9c 6a00 	vldr	s12, [ip]
 802b9f6:	ee77 5a06 	vadd.f32	s11, s14, s12
 802b9fa:	eef7 6a00 	vmov.f32	s13, #112	; 0x70
 802b9fe:	eec6 5aa5 	vdiv.f32	s11, s13, s11
 802ba02:	1040      	asrs	r0, r0, #1
 802ba04:	f040 5000 	orr.w	r0, r0, #536870912	; 0x20000000
 802ba08:	f500 2080 	add.w	r0, r0, #262144	; 0x40000
 802ba0c:	4430      	add	r0, r6
 802ba0e:	ee04 0a90 	vmov	s9, r0
 802ba12:	ee77 6a46 	vsub.f32	s13, s14, s12
 802ba16:	ee34 6ac6 	vsub.f32	s12, s9, s12
 802ba1a:	ee66 3aa5 	vmul.f32	s7, s13, s11
 802ba1e:	ee37 7a46 	vsub.f32	s14, s14, s12
 802ba22:	ee23 6aa3 	vmul.f32	s12, s7, s7
 802ba26:	ee13 6a90 	vmov	r6, s7
 802ba2a:	eea6 0a22 	vfma.f32	s0, s12, s5
 802ba2e:	f426 667f 	bic.w	r6, r6, #4080	; 0xff0
 802ba32:	f026 060f 	bic.w	r6, r6, #15
 802ba36:	ee05 6a10 	vmov	s10, r6
 802ba3a:	eee0 0a06 	vfma.f32	s1, s0, s12
 802ba3e:	1978      	adds	r0, r7, r5
 802ba40:	4475      	add	r5, lr
 802ba42:	eef1 2a45 	vneg.f32	s5, s10
 802ba46:	eee2 6aa4 	vfma.f32	s13, s5, s9
 802ba4a:	eef0 4a41 	vmov.f32	s9, s2
 802ba4e:	eee0 4a86 	vfma.f32	s9, s1, s12
 802ba52:	eee2 6a87 	vfma.f32	s13, s5, s14
 802ba56:	eee4 1a86 	vfma.f32	s3, s9, s12
 802ba5a:	ee66 5aa5 	vmul.f32	s11, s13, s11
 802ba5e:	eef0 6a42 	vmov.f32	s13, s4
 802ba62:	eee1 6a86 	vfma.f32	s13, s3, s12
 802ba66:	ee33 7a85 	vadd.f32	s14, s7, s10
 802ba6a:	ee26 6a06 	vmul.f32	s12, s12, s12
 802ba6e:	ee27 7a25 	vmul.f32	s14, s14, s11
 802ba72:	eef0 4a08 	vmov.f32	s9, #8
 802ba76:	eea6 7a26 	vfma.f32	s14, s12, s13
 802ba7a:	eef0 6a64 	vmov.f32	s13, s9
 802ba7e:	eee5 6a05 	vfma.f32	s13, s10, s10
 802ba82:	edd0 1a00 	vldr	s3, [r0]
 802ba86:	ed95 2a00 	vldr	s4, [r5]
 802ba8a:	ee36 6a87 	vadd.f32	s12, s13, s14
 802ba8e:	ee06 2a90 	vmov	s13, r2
 802ba92:	ee16 2a10 	vmov	r2, s12
 802ba96:	f422 627f 	bic.w	r2, r2, #4080	; 0xff0
 802ba9a:	f022 020f 	bic.w	r2, r2, #15
 802ba9e:	ee06 2a10 	vmov	s12, r2
 802baa2:	ee76 4a64 	vsub.f32	s9, s12, s9
 802baa6:	eef8 6ae6 	vcvt.f32.s32	s13, s13
 802baaa:	eee2 4a85 	vfma.f32	s9, s5, s10
 802baae:	ee37 7a64 	vsub.f32	s14, s14, s9
 802bab2:	ee27 7a23 	vmul.f32	s14, s14, s7
 802bab6:	eea5 7a86 	vfma.f32	s14, s11, s12
 802baba:	eef0 5a47 	vmov.f32	s11, s14
 802babe:	eee5 5a06 	vfma.f32	s11, s10, s12
 802bac2:	ee15 2a90 	vmov	r2, s11
 802bac6:	f422 627f 	bic.w	r2, r2, #4080	; 0xff0
 802baca:	f022 020f 	bic.w	r2, r2, #15
 802bace:	ee05 2a10 	vmov	s10, r2
 802bad2:	eea2 5a86 	vfma.f32	s10, s5, s12
 802bad6:	ee05 2a90 	vmov	s11, r2
 802bada:	ee37 7a45 	vsub.f32	s14, s14, s10
 802bade:	ee67 7a27 	vmul.f32	s15, s14, s15
 802bae2:	eee5 7a83 	vfma.f32	s15, s11, s6
 802bae6:	ee77 7aa1 	vadd.f32	s15, s15, s3
 802baea:	eeb0 7a67 	vmov.f32	s14, s15
 802baee:	eea5 7a84 	vfma.f32	s14, s11, s8
 802baf2:	ee37 7a02 	vadd.f32	s14, s14, s4
 802baf6:	ee37 7a26 	vadd.f32	s14, s14, s13
 802bafa:	ee17 2a10 	vmov	r2, s14
 802bafe:	f422 627f 	bic.w	r2, r2, #4080	; 0xff0
 802bb02:	f022 020f 	bic.w	r2, r2, #15
 802bb06:	ee07 2a10 	vmov	s14, r2
 802bb0a:	ee77 6a66 	vsub.f32	s13, s14, s13
 802bb0e:	ee36 7ac2 	vsub.f32	s14, s13, s4
 802bb12:	eea5 7ac4 	vfms.f32	s14, s11, s8
 802bb16:	ee77 7ac7 	vsub.f32	s15, s15, s14
 802bb1a:	f424 647f 	bic.w	r4, r4, #4080	; 0xff0
 802bb1e:	f024 040f 	bic.w	r4, r4, #15
 802bb22:	ee07 1a10 	vmov	s14, r1
 802bb26:	ee06 4a90 	vmov	s13, r4
 802bb2a:	ee67 7a27 	vmul.f32	s15, s14, s15
 802bb2e:	ee77 6a66 	vsub.f32	s13, s14, s13
 802bb32:	ee06 4a10 	vmov	s12, r4
 802bb36:	ee07 2a10 	vmov	s14, r2
 802bb3a:	ee27 7a06 	vmul.f32	s14, s14, s12
 802bb3e:	ee06 2a10 	vmov	s12, r2
 802bb42:	eee6 7a86 	vfma.f32	s15, s13, s12
 802bb46:	f109 39ff 	add.w	r9, r9, #4294967295
 802bb4a:	ea59 0303 	orrs.w	r3, r9, r3
 802bb4e:	eeb7 8a00 	vmov.f32	s16, #112	; 0x70
 802bb52:	ee77 6a87 	vadd.f32	s13, s15, s14
 802bb56:	eebf 6a00 	vmov.f32	s12, #240	; 0xf0
 802bb5a:	ee16 3a90 	vmov	r3, s13
 802bb5e:	bf08      	it	eq
 802bb60:	eeb0 8a46 	vmoveq.f32	s16, s12
 802bb64:	2b00      	cmp	r3, #0
 802bb66:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
 802bb6a:	f340 80b8 	ble.w	802bcde <__ieee754_powf+0x4ee>
 802bb6e:	f1b2 4f86 	cmp.w	r2, #1124073472	; 0x43000000
 802bb72:	f300 8087 	bgt.w	802bc84 <__ieee754_powf+0x494>
 802bb76:	d07a      	beq.n	802bc6e <__ieee754_powf+0x47e>
 802bb78:	f1b2 5f7c 	cmp.w	r2, #1056964608	; 0x3f000000
 802bb7c:	f300 808b 	bgt.w	802bc96 <__ieee754_powf+0x4a6>
 802bb80:	2200      	movs	r2, #0
 802bb82:	4611      	mov	r1, r2
 802bb84:	f423 637f 	bic.w	r3, r3, #4080	; 0xff0
 802bb88:	f023 030f 	bic.w	r3, r3, #15
 802bb8c:	ee06 3a10 	vmov	s12, r3
 802bb90:	eddf 6a6a 	vldr	s13, [pc, #424]	; 802bd3c <__ieee754_powf+0x54c>
 802bb94:	eddf 5a6a 	vldr	s11, [pc, #424]	; 802bd40 <__ieee754_powf+0x550>
 802bb98:	ed9f 3a6a 	vldr	s6, [pc, #424]	; 802bd44 <__ieee754_powf+0x554>
 802bb9c:	ed9f 2a6a 	vldr	s4, [pc, #424]	; 802bd48 <__ieee754_powf+0x558>
 802bba0:	eddf 3a6a 	vldr	s7, [pc, #424]	; 802bd4c <__ieee754_powf+0x55c>
 802bba4:	ed9f 4a6a 	vldr	s8, [pc, #424]	; 802bd50 <__ieee754_powf+0x560>
 802bba8:	eddf 4a6a 	vldr	s9, [pc, #424]	; 802bd54 <__ieee754_powf+0x564>
 802bbac:	ed9f 5a6a 	vldr	s10, [pc, #424]	; 802bd58 <__ieee754_powf+0x568>
 802bbb0:	ee36 7a47 	vsub.f32	s14, s12, s14
 802bbb4:	eef0 2a00 	vmov.f32	s5, #0
 802bbb8:	ee77 7ac7 	vsub.f32	s15, s15, s14
 802bbbc:	ee26 7a26 	vmul.f32	s14, s12, s13
 802bbc0:	eea7 7aa5 	vfma.f32	s14, s15, s11
 802bbc4:	eef7 5a00 	vmov.f32	s11, #112	; 0x70
 802bbc8:	eef0 6a47 	vmov.f32	s13, s14
 802bbcc:	eee6 6a03 	vfma.f32	s13, s12, s6
 802bbd0:	eef0 7a47 	vmov.f32	s15, s14
 802bbd4:	ee26 7aa6 	vmul.f32	s14, s13, s13
 802bbd8:	eef0 1a66 	vmov.f32	s3, s13
 802bbdc:	eee7 3a02 	vfma.f32	s7, s14, s4
 802bbe0:	eee6 1a43 	vfms.f32	s3, s12, s6
 802bbe4:	eea3 4a87 	vfma.f32	s8, s7, s14
 802bbe8:	eeb0 6a66 	vmov.f32	s12, s13
 802bbec:	eee4 4a07 	vfma.f32	s9, s8, s14
 802bbf0:	ee77 7ae1 	vsub.f32	s15, s15, s3
 802bbf4:	eea4 5a87 	vfma.f32	s10, s9, s14
 802bbf8:	eee6 7aa7 	vfma.f32	s15, s13, s15
 802bbfc:	eea5 6a47 	vfms.f32	s12, s10, s14
 802bc00:	ee26 7a86 	vmul.f32	s14, s13, s12
 802bc04:	ee36 6a62 	vsub.f32	s12, s12, s5
 802bc08:	ee87 7a06 	vdiv.f32	s14, s14, s12
 802bc0c:	ee77 7a67 	vsub.f32	s15, s14, s15
 802bc10:	ee77 7ae6 	vsub.f32	s15, s15, s13
 802bc14:	ee75 7ae7 	vsub.f32	s15, s11, s15
 802bc18:	ee17 3a90 	vmov	r3, s15
 802bc1c:	4413      	add	r3, r2
 802bc1e:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 802bc22:	f2c0 80e4 	blt.w	802bdee <__ieee754_powf+0x5fe>
 802bc26:	ee07 3a90 	vmov	s15, r3
 802bc2a:	ee68 7a27 	vmul.f32	s15, s16, s15
 802bc2e:	ee17 0a90 	vmov	r0, s15
 802bc32:	e5fd      	b.n	802b830 <__ieee754_powf+0x40>
 802bc34:	f002 0201 	and.w	r2, r2, #1
 802bc38:	f1c2 0902 	rsb	r9, r2, #2
 802bc3c:	e604      	b.n	802b848 <__ieee754_powf+0x58>
 802bc3e:	eef1 7a67 	vneg.f32	s15, s15
 802bc42:	ee17 0a90 	vmov	r0, s15
 802bc46:	e5f3      	b.n	802b830 <__ieee754_powf+0x40>
 802bc48:	4a44      	ldr	r2, [pc, #272]	; (802bd5c <__ieee754_powf+0x56c>)
 802bc4a:	4297      	cmp	r7, r2
 802bc4c:	f340 809e 	ble.w	802bd8c <__ieee754_powf+0x59c>
 802bc50:	2c00      	cmp	r4, #0
 802bc52:	f77f ae20 	ble.w	802b896 <__ieee754_powf+0xa6>
 802bc56:	eddf 7a42 	vldr	s15, [pc, #264]	; 802bd60 <__ieee754_powf+0x570>
 802bc5a:	ee67 7aa7 	vmul.f32	s15, s15, s15
 802bc5e:	ee17 0a90 	vmov	r0, s15
 802bc62:	e5e5      	b.n	802b830 <__ieee754_powf+0x40>
 802bc64:	2600      	movs	r6, #0
 802bc66:	4635      	mov	r5, r6
 802bc68:	e6a8      	b.n	802b9bc <__ieee754_powf+0x1cc>
 802bc6a:	2000      	movs	r0, #0
 802bc6c:	e692      	b.n	802b994 <__ieee754_powf+0x1a4>
 802bc6e:	ed9f 6a3d 	vldr	s12, [pc, #244]	; 802bd64 <__ieee754_powf+0x574>
 802bc72:	ee76 6ac7 	vsub.f32	s13, s13, s14
 802bc76:	ee37 6a86 	vadd.f32	s12, s15, s12
 802bc7a:	eeb4 6ae6 	vcmpe.f32	s12, s13
 802bc7e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802bc82:	dd08      	ble.n	802bc96 <__ieee754_powf+0x4a6>
 802bc84:	eddf 7a36 	vldr	s15, [pc, #216]	; 802bd60 <__ieee754_powf+0x570>
 802bc88:	ee28 8a27 	vmul.f32	s16, s16, s15
 802bc8c:	ee68 7a27 	vmul.f32	s15, s16, s15
 802bc90:	ee17 0a90 	vmov	r0, s15
 802bc94:	e5cc      	b.n	802b830 <__ieee754_powf+0x40>
 802bc96:	15d2      	asrs	r2, r2, #23
 802bc98:	f44f 0100 	mov.w	r1, #8388608	; 0x800000
 802bc9c:	3a7e      	subs	r2, #126	; 0x7e
 802bc9e:	fa41 f202 	asr.w	r2, r1, r2
 802bca2:	441a      	add	r2, r3
 802bca4:	f3c2 50c7 	ubfx	r0, r2, #23, #8
 802bca8:	4c2f      	ldr	r4, [pc, #188]	; (802bd68 <__ieee754_powf+0x578>)
 802bcaa:	f1a0 057f 	sub.w	r5, r0, #127	; 0x7f
 802bcae:	412c      	asrs	r4, r5
 802bcb0:	f3c2 0116 	ubfx	r1, r2, #0, #23
 802bcb4:	ea22 0204 	bic.w	r2, r2, r4
 802bcb8:	ee06 2a90 	vmov	s13, r2
 802bcbc:	f1c0 0096 	rsb	r0, r0, #150	; 0x96
 802bcc0:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
 802bcc4:	ee37 7a66 	vsub.f32	s14, s14, s13
 802bcc8:	4101      	asrs	r1, r0
 802bcca:	ea81 71e3 	eor.w	r1, r1, r3, asr #31
 802bcce:	ee77 6a87 	vadd.f32	s13, s15, s14
 802bcd2:	eb01 71d3 	add.w	r1, r1, r3, lsr #31
 802bcd6:	05ca      	lsls	r2, r1, #23
 802bcd8:	ee16 3a90 	vmov	r3, s13
 802bcdc:	e752      	b.n	802bb84 <__ieee754_powf+0x394>
 802bcde:	4923      	ldr	r1, [pc, #140]	; (802bd6c <__ieee754_powf+0x57c>)
 802bce0:	428a      	cmp	r2, r1
 802bce2:	dc08      	bgt.n	802bcf6 <__ieee754_powf+0x506>
 802bce4:	f47f af48 	bne.w	802bb78 <__ieee754_powf+0x388>
 802bce8:	ee76 6ac7 	vsub.f32	s13, s13, s14
 802bcec:	eef4 7ae6 	vcmpe.f32	s15, s13
 802bcf0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802bcf4:	d8cf      	bhi.n	802bc96 <__ieee754_powf+0x4a6>
 802bcf6:	eddf 7a1e 	vldr	s15, [pc, #120]	; 802bd70 <__ieee754_powf+0x580>
 802bcfa:	ee28 8a27 	vmul.f32	s16, s16, s15
 802bcfe:	ee68 7a27 	vmul.f32	s15, s16, s15
 802bd02:	ee17 0a90 	vmov	r0, s15
 802bd06:	e593      	b.n	802b830 <__ieee754_powf+0x40>
 802bd08:	f44f 1600 	mov.w	r6, #2097152	; 0x200000
 802bd0c:	2501      	movs	r5, #1
 802bd0e:	e655      	b.n	802b9bc <__ieee754_powf+0x1cc>
 802bd10:	001cc471 	.word	0x001cc471
 802bd14:	005db3d6 	.word	0x005db3d6
 802bd18:	3e53f142 	.word	0x3e53f142
 802bd1c:	3e6c3255 	.word	0x3e6c3255
 802bd20:	3e8ba305 	.word	0x3e8ba305
 802bd24:	3edb6db7 	.word	0x3edb6db7
 802bd28:	3f19999a 	.word	0x3f19999a
 802bd2c:	3f76384f 	.word	0x3f76384f
 802bd30:	369dc3a0 	.word	0x369dc3a0
 802bd34:	0802ff5c 	.word	0x0802ff5c
 802bd38:	3f763800 	.word	0x3f763800
 802bd3c:	35bfbe8c 	.word	0x35bfbe8c
 802bd40:	3f317218 	.word	0x3f317218
 802bd44:	3f317200 	.word	0x3f317200
 802bd48:	3331bb4c 	.word	0x3331bb4c
 802bd4c:	b5ddea0e 	.word	0xb5ddea0e
 802bd50:	388ab355 	.word	0x388ab355
 802bd54:	bb360b61 	.word	0xbb360b61
 802bd58:	3e2aaaab 	.word	0x3e2aaaab
 802bd5c:	3f800007 	.word	0x3f800007
 802bd60:	7149f2ca 	.word	0x7149f2ca
 802bd64:	3338aa3c 	.word	0x3338aa3c
 802bd68:	007fffff 	.word	0x007fffff
 802bd6c:	43160000 	.word	0x43160000
 802bd70:	0da24260 	.word	0x0da24260
 802bd74:	0802ff64 	.word	0x0802ff64
 802bd78:	0802ff54 	.word	0x0802ff54
 802bd7c:	3eaaaaab 	.word	0x3eaaaaab
 802bd80:	3fb8aa3b 	.word	0x3fb8aa3b
 802bd84:	3fb8aa00 	.word	0x3fb8aa00
 802bd88:	36eca570 	.word	0x36eca570
 802bd8c:	eeb7 7a00 	vmov.f32	s14, #112	; 0x70
 802bd90:	ee77 7ac7 	vsub.f32	s15, s15, s14
 802bd94:	ed1f 6a07 	vldr	s12, [pc, #-28]	; 802bd7c <__ieee754_powf+0x58c>
 802bd98:	ed1f 7a07 	vldr	s14, [pc, #-28]	; 802bd80 <__ieee754_powf+0x590>
 802bd9c:	ed5f 4a06 	vldr	s9, [pc, #-24]	; 802bd88 <__ieee754_powf+0x598>
 802bda0:	ed5f 5a08 	vldr	s11, [pc, #-32]	; 802bd84 <__ieee754_powf+0x594>
 802bda4:	eeb1 5a67 	vneg.f32	s10, s15
 802bda8:	eef5 6a00 	vmov.f32	s13, #80	; 0x50
 802bdac:	eea5 6a26 	vfma.f32	s12, s10, s13
 802bdb0:	eef6 6a00 	vmov.f32	s13, #96	; 0x60
 802bdb4:	eee6 6a67 	vfms.f32	s13, s12, s15
 802bdb8:	eeb0 6a66 	vmov.f32	s12, s13
 802bdbc:	ee67 6aa7 	vmul.f32	s13, s15, s15
 802bdc0:	ee66 6a86 	vmul.f32	s13, s13, s12
 802bdc4:	ee27 7a66 	vnmul.f32	s14, s14, s13
 802bdc8:	eea7 7aa4 	vfma.f32	s14, s15, s9
 802bdcc:	eef0 6a47 	vmov.f32	s13, s14
 802bdd0:	eee7 6aa5 	vfma.f32	s13, s15, s11
 802bdd4:	ee16 2a90 	vmov	r2, s13
 802bdd8:	f422 627f 	bic.w	r2, r2, #4080	; 0xff0
 802bddc:	f022 020f 	bic.w	r2, r2, #15
 802bde0:	ee07 2a90 	vmov	s15, r2
 802bde4:	eee5 7a25 	vfma.f32	s15, s10, s11
 802bde8:	ee77 7a67 	vsub.f32	s15, s14, s15
 802bdec:	e695      	b.n	802bb1a <__ieee754_powf+0x32a>
 802bdee:	ee17 0a90 	vmov	r0, s15
 802bdf2:	f000 fb7b 	bl	802c4ec <scalbnf>
 802bdf6:	ee07 0a90 	vmov	s15, r0
 802bdfa:	e716      	b.n	802bc2a <__ieee754_powf+0x43a>

0802bdfc <__ieee754_sqrtf>:
 802bdfc:	f020 4200 	bic.w	r2, r0, #2147483648	; 0x80000000
 802be00:	f1b2 4fff 	cmp.w	r2, #2139095040	; 0x7f800000
 802be04:	b470      	push	{r4, r5, r6}
 802be06:	ee07 0a90 	vmov	s15, r0
 802be0a:	4603      	mov	r3, r0
 802be0c:	d232      	bcs.n	802be74 <__ieee754_sqrtf+0x78>
 802be0e:	b36a      	cbz	r2, 802be6c <__ieee754_sqrtf+0x70>
 802be10:	2800      	cmp	r0, #0
 802be12:	db41      	blt.n	802be98 <__ieee754_sqrtf+0x9c>
 802be14:	f5b2 0f00 	cmp.w	r2, #8388608	; 0x800000
 802be18:	ea4f 51e0 	mov.w	r1, r0, asr #23
 802be1c:	d330      	bcc.n	802be80 <__ieee754_sqrtf+0x84>
 802be1e:	f1a1 027f 	sub.w	r2, r1, #127	; 0x7f
 802be22:	f3c3 0316 	ubfx	r3, r3, #0, #23
 802be26:	07d1      	lsls	r1, r2, #31
 802be28:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 802be2c:	bf48      	it	mi
 802be2e:	005b      	lslmi	r3, r3, #1
 802be30:	2400      	movs	r4, #0
 802be32:	1056      	asrs	r6, r2, #1
 802be34:	005b      	lsls	r3, r3, #1
 802be36:	4625      	mov	r5, r4
 802be38:	2119      	movs	r1, #25
 802be3a:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 802be3e:	18a8      	adds	r0, r5, r2
 802be40:	4298      	cmp	r0, r3
 802be42:	dc02      	bgt.n	802be4a <__ieee754_sqrtf+0x4e>
 802be44:	1a1b      	subs	r3, r3, r0
 802be46:	1885      	adds	r5, r0, r2
 802be48:	4414      	add	r4, r2
 802be4a:	3901      	subs	r1, #1
 802be4c:	ea4f 0343 	mov.w	r3, r3, lsl #1
 802be50:	ea4f 0252 	mov.w	r2, r2, lsr #1
 802be54:	d1f3      	bne.n	802be3e <__ieee754_sqrtf+0x42>
 802be56:	b113      	cbz	r3, 802be5e <__ieee754_sqrtf+0x62>
 802be58:	f004 0301 	and.w	r3, r4, #1
 802be5c:	441c      	add	r4, r3
 802be5e:	1064      	asrs	r4, r4, #1
 802be60:	f104 547c 	add.w	r4, r4, #1056964608	; 0x3f000000
 802be64:	eb04 53c6 	add.w	r3, r4, r6, lsl #23
 802be68:	ee07 3a90 	vmov	s15, r3
 802be6c:	ee17 0a90 	vmov	r0, s15
 802be70:	bc70      	pop	{r4, r5, r6}
 802be72:	4770      	bx	lr
 802be74:	eee7 7aa7 	vfma.f32	s15, s15, s15
 802be78:	bc70      	pop	{r4, r5, r6}
 802be7a:	ee17 0a90 	vmov	r0, s15
 802be7e:	4770      	bx	lr
 802be80:	f410 0200 	ands.w	r2, r0, #8388608	; 0x800000
 802be84:	d10d      	bne.n	802bea2 <__ieee754_sqrtf+0xa6>
 802be86:	005b      	lsls	r3, r3, #1
 802be88:	0218      	lsls	r0, r3, #8
 802be8a:	f102 0201 	add.w	r2, r2, #1
 802be8e:	d5fa      	bpl.n	802be86 <__ieee754_sqrtf+0x8a>
 802be90:	f1c2 0201 	rsb	r2, r2, #1
 802be94:	4411      	add	r1, r2
 802be96:	e7c2      	b.n	802be1e <__ieee754_sqrtf+0x22>
 802be98:	ee77 7ae7 	vsub.f32	s15, s15, s15
 802be9c:	eec7 7aa7 	vdiv.f32	s15, s15, s15
 802bea0:	e7e4      	b.n	802be6c <__ieee754_sqrtf+0x70>
 802bea2:	2201      	movs	r2, #1
 802bea4:	4411      	add	r1, r2
 802bea6:	e7ba      	b.n	802be1e <__ieee754_sqrtf+0x22>

0802bea8 <matherr>:
 802bea8:	2000      	movs	r0, #0
 802beaa:	4770      	bx	lr

0802beac <nan>:
 802beac:	2000      	movs	r0, #0
 802beae:	4901      	ldr	r1, [pc, #4]	; (802beb4 <nan+0x8>)
 802beb0:	4770      	bx	lr
 802beb2:	bf00      	nop
 802beb4:	7ff80000 	.word	0x7ff80000

0802beb8 <rint>:
 802beb8:	b5f0      	push	{r4, r5, r6, r7, lr}
 802beba:	f3c1 5e0a 	ubfx	lr, r1, #20, #11
 802bebe:	f2ae 35ff 	subw	r5, lr, #1023	; 0x3ff
 802bec2:	2d13      	cmp	r5, #19
 802bec4:	b083      	sub	sp, #12
 802bec6:	4602      	mov	r2, r0
 802bec8:	460b      	mov	r3, r1
 802beca:	460c      	mov	r4, r1
 802becc:	ea4f 76d1 	mov.w	r6, r1, lsr #31
 802bed0:	4607      	mov	r7, r0
 802bed2:	dc2e      	bgt.n	802bf32 <rint+0x7a>
 802bed4:	2d00      	cmp	r5, #0
 802bed6:	db48      	blt.n	802bf6a <rint+0xb2>
 802bed8:	493b      	ldr	r1, [pc, #236]	; (802bfc8 <rint+0x110>)
 802beda:	4129      	asrs	r1, r5
 802bedc:	ea01 0003 	and.w	r0, r1, r3
 802bee0:	4310      	orrs	r0, r2
 802bee2:	d02b      	beq.n	802bf3c <rint+0x84>
 802bee4:	0849      	lsrs	r1, r1, #1
 802bee6:	400b      	ands	r3, r1
 802bee8:	ea53 0702 	orrs.w	r7, r3, r2
 802beec:	d00c      	beq.n	802bf08 <rint+0x50>
 802beee:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 802bef2:	2d13      	cmp	r5, #19
 802bef4:	ea24 0101 	bic.w	r1, r4, r1
 802bef8:	fa43 f405 	asr.w	r4, r3, r5
 802befc:	ea44 0401 	orr.w	r4, r4, r1
 802bf00:	bf0c      	ite	eq
 802bf02:	f04f 4700 	moveq.w	r7, #2147483648	; 0x80000000
 802bf06:	2700      	movne	r7, #0
 802bf08:	4930      	ldr	r1, [pc, #192]	; (802bfcc <rint+0x114>)
 802bf0a:	eb01 06c6 	add.w	r6, r1, r6, lsl #3
 802bf0e:	4623      	mov	r3, r4
 802bf10:	e9d6 4500 	ldrd	r4, r5, [r6]
 802bf14:	463a      	mov	r2, r7
 802bf16:	4620      	mov	r0, r4
 802bf18:	4629      	mov	r1, r5
 802bf1a:	f000 fb73 	bl	802c604 <__adddf3>
 802bf1e:	e9cd 0100 	strd	r0, r1, [sp]
 802bf22:	4622      	mov	r2, r4
 802bf24:	462b      	mov	r3, r5
 802bf26:	e9dd 0100 	ldrd	r0, r1, [sp]
 802bf2a:	f000 fb69 	bl	802c600 <__aeabi_dsub>
 802bf2e:	b003      	add	sp, #12
 802bf30:	bdf0      	pop	{r4, r5, r6, r7, pc}
 802bf32:	2d33      	cmp	r5, #51	; 0x33
 802bf34:	dd06      	ble.n	802bf44 <rint+0x8c>
 802bf36:	f5b5 6f80 	cmp.w	r5, #1024	; 0x400
 802bf3a:	d041      	beq.n	802bfc0 <rint+0x108>
 802bf3c:	4610      	mov	r0, r2
 802bf3e:	4619      	mov	r1, r3
 802bf40:	b003      	add	sp, #12
 802bf42:	bdf0      	pop	{r4, r5, r6, r7, pc}
 802bf44:	f2ae 4e13 	subw	lr, lr, #1043	; 0x413
 802bf48:	f04f 31ff 	mov.w	r1, #4294967295
 802bf4c:	fa21 f10e 	lsr.w	r1, r1, lr
 802bf50:	4201      	tst	r1, r0
 802bf52:	d0f3      	beq.n	802bf3c <rint+0x84>
 802bf54:	0849      	lsrs	r1, r1, #1
 802bf56:	4201      	tst	r1, r0
 802bf58:	d0d6      	beq.n	802bf08 <rint+0x50>
 802bf5a:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 802bf5e:	ea20 0101 	bic.w	r1, r0, r1
 802bf62:	fa43 f70e 	asr.w	r7, r3, lr
 802bf66:	430f      	orrs	r7, r1
 802bf68:	e7ce      	b.n	802bf08 <rint+0x50>
 802bf6a:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 802bf6e:	4301      	orrs	r1, r0
 802bf70:	d0e4      	beq.n	802bf3c <rint+0x84>
 802bf72:	f3c3 0113 	ubfx	r1, r3, #0, #20
 802bf76:	ea41 0c00 	orr.w	ip, r1, r0
 802bf7a:	f1cc 0100 	rsb	r1, ip, #0
 802bf7e:	ea41 0c0c 	orr.w	ip, r1, ip
 802bf82:	4912      	ldr	r1, [pc, #72]	; (802bfcc <rint+0x114>)
 802bf84:	0c5c      	lsrs	r4, r3, #17
 802bf86:	ea4f 3c1c 	mov.w	ip, ip, lsr #12
 802bf8a:	f40c 2c00 	and.w	ip, ip, #524288	; 0x80000
 802bf8e:	0464      	lsls	r4, r4, #17
 802bf90:	eb01 01c6 	add.w	r1, r1, r6, lsl #3
 802bf94:	ea4c 0304 	orr.w	r3, ip, r4
 802bf98:	e9d1 4500 	ldrd	r4, r5, [r1]
 802bf9c:	4620      	mov	r0, r4
 802bf9e:	4629      	mov	r1, r5
 802bfa0:	f000 fb30 	bl	802c604 <__adddf3>
 802bfa4:	e9cd 0100 	strd	r0, r1, [sp]
 802bfa8:	4622      	mov	r2, r4
 802bfaa:	462b      	mov	r3, r5
 802bfac:	e9dd 0100 	ldrd	r0, r1, [sp]
 802bfb0:	f000 fb26 	bl	802c600 <__aeabi_dsub>
 802bfb4:	f021 4400 	bic.w	r4, r1, #2147483648	; 0x80000000
 802bfb8:	ea44 73c6 	orr.w	r3, r4, r6, lsl #31
 802bfbc:	4619      	mov	r1, r3
 802bfbe:	e7bf      	b.n	802bf40 <rint+0x88>
 802bfc0:	f000 fb20 	bl	802c604 <__adddf3>
 802bfc4:	e7bc      	b.n	802bf40 <rint+0x88>
 802bfc6:	bf00      	nop
 802bfc8:	000fffff 	.word	0x000fffff
 802bfcc:	0802ff70 	.word	0x0802ff70

0802bfd0 <expm1f>:
 802bfd0:	4992      	ldr	r1, [pc, #584]	; (802c21c <expm1f+0x24c>)
 802bfd2:	f020 4200 	bic.w	r2, r0, #2147483648	; 0x80000000
 802bfd6:	428a      	cmp	r2, r1
 802bfd8:	ee07 0a90 	vmov	s15, r0
 802bfdc:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
 802bfe0:	d913      	bls.n	802c00a <expm1f+0x3a>
 802bfe2:	f1b2 4fff 	cmp.w	r2, #2139095040	; 0x7f800000
 802bfe6:	f200 8085 	bhi.w	802c0f4 <expm1f+0x124>
 802bfea:	f000 80d2 	beq.w	802c192 <expm1f+0x1c2>
 802bfee:	2b00      	cmp	r3, #0
 802bff0:	f040 80a4 	bne.w	802c13c <expm1f+0x16c>
 802bff4:	4b8a      	ldr	r3, [pc, #552]	; (802c220 <expm1f+0x250>)
 802bff6:	429a      	cmp	r2, r3
 802bff8:	f200 8108 	bhi.w	802c20c <expm1f+0x23c>
 802bffc:	eddf 6a89 	vldr	s13, [pc, #548]	; 802c224 <expm1f+0x254>
 802c000:	eeb6 6a00 	vmov.f32	s12, #96	; 0x60
 802c004:	ee27 7aa6 	vmul.f32	s14, s15, s13
 802c008:	e085      	b.n	802c116 <expm1f+0x146>
 802c00a:	4987      	ldr	r1, [pc, #540]	; (802c228 <expm1f+0x258>)
 802c00c:	428a      	cmp	r2, r1
 802c00e:	d855      	bhi.n	802c0bc <expm1f+0xec>
 802c010:	f1b2 5f4c 	cmp.w	r2, #855638016	; 0x33000000
 802c014:	f0c0 80b2 	bcc.w	802c17c <expm1f+0x1ac>
 802c018:	2300      	movs	r3, #0
 802c01a:	eef6 2a00 	vmov.f32	s5, #96	; 0x60
 802c01e:	ee67 3aa2 	vmul.f32	s7, s15, s5
 802c022:	eddf 5a82 	vldr	s11, [pc, #520]	; 802c22c <expm1f+0x25c>
 802c026:	ed9f 5a82 	vldr	s10, [pc, #520]	; 802c230 <expm1f+0x260>
 802c02a:	ed9f 4a82 	vldr	s8, [pc, #520]	; 802c234 <expm1f+0x264>
 802c02e:	eddf 4a82 	vldr	s9, [pc, #520]	; 802c238 <expm1f+0x268>
 802c032:	ed9f 7a82 	vldr	s14, [pc, #520]	; 802c23c <expm1f+0x26c>
 802c036:	ee27 6aa3 	vmul.f32	s12, s15, s7
 802c03a:	eeb7 3a00 	vmov.f32	s6, #112	; 0x70
 802c03e:	eea6 5a25 	vfma.f32	s10, s12, s11
 802c042:	eef0 5a08 	vmov.f32	s11, #8
 802c046:	eea5 4a06 	vfma.f32	s8, s10, s12
 802c04a:	eeb1 5a08 	vmov.f32	s10, #24
 802c04e:	eee4 4a06 	vfma.f32	s9, s8, s12
 802c052:	eea4 7a86 	vfma.f32	s14, s9, s12
 802c056:	eef0 4a43 	vmov.f32	s9, s6
 802c05a:	eee7 4a06 	vfma.f32	s9, s14, s12
 802c05e:	eee4 5ae3 	vfms.f32	s11, s9, s7
 802c062:	eea7 5ae5 	vfms.f32	s10, s15, s11
 802c066:	ee34 7ae5 	vsub.f32	s14, s9, s11
 802c06a:	ee87 7a05 	vdiv.f32	s14, s14, s10
 802c06e:	ee27 7a06 	vmul.f32	s14, s14, s12
 802c072:	b3b3      	cbz	r3, 802c0e2 <expm1f+0x112>
 802c074:	ee37 7a66 	vsub.f32	s14, s14, s13
 802c078:	1c5a      	adds	r2, r3, #1
 802c07a:	eed7 6a27 	vfnms.f32	s13, s14, s15
 802c07e:	ee76 6ac6 	vsub.f32	s13, s13, s12
 802c082:	f000 80a1 	beq.w	802c1c8 <expm1f+0x1f8>
 802c086:	2b01      	cmp	r3, #1
 802c088:	d068      	beq.n	802c15c <expm1f+0x18c>
 802c08a:	1c5a      	adds	r2, r3, #1
 802c08c:	2a39      	cmp	r2, #57	; 0x39
 802c08e:	f200 808e 	bhi.w	802c1ae <expm1f+0x1de>
 802c092:	2b16      	cmp	r3, #22
 802c094:	f300 809f 	bgt.w	802c1d6 <expm1f+0x206>
 802c098:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 802c09c:	411a      	asrs	r2, r3
 802c09e:	f1c2 527e 	rsb	r2, r2, #1065353216	; 0x3f800000
 802c0a2:	ee76 6ae7 	vsub.f32	s13, s13, s15
 802c0a6:	ee07 2a90 	vmov	s15, r2
 802c0aa:	ee77 7ae6 	vsub.f32	s15, s15, s13
 802c0ae:	ee17 2a90 	vmov	r2, s15
 802c0b2:	eb02 53c3 	add.w	r3, r2, r3, lsl #23
 802c0b6:	ee07 3a90 	vmov	s15, r3
 802c0ba:	e018      	b.n	802c0ee <expm1f+0x11e>
 802c0bc:	4960      	ldr	r1, [pc, #384]	; (802c240 <expm1f+0x270>)
 802c0be:	428a      	cmp	r2, r1
 802c0c0:	d81d      	bhi.n	802c0fe <expm1f+0x12e>
 802c0c2:	ed9f 6a60 	vldr	s12, [pc, #384]	; 802c244 <expm1f+0x274>
 802c0c6:	2b00      	cmp	r3, #0
 802c0c8:	d16a      	bne.n	802c1a0 <expm1f+0x1d0>
 802c0ca:	eddf 6a5f 	vldr	s13, [pc, #380]	; 802c248 <expm1f+0x278>
 802c0ce:	ee37 7ac6 	vsub.f32	s14, s15, s12
 802c0d2:	2301      	movs	r3, #1
 802c0d4:	ee77 7a66 	vsub.f32	s15, s14, s13
 802c0d8:	ee37 7a67 	vsub.f32	s14, s14, s15
 802c0dc:	ee77 6a66 	vsub.f32	s13, s14, s13
 802c0e0:	e79b      	b.n	802c01a <expm1f+0x4a>
 802c0e2:	eef0 6a46 	vmov.f32	s13, s12
 802c0e6:	eed7 6a87 	vfnms.f32	s13, s15, s14
 802c0ea:	ee77 7ae6 	vsub.f32	s15, s15, s13
 802c0ee:	ee17 0a90 	vmov	r0, s15
 802c0f2:	4770      	bx	lr
 802c0f4:	ee77 7aa7 	vadd.f32	s15, s15, s15
 802c0f8:	ee17 0a90 	vmov	r0, s15
 802c0fc:	4770      	bx	lr
 802c0fe:	eddf 6a49 	vldr	s13, [pc, #292]	; 802c224 <expm1f+0x254>
 802c102:	2b00      	cmp	r3, #0
 802c104:	eeb6 6a00 	vmov.f32	s12, #96	; 0x60
 802c108:	eefe 5a00 	vmov.f32	s11, #224	; 0xe0
 802c10c:	ee27 7aa6 	vmul.f32	s14, s15, s13
 802c110:	bf18      	it	ne
 802c112:	eeb0 6a65 	vmovne.f32	s12, s11
 802c116:	ee37 7a06 	vadd.f32	s14, s14, s12
 802c11a:	eddf 5a4a 	vldr	s11, [pc, #296]	; 802c244 <expm1f+0x274>
 802c11e:	ed9f 6a4a 	vldr	s12, [pc, #296]	; 802c248 <expm1f+0x278>
 802c122:	eebd 7ac7 	vcvt.s32.f32	s14, s14
 802c126:	eef8 6ac7 	vcvt.f32.s32	s13, s14
 802c12a:	ee17 3a10 	vmov	r3, s14
 802c12e:	eee6 7ae5 	vfms.f32	s15, s13, s11
 802c132:	ee66 6a86 	vmul.f32	s13, s13, s12
 802c136:	eeb0 7a67 	vmov.f32	s14, s15
 802c13a:	e7cb      	b.n	802c0d4 <expm1f+0x104>
 802c13c:	ed9f 7a43 	vldr	s14, [pc, #268]	; 802c24c <expm1f+0x27c>
 802c140:	ee37 7a87 	vadd.f32	s14, s15, s14
 802c144:	eeb5 7ac0 	vcmpe.f32	s14, #0.0
 802c148:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802c14c:	d463      	bmi.n	802c216 <expm1f+0x246>
 802c14e:	eddf 6a35 	vldr	s13, [pc, #212]	; 802c224 <expm1f+0x254>
 802c152:	eebe 6a00 	vmov.f32	s12, #224	; 0xe0
 802c156:	ee27 7aa6 	vmul.f32	s14, s15, s13
 802c15a:	e7dc      	b.n	802c116 <expm1f+0x146>
 802c15c:	eebd 7a00 	vmov.f32	s14, #208	; 0xd0
 802c160:	eef4 7ac7 	vcmpe.f32	s15, s14
 802c164:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802c168:	d547      	bpl.n	802c1fa <expm1f+0x22a>
 802c16a:	ee77 7aa2 	vadd.f32	s15, s15, s5
 802c16e:	eeb8 7a00 	vmov.f32	s14, #128	; 0x80
 802c172:	ee76 7ae7 	vsub.f32	s15, s13, s15
 802c176:	ee67 7a87 	vmul.f32	s15, s15, s14
 802c17a:	e7b8      	b.n	802c0ee <expm1f+0x11e>
 802c17c:	ed9f 7a34 	vldr	s14, [pc, #208]	; 802c250 <expm1f+0x280>
 802c180:	ee37 7a87 	vadd.f32	s14, s15, s14
 802c184:	ee37 7a47 	vsub.f32	s14, s14, s14
 802c188:	ee77 7ac7 	vsub.f32	s15, s15, s14
 802c18c:	ee17 0a90 	vmov	r0, s15
 802c190:	4770      	bx	lr
 802c192:	2b00      	cmp	r3, #0
 802c194:	eebf 7a00 	vmov.f32	s14, #240	; 0xf0
 802c198:	bf18      	it	ne
 802c19a:	eef0 7a47 	vmovne.f32	s15, s14
 802c19e:	e7a6      	b.n	802c0ee <expm1f+0x11e>
 802c1a0:	eddf 6a2c 	vldr	s13, [pc, #176]	; 802c254 <expm1f+0x284>
 802c1a4:	ee37 7a86 	vadd.f32	s14, s15, s12
 802c1a8:	f04f 33ff 	mov.w	r3, #4294967295
 802c1ac:	e792      	b.n	802c0d4 <expm1f+0x104>
 802c1ae:	ee76 6ae7 	vsub.f32	s13, s13, s15
 802c1b2:	ee73 6a66 	vsub.f32	s13, s6, s13
 802c1b6:	ee16 2a90 	vmov	r2, s13
 802c1ba:	eb02 53c3 	add.w	r3, r2, r3, lsl #23
 802c1be:	ee07 3a90 	vmov	s15, r3
 802c1c2:	ee77 7ac3 	vsub.f32	s15, s15, s6
 802c1c6:	e792      	b.n	802c0ee <expm1f+0x11e>
 802c1c8:	ee77 6ae6 	vsub.f32	s13, s15, s13
 802c1cc:	eefe 7a00 	vmov.f32	s15, #224	; 0xe0
 802c1d0:	eee6 7aa2 	vfma.f32	s15, s13, s5
 802c1d4:	e78b      	b.n	802c0ee <expm1f+0x11e>
 802c1d6:	f1c3 027f 	rsb	r2, r3, #127	; 0x7f
 802c1da:	05d2      	lsls	r2, r2, #23
 802c1dc:	ee07 2a10 	vmov	s14, r2
 802c1e0:	ee76 6a87 	vadd.f32	s13, s13, s14
 802c1e4:	ee77 6ae6 	vsub.f32	s13, s15, s13
 802c1e8:	ee76 7a83 	vadd.f32	s15, s13, s6
 802c1ec:	ee17 2a90 	vmov	r2, s15
 802c1f0:	eb02 53c3 	add.w	r3, r2, r3, lsl #23
 802c1f4:	ee07 3a90 	vmov	s15, r3
 802c1f8:	e779      	b.n	802c0ee <expm1f+0x11e>
 802c1fa:	ee77 6ae6 	vsub.f32	s13, s15, s13
 802c1fe:	eef0 7a00 	vmov.f32	s15, #0
 802c202:	eea6 3aa7 	vfma.f32	s6, s13, s15
 802c206:	eef0 7a43 	vmov.f32	s15, s6
 802c20a:	e770      	b.n	802c0ee <expm1f+0x11e>
 802c20c:	eddf 7a10 	vldr	s15, [pc, #64]	; 802c250 <expm1f+0x280>
 802c210:	ee67 7aa7 	vmul.f32	s15, s15, s15
 802c214:	e76b      	b.n	802c0ee <expm1f+0x11e>
 802c216:	eeff 7a00 	vmov.f32	s15, #240	; 0xf0
 802c21a:	e768      	b.n	802c0ee <expm1f+0x11e>
 802c21c:	4195b843 	.word	0x4195b843
 802c220:	42b17217 	.word	0x42b17217
 802c224:	3fb8aa3b 	.word	0x3fb8aa3b
 802c228:	3eb17218 	.word	0x3eb17218
 802c22c:	b457edbb 	.word	0xb457edbb
 802c230:	36867e54 	.word	0x36867e54
 802c234:	b8a670cd 	.word	0xb8a670cd
 802c238:	3ad00d01 	.word	0x3ad00d01
 802c23c:	bd088889 	.word	0xbd088889
 802c240:	3f851591 	.word	0x3f851591
 802c244:	3f317180 	.word	0x3f317180
 802c248:	3717f7d1 	.word	0x3717f7d1
 802c24c:	0da24260 	.word	0x0da24260
 802c250:	7149f2ca 	.word	0x7149f2ca
 802c254:	b717f7d1 	.word	0xb717f7d1

0802c258 <fabsf>:
 802c258:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
 802c25c:	4770      	bx	lr
 802c25e:	bf00      	nop

0802c260 <finitef>:
 802c260:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
 802c264:	f1b0 4fff 	cmp.w	r0, #2139095040	; 0x7f800000
 802c268:	bfac      	ite	ge
 802c26a:	2000      	movge	r0, #0
 802c26c:	2001      	movlt	r0, #1
 802c26e:	4770      	bx	lr

0802c270 <__fpclassifyf>:
 802c270:	f030 4000 	bics.w	r0, r0, #2147483648	; 0x80000000
 802c274:	d101      	bne.n	802c27a <__fpclassifyf+0xa>
 802c276:	2002      	movs	r0, #2
 802c278:	4770      	bx	lr
 802c27a:	f5a0 0300 	sub.w	r3, r0, #8388608	; 0x800000
 802c27e:	f1b3 4ffe 	cmp.w	r3, #2130706432	; 0x7f000000
 802c282:	d201      	bcs.n	802c288 <__fpclassifyf+0x18>
 802c284:	2004      	movs	r0, #4
 802c286:	4770      	bx	lr
 802c288:	4b05      	ldr	r3, [pc, #20]	; (802c2a0 <__fpclassifyf+0x30>)
 802c28a:	1e42      	subs	r2, r0, #1
 802c28c:	429a      	cmp	r2, r3
 802c28e:	d801      	bhi.n	802c294 <__fpclassifyf+0x24>
 802c290:	2003      	movs	r0, #3
 802c292:	4770      	bx	lr
 802c294:	f1a0 40ff 	sub.w	r0, r0, #2139095040	; 0x7f800000
 802c298:	fab0 f080 	clz	r0, r0
 802c29c:	0940      	lsrs	r0, r0, #5
 802c29e:	4770      	bx	lr
 802c2a0:	007ffffe 	.word	0x007ffffe

0802c2a4 <log1pf>:
 802c2a4:	f1b0 4fff 	cmp.w	r0, #2139095040	; 0x7f800000
 802c2a8:	ee07 0a90 	vmov	s15, r0
 802c2ac:	4603      	mov	r3, r0
 802c2ae:	da46      	bge.n	802c33e <log1pf+0x9a>
 802c2b0:	4a7d      	ldr	r2, [pc, #500]	; (802c4a8 <log1pf+0x204>)
 802c2b2:	4290      	cmp	r0, r2
 802c2b4:	dc1a      	bgt.n	802c2ec <log1pf+0x48>
 802c2b6:	f020 4200 	bic.w	r2, r0, #2147483648	; 0x80000000
 802c2ba:	f1b2 5f7e 	cmp.w	r2, #1065353216	; 0x3f800000
 802c2be:	da43      	bge.n	802c348 <log1pf+0xa4>
 802c2c0:	f1b2 5f44 	cmp.w	r2, #822083584	; 0x31000000
 802c2c4:	da4e      	bge.n	802c364 <log1pf+0xc0>
 802c2c6:	ed9f 7a79 	vldr	s14, [pc, #484]	; 802c4ac <log1pf+0x208>
 802c2ca:	ee37 7a87 	vadd.f32	s14, s15, s14
 802c2ce:	eeb5 7ac0 	vcmpe.f32	s14, #0.0
 802c2d2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802c2d6:	dd02      	ble.n	802c2de <log1pf+0x3a>
 802c2d8:	f1b2 5f12 	cmp.w	r2, #612368384	; 0x24800000
 802c2dc:	db31      	blt.n	802c342 <log1pf+0x9e>
 802c2de:	ee67 6ae7 	vnmul.f32	s13, s15, s15
 802c2e2:	eeb6 7a00 	vmov.f32	s14, #96	; 0x60
 802c2e6:	eee6 7a87 	vfma.f32	s15, s13, s14
 802c2ea:	e02a      	b.n	802c342 <log1pf+0x9e>
 802c2ec:	f1b0 4fb4 	cmp.w	r0, #1509949440	; 0x5a000000
 802c2f0:	db3d      	blt.n	802c36e <log1pf+0xca>
 802c2f2:	15da      	asrs	r2, r3, #23
 802c2f4:	eddf 4a6e 	vldr	s9, [pc, #440]	; 802c4b0 <log1pf+0x20c>
 802c2f8:	3a7f      	subs	r2, #127	; 0x7f
 802c2fa:	496e      	ldr	r1, [pc, #440]	; (802c4b4 <log1pf+0x210>)
 802c2fc:	f3c3 0316 	ubfx	r3, r3, #0, #23
 802c300:	428b      	cmp	r3, r1
 802c302:	f300 8090 	bgt.w	802c426 <log1pf+0x182>
 802c306:	f043 517e 	orr.w	r1, r3, #1065353216	; 0x3f800000
 802c30a:	ee07 1a90 	vmov	s15, r1
 802c30e:	eef7 6a00 	vmov.f32	s13, #112	; 0x70
 802c312:	ee37 6ae6 	vsub.f32	s12, s15, s13
 802c316:	eeb6 7a00 	vmov.f32	s14, #96	; 0x60
 802c31a:	ee26 7a07 	vmul.f32	s14, s12, s14
 802c31e:	ee26 7a07 	vmul.f32	s14, s12, s14
 802c322:	2b00      	cmp	r3, #0
 802c324:	d141      	bne.n	802c3aa <log1pf+0x106>
 802c326:	eeb5 6a40 	vcmp.f32	s12, #0.0
 802c32a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802c32e:	f040 8083 	bne.w	802c438 <log1pf+0x194>
 802c332:	2a00      	cmp	r2, #0
 802c334:	f040 80a9 	bne.w	802c48a <log1pf+0x1e6>
 802c338:	eddf 7a5d 	vldr	s15, [pc, #372]	; 802c4b0 <log1pf+0x20c>
 802c33c:	e001      	b.n	802c342 <log1pf+0x9e>
 802c33e:	ee77 7aa7 	vadd.f32	s15, s15, s15
 802c342:	ee17 0a90 	vmov	r0, s15
 802c346:	4770      	bx	lr
 802c348:	eebf 7a00 	vmov.f32	s14, #240	; 0xf0
 802c34c:	eef4 7a47 	vcmp.f32	s15, s14
 802c350:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802c354:	d17a      	bne.n	802c44c <log1pf+0x1a8>
 802c356:	eddf 7a58 	vldr	s15, [pc, #352]	; 802c4b8 <log1pf+0x214>
 802c35a:	ed9f 7a55 	vldr	s14, [pc, #340]	; 802c4b0 <log1pf+0x20c>
 802c35e:	eec7 7a87 	vdiv.f32	s15, s15, s14
 802c362:	e7ee      	b.n	802c342 <log1pf+0x9e>
 802c364:	4a55      	ldr	r2, [pc, #340]	; (802c4bc <log1pf+0x218>)
 802c366:	4611      	mov	r1, r2
 802c368:	4402      	add	r2, r0
 802c36a:	428a      	cmp	r2, r1
 802c36c:	d814      	bhi.n	802c398 <log1pf+0xf4>
 802c36e:	eef7 6a00 	vmov.f32	s13, #112	; 0x70
 802c372:	ee77 4aa6 	vadd.f32	s9, s15, s13
 802c376:	ee14 3a90 	vmov	r3, s9
 802c37a:	15da      	asrs	r2, r3, #23
 802c37c:	3a7f      	subs	r2, #127	; 0x7f
 802c37e:	2a00      	cmp	r2, #0
 802c380:	bfcb      	itete	gt
 802c382:	ee74 7ae7 	vsubgt.f32	s15, s9, s15
 802c386:	ee74 6ae6 	vsuble.f32	s13, s9, s13
 802c38a:	ee76 7ae7 	vsubgt.f32	s15, s13, s15
 802c38e:	ee77 7ae6 	vsuble.f32	s15, s15, s13
 802c392:	eec7 4aa4 	vdiv.f32	s9, s15, s9
 802c396:	e7b0      	b.n	802c2fa <log1pf+0x56>
 802c398:	eeb6 7a00 	vmov.f32	s14, #96	; 0x60
 802c39c:	ee27 7a87 	vmul.f32	s14, s15, s14
 802c3a0:	ee06 0a10 	vmov	s12, r0
 802c3a4:	ee27 7a87 	vmul.f32	s14, s15, s14
 802c3a8:	2200      	movs	r2, #0
 802c3aa:	eef0 5a00 	vmov.f32	s11, #0
 802c3ae:	ee76 5a25 	vadd.f32	s11, s12, s11
 802c3b2:	ed9f 2a43 	vldr	s4, [pc, #268]	; 802c4c0 <log1pf+0x21c>
 802c3b6:	eddf 2a43 	vldr	s5, [pc, #268]	; 802c4c4 <log1pf+0x220>
 802c3ba:	ed9f 3a43 	vldr	s6, [pc, #268]	; 802c4c8 <log1pf+0x224>
 802c3be:	eddf 3a43 	vldr	s7, [pc, #268]	; 802c4cc <log1pf+0x228>
 802c3c2:	ed9f 4a43 	vldr	s8, [pc, #268]	; 802c4d0 <log1pf+0x22c>
 802c3c6:	eddf 7a43 	vldr	s15, [pc, #268]	; 802c4d4 <log1pf+0x230>
 802c3ca:	ed9f 5a43 	vldr	s10, [pc, #268]	; 802c4d8 <log1pf+0x234>
 802c3ce:	eec6 5a25 	vdiv.f32	s11, s12, s11
 802c3d2:	ee65 6aa5 	vmul.f32	s13, s11, s11
 802c3d6:	eee6 2a82 	vfma.f32	s5, s13, s4
 802c3da:	eea2 3aa6 	vfma.f32	s6, s5, s13
 802c3de:	eee3 3a26 	vfma.f32	s7, s6, s13
 802c3e2:	eea3 4aa6 	vfma.f32	s8, s7, s13
 802c3e6:	eee4 7a26 	vfma.f32	s15, s8, s13
 802c3ea:	eea7 5aa6 	vfma.f32	s10, s15, s13
 802c3ee:	ee25 5a26 	vmul.f32	s10, s10, s13
 802c3f2:	b382      	cbz	r2, 802c456 <log1pf+0x1b2>
 802c3f4:	ee07 2a90 	vmov	s15, r2
 802c3f8:	eef8 6ae7 	vcvt.f32.s32	s13, s15
 802c3fc:	eddf 7a37 	vldr	s15, [pc, #220]	; 802c4dc <log1pf+0x238>
 802c400:	ed9f 4a37 	vldr	s8, [pc, #220]	; 802c4e0 <log1pf+0x23c>
 802c404:	eee6 4aa7 	vfma.f32	s9, s13, s15
 802c408:	ee37 5a05 	vadd.f32	s10, s14, s10
 802c40c:	eef0 7a64 	vmov.f32	s15, s9
 802c410:	eee5 7a25 	vfma.f32	s15, s10, s11
 802c414:	ee37 7a67 	vsub.f32	s14, s14, s15
 802c418:	ee77 7a46 	vsub.f32	s15, s14, s12
 802c41c:	eed6 7a84 	vfnms.f32	s15, s13, s8
 802c420:	ee17 0a90 	vmov	r0, s15
 802c424:	4770      	bx	lr
 802c426:	f5c3 0100 	rsb	r1, r3, #8388608	; 0x800000
 802c42a:	f043 537c 	orr.w	r3, r3, #1056964608	; 0x3f000000
 802c42e:	ee07 3a90 	vmov	s15, r3
 802c432:	3201      	adds	r2, #1
 802c434:	108b      	asrs	r3, r1, #2
 802c436:	e76a      	b.n	802c30e <log1pf+0x6a>
 802c438:	eddf 7a27 	vldr	s15, [pc, #156]	; 802c4d8 <log1pf+0x234>
 802c43c:	eee6 6a67 	vfms.f32	s13, s12, s15
 802c440:	ee26 7a87 	vmul.f32	s14, s13, s14
 802c444:	b982      	cbnz	r2, 802c468 <log1pf+0x1c4>
 802c446:	ee76 7a47 	vsub.f32	s15, s12, s14
 802c44a:	e77a      	b.n	802c342 <log1pf+0x9e>
 802c44c:	ee77 7ae7 	vsub.f32	s15, s15, s15
 802c450:	eec7 7aa7 	vdiv.f32	s15, s15, s15
 802c454:	e775      	b.n	802c342 <log1pf+0x9e>
 802c456:	ee37 5a05 	vadd.f32	s10, s14, s10
 802c45a:	eef0 7a47 	vmov.f32	s15, s14
 802c45e:	eee5 7a65 	vfms.f32	s15, s10, s11
 802c462:	ee76 7a67 	vsub.f32	s15, s12, s15
 802c466:	e76c      	b.n	802c342 <log1pf+0x9e>
 802c468:	ee07 2a90 	vmov	s15, r2
 802c46c:	eef8 6ae7 	vcvt.f32.s32	s13, s15
 802c470:	eddf 7a1a 	vldr	s15, [pc, #104]	; 802c4dc <log1pf+0x238>
 802c474:	eddf 5a1a 	vldr	s11, [pc, #104]	; 802c4e0 <log1pf+0x23c>
 802c478:	eee6 4aa7 	vfma.f32	s9, s13, s15
 802c47c:	ee77 7a64 	vsub.f32	s15, s14, s9
 802c480:	ee77 7ac6 	vsub.f32	s15, s15, s12
 802c484:	eed6 7aa5 	vfnms.f32	s15, s13, s11
 802c488:	e75b      	b.n	802c342 <log1pf+0x9e>
 802c48a:	ee07 2a90 	vmov	s15, r2
 802c48e:	eef8 6ae7 	vcvt.f32.s32	s13, s15
 802c492:	eddf 7a12 	vldr	s15, [pc, #72]	; 802c4dc <log1pf+0x238>
 802c496:	ed9f 7a12 	vldr	s14, [pc, #72]	; 802c4e0 <log1pf+0x23c>
 802c49a:	eee6 4aa7 	vfma.f32	s9, s13, s15
 802c49e:	eef0 7a64 	vmov.f32	s15, s9
 802c4a2:	eee6 7a87 	vfma.f32	s15, s13, s14
 802c4a6:	e74c      	b.n	802c342 <log1pf+0x9e>
 802c4a8:	3ed413d6 	.word	0x3ed413d6
 802c4ac:	4c000000 	.word	0x4c000000
 802c4b0:	00000000 	.word	0x00000000
 802c4b4:	003504f6 	.word	0x003504f6
 802c4b8:	cc000000 	.word	0xcc000000
 802c4bc:	416a09e0 	.word	0x416a09e0
 802c4c0:	3e178897 	.word	0x3e178897
 802c4c4:	3e1cd04f 	.word	0x3e1cd04f
 802c4c8:	3e3a3325 	.word	0x3e3a3325
 802c4cc:	3e638e29 	.word	0x3e638e29
 802c4d0:	3e924925 	.word	0x3e924925
 802c4d4:	3ecccccd 	.word	0x3ecccccd
 802c4d8:	3f2aaaab 	.word	0x3f2aaaab
 802c4dc:	3717f7d1 	.word	0x3717f7d1
 802c4e0:	3f317180 	.word	0x3f317180

0802c4e4 <nanf>:
 802c4e4:	4800      	ldr	r0, [pc, #0]	; (802c4e8 <nanf+0x4>)
 802c4e6:	4770      	bx	lr
 802c4e8:	7fc00000 	.word	0x7fc00000

0802c4ec <scalbnf>:
 802c4ec:	b500      	push	{lr}
 802c4ee:	ed2d 8b02 	vpush	{d8}
 802c4f2:	b083      	sub	sp, #12
 802c4f4:	9001      	str	r0, [sp, #4]
 802c4f6:	9b01      	ldr	r3, [sp, #4]
 802c4f8:	f033 4200 	bics.w	r2, r3, #2147483648	; 0x80000000
 802c4fc:	d023      	beq.n	802c546 <scalbnf+0x5a>
 802c4fe:	f1b2 4fff 	cmp.w	r2, #2139095040	; 0x7f800000
 802c502:	d215      	bcs.n	802c530 <scalbnf+0x44>
 802c504:	f5b2 0f00 	cmp.w	r2, #8388608	; 0x800000
 802c508:	d326      	bcc.n	802c558 <scalbnf+0x6c>
 802c50a:	0dd2      	lsrs	r2, r2, #23
 802c50c:	440a      	add	r2, r1
 802c50e:	2afe      	cmp	r2, #254	; 0xfe
 802c510:	dc3c      	bgt.n	802c58c <scalbnf+0xa0>
 802c512:	2a00      	cmp	r2, #0
 802c514:	dd30      	ble.n	802c578 <scalbnf+0x8c>
 802c516:	f023 43ff 	bic.w	r3, r3, #2139095040	; 0x7f800000
 802c51a:	ea43 53c2 	orr.w	r3, r3, r2, lsl #23
 802c51e:	ee07 3a90 	vmov	s15, r3
 802c522:	ee17 0a90 	vmov	r0, s15
 802c526:	b003      	add	sp, #12
 802c528:	ecbd 8b02 	vpop	{d8}
 802c52c:	f85d fb04 	ldr.w	pc, [sp], #4
 802c530:	ee07 0a90 	vmov	s15, r0
 802c534:	ee77 7aa7 	vadd.f32	s15, s15, s15
 802c538:	ee17 0a90 	vmov	r0, s15
 802c53c:	b003      	add	sp, #12
 802c53e:	ecbd 8b02 	vpop	{d8}
 802c542:	f85d fb04 	ldr.w	pc, [sp], #4
 802c546:	eddd 7a01 	vldr	s15, [sp, #4]
 802c54a:	ee17 0a90 	vmov	r0, s15
 802c54e:	b003      	add	sp, #12
 802c550:	ecbd 8b02 	vpop	{d8}
 802c554:	f85d fb04 	ldr.w	pc, [sp], #4
 802c558:	ed9d 7a01 	vldr	s14, [sp, #4]
 802c55c:	eddf 7a1e 	vldr	s15, [pc, #120]	; 802c5d8 <scalbnf+0xec>
 802c560:	4b1e      	ldr	r3, [pc, #120]	; (802c5dc <scalbnf+0xf0>)
 802c562:	ee67 7a27 	vmul.f32	s15, s14, s15
 802c566:	4299      	cmp	r1, r3
 802c568:	edcd 7a01 	vstr	s15, [sp, #4]
 802c56c:	db20      	blt.n	802c5b0 <scalbnf+0xc4>
 802c56e:	9b01      	ldr	r3, [sp, #4]
 802c570:	f3c3 52c7 	ubfx	r2, r3, #23, #8
 802c574:	3a19      	subs	r2, #25
 802c576:	e7c9      	b.n	802c50c <scalbnf+0x20>
 802c578:	f112 0f16 	cmn.w	r2, #22
 802c57c:	da1f      	bge.n	802c5be <scalbnf+0xd2>
 802c57e:	f24c 3350 	movw	r3, #50000	; 0xc350
 802c582:	4299      	cmp	r1, r3
 802c584:	dc02      	bgt.n	802c58c <scalbnf+0xa0>
 802c586:	ed9f 8a16 	vldr	s16, [pc, #88]	; 802c5e0 <scalbnf+0xf4>
 802c58a:	e001      	b.n	802c590 <scalbnf+0xa4>
 802c58c:	ed9f 8a15 	vldr	s16, [pc, #84]	; 802c5e4 <scalbnf+0xf8>
 802c590:	9901      	ldr	r1, [sp, #4]
 802c592:	ee18 0a10 	vmov	r0, s16
 802c596:	f000 f829 	bl	802c5ec <copysignf>
 802c59a:	ee07 0a90 	vmov	s15, r0
 802c59e:	ee67 7a88 	vmul.f32	s15, s15, s16
 802c5a2:	ee17 0a90 	vmov	r0, s15
 802c5a6:	b003      	add	sp, #12
 802c5a8:	ecbd 8b02 	vpop	{d8}
 802c5ac:	f85d fb04 	ldr.w	pc, [sp], #4
 802c5b0:	eddf 7a0b 	vldr	s15, [pc, #44]	; 802c5e0 <scalbnf+0xf4>
 802c5b4:	ed9d 7a01 	vldr	s14, [sp, #4]
 802c5b8:	ee67 7a27 	vmul.f32	s15, s14, s15
 802c5bc:	e7bc      	b.n	802c538 <scalbnf+0x4c>
 802c5be:	3219      	adds	r2, #25
 802c5c0:	f023 43ff 	bic.w	r3, r3, #2139095040	; 0x7f800000
 802c5c4:	ea43 53c2 	orr.w	r3, r3, r2, lsl #23
 802c5c8:	ed9f 7a07 	vldr	s14, [pc, #28]	; 802c5e8 <scalbnf+0xfc>
 802c5cc:	ee07 3a90 	vmov	s15, r3
 802c5d0:	ee67 7a87 	vmul.f32	s15, s15, s14
 802c5d4:	e7b0      	b.n	802c538 <scalbnf+0x4c>
 802c5d6:	bf00      	nop
 802c5d8:	4c000000 	.word	0x4c000000
 802c5dc:	ffff3cb0 	.word	0xffff3cb0
 802c5e0:	0da24260 	.word	0x0da24260
 802c5e4:	7149f2ca 	.word	0x7149f2ca
 802c5e8:	33000000 	.word	0x33000000

0802c5ec <copysignf>:
 802c5ec:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 802c5f0:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
 802c5f4:	4308      	orrs	r0, r1
 802c5f6:	4770      	bx	lr

0802c5f8 <__aeabi_drsub>:
 802c5f8:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 802c5fc:	e002      	b.n	802c604 <__adddf3>
 802c5fe:	bf00      	nop

0802c600 <__aeabi_dsub>:
 802c600:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

0802c604 <__adddf3>:
 802c604:	b530      	push	{r4, r5, lr}
 802c606:	ea4f 0441 	mov.w	r4, r1, lsl #1
 802c60a:	ea4f 0543 	mov.w	r5, r3, lsl #1
 802c60e:	ea94 0f05 	teq	r4, r5
 802c612:	bf08      	it	eq
 802c614:	ea90 0f02 	teqeq	r0, r2
 802c618:	bf1f      	itttt	ne
 802c61a:	ea54 0c00 	orrsne.w	ip, r4, r0
 802c61e:	ea55 0c02 	orrsne.w	ip, r5, r2
 802c622:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 802c626:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 802c62a:	f000 80e2 	beq.w	802c7f2 <__adddf3+0x1ee>
 802c62e:	ea4f 5454 	mov.w	r4, r4, lsr #21
 802c632:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 802c636:	bfb8      	it	lt
 802c638:	426d      	neglt	r5, r5
 802c63a:	dd0c      	ble.n	802c656 <__adddf3+0x52>
 802c63c:	442c      	add	r4, r5
 802c63e:	ea80 0202 	eor.w	r2, r0, r2
 802c642:	ea81 0303 	eor.w	r3, r1, r3
 802c646:	ea82 0000 	eor.w	r0, r2, r0
 802c64a:	ea83 0101 	eor.w	r1, r3, r1
 802c64e:	ea80 0202 	eor.w	r2, r0, r2
 802c652:	ea81 0303 	eor.w	r3, r1, r3
 802c656:	2d36      	cmp	r5, #54	; 0x36
 802c658:	bf88      	it	hi
 802c65a:	bd30      	pophi	{r4, r5, pc}
 802c65c:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 802c660:	ea4f 3101 	mov.w	r1, r1, lsl #12
 802c664:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 802c668:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 802c66c:	d002      	beq.n	802c674 <__adddf3+0x70>
 802c66e:	4240      	negs	r0, r0
 802c670:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 802c674:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 802c678:	ea4f 3303 	mov.w	r3, r3, lsl #12
 802c67c:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 802c680:	d002      	beq.n	802c688 <__adddf3+0x84>
 802c682:	4252      	negs	r2, r2
 802c684:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 802c688:	ea94 0f05 	teq	r4, r5
 802c68c:	f000 80a7 	beq.w	802c7de <__adddf3+0x1da>
 802c690:	f1a4 0401 	sub.w	r4, r4, #1
 802c694:	f1d5 0e20 	rsbs	lr, r5, #32
 802c698:	db0d      	blt.n	802c6b6 <__adddf3+0xb2>
 802c69a:	fa02 fc0e 	lsl.w	ip, r2, lr
 802c69e:	fa22 f205 	lsr.w	r2, r2, r5
 802c6a2:	1880      	adds	r0, r0, r2
 802c6a4:	f141 0100 	adc.w	r1, r1, #0
 802c6a8:	fa03 f20e 	lsl.w	r2, r3, lr
 802c6ac:	1880      	adds	r0, r0, r2
 802c6ae:	fa43 f305 	asr.w	r3, r3, r5
 802c6b2:	4159      	adcs	r1, r3
 802c6b4:	e00e      	b.n	802c6d4 <__adddf3+0xd0>
 802c6b6:	f1a5 0520 	sub.w	r5, r5, #32
 802c6ba:	f10e 0e20 	add.w	lr, lr, #32
 802c6be:	2a01      	cmp	r2, #1
 802c6c0:	fa03 fc0e 	lsl.w	ip, r3, lr
 802c6c4:	bf28      	it	cs
 802c6c6:	f04c 0c02 	orrcs.w	ip, ip, #2
 802c6ca:	fa43 f305 	asr.w	r3, r3, r5
 802c6ce:	18c0      	adds	r0, r0, r3
 802c6d0:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 802c6d4:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 802c6d8:	d507      	bpl.n	802c6ea <__adddf3+0xe6>
 802c6da:	f04f 0e00 	mov.w	lr, #0
 802c6de:	f1dc 0c00 	rsbs	ip, ip, #0
 802c6e2:	eb7e 0000 	sbcs.w	r0, lr, r0
 802c6e6:	eb6e 0101 	sbc.w	r1, lr, r1
 802c6ea:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 802c6ee:	d31b      	bcc.n	802c728 <__adddf3+0x124>
 802c6f0:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 802c6f4:	d30c      	bcc.n	802c710 <__adddf3+0x10c>
 802c6f6:	0849      	lsrs	r1, r1, #1
 802c6f8:	ea5f 0030 	movs.w	r0, r0, rrx
 802c6fc:	ea4f 0c3c 	mov.w	ip, ip, rrx
 802c700:	f104 0401 	add.w	r4, r4, #1
 802c704:	ea4f 5244 	mov.w	r2, r4, lsl #21
 802c708:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 802c70c:	f080 809a 	bcs.w	802c844 <__adddf3+0x240>
 802c710:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 802c714:	bf08      	it	eq
 802c716:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 802c71a:	f150 0000 	adcs.w	r0, r0, #0
 802c71e:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 802c722:	ea41 0105 	orr.w	r1, r1, r5
 802c726:	bd30      	pop	{r4, r5, pc}
 802c728:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 802c72c:	4140      	adcs	r0, r0
 802c72e:	eb41 0101 	adc.w	r1, r1, r1
 802c732:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 802c736:	f1a4 0401 	sub.w	r4, r4, #1
 802c73a:	d1e9      	bne.n	802c710 <__adddf3+0x10c>
 802c73c:	f091 0f00 	teq	r1, #0
 802c740:	bf04      	itt	eq
 802c742:	4601      	moveq	r1, r0
 802c744:	2000      	moveq	r0, #0
 802c746:	fab1 f381 	clz	r3, r1
 802c74a:	bf08      	it	eq
 802c74c:	3320      	addeq	r3, #32
 802c74e:	f1a3 030b 	sub.w	r3, r3, #11
 802c752:	f1b3 0220 	subs.w	r2, r3, #32
 802c756:	da0c      	bge.n	802c772 <__adddf3+0x16e>
 802c758:	320c      	adds	r2, #12
 802c75a:	dd08      	ble.n	802c76e <__adddf3+0x16a>
 802c75c:	f102 0c14 	add.w	ip, r2, #20
 802c760:	f1c2 020c 	rsb	r2, r2, #12
 802c764:	fa01 f00c 	lsl.w	r0, r1, ip
 802c768:	fa21 f102 	lsr.w	r1, r1, r2
 802c76c:	e00c      	b.n	802c788 <__adddf3+0x184>
 802c76e:	f102 0214 	add.w	r2, r2, #20
 802c772:	bfd8      	it	le
 802c774:	f1c2 0c20 	rsble	ip, r2, #32
 802c778:	fa01 f102 	lsl.w	r1, r1, r2
 802c77c:	fa20 fc0c 	lsr.w	ip, r0, ip
 802c780:	bfdc      	itt	le
 802c782:	ea41 010c 	orrle.w	r1, r1, ip
 802c786:	4090      	lslle	r0, r2
 802c788:	1ae4      	subs	r4, r4, r3
 802c78a:	bfa2      	ittt	ge
 802c78c:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 802c790:	4329      	orrge	r1, r5
 802c792:	bd30      	popge	{r4, r5, pc}
 802c794:	ea6f 0404 	mvn.w	r4, r4
 802c798:	3c1f      	subs	r4, #31
 802c79a:	da1c      	bge.n	802c7d6 <__adddf3+0x1d2>
 802c79c:	340c      	adds	r4, #12
 802c79e:	dc0e      	bgt.n	802c7be <__adddf3+0x1ba>
 802c7a0:	f104 0414 	add.w	r4, r4, #20
 802c7a4:	f1c4 0220 	rsb	r2, r4, #32
 802c7a8:	fa20 f004 	lsr.w	r0, r0, r4
 802c7ac:	fa01 f302 	lsl.w	r3, r1, r2
 802c7b0:	ea40 0003 	orr.w	r0, r0, r3
 802c7b4:	fa21 f304 	lsr.w	r3, r1, r4
 802c7b8:	ea45 0103 	orr.w	r1, r5, r3
 802c7bc:	bd30      	pop	{r4, r5, pc}
 802c7be:	f1c4 040c 	rsb	r4, r4, #12
 802c7c2:	f1c4 0220 	rsb	r2, r4, #32
 802c7c6:	fa20 f002 	lsr.w	r0, r0, r2
 802c7ca:	fa01 f304 	lsl.w	r3, r1, r4
 802c7ce:	ea40 0003 	orr.w	r0, r0, r3
 802c7d2:	4629      	mov	r1, r5
 802c7d4:	bd30      	pop	{r4, r5, pc}
 802c7d6:	fa21 f004 	lsr.w	r0, r1, r4
 802c7da:	4629      	mov	r1, r5
 802c7dc:	bd30      	pop	{r4, r5, pc}
 802c7de:	f094 0f00 	teq	r4, #0
 802c7e2:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 802c7e6:	bf06      	itte	eq
 802c7e8:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 802c7ec:	3401      	addeq	r4, #1
 802c7ee:	3d01      	subne	r5, #1
 802c7f0:	e74e      	b.n	802c690 <__adddf3+0x8c>
 802c7f2:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 802c7f6:	bf18      	it	ne
 802c7f8:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 802c7fc:	d029      	beq.n	802c852 <__adddf3+0x24e>
 802c7fe:	ea94 0f05 	teq	r4, r5
 802c802:	bf08      	it	eq
 802c804:	ea90 0f02 	teqeq	r0, r2
 802c808:	d005      	beq.n	802c816 <__adddf3+0x212>
 802c80a:	ea54 0c00 	orrs.w	ip, r4, r0
 802c80e:	bf04      	itt	eq
 802c810:	4619      	moveq	r1, r3
 802c812:	4610      	moveq	r0, r2
 802c814:	bd30      	pop	{r4, r5, pc}
 802c816:	ea91 0f03 	teq	r1, r3
 802c81a:	bf1e      	ittt	ne
 802c81c:	2100      	movne	r1, #0
 802c81e:	2000      	movne	r0, #0
 802c820:	bd30      	popne	{r4, r5, pc}
 802c822:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 802c826:	d105      	bne.n	802c834 <__adddf3+0x230>
 802c828:	0040      	lsls	r0, r0, #1
 802c82a:	4149      	adcs	r1, r1
 802c82c:	bf28      	it	cs
 802c82e:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 802c832:	bd30      	pop	{r4, r5, pc}
 802c834:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 802c838:	bf3c      	itt	cc
 802c83a:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 802c83e:	bd30      	popcc	{r4, r5, pc}
 802c840:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 802c844:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 802c848:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 802c84c:	f04f 0000 	mov.w	r0, #0
 802c850:	bd30      	pop	{r4, r5, pc}
 802c852:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 802c856:	bf1a      	itte	ne
 802c858:	4619      	movne	r1, r3
 802c85a:	4610      	movne	r0, r2
 802c85c:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 802c860:	bf1c      	itt	ne
 802c862:	460b      	movne	r3, r1
 802c864:	4602      	movne	r2, r0
 802c866:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 802c86a:	bf06      	itte	eq
 802c86c:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 802c870:	ea91 0f03 	teqeq	r1, r3
 802c874:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 802c878:	bd30      	pop	{r4, r5, pc}
 802c87a:	bf00      	nop

0802c87c <__aeabi_ui2d>:
 802c87c:	f090 0f00 	teq	r0, #0
 802c880:	bf04      	itt	eq
 802c882:	2100      	moveq	r1, #0
 802c884:	4770      	bxeq	lr
 802c886:	b530      	push	{r4, r5, lr}
 802c888:	f44f 6480 	mov.w	r4, #1024	; 0x400
 802c88c:	f104 0432 	add.w	r4, r4, #50	; 0x32
 802c890:	f04f 0500 	mov.w	r5, #0
 802c894:	f04f 0100 	mov.w	r1, #0
 802c898:	e750      	b.n	802c73c <__adddf3+0x138>
 802c89a:	bf00      	nop

0802c89c <__aeabi_i2d>:
 802c89c:	f090 0f00 	teq	r0, #0
 802c8a0:	bf04      	itt	eq
 802c8a2:	2100      	moveq	r1, #0
 802c8a4:	4770      	bxeq	lr
 802c8a6:	b530      	push	{r4, r5, lr}
 802c8a8:	f44f 6480 	mov.w	r4, #1024	; 0x400
 802c8ac:	f104 0432 	add.w	r4, r4, #50	; 0x32
 802c8b0:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 802c8b4:	bf48      	it	mi
 802c8b6:	4240      	negmi	r0, r0
 802c8b8:	f04f 0100 	mov.w	r1, #0
 802c8bc:	e73e      	b.n	802c73c <__adddf3+0x138>
 802c8be:	bf00      	nop

0802c8c0 <__aeabi_f2d>:
 802c8c0:	0042      	lsls	r2, r0, #1
 802c8c2:	ea4f 01e2 	mov.w	r1, r2, asr #3
 802c8c6:	ea4f 0131 	mov.w	r1, r1, rrx
 802c8ca:	ea4f 7002 	mov.w	r0, r2, lsl #28
 802c8ce:	bf1f      	itttt	ne
 802c8d0:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 802c8d4:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 802c8d8:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 802c8dc:	4770      	bxne	lr
 802c8de:	f092 0f00 	teq	r2, #0
 802c8e2:	bf14      	ite	ne
 802c8e4:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 802c8e8:	4770      	bxeq	lr
 802c8ea:	b530      	push	{r4, r5, lr}
 802c8ec:	f44f 7460 	mov.w	r4, #896	; 0x380
 802c8f0:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 802c8f4:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 802c8f8:	e720      	b.n	802c73c <__adddf3+0x138>
 802c8fa:	bf00      	nop

0802c8fc <__aeabi_ul2d>:
 802c8fc:	ea50 0201 	orrs.w	r2, r0, r1
 802c900:	bf08      	it	eq
 802c902:	4770      	bxeq	lr
 802c904:	b530      	push	{r4, r5, lr}
 802c906:	f04f 0500 	mov.w	r5, #0
 802c90a:	e00a      	b.n	802c922 <__aeabi_l2d+0x16>

0802c90c <__aeabi_l2d>:
 802c90c:	ea50 0201 	orrs.w	r2, r0, r1
 802c910:	bf08      	it	eq
 802c912:	4770      	bxeq	lr
 802c914:	b530      	push	{r4, r5, lr}
 802c916:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 802c91a:	d502      	bpl.n	802c922 <__aeabi_l2d+0x16>
 802c91c:	4240      	negs	r0, r0
 802c91e:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 802c922:	f44f 6480 	mov.w	r4, #1024	; 0x400
 802c926:	f104 0432 	add.w	r4, r4, #50	; 0x32
 802c92a:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 802c92e:	f43f aedc 	beq.w	802c6ea <__adddf3+0xe6>
 802c932:	f04f 0203 	mov.w	r2, #3
 802c936:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 802c93a:	bf18      	it	ne
 802c93c:	3203      	addne	r2, #3
 802c93e:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 802c942:	bf18      	it	ne
 802c944:	3203      	addne	r2, #3
 802c946:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 802c94a:	f1c2 0320 	rsb	r3, r2, #32
 802c94e:	fa00 fc03 	lsl.w	ip, r0, r3
 802c952:	fa20 f002 	lsr.w	r0, r0, r2
 802c956:	fa01 fe03 	lsl.w	lr, r1, r3
 802c95a:	ea40 000e 	orr.w	r0, r0, lr
 802c95e:	fa21 f102 	lsr.w	r1, r1, r2
 802c962:	4414      	add	r4, r2
 802c964:	e6c1      	b.n	802c6ea <__adddf3+0xe6>
 802c966:	bf00      	nop

0802c968 <__aeabi_dmul>:
 802c968:	b570      	push	{r4, r5, r6, lr}
 802c96a:	f04f 0cff 	mov.w	ip, #255	; 0xff
 802c96e:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 802c972:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 802c976:	bf1d      	ittte	ne
 802c978:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 802c97c:	ea94 0f0c 	teqne	r4, ip
 802c980:	ea95 0f0c 	teqne	r5, ip
 802c984:	f000 f8de 	bleq	802cb44 <__aeabi_dmul+0x1dc>
 802c988:	442c      	add	r4, r5
 802c98a:	ea81 0603 	eor.w	r6, r1, r3
 802c98e:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 802c992:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 802c996:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 802c99a:	bf18      	it	ne
 802c99c:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 802c9a0:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 802c9a4:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 802c9a8:	d038      	beq.n	802ca1c <__aeabi_dmul+0xb4>
 802c9aa:	fba0 ce02 	umull	ip, lr, r0, r2
 802c9ae:	f04f 0500 	mov.w	r5, #0
 802c9b2:	fbe1 e502 	umlal	lr, r5, r1, r2
 802c9b6:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 802c9ba:	fbe0 e503 	umlal	lr, r5, r0, r3
 802c9be:	f04f 0600 	mov.w	r6, #0
 802c9c2:	fbe1 5603 	umlal	r5, r6, r1, r3
 802c9c6:	f09c 0f00 	teq	ip, #0
 802c9ca:	bf18      	it	ne
 802c9cc:	f04e 0e01 	orrne.w	lr, lr, #1
 802c9d0:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 802c9d4:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 802c9d8:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 802c9dc:	d204      	bcs.n	802c9e8 <__aeabi_dmul+0x80>
 802c9de:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 802c9e2:	416d      	adcs	r5, r5
 802c9e4:	eb46 0606 	adc.w	r6, r6, r6
 802c9e8:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 802c9ec:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 802c9f0:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 802c9f4:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 802c9f8:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 802c9fc:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 802ca00:	bf88      	it	hi
 802ca02:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 802ca06:	d81e      	bhi.n	802ca46 <__aeabi_dmul+0xde>
 802ca08:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 802ca0c:	bf08      	it	eq
 802ca0e:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 802ca12:	f150 0000 	adcs.w	r0, r0, #0
 802ca16:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 802ca1a:	bd70      	pop	{r4, r5, r6, pc}
 802ca1c:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 802ca20:	ea46 0101 	orr.w	r1, r6, r1
 802ca24:	ea40 0002 	orr.w	r0, r0, r2
 802ca28:	ea81 0103 	eor.w	r1, r1, r3
 802ca2c:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 802ca30:	bfc2      	ittt	gt
 802ca32:	ebd4 050c 	rsbsgt	r5, r4, ip
 802ca36:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 802ca3a:	bd70      	popgt	{r4, r5, r6, pc}
 802ca3c:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 802ca40:	f04f 0e00 	mov.w	lr, #0
 802ca44:	3c01      	subs	r4, #1
 802ca46:	f300 80ab 	bgt.w	802cba0 <__aeabi_dmul+0x238>
 802ca4a:	f114 0f36 	cmn.w	r4, #54	; 0x36
 802ca4e:	bfde      	ittt	le
 802ca50:	2000      	movle	r0, #0
 802ca52:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 802ca56:	bd70      	pople	{r4, r5, r6, pc}
 802ca58:	f1c4 0400 	rsb	r4, r4, #0
 802ca5c:	3c20      	subs	r4, #32
 802ca5e:	da35      	bge.n	802cacc <__aeabi_dmul+0x164>
 802ca60:	340c      	adds	r4, #12
 802ca62:	dc1b      	bgt.n	802ca9c <__aeabi_dmul+0x134>
 802ca64:	f104 0414 	add.w	r4, r4, #20
 802ca68:	f1c4 0520 	rsb	r5, r4, #32
 802ca6c:	fa00 f305 	lsl.w	r3, r0, r5
 802ca70:	fa20 f004 	lsr.w	r0, r0, r4
 802ca74:	fa01 f205 	lsl.w	r2, r1, r5
 802ca78:	ea40 0002 	orr.w	r0, r0, r2
 802ca7c:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 802ca80:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 802ca84:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 802ca88:	fa21 f604 	lsr.w	r6, r1, r4
 802ca8c:	eb42 0106 	adc.w	r1, r2, r6
 802ca90:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 802ca94:	bf08      	it	eq
 802ca96:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 802ca9a:	bd70      	pop	{r4, r5, r6, pc}
 802ca9c:	f1c4 040c 	rsb	r4, r4, #12
 802caa0:	f1c4 0520 	rsb	r5, r4, #32
 802caa4:	fa00 f304 	lsl.w	r3, r0, r4
 802caa8:	fa20 f005 	lsr.w	r0, r0, r5
 802caac:	fa01 f204 	lsl.w	r2, r1, r4
 802cab0:	ea40 0002 	orr.w	r0, r0, r2
 802cab4:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 802cab8:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 802cabc:	f141 0100 	adc.w	r1, r1, #0
 802cac0:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 802cac4:	bf08      	it	eq
 802cac6:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 802caca:	bd70      	pop	{r4, r5, r6, pc}
 802cacc:	f1c4 0520 	rsb	r5, r4, #32
 802cad0:	fa00 f205 	lsl.w	r2, r0, r5
 802cad4:	ea4e 0e02 	orr.w	lr, lr, r2
 802cad8:	fa20 f304 	lsr.w	r3, r0, r4
 802cadc:	fa01 f205 	lsl.w	r2, r1, r5
 802cae0:	ea43 0302 	orr.w	r3, r3, r2
 802cae4:	fa21 f004 	lsr.w	r0, r1, r4
 802cae8:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 802caec:	fa21 f204 	lsr.w	r2, r1, r4
 802caf0:	ea20 0002 	bic.w	r0, r0, r2
 802caf4:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 802caf8:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 802cafc:	bf08      	it	eq
 802cafe:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 802cb02:	bd70      	pop	{r4, r5, r6, pc}
 802cb04:	f094 0f00 	teq	r4, #0
 802cb08:	d10f      	bne.n	802cb2a <__aeabi_dmul+0x1c2>
 802cb0a:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 802cb0e:	0040      	lsls	r0, r0, #1
 802cb10:	eb41 0101 	adc.w	r1, r1, r1
 802cb14:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 802cb18:	bf08      	it	eq
 802cb1a:	3c01      	subeq	r4, #1
 802cb1c:	d0f7      	beq.n	802cb0e <__aeabi_dmul+0x1a6>
 802cb1e:	ea41 0106 	orr.w	r1, r1, r6
 802cb22:	f095 0f00 	teq	r5, #0
 802cb26:	bf18      	it	ne
 802cb28:	4770      	bxne	lr
 802cb2a:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 802cb2e:	0052      	lsls	r2, r2, #1
 802cb30:	eb43 0303 	adc.w	r3, r3, r3
 802cb34:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 802cb38:	bf08      	it	eq
 802cb3a:	3d01      	subeq	r5, #1
 802cb3c:	d0f7      	beq.n	802cb2e <__aeabi_dmul+0x1c6>
 802cb3e:	ea43 0306 	orr.w	r3, r3, r6
 802cb42:	4770      	bx	lr
 802cb44:	ea94 0f0c 	teq	r4, ip
 802cb48:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 802cb4c:	bf18      	it	ne
 802cb4e:	ea95 0f0c 	teqne	r5, ip
 802cb52:	d00c      	beq.n	802cb6e <__aeabi_dmul+0x206>
 802cb54:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 802cb58:	bf18      	it	ne
 802cb5a:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 802cb5e:	d1d1      	bne.n	802cb04 <__aeabi_dmul+0x19c>
 802cb60:	ea81 0103 	eor.w	r1, r1, r3
 802cb64:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 802cb68:	f04f 0000 	mov.w	r0, #0
 802cb6c:	bd70      	pop	{r4, r5, r6, pc}
 802cb6e:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 802cb72:	bf06      	itte	eq
 802cb74:	4610      	moveq	r0, r2
 802cb76:	4619      	moveq	r1, r3
 802cb78:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 802cb7c:	d019      	beq.n	802cbb2 <__aeabi_dmul+0x24a>
 802cb7e:	ea94 0f0c 	teq	r4, ip
 802cb82:	d102      	bne.n	802cb8a <__aeabi_dmul+0x222>
 802cb84:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 802cb88:	d113      	bne.n	802cbb2 <__aeabi_dmul+0x24a>
 802cb8a:	ea95 0f0c 	teq	r5, ip
 802cb8e:	d105      	bne.n	802cb9c <__aeabi_dmul+0x234>
 802cb90:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 802cb94:	bf1c      	itt	ne
 802cb96:	4610      	movne	r0, r2
 802cb98:	4619      	movne	r1, r3
 802cb9a:	d10a      	bne.n	802cbb2 <__aeabi_dmul+0x24a>
 802cb9c:	ea81 0103 	eor.w	r1, r1, r3
 802cba0:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 802cba4:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 802cba8:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 802cbac:	f04f 0000 	mov.w	r0, #0
 802cbb0:	bd70      	pop	{r4, r5, r6, pc}
 802cbb2:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 802cbb6:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 802cbba:	bd70      	pop	{r4, r5, r6, pc}

0802cbbc <__aeabi_ddiv>:
 802cbbc:	b570      	push	{r4, r5, r6, lr}
 802cbbe:	f04f 0cff 	mov.w	ip, #255	; 0xff
 802cbc2:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 802cbc6:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 802cbca:	bf1d      	ittte	ne
 802cbcc:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 802cbd0:	ea94 0f0c 	teqne	r4, ip
 802cbd4:	ea95 0f0c 	teqne	r5, ip
 802cbd8:	f000 f8a7 	bleq	802cd2a <__aeabi_ddiv+0x16e>
 802cbdc:	eba4 0405 	sub.w	r4, r4, r5
 802cbe0:	ea81 0e03 	eor.w	lr, r1, r3
 802cbe4:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 802cbe8:	ea4f 3101 	mov.w	r1, r1, lsl #12
 802cbec:	f000 8088 	beq.w	802cd00 <__aeabi_ddiv+0x144>
 802cbf0:	ea4f 3303 	mov.w	r3, r3, lsl #12
 802cbf4:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 802cbf8:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 802cbfc:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 802cc00:	ea4f 2202 	mov.w	r2, r2, lsl #8
 802cc04:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 802cc08:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 802cc0c:	ea4f 2600 	mov.w	r6, r0, lsl #8
 802cc10:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 802cc14:	429d      	cmp	r5, r3
 802cc16:	bf08      	it	eq
 802cc18:	4296      	cmpeq	r6, r2
 802cc1a:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 802cc1e:	f504 7440 	add.w	r4, r4, #768	; 0x300
 802cc22:	d202      	bcs.n	802cc2a <__aeabi_ddiv+0x6e>
 802cc24:	085b      	lsrs	r3, r3, #1
 802cc26:	ea4f 0232 	mov.w	r2, r2, rrx
 802cc2a:	1ab6      	subs	r6, r6, r2
 802cc2c:	eb65 0503 	sbc.w	r5, r5, r3
 802cc30:	085b      	lsrs	r3, r3, #1
 802cc32:	ea4f 0232 	mov.w	r2, r2, rrx
 802cc36:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 802cc3a:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 802cc3e:	ebb6 0e02 	subs.w	lr, r6, r2
 802cc42:	eb75 0e03 	sbcs.w	lr, r5, r3
 802cc46:	bf22      	ittt	cs
 802cc48:	1ab6      	subcs	r6, r6, r2
 802cc4a:	4675      	movcs	r5, lr
 802cc4c:	ea40 000c 	orrcs.w	r0, r0, ip
 802cc50:	085b      	lsrs	r3, r3, #1
 802cc52:	ea4f 0232 	mov.w	r2, r2, rrx
 802cc56:	ebb6 0e02 	subs.w	lr, r6, r2
 802cc5a:	eb75 0e03 	sbcs.w	lr, r5, r3
 802cc5e:	bf22      	ittt	cs
 802cc60:	1ab6      	subcs	r6, r6, r2
 802cc62:	4675      	movcs	r5, lr
 802cc64:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 802cc68:	085b      	lsrs	r3, r3, #1
 802cc6a:	ea4f 0232 	mov.w	r2, r2, rrx
 802cc6e:	ebb6 0e02 	subs.w	lr, r6, r2
 802cc72:	eb75 0e03 	sbcs.w	lr, r5, r3
 802cc76:	bf22      	ittt	cs
 802cc78:	1ab6      	subcs	r6, r6, r2
 802cc7a:	4675      	movcs	r5, lr
 802cc7c:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 802cc80:	085b      	lsrs	r3, r3, #1
 802cc82:	ea4f 0232 	mov.w	r2, r2, rrx
 802cc86:	ebb6 0e02 	subs.w	lr, r6, r2
 802cc8a:	eb75 0e03 	sbcs.w	lr, r5, r3
 802cc8e:	bf22      	ittt	cs
 802cc90:	1ab6      	subcs	r6, r6, r2
 802cc92:	4675      	movcs	r5, lr
 802cc94:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 802cc98:	ea55 0e06 	orrs.w	lr, r5, r6
 802cc9c:	d018      	beq.n	802ccd0 <__aeabi_ddiv+0x114>
 802cc9e:	ea4f 1505 	mov.w	r5, r5, lsl #4
 802cca2:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 802cca6:	ea4f 1606 	mov.w	r6, r6, lsl #4
 802ccaa:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 802ccae:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 802ccb2:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 802ccb6:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 802ccba:	d1c0      	bne.n	802cc3e <__aeabi_ddiv+0x82>
 802ccbc:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 802ccc0:	d10b      	bne.n	802ccda <__aeabi_ddiv+0x11e>
 802ccc2:	ea41 0100 	orr.w	r1, r1, r0
 802ccc6:	f04f 0000 	mov.w	r0, #0
 802ccca:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 802ccce:	e7b6      	b.n	802cc3e <__aeabi_ddiv+0x82>
 802ccd0:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 802ccd4:	bf04      	itt	eq
 802ccd6:	4301      	orreq	r1, r0
 802ccd8:	2000      	moveq	r0, #0
 802ccda:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 802ccde:	bf88      	it	hi
 802cce0:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 802cce4:	f63f aeaf 	bhi.w	802ca46 <__aeabi_dmul+0xde>
 802cce8:	ebb5 0c03 	subs.w	ip, r5, r3
 802ccec:	bf04      	itt	eq
 802ccee:	ebb6 0c02 	subseq.w	ip, r6, r2
 802ccf2:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 802ccf6:	f150 0000 	adcs.w	r0, r0, #0
 802ccfa:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 802ccfe:	bd70      	pop	{r4, r5, r6, pc}
 802cd00:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 802cd04:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 802cd08:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 802cd0c:	bfc2      	ittt	gt
 802cd0e:	ebd4 050c 	rsbsgt	r5, r4, ip
 802cd12:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 802cd16:	bd70      	popgt	{r4, r5, r6, pc}
 802cd18:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 802cd1c:	f04f 0e00 	mov.w	lr, #0
 802cd20:	3c01      	subs	r4, #1
 802cd22:	e690      	b.n	802ca46 <__aeabi_dmul+0xde>
 802cd24:	ea45 0e06 	orr.w	lr, r5, r6
 802cd28:	e68d      	b.n	802ca46 <__aeabi_dmul+0xde>
 802cd2a:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 802cd2e:	ea94 0f0c 	teq	r4, ip
 802cd32:	bf08      	it	eq
 802cd34:	ea95 0f0c 	teqeq	r5, ip
 802cd38:	f43f af3b 	beq.w	802cbb2 <__aeabi_dmul+0x24a>
 802cd3c:	ea94 0f0c 	teq	r4, ip
 802cd40:	d10a      	bne.n	802cd58 <__aeabi_ddiv+0x19c>
 802cd42:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 802cd46:	f47f af34 	bne.w	802cbb2 <__aeabi_dmul+0x24a>
 802cd4a:	ea95 0f0c 	teq	r5, ip
 802cd4e:	f47f af25 	bne.w	802cb9c <__aeabi_dmul+0x234>
 802cd52:	4610      	mov	r0, r2
 802cd54:	4619      	mov	r1, r3
 802cd56:	e72c      	b.n	802cbb2 <__aeabi_dmul+0x24a>
 802cd58:	ea95 0f0c 	teq	r5, ip
 802cd5c:	d106      	bne.n	802cd6c <__aeabi_ddiv+0x1b0>
 802cd5e:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 802cd62:	f43f aefd 	beq.w	802cb60 <__aeabi_dmul+0x1f8>
 802cd66:	4610      	mov	r0, r2
 802cd68:	4619      	mov	r1, r3
 802cd6a:	e722      	b.n	802cbb2 <__aeabi_dmul+0x24a>
 802cd6c:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 802cd70:	bf18      	it	ne
 802cd72:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 802cd76:	f47f aec5 	bne.w	802cb04 <__aeabi_dmul+0x19c>
 802cd7a:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 802cd7e:	f47f af0d 	bne.w	802cb9c <__aeabi_dmul+0x234>
 802cd82:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 802cd86:	f47f aeeb 	bne.w	802cb60 <__aeabi_dmul+0x1f8>
 802cd8a:	e712      	b.n	802cbb2 <__aeabi_dmul+0x24a>

0802cd8c <__gedf2>:
 802cd8c:	f04f 3cff 	mov.w	ip, #4294967295
 802cd90:	e006      	b.n	802cda0 <__cmpdf2+0x4>
 802cd92:	bf00      	nop

0802cd94 <__ledf2>:
 802cd94:	f04f 0c01 	mov.w	ip, #1
 802cd98:	e002      	b.n	802cda0 <__cmpdf2+0x4>
 802cd9a:	bf00      	nop

0802cd9c <__cmpdf2>:
 802cd9c:	f04f 0c01 	mov.w	ip, #1
 802cda0:	f84d cd04 	str.w	ip, [sp, #-4]!
 802cda4:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 802cda8:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 802cdac:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 802cdb0:	bf18      	it	ne
 802cdb2:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
 802cdb6:	d01b      	beq.n	802cdf0 <__cmpdf2+0x54>
 802cdb8:	b001      	add	sp, #4
 802cdba:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
 802cdbe:	bf0c      	ite	eq
 802cdc0:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
 802cdc4:	ea91 0f03 	teqne	r1, r3
 802cdc8:	bf02      	ittt	eq
 802cdca:	ea90 0f02 	teqeq	r0, r2
 802cdce:	2000      	moveq	r0, #0
 802cdd0:	4770      	bxeq	lr
 802cdd2:	f110 0f00 	cmn.w	r0, #0
 802cdd6:	ea91 0f03 	teq	r1, r3
 802cdda:	bf58      	it	pl
 802cddc:	4299      	cmppl	r1, r3
 802cdde:	bf08      	it	eq
 802cde0:	4290      	cmpeq	r0, r2
 802cde2:	bf2c      	ite	cs
 802cde4:	17d8      	asrcs	r0, r3, #31
 802cde6:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
 802cdea:	f040 0001 	orr.w	r0, r0, #1
 802cdee:	4770      	bx	lr
 802cdf0:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 802cdf4:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 802cdf8:	d102      	bne.n	802ce00 <__cmpdf2+0x64>
 802cdfa:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 802cdfe:	d107      	bne.n	802ce10 <__cmpdf2+0x74>
 802ce00:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 802ce04:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 802ce08:	d1d6      	bne.n	802cdb8 <__cmpdf2+0x1c>
 802ce0a:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 802ce0e:	d0d3      	beq.n	802cdb8 <__cmpdf2+0x1c>
 802ce10:	f85d 0b04 	ldr.w	r0, [sp], #4
 802ce14:	4770      	bx	lr
 802ce16:	bf00      	nop

0802ce18 <__aeabi_cdrcmple>:
 802ce18:	4684      	mov	ip, r0
 802ce1a:	4610      	mov	r0, r2
 802ce1c:	4662      	mov	r2, ip
 802ce1e:	468c      	mov	ip, r1
 802ce20:	4619      	mov	r1, r3
 802ce22:	4663      	mov	r3, ip
 802ce24:	e000      	b.n	802ce28 <__aeabi_cdcmpeq>
 802ce26:	bf00      	nop

0802ce28 <__aeabi_cdcmpeq>:
 802ce28:	b501      	push	{r0, lr}
 802ce2a:	f7ff ffb7 	bl	802cd9c <__cmpdf2>
 802ce2e:	2800      	cmp	r0, #0
 802ce30:	bf48      	it	mi
 802ce32:	f110 0f00 	cmnmi.w	r0, #0
 802ce36:	bd01      	pop	{r0, pc}

0802ce38 <__aeabi_dcmpeq>:
 802ce38:	f84d ed08 	str.w	lr, [sp, #-8]!
 802ce3c:	f7ff fff4 	bl	802ce28 <__aeabi_cdcmpeq>
 802ce40:	bf0c      	ite	eq
 802ce42:	2001      	moveq	r0, #1
 802ce44:	2000      	movne	r0, #0
 802ce46:	f85d fb08 	ldr.w	pc, [sp], #8
 802ce4a:	bf00      	nop

0802ce4c <__aeabi_dcmplt>:
 802ce4c:	f84d ed08 	str.w	lr, [sp, #-8]!
 802ce50:	f7ff ffea 	bl	802ce28 <__aeabi_cdcmpeq>
 802ce54:	bf34      	ite	cc
 802ce56:	2001      	movcc	r0, #1
 802ce58:	2000      	movcs	r0, #0
 802ce5a:	f85d fb08 	ldr.w	pc, [sp], #8
 802ce5e:	bf00      	nop

0802ce60 <__aeabi_dcmple>:
 802ce60:	f84d ed08 	str.w	lr, [sp, #-8]!
 802ce64:	f7ff ffe0 	bl	802ce28 <__aeabi_cdcmpeq>
 802ce68:	bf94      	ite	ls
 802ce6a:	2001      	movls	r0, #1
 802ce6c:	2000      	movhi	r0, #0
 802ce6e:	f85d fb08 	ldr.w	pc, [sp], #8
 802ce72:	bf00      	nop

0802ce74 <__aeabi_dcmpge>:
 802ce74:	f84d ed08 	str.w	lr, [sp, #-8]!
 802ce78:	f7ff ffce 	bl	802ce18 <__aeabi_cdrcmple>
 802ce7c:	bf94      	ite	ls
 802ce7e:	2001      	movls	r0, #1
 802ce80:	2000      	movhi	r0, #0
 802ce82:	f85d fb08 	ldr.w	pc, [sp], #8
 802ce86:	bf00      	nop

0802ce88 <__aeabi_dcmpgt>:
 802ce88:	f84d ed08 	str.w	lr, [sp, #-8]!
 802ce8c:	f7ff ffc4 	bl	802ce18 <__aeabi_cdrcmple>
 802ce90:	bf34      	ite	cc
 802ce92:	2001      	movcc	r0, #1
 802ce94:	2000      	movcs	r0, #0
 802ce96:	f85d fb08 	ldr.w	pc, [sp], #8
 802ce9a:	bf00      	nop

0802ce9c <__aeabi_d2uiz>:
 802ce9c:	004a      	lsls	r2, r1, #1
 802ce9e:	d211      	bcs.n	802cec4 <__aeabi_d2uiz+0x28>
 802cea0:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 802cea4:	d211      	bcs.n	802ceca <__aeabi_d2uiz+0x2e>
 802cea6:	d50d      	bpl.n	802cec4 <__aeabi_d2uiz+0x28>
 802cea8:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 802ceac:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 802ceb0:	d40e      	bmi.n	802ced0 <__aeabi_d2uiz+0x34>
 802ceb2:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 802ceb6:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 802ceba:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 802cebe:	fa23 f002 	lsr.w	r0, r3, r2
 802cec2:	4770      	bx	lr
 802cec4:	f04f 0000 	mov.w	r0, #0
 802cec8:	4770      	bx	lr
 802ceca:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 802cece:	d102      	bne.n	802ced6 <__aeabi_d2uiz+0x3a>
 802ced0:	f04f 30ff 	mov.w	r0, #4294967295
 802ced4:	4770      	bx	lr
 802ced6:	f04f 0000 	mov.w	r0, #0
 802ceda:	4770      	bx	lr

0802cedc <__aeabi_d2f>:
 802cedc:	ea4f 0241 	mov.w	r2, r1, lsl #1
 802cee0:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
 802cee4:	bf24      	itt	cs
 802cee6:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
 802ceea:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
 802ceee:	d90d      	bls.n	802cf0c <__aeabi_d2f+0x30>
 802cef0:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 802cef4:	ea4f 02c0 	mov.w	r2, r0, lsl #3
 802cef8:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
 802cefc:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
 802cf00:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
 802cf04:	bf08      	it	eq
 802cf06:	f020 0001 	biceq.w	r0, r0, #1
 802cf0a:	4770      	bx	lr
 802cf0c:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
 802cf10:	d121      	bne.n	802cf56 <__aeabi_d2f+0x7a>
 802cf12:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
 802cf16:	bfbc      	itt	lt
 802cf18:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
 802cf1c:	4770      	bxlt	lr
 802cf1e:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 802cf22:	ea4f 5252 	mov.w	r2, r2, lsr #21
 802cf26:	f1c2 0218 	rsb	r2, r2, #24
 802cf2a:	f1c2 0c20 	rsb	ip, r2, #32
 802cf2e:	fa10 f30c 	lsls.w	r3, r0, ip
 802cf32:	fa20 f002 	lsr.w	r0, r0, r2
 802cf36:	bf18      	it	ne
 802cf38:	f040 0001 	orrne.w	r0, r0, #1
 802cf3c:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 802cf40:	ea4f 23d3 	mov.w	r3, r3, lsr #11
 802cf44:	fa03 fc0c 	lsl.w	ip, r3, ip
 802cf48:	ea40 000c 	orr.w	r0, r0, ip
 802cf4c:	fa23 f302 	lsr.w	r3, r3, r2
 802cf50:	ea4f 0343 	mov.w	r3, r3, lsl #1
 802cf54:	e7cc      	b.n	802cef0 <__aeabi_d2f+0x14>
 802cf56:	ea7f 5362 	mvns.w	r3, r2, asr #21
 802cf5a:	d107      	bne.n	802cf6c <__aeabi_d2f+0x90>
 802cf5c:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
 802cf60:	bf1e      	ittt	ne
 802cf62:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
 802cf66:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
 802cf6a:	4770      	bxne	lr
 802cf6c:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
 802cf70:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 802cf74:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 802cf78:	4770      	bx	lr
 802cf7a:	bf00      	nop

0802cf7c <__aeabi_uldivmod>:
 802cf7c:	b94b      	cbnz	r3, 802cf92 <__aeabi_uldivmod+0x16>
 802cf7e:	b942      	cbnz	r2, 802cf92 <__aeabi_uldivmod+0x16>
 802cf80:	2900      	cmp	r1, #0
 802cf82:	bf08      	it	eq
 802cf84:	2800      	cmpeq	r0, #0
 802cf86:	d002      	beq.n	802cf8e <__aeabi_uldivmod+0x12>
 802cf88:	f04f 31ff 	mov.w	r1, #4294967295
 802cf8c:	4608      	mov	r0, r1
 802cf8e:	f000 b83b 	b.w	802d008 <__aeabi_idiv0>
 802cf92:	b082      	sub	sp, #8
 802cf94:	46ec      	mov	ip, sp
 802cf96:	e92d 5000 	stmdb	sp!, {ip, lr}
 802cf9a:	f000 f81d 	bl	802cfd8 <__gnu_uldivmod_helper>
 802cf9e:	f8dd e004 	ldr.w	lr, [sp, #4]
 802cfa2:	b002      	add	sp, #8
 802cfa4:	bc0c      	pop	{r2, r3}
 802cfa6:	4770      	bx	lr

0802cfa8 <__gnu_ldivmod_helper>:
 802cfa8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 802cfac:	9c06      	ldr	r4, [sp, #24]
 802cfae:	4615      	mov	r5, r2
 802cfb0:	4606      	mov	r6, r0
 802cfb2:	460f      	mov	r7, r1
 802cfb4:	4698      	mov	r8, r3
 802cfb6:	f000 f829 	bl	802d00c <__divdi3>
 802cfba:	fb05 f301 	mul.w	r3, r5, r1
 802cfbe:	fb00 3808 	mla	r8, r0, r8, r3
 802cfc2:	fba5 2300 	umull	r2, r3, r5, r0
 802cfc6:	1ab2      	subs	r2, r6, r2
 802cfc8:	4443      	add	r3, r8
 802cfca:	eb67 0303 	sbc.w	r3, r7, r3
 802cfce:	e9c4 2300 	strd	r2, r3, [r4]
 802cfd2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802cfd6:	bf00      	nop

0802cfd8 <__gnu_uldivmod_helper>:
 802cfd8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 802cfdc:	9c06      	ldr	r4, [sp, #24]
 802cfde:	4690      	mov	r8, r2
 802cfe0:	4606      	mov	r6, r0
 802cfe2:	460f      	mov	r7, r1
 802cfe4:	461d      	mov	r5, r3
 802cfe6:	f000 f95f 	bl	802d2a8 <__udivdi3>
 802cfea:	fb00 f505 	mul.w	r5, r0, r5
 802cfee:	fba0 2308 	umull	r2, r3, r0, r8
 802cff2:	fb08 5501 	mla	r5, r8, r1, r5
 802cff6:	1ab2      	subs	r2, r6, r2
 802cff8:	442b      	add	r3, r5
 802cffa:	eb67 0303 	sbc.w	r3, r7, r3
 802cffe:	e9c4 2300 	strd	r2, r3, [r4]
 802d002:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802d006:	bf00      	nop

0802d008 <__aeabi_idiv0>:
 802d008:	4770      	bx	lr
 802d00a:	bf00      	nop

0802d00c <__divdi3>:
 802d00c:	2900      	cmp	r1, #0
 802d00e:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 802d012:	f2c0 80a6 	blt.w	802d162 <__divdi3+0x156>
 802d016:	2600      	movs	r6, #0
 802d018:	2b00      	cmp	r3, #0
 802d01a:	f2c0 809c 	blt.w	802d156 <__divdi3+0x14a>
 802d01e:	4688      	mov	r8, r1
 802d020:	4694      	mov	ip, r2
 802d022:	469e      	mov	lr, r3
 802d024:	4615      	mov	r5, r2
 802d026:	4604      	mov	r4, r0
 802d028:	460f      	mov	r7, r1
 802d02a:	2b00      	cmp	r3, #0
 802d02c:	d13d      	bne.n	802d0aa <__divdi3+0x9e>
 802d02e:	428a      	cmp	r2, r1
 802d030:	d959      	bls.n	802d0e6 <__divdi3+0xda>
 802d032:	fab2 f382 	clz	r3, r2
 802d036:	b13b      	cbz	r3, 802d048 <__divdi3+0x3c>
 802d038:	f1c3 0220 	rsb	r2, r3, #32
 802d03c:	409f      	lsls	r7, r3
 802d03e:	fa20 f202 	lsr.w	r2, r0, r2
 802d042:	409d      	lsls	r5, r3
 802d044:	4317      	orrs	r7, r2
 802d046:	409c      	lsls	r4, r3
 802d048:	0c29      	lsrs	r1, r5, #16
 802d04a:	0c22      	lsrs	r2, r4, #16
 802d04c:	fbb7 fef1 	udiv	lr, r7, r1
 802d050:	b2a8      	uxth	r0, r5
 802d052:	fb01 771e 	mls	r7, r1, lr, r7
 802d056:	ea42 4707 	orr.w	r7, r2, r7, lsl #16
 802d05a:	fb00 f30e 	mul.w	r3, r0, lr
 802d05e:	42bb      	cmp	r3, r7
 802d060:	d90a      	bls.n	802d078 <__divdi3+0x6c>
 802d062:	197f      	adds	r7, r7, r5
 802d064:	f10e 32ff 	add.w	r2, lr, #4294967295
 802d068:	f080 8105 	bcs.w	802d276 <__divdi3+0x26a>
 802d06c:	42bb      	cmp	r3, r7
 802d06e:	f240 8102 	bls.w	802d276 <__divdi3+0x26a>
 802d072:	f1ae 0e02 	sub.w	lr, lr, #2
 802d076:	442f      	add	r7, r5
 802d078:	1aff      	subs	r7, r7, r3
 802d07a:	b2a4      	uxth	r4, r4
 802d07c:	fbb7 f3f1 	udiv	r3, r7, r1
 802d080:	fb01 7713 	mls	r7, r1, r3, r7
 802d084:	ea44 4707 	orr.w	r7, r4, r7, lsl #16
 802d088:	fb00 f003 	mul.w	r0, r0, r3
 802d08c:	42b8      	cmp	r0, r7
 802d08e:	d908      	bls.n	802d0a2 <__divdi3+0x96>
 802d090:	197f      	adds	r7, r7, r5
 802d092:	f103 32ff 	add.w	r2, r3, #4294967295
 802d096:	f080 80f0 	bcs.w	802d27a <__divdi3+0x26e>
 802d09a:	42b8      	cmp	r0, r7
 802d09c:	f240 80ed 	bls.w	802d27a <__divdi3+0x26e>
 802d0a0:	3b02      	subs	r3, #2
 802d0a2:	ea43 430e 	orr.w	r3, r3, lr, lsl #16
 802d0a6:	2200      	movs	r2, #0
 802d0a8:	e003      	b.n	802d0b2 <__divdi3+0xa6>
 802d0aa:	428b      	cmp	r3, r1
 802d0ac:	d90f      	bls.n	802d0ce <__divdi3+0xc2>
 802d0ae:	2200      	movs	r2, #0
 802d0b0:	4613      	mov	r3, r2
 802d0b2:	1c34      	adds	r4, r6, #0
 802d0b4:	bf18      	it	ne
 802d0b6:	2401      	movne	r4, #1
 802d0b8:	4260      	negs	r0, r4
 802d0ba:	f04f 0500 	mov.w	r5, #0
 802d0be:	eb65 0145 	sbc.w	r1, r5, r5, lsl #1
 802d0c2:	4058      	eors	r0, r3
 802d0c4:	4051      	eors	r1, r2
 802d0c6:	1900      	adds	r0, r0, r4
 802d0c8:	4169      	adcs	r1, r5
 802d0ca:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 802d0ce:	fab3 f283 	clz	r2, r3
 802d0d2:	2a00      	cmp	r2, #0
 802d0d4:	f040 8086 	bne.w	802d1e4 <__divdi3+0x1d8>
 802d0d8:	428b      	cmp	r3, r1
 802d0da:	d302      	bcc.n	802d0e2 <__divdi3+0xd6>
 802d0dc:	4584      	cmp	ip, r0
 802d0de:	f200 80db 	bhi.w	802d298 <__divdi3+0x28c>
 802d0e2:	2301      	movs	r3, #1
 802d0e4:	e7e5      	b.n	802d0b2 <__divdi3+0xa6>
 802d0e6:	b912      	cbnz	r2, 802d0ee <__divdi3+0xe2>
 802d0e8:	2301      	movs	r3, #1
 802d0ea:	fbb3 f5f2 	udiv	r5, r3, r2
 802d0ee:	fab5 f085 	clz	r0, r5
 802d0f2:	2800      	cmp	r0, #0
 802d0f4:	d13b      	bne.n	802d16e <__divdi3+0x162>
 802d0f6:	1b78      	subs	r0, r7, r5
 802d0f8:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 802d0fc:	fa1f fc85 	uxth.w	ip, r5
 802d100:	2201      	movs	r2, #1
 802d102:	fbb0 f8fe 	udiv	r8, r0, lr
 802d106:	0c21      	lsrs	r1, r4, #16
 802d108:	fb0e 0718 	mls	r7, lr, r8, r0
 802d10c:	ea41 4707 	orr.w	r7, r1, r7, lsl #16
 802d110:	fb0c f308 	mul.w	r3, ip, r8
 802d114:	42bb      	cmp	r3, r7
 802d116:	d907      	bls.n	802d128 <__divdi3+0x11c>
 802d118:	197f      	adds	r7, r7, r5
 802d11a:	f108 31ff 	add.w	r1, r8, #4294967295
 802d11e:	d202      	bcs.n	802d126 <__divdi3+0x11a>
 802d120:	42bb      	cmp	r3, r7
 802d122:	f200 80bd 	bhi.w	802d2a0 <__divdi3+0x294>
 802d126:	4688      	mov	r8, r1
 802d128:	1aff      	subs	r7, r7, r3
 802d12a:	b2a4      	uxth	r4, r4
 802d12c:	fbb7 f3fe 	udiv	r3, r7, lr
 802d130:	fb0e 7713 	mls	r7, lr, r3, r7
 802d134:	ea44 4707 	orr.w	r7, r4, r7, lsl #16
 802d138:	fb0c fc03 	mul.w	ip, ip, r3
 802d13c:	45bc      	cmp	ip, r7
 802d13e:	d907      	bls.n	802d150 <__divdi3+0x144>
 802d140:	197f      	adds	r7, r7, r5
 802d142:	f103 31ff 	add.w	r1, r3, #4294967295
 802d146:	d202      	bcs.n	802d14e <__divdi3+0x142>
 802d148:	45bc      	cmp	ip, r7
 802d14a:	f200 80a7 	bhi.w	802d29c <__divdi3+0x290>
 802d14e:	460b      	mov	r3, r1
 802d150:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 802d154:	e7ad      	b.n	802d0b2 <__divdi3+0xa6>
 802d156:	4252      	negs	r2, r2
 802d158:	ea6f 0606 	mvn.w	r6, r6
 802d15c:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 802d160:	e75d      	b.n	802d01e <__divdi3+0x12>
 802d162:	4240      	negs	r0, r0
 802d164:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 802d168:	f04f 36ff 	mov.w	r6, #4294967295
 802d16c:	e754      	b.n	802d018 <__divdi3+0xc>
 802d16e:	f1c0 0220 	rsb	r2, r0, #32
 802d172:	fa24 f102 	lsr.w	r1, r4, r2
 802d176:	fa07 f300 	lsl.w	r3, r7, r0
 802d17a:	4085      	lsls	r5, r0
 802d17c:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 802d180:	40d7      	lsrs	r7, r2
 802d182:	4319      	orrs	r1, r3
 802d184:	fbb7 f2fe 	udiv	r2, r7, lr
 802d188:	0c0b      	lsrs	r3, r1, #16
 802d18a:	fb0e 7712 	mls	r7, lr, r2, r7
 802d18e:	fa1f fc85 	uxth.w	ip, r5
 802d192:	ea43 4307 	orr.w	r3, r3, r7, lsl #16
 802d196:	fb0c f702 	mul.w	r7, ip, r2
 802d19a:	429f      	cmp	r7, r3
 802d19c:	fa04 f400 	lsl.w	r4, r4, r0
 802d1a0:	d907      	bls.n	802d1b2 <__divdi3+0x1a6>
 802d1a2:	195b      	adds	r3, r3, r5
 802d1a4:	f102 30ff 	add.w	r0, r2, #4294967295
 802d1a8:	d274      	bcs.n	802d294 <__divdi3+0x288>
 802d1aa:	429f      	cmp	r7, r3
 802d1ac:	d972      	bls.n	802d294 <__divdi3+0x288>
 802d1ae:	3a02      	subs	r2, #2
 802d1b0:	442b      	add	r3, r5
 802d1b2:	1bdf      	subs	r7, r3, r7
 802d1b4:	b289      	uxth	r1, r1
 802d1b6:	fbb7 f8fe 	udiv	r8, r7, lr
 802d1ba:	fb0e 7318 	mls	r3, lr, r8, r7
 802d1be:	ea41 4303 	orr.w	r3, r1, r3, lsl #16
 802d1c2:	fb0c f708 	mul.w	r7, ip, r8
 802d1c6:	429f      	cmp	r7, r3
 802d1c8:	d908      	bls.n	802d1dc <__divdi3+0x1d0>
 802d1ca:	195b      	adds	r3, r3, r5
 802d1cc:	f108 31ff 	add.w	r1, r8, #4294967295
 802d1d0:	d25c      	bcs.n	802d28c <__divdi3+0x280>
 802d1d2:	429f      	cmp	r7, r3
 802d1d4:	d95a      	bls.n	802d28c <__divdi3+0x280>
 802d1d6:	f1a8 0802 	sub.w	r8, r8, #2
 802d1da:	442b      	add	r3, r5
 802d1dc:	1bd8      	subs	r0, r3, r7
 802d1de:	ea48 4202 	orr.w	r2, r8, r2, lsl #16
 802d1e2:	e78e      	b.n	802d102 <__divdi3+0xf6>
 802d1e4:	f1c2 0320 	rsb	r3, r2, #32
 802d1e8:	fa2c f103 	lsr.w	r1, ip, r3
 802d1ec:	fa0e fe02 	lsl.w	lr, lr, r2
 802d1f0:	fa20 f703 	lsr.w	r7, r0, r3
 802d1f4:	ea41 0e0e 	orr.w	lr, r1, lr
 802d1f8:	fa08 f002 	lsl.w	r0, r8, r2
 802d1fc:	fa28 f103 	lsr.w	r1, r8, r3
 802d200:	ea4f 451e 	mov.w	r5, lr, lsr #16
 802d204:	4338      	orrs	r0, r7
 802d206:	fbb1 f8f5 	udiv	r8, r1, r5
 802d20a:	0c03      	lsrs	r3, r0, #16
 802d20c:	fb05 1118 	mls	r1, r5, r8, r1
 802d210:	fa1f f78e 	uxth.w	r7, lr
 802d214:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
 802d218:	fb07 f308 	mul.w	r3, r7, r8
 802d21c:	428b      	cmp	r3, r1
 802d21e:	fa0c fc02 	lsl.w	ip, ip, r2
 802d222:	d909      	bls.n	802d238 <__divdi3+0x22c>
 802d224:	eb11 010e 	adds.w	r1, r1, lr
 802d228:	f108 39ff 	add.w	r9, r8, #4294967295
 802d22c:	d230      	bcs.n	802d290 <__divdi3+0x284>
 802d22e:	428b      	cmp	r3, r1
 802d230:	d92e      	bls.n	802d290 <__divdi3+0x284>
 802d232:	f1a8 0802 	sub.w	r8, r8, #2
 802d236:	4471      	add	r1, lr
 802d238:	1ac9      	subs	r1, r1, r3
 802d23a:	b280      	uxth	r0, r0
 802d23c:	fbb1 f3f5 	udiv	r3, r1, r5
 802d240:	fb05 1113 	mls	r1, r5, r3, r1
 802d244:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
 802d248:	fb07 f703 	mul.w	r7, r7, r3
 802d24c:	428f      	cmp	r7, r1
 802d24e:	d908      	bls.n	802d262 <__divdi3+0x256>
 802d250:	eb11 010e 	adds.w	r1, r1, lr
 802d254:	f103 30ff 	add.w	r0, r3, #4294967295
 802d258:	d216      	bcs.n	802d288 <__divdi3+0x27c>
 802d25a:	428f      	cmp	r7, r1
 802d25c:	d914      	bls.n	802d288 <__divdi3+0x27c>
 802d25e:	3b02      	subs	r3, #2
 802d260:	4471      	add	r1, lr
 802d262:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 802d266:	1bc9      	subs	r1, r1, r7
 802d268:	fba3 890c 	umull	r8, r9, r3, ip
 802d26c:	4549      	cmp	r1, r9
 802d26e:	d309      	bcc.n	802d284 <__divdi3+0x278>
 802d270:	d005      	beq.n	802d27e <__divdi3+0x272>
 802d272:	2200      	movs	r2, #0
 802d274:	e71d      	b.n	802d0b2 <__divdi3+0xa6>
 802d276:	4696      	mov	lr, r2
 802d278:	e6fe      	b.n	802d078 <__divdi3+0x6c>
 802d27a:	4613      	mov	r3, r2
 802d27c:	e711      	b.n	802d0a2 <__divdi3+0x96>
 802d27e:	4094      	lsls	r4, r2
 802d280:	4544      	cmp	r4, r8
 802d282:	d2f6      	bcs.n	802d272 <__divdi3+0x266>
 802d284:	3b01      	subs	r3, #1
 802d286:	e7f4      	b.n	802d272 <__divdi3+0x266>
 802d288:	4603      	mov	r3, r0
 802d28a:	e7ea      	b.n	802d262 <__divdi3+0x256>
 802d28c:	4688      	mov	r8, r1
 802d28e:	e7a5      	b.n	802d1dc <__divdi3+0x1d0>
 802d290:	46c8      	mov	r8, r9
 802d292:	e7d1      	b.n	802d238 <__divdi3+0x22c>
 802d294:	4602      	mov	r2, r0
 802d296:	e78c      	b.n	802d1b2 <__divdi3+0x1a6>
 802d298:	4613      	mov	r3, r2
 802d29a:	e70a      	b.n	802d0b2 <__divdi3+0xa6>
 802d29c:	3b02      	subs	r3, #2
 802d29e:	e757      	b.n	802d150 <__divdi3+0x144>
 802d2a0:	f1a8 0802 	sub.w	r8, r8, #2
 802d2a4:	442f      	add	r7, r5
 802d2a6:	e73f      	b.n	802d128 <__divdi3+0x11c>

0802d2a8 <__udivdi3>:
 802d2a8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 802d2ac:	2b00      	cmp	r3, #0
 802d2ae:	d144      	bne.n	802d33a <__udivdi3+0x92>
 802d2b0:	428a      	cmp	r2, r1
 802d2b2:	4615      	mov	r5, r2
 802d2b4:	4604      	mov	r4, r0
 802d2b6:	d94f      	bls.n	802d358 <__udivdi3+0xb0>
 802d2b8:	fab2 f782 	clz	r7, r2
 802d2bc:	460e      	mov	r6, r1
 802d2be:	b14f      	cbz	r7, 802d2d4 <__udivdi3+0x2c>
 802d2c0:	f1c7 0320 	rsb	r3, r7, #32
 802d2c4:	40b9      	lsls	r1, r7
 802d2c6:	fa20 f603 	lsr.w	r6, r0, r3
 802d2ca:	fa02 f507 	lsl.w	r5, r2, r7
 802d2ce:	430e      	orrs	r6, r1
 802d2d0:	fa00 f407 	lsl.w	r4, r0, r7
 802d2d4:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 802d2d8:	0c23      	lsrs	r3, r4, #16
 802d2da:	fbb6 f0fe 	udiv	r0, r6, lr
 802d2de:	b2af      	uxth	r7, r5
 802d2e0:	fb0e 6110 	mls	r1, lr, r0, r6
 802d2e4:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 802d2e8:	fb07 f100 	mul.w	r1, r7, r0
 802d2ec:	4299      	cmp	r1, r3
 802d2ee:	d909      	bls.n	802d304 <__udivdi3+0x5c>
 802d2f0:	195b      	adds	r3, r3, r5
 802d2f2:	f100 32ff 	add.w	r2, r0, #4294967295
 802d2f6:	f080 80ec 	bcs.w	802d4d2 <__udivdi3+0x22a>
 802d2fa:	4299      	cmp	r1, r3
 802d2fc:	f240 80e9 	bls.w	802d4d2 <__udivdi3+0x22a>
 802d300:	3802      	subs	r0, #2
 802d302:	442b      	add	r3, r5
 802d304:	1a5a      	subs	r2, r3, r1
 802d306:	b2a4      	uxth	r4, r4
 802d308:	fbb2 f3fe 	udiv	r3, r2, lr
 802d30c:	fb0e 2213 	mls	r2, lr, r3, r2
 802d310:	ea44 4202 	orr.w	r2, r4, r2, lsl #16
 802d314:	fb07 f703 	mul.w	r7, r7, r3
 802d318:	4297      	cmp	r7, r2
 802d31a:	d908      	bls.n	802d32e <__udivdi3+0x86>
 802d31c:	1952      	adds	r2, r2, r5
 802d31e:	f103 31ff 	add.w	r1, r3, #4294967295
 802d322:	f080 80d8 	bcs.w	802d4d6 <__udivdi3+0x22e>
 802d326:	4297      	cmp	r7, r2
 802d328:	f240 80d5 	bls.w	802d4d6 <__udivdi3+0x22e>
 802d32c:	3b02      	subs	r3, #2
 802d32e:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 802d332:	2600      	movs	r6, #0
 802d334:	4631      	mov	r1, r6
 802d336:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802d33a:	428b      	cmp	r3, r1
 802d33c:	d847      	bhi.n	802d3ce <__udivdi3+0x126>
 802d33e:	fab3 f683 	clz	r6, r3
 802d342:	2e00      	cmp	r6, #0
 802d344:	d148      	bne.n	802d3d8 <__udivdi3+0x130>
 802d346:	428b      	cmp	r3, r1
 802d348:	d302      	bcc.n	802d350 <__udivdi3+0xa8>
 802d34a:	4282      	cmp	r2, r0
 802d34c:	f200 80cd 	bhi.w	802d4ea <__udivdi3+0x242>
 802d350:	2001      	movs	r0, #1
 802d352:	4631      	mov	r1, r6
 802d354:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802d358:	b912      	cbnz	r2, 802d360 <__udivdi3+0xb8>
 802d35a:	2501      	movs	r5, #1
 802d35c:	fbb5 f5f2 	udiv	r5, r5, r2
 802d360:	fab5 f885 	clz	r8, r5
 802d364:	f1b8 0f00 	cmp.w	r8, #0
 802d368:	d177      	bne.n	802d45a <__udivdi3+0x1b2>
 802d36a:	1b4a      	subs	r2, r1, r5
 802d36c:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 802d370:	b2af      	uxth	r7, r5
 802d372:	2601      	movs	r6, #1
 802d374:	fbb2 f0fe 	udiv	r0, r2, lr
 802d378:	0c23      	lsrs	r3, r4, #16
 802d37a:	fb0e 2110 	mls	r1, lr, r0, r2
 802d37e:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
 802d382:	fb07 f300 	mul.w	r3, r7, r0
 802d386:	428b      	cmp	r3, r1
 802d388:	d907      	bls.n	802d39a <__udivdi3+0xf2>
 802d38a:	1949      	adds	r1, r1, r5
 802d38c:	f100 32ff 	add.w	r2, r0, #4294967295
 802d390:	d202      	bcs.n	802d398 <__udivdi3+0xf0>
 802d392:	428b      	cmp	r3, r1
 802d394:	f200 80ba 	bhi.w	802d50c <__udivdi3+0x264>
 802d398:	4610      	mov	r0, r2
 802d39a:	1ac9      	subs	r1, r1, r3
 802d39c:	b2a4      	uxth	r4, r4
 802d39e:	fbb1 f3fe 	udiv	r3, r1, lr
 802d3a2:	fb0e 1113 	mls	r1, lr, r3, r1
 802d3a6:	ea44 4401 	orr.w	r4, r4, r1, lsl #16
 802d3aa:	fb07 f703 	mul.w	r7, r7, r3
 802d3ae:	42a7      	cmp	r7, r4
 802d3b0:	d908      	bls.n	802d3c4 <__udivdi3+0x11c>
 802d3b2:	1964      	adds	r4, r4, r5
 802d3b4:	f103 32ff 	add.w	r2, r3, #4294967295
 802d3b8:	f080 808f 	bcs.w	802d4da <__udivdi3+0x232>
 802d3bc:	42a7      	cmp	r7, r4
 802d3be:	f240 808c 	bls.w	802d4da <__udivdi3+0x232>
 802d3c2:	3b02      	subs	r3, #2
 802d3c4:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 802d3c8:	4631      	mov	r1, r6
 802d3ca:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802d3ce:	2600      	movs	r6, #0
 802d3d0:	4630      	mov	r0, r6
 802d3d2:	4631      	mov	r1, r6
 802d3d4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802d3d8:	f1c6 0420 	rsb	r4, r6, #32
 802d3dc:	fa22 f504 	lsr.w	r5, r2, r4
 802d3e0:	40b3      	lsls	r3, r6
 802d3e2:	432b      	orrs	r3, r5
 802d3e4:	fa20 fc04 	lsr.w	ip, r0, r4
 802d3e8:	fa01 f706 	lsl.w	r7, r1, r6
 802d3ec:	fa21 f504 	lsr.w	r5, r1, r4
 802d3f0:	ea4f 4e13 	mov.w	lr, r3, lsr #16
 802d3f4:	ea4c 0707 	orr.w	r7, ip, r7
 802d3f8:	fbb5 f8fe 	udiv	r8, r5, lr
 802d3fc:	0c39      	lsrs	r1, r7, #16
 802d3fe:	fb0e 5518 	mls	r5, lr, r8, r5
 802d402:	fa1f fc83 	uxth.w	ip, r3
 802d406:	ea41 4505 	orr.w	r5, r1, r5, lsl #16
 802d40a:	fb0c f108 	mul.w	r1, ip, r8
 802d40e:	42a9      	cmp	r1, r5
 802d410:	fa02 f206 	lsl.w	r2, r2, r6
 802d414:	d904      	bls.n	802d420 <__udivdi3+0x178>
 802d416:	18ed      	adds	r5, r5, r3
 802d418:	f108 34ff 	add.w	r4, r8, #4294967295
 802d41c:	d367      	bcc.n	802d4ee <__udivdi3+0x246>
 802d41e:	46a0      	mov	r8, r4
 802d420:	1a6d      	subs	r5, r5, r1
 802d422:	b2bf      	uxth	r7, r7
 802d424:	fbb5 f4fe 	udiv	r4, r5, lr
 802d428:	fb0e 5514 	mls	r5, lr, r4, r5
 802d42c:	ea47 4105 	orr.w	r1, r7, r5, lsl #16
 802d430:	fb0c fc04 	mul.w	ip, ip, r4
 802d434:	458c      	cmp	ip, r1
 802d436:	d904      	bls.n	802d442 <__udivdi3+0x19a>
 802d438:	18c9      	adds	r1, r1, r3
 802d43a:	f104 35ff 	add.w	r5, r4, #4294967295
 802d43e:	d35c      	bcc.n	802d4fa <__udivdi3+0x252>
 802d440:	462c      	mov	r4, r5
 802d442:	ea44 4408 	orr.w	r4, r4, r8, lsl #16
 802d446:	ebcc 0101 	rsb	r1, ip, r1
 802d44a:	fba4 2302 	umull	r2, r3, r4, r2
 802d44e:	4299      	cmp	r1, r3
 802d450:	d348      	bcc.n	802d4e4 <__udivdi3+0x23c>
 802d452:	d044      	beq.n	802d4de <__udivdi3+0x236>
 802d454:	4620      	mov	r0, r4
 802d456:	2600      	movs	r6, #0
 802d458:	e76c      	b.n	802d334 <__udivdi3+0x8c>
 802d45a:	f1c8 0420 	rsb	r4, r8, #32
 802d45e:	fa01 f308 	lsl.w	r3, r1, r8
 802d462:	fa05 f508 	lsl.w	r5, r5, r8
 802d466:	fa20 f704 	lsr.w	r7, r0, r4
 802d46a:	40e1      	lsrs	r1, r4
 802d46c:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 802d470:	431f      	orrs	r7, r3
 802d472:	fbb1 f6fe 	udiv	r6, r1, lr
 802d476:	0c3a      	lsrs	r2, r7, #16
 802d478:	fb0e 1116 	mls	r1, lr, r6, r1
 802d47c:	fa1f fc85 	uxth.w	ip, r5
 802d480:	ea42 4301 	orr.w	r3, r2, r1, lsl #16
 802d484:	fb0c f206 	mul.w	r2, ip, r6
 802d488:	429a      	cmp	r2, r3
 802d48a:	fa00 f408 	lsl.w	r4, r0, r8
 802d48e:	d907      	bls.n	802d4a0 <__udivdi3+0x1f8>
 802d490:	195b      	adds	r3, r3, r5
 802d492:	f106 31ff 	add.w	r1, r6, #4294967295
 802d496:	d237      	bcs.n	802d508 <__udivdi3+0x260>
 802d498:	429a      	cmp	r2, r3
 802d49a:	d935      	bls.n	802d508 <__udivdi3+0x260>
 802d49c:	3e02      	subs	r6, #2
 802d49e:	442b      	add	r3, r5
 802d4a0:	1a9b      	subs	r3, r3, r2
 802d4a2:	b2bf      	uxth	r7, r7
 802d4a4:	fbb3 f0fe 	udiv	r0, r3, lr
 802d4a8:	fb0e 3310 	mls	r3, lr, r0, r3
 802d4ac:	ea47 4303 	orr.w	r3, r7, r3, lsl #16
 802d4b0:	fb0c f100 	mul.w	r1, ip, r0
 802d4b4:	4299      	cmp	r1, r3
 802d4b6:	d907      	bls.n	802d4c8 <__udivdi3+0x220>
 802d4b8:	195b      	adds	r3, r3, r5
 802d4ba:	f100 32ff 	add.w	r2, r0, #4294967295
 802d4be:	d221      	bcs.n	802d504 <__udivdi3+0x25c>
 802d4c0:	4299      	cmp	r1, r3
 802d4c2:	d91f      	bls.n	802d504 <__udivdi3+0x25c>
 802d4c4:	3802      	subs	r0, #2
 802d4c6:	442b      	add	r3, r5
 802d4c8:	1a5a      	subs	r2, r3, r1
 802d4ca:	ea40 4606 	orr.w	r6, r0, r6, lsl #16
 802d4ce:	4667      	mov	r7, ip
 802d4d0:	e750      	b.n	802d374 <__udivdi3+0xcc>
 802d4d2:	4610      	mov	r0, r2
 802d4d4:	e716      	b.n	802d304 <__udivdi3+0x5c>
 802d4d6:	460b      	mov	r3, r1
 802d4d8:	e729      	b.n	802d32e <__udivdi3+0x86>
 802d4da:	4613      	mov	r3, r2
 802d4dc:	e772      	b.n	802d3c4 <__udivdi3+0x11c>
 802d4de:	40b0      	lsls	r0, r6
 802d4e0:	4290      	cmp	r0, r2
 802d4e2:	d2b7      	bcs.n	802d454 <__udivdi3+0x1ac>
 802d4e4:	1e60      	subs	r0, r4, #1
 802d4e6:	2600      	movs	r6, #0
 802d4e8:	e724      	b.n	802d334 <__udivdi3+0x8c>
 802d4ea:	4630      	mov	r0, r6
 802d4ec:	e722      	b.n	802d334 <__udivdi3+0x8c>
 802d4ee:	42a9      	cmp	r1, r5
 802d4f0:	d995      	bls.n	802d41e <__udivdi3+0x176>
 802d4f2:	f1a8 0802 	sub.w	r8, r8, #2
 802d4f6:	441d      	add	r5, r3
 802d4f8:	e792      	b.n	802d420 <__udivdi3+0x178>
 802d4fa:	458c      	cmp	ip, r1
 802d4fc:	d9a0      	bls.n	802d440 <__udivdi3+0x198>
 802d4fe:	3c02      	subs	r4, #2
 802d500:	4419      	add	r1, r3
 802d502:	e79e      	b.n	802d442 <__udivdi3+0x19a>
 802d504:	4610      	mov	r0, r2
 802d506:	e7df      	b.n	802d4c8 <__udivdi3+0x220>
 802d508:	460e      	mov	r6, r1
 802d50a:	e7c9      	b.n	802d4a0 <__udivdi3+0x1f8>
 802d50c:	3802      	subs	r0, #2
 802d50e:	4429      	add	r1, r5
 802d510:	e743      	b.n	802d39a <__udivdi3+0xf2>
 802d512:	bf00      	nop

0802d514 <__errno>:
 802d514:	4b01      	ldr	r3, [pc, #4]	; (802d51c <__errno+0x8>)
 802d516:	6818      	ldr	r0, [r3, #0]
 802d518:	4770      	bx	lr
 802d51a:	bf00      	nop
 802d51c:	1ffe96a4 	.word	0x1ffe96a4

0802d520 <memcmp>:
 802d520:	b510      	push	{r4, lr}
 802d522:	440a      	add	r2, r1
 802d524:	1e44      	subs	r4, r0, #1
 802d526:	4291      	cmp	r1, r2
 802d528:	d008      	beq.n	802d53c <memcmp+0x1c>
 802d52a:	f814 3f01 	ldrb.w	r3, [r4, #1]!
 802d52e:	7808      	ldrb	r0, [r1, #0]
 802d530:	4283      	cmp	r3, r0
 802d532:	d001      	beq.n	802d538 <memcmp+0x18>
 802d534:	1a18      	subs	r0, r3, r0
 802d536:	bd10      	pop	{r4, pc}
 802d538:	3101      	adds	r1, #1
 802d53a:	e7f4      	b.n	802d526 <memcmp+0x6>
 802d53c:	2000      	movs	r0, #0
 802d53e:	bd10      	pop	{r4, pc}

0802d540 <memcpy>:
 802d540:	b510      	push	{r4, lr}
 802d542:	1e43      	subs	r3, r0, #1
 802d544:	440a      	add	r2, r1
 802d546:	4291      	cmp	r1, r2
 802d548:	d004      	beq.n	802d554 <memcpy+0x14>
 802d54a:	f811 4b01 	ldrb.w	r4, [r1], #1
 802d54e:	f803 4f01 	strb.w	r4, [r3, #1]!
 802d552:	e7f8      	b.n	802d546 <memcpy+0x6>
 802d554:	bd10      	pop	{r4, pc}

0802d556 <memset>:
 802d556:	4402      	add	r2, r0
 802d558:	4603      	mov	r3, r0
 802d55a:	4293      	cmp	r3, r2
 802d55c:	d002      	beq.n	802d564 <memset+0xe>
 802d55e:	f803 1b01 	strb.w	r1, [r3], #1
 802d562:	e7fa      	b.n	802d55a <memset+0x4>
 802d564:	4770      	bx	lr

0802d566 <strlen>:
 802d566:	4603      	mov	r3, r0
 802d568:	f813 2b01 	ldrb.w	r2, [r3], #1
 802d56c:	2a00      	cmp	r2, #0
 802d56e:	d1fb      	bne.n	802d568 <strlen+0x2>
 802d570:	1a18      	subs	r0, r3, r0
 802d572:	3801      	subs	r0, #1
 802d574:	4770      	bx	lr
	...

0802d578 <ds_default_device_settings>:
 802d578:	0040 0000 0e1e 0003 0001 0000 7ca8 4bb7     @............|.K
 802d588:	0000 0000 07d0 0000 000c 0000 0001 0000     ................
 802d598:	49f0 0002 0080 0000 0003 0000 0028 0000     .I..........(...
 802d5a8:	0005 0000 0000 0000 0001 0000 03e8 0000     ................
 802d5b8:	4252 5042 5644 3033 0000 0000 6553 736e     RBBPDV30....Sens
 802d5c8:	3265 6f47 204c 7550 736c 2065 4742 3254     e2GoL Pulse BGT2
 802d5d8:	4c34 5254 3131 4420 6d65 206f 6152 6164     4LTR11 Demo Rada
 802d5e8:	2072 6f42 7261 0064                         r Board.

0802d5f0 <cg_device_info_struct>:
 802d5f0:	d5c4 0802 97a8 016e a4e8 0171 0201 0101     ......n...q.....
 802d600:	0002 0100 4e55 4e4b 574f 204e 5245 4f52     ....UNKNOWN ERRO
 802d610:	0052 0000 5245 4f52 3a52 2d20 4220 616f     R...ERROR: - Boa
 802d620:	6472 7520 736e 7075 6f70 7472 6465 0000     rd unsupported..
 802d630:	5245 4f52 3a52 2d20 4920 766e 6c61 6469     ERROR: - Invalid
 802d640:	4220 616f 6472 4920 2c44 6f20 2072 6f42      Board ID, or Bo
 802d650:	7261 2064 6f6e 2074 6f63 6e6e 6365 6574     ard not connecte
 802d660:	0064 0000 5245 4f52 3a52 2d20 4220 616f     d...ERROR: - Boa
 802d670:	6472 4920 2044 6f6e 2074 7270 676f 6172     rd ID not progra
 802d680:	6d6d 6465 0000 0000 416d 0000 7543 7272     mmed....mA..Curr
 802d690:	6e65 2074 6f43 736e 6d75 7470 6f69 006e     ent Consumption.

0802d6a0 <c_para_value_def_list>:
 802d6a0:	cccd 3dcc 0000 4040 cccd 3dcc 0000 4040     ...=..@@...=..@@
 802d6b0:	cccd 3d4c 0000 4000 0020 0040 0080 0100     ..L=...@ .@.....
 802d6c0:	0000 447a 4000 459c 0000 3f80 0000 44fa     ..zD.@.E...?...D
 802d6d0:	0000 3f80 0000 44fa 0000 0000 03e8 0000     ...?...D........
 802d6e0:	0004 0000 000a 0000 4252 5042 5644 3031     ........RBBPDV10
 802d6f0:	0000 0000 6553 736e 3265 6f47 204c 7550     ....Sense2GoL Pu
 802d700:	736c 2065 4742 3254 4c34 5254 3131 7320     lse BGT24LTR11 s
 802d710:	6968 6c65 2064 3156 302e 0000 7550 736c     hield V1.0..Puls
 802d720:	6465 4420 706f 6c70 7265 0000 6553 736e     ed Doppler..Sens
 802d730:	3265 6f47 204c 7550 736c 2065 4742 3254     e2GoL Pulse BGT2
 802d740:	4c34 5254 3131 7320 6968 6c65 2064 3356     4LTR11 shield V3
 802d750:	302e 0000                                   .0..

0802d754 <CSWTCH.37>:
	...
 802d75c:	0002 0000 0002 0000 000c 0000 000c 0000     ................
 802d76c:	000c 0000 000c 0000 0008 0000 000a 0000     ................

0802d77c <CSWTCH.38>:
 802d77c:	0003 0000 0003 0000 000c 0000 000c 0000     ................
 802d78c:	3000 0000 3000 0000 3000 0000 3000 0000     .0...0...0...0..
 802d79c:	0300 0000 0c00 0000                         ........

0802d7a4 <CSWTCH.43>:
 802d7a4:	0003 0000 0003 0000 000c 0000 000c 0000     ................
 802d7b4:	0030 0000 0030 0000 3000 0000 3000 0000     0...0....0...0..
 802d7c4:	0300 0000 0c00 0000                         ........

0802d7cc <CSWTCH.44>:
	...
 802d7d4:	0002 0000 0002 0000 0004 0000 0004 0000     ................
 802d7e4:	000c 0000 000c 0000 0008 0000 000a 0000     ................

0802d7f4 <Driver_USBD0>:
 802d7f4:	1ffd 0802 265d 0802 2379 0802 2019 0802     ....]&..y#... ..
 802d804:	2031 0802 2049 0802 2161 0802 239d 0802     1 ..I ..a!...#..
 802d814:	2249 0802 2179 0802 2829 0802 261d 0802     I"..y!..)(...&..
 802d824:	2909 0802 2205 0802 2349 0802 235d 0802     .)..."..I#..]#..

0802d834 <g_xmc_vadc_group_array>:
 802d834:	4400 4000 4800 4000 4c00 4000 5000 4000     .D.@.H.@.L.@.P.@
 802d844:	6f4e 4520 7272 726f 0000 0000 4d58 3443     No Error....XMC4
 802d854:	3037 2030 6152 6164 2072 6162 6573 6f62     700 Radar basebo
 802d864:	7261 2064 3256 302e 0000 0000               ard V2.0....

0802d870 <product_string>:
 802d870:	0310 0049 0046 0058 0020 0043 0044 0043     ..I.F.X. .C.D.C.
	...

0802d8d8 <device_descriptor>:
 802d8d8:	0112 0110 0002 4000 058b 0058 0001 0201     .......@..X.....
 802d8e8:	0100 0000                                   ....

0802d8ec <language_string>:
 802d8ec:	0304 0409 0000 0000 0000 0000 0000 0000     ................
	...

0802d954 <manufacturer_string>:
 802d954:	0312 0049 006e 0066 0069 006e 0065 006f     ..I.n.f.i.n.e.o.
 802d964:	006e 0000 0000 0000 0000 0000 0000 0000     n...............
	...

0802d9bc <CSWTCH.1>:
 802d9bc:	d8ec 0802 d954 0802 d870 0802               ....T...p...

0802d9c8 <CSWTCH.2>:
 802d9c8:	0004 0012 0010 0000                         ........

0802d9d0 <configuration_descriptor>:
 802d9d0:	0209 003e 0102 8000 0932 0004 0100 0202     ..>.....2.......
 802d9e0:	0001 2405 1000 0401 0224 0506 0624 0100     ...$....$...$...
 802d9f0:	0507 0381 0008 09ff 0104 0200 000a 0000     ................
 802da00:	0507 0203 0040 0701 8205 4002 0100 0000     ....@......@....

0802da10 <PWM_CCU8_SAMPLE_HOLD_ch1_out0_config>:
 802da10:	0098 0000 0000 0001 0004 0000               ............

0802da1c <PWM_CCU8_ADC_SAMPLE_config_handle>:
 802da1c:	0000 0e0f 0ca8 0708 0100 0000 0000 0000     ................
 802da2c:	0000 0202 0000 0000 0000 0000 dc38 0802     ............8...
 802da3c:	db50 0802 dd0c 0802 0001 0000 0000 0000     P...............
	...
 802da54:	0001 0000 0000 2000 db9c 0802 0001 0000     ....... ........
 802da64:	dc3c 0802 0000 0000 0000 0000 0000 0000     <...............
	...
 802daa8:	9328 1ffe                                   (...

0802daac <PWM_CCU8_BGT_TX_ON_event2_config>:
 802daac:	0000 0001                                   ....

0802dab0 <PWM_CCU8_BGT_TX_ON_dt_config>:
	...

0802dabc <PWM_CCU8_BGT_TX_ON_config_handle>:
 802dabc:	0000 0e0f 0451 0700 0000 0000 0000 0000     ....Q...........
	...
 802dad8:	dcf8 0802 db84 0802 daac 0802 0001 0002     ................
	...
 802daf4:	0001 0000 0000 0800 dab0 0802 0001 0000     ................
 802db04:	db58 0802 0001 0000 8500 4802 000a 0000     X..........H....
 802db14:	dcec 0802 0000 0000 0000 0000 0000 0000     ................
	...
 802db48:	9328 1ffe                                   (...

0802db4c <PWM_CCU8_BGT_VCC_event0_config>:
 802db4c:	0000 0001                                   ....

0802db50 <PWM_CCU8_ADC_SAMPLE_event1_config>:
 802db50:	0000 0001                                   ....

0802db54 <PWM_CCU8_SAMPLE_HOLD_event0_config>:
 802db54:	010c 0001                                   ....

0802db58 <PWM_CCU8_BGT_TX_ON_timer_handle>:
 802db58:	0002 0000 0000 0000 0015 0000 0001 0000     ................

0802db68 <PWM_CCU8_BGT_VCC_ch1_out0_config>:
 802db68:	0098 0000 0000 0001 0004 0000               ............

0802db74 <PWM_CCU8_SAMPLE_HOLD_timer_handle>:
 802db74:	0002 0000 0000 0000 0015 0000 0001 0000     ................

0802db84 <PWM_CCU8_BGT_TX_ON_event1_config>:
 802db84:	020c 0001                                   ....

0802db88 <PWM_CCU8_BGT_VCC_event2_config>:
 802db88:	0000 0001                                   ....

0802db8c <PWM_CCU8_BGT_VCC_dt_config>:
	...

0802db98 <PWM_CCU8_SAMPLE_HOLD_event2_config>:
 802db98:	0000 0001                                   ....

0802db9c <PWM_CCU8_ADC_SAMPLE_dt_config>:
	...

0802dba8 <PWM_CCU8_BGT_VCC_config_handle>:
 802dba8:	0000 000a 0009 0008 0100 0000 0000 0000     ................
 802dbb8:	0000 0303 0000 0000 0000 0000 db4c 0802     ............L...
 802dbc8:	dd08 0802 db88 0802 0000 0000 0000 0000     ................
	...
 802dbe0:	0001 0000 0000 0400 db8c 0802 0001 0000     ................
 802dbf0:	dcdc 0802 0001 0000 8500 4802 000b 0000     ...........H....
 802dc00:	db68 0802 0000 0000 0000 0000 0000 0000     h...............
	...
 802dc34:	9328 1ffe                                   (...

0802dc38 <PWM_CCU8_ADC_SAMPLE_event0_config>:
 802dc38:	010c 0001                                   ....

0802dc3c <PWM_CCU8_ADC_SAMPLE_timer_handle>:
 802dc3c:	0002 0000 0000 0000 0014 0000 0001 0000     ................

0802dc4c <PWM_CCU8_SAMPLE_HOLD_config_handle>:
 802dc4c:	0000 0e0f 0451 0700 0000 0000 0000 0000     ....Q...........
	...
 802dc68:	db54 0802 dd10 0802 db98 0802 0001 0002     T...............
	...
 802dc84:	0001 0000 0000 1000 dcfc 0802 0001 0000     ................
 802dc94:	db74 0802 0001 0000 8500 4802 0009 0000     t..........H....
 802dca4:	da10 0802 0000 0000 0000 0000 0000 0000     ................
	...
 802dcd8:	9328 1ffe                                   (...

0802dcdc <PWM_CCU8_BGT_VCC_timer_handle>:
 802dcdc:	0000 0000 0001 0000 0014 0000 0007 0000     ................

0802dcec <PWM_CCU8_BGT_TX_ON_ch1_out0_config>:
 802dcec:	0098 0000 0000 0001 0004 0000               ............

0802dcf8 <PWM_CCU8_BGT_TX_ON_event0_config>:
 802dcf8:	010c 0001                                   ....

0802dcfc <PWM_CCU8_SAMPLE_HOLD_dt_config>:
	...

0802dd08 <PWM_CCU8_BGT_VCC_event1_config>:
 802dd08:	0000 0001                                   ....

0802dd0c <PWM_CCU8_ADC_SAMPLE_event2_config>:
 802dd0c:	0000 0001                                   ....

0802dd10 <PWM_CCU8_SAMPLE_HOLD_event1_config>:
 802dd10:	020c 0001                                   ....

0802dd14 <INTERRUPT_ERROR_TOGGLE>:
 802dd14:	3f3b 0100                                   ;?..

0802dd18 <INTERRUPT_BB_PRE_TRIGGER>:
 802dd18:	3f3a 0100                                   :?..

0802dd1c <INTERRUPT_PTAT_TIMER>:
 802dd1c:	3f39 0100                                   9?..

0802dd20 <INTERRUPT_FRAME>:
 802dd20:	3d31 0100                                   1=..

0802dd24 <INTERRUPT_PTAT_S_H_DELAY>:
 802dd24:	3f38 0100                                   8?..

0802dd28 <INTERRUPT_BGT_VCC_ON>:
 802dd28:	3f3f 0100                                   ??..

0802dd2c <group_init_handle0>:
	...

0802dd40 <group_init_handle1>:
	...

0802dd54 <group_init_handle3>:
	...

0802dd68 <global_config>:
 802dd68:	0000 0000 0004 0000 0000 0000 0000 0000     ................
	...

0802dd80 <group_init_handle2>:
	...

0802dd94 <DIGITAL_IO_BB1_EN>:
 802dd94:	8300 4802 0080 0000 0000 0001 0004 0000     ...H............
 802dda4:	0009 0000                                   ....

0802dda8 <DIGITAL_IO_BB2_EN>:
 802dda8:	8300 4802 0080 0000 0000 0001 0004 0000     ...H............
 802ddb8:	0004 0000                                   ....

0802ddbc <DIGITAL_IO_BGT_VCC_PTAT>:
 802ddbc:	8000 4802 0080 0000 0001 0000 0000 0000     ...H............
 802ddcc:	000e 0000                                   ....

0802ddd0 <DIGITAL_IO_ARD_D4>:
 802ddd0:	8400 4802 0080 0000 0000 0001 0000 0000     ...H............
 802dde0:	0006 0000                                   ....

0802dde4 <DIGITAL_IO_ARD_D6>:
 802dde4:	8700 4802 0080 0000 0000 0001 0000 0000     ...H............
 802ddf4:	0006 0000                                   ....

0802ddf8 <DIGITAL_IO_ARD_D7>:
 802ddf8:	8300 4802 0080 0000 0000 0001 0000 0000     ...H............
 802de08:	000a 0000                                   ....

0802de0c <DIGITAL_IO_GREEN_LED>:
 802de0c:	8100 4802 0080 0000 0001 0000 0000 0000     ...H............
 802de1c:	000e 0000                                   ....

0802de20 <DIGITAL_IO_RED_LED>:
 802de20:	8100 4802 0080 0000 0001 0000 0000 0000     ...H............
 802de30:	000f 0000                                   ....

0802de34 <DIGITAL_IO_BLUE_LED>:
 802de34:	8100 4802 0080 0000 0001 0000 0000 0000     ...H............
 802de44:	000d 0000                                   ....

0802de48 <DIGITAL_IO_V_PTAT_SH_EN>:
 802de48:	8700 4802 0080 0000 0000 0001 0004 0000     ...H............
 802de58:	000a 0000                                   ....

0802de5c <armBitRevIndexTable64>:
 802de5c:	0008 0040 0010 0080 0018 00c0 0020 0100     ..@......... ...
 802de6c:	0028 0140 0030 0180 0038 01c0 0050 0088     (.@.0...8...P...
 802de7c:	0058 00c8 0060 0108 0068 0148 0070 0188     X...`...h.H.p...
 802de8c:	0078 01c8 0098 00d0 00a0 0110 00a8 0150     x.............P.
 802de9c:	00b0 0190 00b8 01d0 00e0 0118 00e8 0158     ..............X.
 802deac:	00f0 0198 00f8 01d8 0128 0160 0130 01a0     ........(.`.0...
 802debc:	0138 01e0 0170 01a8 0178 01e8 01b8 01f0     8...p...x.......

0802decc <twiddleCoef_256>:
 802decc:	0000 3f80 0000 0000 ec43 3f7f 0ab0 3cc9     ...?....C..?...<
 802dedc:	b10f 3f7f fb2f 3d48 4e6d 3f7f a905 3d96     ...?/.H=mN.?...=
 802deec:	c46d 3f7e bd36 3dc8 1324 3f7e b273 3dfa     m.~?6..=$.~?s..=
 802defc:	3aac 3f7d 4083 3e16 3b28 3f7c 10a2 3e2f     .:}?.@.>(;|?../>
 802df0c:	14be 3f7b c5c2 3e47 c79d 3f79 5c13 3e60     ..{?..G>..y?.\`>
 802df1c:	53f8 3f78 cfcc 3e78 ba07 3f76 8e93 3e88     .Sx?..x>..v?...>
 802df2c:	fa0b 3f74 a031 3e94 1447 3f73 9ae5 3ea0     ..t?1..>G.s?...>
 802df3c:	0908 3f71 7cd4 3eac d89e 3f6e 442a 3eb8     ..q?.|.>..n?*D.>
 802df4c:	835e 3f6c ef15 3ec3 09a7 3f6a 7bca 3ecf     ^.l?...>..j?.{.>
 802df5c:	6bd8 3f67 e880 3eda aa59 3f64 3375 3ee6     .kg?...>Y.d?u3.>
 802df6c:	c598 3f61 5aea 3ef1 be05 3f5e 5d27 3efc     ..a?.Z.>..^?'].>
 802df7c:	941a 3f5b 9c3d 3f03 4853 3f58 f59b 3f08     ..[?=..?SHX?...?
 802df8c:	db31 3f54 39da 3f0e 4d3d 3f51 682a 3f13     1.T?.9.?=MQ?*h.?
 802df9c:	9f02 3f4d 7fc0 3f18 d112 3f49 7fd1 3f1d     ..M?...?..I?...?
 802dfac:	e403 3f45 6799 3f22 d870 3f41 3656 3f27     ..E?.g"?p.A?V6'?
 802dfbc:	aef9 3f3d eb4a 3f2b 6842 3f39 85bb 3f30     ..=?J.+?Bh9?..0?
 802dfcc:	04f3 3f35 04f3 3f35 85bb 3f30 6842 3f39     ..5?..5?..0?Bh9?
 802dfdc:	eb4a 3f2b aef9 3f3d 3656 3f27 d870 3f41     J.+?..=?V6'?p.A?
 802dfec:	6799 3f22 e403 3f45 7fd1 3f1d d112 3f49     .g"?..E?...?..I?
 802dffc:	7fc0 3f18 9f02 3f4d 682a 3f13 4d3d 3f51     ...?..M?*h.?=MQ?
 802e00c:	39da 3f0e db31 3f54 f59b 3f08 4853 3f58     .9.?1.T?...?SHX?
 802e01c:	9c3d 3f03 941a 3f5b 5d27 3efc be05 3f5e     =..?..[?'].>..^?
 802e02c:	5aea 3ef1 c598 3f61 3375 3ee6 aa59 3f64     .Z.>..a?u3.>Y.d?
 802e03c:	e880 3eda 6bd8 3f67 7bca 3ecf 09a7 3f6a     ...>.kg?.{.>..j?
 802e04c:	ef15 3ec3 835e 3f6c 442a 3eb8 d89e 3f6e     ...>^.l?*D.>..n?
 802e05c:	7cd4 3eac 0908 3f71 9ae5 3ea0 1447 3f73     .|.>..q?...>G.s?
 802e06c:	a031 3e94 fa0b 3f74 8e93 3e88 ba07 3f76     1..>..t?...>..v?
 802e07c:	cfcc 3e78 53f8 3f78 5c13 3e60 c79d 3f79     ..x>.Sx?.\`>..y?
 802e08c:	c5c2 3e47 14be 3f7b 10a2 3e2f 3b28 3f7c     ..G>..{?../>(;|?
 802e09c:	4083 3e16 3aac 3f7d b273 3dfa 1324 3f7e     .@.>.:}?s..=$.~?
 802e0ac:	bd36 3dc8 c46d 3f7e a905 3d96 4e6d 3f7f     6..=m.~?...=mN.?
 802e0bc:	fb2f 3d48 b10f 3f7f 0ab0 3cc9 ec43 3f7f     /.H=...?...<C..?
 802e0cc:	0000 0000 0000 3f80 0ab0 bcc9 ec43 3f7f     .......?....C..?
 802e0dc:	fb2f bd48 b10f 3f7f a905 bd96 4e6d 3f7f     /.H....?....mN.?
 802e0ec:	bd36 bdc8 c46d 3f7e b273 bdfa 1324 3f7e     6...m.~?s...$.~?
 802e0fc:	4083 be16 3aac 3f7d 10a2 be2f 3b28 3f7c     .@...:}?../.(;|?
 802e10c:	c5c2 be47 14be 3f7b 5c13 be60 c79d 3f79     ..G...{?.\`...y?
 802e11c:	cfcc be78 53f8 3f78 8e93 be88 ba07 3f76     ..x..Sx?......v?
 802e12c:	a031 be94 fa0b 3f74 9ae5 bea0 1447 3f73     1.....t?....G.s?
 802e13c:	7cd4 beac 0908 3f71 442a beb8 d89e 3f6e     .|....q?*D....n?
 802e14c:	ef15 bec3 835e 3f6c 7bca becf 09a7 3f6a     ....^.l?.{....j?
 802e15c:	e880 beda 6bd8 3f67 3375 bee6 aa59 3f64     .....kg?u3..Y.d?
 802e16c:	5aea bef1 c598 3f61 5d27 befc be05 3f5e     .Z....a?']....^?
 802e17c:	9c3d bf03 941a 3f5b f59b bf08 4853 3f58     =.....[?....SHX?
 802e18c:	39da bf0e db31 3f54 682a bf13 4d3d 3f51     .9..1.T?*h..=MQ?
 802e19c:	7fc0 bf18 9f02 3f4d 7fd1 bf1d d112 3f49     ......M?......I?
 802e1ac:	6799 bf22 e403 3f45 3656 bf27 d870 3f41     .g"...E?V6'.p.A?
 802e1bc:	eb4a bf2b aef9 3f3d 85bb bf30 6842 3f39     J.+...=?..0.Bh9?
 802e1cc:	04f3 bf35 04f3 3f35 6842 bf39 85bb 3f30     ..5...5?Bh9...0?
 802e1dc:	aef9 bf3d eb4a 3f2b d870 bf41 3656 3f27     ..=.J.+?p.A.V6'?
 802e1ec:	e403 bf45 6799 3f22 d112 bf49 7fd1 3f1d     ..E..g"?..I....?
 802e1fc:	9f02 bf4d 7fc0 3f18 4d3d bf51 682a 3f13     ..M....?=MQ.*h.?
 802e20c:	db31 bf54 39da 3f0e 4853 bf58 f59b 3f08     1.T..9.?SHX....?
 802e21c:	941a bf5b 9c3d 3f03 be05 bf5e 5d27 3efc     ..[.=..?..^.'].>
 802e22c:	c598 bf61 5aea 3ef1 aa59 bf64 3375 3ee6     ..a..Z.>Y.d.u3.>
 802e23c:	6bd8 bf67 e880 3eda 09a7 bf6a 7bca 3ecf     .kg....>..j..{.>
 802e24c:	835e bf6c ef15 3ec3 d89e bf6e 442a 3eb8     ^.l....>..n.*D.>
 802e25c:	0908 bf71 7cd4 3eac 1447 bf73 9ae5 3ea0     ..q..|.>G.s....>
 802e26c:	fa0b bf74 a031 3e94 ba07 bf76 8e93 3e88     ..t.1..>..v....>
 802e27c:	53f8 bf78 cfcc 3e78 c79d bf79 5c13 3e60     .Sx...x>..y..\`>
 802e28c:	14be bf7b c5c2 3e47 3b28 bf7c 10a2 3e2f     ..{...G>(;|.../>
 802e29c:	3aac bf7d 4083 3e16 1324 bf7e b273 3dfa     .:}..@.>$.~.s..=
 802e2ac:	c46d bf7e bd36 3dc8 4e6d bf7f a905 3d96     m.~.6..=mN.....=
 802e2bc:	b10f bf7f fb2f 3d48 ec43 bf7f 0ab0 3cc9     ..../.H=C......<
 802e2cc:	0000 bf80 0000 0000 ec43 bf7f 0ab0 bcc9     ........C.......
 802e2dc:	b10f bf7f fb2f bd48 4e6d bf7f a905 bd96     ..../.H.mN......
 802e2ec:	c46d bf7e bd36 bdc8 1324 bf7e b273 bdfa     m.~.6...$.~.s...
 802e2fc:	3aac bf7d 4083 be16 3b28 bf7c 10a2 be2f     .:}..@..(;|.../.
 802e30c:	14be bf7b c5c2 be47 c79d bf79 5c13 be60     ..{...G...y..\`.
 802e31c:	53f8 bf78 cfcc be78 ba07 bf76 8e93 be88     .Sx...x...v.....
 802e32c:	fa0b bf74 a031 be94 1447 bf73 9ae5 bea0     ..t.1...G.s.....
 802e33c:	0908 bf71 7cd4 beac d89e bf6e 442a beb8     ..q..|....n.*D..
 802e34c:	835e bf6c ef15 bec3 09a7 bf6a 7bca becf     ^.l.......j..{..
 802e35c:	6bd8 bf67 e880 beda aa59 bf64 3375 bee6     .kg.....Y.d.u3..
 802e36c:	c598 bf61 5aea bef1 be05 bf5e 5d27 befc     ..a..Z....^.']..
 802e37c:	941a bf5b 9c3d bf03 4853 bf58 f59b bf08     ..[.=...SHX.....
 802e38c:	db31 bf54 39da bf0e 4d3d bf51 682a bf13     1.T..9..=MQ.*h..
 802e39c:	9f02 bf4d 7fc0 bf18 d112 bf49 7fd1 bf1d     ..M.......I.....
 802e3ac:	e403 bf45 6799 bf22 d870 bf41 3656 bf27     ..E..g".p.A.V6'.
 802e3bc:	aef9 bf3d eb4a bf2b 6842 bf39 85bb bf30     ..=.J.+.Bh9...0.
 802e3cc:	04f3 bf35 04f3 bf35 85bb bf30 6842 bf39     ..5...5...0.Bh9.
 802e3dc:	eb4a bf2b aef9 bf3d 3656 bf27 d870 bf41     J.+...=.V6'.p.A.
 802e3ec:	6799 bf22 e403 bf45 7fd1 bf1d d112 bf49     .g"...E.......I.
 802e3fc:	7fc0 bf18 9f02 bf4d 682a bf13 4d3d bf51     ......M.*h..=MQ.
 802e40c:	39da bf0e db31 bf54 f59b bf08 4853 bf58     .9..1.T.....SHX.
 802e41c:	9c3d bf03 941a bf5b 5d27 befc be05 bf5e     =.....[.']....^.
 802e42c:	5aea bef1 c598 bf61 3375 bee6 aa59 bf64     .Z....a.u3..Y.d.
 802e43c:	e880 beda 6bd8 bf67 7bca becf 09a7 bf6a     .....kg..{....j.
 802e44c:	ef15 bec3 835e bf6c 442a beb8 d89e bf6e     ....^.l.*D....n.
 802e45c:	7cd4 beac 0908 bf71 9ae5 bea0 1447 bf73     .|....q.....G.s.
 802e46c:	a031 be94 fa0b bf74 8e93 be88 ba07 bf76     1.....t.......v.
 802e47c:	cfcc be78 53f8 bf78 5c13 be60 c79d bf79     ..x..Sx..\`...y.
 802e48c:	c5c2 be47 14be bf7b 10a2 be2f 3b28 bf7c     ..G...{.../.(;|.
 802e49c:	4083 be16 3aac bf7d b273 bdfa 1324 bf7e     .@...:}.s...$.~.
 802e4ac:	bd36 bdc8 c46d bf7e a905 bd96 4e6d bf7f     6...m.~.....mN..
 802e4bc:	fb2f bd48 b10f bf7f 0ab0 bcc9 ec43 bf7f     /.H.........C...
 802e4cc:	0000 8000 0000 bf80 0ab0 3cc9 ec43 bf7f     ...........<C...
 802e4dc:	fb2f 3d48 b10f bf7f a905 3d96 4e6d bf7f     /.H=.......=mN..
 802e4ec:	bd36 3dc8 c46d bf7e b273 3dfa 1324 bf7e     6..=m.~.s..=$.~.
 802e4fc:	4083 3e16 3aac bf7d 10a2 3e2f 3b28 bf7c     .@.>.:}.../>(;|.
 802e50c:	c5c2 3e47 14be bf7b 5c13 3e60 c79d bf79     ..G>..{..\`>..y.
 802e51c:	cfcc 3e78 53f8 bf78 8e93 3e88 ba07 bf76     ..x>.Sx....>..v.
 802e52c:	a031 3e94 fa0b bf74 9ae5 3ea0 1447 bf73     1..>..t....>G.s.
 802e53c:	7cd4 3eac 0908 bf71 442a 3eb8 d89e bf6e     .|.>..q.*D.>..n.
 802e54c:	ef15 3ec3 835e bf6c 7bca 3ecf 09a7 bf6a     ...>^.l..{.>..j.
 802e55c:	e880 3eda 6bd8 bf67 3375 3ee6 aa59 bf64     ...>.kg.u3.>Y.d.
 802e56c:	5aea 3ef1 c598 bf61 5d27 3efc be05 bf5e     .Z.>..a.'].>..^.
 802e57c:	9c3d 3f03 941a bf5b f59b 3f08 4853 bf58     =..?..[....?SHX.
 802e58c:	39da 3f0e db31 bf54 682a 3f13 4d3d bf51     .9.?1.T.*h.?=MQ.
 802e59c:	7fc0 3f18 9f02 bf4d 7fd1 3f1d d112 bf49     ...?..M....?..I.
 802e5ac:	6799 3f22 e403 bf45 3656 3f27 d870 bf41     .g"?..E.V6'?p.A.
 802e5bc:	eb4a 3f2b aef9 bf3d 85bb 3f30 6842 bf39     J.+?..=...0?Bh9.
 802e5cc:	04f3 3f35 04f3 bf35 6842 3f39 85bb bf30     ..5?..5.Bh9?..0.
 802e5dc:	aef9 3f3d eb4a bf2b d870 3f41 3656 bf27     ..=?J.+.p.A?V6'.
 802e5ec:	e403 3f45 6799 bf22 d112 3f49 7fd1 bf1d     ..E?.g"...I?....
 802e5fc:	9f02 3f4d 7fc0 bf18 4d3d 3f51 682a bf13     ..M?....=MQ?*h..
 802e60c:	db31 3f54 39da bf0e 4853 3f58 f59b bf08     1.T?.9..SHX?....
 802e61c:	941a 3f5b 9c3d bf03 be05 3f5e 5d27 befc     ..[?=.....^?']..
 802e62c:	c598 3f61 5aea bef1 aa59 3f64 3375 bee6     ..a?.Z..Y.d?u3..
 802e63c:	6bd8 3f67 e880 beda 09a7 3f6a 7bca becf     .kg?......j?.{..
 802e64c:	835e 3f6c ef15 bec3 d89e 3f6e 442a beb8     ^.l?......n?*D..
 802e65c:	0908 3f71 7cd4 beac 1447 3f73 9ae5 bea0     ..q?.|..G.s?....
 802e66c:	fa0b 3f74 a031 be94 ba07 3f76 8e93 be88     ..t?1.....v?....
 802e67c:	53f8 3f78 cfcc be78 c79d 3f79 5c13 be60     .Sx?..x...y?.\`.
 802e68c:	14be 3f7b c5c2 be47 3b28 3f7c 10a2 be2f     ..{?..G.(;|?../.
 802e69c:	3aac 3f7d 4083 be16 1324 3f7e b273 bdfa     .:}?.@..$.~?s...
 802e6ac:	c46d 3f7e bd36 bdc8 4e6d 3f7f a905 bd96     m.~?6...mN.?....
 802e6bc:	b10f 3f7f fb2f bd48 ec43 3f7f 0ab0 bcc9     ...?/.H.C..?....

0802e6cc <twiddleCoef_16>:
 802e6cc:	0000 3f80 0000 0000 835e 3f6c ef15 3ec3     ...?....^.l?...>
 802e6dc:	04f3 3f35 04f3 3f35 ef15 3ec3 835e 3f6c     ..5?..5?...>^.l?
 802e6ec:	0000 0000 0000 3f80 ef15 bec3 835e 3f6c     .......?....^.l?
 802e6fc:	04f3 bf35 04f3 3f35 835e bf6c ef15 3ec3     ..5...5?^.l....>
 802e70c:	0000 bf80 0000 0000 835e bf6c ef15 bec3     ........^.l.....
 802e71c:	04f3 bf35 04f3 bf35 ef15 bec3 835e bf6c     ..5...5.....^.l.
 802e72c:	0000 8000 0000 bf80 ef15 3ec3 835e bf6c     ...........>^.l.
 802e73c:	04f3 3f35 04f3 bf35 835e 3f6c ef15 bec3     ..5?..5.^.l?....

0802e74c <twiddleCoef_32>:
 802e74c:	0000 3f80 0000 0000 14be 3f7b c5c2 3e47     ...?......{?..G>
 802e75c:	835e 3f6c ef15 3ec3 db31 3f54 39da 3f0e     ^.l?...>1.T?.9.?
 802e76c:	04f3 3f35 04f3 3f35 39da 3f0e db31 3f54     ..5?..5?.9.?1.T?
 802e77c:	ef15 3ec3 835e 3f6c c5c2 3e47 14be 3f7b     ...>^.l?..G>..{?
 802e78c:	0000 0000 0000 3f80 c5c2 be47 14be 3f7b     .......?..G...{?
 802e79c:	ef15 bec3 835e 3f6c 39da bf0e db31 3f54     ....^.l?.9..1.T?
 802e7ac:	04f3 bf35 04f3 3f35 db31 bf54 39da 3f0e     ..5...5?1.T..9.?
 802e7bc:	835e bf6c ef15 3ec3 14be bf7b c5c2 3e47     ^.l....>..{...G>
 802e7cc:	0000 bf80 0000 0000 14be bf7b c5c2 be47     ..........{...G.
 802e7dc:	835e bf6c ef15 bec3 db31 bf54 39da bf0e     ^.l.....1.T..9..
 802e7ec:	04f3 bf35 04f3 bf35 39da bf0e db31 bf54     ..5...5..9..1.T.
 802e7fc:	ef15 bec3 835e bf6c c5c2 be47 14be bf7b     ....^.l...G...{.
 802e80c:	0000 8000 0000 bf80 c5c2 3e47 14be bf7b     ..........G>..{.
 802e81c:	ef15 3ec3 835e bf6c 39da 3f0e db31 bf54     ...>^.l..9.?1.T.
 802e82c:	04f3 3f35 04f3 bf35 db31 3f54 39da bf0e     ..5?..5.1.T?.9..
 802e83c:	835e 3f6c ef15 bec3 14be 3f7b c5c2 be47     ^.l?......{?..G.

0802e84c <armBitRevIndexTable16>:
 802e84c:	0008 0040 0018 0048 0010 0040 0028 0050     ..@...H...@.(.P.
 802e85c:	0020 0040 0038 0058 0030 0048 0058 0068      .@.8.X.0.H.X.h.
 802e86c:	0048 0060 0068 0070                         H.`.h.p.

0802e874 <armBitRevIndexTable32>:
 802e874:	0008 0040 0010 0080 0018 00c0 0020 0040     ..@......... .@.
 802e884:	0028 0048 0030 0088 0038 00c8 0040 0080     (.H.0...8...@...
 802e894:	0048 0050 0058 00d0 0050 0090 0060 00c0     H.P.X...P...`...
 802e8a4:	0068 00d0 0070 0098 0078 00d8 0088 00c0     h...p...x.......
 802e8b4:	0090 00a0 00a8 00d0 0098 00e0 00b0 00d0     ................
 802e8c4:	00b8 00e8 00d8 00f0 00c8 00e0 00e8 00f0     ................

0802e8d4 <sinTable_f32>:
 802e8d4:	0000 0000 0e92 3c49 0ab1 3cc9 c32b 3d16     ......I<...<+..=
 802e8e4:	fb2e 3d48 2b75 3d7b a904 3d96 b680 3daf     ..H=u+{=...=...=
 802e8f4:	bd36 3dc8 bc2f 3de1 b273 3dfa cf87 3e09     6..=/..=s..=...>
 802e904:	4083 3e16 abb5 3e22 10a2 3e2f 6ecf 3e3b     .@.>..">../>.n;>
 802e914:	c5c2 3e47 1501 3e54 5c13 3e60 9a7f 3e6c     ..G>..T>.\`>..l>
 802e924:	cfcc 3e78 7dc0 3e82 8e93 3e88 9a22 3e8e     ..x>.}.>...>"..>
 802e934:	a032 3e94 a086 3e9a 9ae5 3ea0 8f12 3ea6     2..>...>...>...>
 802e944:	7cd4 3eac 63ef 3eb2 442a 3eb8 1d49 3ebe     .|.>.c.>*D.>I..>
 802e954:	ef15 3ec3 b953 3ec9 7bca 3ecf 3641 3ed5     ...>S..>.{.>A6.>
 802e964:	e880 3eda 924f 3ee0 3375 3ee6 cbbb 3eeb     ...>O..>u3.>...>
 802e974:	5aea 3ef1 e0cb 3ef6 5d27 3efc e7e4 3f00     .Z.>...>'].>...?
 802e984:	9c3d 3f03 4b82 3f06 f59b 3f08 9a6b 3f0b     =..?.K.?...?k..?
 802e994:	39da 3f0e d3cd 3f10 682a 3f13 f6d9 3f15     .9.?...?*h.?...?
 802e9a4:	7fc0 3f18 02c6 3f1b 7fd1 3f1d f6cb 3f1f     ...?...?...?...?
 802e9b4:	6799 3f22 d225 3f24 3656 3f27 9415 3f29     .g"?%.$?V6'?..)?
 802e9c4:	eb4a 3f2b 3bde 3f2e 85bb 3f30 c8c9 3f32     J.+?.;.?..0?..2?
 802e9d4:	04f3 3f35 3a23 3f37 6842 3f39 8f3b 3f3b     ..5?#:7?Bh9?;.;?
 802e9e4:	aef9 3f3d c767 3f3f d870 3f41 e201 3f43     ..=?g.??p.A?..C?
 802e9f4:	e403 3f45 de65 3f47 d112 3f49 bbf8 3f4b     ..E?e.G?..I?..K?
 802ea04:	9f02 3f4d 7a20 3f4f 4d3d 3f51 1849 3f53     ..M? zO?=MQ?I.S?
 802ea14:	db31 3f54 95e5 3f56 4853 3f58 f26a 3f59     1.T?..V?SHX?j.Y?
 802ea24:	941a 3f5b 2d53 3f5d be05 3f5e 4621 3f60     ..[?S-]?..^?!F`?
 802ea34:	c597 3f61 3c5a 3f63 aa59 3f64 0f88 3f66     ..a?Z<c?Y.d?..f?
 802ea44:	6bd8 3f67 bf3c 3f68 09a7 3f6a 4b0c 3f6b     .kg?<.h?..j?.Kk?
 802ea54:	835e 3f6c b293 3f6d d89e 3f6e f573 3f6f     ^.l?..m?..n?s.o?
 802ea64:	0908 3f71 1352 3f72 1447 3f73 0bdd 3f74     ..q?R.r?G.s?..t?
 802ea74:	fa0b 3f74 dec6 3f75 ba07 3f76 8bc5 3f77     ..t?..u?..v?..w?
 802ea84:	53f8 3f78 1298 3f79 c79d 3f79 7302 3f7a     .Sx?..y?..y?.sz?
 802ea94:	14be 3f7b accd 3f7b 3b28 3f7c bfc9 3f7c     ..{?..{?(;|?..|?
 802eaa4:	3aac 3f7d abcc 3f7d 1323 3f7e 70b0 3f7e     .:}?..}?#.~?.p~?
 802eab4:	c46d 3f7e 0e58 3f7f 4e6d 3f7f 84ab 3f7f     m.~?X..?mN.?...?
 802eac4:	b10f 3f7f d397 3f7f ec43 3f7f fb11 3f7f     ...?...?C..?...?
 802ead4:	0000 3f80 fb11 3f7f ec43 3f7f d397 3f7f     ...?...?C..?...?
 802eae4:	b10f 3f7f 84ab 3f7f 4e6d 3f7f 0e58 3f7f     ...?...?mN.?X..?
 802eaf4:	c46d 3f7e 70b0 3f7e 1323 3f7e abcc 3f7d     m.~?.p~?#.~?..}?
 802eb04:	3aac 3f7d bfc9 3f7c 3b28 3f7c accd 3f7b     .:}?..|?(;|?..{?
 802eb14:	14be 3f7b 7302 3f7a c79d 3f79 1298 3f79     ..{?.sz?..y?..y?
 802eb24:	53f8 3f78 8bc5 3f77 ba07 3f76 dec6 3f75     .Sx?..w?..v?..u?
 802eb34:	fa0b 3f74 0bdd 3f74 1447 3f73 1352 3f72     ..t?..t?G.s?R.r?
 802eb44:	0908 3f71 f573 3f6f d89e 3f6e b293 3f6d     ..q?s.o?..n?..m?
 802eb54:	835e 3f6c 4b0c 3f6b 09a7 3f6a bf3c 3f68     ^.l?.Kk?..j?<.h?
 802eb64:	6bd8 3f67 0f88 3f66 aa59 3f64 3c5a 3f63     .kg?..f?Y.d?Z<c?
 802eb74:	c597 3f61 4621 3f60 be05 3f5e 2d53 3f5d     ..a?!F`?..^?S-]?
 802eb84:	941a 3f5b f26a 3f59 4853 3f58 95e5 3f56     ..[?j.Y?SHX?..V?
 802eb94:	db31 3f54 1849 3f53 4d3d 3f51 7a20 3f4f     1.T?I.S?=MQ? zO?
 802eba4:	9f02 3f4d bbf8 3f4b d112 3f49 de65 3f47     ..M?..K?..I?e.G?
 802ebb4:	e403 3f45 e201 3f43 d870 3f41 c767 3f3f     ..E?..C?p.A?g.??
 802ebc4:	aef9 3f3d 8f3b 3f3b 6842 3f39 3a23 3f37     ..=?;.;?Bh9?#:7?
 802ebd4:	04f3 3f35 c8c9 3f32 85bb 3f30 3bde 3f2e     ..5?..2?..0?.;.?
 802ebe4:	eb4a 3f2b 9415 3f29 3656 3f27 d225 3f24     J.+?..)?V6'?%.$?
 802ebf4:	6799 3f22 f6cb 3f1f 7fd1 3f1d 02c6 3f1b     .g"?...?...?...?
 802ec04:	7fc0 3f18 f6d9 3f15 682a 3f13 d3cd 3f10     ...?...?*h.?...?
 802ec14:	39da 3f0e 9a6b 3f0b f59b 3f08 4b82 3f06     .9.?k..?...?.K.?
 802ec24:	9c3d 3f03 e7e4 3f00 5d27 3efc e0cb 3ef6     =..?...?'].>...>
 802ec34:	5aea 3ef1 cbbb 3eeb 3375 3ee6 924f 3ee0     .Z.>...>u3.>O..>
 802ec44:	e880 3eda 3641 3ed5 7bca 3ecf b953 3ec9     ...>A6.>.{.>S..>
 802ec54:	ef15 3ec3 1d49 3ebe 442a 3eb8 63ef 3eb2     ...>I..>*D.>.c.>
 802ec64:	7cd4 3eac 8f12 3ea6 9ae5 3ea0 a086 3e9a     .|.>...>...>...>
 802ec74:	a032 3e94 9a22 3e8e 8e93 3e88 7dc0 3e82     2..>"..>...>.}.>
 802ec84:	cfcc 3e78 9a7f 3e6c 5c13 3e60 1501 3e54     ..x>..l>.\`>..T>
 802ec94:	c5c2 3e47 6ecf 3e3b 10a2 3e2f abb5 3e22     ..G>.n;>../>..">
 802eca4:	4083 3e16 cf87 3e09 b273 3dfa bc2f 3de1     .@.>...>s..=/..=
 802ecb4:	bd36 3dc8 b680 3daf a904 3d96 2b75 3d7b     6..=...=...=u+{=
 802ecc4:	fb2e 3d48 c32b 3d16 0ab1 3cc9 0e92 3c49     ..H=+..=...<..I<
 802ecd4:	0000 0000 0e92 bc49 0ab1 bcc9 c32b bd16     ......I.....+...
 802ece4:	fb2e bd48 2b75 bd7b a904 bd96 b680 bdaf     ..H.u+{.........
 802ecf4:	bd36 bdc8 bc2f bde1 b273 bdfa cf87 be09     6.../...s.......
 802ed04:	4083 be16 abb5 be22 10a2 be2f 6ecf be3b     .@....".../..n;.
 802ed14:	c5c2 be47 1501 be54 5c13 be60 9a7f be6c     ..G...T..\`...l.
 802ed24:	cfcc be78 7dc0 be82 8e93 be88 9a22 be8e     ..x..}......"...
 802ed34:	a032 be94 a086 be9a 9ae5 bea0 8f12 bea6     2...............
 802ed44:	7cd4 beac 63ef beb2 442a beb8 1d49 bebe     .|...c..*D..I...
 802ed54:	ef15 bec3 b953 bec9 7bca becf 3641 bed5     ....S....{..A6..
 802ed64:	e880 beda 924f bee0 3375 bee6 cbbb beeb     ....O...u3......
 802ed74:	5aea bef1 e0cb bef6 5d27 befc e7e4 bf00     .Z......']......
 802ed84:	9c3d bf03 4b82 bf06 f59b bf08 9a6b bf0b     =....K......k...
 802ed94:	39da bf0e d3cd bf10 682a bf13 f6d9 bf15     .9......*h......
 802eda4:	7fc0 bf18 02c6 bf1b 7fd1 bf1d f6cb bf1f     ................
 802edb4:	6799 bf22 d225 bf24 3656 bf27 9415 bf29     .g".%.$.V6'...).
 802edc4:	eb4a bf2b 3bde bf2e 85bb bf30 c8c9 bf32     J.+..;....0...2.
 802edd4:	04f3 bf35 3a23 bf37 6842 bf39 8f3b bf3b     ..5.#:7.Bh9.;.;.
 802ede4:	aef9 bf3d c767 bf3f d870 bf41 e201 bf43     ..=.g.?.p.A...C.
 802edf4:	e403 bf45 de65 bf47 d112 bf49 bbf8 bf4b     ..E.e.G...I...K.
 802ee04:	9f02 bf4d 7a20 bf4f 4d3d bf51 1849 bf53     ..M. zO.=MQ.I.S.
 802ee14:	db31 bf54 95e5 bf56 4853 bf58 f26a bf59     1.T...V.SHX.j.Y.
 802ee24:	941a bf5b 2d53 bf5d be05 bf5e 4621 bf60     ..[.S-]...^.!F`.
 802ee34:	c597 bf61 3c5a bf63 aa59 bf64 0f88 bf66     ..a.Z<c.Y.d...f.
 802ee44:	6bd8 bf67 bf3c bf68 09a7 bf6a 4b0c bf6b     .kg.<.h...j..Kk.
 802ee54:	835e bf6c b293 bf6d d89e bf6e f573 bf6f     ^.l...m...n.s.o.
 802ee64:	0908 bf71 1352 bf72 1447 bf73 0bdd bf74     ..q.R.r.G.s...t.
 802ee74:	fa0b bf74 dec6 bf75 ba07 bf76 8bc5 bf77     ..t...u...v...w.
 802ee84:	53f8 bf78 1298 bf79 c79d bf79 7302 bf7a     .Sx...y...y..sz.
 802ee94:	14be bf7b accd bf7b 3b28 bf7c bfc9 bf7c     ..{...{.(;|...|.
 802eea4:	3aac bf7d abcc bf7d 1323 bf7e 70b0 bf7e     .:}...}.#.~..p~.
 802eeb4:	c46d bf7e 0e58 bf7f 4e6d bf7f 84ab bf7f     m.~.X...mN......
 802eec4:	b10f bf7f d397 bf7f ec43 bf7f fb11 bf7f     ........C.......
 802eed4:	0000 bf80 fb11 bf7f ec43 bf7f d397 bf7f     ........C.......
 802eee4:	b10f bf7f 84ab bf7f 4e6d bf7f 0e58 bf7f     ........mN..X...
 802eef4:	c46d bf7e 70b0 bf7e 1323 bf7e abcc bf7d     m.~..p~.#.~...}.
 802ef04:	3aac bf7d bfc9 bf7c 3b28 bf7c accd bf7b     .:}...|.(;|...{.
 802ef14:	14be bf7b 7302 bf7a c79d bf79 1298 bf79     ..{..sz...y...y.
 802ef24:	53f8 bf78 8bc5 bf77 ba07 bf76 dec6 bf75     .Sx...w...v...u.
 802ef34:	fa0b bf74 0bdd bf74 1447 bf73 1352 bf72     ..t...t.G.s.R.r.
 802ef44:	0908 bf71 f573 bf6f d89e bf6e b293 bf6d     ..q.s.o...n...m.
 802ef54:	835e bf6c 4b0c bf6b 09a7 bf6a bf3c bf68     ^.l..Kk...j.<.h.
 802ef64:	6bd8 bf67 0f88 bf66 aa59 bf64 3c5a bf63     .kg...f.Y.d.Z<c.
 802ef74:	c597 bf61 4621 bf60 be05 bf5e 2d53 bf5d     ..a.!F`...^.S-].
 802ef84:	941a bf5b f26a bf59 4853 bf58 95e5 bf56     ..[.j.Y.SHX...V.
 802ef94:	db31 bf54 1849 bf53 4d3d bf51 7a20 bf4f     1.T.I.S.=MQ. zO.
 802efa4:	9f02 bf4d bbf8 bf4b d112 bf49 de65 bf47     ..M...K...I.e.G.
 802efb4:	e403 bf45 e201 bf43 d870 bf41 c767 bf3f     ..E...C.p.A.g.?.
 802efc4:	aef9 bf3d 8f3b bf3b 6842 bf39 3a23 bf37     ..=.;.;.Bh9.#:7.
 802efd4:	04f3 bf35 c8c9 bf32 85bb bf30 3bde bf2e     ..5...2...0..;..
 802efe4:	eb4a bf2b 9415 bf29 3656 bf27 d225 bf24     J.+...).V6'.%.$.
 802eff4:	6799 bf22 f6cb bf1f 7fd1 bf1d 02c6 bf1b     .g".............
 802f004:	7fc0 bf18 f6d9 bf15 682a bf13 d3cd bf10     ........*h......
 802f014:	39da bf0e 9a6b bf0b f59b bf08 4b82 bf06     .9..k........K..
 802f024:	9c3d bf03 e7e4 bf00 5d27 befc e0cb bef6     =.......']......
 802f034:	5aea bef1 cbbb beeb 3375 bee6 924f bee0     .Z......u3..O...
 802f044:	e880 beda 3641 bed5 7bca becf b953 bec9     ....A6...{..S...
 802f054:	ef15 bec3 1d49 bebe 442a beb8 63ef beb2     ....I...*D...c..
 802f064:	7cd4 beac 8f12 bea6 9ae5 bea0 a086 be9a     .|..............
 802f074:	a032 be94 9a22 be8e 8e93 be88 7dc0 be82     2..."........}..
 802f084:	cfcc be78 9a7f be6c 5c13 be60 1501 be54     ..x...l..\`...T.
 802f094:	c5c2 be47 6ecf be3b 10a2 be2f abb5 be22     ..G..n;.../...".
 802f0a4:	4083 be16 cf87 be09 b273 bdfa bc2f bde1     .@......s.../...
 802f0b4:	bd36 bdc8 b680 bdaf a904 bd96 2b75 bd7b     6...........u+{.
 802f0c4:	fb2e bd48 c32b bd16 0ab1 bcc9 0e92 bc49     ..H.+.........I.
 802f0d4:	0000 8000                                   ....

0802f0d8 <twiddleCoef_128>:
 802f0d8:	0000 3f80 0000 0000 b10f 3f7f fb2f 3d48     ...?.......?/.H=
 802f0e8:	c46d 3f7e bd36 3dc8 3aac 3f7d 4083 3e16     m.~?6..=.:}?.@.>
 802f0f8:	14be 3f7b c5c2 3e47 53f8 3f78 cfcc 3e78     ..{?..G>.Sx?..x>
 802f108:	fa0b 3f74 a031 3e94 0908 3f71 7cd4 3eac     ..t?1..>..q?.|.>
 802f118:	835e 3f6c ef15 3ec3 6bd8 3f67 e880 3eda     ^.l?...>.kg?...>
 802f128:	c598 3f61 5aea 3ef1 941a 3f5b 9c3d 3f03     ..a?.Z.>..[?=..?
 802f138:	db31 3f54 39da 3f0e 9f02 3f4d 7fc0 3f18     1.T?.9.?..M?...?
 802f148:	e403 3f45 6799 3f22 aef9 3f3d eb4a 3f2b     ..E?.g"?..=?J.+?
 802f158:	04f3 3f35 04f3 3f35 eb4a 3f2b aef9 3f3d     ..5?..5?J.+?..=?
 802f168:	6799 3f22 e403 3f45 7fc0 3f18 9f02 3f4d     .g"?..E?...?..M?
 802f178:	39da 3f0e db31 3f54 9c3d 3f03 941a 3f5b     .9.?1.T?=..?..[?
 802f188:	5aea 3ef1 c598 3f61 e880 3eda 6bd8 3f67     .Z.>..a?...>.kg?
 802f198:	ef15 3ec3 835e 3f6c 7cd4 3eac 0908 3f71     ...>^.l?.|.>..q?
 802f1a8:	a031 3e94 fa0b 3f74 cfcc 3e78 53f8 3f78     1..>..t?..x>.Sx?
 802f1b8:	c5c2 3e47 14be 3f7b 4083 3e16 3aac 3f7d     ..G>..{?.@.>.:}?
 802f1c8:	bd36 3dc8 c46d 3f7e fb2f 3d48 b10f 3f7f     6..=m.~?/.H=...?
 802f1d8:	0000 0000 0000 3f80 fb2f bd48 b10f 3f7f     .......?/.H....?
 802f1e8:	bd36 bdc8 c46d 3f7e 4083 be16 3aac 3f7d     6...m.~?.@...:}?
 802f1f8:	c5c2 be47 14be 3f7b cfcc be78 53f8 3f78     ..G...{?..x..Sx?
 802f208:	a031 be94 fa0b 3f74 7cd4 beac 0908 3f71     1.....t?.|....q?
 802f218:	ef15 bec3 835e 3f6c e880 beda 6bd8 3f67     ....^.l?.....kg?
 802f228:	5aea bef1 c598 3f61 9c3d bf03 941a 3f5b     .Z....a?=.....[?
 802f238:	39da bf0e db31 3f54 7fc0 bf18 9f02 3f4d     .9..1.T?......M?
 802f248:	6799 bf22 e403 3f45 eb4a bf2b aef9 3f3d     .g"...E?J.+...=?
 802f258:	04f3 bf35 04f3 3f35 aef9 bf3d eb4a 3f2b     ..5...5?..=.J.+?
 802f268:	e403 bf45 6799 3f22 9f02 bf4d 7fc0 3f18     ..E..g"?..M....?
 802f278:	db31 bf54 39da 3f0e 941a bf5b 9c3d 3f03     1.T..9.?..[.=..?
 802f288:	c598 bf61 5aea 3ef1 6bd8 bf67 e880 3eda     ..a..Z.>.kg....>
 802f298:	835e bf6c ef15 3ec3 0908 bf71 7cd4 3eac     ^.l....>..q..|.>
 802f2a8:	fa0b bf74 a031 3e94 53f8 bf78 cfcc 3e78     ..t.1..>.Sx...x>
 802f2b8:	14be bf7b c5c2 3e47 3aac bf7d 4083 3e16     ..{...G>.:}..@.>
 802f2c8:	c46d bf7e bd36 3dc8 b10f bf7f fb2f 3d48     m.~.6..=..../.H=
 802f2d8:	0000 bf80 0000 0000 b10f bf7f fb2f bd48     ............/.H.
 802f2e8:	c46d bf7e bd36 bdc8 3aac bf7d 4083 be16     m.~.6....:}..@..
 802f2f8:	14be bf7b c5c2 be47 53f8 bf78 cfcc be78     ..{...G..Sx...x.
 802f308:	fa0b bf74 a031 be94 0908 bf71 7cd4 beac     ..t.1.....q..|..
 802f318:	835e bf6c ef15 bec3 6bd8 bf67 e880 beda     ^.l......kg.....
 802f328:	c598 bf61 5aea bef1 941a bf5b 9c3d bf03     ..a..Z....[.=...
 802f338:	db31 bf54 39da bf0e 9f02 bf4d 7fc0 bf18     1.T..9....M.....
 802f348:	e403 bf45 6799 bf22 aef9 bf3d eb4a bf2b     ..E..g"...=.J.+.
 802f358:	04f3 bf35 04f3 bf35 eb4a bf2b aef9 bf3d     ..5...5.J.+...=.
 802f368:	6799 bf22 e403 bf45 7fc0 bf18 9f02 bf4d     .g"...E.......M.
 802f378:	39da bf0e db31 bf54 9c3d bf03 941a bf5b     .9..1.T.=.....[.
 802f388:	5aea bef1 c598 bf61 e880 beda 6bd8 bf67     .Z....a......kg.
 802f398:	ef15 bec3 835e bf6c 7cd4 beac 0908 bf71     ....^.l..|....q.
 802f3a8:	a031 be94 fa0b bf74 cfcc be78 53f8 bf78     1.....t...x..Sx.
 802f3b8:	c5c2 be47 14be bf7b 4083 be16 3aac bf7d     ..G...{..@...:}.
 802f3c8:	bd36 bdc8 c46d bf7e fb2f bd48 b10f bf7f     6...m.~./.H.....
 802f3d8:	0000 8000 0000 bf80 fb2f 3d48 b10f bf7f     ......../.H=....
 802f3e8:	bd36 3dc8 c46d bf7e 4083 3e16 3aac bf7d     6..=m.~..@.>.:}.
 802f3f8:	c5c2 3e47 14be bf7b cfcc 3e78 53f8 bf78     ..G>..{...x>.Sx.
 802f408:	a031 3e94 fa0b bf74 7cd4 3eac 0908 bf71     1..>..t..|.>..q.
 802f418:	ef15 3ec3 835e bf6c e880 3eda 6bd8 bf67     ...>^.l....>.kg.
 802f428:	5aea 3ef1 c598 bf61 9c3d 3f03 941a bf5b     .Z.>..a.=..?..[.
 802f438:	39da 3f0e db31 bf54 7fc0 3f18 9f02 bf4d     .9.?1.T....?..M.
 802f448:	6799 3f22 e403 bf45 eb4a 3f2b aef9 bf3d     .g"?..E.J.+?..=.
 802f458:	04f3 3f35 04f3 bf35 aef9 3f3d eb4a bf2b     ..5?..5...=?J.+.
 802f468:	e403 3f45 6799 bf22 9f02 3f4d 7fc0 bf18     ..E?.g"...M?....
 802f478:	db31 3f54 39da bf0e 941a 3f5b 9c3d bf03     1.T?.9....[?=...
 802f488:	c598 3f61 5aea bef1 6bd8 3f67 e880 beda     ..a?.Z...kg?....
 802f498:	835e 3f6c ef15 bec3 0908 3f71 7cd4 beac     ^.l?......q?.|..
 802f4a8:	fa0b 3f74 a031 be94 53f8 3f78 cfcc be78     ..t?1....Sx?..x.
 802f4b8:	14be 3f7b c5c2 be47 3aac 3f7d 4083 be16     ..{?..G..:}?.@..
 802f4c8:	c46d 3f7e bd36 bdc8 b10f 3f7f fb2f bd48     m.~?6......?/.H.

0802f4d8 <twiddleCoef_64>:
 802f4d8:	0000 3f80 0000 0000 c46d 3f7e bd36 3dc8     ...?....m.~?6..=
 802f4e8:	14be 3f7b c5c2 3e47 fa0b 3f74 a031 3e94     ..{?..G>..t?1..>
 802f4f8:	835e 3f6c ef15 3ec3 c598 3f61 5aea 3ef1     ^.l?...>..a?.Z.>
 802f508:	db31 3f54 39da 3f0e e403 3f45 6799 3f22     1.T?.9.?..E?.g"?
 802f518:	04f3 3f35 04f3 3f35 6799 3f22 e403 3f45     ..5?..5?.g"?..E?
 802f528:	39da 3f0e db31 3f54 5aea 3ef1 c598 3f61     .9.?1.T?.Z.>..a?
 802f538:	ef15 3ec3 835e 3f6c a031 3e94 fa0b 3f74     ...>^.l?1..>..t?
 802f548:	c5c2 3e47 14be 3f7b bd36 3dc8 c46d 3f7e     ..G>..{?6..=m.~?
 802f558:	0000 0000 0000 3f80 bd36 bdc8 c46d 3f7e     .......?6...m.~?
 802f568:	c5c2 be47 14be 3f7b a031 be94 fa0b 3f74     ..G...{?1.....t?
 802f578:	ef15 bec3 835e 3f6c 5aea bef1 c598 3f61     ....^.l?.Z....a?
 802f588:	39da bf0e db31 3f54 6799 bf22 e403 3f45     .9..1.T?.g"...E?
 802f598:	04f3 bf35 04f3 3f35 e403 bf45 6799 3f22     ..5...5?..E..g"?
 802f5a8:	db31 bf54 39da 3f0e c598 bf61 5aea 3ef1     1.T..9.?..a..Z.>
 802f5b8:	835e bf6c ef15 3ec3 fa0b bf74 a031 3e94     ^.l....>..t.1..>
 802f5c8:	14be bf7b c5c2 3e47 c46d bf7e bd36 3dc8     ..{...G>m.~.6..=
 802f5d8:	0000 bf80 0000 0000 c46d bf7e bd36 bdc8     ........m.~.6...
 802f5e8:	14be bf7b c5c2 be47 fa0b bf74 a031 be94     ..{...G...t.1...
 802f5f8:	835e bf6c ef15 bec3 c598 bf61 5aea bef1     ^.l.......a..Z..
 802f608:	db31 bf54 39da bf0e e403 bf45 6799 bf22     1.T..9....E..g".
 802f618:	04f3 bf35 04f3 bf35 6799 bf22 e403 bf45     ..5...5..g"...E.
 802f628:	39da bf0e db31 bf54 5aea bef1 c598 bf61     .9..1.T..Z....a.
 802f638:	ef15 bec3 835e bf6c a031 be94 fa0b bf74     ....^.l.1.....t.
 802f648:	c5c2 be47 14be bf7b bd36 bdc8 c46d bf7e     ..G...{.6...m.~.
 802f658:	0000 8000 0000 bf80 bd36 3dc8 c46d bf7e     ........6..=m.~.
 802f668:	c5c2 3e47 14be bf7b a031 3e94 fa0b bf74     ..G>..{.1..>..t.
 802f678:	ef15 3ec3 835e bf6c 5aea 3ef1 c598 bf61     ...>^.l..Z.>..a.
 802f688:	39da 3f0e db31 bf54 6799 3f22 e403 bf45     .9.?1.T..g"?..E.
 802f698:	04f3 3f35 04f3 bf35 e403 3f45 6799 bf22     ..5?..5...E?.g".
 802f6a8:	db31 3f54 39da bf0e c598 3f61 5aea bef1     1.T?.9....a?.Z..
 802f6b8:	835e 3f6c ef15 bec3 fa0b 3f74 a031 be94     ^.l?......t?1...
 802f6c8:	14be 3f7b c5c2 be47 c46d 3f7e bd36 bdc8     ..{?..G.m.~?6...

0802f6d8 <armBitRevIndexTable256>:
 802f6d8:	0008 0200 0010 0400 0018 0600 0020 0040     ............ .@.
 802f6e8:	0028 0240 0030 0440 0038 0640 0040 0080     (.@.0.@.8.@.@...
 802f6f8:	0048 0280 0050 0480 0058 0680 0060 00c0     H...P...X...`...
 802f708:	0068 02c0 0070 04c0 0078 06c0 0080 0100     h...p...x.......
 802f718:	0088 0300 0090 0500 0098 0700 00a0 0140     ..............@.
 802f728:	00a8 0340 00b0 0540 00b8 0740 00c0 0180     ..@...@...@.....
 802f738:	00c8 0380 00d0 0580 00d8 0780 00e0 01c0     ................
 802f748:	00e8 03c0 00f0 05c0 00f8 07c0 0100 0200     ................
 802f758:	0108 0208 0110 0408 0118 0608 0120 0280     ............ ...
 802f768:	0128 0248 0130 0448 0138 0648 0140 0300     (.H.0.H.8.H.@...
 802f778:	0148 0288 0150 0488 0158 0688 0160 0380     H...P...X...`...
 802f788:	0168 02c8 0170 04c8 0178 06c8 0180 0208     h...p...x.......
 802f798:	0188 0308 0190 0508 0198 0708 01a0 0288     ................
 802f7a8:	01a8 0348 01b0 0548 01b8 0748 01c0 0308     ..H...H...H.....
 802f7b8:	01c8 0388 01d0 0588 01d8 0788 01e0 0388     ................
 802f7c8:	01e8 03c8 01f0 05c8 01f8 07c8 0208 0210     ................
 802f7d8:	0200 0400 0210 0410 0218 0610 0220 0480     ............ ...
 802f7e8:	0228 0250 0230 0450 0238 0650 0240 0500     (.P.0.P.8.P.@...
 802f7f8:	0248 0290 0250 0490 0258 0690 0260 0580     H...P...X...`...
 802f808:	0268 02d0 0270 04d0 0278 06d0 0280 0408     h...p...x.......
 802f818:	0288 0310 0290 0510 0298 0710 02a0 0488     ................
 802f828:	02a8 0350 02b0 0550 02b8 0750 02c0 0508     ..P...P...P.....
 802f838:	02c8 0390 02d0 0590 02d8 0790 02e0 0588     ................
 802f848:	02e8 03d0 02f0 05d0 02f8 07d0 0300 0600     ................
 802f858:	0308 0610 0310 0418 0318 0618 0320 0680     ............ ...
 802f868:	0328 0690 0330 0458 0338 0658 0340 0700     (...0.X.8.X.@...
 802f878:	0348 0710 0350 0498 0358 0698 0360 0780     H...P...X...`...
 802f888:	0368 0790 0370 04d8 0378 06d8 0380 0608     h...p...x.......
 802f898:	0388 0618 0390 0518 0398 0718 03a0 0688     ................
 802f8a8:	03a8 0698 03b0 0558 03b8 0758 03c0 0708     ......X...X.....
 802f8b8:	03c8 0718 03d0 0598 03d8 0798 03e0 0788     ................
 802f8c8:	03e8 0798 03f0 05d8 03f8 07d8 0408 0480     ................
 802f8d8:	0410 0420 0418 0620 0428 0580 0430 0460     .. ... .(...0.`.
 802f8e8:	0438 0660 0440 0600 0448 0488 0450 04a0     8.`.@...H...P...
 802f8f8:	0458 06a0 0460 0610 0468 0588 0470 04e0     X...`...h...p...
 802f908:	0478 06e0 0488 0680 0490 0520 0498 0720     x......... ... .
 802f918:	04a0 0608 04a8 0780 04b0 0560 04b8 0760     ..........`...`.
 802f928:	04c0 0620 04c8 0688 04d0 05a0 04d8 07a0     .. .............
 802f938:	04e0 0618 04e8 0788 04f0 05e0 04f8 07e0     ................
 802f948:	0508 0520 0510 0580 0518 0628 0528 0590     .. .......(.(...
 802f958:	0530 0588 0538 0668 0540 0700 0548 0720     0...8.h.@...H. .
 802f968:	0550 0780 0558 06a8 0560 0708 0568 0598     P...X...`...h...
 802f978:	0570 0788 0578 06e8 0588 0690 0598 0728     p...x.........(.
 802f988:	05a0 0628 05a8 0790 05b0 0728 05b8 0768     ..(.......(...h.
 802f998:	05c0 0710 05c8 0698 05d0 0790 05d8 07a8     ................
 802f9a8:	05e0 0718 05e8 0798 05f0 0798 05f8 07e8     ................
 802f9b8:	0618 0630 0638 0670 0640 0700 0648 0780     ..0.8.p.@...H...
 802f9c8:	0650 0708 0658 06b0 0660 0710 0668 0790     P...X...`...h...
 802f9d8:	0670 0718 0678 06f0 0688 06a0 0698 0730     p...x.........0.
 802f9e8:	06a8 07a0 06b0 0788 06b8 0770 06c0 0720     ..........p... .
 802f9f8:	06c8 07a0 06d0 0728 06d8 07b0 06e0 0730     ......(.......0.
 802fa08:	06e8 07a8 06f0 0798 06f8 07f0 0748 0750     ............H.P.
 802fa18:	0738 0798 0750 0760 0758 0770 0760 07c0     8...P.`.X.p.`...
 802fa28:	0768 07d0 0778 07f0 0770 07e0 07b8 07f0     h...x...p.......
 802fa38:	07a8 07b0 07d8 07f0 07c8 07e0 07e8 07f0     ................

0802fa48 <armBitRevIndexTable128>:
 802fa48:	0008 0200 0010 0040 0018 0240 0020 0080     ......@...@. ...
 802fa58:	0028 0280 0030 00c0 0038 02c0 0040 0100     (...0...8...@...
 802fa68:	0048 0300 0050 0140 0058 0340 0060 0180     H...P.@.X.@.`...
 802fa78:	0068 0380 0070 01c0 0078 03c0 0080 0200     h...p...x.......
 802fa88:	0088 0208 0090 0300 0098 0248 00a0 0208     ..........H.....
 802fa98:	00a8 0288 00b0 00c8 00b8 02c8 00c0 0108     ................
 802faa8:	00c8 0308 00d0 0148 00d8 0348 00e0 0188     ......H...H.....
 802fab8:	00e8 0388 00f0 01c8 00f8 03c8 0108 0210     ................
 802fac8:	0110 0140 0118 0250 0120 0300 0128 0290     ..@...P. ...(...
 802fad8:	0130 0148 0138 02d0 0148 0310 0158 0350     0.H.8...H...X.P.
 802fae8:	0160 0190 0168 0390 0170 01d0 0178 03d0     `...h...p...x...
 802faf8:	0180 0240 0188 0218 0190 0340 0198 0258     ..@.......@...X.
 802fb08:	01a0 0248 01a8 0298 01b0 0348 01b8 02d8     ..H.......H.....
 802fb18:	01c0 0250 01c8 0318 01d0 0350 01d8 0358     ..P.......P...X.
 802fb28:	01e0 0258 01e8 0398 01f0 0358 01f8 03d8     ..X.......X.....
 802fb38:	0208 0220 0210 0240 0218 0260 0228 02a0     .. ...@...`.(...
 802fb48:	0230 0260 0238 02e0 0240 0300 0248 0320     0.`.8...@...H. .
 802fb58:	0250 0340 0258 0360 0260 0320 0268 03a0     P.@.X.`.`. .h...
 802fb68:	0270 0360 0278 03e0 0288 02a0 0290 0380     p.`.x...........
 802fb78:	0298 03a0 02b0 0388 02b8 02e8 02c0 0380     ................
 802fb88:	02c8 0328 02d0 0390 02d8 0368 02e0 03a0     ..(.......h.....
 802fb98:	02e8 03a8 02f0 0398 02f8 03e8 0308 0320     .............. .
 802fba8:	0310 0340 0318 0360 0328 0388 0330 0360     ..@...`.(...0.`.
 802fbb8:	0338 0398 0348 0360 0358 0370 0368 03b0     8...H.`.X.p.h...
 802fbc8:	0378 03f0 0388 03a0 0390 03c0 0398 03e0     x...............
 802fbd8:	03b0 03c8 03b8 03e8 03c8 03e0 03d8 03f0     ................

0802fbe8 <arm_cfft_sR_f32_len64>:
 802fbe8:	0040 0000 f4d8 0802 de5c 0802 0038 0000     @.......\...8...

0802fbf8 <arm_cfft_sR_f32_len128>:
 802fbf8:	0080 0000 f0d8 0802 fa48 0802 00d0 0000     ........H.......

0802fc08 <arm_cfft_sR_f32_len16>:
 802fc08:	0010 0000 e6cc 0802 e84c 0802 0014 0000     ........L.......

0802fc18 <arm_cfft_sR_f32_len256>:
 802fc18:	0100 0000 decc 0802 f6d8 0802 01b8 0000     ................

0802fc28 <arm_cfft_sR_f32_len32>:
 802fc28:	0020 0000 e74c 0802 e874 0802 0030 0000      ...L...t...0...
 802fc38:	0230 0101 0000 0001 0000 0000 0000 0001     0...............
 802fc48:	0102 0101                                   ....

0802fc4c <group_ptrs>:
 802fc4c:	4400 4000 4800 4000 4c00 4000 5000 4000     .D.@.H.@.L.@.P.@

0802fc5c <ADC_MEASUREMENT_ADV_G2_CH_G2_res_config>:
 802fc5c:	0000 8000                                   ....

0802fc60 <ADC_MEASUREMENT_ADV_G0_queue_handle>:
	...
 802fc74:	fe88 0802 0001 0000                         ........

0802fc7c <ADC_MEASUREMENT_ADV_G0_CH_G3_handle>:
 802fc7c:	fe78 0802 fde8 0802 0003 0000               x...........

0802fc88 <ADC_MEASUREMENT_ADV_G2_queue_handle>:
	...
 802fc9c:	fcb0 0802 0001 0001                         ........

0802fca4 <ADC_MEASUREMENT_ADV_G1_CH_G1_handle>:
 802fca4:	fcc0 0802 fcbc 0802 0301 0000               ............

0802fcb0 <ADC_MEASUREMENT_ADV_G2_queue_config>:
 802fcb0:	000c 0000 4800 0000 0004 0000               .....H......

0802fcbc <ADC_MEASUREMENT_ADV_G1_CH_G1_res_config>:
 802fcbc:	0000 8000                                   ....

0802fcc0 <ADC_MEASUREMENT_ADV_G1_CH_G1_ch_config>:
 802fcc0:	0400 0023 0000 0000 0000 0000 ff01 0000     ..#.............

0802fcd0 <ADC_MEASUREMENT_ADV_G0_CH_G2_handle>:
 802fcd0:	fdb8 0802 fd30 0802 0002 0000               ....0.......

0802fcdc <ADC_MEASUREMENT_ADV_G0_CH_G1_handle>:
 802fcdc:	fd10 0802 fdf0 0802 0001 0000               ............

0802fce8 <ADC_MEASUREMENT_ADV_G2_CH_G2_handle>:
 802fce8:	fd60 0802 fc5c 0802 0302 0000               `...\.......

0802fcf4 <ADC_MEASUREMENT_SCAN>:
 802fcf4:	95f4 1ffe 0000 0000 0000 0000 fe98 0802     ................
 802fd04:	95fc 1ffe 0001 0102 0101 0000               ............

0802fd10 <ADC_MEASUREMENT_ADV_G0_CH_G1_ch_config>:
 802fd10:	0003 002f 0000 0000 0000 0000 0201 0000     ../.............

0802fd20 <ADC_MEASUREMENT_SCAN_BGT24_PTAT_handle>:
 802fd20:	fd8c 0802 fd38 0802 0602 0000               ....8.......

0802fd2c <ADC_MEASUREMENT_ADV_G2_CH_G2_queue_entry_0>:
 802fd2c:	00a3 0000                                   ....

0802fd30 <ADC_MEASUREMENT_ADV_G0_CH_G2_res_config>:
 802fd30:	0000 0000                                   ....

0802fd34 <ADC_MEASUREMENT_ADV_G0_CH_G0_res_config>:
 802fd34:	0000 8000                                   ....

0802fd38 <ADC_MEASUREMENT_SCAN_BGT24_PTAT_res_config>:
 802fd38:	0000 0000                                   ....

0802fd3c <ADC_MEASUREMENT_ADV_G1_queue_config>:
 802fd3c:	000c 0000 4800 0000 0004 0000               .....H......

0802fd48 <ADC_MEASUREMENT_ADV_G0_CH_G0_handle>:
 802fd48:	fdd8 0802 fd34 0802 0000 0000               ....4.......

0802fd54 <ADC_MEASUREMENT_ADV_G3_CH_G3_handle>:
 802fd54:	fe64 0802 fdec 0802 0103 0000               d...........

0802fd60 <ADC_MEASUREMENT_ADV_G2_CH_G2_ch_config>:
 802fd60:	0001 0020 0000 0000 0000 0000 ff01 0000     .. .............

0802fd70 <ADC_MEASUREMENT_ADV_G1_queue_handle>:
	...
 802fd84:	fd3c 0802 0001 0000                         <.......

0802fd8c <ADC_MEASUREMENT_SCAN_BGT24_PTAT_ch_config>:
 802fd8c:	0000 0022 0000 0000 0000 0000 ff01 0000     ..".............

0802fd9c <ADC_MEASUREMENT_ADV_G3_queue_handle>:
	...
 802fdb0:	fdc8 0802 0001 0000                         ........

0802fdb8 <ADC_MEASUREMENT_ADV_G0_CH_G2_ch_config>:
 802fdb8:	0003 0021 0000 0000 0000 0000 ff01 0000     ..!.............

0802fdc8 <ADC_MEASUREMENT_ADV_G3_queue_config>:
 802fdc8:	000c 0000 4800 0000 0004 0000               .....H......

0802fdd4 <ADC_MEASUREMENT_ADV_G3_CH_G3_queue_entry_0>:
 802fdd4:	00a1 0000                                   ....

0802fdd8 <ADC_MEASUREMENT_ADV_G0_CH_G0_ch_config>:
 802fdd8:	0400 002f 0000 0000 0000 0000 0601 0000     ../.............

0802fde8 <ADC_MEASUREMENT_ADV_G0_CH_G3_res_config>:
 802fde8:	0000 0000                                   ....

0802fdec <ADC_MEASUREMENT_ADV_G3_CH_G3_res_config>:
 802fdec:	0000 8000                                   ....

0802fdf0 <ADC_MEASUREMENT_ADV_G0_CH_G1_res_config>:
 802fdf0:	0000 0000                                   ....

0802fdf4 <ADC_MEASUREMENT_ADV_G0>:
 802fdf4:	95d0 1ffe 95f8 1ffe 7f9d 0802 fc60 0802     ............`...
 802fe04:	95e0 1ffe 0e03 0100 0104 0001               ............

0802fe10 <ADC_MEASUREMENT_ADV_G1>:
 802fe10:	95c8 1ffe 95f0 1ffe 7fad 0802 fd70 0802     ............p...
 802fe20:	95e8 1ffe 0003 0101 0101 0001               ............

0802fe2c <ADC_MEASUREMENT_ADV_G2>:
 802fe2c:	95cc 1ffe 95e4 1ffe 7fbd 0802 fc88 0802     ................
 802fe3c:	95e9 1ffe 0003 0102 0101 0000               ............

0802fe48 <ADC_MEASUREMENT_ADV_G3>:
 802fe48:	95c4 1ffe 95ec 1ffe 7fcd 0802 fd9c 0802     ................
 802fe58:	95ea 1ffe 0003 0103 0101 0000               ............

0802fe64 <ADC_MEASUREMENT_ADV_G3_CH_G3_ch_config>:
 802fe64:	0000 0024 0000 0000 0000 0000 ff01 0000     ..$.............

0802fe74 <ADC_MEASUREMENT_ADV_G0_CH_G0_queue_entry_0>:
 802fe74:	00a0 0000                                   ....

0802fe78 <ADC_MEASUREMENT_ADV_G0_CH_G3_ch_config>:
 802fe78:	0003 0029 0000 0000 0000 0000 0201 0000     ..).............

0802fe88 <ADC_MEASUREMENT_ADV_G0_queue_config>:
 802fe88:	000c 0000 4800 0000 0004 0000               .....H......

0802fe94 <ADC_MEASUREMENT_ADV_G1_CH_G1_queue_entry_0>:
 802fe94:	00a3 0000                                   ....

0802fe98 <ADC_MEASUREMENT_SCAN_scan_handle>:
	...
 802feac:	febc 0802 0001 0000 0040 0000 0000 0000     ........@.......

0802febc <ADC_MEASUREMENT_SCAN_scan_config>:
 802febc:	000c 0000 4000 0000 0024 0000               .....@..$...

0802fec8 <I2C_MASTER_EEPROM_sda_pin_config>:
 802fec8:	00d0 0000 0001 0000 0000 0000               ............

0802fed4 <I2C_MASTER_EEPROM_scl_pin_config>:
 802fed4:	00d0 0000 0001 0000 0000 0000               ............

0802fee0 <I2C_MASTER_EEPROM_config>:
 802fee0:	ff0c 0802 91c1 0802 91a1 0802 9181 0802     ................
	...
 802ff04:	0202 0000 ffff 0000                         ........

0802ff0c <I2C_MASTER_EEPROM_channel_config>:
 802ff0c:	1a80 0006 0000 0000 6361 736f 0066 0000     ........acosf...
 802ff1c:	6361 736f 6668 0000 6f63 6873 0066 0000     acoshf..coshf...
 802ff2c:	6f70 6677 0000 0000 7173 7472 0066 0000     powf....sqrtf...

0802ff3c <halF>:
 802ff3c:	0000 3f00 0000 bf00                         ...?....

0802ff44 <ln2LO>:
 802ff44:	f7d1 3717 f7d1 b717                         ...7....

0802ff4c <ln2HI>:
 802ff4c:	7180 3f31 7180 bf31                         .q1?.q1.

0802ff54 <dp_h>:
 802ff54:	0000 0000 c000 3f15                         .......?

0802ff5c <dp_l>:
 802ff5c:	0000 0000 cfdc 35d1                         .......5

0802ff64 <bp>:
 802ff64:	0000 3f80 0000 3fc0 0000 0000               ...?...?....

0802ff70 <TWO52>:
 802ff70:	0000 0000 0000 4330 0000 0000 0000 c330     ......0C......0.
 802ff80:	0043 0000                                   C...
