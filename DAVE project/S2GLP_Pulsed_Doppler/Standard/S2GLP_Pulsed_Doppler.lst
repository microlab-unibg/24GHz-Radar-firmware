
S2GLP_Pulsed_Doppler.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00000294  08000000  0c000000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00011b5c  08020000  0c020000  00010000  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .ARM.exidx    00000008  08031b5c  0c031b5c  00021b5c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 Stack         00001000  1ffe8000  1ffe8000  00030000  2**0
                  ALLOC
  4 .data         000006d0  1ffe9000  0c031b64  00029000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .bss          00007064  1ffe96d0  0c032234  000296d0  2**2
                  ALLOC
  6 USB_RAM       00000e00  20000000  20000000  00030000  2**2
                  ALLOC
  7 .no_init      00000014  2003ffc0  2003ffc0  0002ffc0  2**2
                  ALLOC
  8 .debug_aranges 00001d58  00000000  00000000  000296d0  2**3
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_info   0007a204  00000000  00000000  0002b428  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 0000d43f  00000000  00000000  000a562c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   0001acc3  00000000  00000000  000b2a6b  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_frame  00005a48  00000000  00000000  000cd730  2**2
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    00018230  00000000  00000000  000d3178  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    0001f52b  00000000  00000000  000eb3a8  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_ranges 00005568  00000000  00000000  0010a8d3  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .build_attributes 00001b54  00000000  00000000  0010fe3b  2**0
                  CONTENTS, READONLY

Disassembly of section .text:

08020000 <ds_get_board_variant>:
	return def_settings_changed;
}

uint32_t ds_get_board_variant( void )
{
	return detected_board_variant;
 8020000:	4b01      	ldr	r3, [pc, #4]	; (8020008 <ds_get_board_variant+0x8>)
}
 8020002:	6818      	ldr	r0, [r3, #0]
 8020004:	4770      	bx	lr
 8020006:	bf00      	nop
 8020008:	1ffe96d4 	.word	0x1ffe96d4

0802000c <ds_store_algo_result_ptr>:

//============================================================================

void ds_store_algo_result_ptr(algo_result_t *p_result)
{
	p_ds_algo_results = p_result;
 802000c:	4b01      	ldr	r3, [pc, #4]	; (8020014 <ds_store_algo_result_ptr+0x8>)
 802000e:	6018      	str	r0, [r3, #0]
 8020010:	4770      	bx	lr
 8020012:	bf00      	nop
 8020014:	1ffe96d0 	.word	0x1ffe96d0

08020018 <ds_algo_get_settings>:
//============================================================================

algo_settings_t *ds_algo_get_settings(void)
{
  return &ds_algo_settings;
}
 8020018:	4800      	ldr	r0, [pc, #0]	; (802001c <ds_algo_get_settings+0x4>)
 802001a:	4770      	bx	lr
 802001c:	1ffe96dc 	.word	0x1ffe96dc

08020020 <ds_algo_check_settings>:
 */
uint32_t ds_algo_check_settings(algo_settings_t *ptr)
{
  uint32_t retval = 0;

  if (!((ptr->speed_detection_threshold >= BSP_MIN_SPEED_DETECTION_THRESHOLD) && (ptr->speed_detection_threshold <= BSP_MAX_SPEED_DETECTION_THRESHOLD)))
 8020020:	edd0 7a02 	vldr	s15, [r0, #8]
 8020024:	eeb7 7a00 	vmov.f32	s14, #112	; 0x70
 8020028:	eef4 7ac7 	vcmpe.f32	s15, s14
 802002c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr

/* if staged Algo settings are with-in range 0 is return, otherwise non-zero
 * the return value could be interpreted as bit field to identify the failure, if needed!
 */
uint32_t ds_algo_check_settings(algo_settings_t *ptr)
{
 8020030:	4603      	mov	r3, r0
  uint32_t retval = 0;

  if (!((ptr->speed_detection_threshold >= BSP_MIN_SPEED_DETECTION_THRESHOLD) && (ptr->speed_detection_threshold <= BSP_MAX_SPEED_DETECTION_THRESHOLD)))
 8020032:	db33      	blt.n	802009c <ds_algo_check_settings+0x7c>
 8020034:	ed9f 7a1b 	vldr	s14, [pc, #108]	; 80200a4 <ds_algo_check_settings+0x84>
 8020038:	eef4 7ac7 	vcmpe.f32	s15, s14
 802003c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8020040:	bf95      	itete	ls
 8020042:	2202      	movls	r2, #2
 8020044:	2203      	movhi	r2, #3
 8020046:	2000      	movls	r0, #0
 8020048:	2001      	movhi	r0, #1
  {
    retval += 1;
  }
  if (!(ptr->max_speed_kmph > ptr->min_speed_kmph) && (ptr->max_speed_kmph <= BSP_MAX_SPEED_KMPH))
 802004a:	edd3 7a04 	vldr	s15, [r3, #16]
 802004e:	ed93 7a03 	vldr	s14, [r3, #12]
 8020052:	eef4 7ac7 	vcmpe.f32	s15, s14
 8020056:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802005a:	dc07      	bgt.n	802006c <ds_algo_check_settings+0x4c>
 802005c:	eddf 6a12 	vldr	s13, [pc, #72]	; 80200a8 <ds_algo_check_settings+0x88>
  {
    retval += 2;
 8020060:	eef4 7a66 	vcmp.f32	s15, s13
 8020064:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8020068:	bf98      	it	ls
 802006a:	4610      	movls	r0, r2
  }
  if (ptr->min_speed_kmph > ptr->max_speed_kmph)
 802006c:	eef4 7ac7 	vcmpe.f32	s15, s14
  {
    retval += 4;
  }
  if (!(ptr->motion_detection_threshold >= BSP_MIN_MOTION_DETECTION_THRESHOLD) && (ptr->motion_detection_threshold <= BSP_MAX_MOTION_DETECTION_THRESHOLD))
 8020070:	edd3 7a06 	vldr	s15, [r3, #24]
 8020074:	eeb7 7a00 	vmov.f32	s14, #112	; 0x70
  }
  if (!(ptr->max_speed_kmph > ptr->min_speed_kmph) && (ptr->max_speed_kmph <= BSP_MAX_SPEED_KMPH))
  {
    retval += 2;
  }
  if (ptr->min_speed_kmph > ptr->max_speed_kmph)
 8020078:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  {
    retval += 4;
  }
  if (!(ptr->motion_detection_threshold >= BSP_MIN_MOTION_DETECTION_THRESHOLD) && (ptr->motion_detection_threshold <= BSP_MAX_MOTION_DETECTION_THRESHOLD))
 802007c:	eef4 7ac7 	vcmpe.f32	s15, s14
  {
    retval += 2;
  }
  if (ptr->min_speed_kmph > ptr->max_speed_kmph)
  {
    retval += 4;
 8020080:	bf48      	it	mi
 8020082:	3004      	addmi	r0, #4
  }
  if (!(ptr->motion_detection_threshold >= BSP_MIN_MOTION_DETECTION_THRESHOLD) && (ptr->motion_detection_threshold <= BSP_MAX_MOTION_DETECTION_THRESHOLD))
 8020084:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8020088:	da07      	bge.n	802009a <ds_algo_check_settings+0x7a>
 802008a:	ed9f 7a06 	vldr	s14, [pc, #24]	; 80200a4 <ds_algo_check_settings+0x84>
 802008e:	eef4 7ac7 	vcmpe.f32	s15, s14
 8020092:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  {
	 retval += 8;
 8020096:	bf98      	it	ls
 8020098:	3008      	addls	r0, #8
  }
  
  return retval;
}
 802009a:	4770      	bx	lr
 802009c:	2203      	movs	r2, #3
{
  uint32_t retval = 0;

  if (!((ptr->speed_detection_threshold >= BSP_MIN_SPEED_DETECTION_THRESHOLD) && (ptr->speed_detection_threshold <= BSP_MAX_SPEED_DETECTION_THRESHOLD)))
  {
    retval += 1;
 802009e:	2001      	movs	r0, #1
 80200a0:	e7d3      	b.n	802004a <ds_algo_check_settings+0x2a>
 80200a2:	bf00      	nop
 80200a4:	44fa0000 	.word	0x44fa0000
 80200a8:	44870000 	.word	0x44870000

080200ac <ds_dev_check_settings>:

/* if staged Algo settings are with-in range 0 is return, otherwise non-zero
 * the return value could be interpreted as bit field to identify the failure, if needed!
 */
uint32_t ds_dev_check_settings(device_settings_t *ptr)
{
 80200ac:	b570      	push	{r4, r5, r6, lr}

  if (!((ptr->num_sample_skip_count >= BSP_MIN_SAMPLE_SKIP_COUNT) && (ptr->num_sample_skip_count <= BSP_MAX_SAMPLE_SKIP_COUNT)))
  {
    retval += 1;
  }
  if (!(ptr->adc_sampling_freq_Hz >= BSP_MIN_DOPPLER_SAMPLING_FREQ_HZ && (ptr->adc_sampling_freq_Hz <= BSP_MAX_DOPPLER_SAMPLING_FREQ_HZ)))
 80200ae:	6943      	ldr	r3, [r0, #20]
 */
uint32_t ds_dev_check_settings(device_settings_t *ptr)
{
  uint32_t retval = 0;

  if (!((ptr->num_sample_skip_count >= BSP_MIN_SAMPLE_SKIP_COUNT) && (ptr->num_sample_skip_count <= BSP_MAX_SAMPLE_SKIP_COUNT)))
 80200b0:	6ac4      	ldr	r4, [r0, #44]	; 0x2c

/* if staged Algo settings are with-in range 0 is return, otherwise non-zero
 * the return value could be interpreted as bit field to identify the failure, if needed!
 */
uint32_t ds_dev_check_settings(device_settings_t *ptr)
{
 80200b2:	4605      	mov	r5, r0
  uint32_t retval = 0;

  if (!((ptr->num_sample_skip_count >= BSP_MIN_SAMPLE_SKIP_COUNT) && (ptr->num_sample_skip_count <= BSP_MAX_SAMPLE_SKIP_COUNT)))
 80200b4:	f5b4 7f7a 	cmp.w	r4, #1000	; 0x3e8
  {
    retval += 1;
  }
  if (!(ptr->adc_sampling_freq_Hz >= BSP_MIN_DOPPLER_SAMPLING_FREQ_HZ && (ptr->adc_sampling_freq_Hz <= BSP_MAX_DOPPLER_SAMPLING_FREQ_HZ)))
 80200b8:	f5a3 737a 	sub.w	r3, r3, #1000	; 0x3e8
 */
uint32_t ds_dev_check_settings(device_settings_t *ptr)
{
  uint32_t retval = 0;

  if (!((ptr->num_sample_skip_count >= BSP_MIN_SAMPLE_SKIP_COUNT) && (ptr->num_sample_skip_count <= BSP_MAX_SAMPLE_SKIP_COUNT)))
 80200bc:	bf8c      	ite	hi
 80200be:	2401      	movhi	r4, #1
 80200c0:	2400      	movls	r4, #0
  {
    retval += 1;
  }
  if (!(ptr->adc_sampling_freq_Hz >= BSP_MIN_DOPPLER_SAMPLING_FREQ_HZ && (ptr->adc_sampling_freq_Hz <= BSP_MAX_DOPPLER_SAMPLING_FREQ_HZ)))
 80200c2:	f5b3 6f7a 	cmp.w	r3, #4000	; 0xfa0
  {
    retval += 2;
 80200c6:	bf88      	it	hi
 80200c8:	3402      	addhi	r4, #2
  }
  if (!(ptr->frame_period_usec >= bsp_calc_min_frame_interval_usec(ptr)) && (ptr->frame_period_usec*1000 <= BSP_MAX_FRAME_PERIOD_MSEC))
 80200ca:	6a2e      	ldr	r6, [r5, #32]
 80200cc:	f009 fffc 	bl	802a0c8 <bsp_calc_min_frame_interval_usec>
 80200d0:	4286      	cmp	r6, r0
 80200d2:	d208      	bcs.n	80200e6 <ds_dev_check_settings+0x3a>
 80200d4:	6a2a      	ldr	r2, [r5, #32]
 80200d6:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80200da:	fb03 f302 	mul.w	r3, r3, r2
 80200de:	f5b3 6ffa 	cmp.w	r3, #2000	; 0x7d0
  {
    retval += 4;
 80200e2:	bf98      	it	ls
 80200e4:	3404      	addls	r4, #4
  }
  if (!(ptr->num_samples_per_chirp >= BSP_MIN_NUM_SAMPLES_PER_CHIRP) && (ptr->num_samples_per_chirp <= BSP_MAX_NUM_SAMPLES_PER_CHIRP))
 80200e6:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 80200e8:	2b1f      	cmp	r3, #31
  {
	 retval += 8;
  }
  if (ptr->adc_resolution != 12)
 80200ea:	7e2b      	ldrb	r3, [r5, #24]
  {
    retval += 4;
  }
  if (!(ptr->num_samples_per_chirp >= BSP_MIN_NUM_SAMPLES_PER_CHIRP) && (ptr->num_samples_per_chirp <= BSP_MAX_NUM_SAMPLES_PER_CHIRP))
  {
	 retval += 8;
 80200ec:	bf98      	it	ls
 80200ee:	3408      	addls	r4, #8
  }
  if (ptr->adc_resolution != 12)
 80200f0:	2b0c      	cmp	r3, #12
  {
	  retval += 16;
 80200f2:	bf18      	it	ne
 80200f4:	3410      	addne	r4, #16
  }
  return retval;
}
 80200f6:	4620      	mov	r0, r4
 80200f8:	bd70      	pop	{r4, r5, r6, pc}
 80200fa:	bf00      	nop

080200fc <ds_device_get_settings>:
//============================================================================

device_settings_t *ds_device_get_settings(void)
{
  return &ds_device_settings;
}
 80200fc:	4800      	ldr	r0, [pc, #0]	; (8020100 <ds_device_get_settings+0x4>)
 80200fe:	4770      	bx	lr
 8020100:	1ffe973c 	.word	0x1ffe973c

08020104 <ds_device_get_shadow_settings>:
//============================================================================

device_settings_t *ds_device_get_shadow_settings(void)
{
  return &ds_shadow_device_settings;
}
 8020104:	4800      	ldr	r0, [pc, #0]	; (8020108 <ds_device_get_shadow_settings+0x4>)
 8020106:	4770      	bx	lr
 8020108:	1ffe96fc 	.word	0x1ffe96fc

0802010c <ds_is_device_settings_updated>:

//============================================================================

/* handling for staged setting */
uint32_t ds_is_device_settings_updated(void)
{
 802010c:	b508      	push	{r3, lr}
  int32_t retval = 0;
  
  /* if both structs are identical, retval is 0, otherwise != 0 */
  retval = memcmp(&ds_shadow_device_settings,&ds_device_settings, sizeof(ds_shadow_device_settings));
 802010e:	4904      	ldr	r1, [pc, #16]	; (8020120 <ds_is_device_settings_updated+0x14>)
 8020110:	4804      	ldr	r0, [pc, #16]	; (8020124 <ds_is_device_settings_updated+0x18>)
 8020112:	2240      	movs	r2, #64	; 0x40
 8020114:	f00d fa0c 	bl	802d530 <memcmp>
  
  // result of memcmp could be negative!
  return (retval == 0) ? 0U : 1U;
}
 8020118:	3000      	adds	r0, #0
 802011a:	bf18      	it	ne
 802011c:	2001      	movne	r0, #1
 802011e:	bd08      	pop	{r3, pc}
 8020120:	1ffe973c 	.word	0x1ffe973c
 8020124:	1ffe96fc 	.word	0x1ffe96fc

08020128 <ds_device_settings_copy_to_shadow>:

//============================================================================

void ds_device_settings_copy_to_shadow(void)
{
 8020128:	b430      	push	{r4, r5}
  memcpy(&ds_shadow_device_settings, &ds_device_settings, sizeof(ds_shadow_device_settings));
 802012a:	4d07      	ldr	r5, [pc, #28]	; (8020148 <ds_device_settings_copy_to_shadow+0x20>)
 802012c:	4c07      	ldr	r4, [pc, #28]	; (802014c <ds_device_settings_copy_to_shadow+0x24>)
 802012e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8020130:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8020132:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8020134:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8020136:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8020138:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 802013a:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 802013e:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
}
 8020142:	bc30      	pop	{r4, r5}
 8020144:	4770      	bx	lr
 8020146:	bf00      	nop
 8020148:	1ffe973c 	.word	0x1ffe973c
 802014c:	1ffe96fc 	.word	0x1ffe96fc

08020150 <ds_device_settings_revert_from_shadow>:

//============================================================================

void ds_device_settings_revert_from_shadow(void)
{
 8020150:	b430      	push	{r4, r5}
  memcpy(&ds_device_settings, &ds_shadow_device_settings,  sizeof(ds_shadow_device_settings));
 8020152:	4d07      	ldr	r5, [pc, #28]	; (8020170 <ds_device_settings_revert_from_shadow+0x20>)
 8020154:	4c07      	ldr	r4, [pc, #28]	; (8020174 <ds_device_settings_revert_from_shadow+0x24>)
 8020156:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8020158:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 802015a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 802015c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 802015e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8020160:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8020162:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 8020166:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
}
 802016a:	bc30      	pop	{r4, r5}
 802016c:	4770      	bx	lr
 802016e:	bf00      	nop
 8020170:	1ffe96fc 	.word	0x1ffe96fc
 8020174:	1ffe973c 	.word	0x1ffe973c

08020178 <ds_init>:

static char rf_board_id_1[] = RF_BOARD_ID;
static char rf_board_id_2[] = "RBBPDV10";  // Check for previous compatible board-id

uint32_t ds_init(void)
{
 8020178:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
#ifdef DS_USE_EEPROM
  RF_SHIELD_STATUS_t shield_status = RF_SHIELD_BOARD_NOT_CONNECTED;
  EEPROM_STATUS_t ret_status = EEPROM_STATUS_FAILURE;

  /* Read RF board ID, check if a valid board ID is written in EEPROM */
  shield_status = ds_eeprom_read_board_id(rf_board_id_1, sizeof(rf_board_id_1));
 802017c:	48bb      	ldr	r0, [pc, #748]	; (802046c <ds_init+0x2f4>)

static char rf_board_id_1[] = RF_BOARD_ID;
static char rf_board_id_2[] = "RBBPDV10";  // Check for previous compatible board-id

uint32_t ds_init(void)
{
 802017e:	b083      	sub	sp, #12
#ifdef DS_USE_EEPROM
  RF_SHIELD_STATUS_t shield_status = RF_SHIELD_BOARD_NOT_CONNECTED;
  EEPROM_STATUS_t ret_status = EEPROM_STATUS_FAILURE;

  /* Read RF board ID, check if a valid board ID is written in EEPROM */
  shield_status = ds_eeprom_read_board_id(rf_board_id_1, sizeof(rf_board_id_1));
 8020180:	2109      	movs	r1, #9
 8020182:	f000 faad 	bl	80206e0 <ds_eeprom_read_board_id>
  if (shield_status == RF_SHIELD_BOARD_UNSUPPORTED)
 8020186:	2803      	cmp	r0, #3
#ifdef DS_USE_EEPROM
  RF_SHIELD_STATUS_t shield_status = RF_SHIELD_BOARD_NOT_CONNECTED;
  EEPROM_STATUS_t ret_status = EEPROM_STATUS_FAILURE;

  /* Read RF board ID, check if a valid board ID is written in EEPROM */
  shield_status = ds_eeprom_read_board_id(rf_board_id_1, sizeof(rf_board_id_1));
 8020188:	4604      	mov	r4, r0
  if (shield_status == RF_SHIELD_BOARD_UNSUPPORTED)
 802018a:	d01a      	beq.n	80201c2 <ds_init+0x4a>
	  shield_status = ds_eeprom_read_board_id(rf_board_id_2, sizeof(rf_board_id_2));
	  if (shield_status == RF_SHIELD_BOARD_SUPPORTED)
		  board_variant = 1;
  }

  if (shield_status != RF_SHIELD_BOARD_SUPPORTED)
 802018c:	2802      	cmp	r0, #2
 802018e:	d03b      	beq.n	8020208 <ds_init+0x90>
  {
	/* Unsupported RF board !!!!!! */
#if !defined(BUILD_FOR_ARDUINO)
	bsp_led_green_off();
 8020190:	f008 fdce 	bl	8028d30 <bsp_led_green_off>
    bsp_led_blue_off();
 8020194:	f008 fde0 	bl	8028d58 <bsp_led_blue_off>
	bsp_led_red_off();
 8020198:	f008 fdf2 	bl	8028d80 <bsp_led_red_off>

	/*  TODO: Remove before the release!! */
	if (shield_status == RF_SHIELD_BOARD_NOT_PROGRAMMED)
 802019c:	2c04      	cmp	r4, #4
 802019e:	f000 8189 	beq.w	80204b4 <ds_init+0x33c>
      else
      {
        /* Invalid RF shield board:
    	   1- RF shield is not programmed or it contains invalid data
    	   2- Or RF shield board is not connected */
    	TIMER_SetTimeInterval(&TIMER_ERROR_TOGGLE, 100 * 1000U * 100U);
 80201a2:	49b3      	ldr	r1, [pc, #716]	; (8020470 <ds_init+0x2f8>)
 80201a4:	48b3      	ldr	r0, [pc, #716]	; (8020474 <ds_init+0x2fc>)
 80201a6:	f005 fe8f 	bl	8025ec8 <TIMER_SetTimeInterval>
    	bsp_timer_start(&TIMER_ERROR_TOGGLE);
 80201aa:	48b2      	ldr	r0, [pc, #712]	; (8020474 <ds_init+0x2fc>)
 80201ac:	f009 fb56 	bl	802985c <bsp_timer_start>

  	    device_status_set_error(FATAL_ERROR_INVALID_RF_SHIELD);
 80201b0:	f244 1001 	movw	r0, #16641	; 0x4101
 80201b4:	f000 fd0a 	bl	8020bcc <device_status_set_error>
  	    return RF_SHIELD_INVALID;
 80201b8:	f243 0001 	movw	r0, #12289	; 0x3001
  memcpy(&ds_algo_settings, &ds_default_algo_settings, sizeof(algo_settings_t));
  retval += ds_algo_check_settings(&ds_algo_settings);
#endif /* DS_USE_EEPROM */
  
  return retval;
}
 80201bc:	b003      	add	sp, #12
 80201be:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  /* Read RF board ID, check if a valid board ID is written in EEPROM */
  shield_status = ds_eeprom_read_board_id(rf_board_id_1, sizeof(rf_board_id_1));
  if (shield_status == RF_SHIELD_BOARD_UNSUPPORTED)
  {
	  /* Read RF board ID, check if a valid board ID is written in EEPROM */
	  shield_status = ds_eeprom_read_board_id(rf_board_id_2, sizeof(rf_board_id_2));
 80201c2:	48ad      	ldr	r0, [pc, #692]	; (8020478 <ds_init+0x300>)
 80201c4:	2109      	movs	r1, #9
 80201c6:	f000 fa8b 	bl	80206e0 <ds_eeprom_read_board_id>
	  if (shield_status == RF_SHIELD_BOARD_SUPPORTED)
 80201ca:	2802      	cmp	r0, #2
  /* Read RF board ID, check if a valid board ID is written in EEPROM */
  shield_status = ds_eeprom_read_board_id(rf_board_id_1, sizeof(rf_board_id_1));
  if (shield_status == RF_SHIELD_BOARD_UNSUPPORTED)
  {
	  /* Read RF board ID, check if a valid board ID is written in EEPROM */
	  shield_status = ds_eeprom_read_board_id(rf_board_id_2, sizeof(rf_board_id_2));
 80201cc:	4604      	mov	r4, r0
	  if (shield_status == RF_SHIELD_BOARD_SUPPORTED)
 80201ce:	f000 8187 	beq.w	80204e0 <ds_init+0x368>

  if (shield_status != RF_SHIELD_BOARD_SUPPORTED)
  {
	/* Unsupported RF board !!!!!! */
#if !defined(BUILD_FOR_ARDUINO)
	bsp_led_green_off();
 80201d2:	f008 fdad 	bl	8028d30 <bsp_led_green_off>
    bsp_led_blue_off();
 80201d6:	f008 fdbf 	bl	8028d58 <bsp_led_blue_off>
	bsp_led_red_off();
 80201da:	f008 fdd1 	bl	8028d80 <bsp_led_red_off>

	/*  TODO: Remove before the release!! */
	if (shield_status == RF_SHIELD_BOARD_NOT_PROGRAMMED)
 80201de:	2c04      	cmp	r4, #4
 80201e0:	f000 8168 	beq.w	80204b4 <ds_init+0x33c>
			bsp_timer_start(&TIMER_ERROR_TOGGLE);
	    	device_status_set_error(FATAL_ERROR_BOARD_NOT_PROGRAMMED);
			return RF_SHIELD_NOT_PROGRAMMED;
		}
	}
    else if (shield_status == RF_SHIELD_BOARD_UNSUPPORTED)
 80201e4:	2c03      	cmp	r4, #3
 80201e6:	d1dc      	bne.n	80201a2 <ds_init+0x2a>
      {
        /* RF shield board is not compatible and is not supported in the current Firmware.
    	   Shield programmed with the wrong ID, For example RBBxxxxxx */

		TIMER_SetTimeInterval(&TIMER_ERROR_TOGGLE, 400 * 1000U * 100U);
 80201e8:	49a4      	ldr	r1, [pc, #656]	; (802047c <ds_init+0x304>)
 80201ea:	48a2      	ldr	r0, [pc, #648]	; (8020474 <ds_init+0x2fc>)
 80201ec:	f005 fe6c 	bl	8025ec8 <TIMER_SetTimeInterval>
		bsp_timer_start(&TIMER_ERROR_TOGGLE);
 80201f0:	48a0      	ldr	r0, [pc, #640]	; (8020474 <ds_init+0x2fc>)
 80201f2:	f009 fb33 	bl	802985c <bsp_timer_start>
    	device_status_set_error(FATAL_ERROR_BOARD_NOT_SUPPORTED);
 80201f6:	f44f 4082 	mov.w	r0, #16640	; 0x4100
 80201fa:	f000 fce7 	bl	8020bcc <device_status_set_error>
    	return RF_SHIELD_UNSUPPORTED;
 80201fe:	f44f 5040 	mov.w	r0, #12288	; 0x3000
  memcpy(&ds_algo_settings, &ds_default_algo_settings, sizeof(algo_settings_t));
  retval += ds_algo_check_settings(&ds_algo_settings);
#endif /* DS_USE_EEPROM */
  
  return retval;
}
 8020202:	b003      	add	sp, #12
 8020204:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

uint32_t ds_init(void)
{
  /* this function could be used to pre-init the settings store, e.g. with persistent value, that are stored in some persistent memory region */
  uint32_t retval = 0;
  uint32_t board_variant = 2;
 8020208:	2702      	movs	r7, #2
//============================================================================

uint32_t calc_settings_crc(void *p_settings, uint32_t struct_size)
{
	uint32_t crc32 = 0;
	CRC_SW_CalculateCRC(&CRC_SW_EEPROM, p_settings, struct_size);
 802020a:	499d      	ldr	r1, [pc, #628]	; (8020480 <ds_init+0x308>)
 802020c:	489d      	ldr	r0, [pc, #628]	; (8020484 <ds_init+0x30c>)
 802020e:	2240      	movs	r2, #64	; 0x40
 8020210:	f006 fb38 	bl	8026884 <CRC_SW_CalculateCRC>
	crc32 = CRC_SW_GetCRCResult(&CRC_SW_EEPROM);
 8020214:	489b      	ldr	r0, [pc, #620]	; (8020484 <ds_init+0x30c>)
 8020216:	f006 fb77 	bl	8026908 <CRC_SW_GetCRCResult>
//============================================================================

uint32_t calc_settings_crc(void *p_settings, uint32_t struct_size)
{
	uint32_t crc32 = 0;
	CRC_SW_CalculateCRC(&CRC_SW_EEPROM, p_settings, struct_size);
 802021a:	499b      	ldr	r1, [pc, #620]	; (8020488 <ds_init+0x310>)
 802021c:	221c      	movs	r2, #28
	crc32 = CRC_SW_GetCRCResult(&CRC_SW_EEPROM);
 802021e:	4604      	mov	r4, r0
//============================================================================

uint32_t calc_settings_crc(void *p_settings, uint32_t struct_size)
{
	uint32_t crc32 = 0;
	CRC_SW_CalculateCRC(&CRC_SW_EEPROM, p_settings, struct_size);
 8020220:	4898      	ldr	r0, [pc, #608]	; (8020484 <ds_init+0x30c>)
 8020222:	f006 fb2f 	bl	8026884 <CRC_SW_CalculateCRC>
	crc32 = CRC_SW_GetCRCResult(&CRC_SW_EEPROM);
 8020226:	4897      	ldr	r0, [pc, #604]	; (8020484 <ds_init+0x30c>)
 8020228:	f006 fb6e 	bl	8026908 <CRC_SW_GetCRCResult>
	eep_default_settings_t eep_def_settings;

	def_dev_setting_crc = calc_settings_crc((void *)&ds_default_device_settings, sizeof(ds_default_device_settings));
	def_algo_setting_crc = calc_settings_crc((void *)&ds_default_algo_settings, sizeof(ds_default_algo_settings));

	eep_status = ds_eeprom_read_settings(&eep_def_settings, sizeof(eep_def_settings), DS_EEPROM_ADDRESS_DEFAULT_SETTING);
 802022c:	2102      	movs	r1, #2

uint32_t calc_settings_crc(void *p_settings, uint32_t struct_size)
{
	uint32_t crc32 = 0;
	CRC_SW_CalculateCRC(&CRC_SW_EEPROM, p_settings, struct_size);
	crc32 = CRC_SW_GetCRCResult(&CRC_SW_EEPROM);
 802022e:	4605      	mov	r5, r0
	eep_default_settings_t eep_def_settings;

	def_dev_setting_crc = calc_settings_crc((void *)&ds_default_device_settings, sizeof(ds_default_device_settings));
	def_algo_setting_crc = calc_settings_crc((void *)&ds_default_algo_settings, sizeof(ds_default_algo_settings));

	eep_status = ds_eeprom_read_settings(&eep_def_settings, sizeof(eep_def_settings), DS_EEPROM_ADDRESS_DEFAULT_SETTING);
 8020230:	22e0      	movs	r2, #224	; 0xe0
 8020232:	a801      	add	r0, sp, #4
 8020234:	f000 fa18 	bl	8020668 <ds_eeprom_read_settings>

	if (eep_status == EEPROM_STATUS_SUCCESS)
 8020238:	2801      	cmp	r0, #1
 802023a:	f000 80fe 	beq.w	802043a <ds_init+0x2c2>
			eep_def_settings.def_algo_settings_crc 	= def_algo_setting_crc;
			eep_status = ds_eeprom_write_settings(&eep_def_settings, sizeof(eep_def_settings), DS_EEPROM_ADDRESS_DEFAULT_SETTING);
			retval = 1;
		}
	}
	else if (eep_status == EEPROM_STATUS_CRC_MISMATCH)
 802023e:	2806      	cmp	r0, #6
 8020240:	d024      	beq.n	802028c <ds_init+0x114>
 8020242:	f8df 825c 	ldr.w	r8, [pc, #604]	; 80204a0 <ds_init+0x328>
 8020246:	4e91      	ldr	r6, [pc, #580]	; (802048c <ds_init+0x314>)
	  ds_algo_para_factory_reset();
  }

  /* 2- Valid board ID, Read hardware settings from EEPROM */
  ret_status = EEPROM_STATUS_FAILURE;
  ret_status = ds_eeprom_read_settings(&ds_device_settings, sizeof(device_settings_t), DS_EEPROM_ADDRESS_HW_SETTING);
 8020248:	4c90      	ldr	r4, [pc, #576]	; (802048c <ds_init+0x314>)
 802024a:	2140      	movs	r1, #64	; 0x40
 802024c:	4620      	mov	r0, r4
 802024e:	2220      	movs	r2, #32
 8020250:	f000 fa0a 	bl	8020668 <ds_eeprom_read_settings>

  /* 3- Check if a valid hardware settings are written in EEPROM */
  if ((ret_status != EEPROM_STATUS_SUCCESS) ||
 8020254:	2801      	cmp	r0, #1
 8020256:	d104      	bne.n	8020262 <ds_init+0xea>
 8020258:	4b8d      	ldr	r3, [pc, #564]	; (8020490 <ds_init+0x318>)
 802025a:	6862      	ldr	r2, [r4, #4]
 802025c:	429a      	cmp	r2, r3
 802025e:	f000 8100 	beq.w	8020462 <ds_init+0x2ea>

/* Function to copy default hardware settings into EEPROM */
void ds_hw_para_factory_reset(void)
{
#ifdef DS_USE_EEPROM
	ds_device_settings = ds_default_device_settings;
 8020262:	4c87      	ldr	r4, [pc, #540]	; (8020480 <ds_init+0x308>)
 8020264:	4d89      	ldr	r5, [pc, #548]	; (802048c <ds_init+0x314>)
 8020266:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8020268:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 802026a:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 802026c:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 802026e:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8020270:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8020272:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
 8020276:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}
	if (ds_eeprom_write_settings(&ds_default_device_settings, sizeof(device_settings_t), DS_EEPROM_ADDRESS_HW_SETTING) != EEPROM_STATUS_SUCCESS)
 802027a:	f1a4 0030 	sub.w	r0, r4, #48	; 0x30
 802027e:	2140      	movs	r1, #64	; 0x40
 8020280:	2220      	movs	r2, #32
 8020282:	f000 f9b9 	bl	80205f8 <ds_eeprom_write_settings>
 8020286:	2801      	cmp	r0, #1
 8020288:	d021      	beq.n	80202ce <ds_init+0x156>
 802028a:	e7fe      	b.n	802028a <ds_init+0x112>
		 * that means also that this device has no eep_default_settings_t
		 * so we need to write initial def settings check struct to EEPROM */

		eep_def_settings.def_dev_settings_crc 	= def_dev_setting_crc;
		eep_def_settings.def_algo_settings_crc 	= def_algo_setting_crc;
		eep_status = ds_eeprom_write_settings(&eep_def_settings, sizeof(eep_def_settings), DS_EEPROM_ADDRESS_DEFAULT_SETTING);
 802028c:	a801      	add	r0, sp, #4
 802028e:	2102      	movs	r1, #2
 8020290:	22e0      	movs	r2, #224	; 0xe0
	{
		/* if we are here that means the CRC value of eep_default_settings_t mismatched,
		 * that means also that this device has no eep_default_settings_t
		 * so we need to write initial def settings check struct to EEPROM */

		eep_def_settings.def_dev_settings_crc 	= def_dev_setting_crc;
 8020292:	f88d 4004 	strb.w	r4, [sp, #4]
		eep_def_settings.def_algo_settings_crc 	= def_algo_setting_crc;
 8020296:	f88d 5005 	strb.w	r5, [sp, #5]
		eep_status = ds_eeprom_write_settings(&eep_def_settings, sizeof(eep_def_settings), DS_EEPROM_ADDRESS_DEFAULT_SETTING);
 802029a:	f000 f9ad 	bl	80205f8 <ds_eeprom_write_settings>

/* Function to copy default hardware settings into EEPROM */
void ds_hw_para_factory_reset(void)
{
#ifdef DS_USE_EEPROM
	ds_device_settings = ds_default_device_settings;
 802029e:	4c78      	ldr	r4, [pc, #480]	; (8020480 <ds_init+0x308>)
 80202a0:	4e7a      	ldr	r6, [pc, #488]	; (802048c <ds_init+0x314>)
 80202a2:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80202a4:	4635      	mov	r5, r6
 80202a6:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 80202a8:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80202aa:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 80202ac:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80202ae:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 80202b0:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
 80202b4:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}
	if (ds_eeprom_write_settings(&ds_default_device_settings, sizeof(device_settings_t), DS_EEPROM_ADDRESS_HW_SETTING) != EEPROM_STATUS_SUCCESS)
 80202b8:	f1a4 0030 	sub.w	r0, r4, #48	; 0x30
 80202bc:	2140      	movs	r1, #64	; 0x40
 80202be:	2220      	movs	r2, #32
 80202c0:	f000 f99a 	bl	80205f8 <ds_eeprom_write_settings>
 80202c4:	2801      	cmp	r0, #1
 80202c6:	4686      	mov	lr, r0
 80202c8:	f000 809f 	beq.w	802040a <ds_init+0x292>
 80202cc:	e7fe      	b.n	80202cc <ds_init+0x154>

//============================================================================

void ds_set_device_parameter_changed(void)
{
	device_parameter_changed = 1;
 80202ce:	4b71      	ldr	r3, [pc, #452]	; (8020494 <ds_init+0x31c>)
 80202d0:	6018      	str	r0, [r3, #0]

//============================================================================

void ds_device_settings_copy_to_shadow(void)
{
  memcpy(&ds_shadow_device_settings, &ds_device_settings, sizeof(ds_shadow_device_settings));
 80202d2:	4d6e      	ldr	r5, [pc, #440]	; (802048c <ds_init+0x314>)
 80202d4:	4c70      	ldr	r4, [pc, #448]	; (8020498 <ds_init+0x320>)
  /* 4- Valid hardware settings: Use new settings from EEPROM */
  ds_device_settings_copy_to_shadow();

  /* 5- Check if a valid algorithm settings are written in EEPROM */
  ret_status = EEPROM_STATUS_FAILURE;
  ret_status = ds_eeprom_read_settings(&ds_algo_settings, sizeof(algo_settings_t), DS_EEPROM_ADDRESS_ALGO_SETTING);
 80202d6:	f8df 91c8 	ldr.w	r9, [pc, #456]	; 80204a0 <ds_init+0x328>
	/* 4- Invalid hardware settings : */
    /*    Copy default hardware settings in the EEPROM at this address DS_EEPROM_ADDRESS_HW_SETTING */
	ds_hw_para_factory_reset();
  }

  detected_board_variant = board_variant;
 80202da:	f8df e1d4 	ldr.w	lr, [pc, #468]	; 80204b0 <ds_init+0x338>

//============================================================================

void ds_device_settings_copy_to_shadow(void)
{
  memcpy(&ds_shadow_device_settings, &ds_device_settings, sizeof(ds_shadow_device_settings));
 80202de:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80202e0:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80202e2:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80202e4:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80202e6:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80202e8:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80202ea:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 80202ee:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
  /* 4- Valid hardware settings: Use new settings from EEPROM */
  ds_device_settings_copy_to_shadow();

  /* 5- Check if a valid algorithm settings are written in EEPROM */
  ret_status = EEPROM_STATUS_FAILURE;
  ret_status = ds_eeprom_read_settings(&ds_algo_settings, sizeof(algo_settings_t), DS_EEPROM_ADDRESS_ALGO_SETTING);
 80202f2:	4648      	mov	r0, r9
 80202f4:	211c      	movs	r1, #28
 80202f6:	22a0      	movs	r2, #160	; 0xa0
	/* 4- Invalid hardware settings : */
    /*    Copy default hardware settings in the EEPROM at this address DS_EEPROM_ADDRESS_HW_SETTING */
	ds_hw_para_factory_reset();
  }

  detected_board_variant = board_variant;
 80202f8:	f8ce 7000 	str.w	r7, [lr]
  /* 4- Valid hardware settings: Use new settings from EEPROM */
  ds_device_settings_copy_to_shadow();

  /* 5- Check if a valid algorithm settings are written in EEPROM */
  ret_status = EEPROM_STATUS_FAILURE;
  ret_status = ds_eeprom_read_settings(&ds_algo_settings, sizeof(algo_settings_t), DS_EEPROM_ADDRESS_ALGO_SETTING);
 80202fc:	f000 f9b4 	bl	8020668 <ds_eeprom_read_settings>

  if ((ret_status != EEPROM_STATUS_SUCCESS) ||
 8020300:	2801      	cmp	r0, #1
 8020302:	d104      	bne.n	802030e <ds_init+0x196>
 8020304:	4b65      	ldr	r3, [pc, #404]	; (802049c <ds_init+0x324>)
 8020306:	f8d9 2004 	ldr.w	r2, [r9, #4]
 802030a:	429a      	cmp	r2, r3
 802030c:	d010      	beq.n	8020330 <ds_init+0x1b8>

/* Function to copy default algorithm settings into EEPROM */
void ds_algo_para_factory_reset(void)
{
#ifdef DS_USE_EEPROM
	ds_algo_settings = ds_default_algo_settings;
 802030e:	4c5e      	ldr	r4, [pc, #376]	; (8020488 <ds_init+0x310>)
 8020310:	4d63      	ldr	r5, [pc, #396]	; (80204a0 <ds_init+0x328>)
 8020312:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8020314:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8020316:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
 802031a:	e885 0007 	stmia.w	r5, {r0, r1, r2}
	if (ds_eeprom_write_settings(&ds_default_algo_settings, sizeof(algo_settings_t), DS_EEPROM_ADDRESS_ALGO_SETTING) != EEPROM_STATUS_SUCCESS)
 802031e:	f1a4 0010 	sub.w	r0, r4, #16
 8020322:	211c      	movs	r1, #28
 8020324:	22a0      	movs	r2, #160	; 0xa0
 8020326:	f000 f967 	bl	80205f8 <ds_eeprom_write_settings>
 802032a:	2801      	cmp	r0, #1
 802032c:	d004      	beq.n	8020338 <ds_init+0x1c0>
 802032e:	e7fe      	b.n	802032e <ds_init+0x1b6>
  /* 5- Check if a valid algorithm settings are written in EEPROM */
  ret_status = EEPROM_STATUS_FAILURE;
  ret_status = ds_eeprom_read_settings(&ds_algo_settings, sizeof(algo_settings_t), DS_EEPROM_ADDRESS_ALGO_SETTING);

  if ((ret_status != EEPROM_STATUS_SUCCESS) ||
	  (ds_algo_settings.struct_version != DS_ALGO_SETTINGS_STRUCT_VERSION) ||
 8020330:	f8d9 3000 	ldr.w	r3, [r9]
 8020334:	2b1c      	cmp	r3, #28
 8020336:	d1ea      	bne.n	802030e <ds_init+0x196>
 */
uint32_t ds_algo_check_settings(algo_settings_t *ptr)
{
  uint32_t retval = 0;

  if (!((ptr->speed_detection_threshold >= BSP_MIN_SPEED_DETECTION_THRESHOLD) && (ptr->speed_detection_threshold <= BSP_MAX_SPEED_DETECTION_THRESHOLD)))
 8020338:	edd8 7a02 	vldr	s15, [r8, #8]
 802033c:	eeb7 7a00 	vmov.f32	s14, #112	; 0x70
 8020340:	eef4 7ac7 	vcmpe.f32	s15, s14
 8020344:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8020348:	db5c      	blt.n	8020404 <ds_init+0x28c>
 802034a:	ed9f 7a56 	vldr	s14, [pc, #344]	; 80204a4 <ds_init+0x32c>
 802034e:	eef4 7ac7 	vcmpe.f32	s15, s14
 8020352:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8020356:	bf95      	itete	ls
 8020358:	2302      	movls	r3, #2
 802035a:	2303      	movhi	r3, #3
 802035c:	2400      	movls	r4, #0
 802035e:	2401      	movhi	r4, #1
  {
    retval += 1;
  }
  if (!(ptr->max_speed_kmph > ptr->min_speed_kmph) && (ptr->max_speed_kmph <= BSP_MAX_SPEED_KMPH))
 8020360:	edd8 7a04 	vldr	s15, [r8, #16]
 8020364:	ed98 7a03 	vldr	s14, [r8, #12]
 8020368:	eef4 7ac7 	vcmpe.f32	s15, s14
 802036c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8020370:	dc07      	bgt.n	8020382 <ds_init+0x20a>
 8020372:	eddf 6a4d 	vldr	s13, [pc, #308]	; 80204a8 <ds_init+0x330>
  {
    retval += 2;
 8020376:	eef4 7a66 	vcmp.f32	s15, s13
 802037a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802037e:	bf98      	it	ls
 8020380:	461c      	movls	r4, r3
  }
  if (ptr->min_speed_kmph > ptr->max_speed_kmph)
 8020382:	eef4 7ac7 	vcmpe.f32	s15, s14
  {
    retval += 4;
  }
  if (!(ptr->motion_detection_threshold >= BSP_MIN_MOTION_DETECTION_THRESHOLD) && (ptr->motion_detection_threshold <= BSP_MAX_MOTION_DETECTION_THRESHOLD))
 8020386:	edd8 7a06 	vldr	s15, [r8, #24]
 802038a:	eeb7 7a00 	vmov.f32	s14, #112	; 0x70
  }
  if (!(ptr->max_speed_kmph > ptr->min_speed_kmph) && (ptr->max_speed_kmph <= BSP_MAX_SPEED_KMPH))
  {
    retval += 2;
  }
  if (ptr->min_speed_kmph > ptr->max_speed_kmph)
 802038e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  {
    retval += 4;
  }
  if (!(ptr->motion_detection_threshold >= BSP_MIN_MOTION_DETECTION_THRESHOLD) && (ptr->motion_detection_threshold <= BSP_MAX_MOTION_DETECTION_THRESHOLD))
 8020392:	eef4 7ac7 	vcmpe.f32	s15, s14
  {
    retval += 2;
  }
  if (ptr->min_speed_kmph > ptr->max_speed_kmph)
  {
    retval += 4;
 8020396:	bf48      	it	mi
 8020398:	3404      	addmi	r4, #4
  }
  if (!(ptr->motion_detection_threshold >= BSP_MIN_MOTION_DETECTION_THRESHOLD) && (ptr->motion_detection_threshold <= BSP_MAX_MOTION_DETECTION_THRESHOLD))
 802039a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802039e:	da07      	bge.n	80203b0 <ds_init+0x238>
 80203a0:	ed9f 7a40 	vldr	s14, [pc, #256]	; 80204a4 <ds_init+0x32c>
 80203a4:	eef4 7ac7 	vcmpe.f32	s15, s14
 80203a8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  {
	 retval += 8;
 80203ac:	bf98      	it	ls
 80203ae:	3408      	addls	r4, #8
 */
uint32_t ds_dev_check_settings(device_settings_t *ptr)
{
  uint32_t retval = 0;

  if (!((ptr->num_sample_skip_count >= BSP_MIN_SAMPLE_SKIP_COUNT) && (ptr->num_sample_skip_count <= BSP_MAX_SAMPLE_SKIP_COUNT)))
 80203b0:	6af0      	ldr	r0, [r6, #44]	; 0x2c
  {
    retval += 1;
  }
  if (!(ptr->adc_sampling_freq_Hz >= BSP_MIN_DOPPLER_SAMPLING_FREQ_HZ && (ptr->adc_sampling_freq_Hz <= BSP_MAX_DOPPLER_SAMPLING_FREQ_HZ)))
 80203b2:	6973      	ldr	r3, [r6, #20]
  {
    retval += 2;
  }
  if (!(ptr->frame_period_usec >= bsp_calc_min_frame_interval_usec(ptr)) && (ptr->frame_period_usec*1000 <= BSP_MAX_FRAME_PERIOD_MSEC))
 80203b4:	4f35      	ldr	r7, [pc, #212]	; (802048c <ds_init+0x314>)
 80203b6:	f8d6 8020 	ldr.w	r8, [r6, #32]
 */
uint32_t ds_dev_check_settings(device_settings_t *ptr)
{
  uint32_t retval = 0;

  if (!((ptr->num_sample_skip_count >= BSP_MIN_SAMPLE_SKIP_COUNT) && (ptr->num_sample_skip_count <= BSP_MAX_SAMPLE_SKIP_COUNT)))
 80203ba:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
  {
    retval += 1;
  }
  if (!(ptr->adc_sampling_freq_Hz >= BSP_MIN_DOPPLER_SAMPLING_FREQ_HZ && (ptr->adc_sampling_freq_Hz <= BSP_MAX_DOPPLER_SAMPLING_FREQ_HZ)))
 80203be:	f5a3 737a 	sub.w	r3, r3, #1000	; 0x3e8
 */
uint32_t ds_dev_check_settings(device_settings_t *ptr)
{
  uint32_t retval = 0;

  if (!((ptr->num_sample_skip_count >= BSP_MIN_SAMPLE_SKIP_COUNT) && (ptr->num_sample_skip_count <= BSP_MAX_SAMPLE_SKIP_COUNT)))
 80203c2:	bf8c      	ite	hi
 80203c4:	2501      	movhi	r5, #1
 80203c6:	2500      	movls	r5, #0
  }
  if (!(ptr->adc_sampling_freq_Hz >= BSP_MIN_DOPPLER_SAMPLING_FREQ_HZ && (ptr->adc_sampling_freq_Hz <= BSP_MAX_DOPPLER_SAMPLING_FREQ_HZ)))
  {
    retval += 2;
  }
  if (!(ptr->frame_period_usec >= bsp_calc_min_frame_interval_usec(ptr)) && (ptr->frame_period_usec*1000 <= BSP_MAX_FRAME_PERIOD_MSEC))
 80203c8:	4638      	mov	r0, r7

  if (!((ptr->num_sample_skip_count >= BSP_MIN_SAMPLE_SKIP_COUNT) && (ptr->num_sample_skip_count <= BSP_MAX_SAMPLE_SKIP_COUNT)))
  {
    retval += 1;
  }
  if (!(ptr->adc_sampling_freq_Hz >= BSP_MIN_DOPPLER_SAMPLING_FREQ_HZ && (ptr->adc_sampling_freq_Hz <= BSP_MAX_DOPPLER_SAMPLING_FREQ_HZ)))
 80203ca:	f5b3 6f7a 	cmp.w	r3, #4000	; 0xfa0
  {
    retval += 2;
 80203ce:	bf88      	it	hi
 80203d0:	3502      	addhi	r5, #2
  }
  if (!(ptr->frame_period_usec >= bsp_calc_min_frame_interval_usec(ptr)) && (ptr->frame_period_usec*1000 <= BSP_MAX_FRAME_PERIOD_MSEC))
 80203d2:	f009 fe79 	bl	802a0c8 <bsp_calc_min_frame_interval_usec>
 80203d6:	4580      	cmp	r8, r0
 80203d8:	d208      	bcs.n	80203ec <ds_init+0x274>
 80203da:	6a3a      	ldr	r2, [r7, #32]
 80203dc:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80203e0:	fb03 f302 	mul.w	r3, r3, r2
 80203e4:	f5b3 6ffa 	cmp.w	r3, #2000	; 0x7d0
  {
    retval += 4;
 80203e8:	bf98      	it	ls
 80203ea:	3504      	addls	r5, #4
  }
  if (!(ptr->num_samples_per_chirp >= BSP_MIN_NUM_SAMPLES_PER_CHIRP) && (ptr->num_samples_per_chirp <= BSP_MAX_NUM_SAMPLES_PER_CHIRP))
 80203ec:	6a73      	ldr	r3, [r6, #36]	; 0x24
 80203ee:	2b1f      	cmp	r3, #31
  {
	 retval += 8;
  }
  if (ptr->adc_resolution != 12)
 80203f0:	7e33      	ldrb	r3, [r6, #24]
  {
    retval += 4;
  }
  if (!(ptr->num_samples_per_chirp >= BSP_MIN_NUM_SAMPLES_PER_CHIRP) && (ptr->num_samples_per_chirp <= BSP_MAX_NUM_SAMPLES_PER_CHIRP))
  {
	 retval += 8;
 80203f2:	bf98      	it	ls
 80203f4:	3508      	addls	r5, #8
  }
  if (ptr->adc_resolution != 12)
 80203f6:	2b0c      	cmp	r3, #12
  {
	  retval += 16;
 80203f8:	bf18      	it	ne
 80203fa:	3510      	addne	r5, #16
	ds_algo_para_factory_reset();
  }

  /* 6- Valid algorithm settings: Use new settings from EEPROM */
  retval += ds_algo_check_settings(&ds_algo_settings);
  retval += ds_dev_check_settings(&ds_device_settings);
 80203fc:	1928      	adds	r0, r5, r4
  memcpy(&ds_algo_settings, &ds_default_algo_settings, sizeof(algo_settings_t));
  retval += ds_algo_check_settings(&ds_algo_settings);
#endif /* DS_USE_EEPROM */
  
  return retval;
}
 80203fe:	b003      	add	sp, #12
 8020400:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 */
uint32_t ds_algo_check_settings(algo_settings_t *ptr)
{
  uint32_t retval = 0;

  if (!((ptr->speed_detection_threshold >= BSP_MIN_SPEED_DETECTION_THRESHOLD) && (ptr->speed_detection_threshold <= BSP_MAX_SPEED_DETECTION_THRESHOLD)))
 8020404:	2303      	movs	r3, #3
  {
    retval += 1;
 8020406:	2401      	movs	r4, #1
 8020408:	e7aa      	b.n	8020360 <ds_init+0x1e8>

/* Function to copy default algorithm settings into EEPROM */
void ds_algo_para_factory_reset(void)
{
#ifdef DS_USE_EEPROM
	ds_algo_settings = ds_default_algo_settings;
 802040a:	4c1f      	ldr	r4, [pc, #124]	; (8020488 <ds_init+0x310>)
 802040c:	f8df 8090 	ldr.w	r8, [pc, #144]	; 80204a0 <ds_init+0x328>

//============================================================================

void ds_set_device_parameter_changed(void)
{
	device_parameter_changed = 1;
 8020410:	f8df c080 	ldr.w	ip, [pc, #128]	; 8020494 <ds_init+0x31c>

/* Function to copy default algorithm settings into EEPROM */
void ds_algo_para_factory_reset(void)
{
#ifdef DS_USE_EEPROM
	ds_algo_settings = ds_default_algo_settings;
 8020414:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8020416:	4645      	mov	r5, r8
 8020418:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 802041a:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
 802041e:	e885 0007 	stmia.w	r5, {r0, r1, r2}
	if (ds_eeprom_write_settings(&ds_default_algo_settings, sizeof(algo_settings_t), DS_EEPROM_ADDRESS_ALGO_SETTING) != EEPROM_STATUS_SUCCESS)
 8020422:	f1a4 0010 	sub.w	r0, r4, #16
 8020426:	211c      	movs	r1, #28
 8020428:	22a0      	movs	r2, #160	; 0xa0

//============================================================================

void ds_set_device_parameter_changed(void)
{
	device_parameter_changed = 1;
 802042a:	f8cc e000 	str.w	lr, [ip]
/* Function to copy default algorithm settings into EEPROM */
void ds_algo_para_factory_reset(void)
{
#ifdef DS_USE_EEPROM
	ds_algo_settings = ds_default_algo_settings;
	if (ds_eeprom_write_settings(&ds_default_algo_settings, sizeof(algo_settings_t), DS_EEPROM_ADDRESS_ALGO_SETTING) != EEPROM_STATUS_SUCCESS)
 802042e:	f000 f8e3 	bl	80205f8 <ds_eeprom_write_settings>
 8020432:	2801      	cmp	r0, #1
 8020434:	f43f af08 	beq.w	8020248 <ds_init+0xd0>
 8020438:	e7fe      	b.n	8020438 <ds_init+0x2c0>

	eep_status = ds_eeprom_read_settings(&eep_def_settings, sizeof(eep_def_settings), DS_EEPROM_ADDRESS_DEFAULT_SETTING);

	if (eep_status == EEPROM_STATUS_SUCCESS)
	{
		if (def_dev_setting_crc 	!= eep_def_settings.def_dev_settings_crc ||
 802043a:	f89d 3004 	ldrb.w	r3, [sp, #4]
 802043e:	429c      	cmp	r4, r3
 8020440:	d102      	bne.n	8020448 <ds_init+0x2d0>
 8020442:	42ac      	cmp	r4, r5
 8020444:	f43f aefd 	beq.w	8020242 <ds_init+0xca>
==============================================================================
 */

void ds_set_def_settings_changed(void)
{
	def_settings_changed = 1;
 8020448:	4b18      	ldr	r3, [pc, #96]	; (80204ac <ds_init+0x334>)
		{
			/* set the flag */
			ds_set_def_settings_changed();

			/* write changed def settings check struct to EEPROM */
			eep_def_settings.def_dev_settings_crc 	= def_dev_setting_crc;
 802044a:	f88d 4004 	strb.w	r4, [sp, #4]
			eep_def_settings.def_algo_settings_crc 	= def_algo_setting_crc;
			eep_status = ds_eeprom_write_settings(&eep_def_settings, sizeof(eep_def_settings), DS_EEPROM_ADDRESS_DEFAULT_SETTING);
 802044e:	a801      	add	r0, sp, #4
==============================================================================
 */

void ds_set_def_settings_changed(void)
{
	def_settings_changed = 1;
 8020450:	2401      	movs	r4, #1
			ds_set_def_settings_changed();

			/* write changed def settings check struct to EEPROM */
			eep_def_settings.def_dev_settings_crc 	= def_dev_setting_crc;
			eep_def_settings.def_algo_settings_crc 	= def_algo_setting_crc;
			eep_status = ds_eeprom_write_settings(&eep_def_settings, sizeof(eep_def_settings), DS_EEPROM_ADDRESS_DEFAULT_SETTING);
 8020452:	2102      	movs	r1, #2
 8020454:	22e0      	movs	r2, #224	; 0xe0
			/* set the flag */
			ds_set_def_settings_changed();

			/* write changed def settings check struct to EEPROM */
			eep_def_settings.def_dev_settings_crc 	= def_dev_setting_crc;
			eep_def_settings.def_algo_settings_crc 	= def_algo_setting_crc;
 8020456:	f88d 5005 	strb.w	r5, [sp, #5]
==============================================================================
 */

void ds_set_def_settings_changed(void)
{
	def_settings_changed = 1;
 802045a:	601c      	str	r4, [r3, #0]
			ds_set_def_settings_changed();

			/* write changed def settings check struct to EEPROM */
			eep_def_settings.def_dev_settings_crc 	= def_dev_setting_crc;
			eep_def_settings.def_algo_settings_crc 	= def_algo_setting_crc;
			eep_status = ds_eeprom_write_settings(&eep_def_settings, sizeof(eep_def_settings), DS_EEPROM_ADDRESS_DEFAULT_SETTING);
 802045c:	f000 f8cc 	bl	80205f8 <ds_eeprom_write_settings>
 8020460:	e71d      	b.n	802029e <ds_init+0x126>
  ret_status = EEPROM_STATUS_FAILURE;
  ret_status = ds_eeprom_read_settings(&ds_device_settings, sizeof(device_settings_t), DS_EEPROM_ADDRESS_HW_SETTING);

  /* 3- Check if a valid hardware settings are written in EEPROM */
  if ((ret_status != EEPROM_STATUS_SUCCESS) ||
	  (ds_device_settings.struct_version != DS_HW_SETTINGS_STRUCT_VERSION) ||
 8020462:	6823      	ldr	r3, [r4, #0]
 8020464:	2b40      	cmp	r3, #64	; 0x40
 8020466:	f47f aefc 	bne.w	8020262 <ds_init+0xea>
 802046a:	e732      	b.n	80202d2 <ds_init+0x15a>
 802046c:	1ffe9000 	.word	0x1ffe9000
 8020470:	00989680 	.word	0x00989680
 8020474:	1ffe91d8 	.word	0x1ffe91d8
 8020478:	1ffe900c 	.word	0x1ffe900c
 802047c:	02625a00 	.word	0x02625a00
 8020480:	0802f028 	.word	0x0802f028
 8020484:	1ffe9484 	.word	0x1ffe9484
 8020488:	1ffe9050 	.word	0x1ffe9050
 802048c:	1ffe973c 	.word	0x1ffe973c
 8020490:	00030e1e 	.word	0x00030e1e
 8020494:	1ffe96d8 	.word	0x1ffe96d8
 8020498:	1ffe96fc 	.word	0x1ffe96fc
 802049c:	0002e9c6 	.word	0x0002e9c6
 80204a0:	1ffe96dc 	.word	0x1ffe96dc
 80204a4:	44fa0000 	.word	0x44fa0000
 80204a8:	44870000 	.word	0x44870000
 80204ac:	1ffe96f8 	.word	0x1ffe96f8
 80204b0:	1ffe96d4 	.word	0x1ffe96d4

	/*  TODO: Remove before the release!! */
	if (shield_status == RF_SHIELD_BOARD_NOT_PROGRAMMED)
	{
		//static uint8_t ds_eeprom_write_inital_board_id(void);
		if (ds_eeprom_write_inital_board_id() == EEPROM_STATUS_SUCCESS)
 80204b4:	f000 f950 	bl	8020758 <ds_eeprom_write_inital_board_id>
 80204b8:	2801      	cmp	r0, #1
 80204ba:	f47f aea5 	bne.w	8020208 <ds_init+0x90>
		{
			bsp_led_blue_on();
 80204be:	f008 fc41 	bl	8028d44 <bsp_led_blue_on>
			
			TIMER_SetTimeInterval(&TIMER_ERROR_TOGGLE, 200 * 1000U * 100U);
 80204c2:	4908      	ldr	r1, [pc, #32]	; (80204e4 <ds_init+0x36c>)
 80204c4:	4808      	ldr	r0, [pc, #32]	; (80204e8 <ds_init+0x370>)
 80204c6:	f005 fcff 	bl	8025ec8 <TIMER_SetTimeInterval>
			bsp_timer_start(&TIMER_ERROR_TOGGLE);
 80204ca:	4807      	ldr	r0, [pc, #28]	; (80204e8 <ds_init+0x370>)
 80204cc:	f009 f9c6 	bl	802985c <bsp_timer_start>
	    	device_status_set_error(FATAL_ERROR_BOARD_NOT_PROGRAMMED);
 80204d0:	f244 1002 	movw	r0, #16642	; 0x4102
 80204d4:	f000 fb7a 	bl	8020bcc <device_status_set_error>
			return RF_SHIELD_NOT_PROGRAMMED;
 80204d8:	4804      	ldr	r0, [pc, #16]	; (80204ec <ds_init+0x374>)
  memcpy(&ds_algo_settings, &ds_default_algo_settings, sizeof(algo_settings_t));
  retval += ds_algo_check_settings(&ds_algo_settings);
#endif /* DS_USE_EEPROM */
  
  return retval;
}
 80204da:	b003      	add	sp, #12
 80204dc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  if (shield_status == RF_SHIELD_BOARD_UNSUPPORTED)
  {
	  /* Read RF board ID, check if a valid board ID is written in EEPROM */
	  shield_status = ds_eeprom_read_board_id(rf_board_id_2, sizeof(rf_board_id_2));
	  if (shield_status == RF_SHIELD_BOARD_SUPPORTED)
		  board_variant = 1;
 80204e0:	2701      	movs	r7, #1
 80204e2:	e692      	b.n	802020a <ds_init+0x92>
 80204e4:	01312d00 	.word	0x01312d00
 80204e8:	1ffe91d8 	.word	0x1ffe91d8
 80204ec:	00030002 	.word	0x00030002

080204f0 <ds_get_active_acq_buf>:
//============================================================================

acq_buf_obj *ds_get_active_acq_buf(void)
{
  return &s_acq_buf;
}
 80204f0:	4800      	ldr	r0, [pc, #0]	; (80204f4 <ds_get_active_acq_buf+0x4>)
 80204f2:	4770      	bx	lr
 80204f4:	1ffe9018 	.word	0x1ffe9018

080204f8 <ds_set_active_acq_buf>:

//============================================================================

void ds_set_active_acq_buf(const acq_buf_obj acq_buf)
{
 80204f8:	b084      	sub	sp, #16
 80204fa:	b538      	push	{r3, r4, r5, lr}
  if (s_acq_buf.p_acq_buf != NULL)
 80204fc:	4c0c      	ldr	r4, [pc, #48]	; (8020530 <ds_set_active_acq_buf+0x38>)
 80204fe:	6ae5      	ldr	r5, [r4, #44]	; 0x2c
}

//============================================================================

void ds_set_active_acq_buf(const acq_buf_obj acq_buf)
{
 8020500:	f10d 0e10 	add.w	lr, sp, #16
 8020504:	e88e 000f 	stmia.w	lr, {r0, r1, r2, r3}
  if (s_acq_buf.p_acq_buf != NULL)
 8020508:	b115      	cbz	r5, 8020510 <ds_set_active_acq_buf+0x18>
  {
    delete_acq_buffer_obj(&s_acq_buf);
 802050a:	4620      	mov	r0, r4
 802050c:	f000 fa0a 	bl	8020924 <delete_acq_buffer_obj>
  }
  
  memcpy(&s_acq_buf, &acq_buf, sizeof(acq_buf_obj));
 8020510:	ad04      	add	r5, sp, #16
 8020512:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8020514:	4c06      	ldr	r4, [pc, #24]	; (8020530 <ds_set_active_acq_buf+0x38>)
 8020516:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8020518:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 802051a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 802051c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 802051e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8020520:	e895 0003 	ldmia.w	r5, {r0, r1}
 8020524:	e884 0003 	stmia.w	r4, {r0, r1}
}
 8020528:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 802052c:	b004      	add	sp, #16
 802052e:	4770      	bx	lr
 8020530:	1ffe9018 	.word	0x1ffe9018

08020534 <ds_algo_para_factory_reset>:

//============================================================================

/* Function to copy default algorithm settings into EEPROM */
void ds_algo_para_factory_reset(void)
{
 8020534:	b538      	push	{r3, r4, r5, lr}
#ifdef DS_USE_EEPROM
	ds_algo_settings = ds_default_algo_settings;
 8020536:	4c09      	ldr	r4, [pc, #36]	; (802055c <ds_algo_para_factory_reset+0x28>)
 8020538:	4d09      	ldr	r5, [pc, #36]	; (8020560 <ds_algo_para_factory_reset+0x2c>)
 802053a:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 802053c:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 802053e:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
 8020542:	e885 0007 	stmia.w	r5, {r0, r1, r2}
	if (ds_eeprom_write_settings(&ds_default_algo_settings, sizeof(algo_settings_t), DS_EEPROM_ADDRESS_ALGO_SETTING) != EEPROM_STATUS_SUCCESS)
 8020546:	f1a4 0010 	sub.w	r0, r4, #16
 802054a:	211c      	movs	r1, #28
 802054c:	22a0      	movs	r2, #160	; 0xa0
 802054e:	f000 f853 	bl	80205f8 <ds_eeprom_write_settings>
 8020552:	2801      	cmp	r0, #1
 8020554:	d000      	beq.n	8020558 <ds_algo_para_factory_reset+0x24>
	{
		XMC_DEBUG("writing EEPROM failed!\n");
		while (1);
 8020556:	e7fe      	b.n	8020556 <ds_algo_para_factory_reset+0x22>
 8020558:	bd38      	pop	{r3, r4, r5, pc}
 802055a:	bf00      	nop
 802055c:	1ffe9050 	.word	0x1ffe9050
 8020560:	1ffe96dc 	.word	0x1ffe96dc

08020564 <ds_algo_para_store_persistent>:

//============================================================================

/* Function to copy current algorithm settings into EEPROM */
void ds_algo_para_store_persistent(void)
{
 8020564:	b508      	push	{r3, lr}
#ifdef DS_USE_EEPROM
	algo_settings_t *pDev = ds_algo_get_settings();
	if (ds_eeprom_write_settings(pDev, sizeof(algo_settings_t), DS_EEPROM_ADDRESS_ALGO_SETTING) != EEPROM_STATUS_SUCCESS)
 8020566:	4804      	ldr	r0, [pc, #16]	; (8020578 <ds_algo_para_store_persistent+0x14>)
 8020568:	211c      	movs	r1, #28
 802056a:	22a0      	movs	r2, #160	; 0xa0
 802056c:	f000 f844 	bl	80205f8 <ds_eeprom_write_settings>
 8020570:	2801      	cmp	r0, #1
 8020572:	d000      	beq.n	8020576 <ds_algo_para_store_persistent+0x12>
	{
		XMC_DEBUG("writing EEPROM failed!\n");
		while (1);
 8020574:	e7fe      	b.n	8020574 <ds_algo_para_store_persistent+0x10>
 8020576:	bd08      	pop	{r3, pc}
 8020578:	1ffe96dc 	.word	0x1ffe96dc

0802057c <ds_hw_para_factory_reset>:

//============================================================================

/* Function to copy default hardware settings into EEPROM */
void ds_hw_para_factory_reset(void)
{
 802057c:	b538      	push	{r3, r4, r5, lr}
#ifdef DS_USE_EEPROM
	ds_device_settings = ds_default_device_settings;
 802057e:	4c0c      	ldr	r4, [pc, #48]	; (80205b0 <ds_hw_para_factory_reset+0x34>)
 8020580:	4d0c      	ldr	r5, [pc, #48]	; (80205b4 <ds_hw_para_factory_reset+0x38>)
 8020582:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8020584:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8020586:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8020588:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 802058a:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 802058c:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 802058e:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
 8020592:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}
	if (ds_eeprom_write_settings(&ds_default_device_settings, sizeof(device_settings_t), DS_EEPROM_ADDRESS_HW_SETTING) != EEPROM_STATUS_SUCCESS)
 8020596:	f1a4 0030 	sub.w	r0, r4, #48	; 0x30
 802059a:	2140      	movs	r1, #64	; 0x40
 802059c:	2220      	movs	r2, #32
 802059e:	f000 f82b 	bl	80205f8 <ds_eeprom_write_settings>
 80205a2:	2801      	cmp	r0, #1
 80205a4:	d000      	beq.n	80205a8 <ds_hw_para_factory_reset+0x2c>
	{
		XMC_DEBUG("writing EEPROM failed!\n");
		while (1);
 80205a6:	e7fe      	b.n	80205a6 <ds_hw_para_factory_reset+0x2a>

//============================================================================

void ds_set_device_parameter_changed(void)
{
	device_parameter_changed = 1;
 80205a8:	4b03      	ldr	r3, [pc, #12]	; (80205b8 <ds_hw_para_factory_reset+0x3c>)
 80205aa:	6018      	str	r0, [r3, #0]
 80205ac:	bd38      	pop	{r3, r4, r5, pc}
 80205ae:	bf00      	nop
 80205b0:	0802f028 	.word	0x0802f028
 80205b4:	1ffe973c 	.word	0x1ffe973c
 80205b8:	1ffe96d8 	.word	0x1ffe96d8

080205bc <ds_hw_para_store_persistent>:

//============================================================================

/* Function to copy current hardware settings into EEPROM */
void ds_hw_para_store_persistent(void)
{
 80205bc:	b508      	push	{r3, lr}
#ifdef DS_USE_EEPROM
	device_settings_t *pDev = ds_device_get_settings();
	if (ds_eeprom_write_settings(pDev, sizeof(device_settings_t), DS_EEPROM_ADDRESS_HW_SETTING) != EEPROM_STATUS_SUCCESS)
 80205be:	4804      	ldr	r0, [pc, #16]	; (80205d0 <ds_hw_para_store_persistent+0x14>)
 80205c0:	2140      	movs	r1, #64	; 0x40
 80205c2:	2220      	movs	r2, #32
 80205c4:	f000 f818 	bl	80205f8 <ds_eeprom_write_settings>
 80205c8:	2801      	cmp	r0, #1
 80205ca:	d000      	beq.n	80205ce <ds_hw_para_store_persistent+0x12>
	{
		XMC_DEBUG("writing EEPROM failed!\n");
		while (1);
 80205cc:	e7fe      	b.n	80205cc <ds_hw_para_store_persistent+0x10>
 80205ce:	bd08      	pop	{r3, pc}
 80205d0:	1ffe973c 	.word	0x1ffe973c

080205d4 <ds_set_device_parameter_changed>:

//============================================================================

void ds_set_device_parameter_changed(void)
{
	device_parameter_changed = 1;
 80205d4:	4b01      	ldr	r3, [pc, #4]	; (80205dc <ds_set_device_parameter_changed+0x8>)
 80205d6:	2201      	movs	r2, #1
 80205d8:	601a      	str	r2, [r3, #0]
 80205da:	4770      	bx	lr
 80205dc:	1ffe96d8 	.word	0x1ffe96d8

080205e0 <ds_clear_device_parameter_changed>:

//============================================================================

void ds_clear_device_parameter_changed(void)
{
	device_parameter_changed = 0;
 80205e0:	4b01      	ldr	r3, [pc, #4]	; (80205e8 <ds_clear_device_parameter_changed+0x8>)
 80205e2:	2200      	movs	r2, #0
 80205e4:	601a      	str	r2, [r3, #0]
 80205e6:	4770      	bx	lr
 80205e8:	1ffe96d8 	.word	0x1ffe96d8

080205ec <ds_is_device_parameter_changed>:

//============================================================================

uint32_t ds_is_device_parameter_changed(void)
{
	return device_parameter_changed;
 80205ec:	4b01      	ldr	r3, [pc, #4]	; (80205f4 <ds_is_device_parameter_changed+0x8>)
}
 80205ee:	6818      	ldr	r0, [r3, #0]
 80205f0:	4770      	bx	lr
 80205f2:	bf00      	nop
 80205f4:	1ffe96d8 	.word	0x1ffe96d8

080205f8 <ds_eeprom_write_settings>:

#ifdef DS_USE_EEPROM

/* Function to write settings into EEPROM */
EEPROM_STATUS_t ds_eeprom_write_settings(const void *p_settings, uint32_t struct_size, uint16_t eeprom_address)
{
 80205f8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  uint32_t buffer[struct_size/4 + 2]; /* Plus one extra for the CRC32 */
 80205fc:	088d      	lsrs	r5, r1, #2
 80205fe:	1cab      	adds	r3, r5, #2
 8020600:	009b      	lsls	r3, r3, #2
 8020602:	f103 040a 	add.w	r4, r3, #10
 8020606:	f024 0407 	bic.w	r4, r4, #7

#ifdef DS_USE_EEPROM

/* Function to write settings into EEPROM */
EEPROM_STATUS_t ds_eeprom_write_settings(const void *p_settings, uint32_t struct_size, uint16_t eeprom_address)
{
 802060a:	af00      	add	r7, sp, #0
  uint32_t buffer[struct_size/4 + 2]; /* Plus one extra for the CRC32 */
 802060c:	ebad 0d04 	sub.w	sp, sp, r4
  uint32_t buffer_size = 0, crc32 = 0;

  if ((p_settings == NULL) || (struct_size <= 0))
 8020610:	b100      	cbz	r0, 8020614 <ds_eeprom_write_settings+0x1c>
 8020612:	b919      	cbnz	r1, 802061c <ds_eeprom_write_settings+0x24>
  {
    /* Invalid input parameters */
	return EEPROM_STATUS_FAILURE;
 8020614:	2002      	movs	r0, #2
  crc32 = CRC_SW_GetCRCResult(&CRC_SW_EEPROM);
  buffer[buffer_size++] = crc32;

  /* Write hardware settings structure in the EEPROM */
  return(bsp_eeprom_24cw128x_write_data(eeprom_address, (uint8_t*)buffer, buffer_size*4));
}
 8020616:	46bd      	mov	sp, r7
 8020618:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    /* Invalid input parameters */
	return EEPROM_STATUS_FAILURE;
  }

  /* Get the buffer size for the structure */
  if ((struct_size % 4) != 0)
 802061c:	078c      	lsls	r4, r1, #30
 802061e:	4606      	mov	r6, r0
 8020620:	4691      	mov	r9, r2
 8020622:	460c      	mov	r4, r1
  {
	buffer_size = struct_size/4;
  }

  /* Clear the transmit buffer */
  memset(buffer, 0, sizeof(buffer));
 8020624:	461a      	mov	r2, r3
 8020626:	4668      	mov	r0, sp
 8020628:	f04f 0100 	mov.w	r1, #0
  }

  /* Get the buffer size for the structure */
  if ((struct_size % 4) != 0)
  {
    buffer_size = struct_size/4 + 1;
 802062c:	bf18      	it	ne
 802062e:	3501      	addne	r5, #1
  {
	buffer_size = struct_size/4;
  }

  /* Clear the transmit buffer */
  memset(buffer, 0, sizeof(buffer));
 8020630:	f00c ff99 	bl	802d566 <memset>

  /* Copy hardware settings structure into transmit buffer */
  memcpy(buffer, p_settings, struct_size);
 8020634:	4631      	mov	r1, r6
 8020636:	4622      	mov	r2, r4
 8020638:	4668      	mov	r0, sp
 802063a:	f00c ff89 	bl	802d550 <memcpy>

  /*  Get the CRC for all structure */
  CRC_SW_CalculateCRC(&CRC_SW_EEPROM, buffer, buffer_size);
 802063e:	4669      	mov	r1, sp
 8020640:	462a      	mov	r2, r5
 8020642:	4808      	ldr	r0, [pc, #32]	; (8020664 <ds_eeprom_write_settings+0x6c>)
 8020644:	f006 f91e 	bl	8026884 <CRC_SW_CalculateCRC>
  crc32 = CRC_SW_GetCRCResult(&CRC_SW_EEPROM);
 8020648:	4806      	ldr	r0, [pc, #24]	; (8020664 <ds_eeprom_write_settings+0x6c>)
 802064a:	f006 f95d 	bl	8026908 <CRC_SW_GetCRCResult>
  buffer[buffer_size++] = crc32;
 802064e:	1c6a      	adds	r2, r5, #1
 8020650:	f84d 0025 	str.w	r0, [sp, r5, lsl #2]

  /* Write hardware settings structure in the EEPROM */
  return(bsp_eeprom_24cw128x_write_data(eeprom_address, (uint8_t*)buffer, buffer_size*4));
 8020654:	0092      	lsls	r2, r2, #2
 8020656:	4648      	mov	r0, r9
 8020658:	4669      	mov	r1, sp
 802065a:	f008 f925 	bl	80288a8 <bsp_eeprom_24cw128x_write_data>
}
 802065e:	46bd      	mov	sp, r7
 8020660:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8020664:	1ffe9484 	.word	0x1ffe9484

08020668 <ds_eeprom_read_settings>:

//============================================================================

/* Function to read settings from EEPROM */
EEPROM_STATUS_t ds_eeprom_read_settings(void *p_settings, uint32_t struct_size, uint16_t eeprom_address)
{
 8020668:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  uint32_t buffer[struct_size/4 + 2]; /* Plus one extra for the CRC32 */
 802066c:	088d      	lsrs	r5, r1, #2
 802066e:	1cab      	adds	r3, r5, #2
 8020670:	009b      	lsls	r3, r3, #2
 8020672:	f103 040a 	add.w	r4, r3, #10
 8020676:	f024 0407 	bic.w	r4, r4, #7

//============================================================================

/* Function to read settings from EEPROM */
EEPROM_STATUS_t ds_eeprom_read_settings(void *p_settings, uint32_t struct_size, uint16_t eeprom_address)
{
 802067a:	af00      	add	r7, sp, #0
  uint32_t buffer[struct_size/4 + 2]; /* Plus one extra for the CRC32 */
 802067c:	ebad 0d04 	sub.w	sp, sp, r4
  uint32_t buffer_size = 0, new_crc32 = 0, old_crc32 = 0;
  EEPROM_STATUS_t ret_status = EEPROM_STATUS_FAILURE;

  if ((p_settings == NULL) || (struct_size <= 0))
 8020680:	b100      	cbz	r0, 8020684 <ds_eeprom_read_settings+0x1c>
 8020682:	b919      	cbnz	r1, 802068c <ds_eeprom_read_settings+0x24>
  {
    /* Invalid input parameters */
	return EEPROM_STATUS_FAILURE;
 8020684:	2002      	movs	r0, #2
  }
  else
  {
	return EEPROM_STATUS_FAILURE;
  }
}
 8020686:	46bd      	mov	sp, r7
 8020688:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    /* Invalid input parameters */
	return EEPROM_STATUS_FAILURE;
  }

  /* Get the buffer size for the structure */
  if ((struct_size % 4) != 0)
 802068c:	078c      	lsls	r4, r1, #30
  {
    buffer_size = struct_size/4 + 1;
 802068e:	bf18      	it	ne
 8020690:	3501      	addne	r5, #1
 8020692:	4614      	mov	r4, r2
 8020694:	4606      	mov	r6, r0
  {
	buffer_size = struct_size/4;
  }

  /* Clear the receive buffer */
  memset(buffer, 0, sizeof(buffer));
 8020696:	461a      	mov	r2, r3
 8020698:	4689      	mov	r9, r1
 802069a:	4668      	mov	r0, sp
 802069c:	2100      	movs	r1, #0
 802069e:	f00c ff62 	bl	802d566 <memset>

  /* Read hardware settings structure from EEPROM */
  ret_status = bsp_eeprom_24cw128x_read_data(eeprom_address, (uint8_t*)buffer, (buffer_size + 1)*4);
 80206a2:	1c6a      	adds	r2, r5, #1
 80206a4:	4620      	mov	r0, r4
 80206a6:	0092      	lsls	r2, r2, #2
 80206a8:	4669      	mov	r1, sp
 80206aa:	f008 fa37 	bl	8028b1c <bsp_eeprom_24cw128x_read_data>

  /* Get the old CRC and compare it with the new one */
  old_crc32 = buffer[buffer_size];
  CRC_SW_CalculateCRC(&CRC_SW_EEPROM, buffer, buffer_size);
 80206ae:	4669      	mov	r1, sp
 80206b0:	462a      	mov	r2, r5

  /* Clear the receive buffer */
  memset(buffer, 0, sizeof(buffer));

  /* Read hardware settings structure from EEPROM */
  ret_status = bsp_eeprom_24cw128x_read_data(eeprom_address, (uint8_t*)buffer, (buffer_size + 1)*4);
 80206b2:	4604      	mov	r4, r0

  /* Get the old CRC and compare it with the new one */
  old_crc32 = buffer[buffer_size];
  CRC_SW_CalculateCRC(&CRC_SW_EEPROM, buffer, buffer_size);
 80206b4:	4809      	ldr	r0, [pc, #36]	; (80206dc <ds_eeprom_read_settings+0x74>)

  /* Read hardware settings structure from EEPROM */
  ret_status = bsp_eeprom_24cw128x_read_data(eeprom_address, (uint8_t*)buffer, (buffer_size + 1)*4);

  /* Get the old CRC and compare it with the new one */
  old_crc32 = buffer[buffer_size];
 80206b6:	f85d a025 	ldr.w	sl, [sp, r5, lsl #2]
  CRC_SW_CalculateCRC(&CRC_SW_EEPROM, buffer, buffer_size);
 80206ba:	f006 f8e3 	bl	8026884 <CRC_SW_CalculateCRC>
  new_crc32 = CRC_SW_GetCRCResult(&CRC_SW_EEPROM);
 80206be:	4807      	ldr	r0, [pc, #28]	; (80206dc <ds_eeprom_read_settings+0x74>)
 80206c0:	f006 f922 	bl	8026908 <CRC_SW_GetCRCResult>

  /* Check for CRC error */
  if ((new_crc32 == old_crc32) && (ret_status == EEPROM_STATUS_SUCCESS))
 80206c4:	4550      	cmp	r0, sl
 80206c6:	d1dd      	bne.n	8020684 <ds_eeprom_read_settings+0x1c>
 80206c8:	2c01      	cmp	r4, #1
 80206ca:	d1db      	bne.n	8020684 <ds_eeprom_read_settings+0x1c>
  {
    /* Valid CRC: copy buffer into the HW settings structure */
	memcpy(p_settings, buffer, struct_size);
 80206cc:	4630      	mov	r0, r6
 80206ce:	4669      	mov	r1, sp
 80206d0:	464a      	mov	r2, r9
 80206d2:	f00c ff3d 	bl	802d550 <memcpy>

    return EEPROM_STATUS_SUCCESS;
 80206d6:	4620      	mov	r0, r4
 80206d8:	e7d5      	b.n	8020686 <ds_eeprom_read_settings+0x1e>
 80206da:	bf00      	nop
 80206dc:	1ffe9484 	.word	0x1ffe9484

080206e0 <ds_eeprom_read_board_id>:

  uint8_t buffer[32], index = 0;
  char *id = board_id;
  RF_SHIELD_STATUS_t shield_status = RF_SHIELD_BOARD_NOT_CONNECTED;

  if ((board_id == NULL) || (id_size > 32) || (id_size == 0))
 80206e0:	b110      	cbz	r0, 80206e8 <ds_eeprom_read_board_id+0x8>
 80206e2:	1e4b      	subs	r3, r1, #1
 80206e4:	2b1f      	cmp	r3, #31
 80206e6:	d901      	bls.n	80206ec <ds_eeprom_read_board_id+0xc>
  {
	return RF_SHIELD_BOARD_INVALID_PARAM;
 80206e8:	2001      	movs	r0, #1
  {
    shield_status = RF_SHIELD_BOARD_NOT_CONNECTED;
  }

  return shield_status;
}
 80206ea:	4770      	bx	lr
//============================================================================

/* Function to read board ID from EEPROM
   !!! Only 32 bytes are reserved for the RF board ID */
RF_SHIELD_STATUS_t ds_eeprom_read_board_id(char *board_id, uint8_t id_size)
{
 80206ec:	b5f0      	push	{r4, r5, r6, r7, lr}
  {
	return RF_SHIELD_BOARD_INVALID_PARAM;
  }

  /* Clear the receive buffer */
  memset(buffer, 0, sizeof(buffer));
 80206ee:	2400      	movs	r4, #0
//============================================================================

/* Function to read board ID from EEPROM
   !!! Only 32 bytes are reserved for the RF board ID */
RF_SHIELD_STATUS_t ds_eeprom_read_board_id(char *board_id, uint8_t id_size)
{
 80206f0:	b089      	sub	sp, #36	; 0x24
 80206f2:	460f      	mov	r7, r1
 80206f4:	4605      	mov	r5, r0

  /* Clear the receive buffer */
  memset(buffer, 0, sizeof(buffer));

  /*  Read RF board ID from EEPROM and check if a valid board ID is written in EEPROM */
  if (bsp_eeprom_24cw128x_read_data(eeprom_address, buffer, id_size) == EEPROM_STATUS_SUCCESS)
 80206f6:	4669      	mov	r1, sp
 80206f8:	4620      	mov	r0, r4
 80206fa:	463a      	mov	r2, r7
  {
	return RF_SHIELD_BOARD_INVALID_PARAM;
  }

  /* Clear the receive buffer */
  memset(buffer, 0, sizeof(buffer));
 80206fc:	9400      	str	r4, [sp, #0]
 80206fe:	9401      	str	r4, [sp, #4]
 8020700:	9402      	str	r4, [sp, #8]
 8020702:	9403      	str	r4, [sp, #12]
 8020704:	9404      	str	r4, [sp, #16]
 8020706:	9405      	str	r4, [sp, #20]
 8020708:	9406      	str	r4, [sp, #24]
 802070a:	9407      	str	r4, [sp, #28]

  /*  Read RF board ID from EEPROM and check if a valid board ID is written in EEPROM */
  if (bsp_eeprom_24cw128x_read_data(eeprom_address, buffer, id_size) == EEPROM_STATUS_SUCCESS)
 802070c:	f008 fa06 	bl	8028b1c <bsp_eeprom_24cw128x_read_data>
 8020710:	2801      	cmp	r0, #1
 8020712:	d002      	beq.n	802071a <ds_eeprom_read_board_id+0x3a>
      }
    }while (index <= id_size);
  }
  else /* In case of I2C error */
  {
    shield_status = RF_SHIELD_BOARD_NOT_CONNECTED;
 8020714:	2005      	movs	r0, #5
  }

  return shield_status;
}
 8020716:	b009      	add	sp, #36	; 0x24
 8020718:	bdf0      	pop	{r4, r5, r6, r7, pc}
 802071a:	1c79      	adds	r1, r7, #1
 802071c:	4628      	mov	r0, r5

  /* Clear the receive buffer */
  memset(buffer, 0, sizeof(buffer));

  /*  Read RF board ID from EEPROM and check if a valid board ID is written in EEPROM */
  if (bsp_eeprom_24cw128x_read_data(eeprom_address, buffer, id_size) == EEPROM_STATUS_SUCCESS)
 802071e:	4623      	mov	r3, r4
 8020720:	b2c9      	uxtb	r1, r1
 8020722:	f10d 32ff 	add.w	r2, sp, #4294967295
 8020726:	e004      	b.n	8020732 <ds_eeprom_read_board_id+0x52>
      }
      else if (*id == buffer[index])
      {
        /* Go to the next char */
        id++;
        index++;
 8020728:	b2f3      	uxtb	r3, r6
    	  RF shield is not programmed or it contains invalid data */
          shield_status = RF_SHIELD_BOARD_NOT_PROGRAMMED;
    	}
        break;
      }
    }while (index <= id_size);
 802072a:	428b      	cmp	r3, r1
 802072c:	d0f2      	beq.n	8020714 <ds_eeprom_read_board_id+0x34>
  /*  Read RF board ID from EEPROM and check if a valid board ID is written in EEPROM */
  if (bsp_eeprom_24cw128x_read_data(eeprom_address, buffer, id_size) == EEPROM_STATUS_SUCCESS)
  {
    do
    {
      if ((index == id_size) && (*id == '\0'))
 802072e:	429f      	cmp	r7, r3
 8020730:	d00c      	beq.n	802074c <ds_eeprom_read_board_id+0x6c>
      {
        /* Valid board ID */
        shield_status = RF_SHIELD_BOARD_SUPPORTED;
        break;
      }
      else if (*id == buffer[index])
 8020732:	f810 4b01 	ldrb.w	r4, [r0], #1
 8020736:	f812 5f01 	ldrb.w	r5, [r2, #1]!
 802073a:	42a5      	cmp	r5, r4
      {
        /* Go to the next char */
        id++;
        index++;
 802073c:	f103 0601 	add.w	r6, r3, #1
      {
        /* Valid board ID */
        shield_status = RF_SHIELD_BOARD_SUPPORTED;
        break;
      }
      else if (*id == buffer[index])
 8020740:	d0f2      	beq.n	8020728 <ds_eeprom_read_board_id+0x48>
    	}
    	else
    	{
    	  /* Invalid RF shield board.
    	  RF shield is not programmed or it contains invalid data */
          shield_status = RF_SHIELD_BOARD_NOT_PROGRAMMED;
 8020742:	2b02      	cmp	r3, #2
 8020744:	bf8c      	ite	hi
 8020746:	2003      	movhi	r0, #3
 8020748:	2004      	movls	r0, #4
 802074a:	e7e4      	b.n	8020716 <ds_eeprom_read_board_id+0x36>
  /*  Read RF board ID from EEPROM and check if a valid board ID is written in EEPROM */
  if (bsp_eeprom_24cw128x_read_data(eeprom_address, buffer, id_size) == EEPROM_STATUS_SUCCESS)
  {
    do
    {
      if ((index == id_size) && (*id == '\0'))
 802074c:	7804      	ldrb	r4, [r0, #0]
 802074e:	2c00      	cmp	r4, #0
 8020750:	d1ef      	bne.n	8020732 <ds_eeprom_read_board_id+0x52>
      {
        /* Valid board ID */
        shield_status = RF_SHIELD_BOARD_SUPPORTED;
 8020752:	2002      	movs	r0, #2
 8020754:	e7df      	b.n	8020716 <ds_eeprom_read_board_id+0x36>
 8020756:	bf00      	nop

08020758 <ds_eeprom_write_inital_board_id>:
//============================================================================

/* TODO: remove for release! */

uint8_t ds_eeprom_write_inital_board_id(void)
{
 8020758:	b500      	push	{lr}
  uint8_t buffer[] = RF_BOARD_ID;
 802075a:	4b07      	ldr	r3, [pc, #28]	; (8020778 <ds_eeprom_write_inital_board_id+0x20>)
 802075c:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
//============================================================================

/* TODO: remove for release! */

uint8_t ds_eeprom_write_inital_board_id(void)
{
 8020760:	b085      	sub	sp, #20
  uint8_t buffer[] = RF_BOARD_ID;
 8020762:	ab01      	add	r3, sp, #4
 8020764:	c303      	stmia	r3!, {r0, r1}

  /* Read RF board ID from EEPROM */
  return bsp_eeprom_24cw128x_write_data(DS_EEPROM_ADDRESS_BOARD_ID, buffer, sizeof(buffer));
 8020766:	a901      	add	r1, sp, #4

/* TODO: remove for release! */

uint8_t ds_eeprom_write_inital_board_id(void)
{
  uint8_t buffer[] = RF_BOARD_ID;
 8020768:	701a      	strb	r2, [r3, #0]

  /* Read RF board ID from EEPROM */
  return bsp_eeprom_24cw128x_write_data(DS_EEPROM_ADDRESS_BOARD_ID, buffer, sizeof(buffer));
 802076a:	2000      	movs	r0, #0
 802076c:	2209      	movs	r2, #9
 802076e:	f008 f89b 	bl	80288a8 <bsp_eeprom_24cw128x_write_data>
}
 8020772:	b005      	add	sp, #20
 8020774:	f85d fb04 	ldr.w	pc, [sp], #4
 8020778:	0802f068 	.word	0x0802f068

0802077c <ds_ep_get_device_info>:
//============================================================================

const Device_Info_t *ds_ep_get_device_info(void)
{
	return (&cg_device_info_struct);
}
 802077c:	4800      	ldr	r0, [pc, #0]	; (8020780 <ds_ep_get_device_info+0x4>)
 802077e:	4770      	bx	lr
 8020780:	0802f0a0 	.word	0x0802f0a0

08020784 <ds_ep_fetch_frame_format>:

//============================================================================

void ds_ep_fetch_frame_format(Frame_Format_t *p_frame_format)
{
 8020784:	b510      	push	{r4, lr}
 8020786:	4604      	mov	r4, r0
	device_settings_t *p_dev              = ds_device_get_settings();
 8020788:	f7ff fcb8 	bl	80200fc <ds_device_get_settings>
	p_frame_format->num_samples_per_chirp = p_dev->num_samples_per_chirp;
	p_frame_format->num_chirps_per_frame  = p_dev->num_of_chirps_per_frame;
 802078c:	69c2      	ldr	r2, [r0, #28]
//============================================================================

void ds_ep_fetch_frame_format(Frame_Format_t *p_frame_format)
{
	device_settings_t *p_dev              = ds_device_get_settings();
	p_frame_format->num_samples_per_chirp = p_dev->num_samples_per_chirp;
 802078e:	6a41      	ldr	r1, [r0, #36]	; 0x24
	p_frame_format->num_chirps_per_frame  = p_dev->num_of_chirps_per_frame;
 8020790:	e884 0006 	stmia.w	r4, {r1, r2}
	p_frame_format->rx_mask               = p_dev->rx_antenna_mask;
 8020794:	f890 2028 	ldrb.w	r2, [r0, #40]	; 0x28
 8020798:	7222      	strb	r2, [r4, #8]
	p_frame_format->signal_part           = RADAR_SIGNAL_I_AND_Q;
 802079a:	2302      	movs	r3, #2
 802079c:	7263      	strb	r3, [r4, #9]
 802079e:	bd10      	pop	{r4, pc}

080207a0 <SystemCoreClockUpdate>:
  uint32_t pdiv;
  uint32_t ndiv;
  uint32_t kdiv;
  uint32_t temp;

  if (SCU_CLK->SYSCLKCR & SCU_CLK_SYSCLKCR_SYSSEL_Msk)
 80207a0:	4b1c      	ldr	r3, [pc, #112]	; (8020814 <SystemCoreClockUpdate+0x74>)
 80207a2:	68db      	ldr	r3, [r3, #12]
 80207a4:	03d9      	lsls	r1, r3, #15

  SystemCoreClockUpdate();
}

__WEAK void SystemCoreClockUpdate(void)
{
 80207a6:	b510      	push	{r4, lr}
  uint32_t pdiv;
  uint32_t ndiv;
  uint32_t kdiv;
  uint32_t temp;

  if (SCU_CLK->SYSCLKCR & SCU_CLK_SYSCLKCR_SYSSEL_Msk)
 80207a8:	d51d      	bpl.n	80207e6 <SystemCoreClockUpdate+0x46>
  {
    /* fPLL is clock source for fSYS */
    if(SCU_PLL->PLLCON2 & SCU_PLL_PLLCON2_PINSEL_Msk)
 80207aa:	4b1b      	ldr	r3, [pc, #108]	; (8020818 <SystemCoreClockUpdate+0x78>)
 80207ac:	68db      	ldr	r3, [r3, #12]
 80207ae:	07da      	lsls	r2, r3, #31
 80207b0:	d52c      	bpl.n	802080c <SystemCoreClockUpdate+0x6c>
    {
      /* PLL input clock is the backup clock (fOFI) */
      temp = OFI_FREQUENCY;
 80207b2:	481a      	ldr	r0, [pc, #104]	; (802081c <SystemCoreClockUpdate+0x7c>)
      /* PLL input clock is the high performance osicllator (fOSCHP) */
      temp = OSCHP_GetFrequency();
    }

    /* check if PLL is locked */
    if (SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_VCOLOCK_Msk)
 80207b4:	4a18      	ldr	r2, [pc, #96]	; (8020818 <SystemCoreClockUpdate+0x78>)
 80207b6:	6813      	ldr	r3, [r2, #0]
 80207b8:	075b      	lsls	r3, r3, #29
 80207ba:	d416      	bmi.n	80207ea <SystemCoreClockUpdate+0x4a>
    }
    else
    {
      /* PLL prescalar mode */
      /* read back divider settings */
      kdiv  = ((SCU_PLL->PLLCON1 & SCU_PLL_PLLCON1_K1DIV_Msk) >> SCU_PLL_PLLCON1_K1DIV_Pos) + 1;
 80207bc:	6893      	ldr	r3, [r2, #8]
 80207be:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 80207c2:	3301      	adds	r3, #1
      
      temp = (temp / kdiv);
 80207c4:	fbb0 f3f3 	udiv	r3, r0, r3
  {
    /* fOFI is clock source for fSYS */    
    temp = OFI_FREQUENCY;
  }

  temp = temp / ((SCU_CLK->SYSCLKCR & SCU_CLK_SYSCLKCR_SYSDIV_Msk) + 1);
 80207c8:	4a12      	ldr	r2, [pc, #72]	; (8020814 <SystemCoreClockUpdate+0x74>)
  temp = temp / ((SCU_CLK->CPUCLKCR & SCU_CLK_CPUCLKCR_CPUDIV_Msk) + 1);

  SystemCoreClock = temp;
 80207ca:	4915      	ldr	r1, [pc, #84]	; (8020820 <SystemCoreClockUpdate+0x80>)
  {
    /* fOFI is clock source for fSYS */    
    temp = OFI_FREQUENCY;
  }

  temp = temp / ((SCU_CLK->SYSCLKCR & SCU_CLK_SYSCLKCR_SYSDIV_Msk) + 1);
 80207cc:	68d0      	ldr	r0, [r2, #12]
  temp = temp / ((SCU_CLK->CPUCLKCR & SCU_CLK_CPUCLKCR_CPUDIV_Msk) + 1);
 80207ce:	6912      	ldr	r2, [r2, #16]
  {
    /* fOFI is clock source for fSYS */    
    temp = OFI_FREQUENCY;
  }

  temp = temp / ((SCU_CLK->SYSCLKCR & SCU_CLK_SYSCLKCR_SYSDIV_Msk) + 1);
 80207d0:	b2c0      	uxtb	r0, r0
  temp = temp / ((SCU_CLK->CPUCLKCR & SCU_CLK_CPUCLKCR_CPUDIV_Msk) + 1);
 80207d2:	f002 0201 	and.w	r2, r2, #1
  {
    /* fOFI is clock source for fSYS */    
    temp = OFI_FREQUENCY;
  }

  temp = temp / ((SCU_CLK->SYSCLKCR & SCU_CLK_SYSCLKCR_SYSDIV_Msk) + 1);
 80207d6:	3001      	adds	r0, #1
  temp = temp / ((SCU_CLK->CPUCLKCR & SCU_CLK_CPUCLKCR_CPUDIV_Msk) + 1);
 80207d8:	3201      	adds	r2, #1
  {
    /* fOFI is clock source for fSYS */    
    temp = OFI_FREQUENCY;
  }

  temp = temp / ((SCU_CLK->SYSCLKCR & SCU_CLK_SYSCLKCR_SYSDIV_Msk) + 1);
 80207da:	fbb3 f0f0 	udiv	r0, r3, r0
  temp = temp / ((SCU_CLK->CPUCLKCR & SCU_CLK_CPUCLKCR_CPUDIV_Msk) + 1);
 80207de:	fbb0 f0f2 	udiv	r0, r0, r2

  SystemCoreClock = temp;
 80207e2:	6008      	str	r0, [r1, #0]
 80207e4:	bd10      	pop	{r4, pc}
    }
  }
  else
  {
    /* fOFI is clock source for fSYS */    
    temp = OFI_FREQUENCY;
 80207e6:	4b0d      	ldr	r3, [pc, #52]	; (802081c <SystemCoreClockUpdate+0x7c>)
 80207e8:	e7ee      	b.n	80207c8 <SystemCoreClockUpdate+0x28>
    /* check if PLL is locked */
    if (SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_VCOLOCK_Msk)
    {
      /* PLL normal mode */
      /* read back divider settings */
      pdiv = ((SCU_PLL->PLLCON1 & SCU_PLL_PLLCON1_PDIV_Msk) >> SCU_PLL_PLLCON1_PDIV_Pos) + 1;
 80207ea:	6891      	ldr	r1, [r2, #8]
      ndiv = ((SCU_PLL->PLLCON1 & SCU_PLL_PLLCON1_NDIV_Msk) >> SCU_PLL_PLLCON1_NDIV_Pos) + 1;
 80207ec:	6893      	ldr	r3, [r2, #8]
      kdiv = ((SCU_PLL->PLLCON1 & SCU_PLL_PLLCON1_K2DIV_Msk) >> SCU_PLL_PLLCON1_K2DIV_Pos) + 1;
 80207ee:	6894      	ldr	r4, [r2, #8]
    /* check if PLL is locked */
    if (SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_VCOLOCK_Msk)
    {
      /* PLL normal mode */
      /* read back divider settings */
      pdiv = ((SCU_PLL->PLLCON1 & SCU_PLL_PLLCON1_PDIV_Msk) >> SCU_PLL_PLLCON1_PDIV_Pos) + 1;
 80207f0:	f3c1 6203 	ubfx	r2, r1, #24, #4
 80207f4:	3201      	adds	r2, #1
      ndiv = ((SCU_PLL->PLLCON1 & SCU_PLL_PLLCON1_NDIV_Msk) >> SCU_PLL_PLLCON1_NDIV_Pos) + 1;
      kdiv = ((SCU_PLL->PLLCON1 & SCU_PLL_PLLCON1_K2DIV_Msk) >> SCU_PLL_PLLCON1_K2DIV_Pos) + 1;
 80207f6:	f3c4 4106 	ubfx	r1, r4, #16, #7
    if (SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_VCOLOCK_Msk)
    {
      /* PLL normal mode */
      /* read back divider settings */
      pdiv = ((SCU_PLL->PLLCON1 & SCU_PLL_PLLCON1_PDIV_Msk) >> SCU_PLL_PLLCON1_PDIV_Pos) + 1;
      ndiv = ((SCU_PLL->PLLCON1 & SCU_PLL_PLLCON1_NDIV_Msk) >> SCU_PLL_PLLCON1_NDIV_Pos) + 1;
 80207fa:	f3c3 2306 	ubfx	r3, r3, #8, #7
      kdiv = ((SCU_PLL->PLLCON1 & SCU_PLL_PLLCON1_K2DIV_Msk) >> SCU_PLL_PLLCON1_K2DIV_Pos) + 1;

      temp = (temp / (pdiv * kdiv)) * ndiv;
 80207fe:	fb01 2202 	mla	r2, r1, r2, r2
 8020802:	fbb0 f0f2 	udiv	r0, r0, r2
 8020806:	fb03 0300 	mla	r3, r3, r0, r0
 802080a:	e7dd      	b.n	80207c8 <SystemCoreClockUpdate+0x28>
      temp = OFI_FREQUENCY;
    }
    else
    {
      /* PLL input clock is the high performance osicllator (fOSCHP) */
      temp = OSCHP_GetFrequency();
 802080c:	f007 f948 	bl	8027aa0 <OSCHP_GetFrequency>
 8020810:	e7d0      	b.n	80207b4 <SystemCoreClockUpdate+0x14>
 8020812:	bf00      	nop
 8020814:	50004600 	.word	0x50004600
 8020818:	50004710 	.word	0x50004710
 802081c:	016e3600 	.word	0x016e3600
 8020820:	2003ffc0 	.word	0x2003ffc0

08020824 <SystemInit>:
/*******************************************************************************
 * API IMPLEMENTATION
 *******************************************************************************/

__WEAK void SystemInit(void)
{
 8020824:	b510      	push	{r4, lr}
  memcpy(g_chipid, CHIPID_LOC, 16);
 8020826:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
 802082a:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 802082c:	4c03      	ldr	r4, [pc, #12]	; (802083c <SystemInit+0x18>)
 802082e:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
  
  SystemCoreSetup();
 8020832:	f006 f891 	bl	8026958 <SystemCoreSetup>
  SystemCoreClockSetup(); 
 8020836:	f007 f937 	bl	8027aa8 <SystemCoreClockSetup>
 802083a:	bd10      	pop	{r4, pc}
 802083c:	2003ffc4 	.word	0x2003ffc4

08020840 <get_buffer_address_by_chirp>:

uint8_t *get_buffer_address_by_chirp(acq_buf_obj *p_obj, uint32_t channel_index, uint32_t chirpCnt)
{
  size_t offset = 0;
  
  if (p_obj->p_acq_buf == NULL)
 8020840:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8020842:	b173      	cbz	r3, 8020862 <get_buffer_address_by_chirp+0x22>
   6. EXPORTED FUNCTIONS
==============================================================================
 */

uint8_t *get_buffer_address_by_chirp(acq_buf_obj *p_obj, uint32_t channel_index, uint32_t chirpCnt)
{
 8020844:	b470      	push	{r4, r5, r6}
 8020846:	88c5      	ldrh	r5, [r0, #6]
  
  if (p_obj->p_acq_buf == NULL)
    return NULL;
  
  // since the chirps are interleaved, we calculate the buffer base address for a new chirp and the related channel here:
  offset = (p_obj->internals.chirp_inc * chirpCnt) + (p_obj->internals.channel_inc * channel_index);
 8020848:	6944      	ldr	r4, [r0, #20]
 802084a:	6906      	ldr	r6, [r0, #16]
 802084c:	42a9      	cmp	r1, r5
 802084e:	fb04 f001 	mul.w	r0, r4, r1
 8020852:	fb06 0202 	mla	r2, r6, r2, r0
 8020856:	d300      	bcc.n	802085a <get_buffer_address_by_chirp+0x1a>
 8020858:	e7fe      	b.n	8020858 <get_buffer_address_by_chirp+0x18>
  
  /*TODO: Throw some error, if channel_index is larger then the internal number of channels! */
  while (channel_index >= p_obj->params.num_of_rx_values);

  return &p_obj->p_acq_buf[offset];
 802085a:	4413      	add	r3, r2
}
 802085c:	4618      	mov	r0, r3
 802085e:	bc70      	pop	{r4, r5, r6}
 8020860:	4770      	bx	lr
 8020862:	4618      	mov	r0, r3
 8020864:	4770      	bx	lr
 8020866:	bf00      	nop

08020868 <create_acq_data_buffer_obj>:

acq_buf_obj create_acq_data_buffer_obj(uint8_t *p_allocated_buffer, size_t allocated_buffer_size,
                                       uint16_t max_num_of_chirps_per_frame, uint16_t max_num_of_samples_per_chirp,
                                       uint16_t max_num_of_adc_channels, uint16_t adc_resolution,
                                       uint32_t num_sample_skip_count)
{
 8020868:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 802086c:	f8bd 6020 	ldrh.w	r6, [sp, #32]
 8020870:	f8bd c018 	ldrh.w	ip, [sp, #24]
 8020874:	f8bd e01c 	ldrh.w	lr, [sp, #28]
 8020878:	9d09      	ldr	r5, [sp, #36]	; 0x24
  
  obj.status = allocation_ok;
  obj.access_lock = 0;
  obj.acq_timestime = 0;
  obj.internals.is_dynamic_allocated = 0;
  obj.internals.skip_count = num_sample_skip_count;
 802087a:	61c5      	str	r5, [r0, #28]
                                       uint16_t max_num_of_adc_channels, uint16_t adc_resolution,
                                       uint32_t num_sample_skip_count)
{
  acq_buf_obj obj;
  size_t required_size = 0;
  size_t value_size = ((adc_resolution - 1) / 8 ) + 1;
 802087c:	1e74      	subs	r4, r6, #1
 802087e:	bf48      	it	mi
 8020880:	1db4      	addmi	r4, r6, #6
 8020882:	10e4      	asrs	r4, r4, #3
  }
#endif
  
  // calculate the size of allocation buffer
  // consider that an internal acquisition buffer needs to be uint32_t bit aligned on ARM!
  required_size = obj.params.num_of_chirps_per_frame * obj.params.num_of_samples_per_chirp * obj.params.num_of_rx_values * obj.params.size_of_value_in_bytes;
 8020884:	fb0c f703 	mul.w	r7, ip, r3
                                       uint16_t max_num_of_adc_channels, uint16_t adc_resolution,
                                       uint32_t num_sample_skip_count)
{
  acq_buf_obj obj;
  size_t required_size = 0;
  size_t value_size = ((adc_resolution - 1) / 8 ) + 1;
 8020888:	3401      	adds	r4, #1
  }
#endif
  
  // calculate the size of allocation buffer
  // consider that an internal acquisition buffer needs to be uint32_t bit aligned on ARM!
  required_size = obj.params.num_of_chirps_per_frame * obj.params.num_of_samples_per_chirp * obj.params.num_of_rx_values * obj.params.size_of_value_in_bytes;
 802088a:	fb0e f707 	mul.w	r7, lr, r7
  acq_buf_obj obj;
  size_t required_size = 0;
  size_t value_size = ((adc_resolution - 1) / 8 ) + 1;
  
  obj.status = allocation_ok;
  obj.access_lock = 0;
 802088e:	2600      	movs	r6, #0
  }
#endif
  
  // calculate the size of allocation buffer
  // consider that an internal acquisition buffer needs to be uint32_t bit aligned on ARM!
  required_size = obj.params.num_of_chirps_per_frame * obj.params.num_of_samples_per_chirp * obj.params.num_of_rx_values * obj.params.size_of_value_in_bytes;
 8020890:	fb07 f704 	mul.w	r7, r7, r4
{
  acq_buf_obj obj;
  size_t required_size = 0;
  size_t value_size = ((adc_resolution - 1) / 8 ) + 1;
  
  obj.status = allocation_ok;
 8020894:	f04f 0801 	mov.w	r8, #1
  
  obj.p_acq_buf = p_allocated_buffer;
  obj.internals.size_of_acq_buffer = allocated_buffer_size;
  obj.used_size_of_acq_buffer = required_size;
  
  if (max_num_of_adc_channels > MAX_SUPPORTED_RX_SIGNALS_INT)
 8020898:	f1be 0f04 	cmp.w	lr, #4
  obj.internals.skip_count = num_sample_skip_count;
  
  obj.params.num_of_chirps_per_frame = max_num_of_chirps_per_frame;
  obj.params.num_of_samples_per_chirp = max_num_of_samples_per_chirp;
  obj.params.num_of_rx_values = max_num_of_adc_channels;
  obj.params.size_of_value_in_bytes = value_size;
 802089c:	8104      	strh	r4, [r0, #8]
  obj.access_lock = 0;
  obj.acq_timestime = 0;
  obj.internals.is_dynamic_allocated = 0;
  obj.internals.skip_count = num_sample_skip_count;
  
  obj.params.num_of_chirps_per_frame = max_num_of_chirps_per_frame;
 802089e:	8083      	strh	r3, [r0, #4]
  // consider that an internal acquisition buffer needs to be uint32_t bit aligned on ARM!
  required_size = obj.params.num_of_chirps_per_frame * obj.params.num_of_samples_per_chirp * obj.params.num_of_rx_values * obj.params.size_of_value_in_bytes;
  
  obj.p_acq_buf = p_allocated_buffer;
  obj.internals.size_of_acq_buffer = allocated_buffer_size;
  obj.used_size_of_acq_buffer = required_size;
 80208a0:	6207      	str	r7, [r0, #32]
  obj.acq_timestime = 0;
  obj.internals.is_dynamic_allocated = 0;
  obj.internals.skip_count = num_sample_skip_count;
  
  obj.params.num_of_chirps_per_frame = max_num_of_chirps_per_frame;
  obj.params.num_of_samples_per_chirp = max_num_of_samples_per_chirp;
 80208a2:	f8a0 c002 	strh.w	ip, [r0, #2]
  obj.params.num_of_rx_values = max_num_of_adc_channels;
 80208a6:	f8a0 e006 	strh.w	lr, [r0, #6]
  
  // calculate the size of allocation buffer
  // consider that an internal acquisition buffer needs to be uint32_t bit aligned on ARM!
  required_size = obj.params.num_of_chirps_per_frame * obj.params.num_of_samples_per_chirp * obj.params.num_of_rx_values * obj.params.size_of_value_in_bytes;
  
  obj.p_acq_buf = p_allocated_buffer;
 80208aa:	62c1      	str	r1, [r0, #44]	; 0x2c
  obj.internals.size_of_acq_buffer = allocated_buffer_size;
 80208ac:	60c2      	str	r2, [r0, #12]
{
  acq_buf_obj obj;
  size_t required_size = 0;
  size_t value_size = ((adc_resolution - 1) / 8 ) + 1;
  
  obj.status = allocation_ok;
 80208ae:	f880 8030 	strb.w	r8, [r0, #48]	; 0x30
  obj.access_lock = 0;
 80208b2:	6286      	str	r6, [r0, #40]	; 0x28
  obj.acq_timestime = 0;
 80208b4:	6246      	str	r6, [r0, #36]	; 0x24
  obj.internals.is_dynamic_allocated = 0;
 80208b6:	6186      	str	r6, [r0, #24]
  obj.params.num_of_chirps_per_frame = max_num_of_chirps_per_frame;
  obj.params.num_of_samples_per_chirp = max_num_of_samples_per_chirp;
  obj.params.num_of_rx_values = max_num_of_adc_channels;
  obj.params.size_of_value_in_bytes = value_size;
  
  obj.data_type = data_type_unknown;
 80208b8:	7006      	strb	r6, [r0, #0]
  
  obj.p_acq_buf = p_allocated_buffer;
  obj.internals.size_of_acq_buffer = allocated_buffer_size;
  obj.used_size_of_acq_buffer = required_size;
  
  if (max_num_of_adc_channels > MAX_SUPPORTED_RX_SIGNALS_INT)
 80208ba:	d81b      	bhi.n	80208f4 <create_acq_data_buffer_obj+0x8c>
    obj.internals.size_of_acq_buffer = 0;
    obj.used_size_of_acq_buffer = 0;
    return obj;
  }
  
  if (p_allocated_buffer != NULL && allocated_buffer_size == 0)
 80208bc:	b351      	cbz	r1, 8020914 <create_acq_data_buffer_obj+0xac>
 80208be:	b18a      	cbz	r2, 80208e4 <create_acq_data_buffer_obj+0x7c>
    obj.internals.size_of_acq_buffer = 0;
    obj.used_size_of_acq_buffer = 0;
    return obj;
  }
  
  if (((obj.p_acq_buf != NULL) && (obj.internals.size_of_acq_buffer != 0)) && obj.internals.size_of_acq_buffer < required_size)
 80208c0:	4297      	cmp	r7, r2
 80208c2:	d81f      	bhi.n	8020904 <create_acq_data_buffer_obj+0x9c>
  obj.internals.channel_inc = obj.params.num_of_samples_per_chirp * obj.params.size_of_value_in_bytes;
  obj.internals.chirp_inc   = obj.internals.channel_inc * obj.params.num_of_rx_values;
  
  if (obj.p_acq_buf != NULL)
  {
    memset(obj.p_acq_buf, 0, sizeof(obj.used_size_of_acq_buffer));
 80208c4:	460b      	mov	r3, r1
    }
  }
#endif
  
  // calculated internal buffer offsets
  obj.internals.channel_inc = obj.params.num_of_samples_per_chirp * obj.params.size_of_value_in_bytes;
 80208c6:	fb0c f404 	mul.w	r4, ip, r4
  obj.internals.chirp_inc   = obj.internals.channel_inc * obj.params.num_of_rx_values;
  
  if (obj.p_acq_buf != NULL)
  {
    memset(obj.p_acq_buf, 0, sizeof(obj.used_size_of_acq_buffer));
 80208ca:	f803 6b01 	strb.w	r6, [r3], #1
 80208ce:	3301      	adds	r3, #1
 80208d0:	704e      	strb	r6, [r1, #1]
 80208d2:	f803 6b01 	strb.w	r6, [r3], #1
  }
#endif
  
  // calculated internal buffer offsets
  obj.internals.channel_inc = obj.params.num_of_samples_per_chirp * obj.params.size_of_value_in_bytes;
  obj.internals.chirp_inc   = obj.internals.channel_inc * obj.params.num_of_rx_values;
 80208d6:	fb0e f204 	mul.w	r2, lr, r4
  
  if (obj.p_acq_buf != NULL)
  {
    memset(obj.p_acq_buf, 0, sizeof(obj.used_size_of_acq_buffer));
 80208da:	701e      	strb	r6, [r3, #0]
  }
#endif
  
  // calculated internal buffer offsets
  obj.internals.channel_inc = obj.params.num_of_samples_per_chirp * obj.params.size_of_value_in_bytes;
  obj.internals.chirp_inc   = obj.internals.channel_inc * obj.params.num_of_rx_values;
 80208dc:	6102      	str	r2, [r0, #16]
    }
  }
#endif
  
  // calculated internal buffer offsets
  obj.internals.channel_inc = obj.params.num_of_samples_per_chirp * obj.params.size_of_value_in_bytes;
 80208de:	6144      	str	r4, [r0, #20]
 80208e0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    return obj;
  }
  
  if (p_allocated_buffer != NULL && allocated_buffer_size == 0)
  {
    obj.status = allocation_size_is_zero;
 80208e4:	2304      	movs	r3, #4
    obj.p_acq_buf = NULL;
 80208e6:	62c2      	str	r2, [r0, #44]	; 0x2c
    obj.internals.size_of_acq_buffer = 0;
 80208e8:	60c2      	str	r2, [r0, #12]
    obj.used_size_of_acq_buffer = 0;
 80208ea:	6202      	str	r2, [r0, #32]
    return obj;
  }
  
  if (p_allocated_buffer != NULL && allocated_buffer_size == 0)
  {
    obj.status = allocation_size_is_zero;
 80208ec:	f880 3030 	strb.w	r3, [r0, #48]	; 0x30
    obj.p_acq_buf = NULL;
    obj.internals.size_of_acq_buffer = 0;
    obj.used_size_of_acq_buffer = 0;
    return obj;
 80208f0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  obj.internals.size_of_acq_buffer = allocated_buffer_size;
  obj.used_size_of_acq_buffer = required_size;
  
  if (max_num_of_adc_channels > MAX_SUPPORTED_RX_SIGNALS_INT)
  {
    obj.status = num_of_RX_not_supported;
 80208f4:	2305      	movs	r3, #5
    obj.p_acq_buf = NULL;
 80208f6:	62c6      	str	r6, [r0, #44]	; 0x2c
    obj.internals.size_of_acq_buffer = 0;
 80208f8:	60c6      	str	r6, [r0, #12]
    obj.used_size_of_acq_buffer = 0;
 80208fa:	6206      	str	r6, [r0, #32]
  obj.internals.size_of_acq_buffer = allocated_buffer_size;
  obj.used_size_of_acq_buffer = required_size;
  
  if (max_num_of_adc_channels > MAX_SUPPORTED_RX_SIGNALS_INT)
  {
    obj.status = num_of_RX_not_supported;
 80208fc:	f880 3030 	strb.w	r3, [r0, #48]	; 0x30
    obj.p_acq_buf = NULL;
    obj.internals.size_of_acq_buffer = 0;
    obj.used_size_of_acq_buffer = 0;
    return obj;
 8020900:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    return obj;
  }
  
  if (((obj.p_acq_buf != NULL) && (obj.internals.size_of_acq_buffer != 0)) && obj.internals.size_of_acq_buffer < required_size)
  {
    obj.status = allocation_buffer_too_small;
 8020904:	2303      	movs	r3, #3
    obj.p_acq_buf = NULL;
 8020906:	62c6      	str	r6, [r0, #44]	; 0x2c
    obj.internals.size_of_acq_buffer = 0;
 8020908:	60c6      	str	r6, [r0, #12]
    obj.used_size_of_acq_buffer = 0;
 802090a:	6206      	str	r6, [r0, #32]
    return obj;
  }
  
  if (((obj.p_acq_buf != NULL) && (obj.internals.size_of_acq_buffer != 0)) && obj.internals.size_of_acq_buffer < required_size)
  {
    obj.status = allocation_buffer_too_small;
 802090c:	f880 3030 	strb.w	r3, [r0, #48]	; 0x30
    obj.p_acq_buf = NULL;
    obj.internals.size_of_acq_buffer = 0;
    obj.used_size_of_acq_buffer = 0;
    return obj;
 8020910:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    }
  }
#endif
  
  // calculated internal buffer offsets
  obj.internals.channel_inc = obj.params.num_of_samples_per_chirp * obj.params.size_of_value_in_bytes;
 8020914:	fb0c f404 	mul.w	r4, ip, r4
  obj.internals.chirp_inc   = obj.internals.channel_inc * obj.params.num_of_rx_values;
 8020918:	fb0e f304 	mul.w	r3, lr, r4
 802091c:	6103      	str	r3, [r0, #16]
    }
  }
#endif
  
  // calculated internal buffer offsets
  obj.internals.channel_inc = obj.params.num_of_samples_per_chirp * obj.params.size_of_value_in_bytes;
 802091e:	6144      	str	r4, [r0, #20]
  {
    memset(obj.p_acq_buf, 0, sizeof(obj.used_size_of_acq_buffer));
  }
  
  return obj;
}
 8020920:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08020924 <delete_acq_buffer_obj>:

//============================================================================

void delete_acq_buffer_obj(acq_buf_obj *p_obj)
{
  p_obj->status = allocation_is_freed;
 8020924:	2206      	movs	r2, #6
  p_obj->used_size_of_acq_buffer = 0;
 8020926:	2300      	movs	r3, #0

//============================================================================

void delete_acq_buffer_obj(acq_buf_obj *p_obj)
{
  p_obj->status = allocation_is_freed;
 8020928:	f880 2030 	strb.w	r2, [r0, #48]	; 0x30
  p_obj->used_size_of_acq_buffer = 0;
 802092c:	6203      	str	r3, [r0, #32]
 802092e:	4770      	bx	lr

08020930 <radar_open_device>:
}

//============================================================================

uint16_t radar_open_device(int32_t device_number, Radar_Handle_t* device)
{
 8020930:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint16_t retval = RADAR_ERR_OK;
  int32_t status = 0;
  acq_buf_obj acq_buf = { .status = not_initialized } ;

  /* Initialize the driver instance with NULL, until it was successfully initialized */
  if (device)
 8020932:	460c      	mov	r4, r1
}

//============================================================================

uint16_t radar_open_device(int32_t device_number, Radar_Handle_t* device)
{
 8020934:	b09d      	sub	sp, #116	; 0x74
  uint16_t retval = RADAR_ERR_OK;
  int32_t status = 0;
  acq_buf_obj acq_buf = { .status = not_initialized } ;

  /* Initialize the driver instance with NULL, until it was successfully initialized */
  if (device)
 8020936:	b109      	cbz	r1, 802093c <radar_open_device+0xc>
	  (*device = NULL);
 8020938:	2300      	movs	r3, #0
 802093a:	600b      	str	r3, [r1, #0]

  /* Initialize driver data structure */
  /* -------------------------------- */
  status = ds_init();
 802093c:	f7ff fc1c 	bl	8020178 <ds_init>
  if (status > 0)
 8020940:	2800      	cmp	r0, #0
  {
    return (RADAR_ERR_INIT_ERROR);
 8020942:	bfc8      	it	gt
 8020944:	f44f 7080 	movgt.w	r0, #256	; 0x100
	  (*device = NULL);

  /* Initialize driver data structure */
  /* -------------------------------- */
  status = ds_init();
  if (status > 0)
 8020948:	dd01      	ble.n	802094e <radar_open_device+0x1e>
  retval = radar_init(device);
  
  g_adc_sampling_completed = false;

  return (retval);
}
 802094a:	b01d      	add	sp, #116	; 0x74
 802094c:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if (status > 0)
  {
    return (RADAR_ERR_INIT_ERROR);
  }

  device_settings_t *pDev = ds_device_get_settings();
 802094e:	f7ff fbd5 	bl	80200fc <ds_device_get_settings>
 8020952:	4605      	mov	r5, r0
  
  //========================================================================
  //------------------------- Frame Format configurations ------------------
  //========================================================================
  ds_ep_fetch_frame_format(&frame_format);
 8020954:	a80b      	add	r0, sp, #44	; 0x2c
 8020956:	f7ff ff15 	bl	8020784 <ds_ep_fetch_frame_format>


  //=========================================================================
  //------------------------- General configurations ------------------------
  //=========================================================================
  radar_set_data_acq_mode(RADAR_MANUAL_TRIGGER_MODE);
 802095a:	2000      	movs	r0, #0
 802095c:	f000 f92c 	bl	8020bb8 <radar_set_data_acq_mode>
  
  /* If the frame format contains a 0, this makes no sense. */
  if ((frame_format.rx_mask == 0) ||
 8020960:	f89d 3034 	ldrb.w	r3, [sp, #52]	; 0x34
 8020964:	b90b      	cbnz	r3, 802096a <radar_open_device+0x3a>
          (frame_format.num_chirps_per_frame  > BSP_MAX_NUM_CHIRPS_PER_FRAME) ||
            (frame_format.num_samples_per_chirp > BSP_MAX_NUM_SAMPLES_PER_CHIRP) ||
			(frame_format.num_samples_per_chirp < BSP_MIN_NUM_SAMPLES_PER_CHIRP)
			)
  {
    return (RADAR_ERR_UNSUPPORTED_FRAME_FORMAT);
 8020966:	2008      	movs	r0, #8
 8020968:	e7ef      	b.n	802094a <radar_open_device+0x1a>
  //=========================================================================
  radar_set_data_acq_mode(RADAR_MANUAL_TRIGGER_MODE);
  
  /* If the frame format contains a 0, this makes no sense. */
  if ((frame_format.rx_mask == 0) ||
      (frame_format.num_chirps_per_frame  == 0) ||
 802096a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  //------------------------- General configurations ------------------------
  //=========================================================================
  radar_set_data_acq_mode(RADAR_MANUAL_TRIGGER_MODE);
  
  /* If the frame format contains a 0, this makes no sense. */
  if ((frame_format.rx_mask == 0) ||
 802096c:	2b00      	cmp	r3, #0
 802096e:	d0fa      	beq.n	8020966 <radar_open_device+0x36>
      (frame_format.num_chirps_per_frame  == 0) ||
        (frame_format.num_samples_per_chirp == 0) ||
 8020970:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
  //=========================================================================
  radar_set_data_acq_mode(RADAR_MANUAL_TRIGGER_MODE);
  
  /* If the frame format contains a 0, this makes no sense. */
  if ((frame_format.rx_mask == 0) ||
      (frame_format.num_chirps_per_frame  == 0) ||
 8020972:	f1a6 0220 	sub.w	r2, r6, #32
 8020976:	2ae0      	cmp	r2, #224	; 0xe0
 8020978:	d8f5      	bhi.n	8020966 <radar_open_device+0x36>
        (frame_format.num_samples_per_chirp == 0) ||
 802097a:	2b01      	cmp	r3, #1
 802097c:	d8f3      	bhi.n	8020966 <radar_open_device+0x36>
  }
  
  /* Check frame memory limits */
  /* ------------------------- */
  frame_size = frame_format.num_chirps_per_frame * frame_format.num_samples_per_chirp *
    ds_ep_get_device_info()->num_rx_antennas * 2U * sizeof(uint16_t); // complex IQ samples per antenna
 802097e:	f7ff fefd 	bl	802077c <ds_ep_get_device_info>
    return (RADAR_ERR_UNSUPPORTED_FRAME_FORMAT);
  }
  
  /* Check frame memory limits */
  /* ------------------------- */
  frame_size = frame_format.num_chirps_per_frame * frame_format.num_samples_per_chirp *
 8020982:	7b43      	ldrb	r3, [r0, #13]
 8020984:	4a17      	ldr	r2, [pc, #92]	; (80209e4 <radar_open_device+0xb4>)
 8020986:	00b6      	lsls	r6, r6, #2
    ds_ep_get_device_info()->num_rx_antennas * 2U * sizeof(uint16_t); // complex IQ samples per antenna
 8020988:	fb03 f606 	mul.w	r6, r3, r6
  
  if (frame_size > BSP_MAX_ADC_BUFFER_SIZE_BYTES)
 802098c:	f5b6 5f80 	cmp.w	r6, #4096	; 0x1000
    return (RADAR_ERR_UNSUPPORTED_FRAME_FORMAT);
  }
  
  /* Check frame memory limits */
  /* ------------------------- */
  frame_size = frame_format.num_chirps_per_frame * frame_format.num_samples_per_chirp *
 8020990:	6016      	str	r6, [r2, #0]
    ds_ep_get_device_info()->num_rx_antennas * 2U * sizeof(uint16_t); // complex IQ samples per antenna
  
  if (frame_size > BSP_MAX_ADC_BUFFER_SIZE_BYTES)
 8020992:	d8e8      	bhi.n	8020966 <radar_open_device+0x36>
    return (RADAR_ERR_UNSUPPORTED_FRAME_FORMAT);
  }
  
  /* Initialize sensor hardware */
  /* -------------------------- */
  acq_buf = create_acq_data_buffer_obj((uint8_t*) data_fifo, BSP_MAX_ADC_BUFFER_SIZE_BYTES,
 8020994:	f8bd 302c 	ldrh.w	r3, [sp, #44]	; 0x2c
 8020998:	9300      	str	r3, [sp, #0]
 802099a:	2304      	movs	r3, #4
 802099c:	9301      	str	r3, [sp, #4]
 802099e:	7e2b      	ldrb	r3, [r5, #24]
 80209a0:	9302      	str	r3, [sp, #8]
 80209a2:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 80209a4:	f8bd 3030 	ldrh.w	r3, [sp, #48]	; 0x30
 80209a8:	9203      	str	r2, [sp, #12]
 80209aa:	af0e      	add	r7, sp, #56	; 0x38
 80209ac:	4638      	mov	r0, r7
 80209ae:	490e      	ldr	r1, [pc, #56]	; (80209e8 <radar_open_device+0xb8>)
 80209b0:	f44f 5280 	mov.w	r2, #4096	; 0x1000
                                       frame_format.num_chirps_per_frame,
                                       frame_format.num_samples_per_chirp, BSP_MAX_NUM_ADC_CHANNELS, pDev->adc_resolution, pDev->num_sample_skip_count);
  
  ds_set_active_acq_buf(acq_buf);
 80209b4:	ae12      	add	r6, sp, #72	; 0x48
    return (RADAR_ERR_UNSUPPORTED_FRAME_FORMAT);
  }
  
  /* Initialize sensor hardware */
  /* -------------------------- */
  acq_buf = create_acq_data_buffer_obj((uint8_t*) data_fifo, BSP_MAX_ADC_BUFFER_SIZE_BYTES,
 80209b6:	f7ff ff57 	bl	8020868 <create_acq_data_buffer_obj>
                                       frame_format.num_chirps_per_frame,
                                       frame_format.num_samples_per_chirp, BSP_MAX_NUM_ADC_CHANNELS, pDev->adc_resolution, pDev->num_sample_skip_count);
  
  ds_set_active_acq_buf(acq_buf);
 80209ba:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 80209bc:	466d      	mov	r5, sp
 80209be:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 80209c0:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 80209c2:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 80209c4:	e896 0003 	ldmia.w	r6, {r0, r1}
 80209c8:	e885 0003 	stmia.w	r5, {r0, r1}
 80209cc:	e897 000f 	ldmia.w	r7, {r0, r1, r2, r3}
 80209d0:	f7ff fd92 	bl	80204f8 <ds_set_active_acq_buf>
 
  
  /* BGT, DMA, Timers initialization */
  /* -------------------------------------------------- */
  retval = radar_init(device);
 80209d4:	4620      	mov	r0, r4
 80209d6:	f000 f87b 	bl	8020ad0 <radar_init>
  
  g_adc_sampling_completed = false;
 80209da:	4b04      	ldr	r3, [pc, #16]	; (80209ec <radar_open_device+0xbc>)
 80209dc:	2200      	movs	r2, #0
 80209de:	601a      	str	r2, [r3, #0]

  return (retval);
 80209e0:	e7b3      	b.n	802094a <radar_open_device+0x1a>
 80209e2:	bf00      	nop
 80209e4:	1ffe977c 	.word	0x1ffe977c
 80209e8:	1ffef060 	.word	0x1ffef060
 80209ec:	1ffe9784 	.word	0x1ffe9784

080209f0 <radar_set_automatic_frame_trigger>:
}

//============================================================================

uint16_t radar_set_automatic_frame_trigger(Radar_Handle_t device, uint32_t frame_interval_usec)
{
 80209f0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  /* Stop trigger timer first  */
  /* ------------------------- */
  bsp_timer_stop_clear(&TIMER_FRAME_TRIG);
 80209f4:	4834      	ldr	r0, [pc, #208]	; (8020ac8 <radar_set_automatic_frame_trigger+0xd8>)
}

//============================================================================

uint16_t radar_set_automatic_frame_trigger(Radar_Handle_t device, uint32_t frame_interval_usec)
{
 80209f6:	460c      	mov	r4, r1
  /* Stop trigger timer first  */
  /* ------------------------- */
  bsp_timer_stop_clear(&TIMER_FRAME_TRIG);
 80209f8:	f008 ff24 	bl	8029844 <bsp_timer_stop_clear>

  radar_set_data_acq_mode(RADAR_MANUAL_TRIGGER_MODE);
 80209fc:	2000      	movs	r0, #0
 80209fe:	f000 f8db 	bl	8020bb8 <radar_set_data_acq_mode>

  /* Restart trigger timer */
  /* --------------------- */
  if (frame_interval_usec > 0)
 8020a02:	b914      	cbnz	r4, 8020a0a <radar_set_automatic_frame_trigger+0x1a>

      bsp_timer_start(&TIMER_FRAME_TRIG);
    }
  }

  return (RADAR_ERR_OK);
 8020a04:	2000      	movs	r0, #0
 8020a06:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

uint16_t radar_get_min_frame_interval(Radar_Handle_t device, uint32_t* min_frame_interval_usec)
{
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */

  device_settings_t *p_dev = ds_device_get_settings();
 8020a0a:	f7ff fb77 	bl	80200fc <ds_device_get_settings>

  *min_frame_interval_usec = bsp_calc_min_frame_interval_usec(p_dev);
 8020a0e:	f009 fb5b 	bl	802a0c8 <bsp_calc_min_frame_interval_usec>
  {
    uint32_t min_frame_interval_usec;

    radar_get_min_frame_interval(device, &min_frame_interval_usec);

    if (frame_interval_usec < min_frame_interval_usec)
 8020a12:	4284      	cmp	r4, r0
{
  XMC_UNUSED_ARG(device); /* Suppress compiler warnings of unused variable */

  device_settings_t *p_dev = ds_device_get_settings();

  *min_frame_interval_usec = bsp_calc_min_frame_interval_usec(p_dev);
 8020a14:	4605      	mov	r5, r0
  {
    uint32_t min_frame_interval_usec;

    radar_get_min_frame_interval(device, &min_frame_interval_usec);

    if (frame_interval_usec < min_frame_interval_usec)
 8020a16:	d202      	bcs.n	8020a1e <radar_set_automatic_frame_trigger+0x2e>

      bsp_timer_start(&TIMER_FRAME_TRIG);
    }
  }

  return (RADAR_ERR_OK);
 8020a18:	2005      	movs	r0, #5
 8020a1a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    if (frame_interval_usec < min_frame_interval_usec)
    {
      return (RADAR_ERR_UNSUPPORTED_FRAME_INTERVAL);
    }

    device_settings_t *pDev = ds_device_get_settings();
 8020a1e:	f7ff fb6d 	bl	80200fc <ds_device_get_settings>

    pDev->frame_period_usec = frame_interval_usec;
 8020a22:	6204      	str	r4, [r0, #32]
    if (frame_interval_usec < min_frame_interval_usec)
    {
      return (RADAR_ERR_UNSUPPORTED_FRAME_INTERVAL);
    }

    device_settings_t *pDev = ds_device_get_settings();
 8020a24:	4606      	mov	r6, r0

    pDev->frame_period_usec = frame_interval_usec;

    /* Reset the current frame counter */
    bsp_reset_frame_counter();
 8020a26:	f009 fb29 	bl	802a07c <bsp_reset_frame_counter>

    g_adc_sampling_completed = false;

    /* Get data in continuous mode */
    if ((abs(frame_interval_usec - min_frame_interval_usec) < GUARD_FRAME_TIME_USEC))
 8020a2a:	1b63      	subs	r3, r4, r5
 8020a2c:	2b00      	cmp	r3, #0
    pDev->frame_period_usec = frame_interval_usec;

    /* Reset the current frame counter */
    bsp_reset_frame_counter();

    g_adc_sampling_completed = false;
 8020a2e:	4a27      	ldr	r2, [pc, #156]	; (8020acc <radar_set_automatic_frame_trigger+0xdc>)

    /* Get data in continuous mode */
    if ((abs(frame_interval_usec - min_frame_interval_usec) < GUARD_FRAME_TIME_USEC))
 8020a30:	bfb8      	it	lt
 8020a32:	425b      	neglt	r3, r3
    pDev->frame_period_usec = frame_interval_usec;

    /* Reset the current frame counter */
    bsp_reset_frame_counter();

    g_adc_sampling_completed = false;
 8020a34:	2700      	movs	r7, #0

    /* Get data in continuous mode */
    if ((abs(frame_interval_usec - min_frame_interval_usec) < GUARD_FRAME_TIME_USEC))
 8020a36:	f5b3 7ffa 	cmp.w	r3, #500	; 0x1f4
    pDev->frame_period_usec = frame_interval_usec;

    /* Reset the current frame counter */
    bsp_reset_frame_counter();

    g_adc_sampling_completed = false;
 8020a3a:	6017      	str	r7, [r2, #0]

    /* Get data in continuous mode */
    if ((abs(frame_interval_usec - min_frame_interval_usec) < GUARD_FRAME_TIME_USEC))
 8020a3c:	db2e      	blt.n	8020a9c <radar_set_automatic_frame_trigger+0xac>
      /* Start data acquisition */
      bsp_trigger_new_frame();
    }
    else
    {
      radar_set_data_acq_mode(RADAR_AUTO_TRIGGER_MODE);
 8020a3e:	2001      	movs	r0, #1
 8020a40:	f000 f8ba 	bl	8020bb8 <radar_set_data_acq_mode>
      pDev->frame_period_usec = frame_interval_usec;

      uint32_t temp_ptat_switch = pDev->ptat_is_switched;
      uint32_t temp_ptat_delay_usec = pDev->ptat_delay_usec;
 8020a44:	f8d6 803c 	ldr.w	r8, [r6, #60]	; 0x3c
      bsp_trigger_new_frame();
    }
    else
    {
      radar_set_data_acq_mode(RADAR_AUTO_TRIGGER_MODE);
      pDev->frame_period_usec = frame_interval_usec;
 8020a48:	6234      	str	r4, [r6, #32]

      uint32_t temp_ptat_switch = pDev->ptat_is_switched;
      uint32_t temp_ptat_delay_usec = pDev->ptat_delay_usec;

      if (frame_interval_usec < min_frame_interval_usec + 2 * pDev->ptat_delay_usec)
 8020a4a:	eb05 0548 	add.w	r5, r5, r8, lsl #1
 8020a4e:	42ac      	cmp	r4, r5
    else
    {
      radar_set_data_acq_mode(RADAR_AUTO_TRIGGER_MODE);
      pDev->frame_period_usec = frame_interval_usec;

      uint32_t temp_ptat_switch = pDev->ptat_is_switched;
 8020a50:	f8d6 9038 	ldr.w	r9, [r6, #56]	; 0x38
      uint32_t temp_ptat_delay_usec = pDev->ptat_delay_usec;

      if (frame_interval_usec < min_frame_interval_usec + 2 * pDev->ptat_delay_usec)
 8020a54:	d32e      	bcc.n	8020ab4 <radar_set_automatic_frame_trigger+0xc4>
        temp_ptat_switch = 0;
      else
      {
        float sample_interval_usec = 1000000.0 / pDev->adc_sampling_freq_Hz;
 8020a56:	6970      	ldr	r0, [r6, #20]
 8020a58:	f00b ff18 	bl	802c88c <__aeabi_ui2d>
 8020a5c:	4602      	mov	r2, r0
 8020a5e:	460b      	mov	r3, r1
 8020a60:	a117      	add	r1, pc, #92	; (adr r1, 8020ac0 <radar_set_automatic_frame_trigger+0xd0>)
 8020a62:	e9d1 0100 	ldrd	r0, r1, [r1]
 8020a66:	f00c f8b1 	bl	802cbcc <__aeabi_ddiv>
 8020a6a:	f00c fa3f 	bl	802ceec <__aeabi_d2f>
        if (pDev->ptat_delay_usec > (uint32_t)sample_interval_usec)
 8020a6e:	ee07 0a90 	vmov	s15, r0
 8020a72:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8020a76:	ee17 0a90 	vmov	r0, s15
 8020a7a:	4580      	cmp	r8, r0
 8020a7c:	d91c      	bls.n	8020ab8 <radar_set_automatic_frame_trigger+0xc8>
          temp_ptat_delay_usec = pDev->ptat_delay_usec - (uint32_t)sample_interval_usec;
 8020a7e:	ebc0 0808 	rsb	r8, r0, r8
        else
          temp_ptat_delay_usec = 0;
      }

      /* Update time period of Automatic Trigger */
      if (!bsp_start_frame_intervall_timer(frame_interval_usec))
 8020a82:	4620      	mov	r0, r4
 8020a84:	f009 fb12 	bl	802a0ac <bsp_start_frame_intervall_timer>
 8020a88:	2800      	cmp	r0, #0
 8020a8a:	d0c5      	beq.n	8020a18 <radar_set_automatic_frame_trigger+0x28>
      {
        return (RADAR_ERR_UNSUPPORTED_FRAME_INTERVAL);
      }

      bsp_set_ptat_switch_status(temp_ptat_switch, temp_ptat_delay_usec);
 8020a8c:	4648      	mov	r0, r9
 8020a8e:	4641      	mov	r1, r8
 8020a90:	f009 fb2c 	bl	802a0ec <bsp_set_ptat_switch_status>

      bsp_timer_start(&TIMER_FRAME_TRIG);
 8020a94:	480c      	ldr	r0, [pc, #48]	; (8020ac8 <radar_set_automatic_frame_trigger+0xd8>)
 8020a96:	f008 fee1 	bl	802985c <bsp_timer_start>
 8020a9a:	e7b3      	b.n	8020a04 <radar_set_automatic_frame_trigger+0x14>

    /* Get data in continuous mode */
    if ((abs(frame_interval_usec - min_frame_interval_usec) < GUARD_FRAME_TIME_USEC))
    {
      /* Set continuous mode */
      radar_set_data_acq_mode(RADAR_DATA_CONTINUOUS_MODE);
 8020a9c:	2002      	movs	r0, #2
 8020a9e:	f000 f88b 	bl	8020bb8 <radar_set_data_acq_mode>

      bsp_set_ptat_switch_status(0, 0);
 8020aa2:	4638      	mov	r0, r7
 8020aa4:	4639      	mov	r1, r7
 8020aa6:	f009 fb21 	bl	802a0ec <bsp_set_ptat_switch_status>

      /* Start data acquisition */
      bsp_trigger_new_frame();
 8020aaa:	f008 ff6b 	bl	8029984 <bsp_trigger_new_frame>

      bsp_timer_start(&TIMER_FRAME_TRIG);
    }
  }

  return (RADAR_ERR_OK);
 8020aae:	4638      	mov	r0, r7
 8020ab0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

      uint32_t temp_ptat_switch = pDev->ptat_is_switched;
      uint32_t temp_ptat_delay_usec = pDev->ptat_delay_usec;

      if (frame_interval_usec < min_frame_interval_usec + 2 * pDev->ptat_delay_usec)
        temp_ptat_switch = 0;
 8020ab4:	46b9      	mov	r9, r7
 8020ab6:	e7e4      	b.n	8020a82 <radar_set_automatic_frame_trigger+0x92>
      {
        float sample_interval_usec = 1000000.0 / pDev->adc_sampling_freq_Hz;
        if (pDev->ptat_delay_usec > (uint32_t)sample_interval_usec)
          temp_ptat_delay_usec = pDev->ptat_delay_usec - (uint32_t)sample_interval_usec;
        else
          temp_ptat_delay_usec = 0;
 8020ab8:	46b8      	mov	r8, r7
 8020aba:	e7e2      	b.n	8020a82 <radar_set_automatic_frame_trigger+0x92>
 8020abc:	f3af 8000 	nop.w
 8020ac0:	00000000 	.word	0x00000000
 8020ac4:	412e8480 	.word	0x412e8480
 8020ac8:	1ffe9200 	.word	0x1ffe9200
 8020acc:	1ffe9784 	.word	0x1ffe9784

08020ad0 <radar_init>:
    6. EXPORTED FUNCTIONS
==============================================================================
 */

uint16_t radar_init(Radar_Handle_t device)
{
 8020ad0:	b510      	push	{r4, lr}
  uint16_t status = RADAR_ERR_OK;

  device_settings_t *p_Dev = ds_device_get_settings();
 8020ad2:	f7ff fb13 	bl	80200fc <ds_device_get_settings>
 8020ad6:	4604      	mov	r4, r0
  
  /* USB and DMA Setup */
  acq_buf_obj *p_acq_buf = ds_get_active_acq_buf();
 8020ad8:	f7ff fd0a 	bl	80204f0 <ds_get_active_acq_buf>

  bsp_dma_set_adc_control_from_acq_buf_obj(p_acq_buf);
 8020adc:	f008 fec0 	bl	8029860 <bsp_dma_set_adc_control_from_acq_buf_obj>
  
  status |= (uint16_t) bsp_init(p_Dev);
 8020ae0:	4620      	mov	r0, r4
 8020ae2:	f008 fdf9 	bl	80296d8 <bsp_init>
  
  status |= radar_set_sampling_freq(device, p_Dev->pll_modulation_mode, p_Dev->adc_sampling_freq_Hz);
 8020ae6:	edd4 7a05 	vldr	s15, [r4, #20]
  XMC_UNUSED_ARG(modulation_type);
  XMC_UNUSED_ARG(freq_hz);

  //FIXME: Add settings freq here

  if (((uint32_t)freq_hz <= 0) || ((uint32_t)freq_hz > BSP_MAX_ADC_FREQ_HZ))
 8020aea:	4a07      	ldr	r2, [pc, #28]	; (8020b08 <radar_init+0x38>)

  bsp_dma_set_adc_control_from_acq_buf_obj(p_acq_buf);
  
  status |= (uint16_t) bsp_init(p_Dev);
  
  status |= radar_set_sampling_freq(device, p_Dev->pll_modulation_mode, p_Dev->adc_sampling_freq_Hz);
 8020aec:	eef8 7a67 	vcvt.f32.u32	s15, s15
  /* USB and DMA Setup */
  acq_buf_obj *p_acq_buf = ds_get_active_acq_buf();

  bsp_dma_set_adc_control_from_acq_buf_obj(p_acq_buf);
  
  status |= (uint16_t) bsp_init(p_Dev);
 8020af0:	b280      	uxth	r0, r0
  XMC_UNUSED_ARG(modulation_type);
  XMC_UNUSED_ARG(freq_hz);

  //FIXME: Add settings freq here

  if (((uint32_t)freq_hz <= 0) || ((uint32_t)freq_hz > BSP_MAX_ADC_FREQ_HZ))
 8020af2:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8020af6:	ee17 3a90 	vmov	r3, s15
 8020afa:	3b01      	subs	r3, #1
  {
    return RADAR_ERR_BUSY;
  }

  return (RADAR_ERR_OK);
 8020afc:	4293      	cmp	r3, r2
 8020afe:	bf8c      	ite	hi
 8020b00:	2302      	movhi	r3, #2
 8020b02:	2300      	movls	r3, #0
  status |= (uint16_t) bsp_init(p_Dev);
  
  status |= radar_set_sampling_freq(device, p_Dev->pll_modulation_mode, p_Dev->adc_sampling_freq_Hz);
  
  return (status);
}
 8020b04:	4318      	orrs	r0, r3
 8020b06:	bd10      	pop	{r4, pc}
 8020b08:	0016e35f 	.word	0x0016e35f

08020b0c <radar_start_acquisition>:

//============================================================================

uint16_t radar_start_acquisition(Radar_Handle_t device)
{
 8020b0c:	b510      	push	{r4, lr}
 8020b0e:	4604      	mov	r4, r0
  uint16_t status = RADAR_ERR_BUSY;
  
  if (ds_device_get_settings()->frame_period_usec > 0)
 8020b10:	f7ff faf4 	bl	80200fc <ds_device_get_settings>
 8020b14:	6a03      	ldr	r3, [r0, #32]
 8020b16:	b90b      	cbnz	r3, 8020b1c <radar_start_acquisition+0x10>
  {
    status = radar_set_automatic_frame_trigger(device, ds_device_get_settings()->frame_period_usec);
  }
  return (status);
}
 8020b18:	2002      	movs	r0, #2
 8020b1a:	bd10      	pop	{r4, pc}
{
  uint16_t status = RADAR_ERR_BUSY;
  
  if (ds_device_get_settings()->frame_period_usec > 0)
  {
    status = radar_set_automatic_frame_trigger(device, ds_device_get_settings()->frame_period_usec);
 8020b1c:	f7ff faee 	bl	80200fc <ds_device_get_settings>
 8020b20:	6a01      	ldr	r1, [r0, #32]
 8020b22:	4620      	mov	r0, r4
  }
  return (status);
}
 8020b24:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
{
  uint16_t status = RADAR_ERR_BUSY;
  
  if (ds_device_get_settings()->frame_period_usec > 0)
  {
    status = radar_set_automatic_frame_trigger(device, ds_device_get_settings()->frame_period_usec);
 8020b28:	f7ff bf62 	b.w	80209f0 <radar_set_automatic_frame_trigger>

08020b2c <radar_register_callback>:
uint16_t radar_register_callback(Radar_Callback_ID_t cb_id, void (*pcallback)(void *parameter))
{
  uint16_t status = RADAR_ERR_OK;

  /* Check if the callback function is valid */
  if (pcallback == NULL)
 8020b2c:	b151      	cbz	r1, 8020b44 <radar_register_callback+0x18>
  {
    return (RADAR_ERR_BUSY);
  }

  /* Register user callback function based on callback ID */
  switch (cb_id)
 8020b2e:	2801      	cmp	r0, #1
}

//============================================================================

uint16_t radar_register_callback(Radar_Callback_ID_t cb_id, void (*pcallback)(void *parameter))
{
 8020b30:	b508      	push	{r3, lr}
  {
    return (RADAR_ERR_BUSY);
  }

  /* Register user callback function based on callback ID */
  switch (cb_id)
 8020b32:	d003      	beq.n	8020b3c <radar_register_callback+0x10>
 8020b34:	2802      	cmp	r0, #2
 8020b36:	d001      	beq.n	8020b3c <radar_register_callback+0x10>
    bsp_register_callback(BSP_ACQUISITION_DONE_CB_ID, pcallback);
    break;

  default:
    /* Return error status */
    status = RADAR_ERR_BUSY;
 8020b38:	2002      	movs	r0, #2
    break;
  }

  return (status);
}
 8020b3a:	bd08      	pop	{r3, pc}
    bsp_register_callback(BSP_ACQUISITION_STARTED_CB_ID, pcallback);
    break;

  case RADAR_ACQUISITION_DONE_CB_ID:
    /* Callback executed by BSP layer at the end of data acquisition process */
    bsp_register_callback(BSP_ACQUISITION_DONE_CB_ID, pcallback);
 8020b3c:	f009 faa4 	bl	802a088 <bsp_register_callback>

//============================================================================

uint16_t radar_register_callback(Radar_Callback_ID_t cb_id, void (*pcallback)(void *parameter))
{
  uint16_t status = RADAR_ERR_OK;
 8020b40:	2000      	movs	r0, #0
    break;

  case RADAR_ACQUISITION_DONE_CB_ID:
    /* Callback executed by BSP layer at the end of data acquisition process */
    bsp_register_callback(BSP_ACQUISITION_DONE_CB_ID, pcallback);
    break;
 8020b42:	bd08      	pop	{r3, pc}
  uint16_t status = RADAR_ERR_OK;

  /* Check if the callback function is valid */
  if (pcallback == NULL)
  {
    return (RADAR_ERR_BUSY);
 8020b44:	2002      	movs	r0, #2
    status = RADAR_ERR_BUSY;
    break;
  }

  return (status);
}
 8020b46:	4770      	bx	lr

08020b48 <radar_apply_hw_settings>:
}

//============================================================================

uint32_t radar_apply_hw_settings(Radar_Handle_t device, device_settings_t *p_hw_settings)
{
 8020b48:	b5f0      	push	{r4, r5, r6, r7, lr}
 8020b4a:	460c      	mov	r4, r1
 8020b4c:	b099      	sub	sp, #100	; 0x64

uint16_t radar_stop_acquisition(Radar_Handle_t device)
{
  uint16_t status = RADAR_ERR_BUSY;
  
  status = radar_set_automatic_frame_trigger(device , 0);
 8020b4e:	2100      	movs	r1, #0
 8020b50:	f7ff ff4e 	bl	80209f0 <radar_set_automatic_frame_trigger>
{
  uint32_t retval = RADAR_ERR_OK;

  radar_stop_acquisition(device);

  bsp_bgt_shut_down();
 8020b54:	f008 fe70 	bl	8029838 <bsp_bgt_shut_down>

  if (bsp_update(p_new) != 0)
 8020b58:	4620      	mov	r0, r4
 8020b5a:	f008 fbad 	bl	80292b8 <bsp_update>
 8020b5e:	2800      	cmp	r0, #0
  {
	  // invalid settings values not changed!
	  retval = RADAR_ERR_PARAMETER_OUT_OF_RANGE;
 8020b60:	bf0c      	ite	eq
 8020b62:	2700      	moveq	r7, #0
 8020b64:	270c      	movne	r7, #12
  }

  /* recreate acq-buffer object! */
  /* the buffer is statically allocated to the max supported buffer size, so it is save to re-use it!
   * checks should have been applied earlier! */
  acq_buf_obj *p_acq_buf = ds_get_active_acq_buf();
 8020b66:	f7ff fcc3 	bl	80204f0 <ds_get_active_acq_buf>

  uint8_t *p_temp_buf = p_acq_buf->p_acq_buf;
  uint32_t reserved_size = p_acq_buf->internals.size_of_acq_buffer;


  acq_buf_obj acq_buf = create_acq_data_buffer_obj(p_temp_buf, reserved_size,
 8020b6a:	8ca6      	ldrh	r6, [r4, #36]	; 0x24
 8020b6c:	8ba3      	ldrh	r3, [r4, #28]
 8020b6e:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
 8020b70:	68c2      	ldr	r2, [r0, #12]
 8020b72:	7e25      	ldrb	r5, [r4, #24]
 8020b74:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8020b76:	9600      	str	r6, [sp, #0]
 8020b78:	2404      	movs	r4, #4
 8020b7a:	ae0a      	add	r6, sp, #40	; 0x28
 8020b7c:	9502      	str	r5, [sp, #8]
 8020b7e:	9003      	str	r0, [sp, #12]
 8020b80:	9401      	str	r4, [sp, #4]
 8020b82:	4630      	mov	r0, r6
	  											   p_new->num_of_chirps_per_frame,
												   p_new->num_samples_per_chirp, BSP_MAX_NUM_ADC_CHANNELS, p_new->adc_resolution, p_new->num_sample_skip_count);

  ds_set_active_acq_buf(acq_buf);
 8020b84:	ad0e      	add	r5, sp, #56	; 0x38

  uint8_t *p_temp_buf = p_acq_buf->p_acq_buf;
  uint32_t reserved_size = p_acq_buf->internals.size_of_acq_buffer;


  acq_buf_obj acq_buf = create_acq_data_buffer_obj(p_temp_buf, reserved_size,
 8020b86:	f7ff fe6f 	bl	8020868 <create_acq_data_buffer_obj>
	  											   p_new->num_of_chirps_per_frame,
												   p_new->num_samples_per_chirp, BSP_MAX_NUM_ADC_CHANNELS, p_new->adc_resolution, p_new->num_sample_skip_count);

  ds_set_active_acq_buf(acq_buf);
 8020b8a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8020b8c:	466c      	mov	r4, sp
 8020b8e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8020b90:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8020b92:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8020b94:	e895 0003 	ldmia.w	r5, {r0, r1}
 8020b98:	e884 0003 	stmia.w	r4, {r0, r1}
 8020b9c:	e896 000f 	ldmia.w	r6, {r0, r1, r2, r3}
 8020ba0:	f7ff fcaa 	bl	80204f8 <ds_set_active_acq_buf>
  uint32_t retval = RADAR_ERR_OK;

  retval = radar_apply_new_hw_setting(device, p_hw_settings);
  
  return retval;
}
 8020ba4:	4638      	mov	r0, r7
 8020ba6:	b019      	add	sp, #100	; 0x64
 8020ba8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8020baa:	bf00      	nop

08020bac <radar_get_data_acq_mode>:

//============================================================================

Radar_Data_Acq_Mode_t radar_get_data_acq_mode(void)
{
  return s_data_acq_mode;
 8020bac:	4b01      	ldr	r3, [pc, #4]	; (8020bb4 <radar_get_data_acq_mode+0x8>)
}
 8020bae:	7818      	ldrb	r0, [r3, #0]
 8020bb0:	4770      	bx	lr
 8020bb2:	bf00      	nop
 8020bb4:	1ffe9780 	.word	0x1ffe9780

08020bb8 <radar_set_data_acq_mode>:

//============================================================================

void radar_set_data_acq_mode(Radar_Data_Acq_Mode_t new_mode)
{
  s_data_acq_mode = new_mode;
 8020bb8:	4b01      	ldr	r3, [pc, #4]	; (8020bc0 <radar_set_data_acq_mode+0x8>)
 8020bba:	7018      	strb	r0, [r3, #0]
 8020bbc:	4770      	bx	lr
 8020bbe:	bf00      	nop
 8020bc0:	1ffe9780 	.word	0x1ffe9780

08020bc4 <device_status_get_handle>:
 */

Device_Status_t* device_status_get_handle()
{
	return &device_status;
}
 8020bc4:	4800      	ldr	r0, [pc, #0]	; (8020bc8 <device_status_get_handle+0x4>)
 8020bc6:	4770      	bx	lr
 8020bc8:	1ffe9788 	.word	0x1ffe9788

08020bcc <device_status_set_error>:
 */
/*Error prioritized, keep either first or last error*/
void device_status_set_error(Device_Error_t radar_error)
{
	uint8_t new_error_type =  FIND_TYPE_OF_ERROR(radar_error);
	uint8_t latest_error_type = FIND_TYPE_OF_ERROR(device_status.latest_error);
 8020bcc:	4a14      	ldr	r2, [pc, #80]	; (8020c20 <device_status_set_error+0x54>)
 8020bce:	6853      	ldr	r3, [r2, #4]

	/* only one message is stored: guard to not overwrite for example error through a status*/
	if (latest_error_type < new_error_type)
 8020bd0:	f3c3 3103 	ubfx	r1, r3, #12, #4
 * @param radar_error
 */
/*Error prioritized, keep either first or last error*/
void device_status_set_error(Device_Error_t radar_error)
{
	uint8_t new_error_type =  FIND_TYPE_OF_ERROR(radar_error);
 8020bd4:	f3c0 3303 	ubfx	r3, r0, #12, #4
	uint8_t latest_error_type = FIND_TYPE_OF_ERROR(device_status.latest_error);

	/* only one message is stored: guard to not overwrite for example error through a status*/
	if (latest_error_type < new_error_type)
 8020bd8:	428b      	cmp	r3, r1
	{
		device_status.latest_error = radar_error;
	}

	switch(new_error_type)
 8020bda:	f103 33ff 	add.w	r3, r3, #4294967295
	uint8_t latest_error_type = FIND_TYPE_OF_ERROR(device_status.latest_error);

	/* only one message is stored: guard to not overwrite for example error through a status*/
	if (latest_error_type < new_error_type)
	{
		device_status.latest_error = radar_error;
 8020bde:	bf88      	it	hi
 8020be0:	6050      	strhi	r0, [r2, #4]
	}

	switch(new_error_type)
 8020be2:	2b03      	cmp	r3, #3
 8020be4:	d808      	bhi.n	8020bf8 <device_status_set_error+0x2c>
 8020be6:	e8df f003 	tbb	[pc, r3]
 8020bea:	0e14      	.short	0x0e14
 8020bec:	0208      	.short	0x0208
		device_status.error_count++;
		break;

	case STATE_FATAL_ERROR:
		device_status.state = STATE_FATAL_ERROR;
		device_status.fatal_error_count++;
 8020bee:	7ad3      	ldrb	r3, [r2, #11]
		device_status.state = STATE_ERROR;
		device_status.error_count++;
		break;

	case STATE_FATAL_ERROR:
		device_status.state = STATE_FATAL_ERROR;
 8020bf0:	2104      	movs	r1, #4
		device_status.fatal_error_count++;
 8020bf2:	3301      	adds	r3, #1
 8020bf4:	72d3      	strb	r3, [r2, #11]
		device_status.state = STATE_ERROR;
		device_status.error_count++;
		break;

	case STATE_FATAL_ERROR:
		device_status.state = STATE_FATAL_ERROR;
 8020bf6:	7011      	strb	r1, [r2, #0]
 8020bf8:	4770      	bx	lr
		device_status.warning_count++;
		break;

	case STATE_ERROR:
		device_status.state = STATE_ERROR;
		device_status.error_count++;
 8020bfa:	7a93      	ldrb	r3, [r2, #10]
		device_status.state = STATE_WARNING;
		device_status.warning_count++;
		break;

	case STATE_ERROR:
		device_status.state = STATE_ERROR;
 8020bfc:	2103      	movs	r1, #3
		device_status.error_count++;
 8020bfe:	3301      	adds	r3, #1
 8020c00:	7293      	strb	r3, [r2, #10]
		device_status.state = STATE_WARNING;
		device_status.warning_count++;
		break;

	case STATE_ERROR:
		device_status.state = STATE_ERROR;
 8020c02:	7011      	strb	r1, [r2, #0]
		device_status.error_count++;
		break;
 8020c04:	4770      	bx	lr
		device_status.info_count++;
		break;

	case STATE_WARNING:
		device_status.state = STATE_WARNING;
		device_status.warning_count++;
 8020c06:	7a53      	ldrb	r3, [r2, #9]
		device_status.state = STATE_INFO;
		device_status.info_count++;
		break;

	case STATE_WARNING:
		device_status.state = STATE_WARNING;
 8020c08:	2102      	movs	r1, #2
		device_status.warning_count++;
 8020c0a:	3301      	adds	r3, #1
 8020c0c:	7253      	strb	r3, [r2, #9]
		device_status.state = STATE_INFO;
		device_status.info_count++;
		break;

	case STATE_WARNING:
		device_status.state = STATE_WARNING;
 8020c0e:	7011      	strb	r1, [r2, #0]
		device_status.warning_count++;
		break;
 8020c10:	4770      	bx	lr

	switch(new_error_type)
	{
	case STATE_INFO:
		device_status.state = STATE_INFO;
		device_status.info_count++;
 8020c12:	7a13      	ldrb	r3, [r2, #8]
	}

	switch(new_error_type)
	{
	case STATE_INFO:
		device_status.state = STATE_INFO;
 8020c14:	2101      	movs	r1, #1
		device_status.info_count++;
 8020c16:	440b      	add	r3, r1
 8020c18:	7213      	strb	r3, [r2, #8]
	}

	switch(new_error_type)
	{
	case STATE_INFO:
		device_status.state = STATE_INFO;
 8020c1a:	7011      	strb	r1, [r2, #0]
		device_status.info_count++;
		break;
 8020c1c:	4770      	bx	lr
 8020c1e:	bf00      	nop
 8020c20:	1ffe9788 	.word	0x1ffe9788

08020c24 <device_status_get_error_description>:
	 * in case of an error, we do not need to be efficient!
	 */
	uint32_t elems = sizeof(DEVICE_ERROR_DESCRIPTION_TABLE)/sizeof(DEVICE_ERROR_DESCRIPTION_TABLE[0]);
	for (uint32_t i = 0; i< elems; i++)
	{
		if (error == DEVICE_ERROR_DESCRIPTION_TABLE[i].code)
 8020c24:	4b0d      	ldr	r3, [pc, #52]	; (8020c5c <device_status_get_error_description+0x38>)
 8020c26:	681a      	ldr	r2, [r3, #0]
 8020c28:	4282      	cmp	r2, r0
 8020c2a:	d013      	beq.n	8020c54 <device_status_get_error_description+0x30>
 8020c2c:	68da      	ldr	r2, [r3, #12]
 8020c2e:	4282      	cmp	r2, r0
 8020c30:	d012      	beq.n	8020c58 <device_status_get_error_description+0x34>
 8020c32:	699a      	ldr	r2, [r3, #24]
 8020c34:	4282      	cmp	r2, r0
 8020c36:	d006      	beq.n	8020c46 <device_status_get_error_description+0x22>
 8020c38:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8020c3a:	4282      	cmp	r2, r0
{
	/*
	 * in case of an error, we do not need to be efficient!
	 */
	uint32_t elems = sizeof(DEVICE_ERROR_DESCRIPTION_TABLE)/sizeof(DEVICE_ERROR_DESCRIPTION_TABLE[0]);
	for (uint32_t i = 0; i< elems; i++)
 8020c3c:	bf08      	it	eq
 8020c3e:	2203      	moveq	r2, #3
	{
		if (error == DEVICE_ERROR_DESCRIPTION_TABLE[i].code)
 8020c40:	d002      	beq.n	8020c48 <device_status_get_error_description+0x24>
		{
			return DEVICE_ERROR_DESCRIPTION_TABLE[i].pText;
		}
	}
	/* did not found an entry, return text with index 0! */
	return DEVICE_ERROR_DESCRIPTION_TABLE[0].pText;
 8020c42:	6858      	ldr	r0, [r3, #4]
}
 8020c44:	4770      	bx	lr
{
	/*
	 * in case of an error, we do not need to be efficient!
	 */
	uint32_t elems = sizeof(DEVICE_ERROR_DESCRIPTION_TABLE)/sizeof(DEVICE_ERROR_DESCRIPTION_TABLE[0]);
	for (uint32_t i = 0; i< elems; i++)
 8020c46:	2202      	movs	r2, #2
	{
		if (error == DEVICE_ERROR_DESCRIPTION_TABLE[i].code)
		{
			return DEVICE_ERROR_DESCRIPTION_TABLE[i].pText;
 8020c48:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 8020c4c:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 8020c50:	6858      	ldr	r0, [r3, #4]
 8020c52:	4770      	bx	lr
{
	/*
	 * in case of an error, we do not need to be efficient!
	 */
	uint32_t elems = sizeof(DEVICE_ERROR_DESCRIPTION_TABLE)/sizeof(DEVICE_ERROR_DESCRIPTION_TABLE[0]);
	for (uint32_t i = 0; i< elems; i++)
 8020c54:	2200      	movs	r2, #0
 8020c56:	e7f7      	b.n	8020c48 <device_status_get_error_description+0x24>
 8020c58:	2201      	movs	r2, #1
 8020c5a:	e7f5      	b.n	8020c48 <device_status_get_error_description+0x24>
 8020c5c:	1ffe906c 	.word	0x1ffe906c

08020c60 <device_status_check>:
 */
uint32_t device_status_check()
{
	uint32_t retval = 0;

	if (device_status.state != STATE_NO_ERROR)
 8020c60:	4b03      	ldr	r3, [pc, #12]	; (8020c70 <device_status_check+0x10>)
 8020c62:	7818      	ldrb	r0, [r3, #0]
 8020c64:	3000      	adds	r0, #0
 8020c66:	bf18      	it	ne
 8020c68:	2001      	movne	r0, #1
	{
		retval = -1;
	}
	return retval;
}
 8020c6a:	4240      	negs	r0, r0
 8020c6c:	4770      	bx	lr
 8020c6e:	bf00      	nop
 8020c70:	1ffe9788 	.word	0x1ffe9788

08020c74 <device_status_clean>:
/**
 * @brief function to clean the errors of the device status
 */
void device_status_clean()
{
	device_status.latest_error = 0x0000;
 8020c74:	4b02      	ldr	r3, [pc, #8]	; (8020c80 <device_status_clean+0xc>)
 8020c76:	2200      	movs	r2, #0
 8020c78:	605a      	str	r2, [r3, #4]
	device_status.state = STATE_NO_ERROR;
 8020c7a:	701a      	strb	r2, [r3, #0]
 8020c7c:	4770      	bx	lr
 8020c7e:	bf00      	nop
 8020c80:	1ffe9788 	.word	0x1ffe9788

08020c84 <radar_get_consumption_labels>:
==============================================================================
 */

para_consumption_def_t *radar_get_consumption_labels(void)
{
	return p_consumption_def;
 8020c84:	4b01      	ldr	r3, [pc, #4]	; (8020c8c <radar_get_consumption_labels+0x8>)
}
 8020c86:	6818      	ldr	r0, [r3, #0]
 8020c88:	4770      	bx	lr
 8020c8a:	bf00      	nop
 8020c8c:	1ffe90a8 	.word	0x1ffe90a8

08020c90 <set_consumption_repeat_count>:

//============================================================================

void set_consumption_repeat_count(size_t count)
{
	consumption_repeat_count = count;
 8020c90:	4b01      	ldr	r3, [pc, #4]	; (8020c98 <set_consumption_repeat_count+0x8>)
 8020c92:	6018      	str	r0, [r3, #0]
 8020c94:	4770      	bx	lr
 8020c96:	bf00      	nop
 8020c98:	1ffe9794 	.word	0x1ffe9794

08020c9c <inc_consumption_repeat_count>:

//============================================================================

void inc_consumption_repeat_count(size_t count)
{
	consumption_repeat_count += count;
 8020c9c:	4a02      	ldr	r2, [pc, #8]	; (8020ca8 <inc_consumption_repeat_count+0xc>)
 8020c9e:	6813      	ldr	r3, [r2, #0]
 8020ca0:	4418      	add	r0, r3
 8020ca2:	6010      	str	r0, [r2, #0]
 8020ca4:	4770      	bx	lr
 8020ca6:	bf00      	nop
 8020ca8:	1ffe9794 	.word	0x1ffe9794

08020cac <mcu_base_updates>:
}

//============================================================================

void mcu_base_updates(void)
{
 8020cac:	b510      	push	{r4, lr}
	if (consumption_repeat_count > 0)
 8020cae:	4c0b      	ldr	r4, [pc, #44]	; (8020cdc <mcu_base_updates+0x30>)
 8020cb0:	6823      	ldr	r3, [r4, #0]
}

//============================================================================

void mcu_base_updates(void)
{
 8020cb2:	b084      	sub	sp, #16
	if (consumption_repeat_count > 0)
 8020cb4:	b183      	cbz	r3, 8020cd8 <mcu_base_updates+0x2c>
	{
		device_settings_t *pDev = ds_device_get_settings();
 8020cb6:	f7ff fa21 	bl	80200fc <ds_device_get_settings>
		extern float calcCurrentConsumption_mA(device_settings_t *pDev);
		float consumption = calcCurrentConsumption_mA(pDev);
 8020cba:	f009 fae1 	bl	802a280 <calcCurrentConsumption_mA>
uint16_t radar_send_consumption_to_host(int8_t index, float value, char *p_unit)
{
	consumption_response_t consumption;
	consumption.index = index;
	consumption.value = value;
	consumption.p_unit = p_unit;
 8020cbe:	4b08      	ldr	r3, [pc, #32]	; (8020ce0 <mcu_base_updates+0x34>)
/* so far we only have on consumption "sensor" */
uint16_t radar_send_consumption_to_host(int8_t index, float value, char *p_unit)
{
	consumption_response_t consumption;
	consumption.index = index;
	consumption.value = value;
 8020cc0:	9002      	str	r0, [sp, #8]

/* so far we only have on consumption "sensor" */
uint16_t radar_send_consumption_to_host(int8_t index, float value, char *p_unit)
{
	consumption_response_t consumption;
	consumption.index = index;
 8020cc2:	2200      	movs	r2, #0
	consumption.value = value;
	consumption.p_unit = p_unit;

	return send_consumption_response(1, &consumption);
 8020cc4:	2001      	movs	r0, #1
 8020cc6:	a901      	add	r1, sp, #4
uint16_t radar_send_consumption_to_host(int8_t index, float value, char *p_unit)
{
	consumption_response_t consumption;
	consumption.index = index;
	consumption.value = value;
	consumption.p_unit = p_unit;
 8020cc8:	9303      	str	r3, [sp, #12]

/* so far we only have on consumption "sensor" */
uint16_t radar_send_consumption_to_host(int8_t index, float value, char *p_unit)
{
	consumption_response_t consumption;
	consumption.index = index;
 8020cca:	f88d 2004 	strb.w	r2, [sp, #4]
	consumption.value = value;
	consumption.p_unit = p_unit;

	return send_consumption_response(1, &consumption);
 8020cce:	f002 feb9 	bl	8023a44 <send_consumption_response>
		device_settings_t *pDev = ds_device_get_settings();
		extern float calcCurrentConsumption_mA(device_settings_t *pDev);
		float consumption = calcCurrentConsumption_mA(pDev);

		radar_send_consumption_to_host(0, consumption, "mA");
		consumption_repeat_count -= 1;
 8020cd2:	6823      	ldr	r3, [r4, #0]
 8020cd4:	3b01      	subs	r3, #1
 8020cd6:	6023      	str	r3, [r4, #0]
	}
}
 8020cd8:	b004      	add	sp, #16
 8020cda:	bd10      	pop	{r4, pc}
 8020cdc:	1ffe9794 	.word	0x1ffe9794
 8020ce0:	0802f138 	.word	0x0802f138

08020ce4 <set_result_repeat_count>:

//============================================================================

void set_result_repeat_count(uint8_t endpoint, size_t count)
{
	result_repeat_count = count;
 8020ce4:	4a02      	ldr	r2, [pc, #8]	; (8020cf0 <set_result_repeat_count+0xc>)
	g_endpoint = endpoint;
 8020ce6:	4b03      	ldr	r3, [pc, #12]	; (8020cf4 <set_result_repeat_count+0x10>)

//============================================================================

void set_result_repeat_count(uint8_t endpoint, size_t count)
{
	result_repeat_count = count;
 8020ce8:	6011      	str	r1, [r2, #0]
	g_endpoint = endpoint;
 8020cea:	7018      	strb	r0, [r3, #0]
 8020cec:	4770      	bx	lr
 8020cee:	bf00      	nop
 8020cf0:	1ffe97a0 	.word	0x1ffe97a0
 8020cf4:	1ffe9798 	.word	0x1ffe9798

08020cf8 <set_raw_data_repeat_count>:

//============================================================================

void set_raw_data_repeat_count(uint8_t endpoint, size_t count)
{
	raw_data_repeat_count = count;
 8020cf8:	4a02      	ldr	r2, [pc, #8]	; (8020d04 <set_raw_data_repeat_count+0xc>)
	g_endpoint = endpoint;
 8020cfa:	4b03      	ldr	r3, [pc, #12]	; (8020d08 <set_raw_data_repeat_count+0x10>)

//============================================================================

void set_raw_data_repeat_count(uint8_t endpoint, size_t count)
{
	raw_data_repeat_count = count;
 8020cfc:	6011      	str	r1, [r2, #0]
	g_endpoint = endpoint;
 8020cfe:	7018      	strb	r0, [r3, #0]
 8020d00:	4770      	bx	lr
 8020d02:	bf00      	nop
 8020d04:	1ffe979c 	.word	0x1ffe979c
 8020d08:	1ffe9798 	.word	0x1ffe9798

08020d0c <radar_pulse_raw_data>:
}

//============================================================================

void radar_pulse_raw_data(acq_buf_obj *p_acq_buf, device_settings_t *p_dev)
{
 8020d0c:	b510      	push	{r4, lr}
	if (raw_data_repeat_count > 0)
 8020d0e:	4c06      	ldr	r4, [pc, #24]	; (8020d28 <radar_pulse_raw_data+0x1c>)
 8020d10:	6823      	ldr	r3, [r4, #0]
 8020d12:	b143      	cbz	r3, 8020d26 <radar_pulse_raw_data+0x1a>
	{
		send_pulse_frame_data(g_endpoint, p_acq_buf, p_dev);
 8020d14:	4b05      	ldr	r3, [pc, #20]	; (8020d2c <radar_pulse_raw_data+0x20>)
 8020d16:	460a      	mov	r2, r1
 8020d18:	4601      	mov	r1, r0
 8020d1a:	7818      	ldrb	r0, [r3, #0]
 8020d1c:	f003 f86a 	bl	8023df4 <send_pulse_frame_data>
		raw_data_repeat_count -= 1;
 8020d20:	6823      	ldr	r3, [r4, #0]
 8020d22:	3b01      	subs	r3, #1
 8020d24:	6023      	str	r3, [r4, #0]
 8020d26:	bd10      	pop	{r4, pc}
 8020d28:	1ffe979c 	.word	0x1ffe979c
 8020d2c:	1ffe9798 	.word	0x1ffe9798

08020d30 <radar_pulse_results_updates>:
}

//============================================================================

void radar_pulse_results_updates(algo_result_t *p_algo_result)
{
 8020d30:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (result_repeat_count > 0)
 8020d32:	4c13      	ldr	r4, [pc, #76]	; (8020d80 <radar_pulse_results_updates+0x50>)
 8020d34:	6823      	ldr	r3, [r4, #0]
}

//============================================================================

void radar_pulse_results_updates(algo_result_t *p_algo_result)
{
 8020d36:	b087      	sub	sp, #28
	if (result_repeat_count > 0)
 8020d38:	b1fb      	cbz	r3, 8020d7a <radar_pulse_results_updates+0x4a>
	{
		pulse_result_response_t pulse_result;

		pulse_result.frame_count             = p_algo_result->frame_counter;
		pulse_result.velocity_mps            = p_algo_result->velocity_kmph / 3.6f;
 8020d3a:	edd0 7a00 	vldr	s15, [r0]
 8020d3e:	ed9f 7a11 	vldr	s14, [pc, #68]	; 8020d84 <radar_pulse_results_updates+0x54>
		pulse_result.target_departing_bool   = p_algo_result->target_departing;
		pulse_result.target_approaching_bool = p_algo_result->target_approaching;
		pulse_result.motion_detected_bool    = p_algo_result->motion_detected;
		pulse_result.doppler_frequency_hz    = p_algo_result->doppler_frequency_hz;

		send_result_response(g_endpoint, &pulse_result);
 8020d42:	4a11      	ldr	r2, [pc, #68]	; (8020d88 <radar_pulse_results_updates+0x58>)
	{
		pulse_result_response_t pulse_result;

		pulse_result.frame_count             = p_algo_result->frame_counter;
		pulse_result.velocity_mps            = p_algo_result->velocity_kmph / 3.6f;
		pulse_result.level_nu                = p_algo_result->level;
 8020d44:	6841      	ldr	r1, [r0, #4]
		pulse_result.target_departing_bool   = p_algo_result->target_departing;
		pulse_result.target_approaching_bool = p_algo_result->target_approaching;
		pulse_result.motion_detected_bool    = p_algo_result->motion_detected;
		pulse_result.doppler_frequency_hz    = p_algo_result->doppler_frequency_hz;
 8020d46:	68c7      	ldr	r7, [r0, #12]
	{
		pulse_result_response_t pulse_result;

		pulse_result.frame_count             = p_algo_result->frame_counter;
		pulse_result.velocity_mps            = p_algo_result->velocity_kmph / 3.6f;
		pulse_result.level_nu                = p_algo_result->level;
 8020d48:	9103      	str	r1, [sp, #12]
	if (result_repeat_count > 0)
	{
		pulse_result_response_t pulse_result;

		pulse_result.frame_count             = p_algo_result->frame_counter;
		pulse_result.velocity_mps            = p_algo_result->velocity_kmph / 3.6f;
 8020d4a:	eec7 7a87 	vdiv.f32	s15, s15, s14
 8020d4e:	4603      	mov	r3, r0
		pulse_result.target_departing_bool   = p_algo_result->target_departing;
		pulse_result.target_approaching_bool = p_algo_result->target_approaching;
		pulse_result.motion_detected_bool    = p_algo_result->motion_detected;
		pulse_result.doppler_frequency_hz    = p_algo_result->doppler_frequency_hz;

		send_result_response(g_endpoint, &pulse_result);
 8020d50:	a901      	add	r1, sp, #4
{
	if (result_repeat_count > 0)
	{
		pulse_result_response_t pulse_result;

		pulse_result.frame_count             = p_algo_result->frame_counter;
 8020d52:	699e      	ldr	r6, [r3, #24]
		pulse_result.velocity_mps            = p_algo_result->velocity_kmph / 3.6f;
		pulse_result.level_nu                = p_algo_result->level;
		pulse_result.target_departing_bool   = p_algo_result->target_departing;
 8020d54:	7a1d      	ldrb	r5, [r3, #8]
		pulse_result.target_approaching_bool = p_algo_result->target_approaching;
		pulse_result.motion_detected_bool    = p_algo_result->motion_detected;
		pulse_result.doppler_frequency_hz    = p_algo_result->doppler_frequency_hz;

		send_result_response(g_endpoint, &pulse_result);
 8020d56:	7810      	ldrb	r0, [r2, #0]

		pulse_result.frame_count             = p_algo_result->frame_counter;
		pulse_result.velocity_mps            = p_algo_result->velocity_kmph / 3.6f;
		pulse_result.level_nu                = p_algo_result->level;
		pulse_result.target_departing_bool   = p_algo_result->target_departing;
		pulse_result.target_approaching_bool = p_algo_result->target_approaching;
 8020d58:	7a5a      	ldrb	r2, [r3, #9]
		pulse_result.motion_detected_bool    = p_algo_result->motion_detected;
 8020d5a:	7a9b      	ldrb	r3, [r3, #10]
 8020d5c:	f88d 3012 	strb.w	r3, [sp, #18]
		pulse_result.doppler_frequency_hz    = p_algo_result->doppler_frequency_hz;
 8020d60:	9705      	str	r7, [sp, #20]
{
	if (result_repeat_count > 0)
	{
		pulse_result_response_t pulse_result;

		pulse_result.frame_count             = p_algo_result->frame_counter;
 8020d62:	9601      	str	r6, [sp, #4]
		pulse_result.velocity_mps            = p_algo_result->velocity_kmph / 3.6f;
		pulse_result.level_nu                = p_algo_result->level;
		pulse_result.target_departing_bool   = p_algo_result->target_departing;
 8020d64:	f88d 5010 	strb.w	r5, [sp, #16]
		pulse_result.target_approaching_bool = p_algo_result->target_approaching;
 8020d68:	f88d 2011 	strb.w	r2, [sp, #17]
	if (result_repeat_count > 0)
	{
		pulse_result_response_t pulse_result;

		pulse_result.frame_count             = p_algo_result->frame_counter;
		pulse_result.velocity_mps            = p_algo_result->velocity_kmph / 3.6f;
 8020d6c:	edcd 7a02 	vstr	s15, [sp, #8]
		pulse_result.target_departing_bool   = p_algo_result->target_departing;
		pulse_result.target_approaching_bool = p_algo_result->target_approaching;
		pulse_result.motion_detected_bool    = p_algo_result->motion_detected;
		pulse_result.doppler_frequency_hz    = p_algo_result->doppler_frequency_hz;

		send_result_response(g_endpoint, &pulse_result);
 8020d70:	f002 ff9a 	bl	8023ca8 <send_result_response>

		result_repeat_count -= 1;
 8020d74:	6823      	ldr	r3, [r4, #0]
 8020d76:	3b01      	subs	r3, #1
 8020d78:	6023      	str	r3, [r4, #0]
	}
}
 8020d7a:	b007      	add	sp, #28
 8020d7c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8020d7e:	bf00      	nop
 8020d80:	1ffe97a0 	.word	0x1ffe97a0
 8020d84:	40666666 	.word	0x40666666
 8020d88:	1ffe9798 	.word	0x1ffe9798

08020d8c <copyStore2comPara>:

//============================================================================

void copyStore2comPara(pulse_para_values_t *p_com_para)
{
 8020d8c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8020d8e:	4604      	mov	r4, r0
	algo_settings_t *p_algo = ds_algo_get_settings();
 8020d90:	f7ff f942 	bl	8020018 <ds_algo_get_settings>
 8020d94:	4606      	mov	r6, r0
	device_settings_t *p_dev = ds_device_get_settings();
 8020d96:	f7ff f9b1 	bl	80200fc <ds_device_get_settings>

	p_com_para->max_speed_mps              = p_algo->max_speed_kmph / 3.6f;
	p_com_para->min_speed_mps              = p_algo->min_speed_kmph / 3.6f;

	p_com_para->frame_time_sec             = p_dev->frame_period_usec / 1000000.0f;
 8020d9a:	edd0 7a08 	vldr	s15, [r0, #32]
void copyStore2comPara(pulse_para_values_t *p_com_para)
{
	algo_settings_t *p_algo = ds_algo_get_settings();
	device_settings_t *p_dev = ds_device_get_settings();

	p_com_para->max_speed_mps              = p_algo->max_speed_kmph / 3.6f;
 8020d9e:	ed96 6a04 	vldr	s12, [r6, #16]
	p_com_para->min_speed_mps              = p_algo->min_speed_kmph / 3.6f;
 8020da2:	edd6 6a03 	vldr	s13, [r6, #12]
void copyStore2comPara(pulse_para_values_t *p_com_para)
{
	algo_settings_t *p_algo = ds_algo_get_settings();
	device_settings_t *p_dev = ds_device_get_settings();

	p_com_para->max_speed_mps              = p_algo->max_speed_kmph / 3.6f;
 8020da6:	eddf 5a18 	vldr	s11, [pc, #96]	; 8020e08 <copyStore2comPara+0x7c>
	p_com_para->min_speed_mps              = p_algo->min_speed_kmph / 3.6f;

	p_com_para->frame_time_sec             = p_dev->frame_period_usec / 1000000.0f;
 8020daa:	ed9f 5a18 	vldr	s10, [pc, #96]	; 8020e0c <copyStore2comPara+0x80>
	p_com_para->number_of_samples_nu       = (uint16_t)p_dev->num_samples_per_chirp;

	p_com_para->sampling_freq_hz           = (float)p_dev->adc_sampling_freq_Hz;
 8020dae:	ed90 7a05 	vldr	s14, [r0, #20]
	p_com_para->doppler_sensitivity_nu     = p_algo->speed_detection_threshold;
	p_com_para->motion_sensitivity_nu      = p_algo->motion_detection_threshold;

	p_com_para->use_high_gain_doppler_bool = (uint8_t)((p_algo->use_high_gain_doppler == 0L) ? 0U : 1U);
 8020db2:	6973      	ldr	r3, [r6, #20]
	p_com_para->frame_time_sec             = p_dev->frame_period_usec / 1000000.0f;
	p_com_para->number_of_samples_nu       = (uint16_t)p_dev->num_samples_per_chirp;

	p_com_para->sampling_freq_hz           = (float)p_dev->adc_sampling_freq_Hz;
	p_com_para->doppler_sensitivity_nu     = p_algo->speed_detection_threshold;
	p_com_para->motion_sensitivity_nu      = p_algo->motion_detection_threshold;
 8020db4:	69b2      	ldr	r2, [r6, #24]

	p_com_para->frame_time_sec             = p_dev->frame_period_usec / 1000000.0f;
	p_com_para->number_of_samples_nu       = (uint16_t)p_dev->num_samples_per_chirp;

	p_com_para->sampling_freq_hz           = (float)p_dev->adc_sampling_freq_Hz;
	p_com_para->doppler_sensitivity_nu     = p_algo->speed_detection_threshold;
 8020db6:	68b7      	ldr	r7, [r6, #8]

	p_com_para->max_speed_mps              = p_algo->max_speed_kmph / 3.6f;
	p_com_para->min_speed_mps              = p_algo->min_speed_kmph / 3.6f;

	p_com_para->frame_time_sec             = p_dev->frame_period_usec / 1000000.0f;
	p_com_para->number_of_samples_nu       = (uint16_t)p_dev->num_samples_per_chirp;
 8020db8:	6a41      	ldr	r1, [r0, #36]	; 0x24
 8020dba:	81a1      	strh	r1, [r4, #12]
	device_settings_t *p_dev = ds_device_get_settings();

	p_com_para->max_speed_mps              = p_algo->max_speed_kmph / 3.6f;
	p_com_para->min_speed_mps              = p_algo->min_speed_kmph / 3.6f;

	p_com_para->frame_time_sec             = p_dev->frame_period_usec / 1000000.0f;
 8020dbc:	eef8 7a67 	vcvt.f32.u32	s15, s15
void copyStore2comPara(pulse_para_values_t *p_com_para)
{
	algo_settings_t *p_algo = ds_algo_get_settings();
	device_settings_t *p_dev = ds_device_get_settings();

	p_com_para->max_speed_mps              = p_algo->max_speed_kmph / 3.6f;
 8020dc0:	ee86 6a25 	vdiv.f32	s12, s12, s11

	p_com_para->sampling_freq_hz           = (float)p_dev->adc_sampling_freq_Hz;
	p_com_para->doppler_sensitivity_nu     = p_algo->speed_detection_threshold;
	p_com_para->motion_sensitivity_nu      = p_algo->motion_detection_threshold;

	p_com_para->use_high_gain_doppler_bool = (uint8_t)((p_algo->use_high_gain_doppler == 0L) ? 0U : 1U);
 8020dc4:	3300      	adds	r3, #0
 8020dc6:	bf18      	it	ne
 8020dc8:	2301      	movne	r3, #1
//============================================================================

void copyStore2comPara(pulse_para_values_t *p_com_para)
{
	algo_settings_t *p_algo = ds_algo_get_settings();
	device_settings_t *p_dev = ds_device_get_settings();
 8020dca:	4605      	mov	r5, r0

	p_com_para->sampling_freq_hz           = (float)p_dev->adc_sampling_freq_Hz;
	p_com_para->doppler_sensitivity_nu     = p_algo->speed_detection_threshold;
	p_com_para->motion_sensitivity_nu      = p_algo->motion_detection_threshold;

	p_com_para->use_high_gain_doppler_bool = (uint8_t)((p_algo->use_high_gain_doppler == 0L) ? 0U : 1U);
 8020dcc:	7723      	strb	r3, [r4, #28]
	p_com_para->frame_time_sec             = p_dev->frame_period_usec / 1000000.0f;
	p_com_para->number_of_samples_nu       = (uint16_t)p_dev->num_samples_per_chirp;

	p_com_para->sampling_freq_hz           = (float)p_dev->adc_sampling_freq_Hz;
	p_com_para->doppler_sensitivity_nu     = p_algo->speed_detection_threshold;
	p_com_para->motion_sensitivity_nu      = p_algo->motion_detection_threshold;
 8020dce:	61a2      	str	r2, [r4, #24]

	p_com_para->frame_time_sec             = p_dev->frame_period_usec / 1000000.0f;
	p_com_para->number_of_samples_nu       = (uint16_t)p_dev->num_samples_per_chirp;

	p_com_para->sampling_freq_hz           = (float)p_dev->adc_sampling_freq_Hz;
	p_com_para->doppler_sensitivity_nu     = p_algo->speed_detection_threshold;
 8020dd0:	6167      	str	r7, [r4, #20]
{
	algo_settings_t *p_algo = ds_algo_get_settings();
	device_settings_t *p_dev = ds_device_get_settings();

	p_com_para->max_speed_mps              = p_algo->max_speed_kmph / 3.6f;
	p_com_para->min_speed_mps              = p_algo->min_speed_kmph / 3.6f;
 8020dd2:	eec6 6aa5 	vdiv.f32	s13, s13, s11

	p_com_para->frame_time_sec             = p_dev->frame_period_usec / 1000000.0f;
 8020dd6:	eec7 7a85 	vdiv.f32	s15, s15, s10
	p_com_para->number_of_samples_nu       = (uint16_t)p_dev->num_samples_per_chirp;

	p_com_para->sampling_freq_hz           = (float)p_dev->adc_sampling_freq_Hz;
 8020dda:	eeb8 7a47 	vcvt.f32.u32	s14, s14
void copyStore2comPara(pulse_para_values_t *p_com_para)
{
	algo_settings_t *p_algo = ds_algo_get_settings();
	device_settings_t *p_dev = ds_device_get_settings();

	p_com_para->max_speed_mps              = p_algo->max_speed_kmph / 3.6f;
 8020dde:	ed84 6a00 	vstr	s12, [r4]
	p_com_para->min_speed_mps              = p_algo->min_speed_kmph / 3.6f;
 8020de2:	edc4 6a01 	vstr	s13, [r4, #4]

	p_com_para->frame_time_sec             = p_dev->frame_period_usec / 1000000.0f;
 8020de6:	edc4 7a02 	vstr	s15, [r4, #8]
	p_com_para->number_of_samples_nu       = (uint16_t)p_dev->num_samples_per_chirp;

	p_com_para->sampling_freq_hz           = (float)p_dev->adc_sampling_freq_Hz;
 8020dea:	ed84 7a04 	vstr	s14, [r4, #16]
	p_com_para->doppler_sensitivity_nu     = p_algo->speed_detection_threshold;
	p_com_para->motion_sensitivity_nu      = p_algo->motion_detection_threshold;

	p_com_para->use_high_gain_doppler_bool = (uint8_t)((p_algo->use_high_gain_doppler == 0L) ? 0U : 1U);

	uint32_t temp_frame_period_usec        = bsp_calc_min_frame_interval_usec(p_dev);
 8020dee:	f009 f96b 	bl	802a0c8 <bsp_calc_min_frame_interval_usec>

	p_com_para->continuous_mode_bool       = (temp_frame_period_usec == p_dev->frame_period_usec) ? 1 : 0;
 8020df2:	6a2b      	ldr	r3, [r5, #32]
 8020df4:	1a18      	subs	r0, r3, r0
 8020df6:	fab0 f080 	clz	r0, r0
 8020dfa:	0940      	lsrs	r0, r0, #5
 8020dfc:	7760      	strb	r0, [r4, #29]
	p_com_para->number_of_skip_samples_nu  = (uint16_t)p_dev->num_sample_skip_count;
 8020dfe:	6aea      	ldr	r2, [r5, #44]	; 0x2c
	p_com_para->pulse_width_usec           = p_dev->pulse_width_usec;
 8020e00:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 8020e02:	6223      	str	r3, [r4, #32]
	p_com_para->use_high_gain_doppler_bool = (uint8_t)((p_algo->use_high_gain_doppler == 0L) ? 0U : 1U);

	uint32_t temp_frame_period_usec        = bsp_calc_min_frame_interval_usec(p_dev);

	p_com_para->continuous_mode_bool       = (temp_frame_period_usec == p_dev->frame_period_usec) ? 1 : 0;
	p_com_para->number_of_skip_samples_nu  = (uint16_t)p_dev->num_sample_skip_count;
 8020e04:	83e2      	strh	r2, [r4, #30]
	p_com_para->pulse_width_usec           = p_dev->pulse_width_usec;
 8020e06:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8020e08:	40666666 	.word	0x40666666
 8020e0c:	49742400 	.word	0x49742400

08020e10 <copyComPara2Store>:
}

//============================================================================

uint32_t copyComPara2Store(pulse_para_values_t *p_com_para)
{
 8020e10:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8020e14:	b098      	sub	sp, #96	; 0x60
 8020e16:	4680      	mov	r8, r0
	algo_settings_t algo;
	device_settings_t dev;

	algo_settings_t *p_algo  = ds_algo_get_settings();
 8020e18:	f7ff f8fe 	bl	8020018 <ds_algo_get_settings>
 8020e1c:	4605      	mov	r5, r0
	device_settings_t *p_dev = ds_device_get_settings();
 8020e1e:	f7ff f96d 	bl	80200fc <ds_device_get_settings>

	uint32_t error = 0;

	memcpy(&algo, p_algo, sizeof(algo));
 8020e22:	6869      	ldr	r1, [r5, #4]
 8020e24:	68aa      	ldr	r2, [r5, #8]
 8020e26:	68eb      	ldr	r3, [r5, #12]
{
	algo_settings_t algo;
	device_settings_t dev;

	algo_settings_t *p_algo  = ds_algo_get_settings();
	device_settings_t *p_dev = ds_device_get_settings();
 8020e28:	4607      	mov	r7, r0

	uint32_t error = 0;

	memcpy(&algo, p_algo, sizeof(algo));
 8020e2a:	6828      	ldr	r0, [r5, #0]
 8020e2c:	ac01      	add	r4, sp, #4
 8020e2e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8020e30:	6928      	ldr	r0, [r5, #16]
 8020e32:	6969      	ldr	r1, [r5, #20]
 8020e34:	69aa      	ldr	r2, [r5, #24]
	memcpy(&dev, p_dev, sizeof(dev));
 8020e36:	f107 0c40 	add.w	ip, r7, #64	; 0x40
	algo_settings_t *p_algo  = ds_algo_get_settings();
	device_settings_t *p_dev = ds_device_get_settings();

	uint32_t error = 0;

	memcpy(&algo, p_algo, sizeof(algo));
 8020e3a:	c407      	stmia	r4!, {r0, r1, r2}
	memcpy(&dev, p_dev, sizeof(dev));
 8020e3c:	f10d 0e20 	add.w	lr, sp, #32
 8020e40:	463c      	mov	r4, r7
 8020e42:	6820      	ldr	r0, [r4, #0]
 8020e44:	6861      	ldr	r1, [r4, #4]
 8020e46:	68a2      	ldr	r2, [r4, #8]
 8020e48:	68e3      	ldr	r3, [r4, #12]
 8020e4a:	4676      	mov	r6, lr
 8020e4c:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 8020e4e:	3410      	adds	r4, #16
 8020e50:	4564      	cmp	r4, ip
 8020e52:	46b6      	mov	lr, r6
 8020e54:	d1f5      	bne.n	8020e42 <copyComPara2Store+0x32>

	algo.max_speed_kmph             = p_com_para->max_speed_mps * 3.6f;
 8020e56:	ed9f 6a38 	vldr	s12, [pc, #224]	; 8020f38 <copyComPara2Store+0x128>
 8020e5a:	edd8 6a00 	vldr	s13, [r8]
	algo.min_speed_kmph             = p_com_para->min_speed_mps * 3.6f;
 8020e5e:	ed98 7a01 	vldr	s14, [r8, #4]

	dev.num_samples_per_chirp       = (uint32_t)p_com_para->number_of_samples_nu;

	dev.adc_sampling_freq_Hz        = (uint32_t)p_com_para->sampling_freq_hz;
 8020e62:	edd8 7a04 	vldr	s15, [r8, #16]
	algo.speed_detection_threshold  = p_com_para->doppler_sensitivity_nu;
	algo.motion_detection_threshold = p_com_para->motion_sensitivity_nu;
	algo.use_high_gain_doppler      = (uint32_t)((p_com_para->use_high_gain_doppler_bool == 0L) ? 0L : 1L);
 8020e66:	f898 301c 	ldrb.w	r3, [r8, #28]
	algo.min_speed_kmph             = p_com_para->min_speed_mps * 3.6f;

	dev.num_samples_per_chirp       = (uint32_t)p_com_para->number_of_samples_nu;

	dev.adc_sampling_freq_Hz        = (uint32_t)p_com_para->sampling_freq_hz;
	algo.speed_detection_threshold  = p_com_para->doppler_sensitivity_nu;
 8020e6a:	f8d8 0014 	ldr.w	r0, [r8, #20]
	algo.motion_detection_threshold = p_com_para->motion_sensitivity_nu;
 8020e6e:	f8d8 6018 	ldr.w	r6, [r8, #24]
	memcpy(&dev, p_dev, sizeof(dev));

	algo.max_speed_kmph             = p_com_para->max_speed_mps * 3.6f;
	algo.min_speed_kmph             = p_com_para->min_speed_mps * 3.6f;

	dev.num_samples_per_chirp       = (uint32_t)p_com_para->number_of_samples_nu;
 8020e72:	f8b8 400c 	ldrh.w	r4, [r8, #12]

	dev.adc_sampling_freq_Hz        = (uint32_t)p_com_para->sampling_freq_hz;
	algo.speed_detection_threshold  = p_com_para->doppler_sensitivity_nu;
	algo.motion_detection_threshold = p_com_para->motion_sensitivity_nu;
	algo.use_high_gain_doppler      = (uint32_t)((p_com_para->use_high_gain_doppler_bool == 0L) ? 0L : 1L);
	dev.num_sample_skip_count       = (uint32_t)p_com_para->number_of_skip_samples_nu;
 8020e76:	f8b8 101e 	ldrh.w	r1, [r8, #30]
	dev.pulse_width_usec            = p_com_para->pulse_width_usec;
 8020e7a:	f8d8 2020 	ldr.w	r2, [r8, #32]
	algo.min_speed_kmph             = p_com_para->min_speed_mps * 3.6f;

	dev.num_samples_per_chirp       = (uint32_t)p_com_para->number_of_samples_nu;

	dev.adc_sampling_freq_Hz        = (uint32_t)p_com_para->sampling_freq_hz;
	algo.speed_detection_threshold  = p_com_para->doppler_sensitivity_nu;
 8020e7e:	9003      	str	r0, [sp, #12]
	algo.motion_detection_threshold = p_com_para->motion_sensitivity_nu;
	algo.use_high_gain_doppler      = (uint32_t)((p_com_para->use_high_gain_doppler_bool == 0L) ? 0L : 1L);
 8020e80:	3300      	adds	r3, #0
	uint32_t error = 0;

	memcpy(&algo, p_algo, sizeof(algo));
	memcpy(&dev, p_dev, sizeof(dev));

	algo.max_speed_kmph             = p_com_para->max_speed_mps * 3.6f;
 8020e82:	ee66 6a86 	vmul.f32	s13, s13, s12
	algo.min_speed_kmph             = p_com_para->min_speed_mps * 3.6f;
 8020e86:	ee27 7a06 	vmul.f32	s14, s14, s12

	dev.num_samples_per_chirp       = (uint32_t)p_com_para->number_of_samples_nu;

	dev.adc_sampling_freq_Hz        = (uint32_t)p_com_para->sampling_freq_hz;
 8020e8a:	eefc 7ae7 	vcvt.u32.f32	s15, s15
	algo.speed_detection_threshold  = p_com_para->doppler_sensitivity_nu;
	algo.motion_detection_threshold = p_com_para->motion_sensitivity_nu;
	algo.use_high_gain_doppler      = (uint32_t)((p_com_para->use_high_gain_doppler_bool == 0L) ? 0L : 1L);
 8020e8e:	bf18      	it	ne
 8020e90:	2301      	movne	r3, #1
	dev.num_sample_skip_count       = (uint32_t)p_com_para->number_of_skip_samples_nu;
	dev.pulse_width_usec            = p_com_para->pulse_width_usec;

	uint32_t temp_frame_period      = bsp_calc_min_frame_interval_usec(&dev);
 8020e92:	a808      	add	r0, sp, #32
	dev.num_samples_per_chirp       = (uint32_t)p_com_para->number_of_samples_nu;

	dev.adc_sampling_freq_Hz        = (uint32_t)p_com_para->sampling_freq_hz;
	algo.speed_detection_threshold  = p_com_para->doppler_sensitivity_nu;
	algo.motion_detection_threshold = p_com_para->motion_sensitivity_nu;
	algo.use_high_gain_doppler      = (uint32_t)((p_com_para->use_high_gain_doppler_bool == 0L) ? 0L : 1L);
 8020e94:	9306      	str	r3, [sp, #24]
	uint32_t error = 0;

	memcpy(&algo, p_algo, sizeof(algo));
	memcpy(&dev, p_dev, sizeof(dev));

	algo.max_speed_kmph             = p_com_para->max_speed_mps * 3.6f;
 8020e96:	edcd 6a05 	vstr	s13, [sp, #20]
	algo.min_speed_kmph             = p_com_para->min_speed_mps * 3.6f;
 8020e9a:	ed8d 7a04 	vstr	s14, [sp, #16]

	dev.num_samples_per_chirp       = (uint32_t)p_com_para->number_of_samples_nu;

	dev.adc_sampling_freq_Hz        = (uint32_t)p_com_para->sampling_freq_hz;
 8020e9e:	edcd 7a0d 	vstr	s15, [sp, #52]	; 0x34
	algo.speed_detection_threshold  = p_com_para->doppler_sensitivity_nu;
	algo.motion_detection_threshold = p_com_para->motion_sensitivity_nu;
 8020ea2:	9607      	str	r6, [sp, #28]
	memcpy(&dev, p_dev, sizeof(dev));

	algo.max_speed_kmph             = p_com_para->max_speed_mps * 3.6f;
	algo.min_speed_kmph             = p_com_para->min_speed_mps * 3.6f;

	dev.num_samples_per_chirp       = (uint32_t)p_com_para->number_of_samples_nu;
 8020ea4:	9411      	str	r4, [sp, #68]	; 0x44

	dev.adc_sampling_freq_Hz        = (uint32_t)p_com_para->sampling_freq_hz;
	algo.speed_detection_threshold  = p_com_para->doppler_sensitivity_nu;
	algo.motion_detection_threshold = p_com_para->motion_sensitivity_nu;
	algo.use_high_gain_doppler      = (uint32_t)((p_com_para->use_high_gain_doppler_bool == 0L) ? 0L : 1L);
	dev.num_sample_skip_count       = (uint32_t)p_com_para->number_of_skip_samples_nu;
 8020ea6:	9113      	str	r1, [sp, #76]	; 0x4c
	dev.pulse_width_usec            = p_com_para->pulse_width_usec;
 8020ea8:	9214      	str	r2, [sp, #80]	; 0x50

	uint32_t temp_frame_period      = bsp_calc_min_frame_interval_usec(&dev);
 8020eaa:	f009 f90d 	bl	802a0c8 <bsp_calc_min_frame_interval_usec>
	dev.frame_period_usec           = (uint32_t)((p_com_para->continuous_mode_bool == 1U) ? temp_frame_period : (p_com_para->frame_time_sec * 1000000.0f));
 8020eae:	f898 301d 	ldrb.w	r3, [r8, #29]
 8020eb2:	2b01      	cmp	r3, #1
 8020eb4:	d037      	beq.n	8020f26 <copyComPara2Store+0x116>
 8020eb6:	edd8 7a02 	vldr	s15, [r8, #8]
 8020eba:	ed9f 7a20 	vldr	s14, [pc, #128]	; 8020f3c <copyComPara2Store+0x12c>
 8020ebe:	ee67 7a87 	vmul.f32	s15, s15, s14
 8020ec2:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8020ec6:	ee17 3a90 	vmov	r3, s15
 8020eca:	4283      	cmp	r3, r0
 8020ecc:	bf38      	it	cc
 8020ece:	4603      	movcc	r3, r0
 8020ed0:	9310      	str	r3, [sp, #64]	; 0x40
	if (dev.frame_period_usec < temp_frame_period)
		dev.frame_period_usec = temp_frame_period;

	ds_set_device_parameter_changed();
 8020ed2:	f7ff fb7f 	bl	80205d4 <ds_set_device_parameter_changed>

	error += ds_algo_check_settings(&algo);
 8020ed6:	a801      	add	r0, sp, #4
 8020ed8:	f7ff f8a2 	bl	8020020 <ds_algo_check_settings>
 8020edc:	4604      	mov	r4, r0
	error += ds_dev_check_settings(&dev);
 8020ede:	a808      	add	r0, sp, #32
 8020ee0:	f7ff f8e4 	bl	80200ac <ds_dev_check_settings>

	if (error == 0)
 8020ee4:	42e0      	cmn	r0, r4
 8020ee6:	d003      	beq.n	8020ef0 <copyComPara2Store+0xe0>
		memcpy(p_algo, &algo, sizeof(algo));
		memcpy(p_dev, &dev, sizeof(dev));

		return 1;
	}
	return 0;
 8020ee8:	2000      	movs	r0, #0
}
 8020eea:	b018      	add	sp, #96	; 0x60
 8020eec:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	error += ds_algo_check_settings(&algo);
	error += ds_dev_check_settings(&dev);

	if (error == 0)
	{
		memcpy(p_algo, &algo, sizeof(algo));
 8020ef0:	ac01      	add	r4, sp, #4
 8020ef2:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8020ef4:	6028      	str	r0, [r5, #0]
 8020ef6:	6069      	str	r1, [r5, #4]
 8020ef8:	60aa      	str	r2, [r5, #8]
 8020efa:	60eb      	str	r3, [r5, #12]
 8020efc:	cc07      	ldmia	r4!, {r0, r1, r2}
		memcpy(p_dev, &dev, sizeof(dev));
 8020efe:	ae18      	add	r6, sp, #96	; 0x60
 8020f00:	ac08      	add	r4, sp, #32
	error += ds_algo_check_settings(&algo);
	error += ds_dev_check_settings(&dev);

	if (error == 0)
	{
		memcpy(p_algo, &algo, sizeof(algo));
 8020f02:	6128      	str	r0, [r5, #16]
 8020f04:	6169      	str	r1, [r5, #20]
 8020f06:	61aa      	str	r2, [r5, #24]
		memcpy(p_dev, &dev, sizeof(dev));
 8020f08:	4625      	mov	r5, r4
 8020f0a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8020f0c:	42b5      	cmp	r5, r6
 8020f0e:	6038      	str	r0, [r7, #0]
 8020f10:	6079      	str	r1, [r7, #4]
 8020f12:	60ba      	str	r2, [r7, #8]
 8020f14:	60fb      	str	r3, [r7, #12]
 8020f16:	462c      	mov	r4, r5
 8020f18:	f107 0710 	add.w	r7, r7, #16
 8020f1c:	d1f4      	bne.n	8020f08 <copyComPara2Store+0xf8>

		return 1;
 8020f1e:	2001      	movs	r0, #1
	}
	return 0;
}
 8020f20:	b018      	add	sp, #96	; 0x60
 8020f22:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	algo.use_high_gain_doppler      = (uint32_t)((p_com_para->use_high_gain_doppler_bool == 0L) ? 0L : 1L);
	dev.num_sample_skip_count       = (uint32_t)p_com_para->number_of_skip_samples_nu;
	dev.pulse_width_usec            = p_com_para->pulse_width_usec;

	uint32_t temp_frame_period      = bsp_calc_min_frame_interval_usec(&dev);
	dev.frame_period_usec           = (uint32_t)((p_com_para->continuous_mode_bool == 1U) ? temp_frame_period : (p_com_para->frame_time_sec * 1000000.0f));
 8020f26:	ee07 0a90 	vmov	s15, r0
 8020f2a:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8020f2e:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8020f32:	ee17 3a90 	vmov	r3, s15
 8020f36:	e7c8      	b.n	8020eca <copyComPara2Store+0xba>
 8020f38:	40666666 	.word	0x40666666
 8020f3c:	49742400 	.word	0x49742400

08020f40 <XMC_GPIO_Init>:
/*******************************************************************************
 * API IMPLEMENTATION
 *******************************************************************************/

void XMC_GPIO_Init(XMC_GPIO_PORT_t *const port, const uint8_t pin, const XMC_GPIO_CONFIG_t *const config)
{
 8020f40:	f001 03fc 	and.w	r3, r1, #252	; 0xfc
 8020f44:	4403      	add	r3, r0
 8020f46:	b5f0      	push	{r4, r5, r6, r7, lr}
  XMC_ASSERT("XMC_GPIO_Init: Invalid port", XMC_GPIO_CHECK_PORT(port));
  XMC_ASSERT("XMC_GPIO_Init: Invalid mode", XMC_GPIO_IsModeValid(config->mode));
 
  /* Switch to input */
  port->IOCR[pin >> 2U] &= (uint32_t)~(PORT_IOCR_PC_Msk << (PORT_IOCR_PC_Size * (pin & 0x3U)));
 8020f48:	f001 0503 	and.w	r5, r1, #3
 8020f4c:	691e      	ldr	r6, [r3, #16]
  /* HW port control is disabled */
  port->HWSEL &= ~(uint32_t)((uint32_t)PORT_HWSEL_Msk << ((uint32_t)pin << 1U));


  /* Enable digital input */
  if (XMC_GPIO_CHECK_ANALOG_PORT(port))
 8020f4e:	4f1c      	ldr	r7, [pc, #112]	; (8020fc0 <XMC_GPIO_Init+0x80>)
{
  XMC_ASSERT("XMC_GPIO_Init: Invalid port", XMC_GPIO_CHECK_PORT(port));
  XMC_ASSERT("XMC_GPIO_Init: Invalid mode", XMC_GPIO_IsModeValid(config->mode));
 
  /* Switch to input */
  port->IOCR[pin >> 2U] &= (uint32_t)~(PORT_IOCR_PC_Msk << (PORT_IOCR_PC_Size * (pin & 0x3U)));
 8020f50:	00ed      	lsls	r5, r5, #3
 8020f52:	24f8      	movs	r4, #248	; 0xf8
 8020f54:	40ac      	lsls	r4, r5
 8020f56:	ea26 0404 	bic.w	r4, r6, r4
 8020f5a:	611c      	str	r4, [r3, #16]

  /* HW port control is disabled */
  port->HWSEL &= ~(uint32_t)((uint32_t)PORT_HWSEL_Msk << ((uint32_t)pin << 1U));
 8020f5c:	6f46      	ldr	r6, [r0, #116]	; 0x74
 8020f5e:	ea4f 0e41 	mov.w	lr, r1, lsl #1
 8020f62:	2403      	movs	r4, #3
 8020f64:	fa04 f40e 	lsl.w	r4, r4, lr
 8020f68:	ea26 0404 	bic.w	r4, r6, r4


  /* Enable digital input */
  if (XMC_GPIO_CHECK_ANALOG_PORT(port))
 8020f6c:	42b8      	cmp	r0, r7
 
  /* Switch to input */
  port->IOCR[pin >> 2U] &= (uint32_t)~(PORT_IOCR_PC_Msk << (PORT_IOCR_PC_Size * (pin & 0x3U)));

  /* HW port control is disabled */
  port->HWSEL &= ~(uint32_t)((uint32_t)PORT_HWSEL_Msk << ((uint32_t)pin << 1U));
 8020f6e:	6744      	str	r4, [r0, #116]	; 0x74


  /* Enable digital input */
  if (XMC_GPIO_CHECK_ANALOG_PORT(port))
 8020f70:	d01d      	beq.n	8020fae <XMC_GPIO_Init+0x6e>
 8020f72:	4c14      	ldr	r4, [pc, #80]	; (8020fc4 <XMC_GPIO_Init+0x84>)
 8020f74:	42a0      	cmp	r0, r4
 8020f76:	d01a      	beq.n	8020fae <XMC_GPIO_Init+0x6e>
    port->PDISC &= ~(uint32_t)((uint32_t)0x1U << pin);
  }
  else
  {
    /* Set output level */
    port->OMR = (uint32_t)config->output_level << pin;
 8020f78:	6857      	ldr	r7, [r2, #4]

    /* Set output driver strength */
    port->PDR[pin >> 3U] &= (uint32_t)~(PORT_PDR_Msk << ((uint32_t)PORT_PDR_Size * ((uint32_t)pin & 0x7U)));
    port->PDR[pin >> 3U] |= (uint32_t)config->output_strength << ((uint32_t)PORT_PDR_Size * ((uint32_t)pin & 0x7U));
 8020f7a:	7a16      	ldrb	r6, [r2, #8]
 8020f7c:	08cc      	lsrs	r4, r1, #3
 8020f7e:	eb00 0484 	add.w	r4, r0, r4, lsl #2
    port->PDISC &= ~(uint32_t)((uint32_t)0x1U << pin);
  }
  else
  {
    /* Set output level */
    port->OMR = (uint32_t)config->output_level << pin;
 8020f82:	408f      	lsls	r7, r1
 8020f84:	6047      	str	r7, [r0, #4]

    /* Set output driver strength */
    port->PDR[pin >> 3U] &= (uint32_t)~(PORT_PDR_Msk << ((uint32_t)PORT_PDR_Size * ((uint32_t)pin & 0x7U)));
 8020f86:	f001 0107 	and.w	r1, r1, #7
 8020f8a:	6c27      	ldr	r7, [r4, #64]	; 0x40
 8020f8c:	0089      	lsls	r1, r1, #2
 8020f8e:	2007      	movs	r0, #7
 8020f90:	4088      	lsls	r0, r1
 8020f92:	ea27 0000 	bic.w	r0, r7, r0
 8020f96:	6420      	str	r0, [r4, #64]	; 0x40
    port->PDR[pin >> 3U] |= (uint32_t)config->output_strength << ((uint32_t)PORT_PDR_Size * ((uint32_t)pin & 0x7U));
 8020f98:	6c20      	ldr	r0, [r4, #64]	; 0x40
 8020f9a:	fa06 f101 	lsl.w	r1, r6, r1
 8020f9e:	4301      	orrs	r1, r0
 8020fa0:	6421      	str	r1, [r4, #64]	; 0x40
  }

  /* Set mode */
  port->IOCR[pin >> 2U] |= (uint32_t)config->mode << ((uint32_t)PORT_IOCR_PC_Size * ((uint32_t)pin & 0x3U));
 8020fa2:	7812      	ldrb	r2, [r2, #0]
 8020fa4:	6919      	ldr	r1, [r3, #16]
 8020fa6:	40aa      	lsls	r2, r5
 8020fa8:	430a      	orrs	r2, r1
 8020faa:	611a      	str	r2, [r3, #16]
 8020fac:	bdf0      	pop	{r4, r5, r6, r7, pc}


  /* Enable digital input */
  if (XMC_GPIO_CHECK_ANALOG_PORT(port))
  {
    port->PDISC &= ~(uint32_t)((uint32_t)0x1U << pin);
 8020fae:	6e04      	ldr	r4, [r0, #96]	; 0x60
 8020fb0:	2601      	movs	r6, #1
 8020fb2:	fa06 f101 	lsl.w	r1, r6, r1
 8020fb6:	ea24 0101 	bic.w	r1, r4, r1
 8020fba:	6601      	str	r1, [r0, #96]	; 0x60
 8020fbc:	e7f1      	b.n	8020fa2 <XMC_GPIO_Init+0x62>
 8020fbe:	bf00      	nop
 8020fc0:	48028e00 	.word	0x48028e00
 8020fc4:	48028f00 	.word	0x48028f00

08020fc8 <XMC_SCU_RESET_AssertPeripheralReset>:
}

/* API to manually assert a reset request */
void XMC_SCU_RESET_AssertPeripheralReset(const XMC_SCU_PERIPHERAL_RESET_t peripheral)
{
  uint32_t index = (uint32_t)((((uint32_t)peripheral) & 0xf0000000UL) >> 28UL);
 8020fc8:	0f03      	lsrs	r3, r0, #28
  uint32_t mask = (((uint32_t)peripheral) & ((uint32_t)~0xf0000000UL));

  *(uint32_t *)(&(SCU_RESET->PRSET0) + (index * 3U)) = (uint32_t)mask;
 8020fca:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8020fce:	4a03      	ldr	r2, [pc, #12]	; (8020fdc <XMC_SCU_RESET_AssertPeripheralReset+0x14>)

/* API to manually assert a reset request */
void XMC_SCU_RESET_AssertPeripheralReset(const XMC_SCU_PERIPHERAL_RESET_t peripheral)
{
  uint32_t index = (uint32_t)((((uint32_t)peripheral) & 0xf0000000UL) >> 28UL);
  uint32_t mask = (((uint32_t)peripheral) & ((uint32_t)~0xf0000000UL));
 8020fd0:	f020 4070 	bic.w	r0, r0, #4026531840	; 0xf0000000

  *(uint32_t *)(&(SCU_RESET->PRSET0) + (index * 3U)) = (uint32_t)mask;
 8020fd4:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
 8020fd8:	4770      	bx	lr
 8020fda:	bf00      	nop
 8020fdc:	50004410 	.word	0x50004410

08020fe0 <XMC_SCU_RESET_DeassertPeripheralReset>:
}

/* API to manually de-assert a reset request */
void XMC_SCU_RESET_DeassertPeripheralReset(const XMC_SCU_PERIPHERAL_RESET_t peripheral)
{
  uint32_t index = (uint32_t)((((uint32_t)peripheral) & 0xf0000000UL) >> 28UL);
 8020fe0:	0f03      	lsrs	r3, r0, #28
  uint32_t mask = (((uint32_t)peripheral) & ((uint32_t)~0xf0000000UL));

  *(uint32_t *)(&(SCU_RESET->PRCLR0) + (index * 3U)) = (uint32_t)mask;
 8020fe2:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8020fe6:	4a03      	ldr	r2, [pc, #12]	; (8020ff4 <XMC_SCU_RESET_DeassertPeripheralReset+0x14>)

/* API to manually de-assert a reset request */
void XMC_SCU_RESET_DeassertPeripheralReset(const XMC_SCU_PERIPHERAL_RESET_t peripheral)
{
  uint32_t index = (uint32_t)((((uint32_t)peripheral) & 0xf0000000UL) >> 28UL);
  uint32_t mask = (((uint32_t)peripheral) & ((uint32_t)~0xf0000000UL));
 8020fe8:	f020 4070 	bic.w	r0, r0, #4026531840	; 0xf0000000

  *(uint32_t *)(&(SCU_RESET->PRCLR0) + (index * 3U)) = (uint32_t)mask;
 8020fec:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
 8020ff0:	4770      	bx	lr
 8020ff2:	bf00      	nop
 8020ff4:	50004414 	.word	0x50004414

08020ff8 <XMC_SCU_RESET_IsPeripheralResetAsserted>:
}

/* Find out if the peripheral reset is asserted */
bool XMC_SCU_RESET_IsPeripheralResetAsserted(const XMC_SCU_PERIPHERAL_RESET_t peripheral)
{
  uint32_t index = (uint32_t)((((uint32_t)peripheral) & 0xf0000000UL) >> 28UL);
 8020ff8:	0f03      	lsrs	r3, r0, #28
  uint32_t mask = (((uint32_t)peripheral) & ((uint32_t)~0xf0000000UL));

  return ((*(uint32_t *)(&(SCU_RESET->PRSTAT0) + (index * 3U)) & mask) != 0U);
 8020ffa:	4a06      	ldr	r2, [pc, #24]	; (8021014 <XMC_SCU_RESET_IsPeripheralResetAsserted+0x1c>)
 8020ffc:	eb03 0343 	add.w	r3, r3, r3, lsl #1

/* Find out if the peripheral reset is asserted */
bool XMC_SCU_RESET_IsPeripheralResetAsserted(const XMC_SCU_PERIPHERAL_RESET_t peripheral)
{
  uint32_t index = (uint32_t)((((uint32_t)peripheral) & 0xf0000000UL) >> 28UL);
  uint32_t mask = (((uint32_t)peripheral) & ((uint32_t)~0xf0000000UL));
 8021000:	f020 4070 	bic.w	r0, r0, #4026531840	; 0xf0000000

  return ((*(uint32_t *)(&(SCU_RESET->PRSTAT0) + (index * 3U)) & mask) != 0U);
 8021004:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8021008:	4218      	tst	r0, r3
}
 802100a:	bf14      	ite	ne
 802100c:	2001      	movne	r0, #1
 802100e:	2000      	moveq	r0, #0
 8021010:	4770      	bx	lr
 8021012:	bf00      	nop
 8021014:	5000440c 	.word	0x5000440c

08021018 <XMC_SCU_CLOCK_GetPeripheralClockFrequency>:
 * API to retrieve clock frequency of peripherals on the peripheral bus using a shared functional clock
 */
uint32_t XMC_SCU_CLOCK_GetPeripheralClockFrequency(void)
{
  return (uint32_t)(XMC_SCU_CLOCK_GetCpuClockFrequency() >>
         ((SCU_CLK->PBCLKCR & SCU_CLK_PBCLKCR_PBDIV_Msk) >> SCU_CLK_PBCLKCR_PBDIV_Pos));  
 8021018:	4b03      	ldr	r3, [pc, #12]	; (8021028 <XMC_SCU_CLOCK_GetPeripheralClockFrequency+0x10>)
 * \par<b>Related APIs:</b><BR>
 * XMC_SCU_CLOCK_GetPeripheralClockFrequency(), XMC_SCU_CLOCK_GatePeripheralClock() \n\n\n
 */
__STATIC_INLINE uint32_t XMC_SCU_CLOCK_GetCpuClockFrequency(void)
{
  return SystemCoreClock;
 802101a:	4a04      	ldr	r2, [pc, #16]	; (802102c <XMC_SCU_CLOCK_GetPeripheralClockFrequency+0x14>)
 802101c:	695b      	ldr	r3, [r3, #20]
/*
 * API to retrieve clock frequency of peripherals on the peripheral bus using a shared functional clock
 */
uint32_t XMC_SCU_CLOCK_GetPeripheralClockFrequency(void)
{
  return (uint32_t)(XMC_SCU_CLOCK_GetCpuClockFrequency() >>
 802101e:	6810      	ldr	r0, [r2, #0]
 8021020:	f003 0301 	and.w	r3, r3, #1
         ((SCU_CLK->PBCLKCR & SCU_CLK_PBCLKCR_PBDIV_Msk) >> SCU_CLK_PBCLKCR_PBDIV_Pos));  
}
 8021024:	40d8      	lsrs	r0, r3
 8021026:	4770      	bx	lr
 8021028:	50004600 	.word	0x50004600
 802102c:	2003ffc0 	.word	0x2003ffc0

08021030 <XMC_SCU_CLOCK_SetUsbClockSource>:
}

/* API to select fUSB */
void XMC_SCU_CLOCK_SetUsbClockSource(const XMC_SCU_CLOCK_USBCLKSRC_t source)
{
  SCU_CLK->USBCLKCR = (SCU_CLK->USBCLKCR & ((uint32_t)~SCU_CLK_USBCLKCR_USBSEL_Msk)) |
 8021030:	4a03      	ldr	r2, [pc, #12]	; (8021040 <XMC_SCU_CLOCK_SetUsbClockSource+0x10>)
 8021032:	6993      	ldr	r3, [r2, #24]
 8021034:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8021038:	4318      	orrs	r0, r3
 802103a:	6190      	str	r0, [r2, #24]
 802103c:	4770      	bx	lr
 802103e:	bf00      	nop
 8021040:	50004600 	.word	0x50004600

08021044 <XMC_SCU_CLOCK_SetWdtClockSource>:
}

/* API to select fWDT */
void XMC_SCU_CLOCK_SetWdtClockSource(const XMC_SCU_CLOCK_WDTCLKSRC_t source)
{
  SCU_CLK->WDTCLKCR = (SCU_CLK->WDTCLKCR & ((uint32_t)~SCU_CLK_WDTCLKCR_WDTSEL_Msk)) |
 8021044:	4a03      	ldr	r2, [pc, #12]	; (8021054 <XMC_SCU_CLOCK_SetWdtClockSource+0x10>)
 8021046:	6a53      	ldr	r3, [r2, #36]	; 0x24
 8021048:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
 802104c:	4318      	orrs	r0, r3
 802104e:	6250      	str	r0, [r2, #36]	; 0x24
 8021050:	4770      	bx	lr
 8021052:	bf00      	nop
 8021054:	50004600 	.word	0x50004600

08021058 <XMC_SCU_HIB_SetRtcClockSource>:

/* API to select fRTC */
void XMC_SCU_HIB_SetRtcClockSource(const XMC_SCU_HIB_RTCCLKSRC_t source)
{ 
  /* Wait until the update of HDCR register in hibernate domain is completed */
  while((SCU_GENERAL->MIRRSTS) & SCU_GENERAL_MIRRSTS_HDCR_Msk)
 8021058:	4a05      	ldr	r2, [pc, #20]	; (8021070 <XMC_SCU_HIB_SetRtcClockSource+0x18>)
 802105a:	f8d2 30c4 	ldr.w	r3, [r2, #196]	; 0xc4
 802105e:	071b      	lsls	r3, r3, #28
 8021060:	d4fb      	bmi.n	802105a <XMC_SCU_HIB_SetRtcClockSource+0x2>
  {
  }

  SCU_HIBERNATE->HDCR = (SCU_HIBERNATE->HDCR & ((uint32_t)~SCU_HIBERNATE_HDCR_RCS_Msk)) |
 8021062:	4a04      	ldr	r2, [pc, #16]	; (8021074 <XMC_SCU_HIB_SetRtcClockSource+0x1c>)
 8021064:	68d3      	ldr	r3, [r2, #12]
 8021066:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 802106a:	4318      	orrs	r0, r3
 802106c:	60d0      	str	r0, [r2, #12]
 802106e:	4770      	bx	lr
 8021070:	50004000 	.word	0x50004000
 8021074:	50004300 	.word	0x50004300

08021078 <XMC_SCU_CLOCK_SetUsbClockDivider>:
void XMC_SCU_CLOCK_SetUsbClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetSdmmcClockDivider:Wrong clock divider value",
              (divider <= (SCU_CLK_USBCLKCR_USBDIV_Msk + 1UL)) );

  SCU_CLK->USBCLKCR = (SCU_CLK->USBCLKCR & ((uint32_t)~SCU_CLK_USBCLKCR_USBDIV_Msk)) |
 8021078:	4a03      	ldr	r2, [pc, #12]	; (8021088 <XMC_SCU_CLOCK_SetUsbClockDivider+0x10>)
 802107a:	6993      	ldr	r3, [r2, #24]
                      (uint32_t)((uint32_t)(divider - 1UL) << SCU_CLK_USBCLKCR_USBDIV_Pos); 
 802107c:	3801      	subs	r0, #1
void XMC_SCU_CLOCK_SetUsbClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetSdmmcClockDivider:Wrong clock divider value",
              (divider <= (SCU_CLK_USBCLKCR_USBDIV_Msk + 1UL)) );

  SCU_CLK->USBCLKCR = (SCU_CLK->USBCLKCR & ((uint32_t)~SCU_CLK_USBCLKCR_USBDIV_Msk)) |
 802107e:	f023 0307 	bic.w	r3, r3, #7
 8021082:	4303      	orrs	r3, r0
 8021084:	6193      	str	r3, [r2, #24]
 8021086:	4770      	bx	lr
 8021088:	50004600 	.word	0x50004600

0802108c <XMC_SCU_CLOCK_SetEbuClockDivider>:
void XMC_SCU_CLOCK_SetEbuClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetEbuClockDivider:Wrong clock divider value",
              (divider <= (SCU_CLK_EBUCLKCR_EBUDIV_Msk + 1UL) ) );

  SCU_CLK->EBUCLKCR = (SCU_CLK->EBUCLKCR & ((uint32_t)~SCU_CLK_EBUCLKCR_EBUDIV_Msk)) |
 802108c:	4a03      	ldr	r2, [pc, #12]	; (802109c <XMC_SCU_CLOCK_SetEbuClockDivider+0x10>)
 802108e:	69d3      	ldr	r3, [r2, #28]
                      (uint32_t)(((uint32_t)(divider - 1UL)) << SCU_CLK_EBUCLKCR_EBUDIV_Pos);
 8021090:	3801      	subs	r0, #1
void XMC_SCU_CLOCK_SetEbuClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetEbuClockDivider:Wrong clock divider value",
              (divider <= (SCU_CLK_EBUCLKCR_EBUDIV_Msk + 1UL) ) );

  SCU_CLK->EBUCLKCR = (SCU_CLK->EBUCLKCR & ((uint32_t)~SCU_CLK_EBUCLKCR_EBUDIV_Msk)) |
 8021092:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 8021096:	4303      	orrs	r3, r0
 8021098:	61d3      	str	r3, [r2, #28]
 802109a:	4770      	bx	lr
 802109c:	50004600 	.word	0x50004600

080210a0 <XMC_SCU_CLOCK_SetWdtClockDivider>:
void XMC_SCU_CLOCK_SetWdtClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetWdtClockDivider:Wrong clock divider value",
              (divider <= (SCU_CLK_WDTCLKCR_WDTDIV_Msk + 1UL) ) );

  SCU_CLK->WDTCLKCR = (SCU_CLK->WDTCLKCR & ((uint32_t)~SCU_CLK_WDTCLKCR_WDTDIV_Msk)) |
 80210a0:	4a03      	ldr	r2, [pc, #12]	; (80210b0 <XMC_SCU_CLOCK_SetWdtClockDivider+0x10>)
 80210a2:	6a53      	ldr	r3, [r2, #36]	; 0x24
                      (uint32_t)(((uint32_t)(divider - 1UL)) << SCU_CLK_WDTCLKCR_WDTDIV_Pos);
 80210a4:	3801      	subs	r0, #1
void XMC_SCU_CLOCK_SetWdtClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetWdtClockDivider:Wrong clock divider value",
              (divider <= (SCU_CLK_WDTCLKCR_WDTDIV_Msk + 1UL) ) );

  SCU_CLK->WDTCLKCR = (SCU_CLK->WDTCLKCR & ((uint32_t)~SCU_CLK_WDTCLKCR_WDTDIV_Msk)) |
 80210a6:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
 80210aa:	4303      	orrs	r3, r0
 80210ac:	6253      	str	r3, [r2, #36]	; 0x24
 80210ae:	4770      	bx	lr
 80210b0:	50004600 	.word	0x50004600

080210b4 <XMC_SCU_CLOCK_EnableClock>:
#endif

/* API to enable a given module clock */
void XMC_SCU_CLOCK_EnableClock(const XMC_SCU_CLOCK_t clock)
{
  SCU_CLK->CLKSET = ((uint32_t)clock);
 80210b4:	4b01      	ldr	r3, [pc, #4]	; (80210bc <XMC_SCU_CLOCK_EnableClock+0x8>)
 80210b6:	6058      	str	r0, [r3, #4]
 80210b8:	4770      	bx	lr
 80210ba:	bf00      	nop
 80210bc:	50004600 	.word	0x50004600

080210c0 <XMC_SCU_CLOCK_GatePeripheralClock>:

#if defined(CLOCK_GATING_SUPPORTED)
/* API to gate a given module clock */
void XMC_SCU_CLOCK_GatePeripheralClock(const XMC_SCU_PERIPHERAL_CLOCK_t peripheral)
{
  uint32_t index = (peripheral & 0xf0000000UL) >> 28UL;
 80210c0:	0f03      	lsrs	r3, r0, #28
  uint32_t mask = (peripheral & (uint32_t)~0xf0000000UL);

  *(uint32_t *)((&(SCU_CLK->CGATSET0)) + (index * 3U)) = (uint32_t)mask;
 80210c2:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 80210c6:	4a03      	ldr	r2, [pc, #12]	; (80210d4 <XMC_SCU_CLOCK_GatePeripheralClock+0x14>)
#if defined(CLOCK_GATING_SUPPORTED)
/* API to gate a given module clock */
void XMC_SCU_CLOCK_GatePeripheralClock(const XMC_SCU_PERIPHERAL_CLOCK_t peripheral)
{
  uint32_t index = (peripheral & 0xf0000000UL) >> 28UL;
  uint32_t mask = (peripheral & (uint32_t)~0xf0000000UL);
 80210c8:	f020 4070 	bic.w	r0, r0, #4026531840	; 0xf0000000

  *(uint32_t *)((&(SCU_CLK->CGATSET0)) + (index * 3U)) = (uint32_t)mask;
 80210cc:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
 80210d0:	4770      	bx	lr
 80210d2:	bf00      	nop
 80210d4:	50004644 	.word	0x50004644

080210d8 <XMC_SCU_CLOCK_UngatePeripheralClock>:
}

/* API to ungate a given module clock */
void XMC_SCU_CLOCK_UngatePeripheralClock(const XMC_SCU_PERIPHERAL_CLOCK_t peripheral)
{
  uint32_t index = (uint32_t)((peripheral & 0xf0000000UL) >> 28UL);
 80210d8:	0f03      	lsrs	r3, r0, #28
  uint32_t mask = (peripheral & (uint32_t)~0xf0000000UL);

  *(uint32_t *)(&(SCU_CLK->CGATCLR0) + (index * 3U)) = (uint32_t)mask;
 80210da:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 80210de:	4a03      	ldr	r2, [pc, #12]	; (80210ec <XMC_SCU_CLOCK_UngatePeripheralClock+0x14>)

/* API to ungate a given module clock */
void XMC_SCU_CLOCK_UngatePeripheralClock(const XMC_SCU_PERIPHERAL_CLOCK_t peripheral)
{
  uint32_t index = (uint32_t)((peripheral & 0xf0000000UL) >> 28UL);
  uint32_t mask = (peripheral & (uint32_t)~0xf0000000UL);
 80210e0:	f020 4070 	bic.w	r0, r0, #4026531840	; 0xf0000000

  *(uint32_t *)(&(SCU_CLK->CGATCLR0) + (index * 3U)) = (uint32_t)mask;
 80210e4:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
 80210e8:	4770      	bx	lr
 80210ea:	bf00      	nop
 80210ec:	50004648 	.word	0x50004648

080210f0 <XMC_SCU_CLOCK_IsPeripheralClockGated>:
}

/* API to ungate a given module clock */
bool XMC_SCU_CLOCK_IsPeripheralClockGated(const XMC_SCU_PERIPHERAL_CLOCK_t peripheral)
{
  uint32_t index = ((peripheral & 0xf0000000UL) >> 28UL);
 80210f0:	0f03      	lsrs	r3, r0, #28
  uint32_t mask = (peripheral & (uint32_t)~0xf0000000UL);

  return ((*(uint32_t *)(&(SCU_CLK->CGATSTAT0) + (index * 3U)) & mask) != 0U);
 80210f2:	4a06      	ldr	r2, [pc, #24]	; (802110c <XMC_SCU_CLOCK_IsPeripheralClockGated+0x1c>)
 80210f4:	eb03 0343 	add.w	r3, r3, r3, lsl #1

/* API to ungate a given module clock */
bool XMC_SCU_CLOCK_IsPeripheralClockGated(const XMC_SCU_PERIPHERAL_CLOCK_t peripheral)
{
  uint32_t index = ((peripheral & 0xf0000000UL) >> 28UL);
  uint32_t mask = (peripheral & (uint32_t)~0xf0000000UL);
 80210f8:	f020 4070 	bic.w	r0, r0, #4026531840	; 0xf0000000

  return ((*(uint32_t *)(&(SCU_CLK->CGATSTAT0) + (index * 3U)) & mask) != 0U);
 80210fc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8021100:	4218      	tst	r0, r3
}
 8021102:	bf14      	ite	ne
 8021104:	2001      	movne	r0, #1
 8021106:	2000      	moveq	r0, #0
 8021108:	4770      	bx	lr
 802110a:	bf00      	nop
 802110c:	50004640 	.word	0x50004640

08021110 <XMC_SCU_CLOCK_StartUsbPll>:

/* API to configure USB PLL */
void XMC_SCU_CLOCK_StartUsbPll(uint32_t pdiv, uint32_t ndiv)
{
  /* Go to bypass the USB PLL */
  SCU_PLL->USBPLLCON |= (uint32_t)SCU_PLL_USBPLLCON_VCOBYP_Msk;
 8021110:	4b0f      	ldr	r3, [pc, #60]	; (8021150 <XMC_SCU_CLOCK_StartUsbPll+0x40>)
 8021112:	695a      	ldr	r2, [r3, #20]
 8021114:	f042 0201 	orr.w	r2, r2, #1
 8021118:	615a      	str	r2, [r3, #20]

  /* disconnect Oscillator from USB PLL */
  SCU_PLL->USBPLLCON |= (uint32_t)SCU_PLL_USBPLLCON_FINDIS_Msk;
 802111a:	695a      	ldr	r2, [r3, #20]

  /* Setup Divider settings for USB PLL */
  SCU_PLL->USBPLLCON = (uint32_t)((uint32_t)((ndiv -1U) << SCU_PLL_USBPLLCON_NDIV_Pos) |
                       (uint32_t)((pdiv - 1U) << SCU_PLL_USBPLLCON_PDIV_Pos));
 802111c:	3801      	subs	r0, #1
 802111e:	0600      	lsls	r0, r0, #24

  /* disconnect Oscillator from USB PLL */
  SCU_PLL->USBPLLCON |= (uint32_t)SCU_PLL_USBPLLCON_FINDIS_Msk;

  /* Setup Divider settings for USB PLL */
  SCU_PLL->USBPLLCON = (uint32_t)((uint32_t)((ndiv -1U) << SCU_PLL_USBPLLCON_NDIV_Pos) |
 8021120:	3901      	subs	r1, #1
{
  /* Go to bypass the USB PLL */
  SCU_PLL->USBPLLCON |= (uint32_t)SCU_PLL_USBPLLCON_VCOBYP_Msk;

  /* disconnect Oscillator from USB PLL */
  SCU_PLL->USBPLLCON |= (uint32_t)SCU_PLL_USBPLLCON_FINDIS_Msk;
 8021122:	f042 0210 	orr.w	r2, r2, #16

  /* Setup Divider settings for USB PLL */
  SCU_PLL->USBPLLCON = (uint32_t)((uint32_t)((ndiv -1U) << SCU_PLL_USBPLLCON_NDIV_Pos) |
 8021126:	ea40 2001 	orr.w	r0, r0, r1, lsl #8
{
  /* Go to bypass the USB PLL */
  SCU_PLL->USBPLLCON |= (uint32_t)SCU_PLL_USBPLLCON_VCOBYP_Msk;

  /* disconnect Oscillator from USB PLL */
  SCU_PLL->USBPLLCON |= (uint32_t)SCU_PLL_USBPLLCON_FINDIS_Msk;
 802112a:	615a      	str	r2, [r3, #20]

  /* Setup Divider settings for USB PLL */
  SCU_PLL->USBPLLCON = (uint32_t)((uint32_t)((ndiv -1U) << SCU_PLL_USBPLLCON_NDIV_Pos) |
 802112c:	6158      	str	r0, [r3, #20]
                       (uint32_t)((pdiv - 1U) << SCU_PLL_USBPLLCON_PDIV_Pos));

  /* Set OSCDISCDIS */
  SCU_PLL->USBPLLCON |= (uint32_t)SCU_PLL_USBPLLCON_OSCDISCDIS_Msk;
 802112e:	695a      	ldr	r2, [r3, #20]
 8021130:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8021134:	615a      	str	r2, [r3, #20]

  /* connect Oscillator to USB PLL */
  SCU_PLL->USBPLLCON &= (uint32_t)~SCU_PLL_USBPLLCON_FINDIS_Msk;
 8021136:	695a      	ldr	r2, [r3, #20]
 8021138:	f022 0210 	bic.w	r2, r2, #16
 802113c:	615a      	str	r2, [r3, #20]

  /* restart PLL Lock detection */
  SCU_PLL->USBPLLCON |= (uint32_t)SCU_PLL_USBPLLCON_RESLD_Msk;
 802113e:	695a      	ldr	r2, [r3, #20]
 8021140:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 8021144:	615a      	str	r2, [r3, #20]

  while ((SCU_PLL->USBPLLSTAT & SCU_PLL_USBPLLSTAT_VCOLOCK_Msk) == 0U)
 8021146:	691a      	ldr	r2, [r3, #16]
 8021148:	0752      	lsls	r2, r2, #29
 802114a:	d5fc      	bpl.n	8021146 <XMC_SCU_CLOCK_StartUsbPll+0x36>
  {
    /* wait for PLL Lock */
  }

}
 802114c:	4770      	bx	lr
 802114e:	bf00      	nop
 8021150:	50004710 	.word	0x50004710

08021154 <XMC_SCU_POWER_EnableUsb>:

/* API to enable USB Phy and comparator */
void XMC_SCU_POWER_EnableUsb(void)
{
#if defined(USB_OTG_SUPPORTED)
  SCU_POWER->PWRSET = (uint32_t)(SCU_POWER_PWRSET_USBOTGEN_Msk | SCU_POWER_PWRSET_USBPHYPDQ_Msk);
 8021154:	4b02      	ldr	r3, [pc, #8]	; (8021160 <XMC_SCU_POWER_EnableUsb+0xc>)
 8021156:	f44f 3240 	mov.w	r2, #196608	; 0x30000
 802115a:	605a      	str	r2, [r3, #4]
 802115c:	4770      	bx	lr
 802115e:	bf00      	nop
 8021160:	50004200 	.word	0x50004200

08021164 <XMC_SCU_POWER_DisableUsb>:

/* API to power down USB Phy and comparator */
void XMC_SCU_POWER_DisableUsb(void)
{
#if defined(USB_OTG_SUPPORTED)
  SCU_POWER->PWRCLR = (uint32_t)(SCU_POWER_PWRCLR_USBOTGEN_Msk | SCU_POWER_PWRSET_USBPHYPDQ_Msk);
 8021164:	4b02      	ldr	r3, [pc, #8]	; (8021170 <XMC_SCU_POWER_DisableUsb+0xc>)
 8021166:	f44f 3240 	mov.w	r2, #196608	; 0x30000
 802116a:	609a      	str	r2, [r3, #8]
 802116c:	4770      	bx	lr
 802116e:	bf00      	nop
 8021170:	50004200 	.word	0x50004200

08021174 <XMC_SCU_CLOCK_StartSystemPll>:
void XMC_SCU_CLOCK_StartSystemPll(XMC_SCU_CLOCK_SYSPLLCLKSRC_t source,
                                  XMC_SCU_CLOCK_SYSPLL_MODE_t mode,
                                  uint32_t pdiv,
                                  uint32_t ndiv,
                                  uint32_t kdiv)
{
 8021174:	b5f0      	push	{r4, r5, r6, r7, lr}
 8021176:	b083      	sub	sp, #12
void XMC_SCU_CLOCK_SetSystemPllClockSource(const XMC_SCU_CLOCK_SYSPLLCLKSRC_t source)
{
  /* Check input clock */
  if (source == XMC_SCU_CLOCK_SYSPLLCLKSRC_OSCHP) /* Select PLLClockSource */
  {
    SCU_PLL->PLLCON2 &= (uint32_t)~(SCU_PLL_PLLCON2_PINSEL_Msk | SCU_PLL_PLLCON2_K1INSEL_Msk);
 8021178:	4c64      	ldr	r4, [pc, #400]	; (802130c <XMC_SCU_CLOCK_StartSystemPll+0x198>)
void XMC_SCU_CLOCK_StartSystemPll(XMC_SCU_CLOCK_SYSPLLCLKSRC_t source,
                                  XMC_SCU_CLOCK_SYSPLL_MODE_t mode,
                                  uint32_t pdiv,
                                  uint32_t ndiv,
                                  uint32_t kdiv)
{
 802117a:	9e08      	ldr	r6, [sp, #32]

/* API to select fPLL */
void XMC_SCU_CLOCK_SetSystemPllClockSource(const XMC_SCU_CLOCK_SYSPLLCLKSRC_t source)
{
  /* Check input clock */
  if (source == XMC_SCU_CLOCK_SYSPLLCLKSRC_OSCHP) /* Select PLLClockSource */
 802117c:	b1c0      	cbz	r0, 80211b0 <XMC_SCU_CLOCK_StartSystemPll+0x3c>
  {
    SCU_PLL->PLLCON2 &= (uint32_t)~(SCU_PLL_PLLCON2_PINSEL_Msk | SCU_PLL_PLLCON2_K1INSEL_Msk);
  }
  else
  {
    SCU_PLL->PLLCON2 |= (uint32_t)(SCU_PLL_PLLCON2_PINSEL_Msk | SCU_PLL_PLLCON2_K1INSEL_Msk);
 802117e:	68e0      	ldr	r0, [r4, #12]
 8021180:	f440 7080 	orr.w	r0, r0, #256	; 0x100
 8021184:	f040 0001 	orr.w	r0, r0, #1
  uint32_t vco_frequency; /* Q10.22, max VCO frequency = 520MHz */
  uint32_t kdiv_temp;

  XMC_SCU_CLOCK_SetSystemPllClockSource(source);

  if (mode == XMC_SCU_CLOCK_SYSPLL_MODE_NORMAL)
 8021188:	2901      	cmp	r1, #1
  {
    SCU_PLL->PLLCON2 &= (uint32_t)~(SCU_PLL_PLLCON2_PINSEL_Msk | SCU_PLL_PLLCON2_K1INSEL_Msk);
  }
  else
  {
    SCU_PLL->PLLCON2 |= (uint32_t)(SCU_PLL_PLLCON2_PINSEL_Msk | SCU_PLL_PLLCON2_K1INSEL_Msk);
 802118a:	60e0      	str	r0, [r4, #12]
  uint32_t vco_frequency; /* Q10.22, max VCO frequency = 520MHz */
  uint32_t kdiv_temp;

  XMC_SCU_CLOCK_SetSystemPllClockSource(source);

  if (mode == XMC_SCU_CLOCK_SYSPLL_MODE_NORMAL)
 802118c:	f000 8086 	beq.w	802129c <XMC_SCU_CLOCK_StartSystemPll+0x128>

    XMC_SCU_CLOCK_StepSystemPllFrequency(kdiv);
  }
  else
  {
    SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~SCU_PLL_PLLCON1_K1DIV_Msk) |
 8021190:	4a5e      	ldr	r2, [pc, #376]	; (802130c <XMC_SCU_CLOCK_StartSystemPll+0x198>)
 8021192:	6893      	ldr	r3, [r2, #8]
                       ((kdiv -1UL) << SCU_PLL_PLLCON1_K1DIV_Pos));
 8021194:	3e01      	subs	r6, #1

    XMC_SCU_CLOCK_StepSystemPllFrequency(kdiv);
  }
  else
  {
    SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~SCU_PLL_PLLCON1_K1DIV_Msk) |
 8021196:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 802119a:	431e      	orrs	r6, r3
 802119c:	6096      	str	r6, [r2, #8]
                       ((kdiv -1UL) << SCU_PLL_PLLCON1_K1DIV_Pos));

    /* Switch to prescaler mode */
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_VCOBYP_Msk;
 802119e:	6853      	ldr	r3, [r2, #4]
 80211a0:	f043 0301 	orr.w	r3, r3, #1
 80211a4:	6053      	str	r3, [r2, #4]

    while ((SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_VCOBYST_Msk) == 0U)
 80211a6:	6813      	ldr	r3, [r2, #0]
 80211a8:	07db      	lsls	r3, r3, #31
 80211aa:	d5fc      	bpl.n	80211a6 <XMC_SCU_CLOCK_StartSystemPll+0x32>
    {
      /* wait for prescaler mode */
    }
  }
}
 80211ac:	b003      	add	sp, #12
 80211ae:	bdf0      	pop	{r4, r5, r6, r7, pc}
void XMC_SCU_CLOCK_SetSystemPllClockSource(const XMC_SCU_CLOCK_SYSPLLCLKSRC_t source)
{
  /* Check input clock */
  if (source == XMC_SCU_CLOCK_SYSPLLCLKSRC_OSCHP) /* Select PLLClockSource */
  {
    SCU_PLL->PLLCON2 &= (uint32_t)~(SCU_PLL_PLLCON2_PINSEL_Msk | SCU_PLL_PLLCON2_K1INSEL_Msk);
 80211b0:	68e0      	ldr	r0, [r4, #12]
 80211b2:	f420 7080 	bic.w	r0, r0, #256	; 0x100
 80211b6:	f020 0001 	bic.w	r0, r0, #1
  uint32_t vco_frequency; /* Q10.22, max VCO frequency = 520MHz */
  uint32_t kdiv_temp;

  XMC_SCU_CLOCK_SetSystemPllClockSource(source);

  if (mode == XMC_SCU_CLOCK_SYSPLL_MODE_NORMAL)
 80211ba:	2901      	cmp	r1, #1
void XMC_SCU_CLOCK_SetSystemPllClockSource(const XMC_SCU_CLOCK_SYSPLLCLKSRC_t source)
{
  /* Check input clock */
  if (source == XMC_SCU_CLOCK_SYSPLLCLKSRC_OSCHP) /* Select PLLClockSource */
  {
    SCU_PLL->PLLCON2 &= (uint32_t)~(SCU_PLL_PLLCON2_PINSEL_Msk | SCU_PLL_PLLCON2_K1INSEL_Msk);
 80211bc:	60e0      	str	r0, [r4, #12]
  uint32_t vco_frequency; /* Q10.22, max VCO frequency = 520MHz */
  uint32_t kdiv_temp;

  XMC_SCU_CLOCK_SetSystemPllClockSource(source);

  if (mode == XMC_SCU_CLOCK_SYSPLL_MODE_NORMAL)
 80211be:	d1e7      	bne.n	8021190 <XMC_SCU_CLOCK_StartSystemPll+0x1c>
 80211c0:	e88d 000c 	stmia.w	sp, {r2, r3}
  {
    /* Calculate initial step to be close to fOFI */
    if (source == XMC_SCU_CLOCK_SYSPLLCLKSRC_OSCHP)
    {
      vco_frequency = (OSCHP_GetFrequency() / 1000000U) << 22;
 80211c4:	f006 fc6c 	bl	8027aa0 <OSCHP_GetFrequency>
 80211c8:	4d51      	ldr	r5, [pc, #324]	; (8021310 <XMC_SCU_CLOCK_StartSystemPll+0x19c>)
 80211ca:	fba5 3500 	umull	r3, r5, r5, r0
 80211ce:	e89d 000c 	ldmia.w	sp, {r2, r3}
 80211d2:	0cad      	lsrs	r5, r5, #18
 80211d4:	05ad      	lsls	r5, r5, #22
    }
    vco_frequency = ((vco_frequency * ndiv) / pdiv);
    kdiv_temp = (vco_frequency / (OFI_FREQUENCY / 1000000U)) >> 22;

    /* Switch to prescaler mode */
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_VCOBYP_Msk;
 80211d6:	494d      	ldr	r1, [pc, #308]	; (802130c <XMC_SCU_CLOCK_StartSystemPll+0x198>)
    else
    {
      vco_frequency = (OFI_FREQUENCY / 1000000U) << 22;
    }
    vco_frequency = ((vco_frequency * ndiv) / pdiv);
    kdiv_temp = (vco_frequency / (OFI_FREQUENCY / 1000000U)) >> 22;
 80211d8:	4c4e      	ldr	r4, [pc, #312]	; (8021314 <XMC_SCU_CLOCK_StartSystemPll+0x1a0>)

    /* Switch to prescaler mode */
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_VCOBYP_Msk;
 80211da:	684f      	ldr	r7, [r1, #4]

    /* disconnect Oscillator from PLL */
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_FINDIS_Msk;

    /* Setup divider settings for main PLL */
    SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~(SCU_PLL_PLLCON1_NDIV_Msk | SCU_PLL_PLLCON1_K2DIV_Msk |
 80211dc:	484e      	ldr	r0, [pc, #312]	; (8021318 <XMC_SCU_CLOCK_StartSystemPll+0x1a4>)
    }
    vco_frequency = ((vco_frequency * ndiv) / pdiv);
    kdiv_temp = (vco_frequency / (OFI_FREQUENCY / 1000000U)) >> 22;

    /* Switch to prescaler mode */
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_VCOBYP_Msk;
 80211de:	f047 0701 	orr.w	r7, r7, #1
 80211e2:	604f      	str	r7, [r1, #4]

    /* disconnect Oscillator from PLL */
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_FINDIS_Msk;
 80211e4:	684f      	ldr	r7, [r1, #4]
 80211e6:	f047 0710 	orr.w	r7, r7, #16
 80211ea:	604f      	str	r7, [r1, #4]

    /* Setup divider settings for main PLL */
    SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~(SCU_PLL_PLLCON1_NDIV_Msk | SCU_PLL_PLLCON1_K2DIV_Msk |
 80211ec:	f8d1 e008 	ldr.w	lr, [r1, #8]
    }
    else
    {
      vco_frequency = (OFI_FREQUENCY / 1000000U) << 22;
    }
    vco_frequency = ((vco_frequency * ndiv) / pdiv);
 80211f0:	fb03 f505 	mul.w	r5, r3, r5

    /* Setup divider settings for main PLL */
    SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~(SCU_PLL_PLLCON1_NDIV_Msk | SCU_PLL_PLLCON1_K2DIV_Msk |
                                   SCU_PLL_PLLCON1_PDIV_Msk)) | ((ndiv - 1UL) << SCU_PLL_PLLCON1_NDIV_Pos) |
                                   ((kdiv_temp - 1UL) << SCU_PLL_PLLCON1_K2DIV_Pos) |
                                   ((pdiv - 1UL)<< SCU_PLL_PLLCON1_PDIV_Pos));
 80211f4:	1e57      	subs	r7, r2, #1
    }
    else
    {
      vco_frequency = (OFI_FREQUENCY / 1000000U) << 22;
    }
    vco_frequency = ((vco_frequency * ndiv) / pdiv);
 80211f6:	fbb5 f5f2 	udiv	r5, r5, r2

    /* disconnect Oscillator from PLL */
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_FINDIS_Msk;

    /* Setup divider settings for main PLL */
    SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~(SCU_PLL_PLLCON1_NDIV_Msk | SCU_PLL_PLLCON1_K2DIV_Msk |
 80211fa:	ea0e 0000 	and.w	r0, lr, r0
    else
    {
      vco_frequency = (OFI_FREQUENCY / 1000000U) << 22;
    }
    vco_frequency = ((vco_frequency * ndiv) / pdiv);
    kdiv_temp = (vco_frequency / (OFI_FREQUENCY / 1000000U)) >> 22;
 80211fe:	fba4 4205 	umull	r4, r2, r4, r5
 8021202:	ea40 6007 	orr.w	r0, r0, r7, lsl #24
    /* disconnect Oscillator from PLL */
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_FINDIS_Msk;

    /* Setup divider settings for main PLL */
    SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~(SCU_PLL_PLLCON1_NDIV_Msk | SCU_PLL_PLLCON1_K2DIV_Msk |
                                   SCU_PLL_PLLCON1_PDIV_Msk)) | ((ndiv - 1UL) << SCU_PLL_PLLCON1_NDIV_Pos) |
 8021206:	1e5c      	subs	r4, r3, #1
    else
    {
      vco_frequency = (OFI_FREQUENCY / 1000000U) << 22;
    }
    vco_frequency = ((vco_frequency * ndiv) / pdiv);
    kdiv_temp = (vco_frequency / (OFI_FREQUENCY / 1000000U)) >> 22;
 8021208:	0e93      	lsrs	r3, r2, #26
 802120a:	ea40 2004 	orr.w	r0, r0, r4, lsl #8
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_FINDIS_Msk;

    /* Setup divider settings for main PLL */
    SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~(SCU_PLL_PLLCON1_NDIV_Msk | SCU_PLL_PLLCON1_K2DIV_Msk |
                                   SCU_PLL_PLLCON1_PDIV_Msk)) | ((ndiv - 1UL) << SCU_PLL_PLLCON1_NDIV_Pos) |
                                   ((kdiv_temp - 1UL) << SCU_PLL_PLLCON1_K2DIV_Pos) |
 802120e:	3b01      	subs	r3, #1

    /* disconnect Oscillator from PLL */
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_FINDIS_Msk;

    /* Setup divider settings for main PLL */
    SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~(SCU_PLL_PLLCON1_NDIV_Msk | SCU_PLL_PLLCON1_K2DIV_Msk |
 8021210:	ea40 4303 	orr.w	r3, r0, r3, lsl #16
 8021214:	608b      	str	r3, [r1, #8]
                                   SCU_PLL_PLLCON1_PDIV_Msk)) | ((ndiv - 1UL) << SCU_PLL_PLLCON1_NDIV_Pos) |
                                   ((kdiv_temp - 1UL) << SCU_PLL_PLLCON1_K2DIV_Pos) |
                                   ((pdiv - 1UL)<< SCU_PLL_PLLCON1_PDIV_Pos));

    /* Set OSCDISCDIS, OSC clock remains connected to the VCO in case of loss of lock */
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_OSCDISCDIS_Msk;
 8021216:	684b      	ldr	r3, [r1, #4]
 8021218:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 802121c:	604b      	str	r3, [r1, #4]

    /* connect Oscillator to PLL */
    SCU_PLL->PLLCON0 &= (uint32_t)~SCU_PLL_PLLCON0_FINDIS_Msk;
 802121e:	684b      	ldr	r3, [r1, #4]
 8021220:	f023 0310 	bic.w	r3, r3, #16
 8021224:	604b      	str	r3, [r1, #4]

    /* restart PLL Lock detection */
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_RESLD_Msk;
 8021226:	684b      	ldr	r3, [r1, #4]
 8021228:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 802122c:	604b      	str	r3, [r1, #4]
    while ((SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_VCOLOCK_Msk) == 0U)
 802122e:	6808      	ldr	r0, [r1, #0]
 8021230:	4b36      	ldr	r3, [pc, #216]	; (802130c <XMC_SCU_CLOCK_StartSystemPll+0x198>)
 8021232:	0742      	lsls	r2, r0, #29
 8021234:	d5fb      	bpl.n	802122e <XMC_SCU_CLOCK_StartSystemPll+0xba>
    {
      /* wait for PLL Lock */
    }

    /* Switch to normal mode */
    SCU_PLL->PLLCON0 &= (uint32_t)~SCU_PLL_PLLCON0_VCOBYP_Msk;
 8021236:	685a      	ldr	r2, [r3, #4]
 8021238:	f022 0201 	bic.w	r2, r2, #1
 802123c:	605a      	str	r2, [r3, #4]
    while ((SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_VCOBYST_Msk) != 0U)
 802123e:	4619      	mov	r1, r3
 8021240:	680b      	ldr	r3, [r1, #0]
 8021242:	4a32      	ldr	r2, [pc, #200]	; (802130c <XMC_SCU_CLOCK_StartSystemPll+0x198>)
 8021244:	f013 0401 	ands.w	r4, r3, #1
 8021248:	d1fa      	bne.n	8021240 <XMC_SCU_CLOCK_StartSystemPll+0xcc>
    {
      /* wait for normal mode */
    }

    /* Ramp up PLL frequency in steps */
    kdiv_temp = (vco_frequency / 60UL) >> 22;
 802124a:	4b34      	ldr	r3, [pc, #208]	; (802131c <XMC_SCU_CLOCK_StartSystemPll+0x1a8>)
 802124c:	fba3 1305 	umull	r1, r3, r3, r5
 8021250:	0edb      	lsrs	r3, r3, #27
    if (kdiv < kdiv_temp)
 8021252:	429e      	cmp	r6, r3
 8021254:	d33f      	bcc.n	80212d6 <XMC_SCU_CLOCK_StartSystemPll+0x162>
 8021256:	4f32      	ldr	r7, [pc, #200]	; (8021320 <XMC_SCU_CLOCK_StartSystemPll+0x1ac>)
    {
      XMC_SCU_CLOCK_StepSystemPllFrequency(kdiv_temp);
    }

    kdiv_temp = (vco_frequency / 90UL) >> 22;
 8021258:	4b32      	ldr	r3, [pc, #200]	; (8021324 <XMC_SCU_CLOCK_StartSystemPll+0x1b0>)
 802125a:	086d      	lsrs	r5, r5, #1
 802125c:	fba3 2305 	umull	r2, r3, r3, r5
 8021260:	0edb      	lsrs	r3, r3, #27
    if (kdiv < kdiv_temp)
 8021262:	429e      	cmp	r6, r3
 8021264:	d31d      	bcc.n	80212a2 <XMC_SCU_CLOCK_StartSystemPll+0x12e>
}

/* API to step up/down the main PLL frequency */
void XMC_SCU_CLOCK_StepSystemPllFrequency(uint32_t kdiv)
{
  SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~SCU_PLL_PLLCON1_K2DIV_Msk) |
 8021266:	4a29      	ldr	r2, [pc, #164]	; (802130c <XMC_SCU_CLOCK_StartSystemPll+0x198>)
 8021268:	6893      	ldr	r3, [r2, #8]
                     ((kdiv - 1UL) << SCU_PLL_PLLCON1_K2DIV_Pos));
 802126a:	3e01      	subs	r6, #1
}

/* API to step up/down the main PLL frequency */
void XMC_SCU_CLOCK_StepSystemPllFrequency(uint32_t kdiv)
{
  SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~SCU_PLL_PLLCON1_K2DIV_Msk) |
 802126c:	f423 03fe 	bic.w	r3, r3, #8323072	; 0x7f0000
 8021270:	ea43 4606 	orr.w	r6, r3, r6, lsl #16
 8021274:	6096      	str	r6, [r2, #8]
/* This is a local function used to generate the delay until register get updated with new configured value.  */
void XMC_SCU_lDelay(uint32_t delay)
{
  uint32_t i;

  SystemCoreClockUpdate();
 8021276:	f7ff fa93 	bl	80207a0 <SystemCoreClockUpdate>
  delay =  delay * (uint32_t)(SystemCoreClock / FREQ_1MHZ);
 802127a:	683b      	ldr	r3, [r7, #0]
 802127c:	4a24      	ldr	r2, [pc, #144]	; (8021310 <XMC_SCU_CLOCK_StartSystemPll+0x19c>)
 802127e:	fba2 3203 	umull	r3, r2, r2, r3
 8021282:	0c92      	lsrs	r2, r2, #18
 8021284:	2332      	movs	r3, #50	; 0x32
 8021286:	fb03 f202 	mul.w	r2, r3, r2

  for (i = 0U; i < delay; ++i)
 802128a:	2300      	movs	r3, #0
 802128c:	2a00      	cmp	r2, #0
 802128e:	d08d      	beq.n	80211ac <XMC_SCU_CLOCK_StartSystemPll+0x38>
  {
    __NOP();
 8021290:	bf00      	nop
  uint32_t i;

  SystemCoreClockUpdate();
  delay =  delay * (uint32_t)(SystemCoreClock / FREQ_1MHZ);

  for (i = 0U; i < delay; ++i)
 8021292:	3301      	adds	r3, #1
 8021294:	4293      	cmp	r3, r2
 8021296:	d1fb      	bne.n	8021290 <XMC_SCU_CLOCK_StartSystemPll+0x11c>
    while ((SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_VCOBYST_Msk) == 0U)
    {
      /* wait for prescaler mode */
    }
  }
}
 8021298:	b003      	add	sp, #12
 802129a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    {
      vco_frequency = (OSCHP_GetFrequency() / 1000000U) << 22;
    }
    else
    {
      vco_frequency = (OFI_FREQUENCY / 1000000U) << 22;
 802129c:	f04f 65c0 	mov.w	r5, #100663296	; 0x6000000
 80212a0:	e799      	b.n	80211d6 <XMC_SCU_CLOCK_StartSystemPll+0x62>
}

/* API to step up/down the main PLL frequency */
void XMC_SCU_CLOCK_StepSystemPllFrequency(uint32_t kdiv)
{
  SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~SCU_PLL_PLLCON1_K2DIV_Msk) |
 80212a2:	491a      	ldr	r1, [pc, #104]	; (802130c <XMC_SCU_CLOCK_StartSystemPll+0x198>)
 80212a4:	688a      	ldr	r2, [r1, #8]
                     ((kdiv - 1UL) << SCU_PLL_PLLCON1_K2DIV_Pos));
 80212a6:	3b01      	subs	r3, #1
}

/* API to step up/down the main PLL frequency */
void XMC_SCU_CLOCK_StepSystemPllFrequency(uint32_t kdiv)
{
  SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~SCU_PLL_PLLCON1_K2DIV_Msk) |
 80212a8:	f422 02fe 	bic.w	r2, r2, #8323072	; 0x7f0000
 80212ac:	ea42 4303 	orr.w	r3, r2, r3, lsl #16
 80212b0:	608b      	str	r3, [r1, #8]
/* This is a local function used to generate the delay until register get updated with new configured value.  */
void XMC_SCU_lDelay(uint32_t delay)
{
  uint32_t i;

  SystemCoreClockUpdate();
 80212b2:	f7ff fa75 	bl	80207a0 <SystemCoreClockUpdate>
  delay =  delay * (uint32_t)(SystemCoreClock / FREQ_1MHZ);
 80212b6:	683b      	ldr	r3, [r7, #0]
 80212b8:	4a15      	ldr	r2, [pc, #84]	; (8021310 <XMC_SCU_CLOCK_StartSystemPll+0x19c>)
 80212ba:	fba2 3203 	umull	r3, r2, r2, r3
 80212be:	0c92      	lsrs	r2, r2, #18
 80212c0:	2332      	movs	r3, #50	; 0x32
 80212c2:	fb03 f202 	mul.w	r2, r3, r2

  for (i = 0U; i < delay; ++i)
 80212c6:	2a00      	cmp	r2, #0
 80212c8:	d0cd      	beq.n	8021266 <XMC_SCU_CLOCK_StartSystemPll+0xf2>
 80212ca:	2300      	movs	r3, #0
  {
    __NOP();
 80212cc:	bf00      	nop
  uint32_t i;

  SystemCoreClockUpdate();
  delay =  delay * (uint32_t)(SystemCoreClock / FREQ_1MHZ);

  for (i = 0U; i < delay; ++i)
 80212ce:	3301      	adds	r3, #1
 80212d0:	4293      	cmp	r3, r2
 80212d2:	d1fb      	bne.n	80212cc <XMC_SCU_CLOCK_StartSystemPll+0x158>
 80212d4:	e7c7      	b.n	8021266 <XMC_SCU_CLOCK_StartSystemPll+0xf2>
}

/* API to step up/down the main PLL frequency */
void XMC_SCU_CLOCK_StepSystemPllFrequency(uint32_t kdiv)
{
  SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~SCU_PLL_PLLCON1_K2DIV_Msk) |
 80212d6:	6891      	ldr	r1, [r2, #8]
void XMC_SCU_lDelay(uint32_t delay)
{
  uint32_t i;

  SystemCoreClockUpdate();
  delay =  delay * (uint32_t)(SystemCoreClock / FREQ_1MHZ);
 80212d8:	4f11      	ldr	r7, [pc, #68]	; (8021320 <XMC_SCU_CLOCK_StartSystemPll+0x1ac>)
}

/* API to step up/down the main PLL frequency */
void XMC_SCU_CLOCK_StepSystemPllFrequency(uint32_t kdiv)
{
  SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~SCU_PLL_PLLCON1_K2DIV_Msk) |
 80212da:	f421 01fe 	bic.w	r1, r1, #8323072	; 0x7f0000
                     ((kdiv - 1UL) << SCU_PLL_PLLCON1_K2DIV_Pos));
 80212de:	3b01      	subs	r3, #1
}

/* API to step up/down the main PLL frequency */
void XMC_SCU_CLOCK_StepSystemPllFrequency(uint32_t kdiv)
{
  SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~SCU_PLL_PLLCON1_K2DIV_Msk) |
 80212e0:	ea41 4303 	orr.w	r3, r1, r3, lsl #16
 80212e4:	6093      	str	r3, [r2, #8]
/* This is a local function used to generate the delay until register get updated with new configured value.  */
void XMC_SCU_lDelay(uint32_t delay)
{
  uint32_t i;

  SystemCoreClockUpdate();
 80212e6:	f7ff fa5b 	bl	80207a0 <SystemCoreClockUpdate>
  delay =  delay * (uint32_t)(SystemCoreClock / FREQ_1MHZ);
 80212ea:	683b      	ldr	r3, [r7, #0]
 80212ec:	4a08      	ldr	r2, [pc, #32]	; (8021310 <XMC_SCU_CLOCK_StartSystemPll+0x19c>)
 80212ee:	fba2 3203 	umull	r3, r2, r2, r3
 80212f2:	0c92      	lsrs	r2, r2, #18
 80212f4:	2332      	movs	r3, #50	; 0x32
 80212f6:	fb03 f202 	mul.w	r2, r3, r2

  for (i = 0U; i < delay; ++i)
 80212fa:	2a00      	cmp	r2, #0
 80212fc:	d0ac      	beq.n	8021258 <XMC_SCU_CLOCK_StartSystemPll+0xe4>
 80212fe:	4623      	mov	r3, r4
  {
    __NOP();
 8021300:	bf00      	nop
  uint32_t i;

  SystemCoreClockUpdate();
  delay =  delay * (uint32_t)(SystemCoreClock / FREQ_1MHZ);

  for (i = 0U; i < delay; ++i)
 8021302:	3301      	adds	r3, #1
 8021304:	4293      	cmp	r3, r2
 8021306:	d1fb      	bne.n	8021300 <XMC_SCU_CLOCK_StartSystemPll+0x18c>
 8021308:	e7a6      	b.n	8021258 <XMC_SCU_CLOCK_StartSystemPll+0xe4>
 802130a:	bf00      	nop
 802130c:	50004710 	.word	0x50004710
 8021310:	431bde83 	.word	0x431bde83
 8021314:	aaaaaaab 	.word	0xaaaaaaab
 8021318:	f08080ff 	.word	0xf08080ff
 802131c:	88888889 	.word	0x88888889
 8021320:	2003ffc0 	.word	0x2003ffc0
 8021324:	b60b60b7 	.word	0xb60b60b7

08021328 <XMC_SCU_CLOCK_Init>:
}

/* API to select fSYS */
void XMC_SCU_CLOCK_SetSystemClockSource(const XMC_SCU_CLOCK_SYSCLKSRC_t source)
{
  SCU_CLK->SYSCLKCR = (SCU_CLK->SYSCLKCR & ((uint32_t)~SCU_CLK_SYSCLKCR_SYSSEL_Msk)) |
 8021328:	4977      	ldr	r1, [pc, #476]	; (8021508 <XMC_SCU_CLOCK_Init+0x1e0>)

/* API to power up the hibernation domain */
void XMC_SCU_HIB_EnableHibernateDomain(void)
{
  /* Power up HIB domain if and only if it is currently powered down */
  if((SCU_POWER->PWRSTAT & SCU_POWER_PWRSTAT_HIBEN_Msk) == 0UL)
 802132a:	4a78      	ldr	r2, [pc, #480]	; (802150c <XMC_SCU_CLOCK_Init+0x1e4>)
}

/* API to select fSYS */
void XMC_SCU_CLOCK_SetSystemClockSource(const XMC_SCU_CLOCK_SYSCLKSRC_t source)
{
  SCU_CLK->SYSCLKCR = (SCU_CLK->SYSCLKCR & ((uint32_t)~SCU_CLK_SYSCLKCR_SYSSEL_Msk)) |
 802132c:	68cb      	ldr	r3, [r1, #12]
  return (SCU_GENERAL->RMDATA);
}

/* API to initialize the clock tree */
void XMC_SCU_CLOCK_Init(const XMC_SCU_CLOCK_CONFIG_t *const config)
{
 802132e:	b5f0      	push	{r4, r5, r6, r7, lr}
}

/* API to select fSYS */
void XMC_SCU_CLOCK_SetSystemClockSource(const XMC_SCU_CLOCK_SYSCLKSRC_t source)
{
  SCU_CLK->SYSCLKCR = (SCU_CLK->SYSCLKCR & ((uint32_t)~SCU_CLK_SYSCLKCR_SYSSEL_Msk)) |
 8021330:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8021334:	60cb      	str	r3, [r1, #12]

/* API to power up the hibernation domain */
void XMC_SCU_HIB_EnableHibernateDomain(void)
{
  /* Power up HIB domain if and only if it is currently powered down */
  if((SCU_POWER->PWRSTAT & SCU_POWER_PWRSTAT_HIBEN_Msk) == 0UL)
 8021336:	6813      	ldr	r3, [r2, #0]
  return (SCU_GENERAL->RMDATA);
}

/* API to initialize the clock tree */
void XMC_SCU_CLOCK_Init(const XMC_SCU_CLOCK_CONFIG_t *const config)
{
 8021338:	4605      	mov	r5, r0

/* API to power up the hibernation domain */
void XMC_SCU_HIB_EnableHibernateDomain(void)
{
  /* Power up HIB domain if and only if it is currently powered down */
  if((SCU_POWER->PWRSTAT & SCU_POWER_PWRSTAT_HIBEN_Msk) == 0UL)
 802133a:	07d8      	lsls	r0, r3, #31
  return (SCU_GENERAL->RMDATA);
}

/* API to initialize the clock tree */
void XMC_SCU_CLOCK_Init(const XMC_SCU_CLOCK_CONFIG_t *const config)
{
 802133c:	b083      	sub	sp, #12

/* API to power up the hibernation domain */
void XMC_SCU_HIB_EnableHibernateDomain(void)
{
  /* Power up HIB domain if and only if it is currently powered down */
  if((SCU_POWER->PWRSTAT & SCU_POWER_PWRSTAT_HIBEN_Msk) == 0UL)
 802133e:	d404      	bmi.n	802134a <XMC_SCU_CLOCK_Init+0x22>
  {
    SCU_POWER->PWRSET = (uint32_t)SCU_POWER_PWRSET_HIB_Msk;
 8021340:	2301      	movs	r3, #1
 8021342:	6053      	str	r3, [r2, #4]
    
    while((SCU_POWER->PWRSTAT & SCU_POWER_PWRSTAT_HIBEN_Msk) == 0UL)
 8021344:	6813      	ldr	r3, [r2, #0]
 8021346:	07db      	lsls	r3, r3, #31
 8021348:	d5fc      	bpl.n	8021344 <XMC_SCU_CLOCK_Init+0x1c>
      /* wait until HIB domain is enabled */
    }    
  }
  
  /* Remove the reset only if HIB domain were in a state of reset */
  if((SCU_RESET->RSTSTAT) & SCU_RESET_RSTSTAT_HIBRS_Msk)
 802134a:	4a71      	ldr	r2, [pc, #452]	; (8021510 <XMC_SCU_CLOCK_Init+0x1e8>)
 802134c:	6813      	ldr	r3, [r2, #0]
 802134e:	0599      	lsls	r1, r3, #22
 8021350:	d505      	bpl.n	802135e <XMC_SCU_CLOCK_Init+0x36>
  {
    SCU_RESET->RSTCLR = (uint32_t)SCU_RESET_RSTCLR_HIBRS_Msk;
 8021352:	f44f 7300 	mov.w	r3, #512	; 0x200
 8021356:	6093      	str	r3, [r2, #8]
    while((SCU_RESET->RSTSTAT & SCU_RESET_RSTSTAT_HIBRS_Msk) != 0UL)
 8021358:	6813      	ldr	r3, [r2, #0]
 802135a:	059f      	lsls	r7, r3, #22
 802135c:	d4fc      	bmi.n	8021358 <XMC_SCU_CLOCK_Init+0x30>

  XMC_SCU_CLOCK_SetSystemClockSource(XMC_SCU_CLOCK_SYSCLKSRC_OFI);

  XMC_SCU_HIB_EnableHibernateDomain();

  if (config->enable_osculp == true)
 802135e:	79eb      	ldrb	r3, [r5, #7]
 8021360:	2b00      	cmp	r3, #0
 8021362:	f040 8091 	bne.w	8021488 <XMC_SCU_CLOCK_Init+0x160>
  {
    XMC_SCU_CLOCK_EnableLowPowerOscillator();
    while (XMC_SCU_CLOCK_IsLowPowerOscillatorStable() == false);
  }
  
  XMC_SCU_HIB_SetStandbyClockSource(config->fstdby_clksrc);  
 8021366:	7a68      	ldrb	r0, [r5, #9]
}

/* API to select fSTDBY */
void XMC_SCU_HIB_SetStandbyClockSource(const XMC_SCU_HIB_STDBYCLKSRC_t source)
{
  while((SCU_GENERAL->MIRRSTS) & SCU_GENERAL_MIRRSTS_HDCR_Msk)
 8021368:	4a6a      	ldr	r2, [pc, #424]	; (8021514 <XMC_SCU_CLOCK_Init+0x1ec>)
 802136a:	f8d2 30c4 	ldr.w	r3, [r2, #196]	; 0xc4
 802136e:	071b      	lsls	r3, r3, #28
 8021370:	d4fb      	bmi.n	802136a <XMC_SCU_CLOCK_Init+0x42>
  {
    /* check SCU_MIRRSTS to ensure that no transfer over serial interface is pending */
  }
  SCU_HIBERNATE->HDCR = (SCU_HIBERNATE->HDCR & ((uint32_t)~SCU_HIBERNATE_HDCR_STDBYSEL_Msk)) |
 8021372:	4969      	ldr	r1, [pc, #420]	; (8021518 <XMC_SCU_CLOCK_Init+0x1f0>)
 * is busy with executing the previous operation.\n
 * Note: There is no hibernate domain in XMC1x devices. This register is retained for legacy purpose.
 */
__STATIC_INLINE uint32_t XMC_SCU_GetMirrorStatus(void)
{
  return(SCU_GENERAL->MIRRSTS);
 8021374:	4b67      	ldr	r3, [pc, #412]	; (8021514 <XMC_SCU_CLOCK_Init+0x1ec>)
 8021376:	68ca      	ldr	r2, [r1, #12]
 8021378:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 802137c:	4302      	orrs	r2, r0
 802137e:	60ca      	str	r2, [r1, #12]
 8021380:	f8d3 40c4 	ldr.w	r4, [r3, #196]	; 0xc4
    XMC_SCU_CLOCK_EnableLowPowerOscillator();
    while (XMC_SCU_CLOCK_IsLowPowerOscillatorStable() == false);
  }
  
  XMC_SCU_HIB_SetStandbyClockSource(config->fstdby_clksrc);  
  while (XMC_SCU_GetMirrorStatus() != 0)
 8021384:	2c00      	cmp	r4, #0
 8021386:	d1fb      	bne.n	8021380 <XMC_SCU_CLOCK_Init+0x58>

/* API to onfigure the calibration mode for internal oscillator */
void XMC_SCU_CLOCK_SetBackupClockCalibrationMode(XMC_SCU_CLOCK_FOFI_CALIBRATION_MODE_t mode)
{
  /* Enable factory calibration based trimming */
  SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_FOTR_Msk;
 8021388:	4a64      	ldr	r2, [pc, #400]	; (802151c <XMC_SCU_CLOCK_Init+0x1f4>)
  while (XMC_SCU_GetMirrorStatus() != 0)
  {
    /* Wait until update of the stanby clock source is done in the HIB domain */    
  }

  XMC_SCU_CLOCK_SetBackupClockCalibrationMode(config->calibration_mode);
 802138a:	7a29      	ldrb	r1, [r5, #8]

/* API to onfigure the calibration mode for internal oscillator */
void XMC_SCU_CLOCK_SetBackupClockCalibrationMode(XMC_SCU_CLOCK_FOFI_CALIBRATION_MODE_t mode)
{
  /* Enable factory calibration based trimming */
  SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_FOTR_Msk;
 802138c:	6853      	ldr	r3, [r2, #4]

  if (mode == XMC_SCU_CLOCK_FOFI_CALIBRATION_MODE_AUTOMATIC)
 802138e:	2901      	cmp	r1, #1

/* API to onfigure the calibration mode for internal oscillator */
void XMC_SCU_CLOCK_SetBackupClockCalibrationMode(XMC_SCU_CLOCK_FOFI_CALIBRATION_MODE_t mode)
{
  /* Enable factory calibration based trimming */
  SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_FOTR_Msk;
 8021390:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8021394:	6053      	str	r3, [r2, #4]

  if (mode == XMC_SCU_CLOCK_FOFI_CALIBRATION_MODE_AUTOMATIC)
 8021396:	f000 809d 	beq.w	80214d4 <XMC_SCU_CLOCK_Init+0x1ac>
 802139a:	4e61      	ldr	r6, [pc, #388]	; (8021520 <XMC_SCU_CLOCK_Init+0x1f8>)
/* This is a local function used to generate the delay until register get updated with new configured value.  */
void XMC_SCU_lDelay(uint32_t delay)
{
  uint32_t i;

  SystemCoreClockUpdate();
 802139c:	f7ff fa00 	bl	80207a0 <SystemCoreClockUpdate>
  delay =  delay * (uint32_t)(SystemCoreClock / FREQ_1MHZ);
 80213a0:	6833      	ldr	r3, [r6, #0]
 80213a2:	4a60      	ldr	r2, [pc, #384]	; (8021524 <XMC_SCU_CLOCK_Init+0x1fc>)
 80213a4:	fba2 3203 	umull	r3, r2, r2, r3
 80213a8:	0c92      	lsrs	r2, r2, #18
 80213aa:	2364      	movs	r3, #100	; 0x64
 80213ac:	fb03 f202 	mul.w	r2, r3, r2

  for (i = 0U; i < delay; ++i)
 80213b0:	b122      	cbz	r2, 80213bc <XMC_SCU_CLOCK_Init+0x94>
 80213b2:	2300      	movs	r3, #0
  {
    __NOP();
 80213b4:	bf00      	nop
  uint32_t i;

  SystemCoreClockUpdate();
  delay =  delay * (uint32_t)(SystemCoreClock / FREQ_1MHZ);

  for (i = 0U; i < delay; ++i)
 80213b6:	3301      	adds	r3, #1
 80213b8:	4293      	cmp	r3, r2
 80213ba:	d1fb      	bne.n	80213b4 <XMC_SCU_CLOCK_Init+0x8c>
void XMC_SCU_CLOCK_SetSystemClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetSystemClockDivider:Wrong clock divider value",
              (divider <= (SCU_CLK_SYSCLKCR_SYSDIV_Msk + 1UL)) );

  SCU_CLK->SYSCLKCR = (SCU_CLK->SYSCLKCR & ((uint32_t)~SCU_CLK_SYSCLKCR_SYSDIV_Msk)) |
 80213bc:	4b52      	ldr	r3, [pc, #328]	; (8021508 <XMC_SCU_CLOCK_Init+0x1e0>)
    /* Wait until update of the stanby clock source is done in the HIB domain */    
  }

  XMC_SCU_CLOCK_SetBackupClockCalibrationMode(config->calibration_mode);

  XMC_SCU_CLOCK_SetSystemClockDivider((uint32_t)config->fsys_clkdiv);
 80213be:	7c2c      	ldrb	r4, [r5, #16]
void XMC_SCU_CLOCK_SetSystemClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetSystemClockDivider:Wrong clock divider value",
              (divider <= (SCU_CLK_SYSCLKCR_SYSDIV_Msk + 1UL)) );

  SCU_CLK->SYSCLKCR = (SCU_CLK->SYSCLKCR & ((uint32_t)~SCU_CLK_SYSCLKCR_SYSDIV_Msk)) |
 80213c0:	68da      	ldr	r2, [r3, #12]
  XMC_SCU_CLOCK_SetSystemClockDivider((uint32_t)config->fsys_clkdiv);
  XMC_SCU_CLOCK_SetCpuClockDivider((uint32_t)config->fcpu_clkdiv);
  XMC_SCU_CLOCK_SetCcuClockDivider((uint32_t)config->fccu_clkdiv);
  XMC_SCU_CLOCK_SetPeripheralClockDivider((uint32_t)config->fperipheral_clkdiv);

  if (config->enable_oschp == true)
 80213c2:	79a8      	ldrb	r0, [r5, #6]
void XMC_SCU_CLOCK_SetSystemClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetSystemClockDivider:Wrong clock divider value",
              (divider <= (SCU_CLK_SYSCLKCR_SYSDIV_Msk + 1UL)) );

  SCU_CLK->SYSCLKCR = (SCU_CLK->SYSCLKCR & ((uint32_t)~SCU_CLK_SYSCLKCR_SYSDIV_Msk)) |
 80213c4:	f022 01ff 	bic.w	r1, r2, #255	; 0xff
                      ((uint32_t)(((uint32_t)(divider - 1UL)) << SCU_CLK_SYSCLKCR_SYSDIV_Pos));
 80213c8:	1e62      	subs	r2, r4, #1
void XMC_SCU_CLOCK_SetSystemClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetSystemClockDivider:Wrong clock divider value",
              (divider <= (SCU_CLK_SYSCLKCR_SYSDIV_Msk + 1UL)) );

  SCU_CLK->SYSCLKCR = (SCU_CLK->SYSCLKCR & ((uint32_t)~SCU_CLK_SYSCLKCR_SYSDIV_Msk)) |
 80213ca:	430a      	orrs	r2, r1
 80213cc:	60da      	str	r2, [r3, #12]
/* API to program the divider placed between fcpu and its parent */
void XMC_SCU_CLOCK_SetCpuClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetCpuClockDivider:Wrong clock divider value", (divider <= 2UL) );

  SCU_CLK->CPUCLKCR = (SCU_CLK->CPUCLKCR & ((uint32_t)~SCU_CLK_CPUCLKCR_CPUDIV_Msk)) |
 80213ce:	691a      	ldr	r2, [r3, #16]
  }

  XMC_SCU_CLOCK_SetBackupClockCalibrationMode(config->calibration_mode);

  XMC_SCU_CLOCK_SetSystemClockDivider((uint32_t)config->fsys_clkdiv);
  XMC_SCU_CLOCK_SetCpuClockDivider((uint32_t)config->fcpu_clkdiv);
 80213d0:	7c6c      	ldrb	r4, [r5, #17]
/* API to program the divider placed between fcpu and its parent */
void XMC_SCU_CLOCK_SetCpuClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetCpuClockDivider:Wrong clock divider value", (divider <= 2UL) );

  SCU_CLK->CPUCLKCR = (SCU_CLK->CPUCLKCR & ((uint32_t)~SCU_CLK_CPUCLKCR_CPUDIV_Msk)) |
 80213d2:	f022 0101 	bic.w	r1, r2, #1
                      (uint32_t)((uint32_t)(divider - 1UL) << SCU_CLK_CPUCLKCR_CPUDIV_Pos);
 80213d6:	1e62      	subs	r2, r4, #1
/* API to program the divider placed between fcpu and its parent */
void XMC_SCU_CLOCK_SetCpuClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetCpuClockDivider:Wrong clock divider value", (divider <= 2UL) );

  SCU_CLK->CPUCLKCR = (SCU_CLK->CPUCLKCR & ((uint32_t)~SCU_CLK_CPUCLKCR_CPUDIV_Msk)) |
 80213d8:	430a      	orrs	r2, r1
 80213da:	611a      	str	r2, [r3, #16]
/* API to program the divider placed between fccu and its parent */
void XMC_SCU_CLOCK_SetCcuClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetCapcomClockDivider:Wrong clock divider value", (divider <= 2UL) );

  SCU_CLK->CCUCLKCR = (SCU_CLK->CCUCLKCR & ((uint32_t)~SCU_CLK_CCUCLKCR_CCUDIV_Msk)) |
 80213dc:	6a1a      	ldr	r2, [r3, #32]

  XMC_SCU_CLOCK_SetBackupClockCalibrationMode(config->calibration_mode);

  XMC_SCU_CLOCK_SetSystemClockDivider((uint32_t)config->fsys_clkdiv);
  XMC_SCU_CLOCK_SetCpuClockDivider((uint32_t)config->fcpu_clkdiv);
  XMC_SCU_CLOCK_SetCcuClockDivider((uint32_t)config->fccu_clkdiv);
 80213de:	7cac      	ldrb	r4, [r5, #18]
/* API to program the divider placed between fccu and its parent */
void XMC_SCU_CLOCK_SetCcuClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetCapcomClockDivider:Wrong clock divider value", (divider <= 2UL) );

  SCU_CLK->CCUCLKCR = (SCU_CLK->CCUCLKCR & ((uint32_t)~SCU_CLK_CCUCLKCR_CCUDIV_Msk)) |
 80213e0:	f022 0101 	bic.w	r1, r2, #1
                      (uint32_t)((uint32_t)(divider - 1UL) << SCU_CLK_CCUCLKCR_CCUDIV_Pos);
 80213e4:	1e62      	subs	r2, r4, #1
/* API to program the divider placed between fccu and its parent */
void XMC_SCU_CLOCK_SetCcuClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetCapcomClockDivider:Wrong clock divider value", (divider <= 2UL) );

  SCU_CLK->CCUCLKCR = (SCU_CLK->CCUCLKCR & ((uint32_t)~SCU_CLK_CCUCLKCR_CCUDIV_Msk)) |
 80213e6:	430a      	orrs	r2, r1
 80213e8:	621a      	str	r2, [r3, #32]
/* API to program the divider placed between fperiph and its parent */
void XMC_SCU_CLOCK_SetPeripheralClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetPeripheralClockDivider:Wrong clock divider value", (divider <= 2UL) );

  SCU_CLK->PBCLKCR = (SCU_CLK->PBCLKCR & ((uint32_t)~SCU_CLK_PBCLKCR_PBDIV_Msk)) |
 80213ea:	695a      	ldr	r2, [r3, #20]
  XMC_SCU_CLOCK_SetBackupClockCalibrationMode(config->calibration_mode);

  XMC_SCU_CLOCK_SetSystemClockDivider((uint32_t)config->fsys_clkdiv);
  XMC_SCU_CLOCK_SetCpuClockDivider((uint32_t)config->fcpu_clkdiv);
  XMC_SCU_CLOCK_SetCcuClockDivider((uint32_t)config->fccu_clkdiv);
  XMC_SCU_CLOCK_SetPeripheralClockDivider((uint32_t)config->fperipheral_clkdiv);
 80213ec:	7cec      	ldrb	r4, [r5, #19]
/* API to program the divider placed between fperiph and its parent */
void XMC_SCU_CLOCK_SetPeripheralClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetPeripheralClockDivider:Wrong clock divider value", (divider <= 2UL) );

  SCU_CLK->PBCLKCR = (SCU_CLK->PBCLKCR & ((uint32_t)~SCU_CLK_PBCLKCR_PBDIV_Msk)) |
 80213ee:	f022 0101 	bic.w	r1, r2, #1
                     ((uint32_t)((uint32_t)(divider - 1UL) << SCU_CLK_PBCLKCR_PBDIV_Pos));
 80213f2:	1e62      	subs	r2, r4, #1
/* API to program the divider placed between fperiph and its parent */
void XMC_SCU_CLOCK_SetPeripheralClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetPeripheralClockDivider:Wrong clock divider value", (divider <= 2UL) );

  SCU_CLK->PBCLKCR = (SCU_CLK->PBCLKCR & ((uint32_t)~SCU_CLK_PBCLKCR_PBDIV_Msk)) |
 80213f4:	430a      	orrs	r2, r1
 80213f6:	615a      	str	r2, [r3, #20]
  XMC_SCU_CLOCK_SetSystemClockDivider((uint32_t)config->fsys_clkdiv);
  XMC_SCU_CLOCK_SetCpuClockDivider((uint32_t)config->fcpu_clkdiv);
  XMC_SCU_CLOCK_SetCcuClockDivider((uint32_t)config->fccu_clkdiv);
  XMC_SCU_CLOCK_SetPeripheralClockDivider((uint32_t)config->fperipheral_clkdiv);

  if (config->enable_oschp == true)
 80213f8:	bb28      	cbnz	r0, 8021446 <XMC_SCU_CLOCK_Init+0x11e>
  {
    XMC_SCU_CLOCK_EnableHighPerformanceOscillator();
    while(XMC_SCU_CLOCK_IsHighPerformanceOscillatorStable() == false);
  }

  if (config->syspll_config.mode == XMC_SCU_CLOCK_SYSPLL_MODE_DISABLED)
 80213fa:	78e9      	ldrb	r1, [r5, #3]
 80213fc:	b9a1      	cbnz	r1, 8021428 <XMC_SCU_CLOCK_Init+0x100>
}

/* API to disable main PLL */
void XMC_SCU_CLOCK_DisableSystemPll(void)
{
  SCU_PLL->PLLCON0 |= (uint32_t)(SCU_PLL_PLLCON0_VCOPWD_Msk | SCU_PLL_PLLCON0_PLLPWD_Msk);
 80213fe:	4a47      	ldr	r2, [pc, #284]	; (802151c <XMC_SCU_CLOCK_Init+0x1f4>)
 8021400:	6853      	ldr	r3, [r2, #4]
 8021402:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8021406:	f043 0302 	orr.w	r3, r3, #2
 802140a:	6053      	str	r3, [r2, #4]
                                 (uint32_t)config->syspll_config.n_div,
                                 (uint32_t)config->syspll_config.k_div);
  }

  /* use SYSPLL? */
  if (config->fsys_clksrc == XMC_SCU_CLOCK_SYSCLKSRC_PLL)
 802140c:	68eb      	ldr	r3, [r5, #12]
 802140e:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8021412:	d104      	bne.n	802141e <XMC_SCU_CLOCK_Init+0xf6>
}

/* API to select fSYS */
void XMC_SCU_CLOCK_SetSystemClockSource(const XMC_SCU_CLOCK_SYSCLKSRC_t source)
{
  SCU_CLK->SYSCLKCR = (SCU_CLK->SYSCLKCR & ((uint32_t)~SCU_CLK_SYSCLKCR_SYSSEL_Msk)) |
 8021414:	4a3c      	ldr	r2, [pc, #240]	; (8021508 <XMC_SCU_CLOCK_Init+0x1e0>)
 8021416:	68d3      	ldr	r3, [r2, #12]
 8021418:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 802141c:	60d3      	str	r3, [r2, #12]
  if (config->fsys_clksrc == XMC_SCU_CLOCK_SYSCLKSRC_PLL)
  {
    XMC_SCU_CLOCK_SetSystemClockSource(XMC_SCU_CLOCK_SYSCLKSRC_PLL);    
  }
  SystemCoreClockUpdate();
}
 802141e:	b003      	add	sp, #12
 8021420:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  /* use SYSPLL? */
  if (config->fsys_clksrc == XMC_SCU_CLOCK_SYSCLKSRC_PLL)
  {
    XMC_SCU_CLOCK_SetSystemClockSource(XMC_SCU_CLOCK_SYSCLKSRC_PLL);    
  }
  SystemCoreClockUpdate();
 8021424:	f7ff b9bc 	b.w	80207a0 <SystemCoreClockUpdate>
}

/* API to enable main PLL */
void XMC_SCU_CLOCK_EnableSystemPll(void)
{
  SCU_PLL->PLLCON0 &= (uint32_t)~(SCU_PLL_PLLCON0_VCOPWD_Msk | SCU_PLL_PLLCON0_PLLPWD_Msk);
 8021428:	4a3c      	ldr	r2, [pc, #240]	; (802151c <XMC_SCU_CLOCK_Init+0x1f4>)
  }
  else
  {

    XMC_SCU_CLOCK_EnableSystemPll();
    XMC_SCU_CLOCK_StartSystemPll(config->syspll_config.clksrc,
 802142a:	88a8      	ldrh	r0, [r5, #4]
}

/* API to enable main PLL */
void XMC_SCU_CLOCK_EnableSystemPll(void)
{
  SCU_PLL->PLLCON0 &= (uint32_t)~(SCU_PLL_PLLCON0_VCOPWD_Msk | SCU_PLL_PLLCON0_PLLPWD_Msk);
 802142c:	6853      	ldr	r3, [r2, #4]
 802142e:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8021432:	f023 0302 	bic.w	r3, r3, #2
 8021436:	6053      	str	r3, [r2, #4]
  }
  else
  {

    XMC_SCU_CLOCK_EnableSystemPll();
    XMC_SCU_CLOCK_StartSystemPll(config->syspll_config.clksrc,
 8021438:	78ac      	ldrb	r4, [r5, #2]
 802143a:	786a      	ldrb	r2, [r5, #1]
 802143c:	782b      	ldrb	r3, [r5, #0]
 802143e:	9400      	str	r4, [sp, #0]
 8021440:	f7ff fe98 	bl	8021174 <XMC_SCU_CLOCK_StartSystemPll>
 8021444:	e7e2      	b.n	802140c <XMC_SCU_CLOCK_Init+0xe4>
}

/* API to enable High Precision High Speed oscillator */
void XMC_SCU_CLOCK_EnableHighPerformanceOscillator(void)
{
  SCU_PLL->PLLCON0 &= (uint32_t)~SCU_PLL_PLLCON0_PLLPWD_Msk;
 8021446:	4c35      	ldr	r4, [pc, #212]	; (802151c <XMC_SCU_CLOCK_Init+0x1f4>)

  SCU_OSC->OSCHPCTRL = (uint32_t)((SCU_OSC->OSCHPCTRL & ~(SCU_OSC_OSCHPCTRL_MODE_Msk | SCU_OSC_OSCHPCTRL_OSCVAL_Msk)) |
 8021448:	4f37      	ldr	r7, [pc, #220]	; (8021528 <XMC_SCU_CLOCK_Init+0x200>)
}

/* API to enable High Precision High Speed oscillator */
void XMC_SCU_CLOCK_EnableHighPerformanceOscillator(void)
{
  SCU_PLL->PLLCON0 &= (uint32_t)~SCU_PLL_PLLCON0_PLLPWD_Msk;
 802144a:	6863      	ldr	r3, [r4, #4]
 802144c:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8021450:	6063      	str	r3, [r4, #4]

  SCU_OSC->OSCHPCTRL = (uint32_t)((SCU_OSC->OSCHPCTRL & ~(SCU_OSC_OSCHPCTRL_MODE_Msk | SCU_OSC_OSCHPCTRL_OSCVAL_Msk)) |
 8021452:	687e      	ldr	r6, [r7, #4]
                                  (((OSCHP_GetFrequency() / FOSCREF) - 1UL) << SCU_OSC_OSCHPCTRL_OSCVAL_Pos));
 8021454:	f006 fb24 	bl	8027aa0 <OSCHP_GetFrequency>
 8021458:	4a34      	ldr	r2, [pc, #208]	; (802152c <XMC_SCU_CLOCK_Init+0x204>)
 802145a:	fba2 3200 	umull	r3, r2, r2, r0
 802145e:	0d12      	lsrs	r2, r2, #20
/* API to enable High Precision High Speed oscillator */
void XMC_SCU_CLOCK_EnableHighPerformanceOscillator(void)
{
  SCU_PLL->PLLCON0 &= (uint32_t)~SCU_PLL_PLLCON0_PLLPWD_Msk;

  SCU_OSC->OSCHPCTRL = (uint32_t)((SCU_OSC->OSCHPCTRL & ~(SCU_OSC_OSCHPCTRL_MODE_Msk | SCU_OSC_OSCHPCTRL_OSCVAL_Msk)) |
 8021460:	f426 2370 	bic.w	r3, r6, #983040	; 0xf0000
                                  (((OSCHP_GetFrequency() / FOSCREF) - 1UL) << SCU_OSC_OSCHPCTRL_OSCVAL_Pos));
 8021464:	3a01      	subs	r2, #1
/* API to enable High Precision High Speed oscillator */
void XMC_SCU_CLOCK_EnableHighPerformanceOscillator(void)
{
  SCU_PLL->PLLCON0 &= (uint32_t)~SCU_PLL_PLLCON0_PLLPWD_Msk;

  SCU_OSC->OSCHPCTRL = (uint32_t)((SCU_OSC->OSCHPCTRL & ~(SCU_OSC_OSCHPCTRL_MODE_Msk | SCU_OSC_OSCHPCTRL_OSCVAL_Msk)) |
 8021466:	f023 0330 	bic.w	r3, r3, #48	; 0x30
 802146a:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 802146e:	607b      	str	r3, [r7, #4]
                                  (((OSCHP_GetFrequency() / FOSCREF) - 1UL) << SCU_OSC_OSCHPCTRL_OSCVAL_Pos));

  /* restart OSC Watchdog */
  SCU_PLL->PLLCON0 &= (uint32_t)~SCU_PLL_PLLCON0_OSCRES_Msk;
 8021470:	6863      	ldr	r3, [r4, #4]
 8021472:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
 8021476:	6063      	str	r3, [r4, #4]
}

bool XMC_SCU_CLOCK_IsHighPerformanceOscillatorStable(void)
{
  return ((SCU_PLL->PLLSTAT & XMC_SCU_PLL_PLLSTAT_OSC_USABLE) == XMC_SCU_PLL_PLLSTAT_OSC_USABLE);
 8021478:	4622      	mov	r2, r4
 802147a:	6813      	ldr	r3, [r2, #0]
 802147c:	f403 7360 	and.w	r3, r3, #896	; 0x380
  XMC_SCU_CLOCK_SetPeripheralClockDivider((uint32_t)config->fperipheral_clkdiv);

  if (config->enable_oschp == true)
  {
    XMC_SCU_CLOCK_EnableHighPerformanceOscillator();
    while(XMC_SCU_CLOCK_IsHighPerformanceOscillatorStable() == false);
 8021480:	f5b3 7f60 	cmp.w	r3, #896	; 0x380
 8021484:	d1f9      	bne.n	802147a <XMC_SCU_CLOCK_Init+0x152>
 8021486:	e7b8      	b.n	80213fa <XMC_SCU_CLOCK_Init+0xd2>

/* API to configure the 32khz Ultra Low Power oscillator */
void XMC_SCU_CLOCK_EnableLowPowerOscillator(void)
{
  /* Enable OSC_ULP */
  while((SCU_GENERAL->MIRRSTS) & SCU_GENERAL_MIRRSTS_OSCULCTRL_Msk)
 8021488:	4a22      	ldr	r2, [pc, #136]	; (8021514 <XMC_SCU_CLOCK_Init+0x1ec>)
 802148a:	f8d2 30c4 	ldr.w	r3, [r2, #196]	; 0xc4
 802148e:	061e      	lsls	r6, r3, #24
 8021490:	d4fb      	bmi.n	802148a <XMC_SCU_CLOCK_Init+0x162>
  {
    /* Wait until no pending update to OSCULCTRL register in hibernate domain */
  }
  SCU_HIBERNATE->OSCULCTRL &= ~SCU_HIBERNATE_OSCULCTRL_MODE_Msk;
 8021492:	4921      	ldr	r1, [pc, #132]	; (8021518 <XMC_SCU_CLOCK_Init+0x1f0>)

  /* Enable OSC_ULP Oscillator Watchdog*/
  while (SCU_GENERAL->MIRRSTS & SCU_GENERAL_MIRRSTS_HDCR_Msk)
 8021494:	4a1f      	ldr	r2, [pc, #124]	; (8021514 <XMC_SCU_CLOCK_Init+0x1ec>)
  /* Enable OSC_ULP */
  while((SCU_GENERAL->MIRRSTS) & SCU_GENERAL_MIRRSTS_OSCULCTRL_Msk)
  {
    /* Wait until no pending update to OSCULCTRL register in hibernate domain */
  }
  SCU_HIBERNATE->OSCULCTRL &= ~SCU_HIBERNATE_OSCULCTRL_MODE_Msk;
 8021496:	69cb      	ldr	r3, [r1, #28]
 8021498:	f023 0330 	bic.w	r3, r3, #48	; 0x30
 802149c:	61cb      	str	r3, [r1, #28]

  /* Enable OSC_ULP Oscillator Watchdog*/
  while (SCU_GENERAL->MIRRSTS & SCU_GENERAL_MIRRSTS_HDCR_Msk)
 802149e:	f8d2 30c4 	ldr.w	r3, [r2, #196]	; 0xc4
 80214a2:	071c      	lsls	r4, r3, #28
 80214a4:	d4fb      	bmi.n	802149e <XMC_SCU_CLOCK_Init+0x176>
  {
    /* check SCU_MIRRSTS to ensure that no transfer over serial interface is pending */
  }
  SCU_HIBERNATE->HDCR |= (uint32_t)SCU_HIBERNATE_HDCR_ULPWDGEN_Msk;
 80214a6:	491c      	ldr	r1, [pc, #112]	; (8021518 <XMC_SCU_CLOCK_Init+0x1f0>)

  /* Enable OSC_ULP Oscillator Watchdog*/
  while (SCU_GENERAL->MIRRSTS & SCU_GENERAL_MIRRSTS_HDSET_Msk)
 80214a8:	4a1a      	ldr	r2, [pc, #104]	; (8021514 <XMC_SCU_CLOCK_Init+0x1ec>)
  /* Enable OSC_ULP Oscillator Watchdog*/
  while (SCU_GENERAL->MIRRSTS & SCU_GENERAL_MIRRSTS_HDCR_Msk)
  {
    /* check SCU_MIRRSTS to ensure that no transfer over serial interface is pending */
  }
  SCU_HIBERNATE->HDCR |= (uint32_t)SCU_HIBERNATE_HDCR_ULPWDGEN_Msk;
 80214aa:	68cb      	ldr	r3, [r1, #12]
 80214ac:	f043 0308 	orr.w	r3, r3, #8
 80214b0:	60cb      	str	r3, [r1, #12]

  /* Enable OSC_ULP Oscillator Watchdog*/
  while (SCU_GENERAL->MIRRSTS & SCU_GENERAL_MIRRSTS_HDSET_Msk)
 80214b2:	f8d2 30c4 	ldr.w	r3, [r2, #196]	; 0xc4
 80214b6:	0758      	lsls	r0, r3, #29
 80214b8:	d4fb      	bmi.n	80214b2 <XMC_SCU_CLOCK_Init+0x18a>
  {
    /* check SCU_MIRRSTS to ensure that no transfer over serial interface is pending */
  }
  SCU_HIBERNATE->HDSET = (uint32_t)SCU_HIBERNATE_HDSET_ULPWDG_Msk;
 80214ba:	4b17      	ldr	r3, [pc, #92]	; (8021518 <XMC_SCU_CLOCK_Init+0x1f0>)
 80214bc:	4a15      	ldr	r2, [pc, #84]	; (8021514 <XMC_SCU_CLOCK_Init+0x1ec>)
 80214be:	2108      	movs	r1, #8
 80214c0:	6099      	str	r1, [r3, #8]
 80214c2:	f8d2 30c4 	ldr.w	r3, [r2, #196]	; 0xc4

  while (XMC_SCU_GetMirrorStatus() != 0)
 80214c6:	2b00      	cmp	r3, #0
 80214c8:	d1fb      	bne.n	80214c2 <XMC_SCU_CLOCK_Init+0x19a>

#endif

bool XMC_SCU_CLOCK_IsLowPowerOscillatorStable(void)
{
  return ((SCU_HIBERNATE->HDSTAT & SCU_HIBERNATE_HDSTAT_ULPWDG_Msk) == 0UL);
 80214ca:	4a13      	ldr	r2, [pc, #76]	; (8021518 <XMC_SCU_CLOCK_Init+0x1f0>)
 80214cc:	6813      	ldr	r3, [r2, #0]
  XMC_SCU_HIB_EnableHibernateDomain();

  if (config->enable_osculp == true)
  {
    XMC_SCU_CLOCK_EnableLowPowerOscillator();
    while (XMC_SCU_CLOCK_IsLowPowerOscillatorStable() == false);
 80214ce:	0719      	lsls	r1, r3, #28
 80214d0:	d4fc      	bmi.n	80214cc <XMC_SCU_CLOCK_Init+0x1a4>
 80214d2:	e748      	b.n	8021366 <XMC_SCU_CLOCK_Init+0x3e>
  SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_FOTR_Msk;

  if (mode == XMC_SCU_CLOCK_FOFI_CALIBRATION_MODE_AUTOMATIC)
  {
    /* Disable factory calibration based trimming */
    SCU_PLL->PLLCON0 &= (uint32_t)~SCU_PLL_PLLCON0_FOTR_Msk;
 80214d4:	6853      	ldr	r3, [r2, #4]
void XMC_SCU_lDelay(uint32_t delay)
{
  uint32_t i;

  SystemCoreClockUpdate();
  delay =  delay * (uint32_t)(SystemCoreClock / FREQ_1MHZ);
 80214d6:	4e12      	ldr	r6, [pc, #72]	; (8021520 <XMC_SCU_CLOCK_Init+0x1f8>)
  SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_FOTR_Msk;

  if (mode == XMC_SCU_CLOCK_FOFI_CALIBRATION_MODE_AUTOMATIC)
  {
    /* Disable factory calibration based trimming */
    SCU_PLL->PLLCON0 &= (uint32_t)~SCU_PLL_PLLCON0_FOTR_Msk;
 80214d8:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
 80214dc:	6053      	str	r3, [r2, #4]
/* This is a local function used to generate the delay until register get updated with new configured value.  */
void XMC_SCU_lDelay(uint32_t delay)
{
  uint32_t i;

  SystemCoreClockUpdate();
 80214de:	f7ff f95f 	bl	80207a0 <SystemCoreClockUpdate>
  delay =  delay * (uint32_t)(SystemCoreClock / FREQ_1MHZ);
 80214e2:	4a10      	ldr	r2, [pc, #64]	; (8021524 <XMC_SCU_CLOCK_Init+0x1fc>)
 80214e4:	6833      	ldr	r3, [r6, #0]
 80214e6:	fba2 2303 	umull	r2, r3, r2, r3
 80214ea:	0c9a      	lsrs	r2, r3, #18
 80214ec:	2364      	movs	r3, #100	; 0x64
 80214ee:	fb03 f302 	mul.w	r3, r3, r2

  for (i = 0U; i < delay; ++i)
 80214f2:	b11b      	cbz	r3, 80214fc <XMC_SCU_CLOCK_Init+0x1d4>
  {
    __NOP();
 80214f4:	bf00      	nop
  uint32_t i;

  SystemCoreClockUpdate();
  delay =  delay * (uint32_t)(SystemCoreClock / FREQ_1MHZ);

  for (i = 0U; i < delay; ++i)
 80214f6:	3401      	adds	r4, #1
 80214f8:	429c      	cmp	r4, r3
 80214fa:	d1fb      	bne.n	80214f4 <XMC_SCU_CLOCK_Init+0x1cc>
    /* Disable factory calibration based trimming */
    SCU_PLL->PLLCON0 &= (uint32_t)~SCU_PLL_PLLCON0_FOTR_Msk;
    XMC_SCU_lDelay(100UL);

    /* Enable automatic calibration */
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_AOTREN_Msk;
 80214fc:	4a07      	ldr	r2, [pc, #28]	; (802151c <XMC_SCU_CLOCK_Init+0x1f4>)
 80214fe:	6853      	ldr	r3, [r2, #4]
 8021500:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 8021504:	6053      	str	r3, [r2, #4]
 8021506:	e749      	b.n	802139c <XMC_SCU_CLOCK_Init+0x74>
 8021508:	50004600 	.word	0x50004600
 802150c:	50004200 	.word	0x50004200
 8021510:	50004400 	.word	0x50004400
 8021514:	50004000 	.word	0x50004000
 8021518:	50004300 	.word	0x50004300
 802151c:	50004710 	.word	0x50004710
 8021520:	2003ffc0 	.word	0x2003ffc0
 8021524:	431bde83 	.word	0x431bde83
 8021528:	50004700 	.word	0x50004700
 802152c:	6b5fca6b 	.word	0x6b5fca6b

08021530 <XMC_CCU4_Init>:
#endif
}

/* API to initialize CCU4 global resources  */
void XMC_CCU4_Init(XMC_CCU4_MODULE_t *const module, const XMC_CCU4_SLICE_MCMS_ACTION_t mcs_action)
{
 8021530:	b538      	push	{r3, r4, r5, lr}
 8021532:	4604      	mov	r4, r0
{
  XMC_ASSERT("XMC_CCU4_EnableModule:Invalid Module Pointer", XMC_CCU4_IsValidModule(module));

#if UC_FAMILY == XMC4
  /* Enable CCU4 module clock */
  XMC_SCU_CLOCK_EnableClock(XMC_SCU_CLOCK_CCU);
 8021534:	2010      	movs	r0, #16
#endif
}

/* API to initialize CCU4 global resources  */
void XMC_CCU4_Init(XMC_CCU4_MODULE_t *const module, const XMC_CCU4_SLICE_MCMS_ACTION_t mcs_action)
{
 8021536:	460d      	mov	r5, r1
{
  XMC_ASSERT("XMC_CCU4_EnableModule:Invalid Module Pointer", XMC_CCU4_IsValidModule(module));

#if UC_FAMILY == XMC4
  /* Enable CCU4 module clock */
  XMC_SCU_CLOCK_EnableClock(XMC_SCU_CLOCK_CCU);
 8021538:	f7ff fdbc 	bl	80210b4 <XMC_SCU_CLOCK_EnableClock>
  }
}

__STATIC_INLINE void XMC_CCU4_lUngateClock(const XMC_CCU4_MODULE_t *const module)
{
  if (module == CCU40)
 802153c:	4b19      	ldr	r3, [pc, #100]	; (80215a4 <XMC_CCU4_Init+0x74>)
 802153e:	429c      	cmp	r4, r3
 8021540:	d01a      	beq.n	8021578 <XMC_CCU4_Init+0x48>
  {
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_CCU40);
  }
#if defined(CCU41)
  else if (module == CCU41)
 8021542:	4b19      	ldr	r3, [pc, #100]	; (80215a8 <XMC_CCU4_Init+0x78>)
 8021544:	429c      	cmp	r4, r3
 8021546:	d01e      	beq.n	8021586 <XMC_CCU4_Init+0x56>
  {
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_CCU41);
  }
#endif
#if defined(CCU42)
  else if (module == CCU42)
 8021548:	4b18      	ldr	r3, [pc, #96]	; (80215ac <XMC_CCU4_Init+0x7c>)
 802154a:	429c      	cmp	r4, r3
 802154c:	d022      	beq.n	8021594 <XMC_CCU4_Init+0x64>
  {
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_CCU42);
  }
#endif
#if defined(CCU43)
  else if (module == CCU43)
 802154e:	4b18      	ldr	r3, [pc, #96]	; (80215b0 <XMC_CCU4_Init+0x80>)
 8021550:	429c      	cmp	r4, r3
 8021552:	d00a      	beq.n	802156a <XMC_CCU4_Init+0x3a>
 * XMC_CCU4_StopPrescaler().
 */
__STATIC_INLINE void XMC_CCU4_StartPrescaler(XMC_CCU4_MODULE_t *const module)
{
  XMC_ASSERT("XMC_CCU4_StartPrescaler:Invalid Module Pointer", XMC_CCU4_IsValidModule(module));
  module->GIDLC |= (uint32_t) CCU4_GIDLC_SPRB_Msk;
 8021554:	68e3      	ldr	r3, [r4, #12]
 8021556:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 802155a:	60e3      	str	r3, [r4, #12]
  /* Enable CCU4 module */
  XMC_CCU4_EnableModule(module);
  /* Start the prescaler */
  XMC_CCU4_StartPrescaler(module);
  
  gctrl = module->GCTRL;
 802155c:	6821      	ldr	r1, [r4, #0]
  gctrl &= ~((uint32_t) CCU4_GCTRL_MSDE_Msk);
 802155e:	f421 4140 	bic.w	r1, r1, #49152	; 0xc000
  gctrl |= ((uint32_t) mcs_action) << CCU4_GCTRL_MSDE_Pos;
 8021562:	ea41 3185 	orr.w	r1, r1, r5, lsl #14
  
  module->GCTRL = gctrl;
 8021566:	6021      	str	r1, [r4, #0]
 8021568:	bd38      	pop	{r3, r4, r5, pc}
  }
#endif
#if defined(CCU43)
  else if (module == CCU43)
  {
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_CCU43);
 802156a:	4812      	ldr	r0, [pc, #72]	; (80215b4 <XMC_CCU4_Init+0x84>)
 802156c:	f7ff fdb4 	bl	80210d8 <XMC_SCU_CLOCK_UngatePeripheralClock>
  }
#endif
#if defined(CCU43)
  else if (module == CCU43)
  {
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_CCU43);
 8021570:	4810      	ldr	r0, [pc, #64]	; (80215b4 <XMC_CCU4_Init+0x84>)
 8021572:	f7ff fd35 	bl	8020fe0 <XMC_SCU_RESET_DeassertPeripheralReset>
 8021576:	e7ed      	b.n	8021554 <XMC_CCU4_Init+0x24>

__STATIC_INLINE void XMC_CCU4_lUngateClock(const XMC_CCU4_MODULE_t *const module)
{
  if (module == CCU40)
  {
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_CCU40);
 8021578:	2004      	movs	r0, #4
 802157a:	f7ff fdad 	bl	80210d8 <XMC_SCU_CLOCK_UngatePeripheralClock>

__STATIC_INLINE void XMC_CCU4_lDeassertReset(const XMC_CCU4_MODULE_t *const module)
{
  if (module == CCU40)
  {
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_CCU40);
 802157e:	2004      	movs	r0, #4
 8021580:	f7ff fd2e 	bl	8020fe0 <XMC_SCU_RESET_DeassertPeripheralReset>
 8021584:	e7e6      	b.n	8021554 <XMC_CCU4_Init+0x24>
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_CCU40);
  }
#if defined(CCU41)
  else if (module == CCU41)
  {
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_CCU41);
 8021586:	2008      	movs	r0, #8
 8021588:	f7ff fda6 	bl	80210d8 <XMC_SCU_CLOCK_UngatePeripheralClock>
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_CCU40);
  }
#if defined(CCU41)
  else if (module == CCU41)
  {
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_CCU41);
 802158c:	2008      	movs	r0, #8
 802158e:	f7ff fd27 	bl	8020fe0 <XMC_SCU_RESET_DeassertPeripheralReset>
 8021592:	e7df      	b.n	8021554 <XMC_CCU4_Init+0x24>
  }
#endif
#if defined(CCU42)
  else if (module == CCU42)
  {
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_CCU42);
 8021594:	2010      	movs	r0, #16
 8021596:	f7ff fd9f 	bl	80210d8 <XMC_SCU_CLOCK_UngatePeripheralClock>
  }
#endif
#if defined(CCU42)
  else if (module == CCU42)
  {
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_CCU42);
 802159a:	2010      	movs	r0, #16
 802159c:	f7ff fd20 	bl	8020fe0 <XMC_SCU_RESET_DeassertPeripheralReset>
 80215a0:	e7d8      	b.n	8021554 <XMC_CCU4_Init+0x24>
 80215a2:	bf00      	nop
 80215a4:	4000c000 	.word	0x4000c000
 80215a8:	40010000 	.word	0x40010000
 80215ac:	40014000 	.word	0x40014000
 80215b0:	48004000 	.word	0x48004000
 80215b4:	10000001 	.word	0x10000001

080215b8 <XMC_CCU4_SLICE_CompareInit>:
}

/* API to configure CC4 Slice as Timer */
void XMC_CCU4_SLICE_CompareInit(XMC_CCU4_SLICE_t *const slice,
                                const XMC_CCU4_SLICE_COMPARE_CONFIG_t *const compare_init)
{
 80215b8:	b470      	push	{r4, r5, r6}
             (XMC_CCU4_SLICE_COMPARE_CONFIG_t *) NULL != compare_init);

  /* Program the timer mode */
  slice->TC = compare_init->tc;
  /* Enable the timer concatenation */
  slice->CMC = ((uint32_t) compare_init->timer_concatenation << CCU4_CC4_CMC_TCE_Pos);
 80215ba:	794b      	ldrb	r3, [r1, #5]
  /* Program initial prescaler divider value */
  slice->PSC = (uint32_t) compare_init->prescaler_initval;
 80215bc:	790e      	ldrb	r6, [r1, #4]
  XMC_ASSERT("XMC_CCU4_SLICE_CompareInit:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_CompareInit:Compare Init Pointer is NULL",
             (XMC_CCU4_SLICE_COMPARE_CONFIG_t *) NULL != compare_init);

  /* Program the timer mode */
  slice->TC = compare_init->tc;
 80215be:	6809      	ldr	r1, [r1, #0]
 80215c0:	6141      	str	r1, [r0, #20]
  /* Program initial prescaler divider value */
  slice->PSC = (uint32_t) compare_init->prescaler_initval;
  /* Program the dither compare value */
  slice->DITS = (uint32_t) compare_init->dither_limit;
  /* Program timer output passive level */
  slice->PSL = (uint32_t) compare_init->passive_level;
 80215c2:	461c      	mov	r4, r3
  /* Enable the timer concatenation */
  slice->CMC = ((uint32_t) compare_init->timer_concatenation << CCU4_CC4_CMC_TCE_Pos);
  /* Program initial prescaler divider value */
  slice->PSC = (uint32_t) compare_init->prescaler_initval;
  /* Program the dither compare value */
  slice->DITS = (uint32_t) compare_init->dither_limit;
 80215c4:	461d      	mov	r5, r3
  /* Program timer output passive level */
  slice->PSL = (uint32_t) compare_init->passive_level;
  /* Program floating prescaler compare value */
  slice->FPCS = (uint32_t) compare_init->float_limit;
 80215c6:	4632      	mov	r2, r6
             (XMC_CCU4_SLICE_COMPARE_CONFIG_t *) NULL != compare_init);

  /* Program the timer mode */
  slice->TC = compare_init->tc;
  /* Enable the timer concatenation */
  slice->CMC = ((uint32_t) compare_init->timer_concatenation << CCU4_CC4_CMC_TCE_Pos);
 80215c8:	f3c3 1340 	ubfx	r3, r3, #5, #1
  /* Program initial prescaler divider value */
  slice->PSC = (uint32_t) compare_init->prescaler_initval;
 80215cc:	f006 060f 	and.w	r6, r6, #15
  /* Program the dither compare value */
  slice->DITS = (uint32_t) compare_init->dither_limit;
 80215d0:	f005 050f 	and.w	r5, r5, #15
  /* Program timer output passive level */
  slice->PSL = (uint32_t) compare_init->passive_level;
 80215d4:	f3c4 1100 	ubfx	r1, r4, #4, #1
             (XMC_CCU4_SLICE_COMPARE_CONFIG_t *) NULL != compare_init);

  /* Program the timer mode */
  slice->TC = compare_init->tc;
  /* Enable the timer concatenation */
  slice->CMC = ((uint32_t) compare_init->timer_concatenation << CCU4_CC4_CMC_TCE_Pos);
 80215d8:	051b      	lsls	r3, r3, #20
  /* Program the dither compare value */
  slice->DITS = (uint32_t) compare_init->dither_limit;
  /* Program timer output passive level */
  slice->PSL = (uint32_t) compare_init->passive_level;
  /* Program floating prescaler compare value */
  slice->FPCS = (uint32_t) compare_init->float_limit;
 80215da:	0912      	lsrs	r2, r2, #4
             (XMC_CCU4_SLICE_COMPARE_CONFIG_t *) NULL != compare_init);

  /* Program the timer mode */
  slice->TC = compare_init->tc;
  /* Enable the timer concatenation */
  slice->CMC = ((uint32_t) compare_init->timer_concatenation << CCU4_CC4_CMC_TCE_Pos);
 80215dc:	6043      	str	r3, [r0, #4]
  /* Program initial prescaler divider value */
  slice->PSC = (uint32_t) compare_init->prescaler_initval;
 80215de:	6246      	str	r6, [r0, #36]	; 0x24
  /* Program the dither compare value */
  slice->DITS = (uint32_t) compare_init->dither_limit;
 80215e0:	6205      	str	r5, [r0, #32]
  /* Program timer output passive level */
  slice->PSL = (uint32_t) compare_init->passive_level;
 80215e2:	6181      	str	r1, [r0, #24]
  /* Program floating prescaler compare value */
  slice->FPCS = (uint32_t) compare_init->float_limit;
}
 80215e4:	bc70      	pop	{r4, r5, r6}
  /* Program the dither compare value */
  slice->DITS = (uint32_t) compare_init->dither_limit;
  /* Program timer output passive level */
  slice->PSL = (uint32_t) compare_init->passive_level;
  /* Program floating prescaler compare value */
  slice->FPCS = (uint32_t) compare_init->float_limit;
 80215e6:	62c2      	str	r2, [r0, #44]	; 0x2c
}
 80215e8:	4770      	bx	lr
 80215ea:	bf00      	nop

080215ec <XMC_CCU4_SLICE_SetPrescaler>:
{
  uint32_t fpc;
  
  XMC_ASSERT("XMC_CCU4_SLICE_SetPrescaler:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));

  fpc = slice->FPC;
 80215ec:	6a83      	ldr	r3, [r0, #40]	; 0x28
  fpc &= ~((uint32_t) CCU4_CC4_FPC_PVAL_Msk);
 80215ee:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
  fpc |= ((uint32_t) div_val) << CCU4_CC4_FPC_PVAL_Pos;
 80215f2:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
  slice->FPC = fpc;
 80215f6:	6283      	str	r3, [r0, #40]	; 0x28
  /* 
   * In any case, update the initial value of the divider which is to be loaded once the prescaler increments to the 
   * compare value.
   */
  slice->PSC = (uint32_t) div_val;
 80215f8:	6241      	str	r1, [r0, #36]	; 0x24
 80215fa:	4770      	bx	lr

080215fc <XMC_CCU4_SLICE_SetInterruptNode>:

/* Binds a capcom event to an NVIC node  */
void XMC_CCU4_SLICE_SetInterruptNode(XMC_CCU4_SLICE_t *const slice,
                                     const XMC_CCU4_SLICE_IRQ_ID_t event,
                                     const XMC_CCU4_SLICE_SR_ID_t sr)
{
 80215fc:	2909      	cmp	r1, #9
 80215fe:	b430      	push	{r4, r5}

  XMC_ASSERT("XMC_CCU4_SLICE_SetInterruptNode:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_SetInterruptNode:Invalid SR ID ", XMC_CCU4_SLICE_CHECK_SR_ID(sr));
  XMC_ASSERT("XMC_CCU4_SLICE_SetInterruptNode:Invalid event", XMC_CCU4_SLICE_CHECK_INTERRUPT(event));
  
  srs = slice->SRS;
 8021600:	f8d0 40a8 	ldr.w	r4, [r0, #168]	; 0xa8
 8021604:	d80d      	bhi.n	8021622 <XMC_CCU4_SLICE_SetInterruptNode+0x26>
 8021606:	4b09      	ldr	r3, [pc, #36]	; (802162c <XMC_CCU4_SLICE_SetInterruptNode+0x30>)
 8021608:	4d09      	ldr	r5, [pc, #36]	; (8021630 <XMC_CCU4_SLICE_SetInterruptNode+0x34>)
 802160a:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 802160e:	f855 1021 	ldr.w	r1, [r5, r1, lsl #2]
 8021612:	43db      	mvns	r3, r3
      mask = ((uint32_t) CCU4_CC4_SRS_E2SR_Msk);
      pos  = CCU4_CC4_SRS_E2SR_Pos;
      break;
  }
  
  srs &= ~mask; 
 8021614:	4023      	ands	r3, r4
  srs |= (uint32_t)sr << pos;
 8021616:	408a      	lsls	r2, r1
 8021618:	431a      	orrs	r2, r3
  slice->SRS = srs;
 802161a:	f8c0 20a8 	str.w	r2, [r0, #168]	; 0xa8
}
 802161e:	bc30      	pop	{r4, r5}
 8021620:	4770      	bx	lr

  XMC_ASSERT("XMC_CCU4_SLICE_SetInterruptNode:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_SetInterruptNode:Invalid SR ID ", XMC_CCU4_SLICE_CHECK_SR_ID(sr));
  XMC_ASSERT("XMC_CCU4_SLICE_SetInterruptNode:Invalid event", XMC_CCU4_SLICE_CHECK_INTERRUPT(event));
  
  srs = slice->SRS;
 8021622:	210c      	movs	r1, #12
 8021624:	f46f 5340 	mvn.w	r3, #12288	; 0x3000
 8021628:	e7f4      	b.n	8021614 <XMC_CCU4_SLICE_SetInterruptNode+0x18>
 802162a:	bf00      	nop
 802162c:	0802f22c 	.word	0x0802f22c
 8021630:	0802f204 	.word	0x0802f204

08021634 <XMC_CCU8_Init>:
#endif
}

/* API to initialize CCU8 global resources  */
void XMC_CCU8_Init(XMC_CCU8_MODULE_t *const module, const XMC_CCU8_SLICE_MCMS_ACTION_t mcs_action)
{
 8021634:	b538      	push	{r3, r4, r5, lr}
 8021636:	4604      	mov	r4, r0
{
  XMC_ASSERT("XMC_CCU8_EnableModule:Invalid Module Pointer", XMC_CCU8_IsValidModule(module));

#if (UC_FAMILY == XMC4)
  /* Enable CCU8 module clock */
  XMC_SCU_CLOCK_EnableClock(XMC_SCU_CLOCK_CCU);
 8021638:	2010      	movs	r0, #16
#endif
}

/* API to initialize CCU8 global resources  */
void XMC_CCU8_Init(XMC_CCU8_MODULE_t *const module, const XMC_CCU8_SLICE_MCMS_ACTION_t mcs_action)
{
 802163a:	460d      	mov	r5, r1
{
  XMC_ASSERT("XMC_CCU8_EnableModule:Invalid Module Pointer", XMC_CCU8_IsValidModule(module));

#if (UC_FAMILY == XMC4)
  /* Enable CCU8 module clock */
  XMC_SCU_CLOCK_EnableClock(XMC_SCU_CLOCK_CCU);
 802163c:	f7ff fd3a 	bl	80210b4 <XMC_SCU_CLOCK_EnableClock>
  }
}

__STATIC_INLINE void XMC_CCU8_lUngateClock(XMC_CCU8_MODULE_t *const module)
{
  if (module == CCU80)
 8021640:	4b10      	ldr	r3, [pc, #64]	; (8021684 <XMC_CCU8_Init+0x50>)
 8021642:	429c      	cmp	r4, r3
 8021644:	d016      	beq.n	8021674 <XMC_CCU8_Init+0x40>
  {
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_CCU80);
  }
#if defined(CCU81)
  else if (module == CCU81)
 8021646:	4b10      	ldr	r3, [pc, #64]	; (8021688 <XMC_CCU8_Init+0x54>)
 8021648:	429c      	cmp	r4, r3
 802164a:	d00a      	beq.n	8021662 <XMC_CCU8_Init+0x2e>
 *  XMC_CCU8_StopPrescaler().
 */
__STATIC_INLINE void XMC_CCU8_StartPrescaler(XMC_CCU8_MODULE_t *const module)
{
  XMC_ASSERT("XMC_CCU8_StartPrescaler:Invalid Module Pointer", XMC_CCU8_IsValidModule(module));
  module->GIDLC |= (uint32_t) CCU8_GIDLC_SPRB_Msk;
 802164c:	68e3      	ldr	r3, [r4, #12]
 802164e:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8021652:	60e3      	str	r3, [r4, #12]
  /* Enable CCU8 module */
  XMC_CCU8_EnableModule(module);
  /* Start the prescaler */
  XMC_CCU8_StartPrescaler(module);
  
  gctrl = module->GCTRL;
 8021654:	6823      	ldr	r3, [r4, #0]
  gctrl &= ~((uint32_t) CCU8_GCTRL_MSDE_Msk);
 8021656:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
  gctrl |= (uint32_t)mcs_action << CCU8_GCTRL_MSDE_Pos;
 802165a:	ea43 3185 	orr.w	r1, r3, r5, lsl #14
  
  module->GCTRL = gctrl;
 802165e:	6021      	str	r1, [r4, #0]
 8021660:	bd38      	pop	{r3, r4, r5, pc}
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_CCU80);
  }
#if defined(CCU81)
  else if (module == CCU81)
  {
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_CCU81);
 8021662:	f44f 7080 	mov.w	r0, #256	; 0x100
 8021666:	f7ff fd37 	bl	80210d8 <XMC_SCU_CLOCK_UngatePeripheralClock>
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_CCU80);
  }
#if defined(CCU81)
  else if (module == CCU81)
  {
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_CCU81);
 802166a:	f44f 7080 	mov.w	r0, #256	; 0x100
 802166e:	f7ff fcb7 	bl	8020fe0 <XMC_SCU_RESET_DeassertPeripheralReset>
 8021672:	e7eb      	b.n	802164c <XMC_CCU8_Init+0x18>

__STATIC_INLINE void XMC_CCU8_lUngateClock(XMC_CCU8_MODULE_t *const module)
{
  if (module == CCU80)
  {
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_CCU80);
 8021674:	2080      	movs	r0, #128	; 0x80
 8021676:	f7ff fd2f 	bl	80210d8 <XMC_SCU_CLOCK_UngatePeripheralClock>

__STATIC_INLINE void XMC_CCU8_lDeassertReset(const XMC_CCU8_MODULE_t *const module)
{
  if (module == CCU80)
  {
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_CCU80);
 802167a:	2080      	movs	r0, #128	; 0x80
 802167c:	f7ff fcb0 	bl	8020fe0 <XMC_SCU_RESET_DeassertPeripheralReset>
 8021680:	e7e4      	b.n	802164c <XMC_CCU8_Init+0x18>
 8021682:	bf00      	nop
 8021684:	40020000 	.word	0x40020000
 8021688:	40024000 	.word	0x40024000

0802168c <XMC_CCU8_SLICE_CompareInit>:
  /* Stops the timer */
  XMC_CCU8_SLICE_StopTimer(slice);
  /* Program the timer mode */
  slice->TC = compare_init->tc;
  /* Enable the timer concatenation */
  slice->CMC =  (uint32_t)compare_init->timer_concatenation << CCU8_CC8_CMC_TCE_Pos;
 802168c:	7b4b      	ldrb	r3, [r1, #13]
}

/* API to configure CC8 Slice in Compare mode */
void XMC_CCU8_SLICE_CompareInit(XMC_CCU8_SLICE_t *const slice,
                                const XMC_CCU8_SLICE_COMPARE_CONFIG_t *const compare_init)
{
 802168e:	b470      	push	{r4, r5, r6}
  /* Program the timer mode */
  slice->TC = compare_init->tc;
  /* Enable the timer concatenation */
  slice->CMC =  (uint32_t)compare_init->timer_concatenation << CCU8_CC8_CMC_TCE_Pos;
  /* Program initial prescaler divider value */
  slice->PSC = (uint32_t) compare_init->prescaler_initval;
 8021690:	7b0d      	ldrb	r5, [r1, #12]
 *  XMC_CCU8_SLICE_StartTimer().
 */
__STATIC_INLINE void XMC_CCU8_SLICE_StopTimer(XMC_CCU8_SLICE_t *const slice)
{
  XMC_ASSERT("XMC_CCU8_SLICE_StopTimer:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  slice->TCCLR = (uint32_t) CCU8_CC8_TCCLR_TRBC_Msk;
 8021692:	2601      	movs	r6, #1
 8021694:	6106      	str	r6, [r0, #16]
  /* Program floating prescaler compare value */
  slice->FPCS = (uint32_t) compare_init->float_limit;
 8021696:	462c      	mov	r4, r5
  /* Program the dither compare value */
  slice->DITS = (uint32_t) compare_init->dither_limit;
 8021698:	461a      	mov	r2, r3
  /* Stops the timer */
  XMC_CCU8_SLICE_StopTimer(slice);
  /* Program the timer mode */
  slice->TC = compare_init->tc;
  /* Enable the timer concatenation */
  slice->CMC =  (uint32_t)compare_init->timer_concatenation << CCU8_CC8_CMC_TCE_Pos;
 802169a:	f3c3 1300 	ubfx	r3, r3, #4, #1
  XMC_ASSERT("XMC_CCU8_SLICE_CompareInit:Timer Init Pointer is NULL",
             (XMC_CCU8_SLICE_COMPARE_CONFIG_t *) NULL != compare_init);
  /* Stops the timer */
  XMC_CCU8_SLICE_StopTimer(slice);
  /* Program the timer mode */
  slice->TC = compare_init->tc;
 802169e:	680e      	ldr	r6, [r1, #0]
 80216a0:	6146      	str	r6, [r0, #20]
  /* Enable the timer concatenation */
  slice->CMC =  (uint32_t)compare_init->timer_concatenation << CCU8_CC8_CMC_TCE_Pos;
 80216a2:	051b      	lsls	r3, r3, #20
  /* Program initial prescaler divider value */
  slice->PSC = (uint32_t) compare_init->prescaler_initval;
 80216a4:	f005 050f 	and.w	r5, r5, #15
  /* Program floating prescaler compare value */
  slice->FPCS = (uint32_t) compare_init->float_limit;
 80216a8:	0924      	lsrs	r4, r4, #4
  /* Program the dither compare value */
  slice->DITS = (uint32_t) compare_init->dither_limit;
 80216aa:	f002 020f 	and.w	r2, r2, #15
  /* Stops the timer */
  XMC_CCU8_SLICE_StopTimer(slice);
  /* Program the timer mode */
  slice->TC = compare_init->tc;
  /* Enable the timer concatenation */
  slice->CMC =  (uint32_t)compare_init->timer_concatenation << CCU8_CC8_CMC_TCE_Pos;
 80216ae:	6043      	str	r3, [r0, #4]
  /* Program initial prescaler divider value */
  slice->PSC = (uint32_t) compare_init->prescaler_initval;
 80216b0:	6245      	str	r5, [r0, #36]	; 0x24
  /* Program floating prescaler compare value */
  slice->FPCS = (uint32_t) compare_init->float_limit;
 80216b2:	62c4      	str	r4, [r0, #44]	; 0x2c
  /* Program the dither compare value */
  slice->DITS = (uint32_t) compare_init->dither_limit;
 80216b4:	6202      	str	r2, [r0, #32]
  /* Program timer output passive level */
  slice->PSL = (uint32_t) compare_init->psl;
 80216b6:	684b      	ldr	r3, [r1, #4]
 80216b8:	6183      	str	r3, [r0, #24]
  /* Asymmetric PWM and Slice output routing configuration */
#if defined(CCU8V3) /* Defined for XMC1400 devices only */
  slice->CHC = (uint32_t) compare_init->chc;
#else
  slice->CHC = (uint32_t)((uint32_t)compare_init->chc ^ XMC_CCU8_SLICE_CHC_CONFIG_MASK);
 80216ba:	688b      	ldr	r3, [r1, #8]
 80216bc:	f083 0314 	eor.w	r3, r3, #20
 80216c0:	6483      	str	r3, [r0, #72]	; 0x48
#endif
}
 80216c2:	bc70      	pop	{r4, r5, r6}
 80216c4:	4770      	bx	lr
 80216c6:	bf00      	nop

080216c8 <XMC_CCU8_SetMultiChannelShadowTransferMode>:
{
  uint32_t gctrl;

  XMC_ASSERT("XMC_CCU8_SetMultiChannelShadowTransferMode:Invalid module Pointer", XMC_CCU8_IsValidModule(module));
  
  gctrl = module->GCTRL;
 80216c8:	6802      	ldr	r2, [r0, #0]
  gctrl &= ~((uint32_t)slice_mode_msk >> 16U);
  gctrl |= ((uint32_t)slice_mode_msk & 0xFFFFU);
 80216ca:	b28b      	uxth	r3, r1
  uint32_t gctrl;

  XMC_ASSERT("XMC_CCU8_SetMultiChannelShadowTransferMode:Invalid module Pointer", XMC_CCU8_IsValidModule(module));
  
  gctrl = module->GCTRL;
  gctrl &= ~((uint32_t)slice_mode_msk >> 16U);
 80216cc:	ea22 4111 	bic.w	r1, r2, r1, lsr #16
  gctrl |= ((uint32_t)slice_mode_msk & 0xFFFFU);
 80216d0:	4319      	orrs	r1, r3
  module->GCTRL = gctrl;
 80216d2:	6001      	str	r1, [r0, #0]
 80216d4:	4770      	bx	lr
 80216d6:	bf00      	nop

080216d8 <XMC_CCU8_SLICE_StartConfig>:
  XMC_ASSERT("XMC_CCU8_SLICE_StartConfig:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU8_SLICE_StartConfig:Invalid Event ID", XMC_CCU8_SLICE_CHECK_EVENT_ID(event));
  XMC_ASSERT("XMC_CCU8_SLICE_StartConfig:Invalid Start Mode", 
             ((start_mode == XMC_CCU8_SLICE_START_MODE_TIMER_START) ||\
              (start_mode == XMC_CCU8_SLICE_START_MODE_TIMER_START_CLEAR)));
  cmc = slice->CMC;
 80216d8:	6843      	ldr	r3, [r0, #4]

  cmc &= ~((uint32_t) CCU8_CC8_CMC_STRTS_Msk);
 80216da:	f023 0303 	bic.w	r3, r3, #3
  cmc |= ((uint32_t) event) << CCU8_CC8_CMC_STRTS_Pos;
 80216de:	4319      	orrs	r1, r3

  slice->CMC = cmc;
 80216e0:	6041      	str	r1, [r0, #4]

  tc  = slice->TC;
 80216e2:	6943      	ldr	r3, [r0, #20]

  if(start_mode == XMC_CCU8_SLICE_START_MODE_TIMER_START_CLEAR)
 80216e4:	2a01      	cmp	r2, #1
  {
    tc |= (uint32_t) CCU8_CC8_TC_STRM_Msk;
 80216e6:	bf0c      	ite	eq
 80216e8:	f443 6380 	orreq.w	r3, r3, #1024	; 0x400
  }
  else
  {
    tc &= ~((uint32_t) CCU8_CC8_TC_STRM_Msk);
 80216ec:	f423 6380 	bicne.w	r3, r3, #1024	; 0x400
  }

  slice->TC = tc;
 80216f0:	6143      	str	r3, [r0, #20]
 80216f2:	4770      	bx	lr

080216f4 <XMC_CCU8_SLICE_StopConfig>:

  XMC_ASSERT("XMC_CCU8_SLICE_StopConfig:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU8_SLICE_StopConfig:Invalid Event ID", XMC_CCU8_SLICE_CHECK_EVENT_ID(event));
  XMC_ASSERT("XMC_CCU8_SLICE_StopConfig:Invalid End Mode", XMC_CCU8_SLICE_CHECK_END_MODE(end_mode));

  cmc = slice->CMC;
 80216f4:	6843      	ldr	r3, [r0, #4]
  /* First, Bind the event with the stop function */
  cmc &= ~((uint32_t) CCU8_CC8_CMC_ENDS_Msk);
 80216f6:	f023 030c 	bic.w	r3, r3, #12
  cmc |= ((uint32_t) event) << CCU8_CC8_CMC_ENDS_Pos;
 80216fa:	ea43 0181 	orr.w	r1, r3, r1, lsl #2

  slice->CMC = cmc;
 80216fe:	6041      	str	r1, [r0, #4]

  /* Configure the stop mode */
  tc = slice->TC;
 8021700:	6943      	ldr	r3, [r0, #20]
  tc &= ~((uint32_t) CCU8_CC8_TC_ENDM_Msk);
 8021702:	f423 7340 	bic.w	r3, r3, #768	; 0x300
  tc |= ((uint32_t) end_mode) << CCU8_CC8_TC_ENDM_Pos;
 8021706:	ea43 2202 	orr.w	r2, r3, r2, lsl #8

  slice->TC = tc;
 802170a:	6142      	str	r2, [r0, #20]
 802170c:	4770      	bx	lr
 802170e:	bf00      	nop

08021710 <XMC_CCU8_SLICE_LoadConfig>:
  uint32_t cmc;

  XMC_ASSERT("XMC_CCU8_SLICE_LoadConfig:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU8_SLICE_LoadConfig:Invalid Event ID", XMC_CCU8_SLICE_CHECK_EVENT_ID(event));

  cmc = slice->CMC;
 8021710:	6843      	ldr	r3, [r0, #4]

  /* First, Bind the event with the load function */
  cmc &= ~((uint32_t) CCU8_CC8_CMC_LDS_Msk);
 8021712:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
  cmc |= ((uint32_t) event) << CCU8_CC8_CMC_LDS_Pos;
 8021716:	ea43 3101 	orr.w	r1, r3, r1, lsl #12

  slice->CMC = cmc;
 802171a:	6041      	str	r1, [r0, #4]
 802171c:	4770      	bx	lr
 802171e:	bf00      	nop

08021720 <XMC_CCU8_SLICE_LoadSelector>:
  uint32_t tc;

  XMC_ASSERT("XMC_CCU8_SLICE_LoadSelector:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU8_SLICE_LoadSelector:Invalid Channel number", XMC_CCU8_SLICE_CHECK_COMP_CHANNEL(ch_num));

  tc = slice->TC;
 8021720:	6943      	ldr	r3, [r0, #20]

  /* First, Bind the event with the load function */
  tc &= ~((uint32_t) CCU8_CC8_TC_TLS_Msk);
 8021722:	f023 0380 	bic.w	r3, r3, #128	; 0x80
  tc |= (uint32_t)ch_num << CCU8_CC8_TC_TLS_Pos;
 8021726:	ea43 11c1 	orr.w	r1, r3, r1, lsl #7

  slice->TC = tc;
 802172a:	6141      	str	r1, [r0, #20]
 802172c:	4770      	bx	lr
 802172e:	bf00      	nop

08021730 <XMC_CCU8_SLICE_ModulationConfig>:
void XMC_CCU8_SLICE_ModulationConfig(XMC_CCU8_SLICE_t *const slice,
                                     const XMC_CCU8_SLICE_EVENT_t event,
                                     const XMC_CCU8_SLICE_MODULATION_MODE_t mod_mode,
                                     const XMC_CCU8_SLICE_MODULATION_CHANNEL_t channel,
                                     const bool synch_with_pwm)
{
 8021730:	b430      	push	{r4, r5}
             XMC_CCU8_SLICE_CHECK_MODULATION_CHANNEL(channel));
  XMC_ASSERT("XMC_CCU8_SLICE_ModulationConfig:Invalid Modulation Mode", 
             ((mod_mode == XMC_CCU8_SLICE_MODULATION_MODE_CLEAR_ST_OUT) ||\
              (mod_mode == XMC_CCU8_SLICE_MODULATION_MODE_CLEAR_OUT)));

  cmc = slice->CMC;
 8021732:	6844      	ldr	r4, [r0, #4]
void XMC_CCU8_SLICE_ModulationConfig(XMC_CCU8_SLICE_t *const slice,
                                     const XMC_CCU8_SLICE_EVENT_t event,
                                     const XMC_CCU8_SLICE_MODULATION_MODE_t mod_mode,
                                     const XMC_CCU8_SLICE_MODULATION_CHANNEL_t channel,
                                     const bool synch_with_pwm)
{
 8021734:	f89d 5008 	ldrb.w	r5, [sp, #8]
              (mod_mode == XMC_CCU8_SLICE_MODULATION_MODE_CLEAR_OUT)));

  cmc = slice->CMC;

  /* First, Bind the event with the modulation function */
  cmc &= ~((uint32_t) CCU8_CC8_CMC_MOS_Msk);
 8021738:	f424 2440 	bic.w	r4, r4, #786432	; 0xc0000
  cmc |= ((uint32_t) event) << CCU8_CC8_CMC_MOS_Pos;
 802173c:	ea44 4181 	orr.w	r1, r4, r1, lsl #18

  slice->CMC = cmc;
 8021740:	6041      	str	r1, [r0, #4]

  tc  = slice->TC;
 8021742:	6941      	ldr	r1, [r0, #20]

  /* Next, Modulation mode */
  if(mod_mode == XMC_CCU8_SLICE_MODULATION_MODE_CLEAR_OUT)
 8021744:	2a01      	cmp	r2, #1
  {
    tc |= (uint32_t) CCU8_CC8_TC_EMT_Msk;
 8021746:	bf0c      	ite	eq
 8021748:	f041 7180 	orreq.w	r1, r1, #16777216	; 0x1000000
  }
  else
  {
    tc &= ~((uint32_t) CCU8_CC8_TC_EMT_Msk);
 802174c:	f021 7180 	bicne.w	r1, r1, #16777216	; 0x1000000
  }

  /* Synchronization of modulation effect with PWM cycle */
  if(synch_with_pwm == true)
 8021750:	b945      	cbnz	r5, 8021764 <XMC_CCU8_SLICE_ModulationConfig+0x34>
  {
    tc |= (uint32_t) CCU8_CC8_TC_EMS_Msk;
  }
  else
  {
    tc &= ~((uint32_t) CCU8_CC8_TC_EMS_Msk);
 8021752:	f421 0100 	bic.w	r1, r1, #8388608	; 0x800000
  }
  
  /* Configure on which channel external modulation to be applied */
  tc &= ~((uint32_t) CCU8_CC8_TC_EME_Msk);
 8021756:	f021 51c0 	bic.w	r1, r1, #402653184	; 0x18000000
  tc |= (uint32_t)channel << CCU8_CC8_TC_EME_Pos;
 802175a:	ea41 63c3 	orr.w	r3, r1, r3, lsl #27

  slice->TC = tc;
 802175e:	6143      	str	r3, [r0, #20]
}
 8021760:	bc30      	pop	{r4, r5}
 8021762:	4770      	bx	lr
  }

  /* Synchronization of modulation effect with PWM cycle */
  if(synch_with_pwm == true)
  {
    tc |= (uint32_t) CCU8_CC8_TC_EMS_Msk;
 8021764:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
 8021768:	e7f5      	b.n	8021756 <XMC_CCU8_SLICE_ModulationConfig+0x26>
 802176a:	bf00      	nop

0802176c <XMC_CCU8_SLICE_CountConfig>:
  uint32_t cmc;

  XMC_ASSERT("XMC_CCU8_SLICE_CountConfig:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU8_SLICE_CountConfig:Invalid Event ID", XMC_CCU8_SLICE_CHECK_EVENT_ID(event));

  cmc = slice->CMC;
 802176c:	6843      	ldr	r3, [r0, #4]

  /* First, Bind the event with the count function */
  cmc &= ~((uint32_t) CCU8_CC8_CMC_CNTS_Msk);
 802176e:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
  cmc |= ((uint32_t) event) << CCU8_CC8_CMC_CNTS_Pos;
 8021772:	ea43 3181 	orr.w	r1, r3, r1, lsl #14

  slice->CMC = cmc;
 8021776:	6041      	str	r1, [r0, #4]
 8021778:	4770      	bx	lr
 802177a:	bf00      	nop

0802177c <XMC_CCU8_SLICE_GateConfig>:
  uint32_t cmc;

  XMC_ASSERT("XMC_CCU8_SLICE_GateConfig:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU8_SLICE_GateConfig:Invalid Event ID", XMC_CCU8_SLICE_CHECK_EVENT_ID(event));

  cmc = slice->CMC;
 802177c:	6843      	ldr	r3, [r0, #4]

  /* First, Bind the event with the gate function */
  cmc &= ~((uint32_t) CCU8_CC8_CMC_GATES_Msk);
 802177e:	f423 7340 	bic.w	r3, r3, #768	; 0x300
  cmc |= ((uint32_t) event) << CCU8_CC8_CMC_GATES_Pos;
 8021782:	ea43 2101 	orr.w	r1, r3, r1, lsl #8

  slice->CMC = cmc;
 8021786:	6041      	str	r1, [r0, #4]
 8021788:	4770      	bx	lr
 802178a:	bf00      	nop

0802178c <XMC_CCU8_SLICE_DirectionConfig>:
  uint32_t cmc;

  XMC_ASSERT("XMC_CCU8_SLICE_DirectionConfig:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU8_SLICE_DirectionConfig:Invalid Event ID", XMC_CCU8_SLICE_CHECK_EVENT_ID(event));

  cmc = slice->CMC;
 802178c:	6843      	ldr	r3, [r0, #4]

  /* First, Bind the event with the direction function */
  cmc &= ~((uint32_t) CCU8_CC8_CMC_UDS_Msk);
 802178e:	f423 6340 	bic.w	r3, r3, #3072	; 0xc00
  cmc |= ((uint32_t) event) << CCU8_CC8_CMC_UDS_Pos;
 8021792:	ea43 2181 	orr.w	r1, r3, r1, lsl #10

  slice->CMC = cmc;
 8021796:	6041      	str	r1, [r0, #4]
 8021798:	4770      	bx	lr
 802179a:	bf00      	nop

0802179c <XMC_CCU8_SLICE_StatusBitOverrideConfig>:
{
  uint32_t cmc;

  XMC_ASSERT("XMC_CCU8_SLICE_StatusBitOverrideConfig:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));

  cmc = slice->CMC;
 802179c:	6843      	ldr	r3, [r0, #4]

  /* Map status bit trigger override to Event 1 &
         status bit value override to Event 2 */
  cmc &= ~((uint32_t) CCU8_CC8_CMC_OFS_Msk);
  cmc |= ((uint32_t) 1) << CCU8_CC8_CMC_OFS_Pos;
 802179e:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000

  slice->CMC = cmc;
 80217a2:	6043      	str	r3, [r0, #4]
 80217a4:	4770      	bx	lr
 80217a6:	bf00      	nop

080217a8 <XMC_CCU8_SLICE_TrapConfig>:

  XMC_ASSERT("XMC_CCU8_SLICE_TrapConfig:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU8_SLICE_TrapConfig:Invalid Exit Mode", ((exit_mode == XMC_CCU8_SLICE_TRAP_EXIT_MODE_AUTOMATIC) ||\
                                                             (exit_mode == XMC_CCU8_SLICE_TRAP_EXIT_MODE_SW)));

  cmc = slice->CMC;
 80217a8:	6843      	ldr	r3, [r0, #4]

  /* Map trap function to Event 2 */
  cmc &= ~((uint32_t) CCU8_CC8_CMC_TS_Msk);
  cmc |= ((uint32_t) 1) << CCU8_CC8_CMC_TS_Pos;
 80217aa:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000

  slice->CMC = cmc;
 80217ae:	6043      	str	r3, [r0, #4]

  tc = slice->TC;
 80217b0:	6943      	ldr	r3, [r0, #20]

  /* Configure synchronization option */
  if(synch_with_pwm == true)
 80217b2:	b14a      	cbz	r2, 80217c8 <XMC_CCU8_SLICE_TrapConfig+0x20>
  {
    tc |= (uint32_t) CCU8_CC8_TC_TRPSE_Msk;
 80217b4:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
  {
    tc &= ~((uint32_t) CCU8_CC8_TC_TRPSE_Msk);
  }

  /* Configure exit mode */
  if(exit_mode == XMC_CCU8_SLICE_TRAP_EXIT_MODE_SW)
 80217b8:	2901      	cmp	r1, #1
  {
    tc |= (uint32_t) CCU8_CC8_TC_TRPSW_Msk;
 80217ba:	bf0c      	ite	eq
 80217bc:	f443 0380 	orreq.w	r3, r3, #4194304	; 0x400000
  }
  else
  {
    tc &= ~((uint32_t) CCU8_CC8_TC_TRPSW_Msk);
 80217c0:	f423 0380 	bicne.w	r3, r3, #4194304	; 0x400000
  }

  slice->TC = tc;
 80217c4:	6143      	str	r3, [r0, #20]
 80217c6:	4770      	bx	lr
  {
    tc |= (uint32_t) CCU8_CC8_TC_TRPSE_Msk;
  }
  else
  {
    tc &= ~((uint32_t) CCU8_CC8_TC_TRPSE_Msk);
 80217c8:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 80217cc:	e7f4      	b.n	80217b8 <XMC_CCU8_SLICE_TrapConfig+0x10>
 80217ce:	bf00      	nop

080217d0 <XMC_CCU8_SLICE_ConfigureStatusBitOverrideEvent>:

/* API to configure a slice Status Bit Override event */
void XMC_CCU8_SLICE_ConfigureStatusBitOverrideEvent(XMC_CCU8_SLICE_t *const slice,
                                                    const XMC_CCU8_SLICE_EVENT_CONFIG_t *const ev1_config,
                                                    const XMC_CCU8_SLICE_EVENT_CONFIG_t *const ev2_config)
{
 80217d0:	b5f0      	push	{r4, r5, r6, r7, lr}
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_INPUT_CONFIG_MASK) << CCU8_CC8_INS1_EV2IS_Pos);
  ins |= ((uint32_t) ev2_config->mapped_input) << CCU8_CC8_INS1_EV2IS_Pos;

  slice->INS1 = ins;  
#else
  ins = slice->INS;
 80217d2:	6803      	ldr	r3, [r0, #0]

  /* Configure the edge sensitivity for event 1 */
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_EDGE_CONFIG_MASK) << CCU8_CC8_INS_EV1EM_Pos);
  ins |= ((uint32_t) ev1_config->edge) << CCU8_CC8_INS_EV1EM_Pos;
 80217d4:	784e      	ldrb	r6, [r1, #1]
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_EDGE_CONFIG_MASK) << CCU8_CC8_INS_EV2EM_Pos);
  ins |= ((uint32_t) ev2_config->edge) << CCU8_CC8_INS_EV2EM_Pos;

  /* Configure the level sensitivity for event 1 */
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_LEVEL_CONFIG_MASK) << CCU8_CC8_INS_EV1LM_Pos);
  ins |= ((uint32_t) ev1_config->level) << CCU8_CC8_INS_EV1LM_Pos;
 80217d6:	f891 e002 	ldrb.w	lr, [r1, #2]
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_LEVEL_CONFIG_MASK) << CCU8_CC8_INS_EV2LM_Pos);
  ins |= ((uint32_t) ev2_config->level) << CCU8_CC8_INS_EV2LM_Pos;

  /* Configure the debounce filter for event 1 */
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_FILTER_CONFIG_MASK) << CCU8_CC8_INS_LPF1M_Pos);
  ins |= ((uint32_t) ev1_config->duration) << CCU8_CC8_INS_LPF1M_Pos;
 80217da:	78cf      	ldrb	r7, [r1, #3]
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_FILTER_CONFIG_MASK) << CCU8_CC8_INS_LPF2M_Pos);
  ins |= ((uint32_t) ev2_config->duration) << CCU8_CC8_INS_LPF2M_Pos;

  /* Next, the input for Event1 */
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_INPUT_CONFIG_MASK) << CCU8_CC8_INS_EV1IS_Pos);
  ins |= ((uint32_t) ev1_config->mapped_input) << CCU8_CC8_INS_EV1IS_Pos;
 80217dc:	780d      	ldrb	r5, [r1, #0]
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_EDGE_CONFIG_MASK) << CCU8_CC8_INS_EV1EM_Pos);
  ins |= ((uint32_t) ev1_config->edge) << CCU8_CC8_INS_EV1EM_Pos;

  /* Configure the edge sensitivity for event 2 */
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_EDGE_CONFIG_MASK) << CCU8_CC8_INS_EV2EM_Pos);
  ins |= ((uint32_t) ev2_config->edge) << CCU8_CC8_INS_EV2EM_Pos;
 80217de:	7851      	ldrb	r1, [r2, #1]
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_LEVEL_CONFIG_MASK) << CCU8_CC8_INS_EV1LM_Pos);
  ins |= ((uint32_t) ev1_config->level) << CCU8_CC8_INS_EV1LM_Pos;

  /* Configure the level sensitivity for event 2 */
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_LEVEL_CONFIG_MASK) << CCU8_CC8_INS_EV2LM_Pos);
  ins |= ((uint32_t) ev2_config->level) << CCU8_CC8_INS_EV2LM_Pos;
 80217e0:	f892 c002 	ldrb.w	ip, [r2, #2]
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_INPUT_CONFIG_MASK) << CCU8_CC8_INS_EV1IS_Pos);
  ins |= ((uint32_t) ev1_config->mapped_input) << CCU8_CC8_INS_EV1IS_Pos;

  /* Finally, the input for Event2 */
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_INPUT_CONFIG_MASK) << CCU8_CC8_INS_EV2IS_Pos);
  ins |= ((uint32_t) ev2_config->mapped_input) << CCU8_CC8_INS_EV2IS_Pos;
 80217e4:	7814      	ldrb	r4, [r2, #0]
  slice->INS1 = ins;  
#else
  ins = slice->INS;

  /* Configure the edge sensitivity for event 1 */
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_EDGE_CONFIG_MASK) << CCU8_CC8_INS_EV1EM_Pos);
 80217e6:	f423 2340 	bic.w	r3, r3, #786432	; 0xc0000
  ins |= ((uint32_t) ev1_config->edge) << CCU8_CC8_INS_EV1EM_Pos;
 80217ea:	ea43 4686 	orr.w	r6, r3, r6, lsl #18

  /* Configure the edge sensitivity for event 2 */
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_EDGE_CONFIG_MASK) << CCU8_CC8_INS_EV2EM_Pos);
 80217ee:	f426 1640 	bic.w	r6, r6, #3145728	; 0x300000
  ins |= ((uint32_t) ev2_config->edge) << CCU8_CC8_INS_EV2EM_Pos;
 80217f2:	ea46 5101 	orr.w	r1, r6, r1, lsl #20

  /* Configure the level sensitivity for event 1 */
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_LEVEL_CONFIG_MASK) << CCU8_CC8_INS_EV1LM_Pos);
 80217f6:	f421 0100 	bic.w	r1, r1, #8388608	; 0x800000
  ins |= ((uint32_t) ev1_config->level) << CCU8_CC8_INS_EV1LM_Pos;
 80217fa:	ea41 51ce 	orr.w	r1, r1, lr, lsl #23

  /* Configure the level sensitivity for event 2 */
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_LEVEL_CONFIG_MASK) << CCU8_CC8_INS_EV2LM_Pos);
 80217fe:	f021 7180 	bic.w	r1, r1, #16777216	; 0x1000000
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_FILTER_CONFIG_MASK) << CCU8_CC8_INS_LPF1M_Pos);
  ins |= ((uint32_t) ev1_config->duration) << CCU8_CC8_INS_LPF1M_Pos;

  /* Configure the debounce filter for event 2 */
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_FILTER_CONFIG_MASK) << CCU8_CC8_INS_LPF2M_Pos);
  ins |= ((uint32_t) ev2_config->duration) << CCU8_CC8_INS_LPF2M_Pos;
 8021802:	78d3      	ldrb	r3, [r2, #3]
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_LEVEL_CONFIG_MASK) << CCU8_CC8_INS_EV1LM_Pos);
  ins |= ((uint32_t) ev1_config->level) << CCU8_CC8_INS_EV1LM_Pos;

  /* Configure the level sensitivity for event 2 */
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_LEVEL_CONFIG_MASK) << CCU8_CC8_INS_EV2LM_Pos);
  ins |= ((uint32_t) ev2_config->level) << CCU8_CC8_INS_EV2LM_Pos;
 8021804:	ea41 620c 	orr.w	r2, r1, ip, lsl #24

  /* Configure the debounce filter for event 1 */
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_FILTER_CONFIG_MASK) << CCU8_CC8_INS_LPF1M_Pos);
 8021808:	f022 52c0 	bic.w	r2, r2, #402653184	; 0x18000000
  ins |= ((uint32_t) ev1_config->duration) << CCU8_CC8_INS_LPF1M_Pos;
 802180c:	ea42 62c7 	orr.w	r2, r2, r7, lsl #27

  /* Configure the debounce filter for event 2 */
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_FILTER_CONFIG_MASK) << CCU8_CC8_INS_LPF2M_Pos);
 8021810:	f022 42c0 	bic.w	r2, r2, #1610612736	; 0x60000000
  ins |= ((uint32_t) ev2_config->duration) << CCU8_CC8_INS_LPF2M_Pos;
 8021814:	ea42 7243 	orr.w	r2, r2, r3, lsl #29

  /* Next, the input for Event1 */
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_INPUT_CONFIG_MASK) << CCU8_CC8_INS_EV1IS_Pos);
 8021818:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
  ins |= ((uint32_t) ev1_config->mapped_input) << CCU8_CC8_INS_EV1IS_Pos;
 802181c:	ea42 1305 	orr.w	r3, r2, r5, lsl #4

  /* Finally, the input for Event2 */
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_INPUT_CONFIG_MASK) << CCU8_CC8_INS_EV2IS_Pos);
 8021820:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
  ins |= ((uint32_t) ev2_config->mapped_input) << CCU8_CC8_INS_EV2IS_Pos;
 8021824:	ea43 2304 	orr.w	r3, r3, r4, lsl #8

  slice->INS = ins;
 8021828:	6003      	str	r3, [r0, #0]
 802182a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0802182c <XMC_CCU8_SLICE_ConfigureEvent>:
              (config->level == XMC_CCU8_SLICE_EVENT_LEVEL_SENSITIVITY_ACTIVE_LOW)));
  XMC_ASSERT("XMC_CCU8_SLICE_ConfigureEvent:Invalid Debounce Period",
             XMC_CCU8_SLICE_CHECK_EVENT_FILTER(config->duration));

  /* Calculate offset with reference to event */
  offset = ((uint8_t) event) - 1U;
 802182c:	1e4b      	subs	r3, r1, #1

/* API to configure a slice trigger event */
void XMC_CCU8_SLICE_ConfigureEvent(XMC_CCU8_SLICE_t *const slice,
                                   const XMC_CCU8_SLICE_EVENT_t event,
                                   const XMC_CCU8_SLICE_EVENT_CONFIG_t *const config)
{
 802182e:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
              (config->level == XMC_CCU8_SLICE_EVENT_LEVEL_SENSITIVITY_ACTIVE_LOW)));
  XMC_ASSERT("XMC_CCU8_SLICE_ConfigureEvent:Invalid Debounce Period",
             XMC_CCU8_SLICE_CHECK_EVENT_FILTER(config->duration));

  /* Calculate offset with reference to event */
  offset = ((uint8_t) event) - 1U;
 8021832:	b2db      	uxtb	r3, r3

#else
  ins = slice->INS;

  /* First, configure the edge sensitivity */
  pos = ((uint8_t) CCU8_CC8_INS_EV0EM_Pos) + (uint8_t)(offset << 1U);
 8021834:	ea4f 0843 	mov.w	r8, r3, lsl #1
 8021838:	fa5f f888 	uxtb.w	r8, r8
 802183c:	f108 0910 	add.w	r9, r8, #16
  ins |= ((uint32_t) config->mapped_input) << pos;

  slice->INS1 = ins;

#else
  ins = slice->INS;
 8021840:	6807      	ldr	r7, [r0, #0]

  /* First, configure the edge sensitivity */
  pos = ((uint8_t) CCU8_CC8_INS_EV0EM_Pos) + (uint8_t)(offset << 1U);
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_EDGE_CONFIG_MASK) << pos);
  ins |= ((uint32_t) config->edge) << pos;
 8021842:	f892 c001 	ldrb.w	ip, [r2, #1]

  /* Next, the level */
  pos = ((uint8_t) CCU8_CC8_INS_EV0LM_Pos) + offset;
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_LEVEL_CONFIG_MASK) << pos);
  ins |= ((uint32_t) (config->level)) << pos;
 8021846:	7896      	ldrb	r6, [r2, #2]

  /* Next, the debounce filter */
  pos = ((uint8_t) CCU8_CC8_INS_LPF0M_Pos) + (uint8_t)(offset << 1U);
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_FILTER_CONFIG_MASK) << pos);
  ins |= ((uint32_t) config->duration) << pos;
 8021848:	78d4      	ldrb	r4, [r2, #3]

  /* Finally the input */
  pos = ((uint8_t) CCU8_CC8_INS_EV0IS_Pos) + (uint8_t)(offset << 2U);
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_INPUT_CONFIG_MASK) << pos);
  ins |= ((uint32_t) config->mapped_input) << pos;
 802184a:	f892 e000 	ldrb.w	lr, [r2]
#else
  ins = slice->INS;

  /* First, configure the edge sensitivity */
  pos = ((uint8_t) CCU8_CC8_INS_EV0EM_Pos) + (uint8_t)(offset << 1U);
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_EDGE_CONFIG_MASK) << pos);
 802184e:	fa5f f989 	uxtb.w	r9, r9
 8021852:	2503      	movs	r5, #3
 8021854:	fa05 f209 	lsl.w	r2, r5, r9
  ins |= ((uint32_t) config->edge) << pos;

  /* Next, the level */
  pos = ((uint8_t) CCU8_CC8_INS_EV0LM_Pos) + offset;
 8021858:	3115      	adds	r1, #21
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_LEVEL_CONFIG_MASK) << pos);
 802185a:	b2c9      	uxtb	r1, r1
#else
  ins = slice->INS;

  /* First, configure the edge sensitivity */
  pos = ((uint8_t) CCU8_CC8_INS_EV0EM_Pos) + (uint8_t)(offset << 1U);
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_EDGE_CONFIG_MASK) << pos);
 802185c:	ea27 0202 	bic.w	r2, r7, r2
  ins |= ((uint32_t) config->edge) << pos;
 8021860:	fa0c fc09 	lsl.w	ip, ip, r9

  /* Next, the level */
  pos = ((uint8_t) CCU8_CC8_INS_EV0LM_Pos) + offset;
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_LEVEL_CONFIG_MASK) << pos);
 8021864:	2701      	movs	r7, #1
  ins = slice->INS;

  /* First, configure the edge sensitivity */
  pos = ((uint8_t) CCU8_CC8_INS_EV0EM_Pos) + (uint8_t)(offset << 1U);
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_EDGE_CONFIG_MASK) << pos);
  ins |= ((uint32_t) config->edge) << pos;
 8021866:	ea42 0c0c 	orr.w	ip, r2, ip

  /* Next, the level */
  pos = ((uint8_t) CCU8_CC8_INS_EV0LM_Pos) + offset;
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_LEVEL_CONFIG_MASK) << pos);
 802186a:	408f      	lsls	r7, r1
  ins |= ((uint32_t) (config->level)) << pos;

  /* Next, the debounce filter */
  pos = ((uint8_t) CCU8_CC8_INS_LPF0M_Pos) + (uint8_t)(offset << 1U);
 802186c:	f108 0819 	add.w	r8, r8, #25
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_FILTER_CONFIG_MASK) << pos);
 8021870:	fa5f f288 	uxtb.w	r2, r8
  ins |= ((uint32_t) config->edge) << pos;

  /* Next, the level */
  pos = ((uint8_t) CCU8_CC8_INS_EV0LM_Pos) + offset;
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_LEVEL_CONFIG_MASK) << pos);
  ins |= ((uint32_t) (config->level)) << pos;
 8021874:	408e      	lsls	r6, r1
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_EDGE_CONFIG_MASK) << pos);
  ins |= ((uint32_t) config->edge) << pos;

  /* Next, the level */
  pos = ((uint8_t) CCU8_CC8_INS_EV0LM_Pos) + offset;
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_LEVEL_CONFIG_MASK) << pos);
 8021876:	ea2c 0707 	bic.w	r7, ip, r7
  pos = ((uint8_t) CCU8_CC8_INS_LPF0M_Pos) + (uint8_t)(offset << 1U);
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_FILTER_CONFIG_MASK) << pos);
  ins |= ((uint32_t) config->duration) << pos;

  /* Finally the input */
  pos = ((uint8_t) CCU8_CC8_INS_EV0IS_Pos) + (uint8_t)(offset << 2U);
 802187a:	0099      	lsls	r1, r3, #2
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_LEVEL_CONFIG_MASK) << pos);
  ins |= ((uint32_t) (config->level)) << pos;

  /* Next, the debounce filter */
  pos = ((uint8_t) CCU8_CC8_INS_LPF0M_Pos) + (uint8_t)(offset << 1U);
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_FILTER_CONFIG_MASK) << pos);
 802187c:	4095      	lsls	r5, r2
  ins |= ((uint32_t) config->edge) << pos;

  /* Next, the level */
  pos = ((uint8_t) CCU8_CC8_INS_EV0LM_Pos) + offset;
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_LEVEL_CONFIG_MASK) << pos);
  ins |= ((uint32_t) (config->level)) << pos;
 802187e:	433e      	orrs	r6, r7
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_FILTER_CONFIG_MASK) << pos);
  ins |= ((uint32_t) config->duration) << pos;

  /* Finally the input */
  pos = ((uint8_t) CCU8_CC8_INS_EV0IS_Pos) + (uint8_t)(offset << 2U);
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_INPUT_CONFIG_MASK) << pos);
 8021880:	b2c9      	uxtb	r1, r1
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_LEVEL_CONFIG_MASK) << pos);
  ins |= ((uint32_t) (config->level)) << pos;

  /* Next, the debounce filter */
  pos = ((uint8_t) CCU8_CC8_INS_LPF0M_Pos) + (uint8_t)(offset << 1U);
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_FILTER_CONFIG_MASK) << pos);
 8021882:	ea26 0505 	bic.w	r5, r6, r5
  ins |= ((uint32_t) config->duration) << pos;
 8021886:	fa04 f202 	lsl.w	r2, r4, r2

  /* Finally the input */
  pos = ((uint8_t) CCU8_CC8_INS_EV0IS_Pos) + (uint8_t)(offset << 2U);
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_INPUT_CONFIG_MASK) << pos);
 802188a:	230f      	movs	r3, #15
  ins |= ((uint32_t) (config->level)) << pos;

  /* Next, the debounce filter */
  pos = ((uint8_t) CCU8_CC8_INS_LPF0M_Pos) + (uint8_t)(offset << 1U);
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_FILTER_CONFIG_MASK) << pos);
  ins |= ((uint32_t) config->duration) << pos;
 802188c:	432a      	orrs	r2, r5

  /* Finally the input */
  pos = ((uint8_t) CCU8_CC8_INS_EV0IS_Pos) + (uint8_t)(offset << 2U);
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_INPUT_CONFIG_MASK) << pos);
 802188e:	408b      	lsls	r3, r1
  ins |= ((uint32_t) config->mapped_input) << pos;
 8021890:	fa0e fe01 	lsl.w	lr, lr, r1
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_FILTER_CONFIG_MASK) << pos);
  ins |= ((uint32_t) config->duration) << pos;

  /* Finally the input */
  pos = ((uint8_t) CCU8_CC8_INS_EV0IS_Pos) + (uint8_t)(offset << 2U);
  ins &= ~(((uint32_t) XMC_CCU8_SLICE_EVENT_INPUT_CONFIG_MASK) << pos);
 8021894:	ea22 0303 	bic.w	r3, r2, r3
  ins |= ((uint32_t) config->mapped_input) << pos;
 8021898:	ea43 030e 	orr.w	r3, r3, lr

  slice->INS = ins;
 802189c:	6003      	str	r3, [r0, #0]
 802189e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80218a2:	bf00      	nop

080218a4 <XMC_CCU8_SLICE_SetTimerPeriodMatch>:

/* Programs period match value of the timer  */
void XMC_CCU8_SLICE_SetTimerPeriodMatch(XMC_CCU8_SLICE_t *const slice, const uint16_t period_val)
{
  XMC_ASSERT("XMC_CCU8_SLICE_SetTimerPeriodMatch:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  slice->PRS = (uint32_t) period_val;
 80218a4:	6341      	str	r1, [r0, #52]	; 0x34
 80218a6:	4770      	bx	lr

080218a8 <XMC_CCU8_SLICE_SetTimerCompareMatch>:
                                         const uint16_t compare_val)
{
  XMC_ASSERT("XMC_CCU8_SLICE_SetTimerCompareMatch:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU8_SLICE_SetTimerCompareMatch:Invalid channel", XMC_CCU8_SLICE_CHECK_COMP_CHANNEL(channel));

  if (XMC_CCU8_SLICE_COMPARE_CHANNEL_1 == channel)
 80218a8:	b109      	cbz	r1, 80218ae <XMC_CCU8_SLICE_SetTimerCompareMatch+0x6>
  {
    slice->CR1S = (uint32_t) compare_val;
  }
  else
  {
    slice->CR2S = (uint32_t) compare_val;
 80218aa:	6442      	str	r2, [r0, #68]	; 0x44
 80218ac:	4770      	bx	lr
  XMC_ASSERT("XMC_CCU8_SLICE_SetTimerCompareMatch:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU8_SLICE_SetTimerCompareMatch:Invalid channel", XMC_CCU8_SLICE_CHECK_COMP_CHANNEL(channel));

  if (XMC_CCU8_SLICE_COMPARE_CHANNEL_1 == channel)
  {
    slice->CR1S = (uint32_t) compare_val;
 80218ae:	63c2      	str	r2, [r0, #60]	; 0x3c
 80218b0:	4770      	bx	lr
 80218b2:	bf00      	nop

080218b4 <XMC_CCU8_SLICE_SetInterruptNode>:

/* Binds a capcom event to an NVIC node  */
void XMC_CCU8_SLICE_SetInterruptNode(XMC_CCU8_SLICE_t *const slice,
                                     const XMC_CCU8_SLICE_IRQ_ID_t event,
                                     const XMC_CCU8_SLICE_SR_ID_t sr)
{
 80218b4:	2909      	cmp	r1, #9
 80218b6:	b430      	push	{r4, r5}

  XMC_ASSERT("XMC_CCU8_SLICE_SetInterruptNode:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU8_SLICE_SetInterruptNode:Invalid SR ID ", XMC_CCU8_SLICE_CHECK_SR_ID(sr));
  XMC_ASSERT("XMC_CCU8_SLICE_SetInterruptNode:Invalid event", XMC_CCU8_SLICE_CHECK_INTERRUPT(event));

  srs = slice->SRS;
 80218b8:	f8d0 40a8 	ldr.w	r4, [r0, #168]	; 0xa8
 80218bc:	d80d      	bhi.n	80218da <XMC_CCU8_SLICE_SetInterruptNode+0x26>
 80218be:	4b09      	ldr	r3, [pc, #36]	; (80218e4 <XMC_CCU8_SLICE_SetInterruptNode+0x30>)
 80218c0:	4d09      	ldr	r5, [pc, #36]	; (80218e8 <XMC_CCU8_SLICE_SetInterruptNode+0x34>)
 80218c2:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 80218c6:	f855 1021 	ldr.w	r1, [r5, r1, lsl #2]
 80218ca:	43db      	mvns	r3, r3
      mask = ((uint32_t) CCU8_CC8_SRS_E2SR_Msk);
      pos  = CCU8_CC8_SRS_E2SR_Pos;
      break;
  }
  
  srs &= ~mask;
 80218cc:	4023      	ands	r3, r4
  srs |= (uint32_t)sr << pos;
 80218ce:	408a      	lsls	r2, r1
 80218d0:	431a      	orrs	r2, r3
  
  slice->SRS = srs;
 80218d2:	f8c0 20a8 	str.w	r2, [r0, #168]	; 0xa8
}
 80218d6:	bc30      	pop	{r4, r5}
 80218d8:	4770      	bx	lr

  XMC_ASSERT("XMC_CCU8_SLICE_SetInterruptNode:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU8_SLICE_SetInterruptNode:Invalid SR ID ", XMC_CCU8_SLICE_CHECK_SR_ID(sr));
  XMC_ASSERT("XMC_CCU8_SLICE_SetInterruptNode:Invalid event", XMC_CCU8_SLICE_CHECK_INTERRUPT(event));

  srs = slice->SRS;
 80218da:	210c      	movs	r1, #12
 80218dc:	f46f 5340 	mvn.w	r3, #12288	; 0x3000
 80218e0:	e7f4      	b.n	80218cc <XMC_CCU8_SLICE_SetInterruptNode+0x18>
 80218e2:	bf00      	nop
 80218e4:	0802f254 	.word	0x0802f254
 80218e8:	0802f27c 	.word	0x0802f27c

080218ec <XMC_CCU8_SLICE_DeadTimeInit>:
                                 const XMC_CCU8_SLICE_DEAD_TIME_CONFIG_t *const config)
{
  XMC_ASSERT("XMC_CCU8_SLICE_ConfigureDeadTime:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));

  /* Program dead time value for channel 1 */
  slice->DC1R = config->dc1r;
 80218ec:	684b      	ldr	r3, [r1, #4]
 80218ee:	6503      	str	r3, [r0, #80]	; 0x50
  /* Program dead time value for channel 2 */
  slice->DC2R = config->dc2r;
 80218f0:	688b      	ldr	r3, [r1, #8]
 80218f2:	6543      	str	r3, [r0, #84]	; 0x54
  /* Program dead time control configuration */
  slice->DTC = config->dtc;
 80218f4:	680b      	ldr	r3, [r1, #0]
 80218f6:	64c3      	str	r3, [r0, #76]	; 0x4c
 80218f8:	4770      	bx	lr
 80218fa:	bf00      	nop

080218fc <XMC_DMA_Init>:

/* Enable GPDMA module */
void XMC_DMA_Enable(XMC_DMA_t *const dma)
{
#if defined(GPDMA1)
  if (dma == XMC_DMA0)
 80218fc:	4b0c      	ldr	r3, [pc, #48]	; (8021930 <XMC_DMA_Init+0x34>)
 80218fe:	4298      	cmp	r0, r3
 * API IMPLEMENTATION
 *******************************************************************************/

/* Initialize GPDMA */
void XMC_DMA_Init(XMC_DMA_t *const dma)
{
 8021900:	b510      	push	{r4, lr}
 8021902:	4604      	mov	r4, r0

/* Enable GPDMA module */
void XMC_DMA_Enable(XMC_DMA_t *const dma)
{
#if defined(GPDMA1)
  if (dma == XMC_DMA0)
 8021904:	d009      	beq.n	802191a <XMC_DMA_Init+0x1e>
#if defined(GPDMA1)
  }
  else
  {
#if defined(CLOCK_GATING_SUPPORTED)
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_GPDMA1);
 8021906:	480b      	ldr	r0, [pc, #44]	; (8021934 <XMC_DMA_Init+0x38>)
 8021908:	f7ff fbe6 	bl	80210d8 <XMC_SCU_CLOCK_UngatePeripheralClock>
#endif
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_GPDMA1);
 802190c:	4809      	ldr	r0, [pc, #36]	; (8021934 <XMC_DMA_Init+0x38>)
 802190e:	f7ff fb67 	bl	8020fe0 <XMC_SCU_RESET_DeassertPeripheralReset>
  }
#endif

  dma->DMACFGREG = 0x1U;
 8021912:	2301      	movs	r3, #1
 8021914:	f8c4 3398 	str.w	r3, [r4, #920]	; 0x398
 8021918:	bd10      	pop	{r4, pc}
#if defined(GPDMA1)
  if (dma == XMC_DMA0)
  {
#endif
#if defined(CLOCK_GATING_SUPPORTED)
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_GPDMA0);
 802191a:	4807      	ldr	r0, [pc, #28]	; (8021938 <XMC_DMA_Init+0x3c>)
 802191c:	f7ff fbdc 	bl	80210d8 <XMC_SCU_CLOCK_UngatePeripheralClock>
#endif
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_GPDMA0);
 8021920:	4805      	ldr	r0, [pc, #20]	; (8021938 <XMC_DMA_Init+0x3c>)
 8021922:	f7ff fb5d 	bl	8020fe0 <XMC_SCU_RESET_DeassertPeripheralReset>
#endif
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_GPDMA1);
  }
#endif

  dma->DMACFGREG = 0x1U;
 8021926:	2301      	movs	r3, #1
 8021928:	f8c4 3398 	str.w	r3, [r4, #920]	; 0x398
 802192c:	bd10      	pop	{r4, pc}
 802192e:	bf00      	nop
 8021930:	50014000 	.word	0x50014000
 8021934:	20000020 	.word	0x20000020
 8021938:	20000010 	.word	0x20000010

0802193c <XMC_DMA_CH_Disable>:
}

/* Disable DMA channel */
void XMC_DMA_CH_Disable(XMC_DMA_t *const dma, const uint8_t channel)
{
  dma->CHENREG = (uint32_t)(0x100UL << channel);
 802193c:	f44f 7380 	mov.w	r3, #256	; 0x100
 8021940:	408b      	lsls	r3, r1
 8021942:	2201      	movs	r2, #1
 8021944:	f8c0 33a0 	str.w	r3, [r0, #928]	; 0x3a0
 8021948:	408a      	lsls	r2, r1
  while((dma->CHENREG & (uint32_t)(0x1UL << channel)) != 0U)
 802194a:	f8d0 33a0 	ldr.w	r3, [r0, #928]	; 0x3a0
 802194e:	421a      	tst	r2, r3
 8021950:	d1fb      	bne.n	802194a <XMC_DMA_CH_Disable+0xe>
  {
    /* wait until channel is disabled */
  }
}
 8021952:	4770      	bx	lr

08021954 <XMC_DMA_CH_Init>:
  return (bool)(dma->CHENREG & ((uint32_t)1U << channel));
}

/* Initialize DMA channel */
XMC_DMA_CH_STATUS_t XMC_DMA_CH_Init(XMC_DMA_t *const dma, const uint8_t channel, const XMC_DMA_CH_CONFIG_t *const config)
{
 8021954:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
bool XMC_DMA_IsEnabled(const XMC_DMA_t *const dma)
{
  bool status;

#if defined(GPDMA1)
  if (dma == XMC_DMA0)
 8021956:	4ba1      	ldr	r3, [pc, #644]	; (8021bdc <XMC_DMA_CH_Init+0x288>)
 8021958:	4298      	cmp	r0, r3
  return (bool)(dma->CHENREG & ((uint32_t)1U << channel));
}

/* Initialize DMA channel */
XMC_DMA_CH_STATUS_t XMC_DMA_CH_Init(XMC_DMA_t *const dma, const uint8_t channel, const XMC_DMA_CH_CONFIG_t *const config)
{
 802195a:	4604      	mov	r4, r0
 802195c:	460e      	mov	r6, r1
 802195e:	4615      	mov	r5, r2
bool XMC_DMA_IsEnabled(const XMC_DMA_t *const dma)
{
  bool status;

#if defined(GPDMA1)
  if (dma == XMC_DMA0)
 8021960:	d053      	beq.n	8021a0a <XMC_DMA_CH_Init+0xb6>
#endif
#if defined(GPDMA1)
  }
  else
  {
    status = !XMC_SCU_RESET_IsPeripheralResetAsserted(XMC_SCU_PERIPHERAL_RESET_GPDMA1);
 8021962:	489f      	ldr	r0, [pc, #636]	; (8021be0 <XMC_DMA_CH_Init+0x28c>)
 8021964:	f7ff fb48 	bl	8020ff8 <XMC_SCU_RESET_IsPeripheralResetAsserted>
#if defined(CLOCK_GATING_SUPPORTED)
    status = status && !XMC_SCU_CLOCK_IsPeripheralClockGated(XMC_SCU_PERIPHERAL_CLOCK_GPDMA1);
 8021968:	b108      	cbz	r0, 802196e <XMC_DMA_CH_Init+0x1a>
      status = XMC_DMA_CH_STATUS_BUSY;
    }
  }
  else 
  {
    status = XMC_DMA_CH_STATUS_ERROR;
 802196a:	2001      	movs	r0, #1
 802196c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  }
  else
  {
    status = !XMC_SCU_RESET_IsPeripheralResetAsserted(XMC_SCU_PERIPHERAL_RESET_GPDMA1);
#if defined(CLOCK_GATING_SUPPORTED)
    status = status && !XMC_SCU_CLOCK_IsPeripheralClockGated(XMC_SCU_PERIPHERAL_CLOCK_GPDMA1);
 802196e:	489c      	ldr	r0, [pc, #624]	; (8021be0 <XMC_DMA_CH_Init+0x28c>)
 8021970:	f7ff fbbe 	bl	80210f0 <XMC_SCU_CLOCK_IsPeripheralClockGated>
 8021974:	f080 0001 	eor.w	r0, r0, #1
 8021978:	b2c0      	uxtb	r0, r0
#endif
  }
#endif

  /* DMA reset is not asserted and peripheral clock is not gated */
  if (status == true)
 802197a:	2800      	cmp	r0, #0
 802197c:	d0f5      	beq.n	802196a <XMC_DMA_CH_Init+0x16>
  {
    status = status && (dma->DMACFGREG != 0U);
 802197e:	f8d4 3398 	ldr.w	r3, [r4, #920]	; 0x398
{
  XMC_DMA_CH_STATUS_t status;
  uint8_t line;
  uint8_t peripheral;

  if (XMC_DMA_IsEnabled(dma) == true)
 8021982:	2b00      	cmp	r3, #0
 8021984:	d0f1      	beq.n	802196a <XMC_DMA_CH_Init+0x16>
}

/* Check if a DMA channel is enabled */
bool XMC_DMA_CH_IsEnabled(XMC_DMA_t *const dma, const uint8_t channel)
{
  return (bool)(dma->CHENREG & ((uint32_t)1U << channel));
 8021986:	f8d4 33a0 	ldr.w	r3, [r4, #928]	; 0x3a0
 802198a:	40f3      	lsrs	r3, r6
  uint8_t line;
  uint8_t peripheral;

  if (XMC_DMA_IsEnabled(dma) == true)
  {
    if (XMC_DMA_CH_IsEnabled(dma, channel) == false)
 802198c:	07db      	lsls	r3, r3, #31
 802198e:	d501      	bpl.n	8021994 <XMC_DMA_CH_Init+0x40>
      status = XMC_DMA_CH_STATUS_OK;

    }
    else
    {
      status = XMC_DMA_CH_STATUS_BUSY;
 8021990:	2002      	movs	r0, #2
 8021992:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

  if (XMC_DMA_IsEnabled(dma) == true)
  {
    if (XMC_DMA_CH_IsEnabled(dma, channel) == false)
    {
      dma->CH[channel].SAR = config->src_addr;
 8021994:	2258      	movs	r2, #88	; 0x58
 8021996:	fb02 f206 	mul.w	r2, r2, r6
 802199a:	6869      	ldr	r1, [r5, #4]
 802199c:	50a1      	str	r1, [r4, r2]
 802199e:	18a3      	adds	r3, r4, r2
      dma->CH[channel].DAR = config->dst_addr;
 80219a0:	68a9      	ldr	r1, [r5, #8]
      dma->CH[channel].LLP = (uint32_t)config->linked_list_pointer;
      dma->CH[channel].CTLH = (uint32_t)config->block_size;
      dma->CH[channel].CTLL = config->control;

      dma->CH[channel].CFGL = (uint32_t)((uint32_t)config->priority |
 80219a2:	7eea      	ldrb	r2, [r5, #27]
  {
    if (XMC_DMA_CH_IsEnabled(dma, channel) == false)
    {
      dma->CH[channel].SAR = config->src_addr;
      dma->CH[channel].DAR = config->dst_addr;
      dma->CH[channel].LLP = (uint32_t)config->linked_list_pointer;
 80219a4:	f8d5 e00c 	ldr.w	lr, [r5, #12]
      dma->CH[channel].CTLH = (uint32_t)config->block_size;
 80219a8:	8b2f      	ldrh	r7, [r5, #24]
  if (XMC_DMA_IsEnabled(dma) == true)
  {
    if (XMC_DMA_CH_IsEnabled(dma, channel) == false)
    {
      dma->CH[channel].SAR = config->src_addr;
      dma->CH[channel].DAR = config->dst_addr;
 80219aa:	6099      	str	r1, [r3, #8]

      dma->CH[channel].CFGL = (uint32_t)((uint32_t)config->priority |
                                         (uint32_t)GPDMA0_CH_CFGL_HS_SEL_SRC_Msk |
                                         (uint32_t)GPDMA0_CH_CFGL_HS_SEL_DST_Msk);

      if ((dma == XMC_DMA0) && (channel < (uint8_t)2))
 80219ac:	498b      	ldr	r1, [pc, #556]	; (8021bdc <XMC_DMA_CH_Init+0x288>)
  {
    if (XMC_DMA_CH_IsEnabled(dma, channel) == false)
    {
      dma->CH[channel].SAR = config->src_addr;
      dma->CH[channel].DAR = config->dst_addr;
      dma->CH[channel].LLP = (uint32_t)config->linked_list_pointer;
 80219ae:	f8c3 e010 	str.w	lr, [r3, #16]
      dma->CH[channel].CTLH = (uint32_t)config->block_size;
 80219b2:	61df      	str	r7, [r3, #28]
      dma->CH[channel].CTLL = config->control;
 80219b4:	6828      	ldr	r0, [r5, #0]
 80219b6:	6198      	str	r0, [r3, #24]

      dma->CH[channel].CFGL = (uint32_t)((uint32_t)config->priority |
 80219b8:	f442 6240 	orr.w	r2, r2, #3072	; 0xc00
                                         (uint32_t)GPDMA0_CH_CFGL_HS_SEL_SRC_Msk |
                                         (uint32_t)GPDMA0_CH_CFGL_HS_SEL_DST_Msk);

      if ((dma == XMC_DMA0) && (channel < (uint8_t)2))
 80219bc:	428c      	cmp	r4, r1
      dma->CH[channel].DAR = config->dst_addr;
      dma->CH[channel].LLP = (uint32_t)config->linked_list_pointer;
      dma->CH[channel].CTLH = (uint32_t)config->block_size;
      dma->CH[channel].CTLL = config->control;

      dma->CH[channel].CFGL = (uint32_t)((uint32_t)config->priority |
 80219be:	641a      	str	r2, [r3, #64]	; 0x40
                                         (uint32_t)GPDMA0_CH_CFGL_HS_SEL_SRC_Msk |
                                         (uint32_t)GPDMA0_CH_CFGL_HS_SEL_DST_Msk);

      if ((dma == XMC_DMA0) && (channel < (uint8_t)2))
 80219c0:	d02f      	beq.n	8021a22 <XMC_DMA_CH_Init+0xce>
        /* Configure scatter and gather */
        dma->CH[channel].SGR = config->src_gather_control;
        dma->CH[channel].DSR = config->dst_scatter_control;
      }

      if (config->dst_handshaking == XMC_DMA_CH_DST_HANDSHAKING_HARDWARE)
 80219c2:	8c2b      	ldrh	r3, [r5, #32]
 80219c4:	b923      	cbnz	r3, 80219d0 <XMC_DMA_CH_Init+0x7c>
      {
        /* Hardware handshaking interface configuration */
        if ((config->transfer_flow == (uint32_t)XMC_DMA_CH_TRANSFER_FLOW_M2P_DMA) ||
 80219c6:	78ab      	ldrb	r3, [r5, #2]
 80219c8:	f003 0350 	and.w	r3, r3, #80	; 0x50
 80219cc:	2b10      	cmp	r3, #16
 80219ce:	d02f      	beq.n	8021a30 <XMC_DMA_CH_Init+0xdc>
          dma->CH[channel].CFGL &= (uint32_t)~GPDMA0_CH_CFGL_HS_SEL_DST_Msk;
        }
      }


      if (config->src_handshaking == XMC_DMA_CH_SRC_HANDSHAKING_HARDWARE)
 80219d0:	8bab      	ldrh	r3, [r5, #28]
 80219d2:	b923      	cbnz	r3, 80219de <XMC_DMA_CH_Init+0x8a>
      {
        if ((config->transfer_flow == (uint32_t)XMC_DMA_CH_TRANSFER_FLOW_P2M_DMA) ||
 80219d4:	78ab      	ldrb	r3, [r5, #2]
 80219d6:	f003 0360 	and.w	r3, r3, #96	; 0x60
 80219da:	2b20      	cmp	r3, #32
 80219dc:	d053      	beq.n	8021a86 <XMC_DMA_CH_Init+0x132>
                                                           (uint32_t)XMC_DMA_CH_EVENT_BLOCK_TRANSFER_COMPLETE |
                                                           (uint32_t)XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE |
                                                           (uint32_t)XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE |
                                                           (uint32_t)XMC_DMA_CH_EVENT_ERROR));

      switch (config->transfer_type)
 80219de:	7eaa      	ldrb	r2, [r5, #26]

  for(event_idx = 0UL; event_idx < DMA_EVENT_MAX; ++event_idx)
  {
    if (event & (uint32_t)((uint32_t)0x1UL << event_idx))
    {
      dma->CLEARCHEV[event_idx * 2UL] = ((uint32_t)0x1UL << channel);
 80219e0:	2301      	movs	r3, #1
 80219e2:	40b3      	lsls	r3, r6
                                                           (uint32_t)XMC_DMA_CH_EVENT_BLOCK_TRANSFER_COMPLETE |
                                                           (uint32_t)XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE |
                                                           (uint32_t)XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE |
                                                           (uint32_t)XMC_DMA_CH_EVENT_ERROR));

      switch (config->transfer_type)
 80219e4:	3a01      	subs	r2, #1

  for(event_idx = 0UL; event_idx < DMA_EVENT_MAX; ++event_idx)
  {
    if (event & (uint32_t)((uint32_t)0x1UL << event_idx))
    {
      dma->CLEARCHEV[event_idx * 2UL] = ((uint32_t)0x1UL << channel);
 80219e6:	f8c4 3338 	str.w	r3, [r4, #824]	; 0x338
 80219ea:	f8c4 3340 	str.w	r3, [r4, #832]	; 0x340
 80219ee:	f8c4 3348 	str.w	r3, [r4, #840]	; 0x348
 80219f2:	f8c4 3350 	str.w	r3, [r4, #848]	; 0x350
 80219f6:	f8c4 3358 	str.w	r3, [r4, #856]	; 0x358
                                                           (uint32_t)XMC_DMA_CH_EVENT_BLOCK_TRANSFER_COMPLETE |
                                                           (uint32_t)XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE |
                                                           (uint32_t)XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE |
                                                           (uint32_t)XMC_DMA_CH_EVENT_ERROR));

      switch (config->transfer_type)
 80219fa:	2a07      	cmp	r2, #7
 80219fc:	d86c      	bhi.n	8021ad8 <XMC_DMA_CH_Init+0x184>
 80219fe:	e8df f002 	tbb	[pc, r2]
 8021a02:	9e95      	.short	0x9e95
 8021a04:	8c7f766d 	.word	0x8c7f766d
 8021a08:	b4a7      	.short	0xb4a7

#if defined(GPDMA1)
  if (dma == XMC_DMA0)
  {
#endif
    status = !XMC_SCU_RESET_IsPeripheralResetAsserted(XMC_SCU_PERIPHERAL_RESET_GPDMA0);
 8021a0a:	4876      	ldr	r0, [pc, #472]	; (8021be4 <XMC_DMA_CH_Init+0x290>)
 8021a0c:	f7ff faf4 	bl	8020ff8 <XMC_SCU_RESET_IsPeripheralResetAsserted>
#if defined(CLOCK_GATING_SUPPORTED)
    status = status && !XMC_SCU_CLOCK_IsPeripheralClockGated(XMC_SCU_PERIPHERAL_CLOCK_GPDMA0);
 8021a10:	2800      	cmp	r0, #0
 8021a12:	d1aa      	bne.n	802196a <XMC_DMA_CH_Init+0x16>
 8021a14:	4873      	ldr	r0, [pc, #460]	; (8021be4 <XMC_DMA_CH_Init+0x290>)
 8021a16:	f7ff fb6b 	bl	80210f0 <XMC_SCU_CLOCK_IsPeripheralClockGated>
 8021a1a:	f080 0001 	eor.w	r0, r0, #1
 8021a1e:	b2c0      	uxtb	r0, r0
 8021a20:	e7ab      	b.n	802197a <XMC_DMA_CH_Init+0x26>

      dma->CH[channel].CFGL = (uint32_t)((uint32_t)config->priority |
                                         (uint32_t)GPDMA0_CH_CFGL_HS_SEL_SRC_Msk |
                                         (uint32_t)GPDMA0_CH_CFGL_HS_SEL_DST_Msk);

      if ((dma == XMC_DMA0) && (channel < (uint8_t)2))
 8021a22:	2e01      	cmp	r6, #1
 8021a24:	d8cd      	bhi.n	80219c2 <XMC_DMA_CH_Init+0x6e>
      {
        /* Configure scatter and gather */
        dma->CH[channel].SGR = config->src_gather_control;
 8021a26:	692a      	ldr	r2, [r5, #16]
 8021a28:	649a      	str	r2, [r3, #72]	; 0x48
        dma->CH[channel].DSR = config->dst_scatter_control;
 8021a2a:	696a      	ldr	r2, [r5, #20]
 8021a2c:	651a      	str	r2, [r3, #80]	; 0x50
 8021a2e:	e7c8      	b.n	80219c2 <XMC_DMA_CH_Init+0x6e>
        /* Hardware handshaking interface configuration */
        if ((config->transfer_flow == (uint32_t)XMC_DMA_CH_TRANSFER_FLOW_M2P_DMA) ||
            (config->transfer_flow == (uint32_t)XMC_DMA_CH_TRANSFER_FLOW_P2P_DMA))
        {
#if defined(GPDMA1)
          if (dma == XMC_DMA0)
 8021a30:	4b6a      	ldr	r3, [pc, #424]	; (8021bdc <XMC_DMA_CH_Init+0x288>)
{
#if defined(GPDMA1)
  if (dma == XMC_DMA0)
  {
#endif
    DLR->SRSEL0 = ((DLR->SRSEL0 & (uint32_t)~(DLR_SRSEL_RS_MSK << (line * DLR_SRSEL_RS_BITSIZE))) |
 8021a32:	496d      	ldr	r1, [pc, #436]	; (8021be8 <XMC_DMA_CH_Init+0x294>)
            line = config->dst_peripheral_request & GPDMA1_CH_CFGH_PER_Msk;
          }
#endif
          peripheral = config->dst_peripheral_request >> GPDMA_CH_CFGH_PER_BITSIZE;

          dma->CH[channel].CFGH |= (uint32_t)((uint32_t)line << GPDMA0_CH_CFGH_DEST_PER_Pos);
 8021a34:	2258      	movs	r2, #88	; 0x58
 8021a36:	fb02 4206 	mla	r2, r2, r6, r4
        /* Hardware handshaking interface configuration */
        if ((config->transfer_flow == (uint32_t)XMC_DMA_CH_TRANSFER_FLOW_M2P_DMA) ||
            (config->transfer_flow == (uint32_t)XMC_DMA_CH_TRANSFER_FLOW_P2P_DMA))
        {
#if defined(GPDMA1)
          if (dma == XMC_DMA0)
 8021a3a:	429c      	cmp	r4, r3
            line = config->dst_peripheral_request & GPDMA1_CH_CFGH_PER_Msk;
          }
#endif
          peripheral = config->dst_peripheral_request >> GPDMA_CH_CFGH_PER_BITSIZE;

          dma->CH[channel].CFGH |= (uint32_t)((uint32_t)line << GPDMA0_CH_CFGH_DEST_PER_Pos);
 8021a3c:	6c57      	ldr	r7, [r2, #68]	; 0x44
        {
#if defined(GPDMA1)
          if (dma == XMC_DMA0)
          {
#endif
            line = config->dst_peripheral_request & GPDMA0_CH_CFGH_PER_Msk;
 8021a3e:	f895 3022 	ldrb.w	r3, [r5, #34]	; 0x22
        /* Hardware handshaking interface configuration */
        if ((config->transfer_flow == (uint32_t)XMC_DMA_CH_TRANSFER_FLOW_M2P_DMA) ||
            (config->transfer_flow == (uint32_t)XMC_DMA_CH_TRANSFER_FLOW_P2P_DMA))
        {
#if defined(GPDMA1)
          if (dma == XMC_DMA0)
 8021a42:	f000 80b3 	beq.w	8021bac <XMC_DMA_CH_Init+0x258>
            line = config->dst_peripheral_request & GPDMA0_CH_CFGH_PER_Msk;
#if defined(GPDMA1)
          }
          else
          {
            line = config->dst_peripheral_request & GPDMA1_CH_CFGH_PER_Msk;
 8021a46:	f003 0003 	and.w	r0, r3, #3
          }
#endif
          peripheral = config->dst_peripheral_request >> GPDMA_CH_CFGH_PER_BITSIZE;

          dma->CH[channel].CFGH |= (uint32_t)((uint32_t)line << GPDMA0_CH_CFGH_DEST_PER_Pos);
 8021a4a:	ea47 27c0 	orr.w	r7, r7, r0, lsl #11
 8021a4e:	6457      	str	r7, [r2, #68]	; 0x44
    DLR->LNEN |= (0x1UL << (line & GPDMA0_CH_CFGH_PER_Msk));
#if defined(GPDMA1)
  }
  else
  {
    DLR->SRSEL1 = ((DLR->SRSEL1 & (uint32_t)~(DLR_SRSEL_RS_MSK << (line * DLR_SRSEL_RS_BITSIZE))) |
 8021a50:	68cf      	ldr	r7, [r1, #12]
 8021a52:	ea4f 0e80 	mov.w	lr, r0, lsl #2
 8021a56:	220f      	movs	r2, #15
                   ((uint32_t)peripheral << (line * DLR_SRSEL_RS_BITSIZE)));
 8021a58:	091b      	lsrs	r3, r3, #4
    DLR->LNEN |= (0x1UL << (line & GPDMA0_CH_CFGH_PER_Msk));
#if defined(GPDMA1)
  }
  else
  {
    DLR->SRSEL1 = ((DLR->SRSEL1 & (uint32_t)~(DLR_SRSEL_RS_MSK << (line * DLR_SRSEL_RS_BITSIZE))) |
 8021a5a:	fa02 f20e 	lsl.w	r2, r2, lr
 8021a5e:	ea27 0202 	bic.w	r2, r7, r2
                   ((uint32_t)peripheral << (line * DLR_SRSEL_RS_BITSIZE)));
 8021a62:	fa03 f30e 	lsl.w	r3, r3, lr
    DLR->LNEN |= (0x1UL << (line & GPDMA0_CH_CFGH_PER_Msk));
#if defined(GPDMA1)
  }
  else
  {
    DLR->SRSEL1 = ((DLR->SRSEL1 & (uint32_t)~(DLR_SRSEL_RS_MSK << (line * DLR_SRSEL_RS_BITSIZE))) |
 8021a66:	4313      	orrs	r3, r2
 8021a68:	60cb      	str	r3, [r1, #12]
                   ((uint32_t)peripheral << (line * DLR_SRSEL_RS_BITSIZE)));
    DLR->LNEN |= (0x100UL << line);
 8021a6a:	690a      	ldr	r2, [r1, #16]
 8021a6c:	f44f 7380 	mov.w	r3, #256	; 0x100
 8021a70:	4083      	lsls	r3, r0
 8021a72:	4313      	orrs	r3, r2
 8021a74:	610b      	str	r3, [r1, #16]
#endif
          peripheral = config->dst_peripheral_request >> GPDMA_CH_CFGH_PER_BITSIZE;

          dma->CH[channel].CFGH |= (uint32_t)((uint32_t)line << GPDMA0_CH_CFGH_DEST_PER_Pos);
          XMC_DMA_EnableRequestLine(dma, line, peripheral);
          dma->CH[channel].CFGL &= (uint32_t)~GPDMA0_CH_CFGL_HS_SEL_DST_Msk;
 8021a76:	2358      	movs	r3, #88	; 0x58
 8021a78:	fb03 4306 	mla	r3, r3, r6, r4
 8021a7c:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8021a7e:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8021a82:	641a      	str	r2, [r3, #64]	; 0x40
 8021a84:	e7a4      	b.n	80219d0 <XMC_DMA_CH_Init+0x7c>
      {
        if ((config->transfer_flow == (uint32_t)XMC_DMA_CH_TRANSFER_FLOW_P2M_DMA) ||
            (config->transfer_flow == (uint32_t)XMC_DMA_CH_TRANSFER_FLOW_P2P_DMA))
        {
#if defined(GPDMA1)
          if (dma == XMC_DMA0)
 8021a86:	4b55      	ldr	r3, [pc, #340]	; (8021bdc <XMC_DMA_CH_Init+0x288>)
{
#if defined(GPDMA1)
  if (dma == XMC_DMA0)
  {
#endif
    DLR->SRSEL0 = ((DLR->SRSEL0 & (uint32_t)~(DLR_SRSEL_RS_MSK << (line * DLR_SRSEL_RS_BITSIZE))) |
 8021a88:	4957      	ldr	r1, [pc, #348]	; (8021be8 <XMC_DMA_CH_Init+0x294>)
            line = config->src_peripheral_request & GPDMA1_CH_CFGH_PER_Msk;
          }
#endif
          peripheral = config->src_peripheral_request >> GPDMA_CH_CFGH_PER_BITSIZE;

          dma->CH[channel].CFGH |= (uint32_t)((uint32_t)line << GPDMA0_CH_CFGH_SRC_PER_Pos);
 8021a8a:	2258      	movs	r2, #88	; 0x58
 8021a8c:	fb02 4206 	mla	r2, r2, r6, r4
      {
        if ((config->transfer_flow == (uint32_t)XMC_DMA_CH_TRANSFER_FLOW_P2M_DMA) ||
            (config->transfer_flow == (uint32_t)XMC_DMA_CH_TRANSFER_FLOW_P2P_DMA))
        {
#if defined(GPDMA1)
          if (dma == XMC_DMA0)
 8021a90:	429c      	cmp	r4, r3
            line = config->src_peripheral_request & GPDMA1_CH_CFGH_PER_Msk;
          }
#endif
          peripheral = config->src_peripheral_request >> GPDMA_CH_CFGH_PER_BITSIZE;

          dma->CH[channel].CFGH |= (uint32_t)((uint32_t)line << GPDMA0_CH_CFGH_SRC_PER_Pos);
 8021a92:	6c57      	ldr	r7, [r2, #68]	; 0x44
        {
#if defined(GPDMA1)
          if (dma == XMC_DMA0)
          {
#endif
            line = config->src_peripheral_request & GPDMA0_CH_CFGH_PER_Msk;
 8021a94:	7fab      	ldrb	r3, [r5, #30]
      {
        if ((config->transfer_flow == (uint32_t)XMC_DMA_CH_TRANSFER_FLOW_P2M_DMA) ||
            (config->transfer_flow == (uint32_t)XMC_DMA_CH_TRANSFER_FLOW_P2P_DMA))
        {
#if defined(GPDMA1)
          if (dma == XMC_DMA0)
 8021a96:	d071      	beq.n	8021b7c <XMC_DMA_CH_Init+0x228>
            line = config->src_peripheral_request & GPDMA0_CH_CFGH_PER_Msk;
#if defined(GPDMA1)
          }
          else
          {
            line = config->src_peripheral_request & GPDMA1_CH_CFGH_PER_Msk;
 8021a98:	f003 0003 	and.w	r0, r3, #3
          }
#endif
          peripheral = config->src_peripheral_request >> GPDMA_CH_CFGH_PER_BITSIZE;

          dma->CH[channel].CFGH |= (uint32_t)((uint32_t)line << GPDMA0_CH_CFGH_SRC_PER_Pos);
 8021a9c:	ea47 17c0 	orr.w	r7, r7, r0, lsl #7
 8021aa0:	6457      	str	r7, [r2, #68]	; 0x44
    DLR->LNEN |= (0x1UL << (line & GPDMA0_CH_CFGH_PER_Msk));
#if defined(GPDMA1)
  }
  else
  {
    DLR->SRSEL1 = ((DLR->SRSEL1 & (uint32_t)~(DLR_SRSEL_RS_MSK << (line * DLR_SRSEL_RS_BITSIZE))) |
 8021aa2:	68cf      	ldr	r7, [r1, #12]
 8021aa4:	ea4f 0e80 	mov.w	lr, r0, lsl #2
 8021aa8:	220f      	movs	r2, #15
                   ((uint32_t)peripheral << (line * DLR_SRSEL_RS_BITSIZE)));
 8021aaa:	091b      	lsrs	r3, r3, #4
    DLR->LNEN |= (0x1UL << (line & GPDMA0_CH_CFGH_PER_Msk));
#if defined(GPDMA1)
  }
  else
  {
    DLR->SRSEL1 = ((DLR->SRSEL1 & (uint32_t)~(DLR_SRSEL_RS_MSK << (line * DLR_SRSEL_RS_BITSIZE))) |
 8021aac:	fa02 f20e 	lsl.w	r2, r2, lr
 8021ab0:	ea27 0202 	bic.w	r2, r7, r2
                   ((uint32_t)peripheral << (line * DLR_SRSEL_RS_BITSIZE)));
 8021ab4:	fa03 f30e 	lsl.w	r3, r3, lr
    DLR->LNEN |= (0x1UL << (line & GPDMA0_CH_CFGH_PER_Msk));
#if defined(GPDMA1)
  }
  else
  {
    DLR->SRSEL1 = ((DLR->SRSEL1 & (uint32_t)~(DLR_SRSEL_RS_MSK << (line * DLR_SRSEL_RS_BITSIZE))) |
 8021ab8:	4313      	orrs	r3, r2
 8021aba:	60cb      	str	r3, [r1, #12]
                   ((uint32_t)peripheral << (line * DLR_SRSEL_RS_BITSIZE)));
    DLR->LNEN |= (0x100UL << line);
 8021abc:	690a      	ldr	r2, [r1, #16]
 8021abe:	f44f 7380 	mov.w	r3, #256	; 0x100
 8021ac2:	4083      	lsls	r3, r0
 8021ac4:	4313      	orrs	r3, r2
 8021ac6:	610b      	str	r3, [r1, #16]
#endif
          peripheral = config->src_peripheral_request >> GPDMA_CH_CFGH_PER_BITSIZE;

          dma->CH[channel].CFGH |= (uint32_t)((uint32_t)line << GPDMA0_CH_CFGH_SRC_PER_Pos);
          XMC_DMA_EnableRequestLine(dma, line, peripheral);
          dma->CH[channel].CFGL &= (uint32_t)~GPDMA0_CH_CFGL_HS_SEL_SRC_Msk;
 8021ac8:	2358      	movs	r3, #88	; 0x58
 8021aca:	fb03 4306 	mla	r3, r3, r6, r4
 8021ace:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8021ad0:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 8021ad4:	641a      	str	r2, [r3, #64]	; 0x40
 8021ad6:	e782      	b.n	80219de <XMC_DMA_CH_Init+0x8a>

        default:
          break;
      }

      status = XMC_DMA_CH_STATUS_OK;
 8021ad8:	2000      	movs	r0, #0
 8021ada:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_RELOAD_DSTADR_CONTIGUOUS:
          dma->CH[channel].CFGL |= (uint32_t)GPDMA0_CH_CFGL_RELOAD_SRC_Msk;
          break;

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_RELOAD_DSTADR_RELOAD:
          dma->CH[channel].CFGL |= (uint32_t)((uint32_t)GPDMA0_CH_CFGL_RELOAD_DST_Msk |
 8021adc:	2158      	movs	r1, #88	; 0x58
 8021ade:	fb01 4406 	mla	r4, r1, r6, r4

        default:
          break;
      }

      status = XMC_DMA_CH_STATUS_OK;
 8021ae2:	2000      	movs	r0, #0
        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_RELOAD_DSTADR_CONTIGUOUS:
          dma->CH[channel].CFGL |= (uint32_t)GPDMA0_CH_CFGL_RELOAD_SRC_Msk;
          break;

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_RELOAD_DSTADR_RELOAD:
          dma->CH[channel].CFGL |= (uint32_t)((uint32_t)GPDMA0_CH_CFGL_RELOAD_DST_Msk |
 8021ae4:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8021ae6:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
 8021aea:	6423      	str	r3, [r4, #64]	; 0x40
                                              (uint32_t)GPDMA0_CH_CFGL_RELOAD_SRC_Msk);
          break;
 8021aec:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_CONTIGUOUS_DSTADR_LINKED:
          dma->CH[channel].CTLL |= (uint32_t)GPDMA0_CH_CTLL_LLP_DST_EN_Msk;
 8021aee:	2158      	movs	r1, #88	; 0x58
 8021af0:	fb01 4406 	mla	r4, r1, r6, r4

        default:
          break;
      }

      status = XMC_DMA_CH_STATUS_OK;
 8021af4:	2000      	movs	r0, #0
          dma->CH[channel].CFGL |= (uint32_t)((uint32_t)GPDMA0_CH_CFGL_RELOAD_DST_Msk |
                                              (uint32_t)GPDMA0_CH_CFGL_RELOAD_SRC_Msk);
          break;

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_CONTIGUOUS_DSTADR_LINKED:
          dma->CH[channel].CTLL |= (uint32_t)GPDMA0_CH_CTLL_LLP_DST_EN_Msk;
 8021af6:	69a3      	ldr	r3, [r4, #24]
 8021af8:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 8021afc:	61a3      	str	r3, [r4, #24]
          break;
 8021afe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_RELOAD_DSTADR_LINKED:
          dma->CH[channel].CFGL |= (uint32_t)GPDMA0_CH_CFGL_RELOAD_SRC_Msk;
 8021b00:	2158      	movs	r1, #88	; 0x58
 8021b02:	fb01 4406 	mla	r4, r1, r6, r4

        default:
          break;
      }

      status = XMC_DMA_CH_STATUS_OK;
 8021b06:	2000      	movs	r0, #0
        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_CONTIGUOUS_DSTADR_LINKED:
          dma->CH[channel].CTLL |= (uint32_t)GPDMA0_CH_CTLL_LLP_DST_EN_Msk;
          break;

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_RELOAD_DSTADR_LINKED:
          dma->CH[channel].CFGL |= (uint32_t)GPDMA0_CH_CFGL_RELOAD_SRC_Msk;
 8021b08:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8021b0a:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 8021b0e:	6423      	str	r3, [r4, #64]	; 0x40
          dma->CH[channel].CTLL |= (uint32_t)GPDMA0_CH_CTLL_LLP_DST_EN_Msk;
 8021b10:	69a3      	ldr	r3, [r4, #24]
 8021b12:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 8021b16:	61a3      	str	r3, [r4, #24]
          break;
 8021b18:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_LINKED_DSTADR_CONTIGUOUS:
          dma->CH[channel].CTLL |= (uint32_t)GPDMA0_CH_CTLL_LLP_SRC_EN_Msk;
 8021b1a:	2158      	movs	r1, #88	; 0x58
 8021b1c:	fb01 4406 	mla	r4, r1, r6, r4

        default:
          break;
      }

      status = XMC_DMA_CH_STATUS_OK;
 8021b20:	2000      	movs	r0, #0
          dma->CH[channel].CFGL |= (uint32_t)GPDMA0_CH_CFGL_RELOAD_SRC_Msk;
          dma->CH[channel].CTLL |= (uint32_t)GPDMA0_CH_CTLL_LLP_DST_EN_Msk;
          break;

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_LINKED_DSTADR_CONTIGUOUS:
          dma->CH[channel].CTLL |= (uint32_t)GPDMA0_CH_CTLL_LLP_SRC_EN_Msk;
 8021b22:	69a3      	ldr	r3, [r4, #24]
 8021b24:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8021b28:	61a3      	str	r3, [r4, #24]
          break;
 8021b2a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      {
        case XMC_DMA_CH_TRANSFER_TYPE_SINGLE_BLOCK:
          break;

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_CONTIGUOUS_DSTADR_RELOAD:
          dma->CH[channel].CFGL |= (uint32_t)GPDMA0_CH_CFGL_RELOAD_DST_Msk;
 8021b2c:	2158      	movs	r1, #88	; 0x58
 8021b2e:	fb01 4406 	mla	r4, r1, r6, r4

        default:
          break;
      }

      status = XMC_DMA_CH_STATUS_OK;
 8021b32:	2000      	movs	r0, #0
      {
        case XMC_DMA_CH_TRANSFER_TYPE_SINGLE_BLOCK:
          break;

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_CONTIGUOUS_DSTADR_RELOAD:
          dma->CH[channel].CFGL |= (uint32_t)GPDMA0_CH_CFGL_RELOAD_DST_Msk;
 8021b34:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8021b36:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8021b3a:	6423      	str	r3, [r4, #64]	; 0x40
          break;
 8021b3c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_RELOAD_DSTADR_CONTIGUOUS:
          dma->CH[channel].CFGL |= (uint32_t)GPDMA0_CH_CFGL_RELOAD_SRC_Msk;
 8021b3e:	2158      	movs	r1, #88	; 0x58
 8021b40:	fb01 4406 	mla	r4, r1, r6, r4

        default:
          break;
      }

      status = XMC_DMA_CH_STATUS_OK;
 8021b44:	2000      	movs	r0, #0
        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_CONTIGUOUS_DSTADR_RELOAD:
          dma->CH[channel].CFGL |= (uint32_t)GPDMA0_CH_CFGL_RELOAD_DST_Msk;
          break;

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_RELOAD_DSTADR_CONTIGUOUS:
          dma->CH[channel].CFGL |= (uint32_t)GPDMA0_CH_CFGL_RELOAD_SRC_Msk;
 8021b46:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8021b48:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 8021b4c:	6423      	str	r3, [r4, #64]	; 0x40
          break;
 8021b4e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_LINKED_DSTADR_CONTIGUOUS:
          dma->CH[channel].CTLL |= (uint32_t)GPDMA0_CH_CTLL_LLP_SRC_EN_Msk;
          break;

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_LINKED_DSTADR_RELOAD:
          dma->CH[channel].CFGL |= (uint32_t)GPDMA0_CH_CFGL_RELOAD_DST_Msk;
 8021b50:	2158      	movs	r1, #88	; 0x58
 8021b52:	fb01 4406 	mla	r4, r1, r6, r4

        default:
          break;
      }

      status = XMC_DMA_CH_STATUS_OK;
 8021b56:	2000      	movs	r0, #0
        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_LINKED_DSTADR_CONTIGUOUS:
          dma->CH[channel].CTLL |= (uint32_t)GPDMA0_CH_CTLL_LLP_SRC_EN_Msk;
          break;

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_LINKED_DSTADR_RELOAD:
          dma->CH[channel].CFGL |= (uint32_t)GPDMA0_CH_CFGL_RELOAD_DST_Msk;
 8021b58:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8021b5a:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8021b5e:	6423      	str	r3, [r4, #64]	; 0x40
          dma->CH[channel].CTLL |= (uint32_t)GPDMA0_CH_CTLL_LLP_SRC_EN_Msk;
 8021b60:	69a3      	ldr	r3, [r4, #24]
 8021b62:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8021b66:	61a3      	str	r3, [r4, #24]
          break;
 8021b68:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_LINKED_DSTADR_LINKED:
          dma->CH[channel].CTLL |= (uint32_t)((uint32_t)GPDMA0_CH_CTLL_LLP_SRC_EN_Msk |
 8021b6a:	2158      	movs	r1, #88	; 0x58
 8021b6c:	fb01 4406 	mla	r4, r1, r6, r4

        default:
          break;
      }

      status = XMC_DMA_CH_STATUS_OK;
 8021b70:	2000      	movs	r0, #0
          dma->CH[channel].CFGL |= (uint32_t)GPDMA0_CH_CFGL_RELOAD_DST_Msk;
          dma->CH[channel].CTLL |= (uint32_t)GPDMA0_CH_CTLL_LLP_SRC_EN_Msk;
          break;

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_LINKED_DSTADR_LINKED:
          dma->CH[channel].CTLL |= (uint32_t)((uint32_t)GPDMA0_CH_CTLL_LLP_SRC_EN_Msk |
 8021b72:	69a3      	ldr	r3, [r4, #24]
 8021b74:	f043 53c0 	orr.w	r3, r3, #402653184	; 0x18000000
 8021b78:	61a3      	str	r3, [r4, #24]
                                              (uint32_t)GPDMA0_CH_CTLL_LLP_DST_EN_Msk);
          break;
 8021b7a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        {
#if defined(GPDMA1)
          if (dma == XMC_DMA0)
          {
#endif
            line = config->src_peripheral_request & GPDMA0_CH_CFGH_PER_Msk;
 8021b7c:	f003 0007 	and.w	r0, r3, #7
            line = config->src_peripheral_request & GPDMA1_CH_CFGH_PER_Msk;
          }
#endif
          peripheral = config->src_peripheral_request >> GPDMA_CH_CFGH_PER_BITSIZE;

          dma->CH[channel].CFGH |= (uint32_t)((uint32_t)line << GPDMA0_CH_CFGH_SRC_PER_Pos);
 8021b80:	ea47 17c0 	orr.w	r7, r7, r0, lsl #7
 8021b84:	6457      	str	r7, [r2, #68]	; 0x44
{
#if defined(GPDMA1)
  if (dma == XMC_DMA0)
  {
#endif
    DLR->SRSEL0 = ((DLR->SRSEL0 & (uint32_t)~(DLR_SRSEL_RS_MSK << (line * DLR_SRSEL_RS_BITSIZE))) |
 8021b86:	688f      	ldr	r7, [r1, #8]
 8021b88:	ea4f 0e80 	mov.w	lr, r0, lsl #2
 8021b8c:	220f      	movs	r2, #15
                   ((uint32_t)peripheral << (line * DLR_SRSEL_RS_BITSIZE)));
 8021b8e:	091b      	lsrs	r3, r3, #4
{
#if defined(GPDMA1)
  if (dma == XMC_DMA0)
  {
#endif
    DLR->SRSEL0 = ((DLR->SRSEL0 & (uint32_t)~(DLR_SRSEL_RS_MSK << (line * DLR_SRSEL_RS_BITSIZE))) |
 8021b90:	fa02 f20e 	lsl.w	r2, r2, lr
 8021b94:	ea27 0202 	bic.w	r2, r7, r2
                   ((uint32_t)peripheral << (line * DLR_SRSEL_RS_BITSIZE)));
 8021b98:	fa03 f30e 	lsl.w	r3, r3, lr
{
#if defined(GPDMA1)
  if (dma == XMC_DMA0)
  {
#endif
    DLR->SRSEL0 = ((DLR->SRSEL0 & (uint32_t)~(DLR_SRSEL_RS_MSK << (line * DLR_SRSEL_RS_BITSIZE))) |
 8021b9c:	4313      	orrs	r3, r2
 8021b9e:	608b      	str	r3, [r1, #8]
                   ((uint32_t)peripheral << (line * DLR_SRSEL_RS_BITSIZE)));
    DLR->LNEN |= (0x1UL << (line & GPDMA0_CH_CFGH_PER_Msk));
 8021ba0:	690a      	ldr	r2, [r1, #16]
 8021ba2:	2301      	movs	r3, #1
 8021ba4:	4083      	lsls	r3, r0
 8021ba6:	4313      	orrs	r3, r2
 8021ba8:	610b      	str	r3, [r1, #16]
 8021baa:	e78d      	b.n	8021ac8 <XMC_DMA_CH_Init+0x174>
        {
#if defined(GPDMA1)
          if (dma == XMC_DMA0)
          {
#endif
            line = config->dst_peripheral_request & GPDMA0_CH_CFGH_PER_Msk;
 8021bac:	f003 0007 	and.w	r0, r3, #7
            line = config->dst_peripheral_request & GPDMA1_CH_CFGH_PER_Msk;
          }
#endif
          peripheral = config->dst_peripheral_request >> GPDMA_CH_CFGH_PER_BITSIZE;

          dma->CH[channel].CFGH |= (uint32_t)((uint32_t)line << GPDMA0_CH_CFGH_DEST_PER_Pos);
 8021bb0:	ea47 27c0 	orr.w	r7, r7, r0, lsl #11
 8021bb4:	6457      	str	r7, [r2, #68]	; 0x44
{
#if defined(GPDMA1)
  if (dma == XMC_DMA0)
  {
#endif
    DLR->SRSEL0 = ((DLR->SRSEL0 & (uint32_t)~(DLR_SRSEL_RS_MSK << (line * DLR_SRSEL_RS_BITSIZE))) |
 8021bb6:	688f      	ldr	r7, [r1, #8]
 8021bb8:	ea4f 0e80 	mov.w	lr, r0, lsl #2
 8021bbc:	220f      	movs	r2, #15
                   ((uint32_t)peripheral << (line * DLR_SRSEL_RS_BITSIZE)));
 8021bbe:	091b      	lsrs	r3, r3, #4
{
#if defined(GPDMA1)
  if (dma == XMC_DMA0)
  {
#endif
    DLR->SRSEL0 = ((DLR->SRSEL0 & (uint32_t)~(DLR_SRSEL_RS_MSK << (line * DLR_SRSEL_RS_BITSIZE))) |
 8021bc0:	fa02 f20e 	lsl.w	r2, r2, lr
 8021bc4:	ea27 0202 	bic.w	r2, r7, r2
                   ((uint32_t)peripheral << (line * DLR_SRSEL_RS_BITSIZE)));
 8021bc8:	fa03 f30e 	lsl.w	r3, r3, lr
{
#if defined(GPDMA1)
  if (dma == XMC_DMA0)
  {
#endif
    DLR->SRSEL0 = ((DLR->SRSEL0 & (uint32_t)~(DLR_SRSEL_RS_MSK << (line * DLR_SRSEL_RS_BITSIZE))) |
 8021bcc:	4313      	orrs	r3, r2
 8021bce:	608b      	str	r3, [r1, #8]
                   ((uint32_t)peripheral << (line * DLR_SRSEL_RS_BITSIZE)));
    DLR->LNEN |= (0x1UL << (line & GPDMA0_CH_CFGH_PER_Msk));
 8021bd0:	690a      	ldr	r2, [r1, #16]
 8021bd2:	2301      	movs	r3, #1
 8021bd4:	4083      	lsls	r3, r0
 8021bd6:	4313      	orrs	r3, r2
 8021bd8:	610b      	str	r3, [r1, #16]
 8021bda:	e74c      	b.n	8021a76 <XMC_DMA_CH_Init+0x122>
 8021bdc:	50014000 	.word	0x50014000
 8021be0:	20000020 	.word	0x20000020
 8021be4:	20000010 	.word	0x20000010
 8021be8:	50004900 	.word	0x50004900

08021bec <XMC_DMA_CH_EnableEvent>:

  for(event_idx = 0UL; event_idx < DMA_EVENT_MAX; ++event_idx)
  {
    if (event & ((uint32_t)0x1UL << event_idx))
    {
      dma->MASKCHEV[event_idx * 2UL] = ((uint32_t)0x101UL << channel);
 8021bec:	f240 1301 	movw	r3, #257	; 0x101
 8021bf0:	408b      	lsls	r3, r1
{
  uint32_t event_idx;

  for(event_idx = 0UL; event_idx < DMA_EVENT_MAX; ++event_idx)
  {
    if (event & ((uint32_t)0x1UL << event_idx))
 8021bf2:	07d1      	lsls	r1, r2, #31
    {
      dma->MASKCHEV[event_idx * 2UL] = ((uint32_t)0x101UL << channel);
 8021bf4:	bf48      	it	mi
 8021bf6:	f8c0 3310 	strmi.w	r3, [r0, #784]	; 0x310
{
  uint32_t event_idx;

  for(event_idx = 0UL; event_idx < DMA_EVENT_MAX; ++event_idx)
  {
    if (event & ((uint32_t)0x1UL << event_idx))
 8021bfa:	0791      	lsls	r1, r2, #30
    {
      dma->MASKCHEV[event_idx * 2UL] = ((uint32_t)0x101UL << channel);
 8021bfc:	bf48      	it	mi
 8021bfe:	f8c0 3318 	strmi.w	r3, [r0, #792]	; 0x318
{
  uint32_t event_idx;

  for(event_idx = 0UL; event_idx < DMA_EVENT_MAX; ++event_idx)
  {
    if (event & ((uint32_t)0x1UL << event_idx))
 8021c02:	0751      	lsls	r1, r2, #29
    {
      dma->MASKCHEV[event_idx * 2UL] = ((uint32_t)0x101UL << channel);
 8021c04:	bf48      	it	mi
 8021c06:	f8c0 3320 	strmi.w	r3, [r0, #800]	; 0x320
{
  uint32_t event_idx;

  for(event_idx = 0UL; event_idx < DMA_EVENT_MAX; ++event_idx)
  {
    if (event & ((uint32_t)0x1UL << event_idx))
 8021c0a:	0711      	lsls	r1, r2, #28
    {
      dma->MASKCHEV[event_idx * 2UL] = ((uint32_t)0x101UL << channel);
 8021c0c:	bf48      	it	mi
 8021c0e:	f8c0 3328 	strmi.w	r3, [r0, #808]	; 0x328
{
  uint32_t event_idx;

  for(event_idx = 0UL; event_idx < DMA_EVENT_MAX; ++event_idx)
  {
    if (event & ((uint32_t)0x1UL << event_idx))
 8021c12:	06d2      	lsls	r2, r2, #27
    {
      dma->MASKCHEV[event_idx * 2UL] = ((uint32_t)0x101UL << channel);
 8021c14:	bf48      	it	mi
 8021c16:	f8c0 3330 	strmi.w	r3, [r0, #816]	; 0x330
 8021c1a:	4770      	bx	lr

08021c1c <XMC_DMA_CH_SetEventHandler>:

/* Set event handler */
void XMC_DMA_CH_SetEventHandler(XMC_DMA_t *const dma, const uint8_t channel, XMC_DMA_CH_EVENT_HANDLER_t event_handler)
{
#if defined(GPDMA1)
  if (dma == XMC_DMA0)
 8021c1c:	4b03      	ldr	r3, [pc, #12]	; (8021c2c <XMC_DMA_CH_SetEventHandler+0x10>)
 8021c1e:	4298      	cmp	r0, r3
  {
#endif
    dma0_event_handlers[channel] = event_handler;
 8021c20:	bf0c      	ite	eq
 8021c22:	4b03      	ldreq	r3, [pc, #12]	; (8021c30 <XMC_DMA_CH_SetEventHandler+0x14>)
#if defined(GPDMA1)
  }
  else
  {
    dma1_event_handlers[channel] = event_handler;
 8021c24:	4b03      	ldrne	r3, [pc, #12]	; (8021c34 <XMC_DMA_CH_SetEventHandler+0x18>)
 8021c26:	f843 2021 	str.w	r2, [r3, r1, lsl #2]
 8021c2a:	4770      	bx	lr
 8021c2c:	50014000 	.word	0x50014000
 8021c30:	1fff0060 	.word	0x1fff0060
 8021c34:	1fff0080 	.word	0x1fff0080

08021c38 <XMC_DMA_CH_ClearSourcePeripheralRequest>:
}

void XMC_DMA_CH_ClearSourcePeripheralRequest(XMC_DMA_t *const dma, uint8_t channel)
{
  uint32_t line;
  line = (dma->CH[channel].CFGH & GPDMA0_CH_CFGH_SRC_PER_Msk) >> GPDMA0_CH_CFGH_SRC_PER_Pos;
 8021c38:	2358      	movs	r3, #88	; 0x58
 8021c3a:	fb03 0101 	mla	r1, r3, r1, r0
}

void XMC_DMA_ClearRequestLine(XMC_DMA_t *const dma, uint8_t line)
{
#if defined(GPDMA1)
  if (dma == XMC_DMA0)
 8021c3e:	4a0a      	ldr	r2, [pc, #40]	; (8021c68 <XMC_DMA_CH_ClearSourcePeripheralRequest+0x30>)
}

void XMC_DMA_CH_ClearSourcePeripheralRequest(XMC_DMA_t *const dma, uint8_t channel)
{
  uint32_t line;
  line = (dma->CH[channel].CFGH & GPDMA0_CH_CFGH_SRC_PER_Msk) >> GPDMA0_CH_CFGH_SRC_PER_Pos;
 8021c40:	6c4b      	ldr	r3, [r1, #68]	; 0x44
 8021c42:	f3c3 11c3 	ubfx	r1, r3, #7, #4
{
#if defined(GPDMA1)
  if (dma == XMC_DMA0)
  {
#endif
    DLR->LNEN &= ~(0x1UL << line);
 8021c46:	4b09      	ldr	r3, [pc, #36]	; (8021c6c <XMC_DMA_CH_ClearSourcePeripheralRequest+0x34>)
}

void XMC_DMA_ClearRequestLine(XMC_DMA_t *const dma, uint8_t line)
{
#if defined(GPDMA1)
  if (dma == XMC_DMA0)
 8021c48:	4290      	cmp	r0, r2
  {
#endif
    DLR->LNEN &= ~(0x1UL << line);
 8021c4a:	bf08      	it	eq
 8021c4c:	2201      	moveq	r2, #1
	DLR->LNEN |= 0x1UL << line;
#if defined(GPDMA1)
  }
  else
  {
    DLR->LNEN &= ~(0x100UL << line);
 8021c4e:	6918      	ldr	r0, [r3, #16]
 8021c50:	bf18      	it	ne
 8021c52:	f44f 7280 	movne.w	r2, #256	; 0x100
 8021c56:	408a      	lsls	r2, r1
 8021c58:	ea20 0102 	bic.w	r1, r0, r2
 8021c5c:	6119      	str	r1, [r3, #16]
	DLR->LNEN |= 0x100UL << line;
 8021c5e:	6919      	ldr	r1, [r3, #16]
 8021c60:	430a      	orrs	r2, r1
 8021c62:	611a      	str	r2, [r3, #16]
 8021c64:	4770      	bx	lr
 8021c66:	bf00      	nop
 8021c68:	50014000 	.word	0x50014000
 8021c6c:	50004900 	.word	0x50004900

08021c70 <XMC_DMA_IRQHandler>:
    dma_event_handlers = dma0_event_handlers;
#if defined(GPDMA1)
  }
  else
  {
    dma_event_handlers = dma1_event_handlers;
 8021c70:	4a5a      	ldr	r2, [pc, #360]	; (8021ddc <XMC_DMA_IRQHandler+0x16c>)
 8021c72:	495b      	ldr	r1, [pc, #364]	; (8021de0 <XMC_DMA_IRQHandler+0x170>)
 * Destination transaction complete -> ::XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE <br>
 * DMA error event -> ::XMC_DMA_CH_EVENT_ERROR                                     <br>
 */
__STATIC_INLINE uint32_t XMC_DMA_GetEventStatus(XMC_DMA_t *const dma)
{
  return (dma->STATUSGLEV);
 8021c74:	f8d0 3360 	ldr.w	r3, [r0, #864]	; 0x360
  XMC_DMA_ClearRequestLine(dma, (uint8_t)line);
}

/* Default DMA IRQ handler */
void XMC_DMA_IRQHandler(XMC_DMA_t *const dma)
{
 8021c78:	b430      	push	{r4, r5}
  uint32_t mask;
  XMC_DMA_CH_EVENT_HANDLER_t *dma_event_handlers;
  XMC_DMA_CH_EVENT_HANDLER_t event_handler;

#if defined(GPDMA1)
  if (dma == XMC_DMA0)
 8021c7a:	4d5a      	ldr	r5, [pc, #360]	; (8021de4 <XMC_DMA_IRQHandler+0x174>)
    dma_event_handlers = dma0_event_handlers;
#if defined(GPDMA1)
  }
  else
  {
    dma_event_handlers = dma1_event_handlers;
 8021c7c:	42a8      	cmp	r0, r5
 8021c7e:	bf0c      	ite	eq
 8021c80:	460d      	moveq	r5, r1
 8021c82:	4615      	movne	r5, r2
#endif
  
  event = XMC_DMA_GetEventStatus(dma);
  channel = 0;

  if ((event & (uint32_t)XMC_DMA_CH_EVENT_ERROR) != (uint32_t)0UL)
 8021c84:	f013 0210 	ands.w	r2, r3, #16
 8021c88:	d01d      	beq.n	8021cc6 <XMC_DMA_IRQHandler+0x56>
 * \par
 * The function returns error interrupt status. <br>
 */
__STATIC_INLINE uint32_t XMC_DMA_GetChannelsErrorStatus(XMC_DMA_t *const dma)
{
  return (dma->STATUSCHEV[8]);
 8021c8a:	f8d0 1308 	ldr.w	r1, [r0, #776]	; 0x308
  {
    event = XMC_DMA_GetChannelsErrorStatus(dma);
    while (event != 0)
 8021c8e:	b1c1      	cbz	r1, 8021cc2 <XMC_DMA_IRQHandler+0x52>
    {
      mask = (uint32_t)1U << channel;
      if ((event & mask) != 0)
 8021c90:	07cb      	lsls	r3, r1, #31
 8021c92:	f100 8097 	bmi.w	8021dc4 <XMC_DMA_IRQHandler+0x154>
 8021c96:	2301      	movs	r3, #1
  if ((event & (uint32_t)XMC_DMA_CH_EVENT_ERROR) != (uint32_t)0UL)
  {
    event = XMC_DMA_GetChannelsErrorStatus(dma);
    while (event != 0)
    {
      mask = (uint32_t)1U << channel;
 8021c98:	461c      	mov	r4, r3
 8021c9a:	e000      	b.n	8021c9e <XMC_DMA_IRQHandler+0x2e>
          event_handler(XMC_DMA_CH_EVENT_ERROR);
        }
       
        break;
      }
      ++channel;
 8021c9c:	3301      	adds	r3, #1
  if ((event & (uint32_t)XMC_DMA_CH_EVENT_ERROR) != (uint32_t)0UL)
  {
    event = XMC_DMA_GetChannelsErrorStatus(dma);
    while (event != 0)
    {
      mask = (uint32_t)1U << channel;
 8021c9e:	fa04 f203 	lsl.w	r2, r4, r3
      if ((event & mask) != 0)
 8021ca2:	420a      	tst	r2, r1
 8021ca4:	d0fa      	beq.n	8021c9c <XMC_DMA_IRQHandler+0x2c>
 8021ca6:	009a      	lsls	r2, r3, #2
      {
        XMC_DMA_CH_ClearEventStatus(dma, (uint8_t)channel, (uint32_t)XMC_DMA_CH_EVENT_ERROR);

        /* Call user callback to handle event */
        event_handler = dma_event_handlers[channel];
 8021ca8:	58a9      	ldr	r1, [r5, r2]

  for(event_idx = 0UL; event_idx < DMA_EVENT_MAX; ++event_idx)
  {
    if (event & (uint32_t)((uint32_t)0x1UL << event_idx))
    {
      dma->CLEARCHEV[event_idx * 2UL] = ((uint32_t)0x1UL << channel);
 8021caa:	b2db      	uxtb	r3, r3
 8021cac:	2201      	movs	r2, #1
 8021cae:	fa02 f303 	lsl.w	r3, r2, r3
 8021cb2:	f8c0 3358 	str.w	r3, [r0, #856]	; 0x358
      {
        XMC_DMA_CH_ClearEventStatus(dma, (uint8_t)channel, (uint32_t)XMC_DMA_CH_EVENT_ERROR);

        /* Call user callback to handle event */
        event_handler = dma_event_handlers[channel];
        if (event_handler != NULL)
 8021cb6:	b121      	cbz	r1, 8021cc2 <XMC_DMA_IRQHandler+0x52>
        {
          event_handler(XMC_DMA_CH_EVENT_ERROR);
 8021cb8:	2010      	movs	r0, #16
  else
  {
    /* no active interrupt was found? */
  }

}
 8021cba:	bc30      	pop	{r4, r5}

        /* Call user callback to handle event */
        event_handler = dma_event_handlers[channel];
        if (event_handler != NULL)
        {
          event_handler(XMC_DMA_CH_EVENT_ERROR);
 8021cbc:	4708      	bx	r1
        break;
      }
      ++channel;
    }
  }
  else if ((event & (uint32_t)XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE) != (uint32_t)0UL)
 8021cbe:	071a      	lsls	r2, r3, #28
 8021cc0:	d465      	bmi.n	8021d8e <XMC_DMA_IRQHandler+0x11e>
  else
  {
    /* no active interrupt was found? */
  }

}
 8021cc2:	bc30      	pop	{r4, r5}
 8021cc4:	4770      	bx	lr
        break;
      }
      ++channel;
    }
  }
  else if ((event & (uint32_t)XMC_DMA_CH_EVENT_TRANSFER_COMPLETE) != (uint32_t)0UL)
 8021cc6:	f013 0401 	ands.w	r4, r3, #1
 8021cca:	d020      	beq.n	8021d0e <XMC_DMA_IRQHandler+0x9e>
 * \par
 * The function returns GPDMA transfer complete interrupt status. <br>
 */
__STATIC_INLINE uint32_t XMC_DMA_GetChannelsTransferCompleteStatus(XMC_DMA_t *const dma)
{
  return (dma->STATUSCHEV[0]);
 8021ccc:	f8d0 12e8 	ldr.w	r1, [r0, #744]	; 0x2e8
  {
    event = XMC_DMA_GetChannelsTransferCompleteStatus(dma);
    while (event != 0)
 8021cd0:	2900      	cmp	r1, #0
 8021cd2:	d0f6      	beq.n	8021cc2 <XMC_DMA_IRQHandler+0x52>
    {
      mask = (uint32_t)1U << channel;
      if (event & mask)
 8021cd4:	07cc      	lsls	r4, r1, #31
 8021cd6:	d478      	bmi.n	8021dca <XMC_DMA_IRQHandler+0x15a>
 8021cd8:	2301      	movs	r3, #1
  else if ((event & (uint32_t)XMC_DMA_CH_EVENT_TRANSFER_COMPLETE) != (uint32_t)0UL)
  {
    event = XMC_DMA_GetChannelsTransferCompleteStatus(dma);
    while (event != 0)
    {
      mask = (uint32_t)1U << channel;
 8021cda:	461c      	mov	r4, r3
 8021cdc:	e000      	b.n	8021ce0 <XMC_DMA_IRQHandler+0x70>
          event_handler(XMC_DMA_CH_EVENT_TRANSFER_COMPLETE);
        }
																	  
        break;
      }
      ++channel;
 8021cde:	3301      	adds	r3, #1
  else if ((event & (uint32_t)XMC_DMA_CH_EVENT_TRANSFER_COMPLETE) != (uint32_t)0UL)
  {
    event = XMC_DMA_GetChannelsTransferCompleteStatus(dma);
    while (event != 0)
    {
      mask = (uint32_t)1U << channel;
 8021ce0:	fa04 f203 	lsl.w	r2, r4, r3
      if (event & mask)
 8021ce4:	420a      	tst	r2, r1
 8021ce6:	d0fa      	beq.n	8021cde <XMC_DMA_IRQHandler+0x6e>
 8021ce8:	009a      	lsls	r2, r3, #2
                                                                      (uint32_t)XMC_DMA_CH_EVENT_BLOCK_TRANSFER_COMPLETE | 
                                                                      (uint32_t)XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE | 
                                                                      (uint32_t)XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE));

        /* Call user callback to handle event */
        event_handler = dma_event_handlers[channel];
 8021cea:	58aa      	ldr	r2, [r5, r2]

  for(event_idx = 0UL; event_idx < DMA_EVENT_MAX; ++event_idx)
  {
    if (event & (uint32_t)((uint32_t)0x1UL << event_idx))
    {
      dma->CLEARCHEV[event_idx * 2UL] = ((uint32_t)0x1UL << channel);
 8021cec:	b2db      	uxtb	r3, r3
 8021cee:	2101      	movs	r1, #1
 8021cf0:	fa01 f303 	lsl.w	r3, r1, r3
 8021cf4:	f8c0 3338 	str.w	r3, [r0, #824]	; 0x338
 8021cf8:	f8c0 3340 	str.w	r3, [r0, #832]	; 0x340
 8021cfc:	f8c0 3348 	str.w	r3, [r0, #840]	; 0x348
 8021d00:	f8c0 3350 	str.w	r3, [r0, #848]	; 0x350
                                                                      (uint32_t)XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE | 
                                                                      (uint32_t)XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE));

        /* Call user callback to handle event */
        event_handler = dma_event_handlers[channel];
        if (event_handler != NULL)
 8021d04:	2a00      	cmp	r2, #0
 8021d06:	d0dc      	beq.n	8021cc2 <XMC_DMA_IRQHandler+0x52>
        {
          event_handler(XMC_DMA_CH_EVENT_TRANSFER_COMPLETE);
 8021d08:	4608      	mov	r0, r1
  else
  {
    /* no active interrupt was found? */
  }

}
 8021d0a:	bc30      	pop	{r4, r5}

        /* Call user callback to handle event */
        event_handler = dma_event_handlers[channel];
        if (event_handler != NULL)
        {
          event_handler(XMC_DMA_CH_EVENT_TRANSFER_COMPLETE);
 8021d0c:	4710      	bx	r2
        break;
      }
      ++channel;
    }
  }
  else if ((event & (uint32_t)XMC_DMA_CH_EVENT_BLOCK_TRANSFER_COMPLETE) != (uint32_t)0UL)
 8021d0e:	f013 0202 	ands.w	r2, r3, #2
 8021d12:	d11d      	bne.n	8021d50 <XMC_DMA_IRQHandler+0xe0>
        break;
      }
      ++channel;
    }
  }
  else if ((event & (uint32_t)XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE) != (uint32_t)0UL)
 8021d14:	f013 0404 	ands.w	r4, r3, #4
 8021d18:	d0d1      	beq.n	8021cbe <XMC_DMA_IRQHandler+0x4e>
 * If the source peripheral is memory, the source transaction complete interrupt is
 * ignored.
 */
__STATIC_INLINE uint32_t XMC_DMA_GetChannelsSourceTransactionCompleteStatus(XMC_DMA_t *const dma)
{
  return (dma->STATUSCHEV[4]);
 8021d1a:	f8d0 12f8 	ldr.w	r1, [r0, #760]	; 0x2f8
  {
    event = XMC_DMA_GetChannelsSourceTransactionCompleteStatus(dma);
    while (event != 0)
 8021d1e:	2900      	cmp	r1, #0
 8021d20:	d0cf      	beq.n	8021cc2 <XMC_DMA_IRQHandler+0x52>
    {
      mask = (uint32_t)1U << channel;
      if (event & mask)
 8021d22:	07cc      	lsls	r4, r1, #31
 8021d24:	d455      	bmi.n	8021dd2 <XMC_DMA_IRQHandler+0x162>
 8021d26:	2301      	movs	r3, #1
  else if ((event & (uint32_t)XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE) != (uint32_t)0UL)
  {
    event = XMC_DMA_GetChannelsSourceTransactionCompleteStatus(dma);
    while (event != 0)
    {
      mask = (uint32_t)1U << channel;
 8021d28:	461c      	mov	r4, r3
 8021d2a:	e000      	b.n	8021d2e <XMC_DMA_IRQHandler+0xbe>
          event_handler(XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE);
        }
        
        break;
      }
      ++channel;
 8021d2c:	3301      	adds	r3, #1
  else if ((event & (uint32_t)XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE) != (uint32_t)0UL)
  {
    event = XMC_DMA_GetChannelsSourceTransactionCompleteStatus(dma);
    while (event != 0)
    {
      mask = (uint32_t)1U << channel;
 8021d2e:	fa04 f203 	lsl.w	r2, r4, r3
      if (event & mask)
 8021d32:	420a      	tst	r2, r1
 8021d34:	d0fa      	beq.n	8021d2c <XMC_DMA_IRQHandler+0xbc>
 8021d36:	009a      	lsls	r2, r3, #2
      {
        XMC_DMA_CH_ClearEventStatus(dma, (uint8_t)channel, (uint32_t)XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE);

        /* Call user callback to handle event */
        event_handler = dma_event_handlers[channel];
 8021d38:	58a9      	ldr	r1, [r5, r2]

  for(event_idx = 0UL; event_idx < DMA_EVENT_MAX; ++event_idx)
  {
    if (event & (uint32_t)((uint32_t)0x1UL << event_idx))
    {
      dma->CLEARCHEV[event_idx * 2UL] = ((uint32_t)0x1UL << channel);
 8021d3a:	b2db      	uxtb	r3, r3
 8021d3c:	2201      	movs	r2, #1
 8021d3e:	fa02 f303 	lsl.w	r3, r2, r3
 8021d42:	f8c0 3348 	str.w	r3, [r0, #840]	; 0x348
      {
        XMC_DMA_CH_ClearEventStatus(dma, (uint8_t)channel, (uint32_t)XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE);

        /* Call user callback to handle event */
        event_handler = dma_event_handlers[channel];
        if (event_handler != NULL)
 8021d46:	2900      	cmp	r1, #0
 8021d48:	d0bb      	beq.n	8021cc2 <XMC_DMA_IRQHandler+0x52>
        {
          event_handler(XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE);
 8021d4a:	2004      	movs	r0, #4
  else
  {
    /* no active interrupt was found? */
  }

}
 8021d4c:	bc30      	pop	{r4, r5}

        /* Call user callback to handle event */
        event_handler = dma_event_handlers[channel];
        if (event_handler != NULL)
        {
          event_handler(XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE);
 8021d4e:	4708      	bx	r1
 * \par
 * The function returns GPDMA block transfer complete interrupt status. <br>
 */
__STATIC_INLINE uint32_t XMC_DMA_GetChannelsBlockCompleteStatus(XMC_DMA_t *const dma)
{
  return (dma->STATUSCHEV[2]);
 8021d50:	f8d0 12f0 	ldr.w	r1, [r0, #752]	; 0x2f0
    }
  }
  else if ((event & (uint32_t)XMC_DMA_CH_EVENT_BLOCK_TRANSFER_COMPLETE) != (uint32_t)0UL)
  {
    event = XMC_DMA_GetChannelsBlockCompleteStatus(dma);
    while (event != 0)
 8021d54:	2900      	cmp	r1, #0
 8021d56:	d0b4      	beq.n	8021cc2 <XMC_DMA_IRQHandler+0x52>
    {
      mask = (uint32_t)1U << channel;
      if (event & mask)
 8021d58:	07cb      	lsls	r3, r1, #31
 8021d5a:	d438      	bmi.n	8021dce <XMC_DMA_IRQHandler+0x15e>
 8021d5c:	2301      	movs	r3, #1
  else if ((event & (uint32_t)XMC_DMA_CH_EVENT_BLOCK_TRANSFER_COMPLETE) != (uint32_t)0UL)
  {
    event = XMC_DMA_GetChannelsBlockCompleteStatus(dma);
    while (event != 0)
    {
      mask = (uint32_t)1U << channel;
 8021d5e:	461c      	mov	r4, r3
 8021d60:	e000      	b.n	8021d64 <XMC_DMA_IRQHandler+0xf4>
          event_handler(XMC_DMA_CH_EVENT_BLOCK_TRANSFER_COMPLETE);
        }

        break;
      }
      ++channel;
 8021d62:	3301      	adds	r3, #1
  else if ((event & (uint32_t)XMC_DMA_CH_EVENT_BLOCK_TRANSFER_COMPLETE) != (uint32_t)0UL)
  {
    event = XMC_DMA_GetChannelsBlockCompleteStatus(dma);
    while (event != 0)
    {
      mask = (uint32_t)1U << channel;
 8021d64:	fa04 f203 	lsl.w	r2, r4, r3
      if (event & mask)
 8021d68:	420a      	tst	r2, r1
 8021d6a:	d0fa      	beq.n	8021d62 <XMC_DMA_IRQHandler+0xf2>
 8021d6c:	009c      	lsls	r4, r3, #2
        XMC_DMA_CH_ClearEventStatus(dma, (uint8_t)channel, (uint32_t)((uint32_t)XMC_DMA_CH_EVENT_BLOCK_TRANSFER_COMPLETE |
                                                                      (uint32_t)XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE | 
                                                                      (uint32_t)XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE));

        /* Call user callback to handle event */
        event_handler = dma_event_handlers[channel];
 8021d6e:	5929      	ldr	r1, [r5, r4]

  for(event_idx = 0UL; event_idx < DMA_EVENT_MAX; ++event_idx)
  {
    if (event & (uint32_t)((uint32_t)0x1UL << event_idx))
    {
      dma->CLEARCHEV[event_idx * 2UL] = ((uint32_t)0x1UL << channel);
 8021d70:	b2db      	uxtb	r3, r3
 8021d72:	2201      	movs	r2, #1
 8021d74:	fa02 f303 	lsl.w	r3, r2, r3
 8021d78:	f8c0 3340 	str.w	r3, [r0, #832]	; 0x340
 8021d7c:	f8c0 3348 	str.w	r3, [r0, #840]	; 0x348
 8021d80:	f8c0 3350 	str.w	r3, [r0, #848]	; 0x350
                                                                      (uint32_t)XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE | 
                                                                      (uint32_t)XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE));

        /* Call user callback to handle event */
        event_handler = dma_event_handlers[channel];
        if (event_handler != NULL)
 8021d84:	2900      	cmp	r1, #0
 8021d86:	d09c      	beq.n	8021cc2 <XMC_DMA_IRQHandler+0x52>
        {
          event_handler(XMC_DMA_CH_EVENT_BLOCK_TRANSFER_COMPLETE);
 8021d88:	2002      	movs	r0, #2
  else
  {
    /* no active interrupt was found? */
  }

}
 8021d8a:	bc30      	pop	{r4, r5}

        /* Call user callback to handle event */
        event_handler = dma_event_handlers[channel];
        if (event_handler != NULL)
        {
          event_handler(XMC_DMA_CH_EVENT_BLOCK_TRANSFER_COMPLETE);
 8021d8c:	4708      	bx	r1
 * If the destination peripheral is memory, the destination transaction complete
 * interrupt is ignored.
 */
__STATIC_INLINE uint32_t XMC_DMA_GetChannelsDestinationTransactionCompleteStatus(XMC_DMA_t *const dma)
{
  return (dma->STATUSCHEV[6]);
 8021d8e:	f8d0 1300 	ldr.w	r1, [r0, #768]	; 0x300
    }
  }
  else if ((event & (uint32_t)XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE) != (uint32_t)0UL)
  {
    event = XMC_DMA_GetChannelsDestinationTransactionCompleteStatus(dma);
    while (event != 0)
 8021d92:	2900      	cmp	r1, #0
 8021d94:	d095      	beq.n	8021cc2 <XMC_DMA_IRQHandler+0x52>
    {
      mask = (uint32_t)1U << channel;
      if (event & mask)
 8021d96:	07cb      	lsls	r3, r1, #31
 8021d98:	d41d      	bmi.n	8021dd6 <XMC_DMA_IRQHandler+0x166>
 8021d9a:	2301      	movs	r3, #1
  else if ((event & (uint32_t)XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE) != (uint32_t)0UL)
  {
    event = XMC_DMA_GetChannelsDestinationTransactionCompleteStatus(dma);
    while (event != 0)
    {
      mask = (uint32_t)1U << channel;
 8021d9c:	461c      	mov	r4, r3
 8021d9e:	e000      	b.n	8021da2 <XMC_DMA_IRQHandler+0x132>
          event_handler(XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE);
        }      

        break;
      }
      ++channel;
 8021da0:	3301      	adds	r3, #1
  else if ((event & (uint32_t)XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE) != (uint32_t)0UL)
  {
    event = XMC_DMA_GetChannelsDestinationTransactionCompleteStatus(dma);
    while (event != 0)
    {
      mask = (uint32_t)1U << channel;
 8021da2:	fa04 f203 	lsl.w	r2, r4, r3
      if (event & mask)
 8021da6:	420a      	tst	r2, r1
 8021da8:	d0fa      	beq.n	8021da0 <XMC_DMA_IRQHandler+0x130>
 8021daa:	009c      	lsls	r4, r3, #2

  for(event_idx = 0UL; event_idx < DMA_EVENT_MAX; ++event_idx)
  {
    if (event & (uint32_t)((uint32_t)0x1UL << event_idx))
    {
      dma->CLEARCHEV[event_idx * 2UL] = ((uint32_t)0x1UL << channel);
 8021dac:	b2db      	uxtb	r3, r3
      if (event & mask)
      {
        XMC_DMA_CH_ClearEventStatus(dma, (uint8_t)channel, (uint32_t)XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE);

        /* Call user callback to handle event */
        event_handler = dma_event_handlers[channel];
 8021dae:	5929      	ldr	r1, [r5, r4]

  for(event_idx = 0UL; event_idx < DMA_EVENT_MAX; ++event_idx)
  {
    if (event & (uint32_t)((uint32_t)0x1UL << event_idx))
    {
      dma->CLEARCHEV[event_idx * 2UL] = ((uint32_t)0x1UL << channel);
 8021db0:	2201      	movs	r2, #1
 8021db2:	fa02 f303 	lsl.w	r3, r2, r3
 8021db6:	f8c0 3350 	str.w	r3, [r0, #848]	; 0x350
      {
        XMC_DMA_CH_ClearEventStatus(dma, (uint8_t)channel, (uint32_t)XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE);

        /* Call user callback to handle event */
        event_handler = dma_event_handlers[channel];
        if (event_handler != NULL)
 8021dba:	2900      	cmp	r1, #0
 8021dbc:	d081      	beq.n	8021cc2 <XMC_DMA_IRQHandler+0x52>
        {
          event_handler(XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE);
 8021dbe:	2008      	movs	r0, #8
  else
  {
    /* no active interrupt was found? */
  }

}
 8021dc0:	bc30      	pop	{r4, r5}

        /* Call user callback to handle event */
        event_handler = dma_event_handlers[channel];
        if (event_handler != NULL)
        {
          event_handler(XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE);
 8021dc2:	4708      	bx	r1
  {
    event = XMC_DMA_GetChannelsErrorStatus(dma);
    while (event != 0)
    {
      mask = (uint32_t)1U << channel;
      if ((event & mask) != 0)
 8021dc4:	2200      	movs	r2, #0
    dma_event_handlers = dma1_event_handlers;
  }
#endif
  
  event = XMC_DMA_GetEventStatus(dma);
  channel = 0;
 8021dc6:	4613      	mov	r3, r2
 8021dc8:	e76e      	b.n	8021ca8 <XMC_DMA_IRQHandler+0x38>
 8021dca:	4613      	mov	r3, r2
 8021dcc:	e78d      	b.n	8021cea <XMC_DMA_IRQHandler+0x7a>
 8021dce:	4623      	mov	r3, r4
 8021dd0:	e7cd      	b.n	8021d6e <XMC_DMA_IRQHandler+0xfe>
 8021dd2:	4613      	mov	r3, r2
 8021dd4:	e7b0      	b.n	8021d38 <XMC_DMA_IRQHandler+0xc8>
 8021dd6:	4623      	mov	r3, r4
 8021dd8:	e7e8      	b.n	8021dac <XMC_DMA_IRQHandler+0x13c>
 8021dda:	bf00      	nop
 8021ddc:	1fff0080 	.word	0x1fff0080
 8021de0:	1fff0060 	.word	0x1fff0060
 8021de4:	50014000 	.word	0x50014000

08021de8 <XMC_GPIO_SetMode>:
/*******************************************************************************
 * API IMPLEMENTATION
 *******************************************************************************/

void XMC_GPIO_SetMode(XMC_GPIO_PORT_t *const port, const uint8_t pin, const XMC_GPIO_MODE_t mode)
{
 8021de8:	f001 03fc 	and.w	r3, r1, #252	; 0xfc
 8021dec:	4418      	add	r0, r3
  XMC_ASSERT("XMC_GPIO_SetMode: Invalid port", XMC_GPIO_CHECK_PORT(port));
  XMC_ASSERT("XMC_GPIO_SetMode: Invalid mode", XMC_GPIO_IsModeValid(mode));

  port->IOCR[(uint32_t)pin >> 2U] &= ~(uint32_t)((uint32_t)PORT_IOCR_PC_Msk << ((uint32_t)PORT_IOCR_PC_Size * ((uint32_t)pin & 0x3U)));
 8021dee:	f001 0103 	and.w	r1, r1, #3
/*******************************************************************************
 * API IMPLEMENTATION
 *******************************************************************************/

void XMC_GPIO_SetMode(XMC_GPIO_PORT_t *const port, const uint8_t pin, const XMC_GPIO_MODE_t mode)
{
 8021df2:	b410      	push	{r4}
  XMC_ASSERT("XMC_GPIO_SetMode: Invalid port", XMC_GPIO_CHECK_PORT(port));
  XMC_ASSERT("XMC_GPIO_SetMode: Invalid mode", XMC_GPIO_IsModeValid(mode));

  port->IOCR[(uint32_t)pin >> 2U] &= ~(uint32_t)((uint32_t)PORT_IOCR_PC_Msk << ((uint32_t)PORT_IOCR_PC_Size * ((uint32_t)pin & 0x3U)));
 8021df4:	00c9      	lsls	r1, r1, #3
 8021df6:	6904      	ldr	r4, [r0, #16]
 8021df8:	23f8      	movs	r3, #248	; 0xf8
 8021dfa:	408b      	lsls	r3, r1
 8021dfc:	ea24 0303 	bic.w	r3, r4, r3
 8021e00:	6103      	str	r3, [r0, #16]
  port->IOCR[(uint32_t)pin >> 2U] |= (uint32_t)mode << ((uint32_t)PORT_IOCR_PC_Size * ((uint32_t)pin & 0x3U));
 8021e02:	6903      	ldr	r3, [r0, #16]
}
 8021e04:	f85d 4b04 	ldr.w	r4, [sp], #4
{
  XMC_ASSERT("XMC_GPIO_SetMode: Invalid port", XMC_GPIO_CHECK_PORT(port));
  XMC_ASSERT("XMC_GPIO_SetMode: Invalid mode", XMC_GPIO_IsModeValid(mode));

  port->IOCR[(uint32_t)pin >> 2U] &= ~(uint32_t)((uint32_t)PORT_IOCR_PC_Msk << ((uint32_t)PORT_IOCR_PC_Size * ((uint32_t)pin & 0x3U)));
  port->IOCR[(uint32_t)pin >> 2U] |= (uint32_t)mode << ((uint32_t)PORT_IOCR_PC_Size * ((uint32_t)pin & 0x3U));
 8021e08:	408a      	lsls	r2, r1
 8021e0a:	4313      	orrs	r3, r2
 8021e0c:	6103      	str	r3, [r0, #16]
}
 8021e0e:	4770      	bx	lr

08021e10 <XMC_GPIO_SetHardwareControl>:

void XMC_GPIO_SetHardwareControl(XMC_GPIO_PORT_t *const port, const uint8_t pin, const XMC_GPIO_HWCTRL_t hwctrl)
{
 8021e10:	b410      	push	{r4}
  XMC_ASSERT("XMC_GPIO_SetHardwareControl: Invalid port", XMC_GPIO_CHECK_PORT(port));
  XMC_ASSERT("XMC_GPIO_SetHardwareControl: Invalid hwctrl", XMC_GPIO_CHECK_HWCTRL(hwctrl));

  port->HWSEL &= ~(uint32_t)((uint32_t)PORT_HWSEL_Msk << ((uint32_t)pin << 1U));
 8021e12:	0049      	lsls	r1, r1, #1
 8021e14:	6f44      	ldr	r4, [r0, #116]	; 0x74
 8021e16:	2303      	movs	r3, #3
 8021e18:	408b      	lsls	r3, r1
 8021e1a:	ea24 0303 	bic.w	r3, r4, r3
 8021e1e:	6743      	str	r3, [r0, #116]	; 0x74
  port->HWSEL |= (uint32_t)hwctrl << ((uint32_t)pin << 1U);
 8021e20:	6f43      	ldr	r3, [r0, #116]	; 0x74
}
 8021e22:	f85d 4b04 	ldr.w	r4, [sp], #4
{
  XMC_ASSERT("XMC_GPIO_SetHardwareControl: Invalid port", XMC_GPIO_CHECK_PORT(port));
  XMC_ASSERT("XMC_GPIO_SetHardwareControl: Invalid hwctrl", XMC_GPIO_CHECK_HWCTRL(hwctrl));

  port->HWSEL &= ~(uint32_t)((uint32_t)PORT_HWSEL_Msk << ((uint32_t)pin << 1U));
  port->HWSEL |= (uint32_t)hwctrl << ((uint32_t)pin << 1U);
 8021e26:	408a      	lsls	r2, r1
 8021e28:	4313      	orrs	r3, r2
 8021e2a:	6743      	str	r3, [r0, #116]	; 0x74
}
 8021e2c:	4770      	bx	lr
 8021e2e:	bf00      	nop

08021e30 <XMC_I2C_CH_Init>:
/*********************************************************************************************************************
 * API IMPLEMENTATION
 *********************************************************************************************************************/
/* Initializes the USIC channel by setting the data format, slave address, baudrate, transfer buffer */
void XMC_I2C_CH_Init(XMC_USIC_CH_t *const channel, const XMC_I2C_CH_CONFIG_t *const config)
{
 8021e30:	b538      	push	{r3, r4, r5, lr}
 8021e32:	460d      	mov	r5, r1
 8021e34:	4604      	mov	r4, r0
  XMC_USIC_CH_Enable(channel);
 8021e36:	f001 fa43 	bl	80232c0 <XMC_USIC_CH_Enable>
                  ((uint32_t)WORDLENGTH << (uint32_t)USIC_CH_SCTR_WLE_Pos) | /* 8 data bits */
                  USIC_CH_SCTR_FLE_Msk |           /* unlimited data flow */
                  USIC_CH_SCTR_SDIR_Msk |          /* MSB shifted first */
                  USIC_CH_SCTR_PDL_Msk;            /* Passive Data Level */

  XMC_I2C_CH_SetSlaveAddress(channel, config->address);
 8021e3a:	88ab      	ldrh	r3, [r5, #4]
void XMC_I2C_CH_Init(XMC_USIC_CH_t *const channel, const XMC_I2C_CH_CONFIG_t *const config)
{
  XMC_USIC_CH_Enable(channel);
  
  /* Data format configuration */
  channel->SCTR = ((uint32_t)TRANSMISSION_MODE << (uint32_t)USIC_CH_SCTR_TRM_Pos) | /* Transmision mode */
 8021e3c:	4a18      	ldr	r2, [pc, #96]	; (8021ea0 <XMC_I2C_CH_Init+0x70>)
 8021e3e:	6362      	str	r2, [r4, #52]	; 0x34
  channel->CCR = 0x0U;
}
/* Sets the slave address */
void XMC_I2C_CH_SetSlaveAddress(XMC_USIC_CH_t *const channel, const uint16_t address)
{
  if ((address & XMC_I2C_10BIT_ADDR_MASK) == XMC_I2C_10BIT_ADDR_GROUP)
 8021e40:	f403 42f8 	and.w	r2, r3, #31744	; 0x7c00
 8021e44:	f5b2 4ff0 	cmp.w	r2, #30720	; 0x7800
 8021e48:	d023      	beq.n	8021e92 <XMC_I2C_CH_Init+0x62>
  {
    channel->PCR_IICMode = (address & 0xffU) | ((address << 1) & 0xfe00U);
  }
  else
  {
    channel->PCR_IICMode = ((uint32_t)address) << XMC_I2C_7BIT_ADDR_Pos;
 8021e4a:	021b      	lsls	r3, r3, #8
 8021e4c:	63e3      	str	r3, [r4, #60]	; 0x3c
                  USIC_CH_SCTR_FLE_Msk |           /* unlimited data flow */
                  USIC_CH_SCTR_SDIR_Msk |          /* MSB shifted first */
                  USIC_CH_SCTR_PDL_Msk;            /* Passive Data Level */

  XMC_I2C_CH_SetSlaveAddress(channel, config->address);
  (void)XMC_I2C_CH_SetBaudrate(channel, config->baudrate);
 8021e4e:	6829      	ldr	r1, [r5, #0]
{
  XMC_I2C_CH_STATUS_t status;
  
  status = XMC_I2C_CH_STATUS_ERROR;
  
  if (rate <= (uint32_t)XMC_I2C_CH_MAX_SPEED_STANDARD)
 8021e50:	4b14      	ldr	r3, [pc, #80]	; (8021ea4 <XMC_I2C_CH_Init+0x74>)
 8021e52:	4299      	cmp	r1, r3
 8021e54:	d914      	bls.n	8021e80 <XMC_I2C_CH_Init+0x50>
    if (XMC_USIC_CH_SetBaudrate(channel, rate, (uint32_t)XMC_I2C_CH_CLOCK_OVERSAMPLING_STANDARD) == XMC_USIC_CH_STATUS_OK)
    {
      status = XMC_I2C_CH_STATUS_OK;
    }
  }
  else if (rate <= (uint32_t)XMC_I2C_CH_MAX_SPEED_FAST)
 8021e56:	4b14      	ldr	r3, [pc, #80]	; (8021ea8 <XMC_I2C_CH_Init+0x78>)
 8021e58:	4299      	cmp	r1, r3
 8021e5a:	d908      	bls.n	8021e6e <XMC_I2C_CH_Init+0x3e>

  XMC_I2C_CH_SetSlaveAddress(channel, config->address);
  (void)XMC_I2C_CH_SetBaudrate(channel, config->baudrate);
    
  /* Enable transfer buffer */
  channel->TCSR = ((uint32_t)SET_TDV << (uint32_t)USIC_CH_TCSR_TDEN_Pos) | USIC_CH_TCSR_TDSSM_Msk;
 8021e5c:	f44f 61a0 	mov.w	r1, #1280	; 0x500

  /* Clear status flags */
  channel->PSCR = 0xFFFFFFFFU;
 8021e60:	f04f 32ff 	mov.w	r2, #4294967295

  /* Disable parity generation */
  channel->CCR = 0x0U;
 8021e64:	2300      	movs	r3, #0

  XMC_I2C_CH_SetSlaveAddress(channel, config->address);
  (void)XMC_I2C_CH_SetBaudrate(channel, config->baudrate);
    
  /* Enable transfer buffer */
  channel->TCSR = ((uint32_t)SET_TDV << (uint32_t)USIC_CH_TCSR_TDEN_Pos) | USIC_CH_TCSR_TDSSM_Msk;
 8021e66:	63a1      	str	r1, [r4, #56]	; 0x38

  /* Clear status flags */
  channel->PSCR = 0xFFFFFFFFU;
 8021e68:	64e2      	str	r2, [r4, #76]	; 0x4c

  /* Disable parity generation */
  channel->CCR = 0x0U;
 8021e6a:	6423      	str	r3, [r4, #64]	; 0x40
 8021e6c:	bd38      	pop	{r3, r4, r5, pc}
      status = XMC_I2C_CH_STATUS_OK;
    }
  }
  else if (rate <= (uint32_t)XMC_I2C_CH_MAX_SPEED_FAST)
  {
    channel->PCR_IICMode |= (uint32_t)USIC_CH_PCR_IICMode_STIM_Msk;
 8021e6e:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8021e70:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8021e74:	63e3      	str	r3, [r4, #60]	; 0x3c
    if (XMC_USIC_CH_SetBaudrate(channel, rate, (uint32_t)XMC_I2C_CH_CLOCK_OVERSAMPLING_FAST) == XMC_USIC_CH_STATUS_OK)
 8021e76:	4620      	mov	r0, r4
 8021e78:	2219      	movs	r2, #25
 8021e7a:	f001 fa63 	bl	8023344 <XMC_USIC_CH_SetBaudrate>
 8021e7e:	e7ed      	b.n	8021e5c <XMC_I2C_CH_Init+0x2c>
  
  status = XMC_I2C_CH_STATUS_ERROR;
  
  if (rate <= (uint32_t)XMC_I2C_CH_MAX_SPEED_STANDARD)
  {
		channel->PCR_IICMode &= (uint32_t)~USIC_CH_PCR_IICMode_STIM_Msk;
 8021e80:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8021e82:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
 8021e86:	63e3      	str	r3, [r4, #60]	; 0x3c
    if (XMC_USIC_CH_SetBaudrate(channel, rate, (uint32_t)XMC_I2C_CH_CLOCK_OVERSAMPLING_STANDARD) == XMC_USIC_CH_STATUS_OK)
 8021e88:	4620      	mov	r0, r4
 8021e8a:	220a      	movs	r2, #10
 8021e8c:	f001 fa5a 	bl	8023344 <XMC_USIC_CH_SetBaudrate>
 8021e90:	e7e4      	b.n	8021e5c <XMC_I2C_CH_Init+0x2c>
/* Sets the slave address */
void XMC_I2C_CH_SetSlaveAddress(XMC_USIC_CH_t *const channel, const uint16_t address)
{
  if ((address & XMC_I2C_10BIT_ADDR_MASK) == XMC_I2C_10BIT_ADDR_GROUP)
  {
    channel->PCR_IICMode = (address & 0xffU) | ((address << 1) & 0xfe00U);
 8021e92:	005a      	lsls	r2, r3, #1
 8021e94:	f402 427e 	and.w	r2, r2, #65024	; 0xfe00
 8021e98:	b2db      	uxtb	r3, r3
 8021e9a:	4313      	orrs	r3, r2
 8021e9c:	63e3      	str	r3, [r4, #60]	; 0x3c
 8021e9e:	e7d6      	b.n	8021e4e <XMC_I2C_CH_Init+0x1e>
 8021ea0:	073f0303 	.word	0x073f0303
 8021ea4:	000186a0 	.word	0x000186a0
 8021ea8:	00061a80 	.word	0x00061a80

08021eac <XMC_I2C_CH_MasterStart>:
  {
    temp |= 0x1U;
  }

  /* Check FIFO size */
  if ((channel->TBCTR & USIC_CH_TBCTR_SIZE_Msk) == 0U)
 8021eac:	f8d0 3108 	ldr.w	r3, [r0, #264]	; 0x108
void XMC_I2C_CH_MasterStart(XMC_USIC_CH_t *const channel, const uint16_t addr, const XMC_I2C_CH_CMD_t command)
{
  uint32_t temp;
  
  temp = addr | (uint32_t)XMC_I2C_CH_TDF_MASTER_START;
  if (command == XMC_I2C_CH_CMD_READ)
 8021eb0:	2a01      	cmp	r2, #1
  {
    temp |= 0x1U;
 8021eb2:	f441 6180 	orr.w	r1, r1, #1024	; 0x400
 8021eb6:	bf08      	it	eq
 8021eb8:	f041 0101 	orreq.w	r1, r1, #1
  }

  /* Check FIFO size */
  if ((channel->TBCTR & USIC_CH_TBCTR_SIZE_Msk) == 0U)
 8021ebc:	f013 6fe0 	tst.w	r3, #117440512	; 0x7000000
 8021ec0:	d002      	beq.n	8021ec8 <XMC_I2C_CH_MasterStart+0x1c>

    channel->TBUF[0] = temp;
  }
  else
  {
    channel->IN[0U] = temp;
 8021ec2:	f8c0 1180 	str.w	r1, [r0, #384]	; 0x180
 8021ec6:	4770      	bx	lr
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_SetDataOutputMode() \n\n\n
 */
__STATIC_INLINE XMC_USIC_CH_TBUF_STATUS_t XMC_USIC_CH_GetTransmitBufferStatus(XMC_USIC_CH_t *const channel)
{
  return (XMC_USIC_CH_TBUF_STATUS_t)(channel->TCSR & USIC_CH_TCSR_TDV_Msk);
 8021ec8:	6b83      	ldr	r3, [r0, #56]	; 0x38
  }

  /* Check FIFO size */
  if ((channel->TBCTR & USIC_CH_TBCTR_SIZE_Msk) == 0U)
  {
    while (XMC_USIC_CH_GetTransmitBufferStatus(channel) == XMC_USIC_CH_TBUF_STATUS_BUSY)
 8021eca:	061b      	lsls	r3, r3, #24
 8021ecc:	d4fc      	bmi.n	8021ec8 <XMC_I2C_CH_MasterStart+0x1c>
 * \par<b>Related APIs:</b><br>
 * XMC_I2C_CH_GetStatusFlag()\n\n
 */
__STATIC_INLINE void XMC_I2C_CH_ClearStatusFlag(XMC_USIC_CH_t *const channel, uint32_t flag)
{
  channel->PSCR |= flag;
 8021ece:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 8021ed0:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8021ed4:	64c3      	str	r3, [r0, #76]	; 0x4c
    }

    /* clear PSR_TBIF */
    XMC_I2C_CH_ClearStatusFlag(channel, (uint32_t)XMC_I2C_CH_STATUS_FLAG_TRANSMIT_BUFFER_INDICATION);

    channel->TBUF[0] = temp;
 8021ed6:	f8c0 1080 	str.w	r1, [r0, #128]	; 0x80
 8021eda:	4770      	bx	lr

08021edc <XMC_I2C_CH_MasterRepeatedStart>:
  {
    tmp |= 0x1U;
  }

  /* Check FIFO size */
  if ((channel->TBCTR & USIC_CH_TBCTR_SIZE_Msk) == 0U)
 8021edc:	f8d0 3108 	ldr.w	r3, [r0, #264]	; 0x108
/* Sends master repeated start condition along with read/write command to IN/TBUF register based on FIFO/non-FIFO modes. */
void XMC_I2C_CH_MasterRepeatedStart(XMC_USIC_CH_t *const channel, const uint16_t addr, const XMC_I2C_CH_CMD_t command)
{
  uint32_t tmp;
  tmp = addr | (uint32_t)XMC_I2C_CH_TDF_MASTER_RESTART;
  if (command == XMC_I2C_CH_CMD_READ)
 8021ee0:	2a01      	cmp	r2, #1
  {
    tmp |= 0x1U;
 8021ee2:	f441 61a0 	orr.w	r1, r1, #1280	; 0x500
 8021ee6:	bf08      	it	eq
 8021ee8:	f041 0101 	orreq.w	r1, r1, #1
  }

  /* Check FIFO size */
  if ((channel->TBCTR & USIC_CH_TBCTR_SIZE_Msk) == 0U)
 8021eec:	f013 6fe0 	tst.w	r3, #117440512	; 0x7000000
 8021ef0:	d002      	beq.n	8021ef8 <XMC_I2C_CH_MasterRepeatedStart+0x1c>

    channel->TBUF[0] = tmp;
  }
  else
  {
    channel->IN[0U] = tmp;
 8021ef2:	f8c0 1180 	str.w	r1, [r0, #384]	; 0x180
 8021ef6:	4770      	bx	lr
 8021ef8:	6b83      	ldr	r3, [r0, #56]	; 0x38
  }

  /* Check FIFO size */
  if ((channel->TBCTR & USIC_CH_TBCTR_SIZE_Msk) == 0U)
  {  
    while (XMC_USIC_CH_GetTransmitBufferStatus(channel) == XMC_USIC_CH_TBUF_STATUS_BUSY)
 8021efa:	061b      	lsls	r3, r3, #24
 8021efc:	d4fc      	bmi.n	8021ef8 <XMC_I2C_CH_MasterRepeatedStart+0x1c>
 8021efe:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 8021f00:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8021f04:	64c3      	str	r3, [r0, #76]	; 0x4c
    }

    /* clear PSR_TBIF */
    XMC_I2C_CH_ClearStatusFlag(channel, (uint32_t)XMC_I2C_CH_STATUS_FLAG_TRANSMIT_BUFFER_INDICATION);

    channel->TBUF[0] = tmp;
 8021f06:	f8c0 1080 	str.w	r1, [r0, #128]	; 0x80
 8021f0a:	4770      	bx	lr

08021f0c <XMC_I2C_CH_MasterStop>:

/* Sends master stop command to IN/TBUF register based on FIFO/non-FIFO modes. */
void XMC_I2C_CH_MasterStop(XMC_USIC_CH_t *const channel)
{
  /* Check FIFO size */
  if ((channel->TBCTR & USIC_CH_TBCTR_SIZE_Msk) == 0U)
 8021f0c:	f8d0 3108 	ldr.w	r3, [r0, #264]	; 0x108
 8021f10:	f013 6fe0 	tst.w	r3, #117440512	; 0x7000000
 8021f14:	d004      	beq.n	8021f20 <XMC_I2C_CH_MasterStop+0x14>

    channel->TBUF[0] = (uint32_t)XMC_I2C_CH_TDF_MASTER_STOP;
  }
  else
  {
    channel->IN[0U] = (uint32_t)XMC_I2C_CH_TDF_MASTER_STOP;
 8021f16:	f44f 63c0 	mov.w	r3, #1536	; 0x600
 8021f1a:	f8c0 3180 	str.w	r3, [r0, #384]	; 0x180
 8021f1e:	4770      	bx	lr
 8021f20:	6b83      	ldr	r3, [r0, #56]	; 0x38
void XMC_I2C_CH_MasterStop(XMC_USIC_CH_t *const channel)
{
  /* Check FIFO size */
  if ((channel->TBCTR & USIC_CH_TBCTR_SIZE_Msk) == 0U)
  {
    while (XMC_USIC_CH_GetTransmitBufferStatus(channel) == XMC_USIC_CH_TBUF_STATUS_BUSY)
 8021f22:	061b      	lsls	r3, r3, #24
 8021f24:	d4fc      	bmi.n	8021f20 <XMC_I2C_CH_MasterStop+0x14>
 8021f26:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
    }

    /* clear PSR_TBIF */
    XMC_I2C_CH_ClearStatusFlag(channel, (uint32_t)XMC_I2C_CH_STATUS_FLAG_TRANSMIT_BUFFER_INDICATION);

    channel->TBUF[0] = (uint32_t)XMC_I2C_CH_TDF_MASTER_STOP;
 8021f28:	f44f 62c0 	mov.w	r2, #1536	; 0x600
 8021f2c:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8021f30:	64c3      	str	r3, [r0, #76]	; 0x4c
 8021f32:	f8c0 2080 	str.w	r2, [r0, #128]	; 0x80
 8021f36:	4770      	bx	lr

08021f38 <XMC_I2C_CH_MasterTransmit>:

/* Sends master send command along with data to IN/TBUF register based on FIFO/non-FIFO modes. */
void XMC_I2C_CH_MasterTransmit(XMC_USIC_CH_t *const channel, const uint8_t data)
{
  /* Check FIFO size */
  if ((channel->TBCTR & USIC_CH_TBCTR_SIZE_Msk) == 0U)
 8021f38:	f8d0 3108 	ldr.w	r3, [r0, #264]	; 0x108
 8021f3c:	f013 6fe0 	tst.w	r3, #117440512	; 0x7000000
 8021f40:	d002      	beq.n	8021f48 <XMC_I2C_CH_MasterTransmit+0x10>

    channel->TBUF[0] = (uint32_t)XMC_I2C_CH_TDF_MASTER_SEND | data;
  }
  else
  {
    channel->IN[0] = (uint32_t)XMC_I2C_CH_TDF_MASTER_SEND | data;
 8021f42:	f8c0 1180 	str.w	r1, [r0, #384]	; 0x180
 8021f46:	4770      	bx	lr
 8021f48:	6b83      	ldr	r3, [r0, #56]	; 0x38
void XMC_I2C_CH_MasterTransmit(XMC_USIC_CH_t *const channel, const uint8_t data)
{
  /* Check FIFO size */
  if ((channel->TBCTR & USIC_CH_TBCTR_SIZE_Msk) == 0U)
  {    
    while (XMC_USIC_CH_GetTransmitBufferStatus(channel) == XMC_USIC_CH_TBUF_STATUS_BUSY)
 8021f4a:	061b      	lsls	r3, r3, #24
 8021f4c:	d4fc      	bmi.n	8021f48 <XMC_I2C_CH_MasterTransmit+0x10>
 8021f4e:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 8021f50:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8021f54:	64c3      	str	r3, [r0, #76]	; 0x4c
    }

    /* clear PSR_TBIF */
    XMC_I2C_CH_ClearStatusFlag(channel, (uint32_t)XMC_I2C_CH_STATUS_FLAG_TRANSMIT_BUFFER_INDICATION);

    channel->TBUF[0] = (uint32_t)XMC_I2C_CH_TDF_MASTER_SEND | data;
 8021f56:	f8c0 1080 	str.w	r1, [r0, #128]	; 0x80
 8021f5a:	4770      	bx	lr

08021f5c <XMC_I2C_CH_MasterReceiveAck>:

/* Sends master receive ack command to IN/TBUF register based on FIFO/non-FIFO modes. */
void XMC_I2C_CH_MasterReceiveAck(XMC_USIC_CH_t *const channel)
{
/* Check FIFO size */
  if ((channel->TBCTR & USIC_CH_TBCTR_SIZE_Msk) == 0U)
 8021f5c:	f8d0 3108 	ldr.w	r3, [r0, #264]	; 0x108
 8021f60:	f013 6fe0 	tst.w	r3, #117440512	; 0x7000000
 8021f64:	d004      	beq.n	8021f70 <XMC_I2C_CH_MasterReceiveAck+0x14>

    channel->TBUF[0] = (uint32_t)XMC_I2C_CH_TDF_MASTER_RECEIVE_ACK;
  }
  else
  {
    channel->IN[0] = (uint32_t)XMC_I2C_CH_TDF_MASTER_RECEIVE_ACK;
 8021f66:	f44f 7300 	mov.w	r3, #512	; 0x200
 8021f6a:	f8c0 3180 	str.w	r3, [r0, #384]	; 0x180
 8021f6e:	4770      	bx	lr
 8021f70:	6b83      	ldr	r3, [r0, #56]	; 0x38
void XMC_I2C_CH_MasterReceiveAck(XMC_USIC_CH_t *const channel)
{
/* Check FIFO size */
  if ((channel->TBCTR & USIC_CH_TBCTR_SIZE_Msk) == 0U)
  {    
    while(XMC_USIC_CH_GetTransmitBufferStatus(channel) == XMC_USIC_CH_TBUF_STATUS_BUSY)
 8021f72:	061b      	lsls	r3, r3, #24
 8021f74:	d4fc      	bmi.n	8021f70 <XMC_I2C_CH_MasterReceiveAck+0x14>
 8021f76:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
    }

    /* clear PSR_TBIF */
    XMC_I2C_CH_ClearStatusFlag(channel, (uint32_t)XMC_I2C_CH_STATUS_FLAG_TRANSMIT_BUFFER_INDICATION);

    channel->TBUF[0] = (uint32_t)XMC_I2C_CH_TDF_MASTER_RECEIVE_ACK;
 8021f78:	f44f 7200 	mov.w	r2, #512	; 0x200
 8021f7c:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8021f80:	64c3      	str	r3, [r0, #76]	; 0x4c
 8021f82:	f8c0 2080 	str.w	r2, [r0, #128]	; 0x80
 8021f86:	4770      	bx	lr

08021f88 <XMC_I2C_CH_MasterReceiveNack>:

/* Sends master receive nack command to IN/TBUF register based on FIFO/non-FIFO modes. */
void XMC_I2C_CH_MasterReceiveNack(XMC_USIC_CH_t *const channel)
{
  /* Check FIFO size */
  if ((channel->TBCTR & USIC_CH_TBCTR_SIZE_Msk) == 0U)
 8021f88:	f8d0 3108 	ldr.w	r3, [r0, #264]	; 0x108
 8021f8c:	f013 6fe0 	tst.w	r3, #117440512	; 0x7000000
 8021f90:	d004      	beq.n	8021f9c <XMC_I2C_CH_MasterReceiveNack+0x14>

    channel->TBUF[0] = (uint32_t)XMC_I2C_CH_TDF_MASTER_RECEIVE_NACK;
  }
  else 
  {
    channel->IN[0] = (uint32_t)XMC_I2C_CH_TDF_MASTER_RECEIVE_NACK;
 8021f92:	f44f 7340 	mov.w	r3, #768	; 0x300
 8021f96:	f8c0 3180 	str.w	r3, [r0, #384]	; 0x180
 8021f9a:	4770      	bx	lr
 8021f9c:	6b83      	ldr	r3, [r0, #56]	; 0x38
void XMC_I2C_CH_MasterReceiveNack(XMC_USIC_CH_t *const channel)
{
  /* Check FIFO size */
  if ((channel->TBCTR & USIC_CH_TBCTR_SIZE_Msk) == 0U)
  {    
    while(XMC_USIC_CH_GetTransmitBufferStatus(channel) == XMC_USIC_CH_TBUF_STATUS_BUSY)
 8021f9e:	061b      	lsls	r3, r3, #24
 8021fa0:	d4fc      	bmi.n	8021f9c <XMC_I2C_CH_MasterReceiveNack+0x14>
 8021fa2:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
    }

    /* clear PSR_TBIF */
    XMC_I2C_CH_ClearStatusFlag(channel, (uint32_t)XMC_I2C_CH_STATUS_FLAG_TRANSMIT_BUFFER_INDICATION);

    channel->TBUF[0] = (uint32_t)XMC_I2C_CH_TDF_MASTER_RECEIVE_NACK;
 8021fa4:	f44f 7240 	mov.w	r2, #768	; 0x300
 8021fa8:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8021fac:	64c3      	str	r3, [r0, #76]	; 0x4c
 8021fae:	f8c0 2080 	str.w	r2, [r0, #128]	; 0x80
 8021fb2:	4770      	bx	lr

08021fb4 <XMC_I2C_CH_GetReceivedData>:
uint8_t XMC_I2C_CH_GetReceivedData(const XMC_USIC_CH_t *const channel)
{
  uint8_t retval;

  /* Check FIFO size */
  if ((channel->RBCTR & USIC_CH_RBCTR_SIZE_Msk) == 0U)
 8021fb4:	f8d0 310c 	ldr.w	r3, [r0, #268]	; 0x10c
 8021fb8:	f013 6fe0 	tst.w	r3, #117440512	; 0x7000000
  {
    retval = (uint8_t)channel->RBUF;
 8021fbc:	bf0c      	ite	eq
 8021fbe:	6d40      	ldreq	r0, [r0, #84]	; 0x54
  }
  else
  {
    retval = (uint8_t)channel->OUTR;
 8021fc0:	f8d0 011c 	ldrne.w	r0, [r0, #284]	; 0x11c
 8021fc4:	b2c0      	uxtb	r0, r0
  }

  return retval;
}
 8021fc6:	4770      	bx	lr

08021fc8 <XMC_USBD_GetCapabilities>:
  cap.event_remote_wakeup = 1U;
  cap.event_reset = 1U;
  cap.event_resume = 1U;
  cap.event_suspend = 1U;
  cap.reserved = 0U;
  return cap;
 8021fc8:	2000      	movs	r0, #0
 8021fca:	f36f 0000 	bfc	r0, #0, #1
 8021fce:	f36f 0041 	bfc	r0, #1, #1
 8021fd2:	f040 001c 	orr.w	r0, r0, #28
 8021fd6:	f36f 1045 	bfc	r0, #5, #1
 8021fda:	f440 70e0 	orr.w	r0, r0, #448	; 0x1c0
}
 8021fde:	f3c0 0008 	ubfx	r0, r0, #0, #9
 8021fe2:	4770      	bx	lr

08021fe4 <XMC_USBD_DeviceConnect>:
 **/
XMC_USBD_STATUS_t XMC_USBD_DeviceConnect() 
{
  /* Just disable softdisconnect */
  dctl_data_t dctl;
	dctl.d32 = xmc_device.device_register->dctl;
 8021fe4:	4b04      	ldr	r3, [pc, #16]	; (8021ff8 <XMC_USBD_DeviceConnect+0x14>)
 8021fe6:	f8d3 21a4 	ldr.w	r2, [r3, #420]	; 0x1a4
 8021fea:	6853      	ldr	r3, [r2, #4]
  dctl.b.sftdiscon = 0U;
 8021fec:	f36f 0341 	bfc	r3, #1, #1
  xmc_device.device_register->dctl = dctl.d32;
 8021ff0:	6053      	str	r3, [r2, #4]
  return XMC_USBD_STATUS_OK;
}
 8021ff2:	2000      	movs	r0, #0
 8021ff4:	4770      	bx	lr
 8021ff6:	bf00      	nop
 8021ff8:	1fff0094 	.word	0x1fff0094

08021ffc <XMC_USBD_DeviceDisconnect>:
 * Disconnects the USB device from host
 **/
XMC_USBD_STATUS_t XMC_USBD_DeviceDisconnect() 
{
  dctl_data_t dctl;
	dctl.d32 = xmc_device.device_register->dctl;
 8021ffc:	4b04      	ldr	r3, [pc, #16]	; (8022010 <XMC_USBD_DeviceDisconnect+0x14>)
 8021ffe:	f8d3 21a4 	ldr.w	r2, [r3, #420]	; 0x1a4
 8022002:	6853      	ldr	r3, [r2, #4]
  dctl.b.sftdiscon = 1U;
 8022004:	f043 0302 	orr.w	r3, r3, #2
  xmc_device.device_register->dctl = dctl.d32;
 8022008:	6053      	str	r3, [r2, #4]
  return XMC_USBD_STATUS_OK;
}
 802200a:	2000      	movs	r0, #0
 802200c:	4770      	bx	lr
 802200e:	bf00      	nop
 8022010:	1fff0094 	.word	0x1fff0094

08022014 <XMC_USBD_DeviceGetState>:
 **/
XMC_USBD_STATE_t XMC_USBD_DeviceGetState(const XMC_USBD_t *const obj) 
{
  XMC_USBD_STATE_t state={0U};
  state.speed = XMC_USBD_SPEED_FULL;
  state.connected = xmc_device.IsConnected;
 8022014:	4a44      	ldr	r2, [pc, #272]	; (8022128 <XMC_USBD_DeviceGetState+0x114>)
 */
uint8_t XMC_USBD_lDeviceActive(const XMC_USBD_t *const obj) 
{
  uint8_t i;
  uint8_t result = 0U;
  for (i = 0U; i < (uint8_t)obj->usbd_max_num_eps; i++)
 8022016:	7b01      	ldrb	r1, [r0, #12]

/**
 * Gets the USB device state.
 **/
XMC_USBD_STATE_t XMC_USBD_DeviceGetState(const XMC_USBD_t *const obj) 
{
 8022018:	b470      	push	{r4, r5, r6}
  XMC_USBD_STATE_t state={0U};
  state.speed = XMC_USBD_SPEED_FULL;
  state.connected = xmc_device.IsConnected;
 802201a:	f892 41fe 	ldrb.w	r4, [r2, #510]	; 0x1fe
/**
 * Gets the USB device state.
 **/
XMC_USBD_STATE_t XMC_USBD_DeviceGetState(const XMC_USBD_t *const obj) 
{
  XMC_USBD_STATE_t state={0U};
 802201e:	2000      	movs	r0, #0
  state.speed = XMC_USBD_SPEED_FULL;
  state.connected = xmc_device.IsConnected;
 8022020:	f004 0401 	and.w	r4, r4, #1
 */
uint8_t XMC_USBD_lDeviceActive(const XMC_USBD_t *const obj) 
{
  uint8_t i;
  uint8_t result = 0U;
  for (i = 0U; i < (uint8_t)obj->usbd_max_num_eps; i++)
 8022024:	2900      	cmp	r1, #0
 8022026:	d07c      	beq.n	8022122 <XMC_USBD_DeviceGetState+0x10e>
  {
    if (xmc_device.ep[i].inInUse || xmc_device.ep[i].outInUse)
 8022028:	6853      	ldr	r3, [r2, #4]
 802202a:	071e      	lsls	r6, r3, #28
 802202c:	bf56      	itet	pl
 802202e:	6853      	ldrpl	r3, [r2, #4]
    {
      result = 1U;
 8022030:	2301      	movmi	r3, #1
{
  uint8_t i;
  uint8_t result = 0U;
  for (i = 0U; i < (uint8_t)obj->usbd_max_num_eps; i++)
  {
    if (xmc_device.ep[i].inInUse || xmc_device.ep[i].outInUse)
 8022032:	f3c3 1300 	ubfxpl	r3, r3, #4, #1
 */
uint8_t XMC_USBD_lDeviceActive(const XMC_USBD_t *const obj) 
{
  uint8_t i;
  uint8_t result = 0U;
  for (i = 0U; i < (uint8_t)obj->usbd_max_num_eps; i++)
 8022036:	2901      	cmp	r1, #1
 8022038:	d954      	bls.n	80220e4 <XMC_USBD_DeviceGetState+0xd0>
  {
    if (xmc_device.ep[i].inInUse || xmc_device.ep[i].outInUse)
 802203a:	6b95      	ldr	r5, [r2, #56]	; 0x38
 802203c:	4e3a      	ldr	r6, [pc, #232]	; (8022128 <XMC_USBD_DeviceGetState+0x114>)
 802203e:	072d      	lsls	r5, r5, #28
 8022040:	d461      	bmi.n	8022106 <XMC_USBD_DeviceGetState+0xf2>
 8022042:	6bb5      	ldr	r5, [r6, #56]	; 0x38
    {
      result = 1U;
 8022044:	f015 0f10 	tst.w	r5, #16
 8022048:	bf18      	it	ne
 802204a:	2301      	movne	r3, #1
 */
uint8_t XMC_USBD_lDeviceActive(const XMC_USBD_t *const obj) 
{
  uint8_t i;
  uint8_t result = 0U;
  for (i = 0U; i < (uint8_t)obj->usbd_max_num_eps; i++)
 802204c:	2902      	cmp	r1, #2
 802204e:	d049      	beq.n	80220e4 <XMC_USBD_DeviceGetState+0xd0>
  {
    if (xmc_device.ep[i].inInUse || xmc_device.ep[i].outInUse)
 8022050:	6ed5      	ldr	r5, [r2, #108]	; 0x6c
 8022052:	4e35      	ldr	r6, [pc, #212]	; (8022128 <XMC_USBD_DeviceGetState+0x114>)
 8022054:	072d      	lsls	r5, r5, #28
 8022056:	d462      	bmi.n	802211e <XMC_USBD_DeviceGetState+0x10a>
 8022058:	6ef5      	ldr	r5, [r6, #108]	; 0x6c
    {
      result = 1U;
 802205a:	f015 0f10 	tst.w	r5, #16
 802205e:	bf18      	it	ne
 8022060:	2301      	movne	r3, #1
 */
uint8_t XMC_USBD_lDeviceActive(const XMC_USBD_t *const obj) 
{
  uint8_t i;
  uint8_t result = 0U;
  for (i = 0U; i < (uint8_t)obj->usbd_max_num_eps; i++)
 8022062:	2903      	cmp	r1, #3
 8022064:	d03e      	beq.n	80220e4 <XMC_USBD_DeviceGetState+0xd0>
  {
    if (xmc_device.ep[i].inInUse || xmc_device.ep[i].outInUse)
 8022066:	f8d2 50a0 	ldr.w	r5, [r2, #160]	; 0xa0
 802206a:	4e2f      	ldr	r6, [pc, #188]	; (8022128 <XMC_USBD_DeviceGetState+0x114>)
 802206c:	072d      	lsls	r5, r5, #28
 802206e:	d454      	bmi.n	802211a <XMC_USBD_DeviceGetState+0x106>
 8022070:	f8d6 50a0 	ldr.w	r5, [r6, #160]	; 0xa0
    {
      result = 1U;
 8022074:	f015 0f10 	tst.w	r5, #16
 8022078:	bf18      	it	ne
 802207a:	2301      	movne	r3, #1
 */
uint8_t XMC_USBD_lDeviceActive(const XMC_USBD_t *const obj) 
{
  uint8_t i;
  uint8_t result = 0U;
  for (i = 0U; i < (uint8_t)obj->usbd_max_num_eps; i++)
 802207c:	2904      	cmp	r1, #4
 802207e:	d031      	beq.n	80220e4 <XMC_USBD_DeviceGetState+0xd0>
  {
    if (xmc_device.ep[i].inInUse || xmc_device.ep[i].outInUse)
 8022080:	f8d2 50d4 	ldr.w	r5, [r2, #212]	; 0xd4
 8022084:	4e28      	ldr	r6, [pc, #160]	; (8022128 <XMC_USBD_DeviceGetState+0x114>)
 8022086:	072d      	lsls	r5, r5, #28
 8022088:	d445      	bmi.n	8022116 <XMC_USBD_DeviceGetState+0x102>
 802208a:	f8d6 50d4 	ldr.w	r5, [r6, #212]	; 0xd4
    {
      result = 1U;
 802208e:	f015 0f10 	tst.w	r5, #16
 8022092:	bf18      	it	ne
 8022094:	2301      	movne	r3, #1
 */
uint8_t XMC_USBD_lDeviceActive(const XMC_USBD_t *const obj) 
{
  uint8_t i;
  uint8_t result = 0U;
  for (i = 0U; i < (uint8_t)obj->usbd_max_num_eps; i++)
 8022096:	2905      	cmp	r1, #5
 8022098:	d024      	beq.n	80220e4 <XMC_USBD_DeviceGetState+0xd0>
  {
    if (xmc_device.ep[i].inInUse || xmc_device.ep[i].outInUse)
 802209a:	f8d2 5108 	ldr.w	r5, [r2, #264]	; 0x108
 802209e:	4e22      	ldr	r6, [pc, #136]	; (8022128 <XMC_USBD_DeviceGetState+0x114>)
 80220a0:	072d      	lsls	r5, r5, #28
 80220a2:	d436      	bmi.n	8022112 <XMC_USBD_DeviceGetState+0xfe>
 80220a4:	f8d6 5108 	ldr.w	r5, [r6, #264]	; 0x108
    {
      result = 1U;
 80220a8:	f015 0f10 	tst.w	r5, #16
 80220ac:	bf18      	it	ne
 80220ae:	2301      	movne	r3, #1
 */
uint8_t XMC_USBD_lDeviceActive(const XMC_USBD_t *const obj) 
{
  uint8_t i;
  uint8_t result = 0U;
  for (i = 0U; i < (uint8_t)obj->usbd_max_num_eps; i++)
 80220b0:	2906      	cmp	r1, #6
 80220b2:	d017      	beq.n	80220e4 <XMC_USBD_DeviceGetState+0xd0>
  {
    if (xmc_device.ep[i].inInUse || xmc_device.ep[i].outInUse)
 80220b4:	f8d2 513c 	ldr.w	r5, [r2, #316]	; 0x13c
 80220b8:	4e1b      	ldr	r6, [pc, #108]	; (8022128 <XMC_USBD_DeviceGetState+0x114>)
 80220ba:	072d      	lsls	r5, r5, #28
 80220bc:	d427      	bmi.n	802210e <XMC_USBD_DeviceGetState+0xfa>
 80220be:	f8d6 513c 	ldr.w	r5, [r6, #316]	; 0x13c
    {
      result = 1U;
 80220c2:	f015 0f10 	tst.w	r5, #16
 80220c6:	bf18      	it	ne
 80220c8:	2301      	movne	r3, #1
 */
uint8_t XMC_USBD_lDeviceActive(const XMC_USBD_t *const obj) 
{
  uint8_t i;
  uint8_t result = 0U;
  for (i = 0U; i < (uint8_t)obj->usbd_max_num_eps; i++)
 80220ca:	2907      	cmp	r1, #7
 80220cc:	d00a      	beq.n	80220e4 <XMC_USBD_DeviceGetState+0xd0>
  {
    if (xmc_device.ep[i].inInUse || xmc_device.ep[i].outInUse)
 80220ce:	f8d2 1170 	ldr.w	r1, [r2, #368]	; 0x170
 80220d2:	4d15      	ldr	r5, [pc, #84]	; (8022128 <XMC_USBD_DeviceGetState+0x114>)
 80220d4:	0709      	lsls	r1, r1, #28
 80220d6:	d418      	bmi.n	802210a <XMC_USBD_DeviceGetState+0xf6>
 80220d8:	f8d5 1170 	ldr.w	r1, [r5, #368]	; 0x170
    {
      result = 1U;
 80220dc:	f011 0f10 	tst.w	r1, #16
 80220e0:	bf18      	it	ne
 80220e2:	2301      	movne	r3, #1
 80220e4:	f003 0301 	and.w	r3, r3, #1
{
  XMC_USBD_STATE_t state={0U};
  state.speed = XMC_USBD_SPEED_FULL;
  state.connected = xmc_device.IsConnected;
  state.active = XMC_USBD_lDeviceActive(obj);
  state.powered = xmc_device.IsPowered;
 80220e8:	f892 21fe 	ldrb.w	r2, [r2, #510]	; 0x1fe
  return state;
 80220ec:	f3c2 0280 	ubfx	r2, r2, #2, #1
 80220f0:	f362 0000 	bfi	r0, r2, #0, #1
 80220f4:	f364 0041 	bfi	r0, r4, #1, #1
 80220f8:	f363 0082 	bfi	r0, r3, #2, #1
 80220fc:	2301      	movs	r3, #1
 80220fe:	f363 00c4 	bfi	r0, r3, #3, #2
}
 8022102:	bc70      	pop	{r4, r5, r6}
 8022104:	4770      	bx	lr
  uint8_t result = 0U;
  for (i = 0U; i < (uint8_t)obj->usbd_max_num_eps; i++)
  {
    if (xmc_device.ep[i].inInUse || xmc_device.ep[i].outInUse)
    {
      result = 1U;
 8022106:	2301      	movs	r3, #1
 8022108:	e7a0      	b.n	802204c <XMC_USBD_DeviceGetState+0x38>
 802210a:	2301      	movs	r3, #1
 802210c:	e7ea      	b.n	80220e4 <XMC_USBD_DeviceGetState+0xd0>
 802210e:	2301      	movs	r3, #1
 8022110:	e7db      	b.n	80220ca <XMC_USBD_DeviceGetState+0xb6>
 8022112:	2301      	movs	r3, #1
 8022114:	e7cc      	b.n	80220b0 <XMC_USBD_DeviceGetState+0x9c>
 8022116:	2301      	movs	r3, #1
 8022118:	e7bd      	b.n	8022096 <XMC_USBD_DeviceGetState+0x82>
 802211a:	2301      	movs	r3, #1
 802211c:	e7ae      	b.n	802207c <XMC_USBD_DeviceGetState+0x68>
 802211e:	2301      	movs	r3, #1
 8022120:	e79f      	b.n	8022062 <XMC_USBD_DeviceGetState+0x4e>
 */
uint8_t XMC_USBD_lDeviceActive(const XMC_USBD_t *const obj) 
{
  uint8_t i;
  uint8_t result = 0U;
  for (i = 0U; i < (uint8_t)obj->usbd_max_num_eps; i++)
 8022122:	4603      	mov	r3, r0
 8022124:	e7e0      	b.n	80220e8 <XMC_USBD_DeviceGetState+0xd4>
 8022126:	bf00      	nop
 8022128:	1fff0094 	.word	0x1fff0094

0802212c <XMC_USBD_DeviceSetAddress>:
 * Sets the USB device address.
 **/
XMC_USBD_STATUS_t XMC_USBD_DeviceSetAddress(const uint8_t address,const XMC_USBD_SET_ADDRESS_STAGE_t stage) 
{
  dcfg_data_t data;
  data.d32 = xmc_device.device_register->dcfg;
 802212c:	4b04      	ldr	r3, [pc, #16]	; (8022140 <XMC_USBD_DeviceSetAddress+0x14>)
 802212e:	f8d3 31a4 	ldr.w	r3, [r3, #420]	; 0x1a4
 8022132:	681a      	ldr	r2, [r3, #0]
  if (stage == XMC_USBD_SET_ADDRESS_STAGE_SETUP)
 8022134:	b911      	cbnz	r1, 802213c <XMC_USBD_DeviceSetAddress+0x10>
  {
    data.b.devaddr = address;
 8022136:	f360 120a 	bfi	r2, r0, #4, #7
    xmc_device.device_register->dcfg = data.d32;
 802213a:	601a      	str	r2, [r3, #0]
  }
	return XMC_USBD_STATUS_OK;
}
 802213c:	2000      	movs	r0, #0
 802213e:	4770      	bx	lr
 8022140:	1fff0094 	.word	0x1fff0094

08022144 <XMC_USBD_EndpointStall>:
 * Set/clear stall on the selected endpoint.
 **/
XMC_USBD_STATUS_t XMC_USBD_EndpointStall(const uint8_t ep_addr, const bool stall) 
{
  depctl_data_t data;
  XMC_USBD_EP_t *ep = &xmc_device.ep[(ep_addr & (uint8_t)XMC_USBD_EP_NUM_MASK)];
 8022144:	f000 020f 	and.w	r2, r0, #15
  if (stall)
 8022148:	b1e9      	cbz	r1, 8022186 <XMC_USBD_EndpointStall+0x42>
  {
    if (ep_addr & (uint8_t)XMC_USBD_ENDPOINT_DIRECTION_MASK)
    {
      /*set stall bit */
      data.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl;
 802214a:	2334      	movs	r3, #52	; 0x34
{
  depctl_data_t data;
  XMC_USBD_EP_t *ep = &xmc_device.ep[(ep_addr & (uint8_t)XMC_USBD_EP_NUM_MASK)];
  if (stall)
  {
    if (ep_addr & (uint8_t)XMC_USBD_ENDPOINT_DIRECTION_MASK)
 802214c:	f010 0f80 	tst.w	r0, #128	; 0x80
    {
      /*set stall bit */
      data.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl;
 8022150:	fb03 f302 	mul.w	r3, r3, r2
 8022154:	481d      	ldr	r0, [pc, #116]	; (80221cc <XMC_USBD_EndpointStall+0x88>)
 8022156:	5cc3      	ldrb	r3, [r0, r3]
 8022158:	f003 030f 	and.w	r3, r3, #15
      xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = data.d32;
    }
    else
    {
      /*set stall bit */
      data.d32 = xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl;
 802215c:	bf0b      	itete	eq
 802215e:	eb00 0383 	addeq.w	r3, r0, r3, lsl #2
  if (stall)
  {
    if (ep_addr & (uint8_t)XMC_USBD_ENDPOINT_DIRECTION_MASK)
    {
      /*set stall bit */
      data.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl;
 8022162:	336a      	addne	r3, #106	; 0x6a
      xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = data.d32;
    }
    else
    {
      /*set stall bit */
      data.d32 = xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl;
 8022164:	f8d3 11c4 	ldreq.w	r1, [r3, #452]	; 0x1c4
  if (stall)
  {
    if (ep_addr & (uint8_t)XMC_USBD_ENDPOINT_DIRECTION_MASK)
    {
      /*set stall bit */
      data.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl;
 8022168:	f850 1023 	ldrne.w	r1, [r0, r3, lsl #2]
      xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = data.d32;
    }
    else
    {
      /*set stall bit */
      data.d32 = xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl;
 802216c:	680b      	ldr	r3, [r1, #0]
      data.b.stall = 1U;
 802216e:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
      xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl = data.d32;
 8022172:	600b      	str	r3, [r1, #0]
    }
    ep->isStalled = 1U;
 8022174:	2334      	movs	r3, #52	; 0x34
 8022176:	fb03 0202 	mla	r2, r3, r2, r0
			xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl = data.d32;
		}
		ep->isStalled = 0U;
	}
	return XMC_USBD_STATUS_OK;
}
 802217a:	2000      	movs	r0, #0
      /*set stall bit */
      data.d32 = xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl;
      data.b.stall = 1U;
      xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl = data.d32;
    }
    ep->isStalled = 1U;
 802217c:	7913      	ldrb	r3, [r2, #4]
 802217e:	f043 0320 	orr.w	r3, r3, #32
 8022182:	7113      	strb	r3, [r2, #4]
			xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl = data.d32;
		}
		ep->isStalled = 0U;
	}
	return XMC_USBD_STATUS_OK;
}
 8022184:	4770      	bx	lr

/**
 * Set/clear stall on the selected endpoint.
 **/
XMC_USBD_STATUS_t XMC_USBD_EndpointStall(const uint8_t ep_addr, const bool stall) 
{
 8022186:	b410      	push	{r4}
  else
  {
    /* just clear stall bit */
		if (ep_addr & (uint8_t)XMC_USBD_ENDPOINT_DIRECTION_MASK)
		{
			data.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl;
 8022188:	2334      	movs	r3, #52	; 0x34
    ep->isStalled = 1U;
  }
  else
  {
    /* just clear stall bit */
		if (ep_addr & (uint8_t)XMC_USBD_ENDPOINT_DIRECTION_MASK)
 802218a:	f010 0f80 	tst.w	r0, #128	; 0x80
		{
			data.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl;
 802218e:	fb03 f302 	mul.w	r3, r3, r2
 8022192:	480e      	ldr	r0, [pc, #56]	; (80221cc <XMC_USBD_EndpointStall+0x88>)
 8022194:	5cc3      	ldrb	r3, [r0, r3]
 8022196:	f003 030f 	and.w	r3, r3, #15
			data.b.setd0pid = 1U; /* reset pid to 0 */
			xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = data.d32;
		}
		else
		{
			data.d32 = xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl;
 802219a:	bf0b      	itete	eq
 802219c:	eb00 0383 	addeq.w	r3, r0, r3, lsl #2
  else
  {
    /* just clear stall bit */
		if (ep_addr & (uint8_t)XMC_USBD_ENDPOINT_DIRECTION_MASK)
		{
			data.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl;
 80221a0:	336a      	addne	r3, #106	; 0x6a
			data.b.setd0pid = 1U; /* reset pid to 0 */
			xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = data.d32;
		}
		else
		{
			data.d32 = xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl;
 80221a2:	f8d3 41c4 	ldreq.w	r4, [r3, #452]	; 0x1c4
  else
  {
    /* just clear stall bit */
		if (ep_addr & (uint8_t)XMC_USBD_ENDPOINT_DIRECTION_MASK)
		{
			data.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl;
 80221a6:	f850 4023 	ldrne.w	r4, [r0, r3, lsl #2]
			data.b.setd0pid = 1U; /* reset pid to 0 */
			xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = data.d32;
		}
		else
		{
			data.d32 = xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl;
 80221aa:	6823      	ldr	r3, [r4, #0]
			data.b.stall = 0U;
 80221ac:	f361 5355 	bfi	r3, r1, #21, #1
			data.b.setd0pid = 1U; /* reset pid to 0 */
 80221b0:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
			xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl = data.d32;
 80221b4:	6023      	str	r3, [r4, #0]
		}
		ep->isStalled = 0U;
 80221b6:	2334      	movs	r3, #52	; 0x34
 80221b8:	fb03 0202 	mla	r2, r3, r2, r0
	}
	return XMC_USBD_STATUS_OK;
}
 80221bc:	f85d 4b04 	ldr.w	r4, [sp], #4
			data.d32 = xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl;
			data.b.stall = 0U;
			data.b.setd0pid = 1U; /* reset pid to 0 */
			xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl = data.d32;
		}
		ep->isStalled = 0U;
 80221c0:	7913      	ldrb	r3, [r2, #4]
 80221c2:	f36f 1345 	bfc	r3, #5, #1
	}
	return XMC_USBD_STATUS_OK;
}
 80221c6:	2000      	movs	r0, #0
			data.d32 = xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl;
			data.b.stall = 0U;
			data.b.setd0pid = 1U; /* reset pid to 0 */
			xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl = data.d32;
		}
		ep->isStalled = 0U;
 80221c8:	7113      	strb	r3, [r2, #4]
	}
	return XMC_USBD_STATUS_OK;
}
 80221ca:	4770      	bx	lr
 80221cc:	1fff0094 	.word	0x1fff0094

080221d0 <XMC_USBD_EndpointAbort>:

/**
 * Aborts the data transfer on the selected endpoint
 **/
XMC_USBD_STATUS_t XMC_USBD_EndpointAbort(const uint8_t ep_addr) {
  XMC_USBD_EP_t *ep = &xmc_device.ep[ep_addr & (uint8_t)XMC_USBD_ENDPOINT_NUMBER_MASK];
 80221d0:	f000 000f 	and.w	r0, r0, #15
  if (ep->address_u.address_st.direction)
 80221d4:	2234      	movs	r2, #52	; 0x34
 80221d6:	fb02 f200 	mul.w	r2, r2, r0
 80221da:	4b0d      	ldr	r3, [pc, #52]	; (8022210 <XMC_USBD_EndpointAbort+0x40>)
 80221dc:	5c99      	ldrb	r1, [r3, r2]
 80221de:	441a      	add	r2, r3
 80221e0:	f011 0f80 	tst.w	r1, #128	; 0x80
  {
    ep->inInUse = 0U;
 80221e4:	6851      	ldr	r1, [r2, #4]
  }
  if (!ep->address_u.address_st.direction)
  {
    ep->outInUse = 0U;
 80221e6:	bf0c      	ite	eq
 80221e8:	f021 0110 	biceq.w	r1, r1, #16
 **/
XMC_USBD_STATUS_t XMC_USBD_EndpointAbort(const uint8_t ep_addr) {
  XMC_USBD_EP_t *ep = &xmc_device.ep[ep_addr & (uint8_t)XMC_USBD_ENDPOINT_NUMBER_MASK];
  if (ep->address_u.address_st.direction)
  {
    ep->inInUse = 0U;
 80221ec:	f021 0108 	bicne.w	r1, r1, #8
 80221f0:	6051      	str	r1, [r2, #4]
  }
  if (!ep->address_u.address_st.direction)
  {
    ep->outInUse = 0U;
  }
  ep->isStalled = 0U;
 80221f2:	2234      	movs	r2, #52	; 0x34
 80221f4:	fb02 3300 	mla	r3, r2, r0, r3
  ep->outBytesAvailable = 0U;
 80221f8:	2000      	movs	r0, #0
  }
  if (!ep->address_u.address_st.direction)
  {
    ep->outInUse = 0U;
  }
  ep->isStalled = 0U;
 80221fa:	791a      	ldrb	r2, [r3, #4]
  ep->outBytesAvailable = 0U;
  ep->outOffset = 0U;
  ep->xferLength = 0U;
  ep->xferCount = 0U;
 80221fc:	62d8      	str	r0, [r3, #44]	; 0x2c
  }
  if (!ep->address_u.address_st.direction)
  {
    ep->outInUse = 0U;
  }
  ep->isStalled = 0U;
 80221fe:	f36f 1245 	bfc	r2, #5, #1
 8022202:	711a      	strb	r2, [r3, #4]
  ep->outBytesAvailable = 0U;
 8022204:	6118      	str	r0, [r3, #16]
  ep->outOffset = 0U;
 8022206:	6198      	str	r0, [r3, #24]
  ep->xferLength = 0U;
 8022208:	6298      	str	r0, [r3, #40]	; 0x28
  ep->xferCount = 0U;
  ep->xferTotal = 0U;
 802220a:	6318      	str	r0, [r3, #48]	; 0x30

  return XMC_USBD_STATUS_OK;
}
 802220c:	4770      	bx	lr
 802220e:	bf00      	nop
 8022210:	1fff0094 	.word	0x1fff0094

08022214 <XMC_USBD_EndpointUnconfigure>:

/**
 * Unconfigure the selected endpoint.
 **/
XMC_USBD_STATUS_t XMC_USBD_EndpointUnconfigure(const uint8_t ep_addr) 
{
 8022214:	b5f0      	push	{r4, r5, r6, r7, lr}
  depctl_data_t data;
	daint_data_t daintmsk;
	XMC_USBD_STATUS_t result;
	uint32_t number_temp;
  data.d32 = 0U;  
  daintmsk.d32 = xmc_device.device_register->daintmsk;  
 8022216:	4b3d      	ldr	r3, [pc, #244]	; (802230c <XMC_USBD_EndpointUnconfigure+0xf8>)
/**
 * Unconfigure the selected endpoint.
 **/
XMC_USBD_STATUS_t XMC_USBD_EndpointUnconfigure(const uint8_t ep_addr) 
{
  XMC_USBD_EP_t *ep = &xmc_device.ep[ep_addr & (uint8_t)XMC_USBD_ENDPOINT_NUMBER_MASK];
 8022218:	f000 000f 	and.w	r0, r0, #15
	daint_data_t daintmsk;
	XMC_USBD_STATUS_t result;
	uint32_t number_temp;
  data.d32 = 0U;  
  daintmsk.d32 = xmc_device.device_register->daintmsk;  
  number_temp = (uint32_t)((uint32_t)1U << (uint8_t)ep->address_u.address_st.number);
 802221c:	2134      	movs	r1, #52	; 0x34
 802221e:	fb01 f100 	mul.w	r1, r1, r0
 8022222:	185a      	adds	r2, r3, r1
 8022224:	f813 e001 	ldrb.w	lr, [r3, r1]
  /* if not configured return an error */
  if (!ep->isConfigured)
 8022228:	7914      	ldrb	r4, [r2, #4]
  depctl_data_t data;
	daint_data_t daintmsk;
	XMC_USBD_STATUS_t result;
	uint32_t number_temp;
  data.d32 = 0U;  
  daintmsk.d32 = xmc_device.device_register->daintmsk;  
 802222a:	f8d3 71a4 	ldr.w	r7, [r3, #420]	; 0x1a4
  number_temp = (uint32_t)((uint32_t)1U << (uint8_t)ep->address_u.address_st.number);
  /* if not configured return an error */
  if (!ep->isConfigured)
 802222e:	f014 0f04 	tst.w	r4, #4
	daint_data_t daintmsk;
	XMC_USBD_STATUS_t result;
	uint32_t number_temp;
  data.d32 = 0U;  
  daintmsk.d32 = xmc_device.device_register->daintmsk;  
  number_temp = (uint32_t)((uint32_t)1U << (uint8_t)ep->address_u.address_st.number);
 8022232:	f00e 060f 	and.w	r6, lr, #15
  depctl_data_t data;
	daint_data_t daintmsk;
	XMC_USBD_STATUS_t result;
	uint32_t number_temp;
  data.d32 = 0U;  
  daintmsk.d32 = xmc_device.device_register->daintmsk;  
 8022236:	69fd      	ldr	r5, [r7, #28]
  XMC_USBD_EP_t *ep = &xmc_device.ep[ep_addr & (uint8_t)XMC_USBD_ENDPOINT_NUMBER_MASK];
  depctl_data_t data;
	daint_data_t daintmsk;
	XMC_USBD_STATUS_t result;
	uint32_t number_temp;
  data.d32 = 0U;  
 8022238:	f04f 0100 	mov.w	r1, #0
  daintmsk.d32 = xmc_device.device_register->daintmsk;  
  number_temp = (uint32_t)((uint32_t)1U << (uint8_t)ep->address_u.address_st.number);
  /* if not configured return an error */
  if (!ep->isConfigured)
 802223c:	d05a      	beq.n	80222f4 <XMC_USBD_EndpointUnconfigure+0xe0>
    data.b.usbactep = 0U;
    data.b.epdis =  1U;
    data.b.snak =  1U;
    data.b.stall =  0U;
    ep->isConfigured =  0U;
    ep->isStalled =  0U;
 802223e:	f004 04fb 	and.w	r4, r4, #251	; 0xfb
 8022242:	f36f 1445 	bfc	r4, #5, #1
 8022246:	7114      	strb	r4, [r2, #4]
    ep->outInUse =  0U;
 8022248:	6854      	ldr	r4, [r2, #4]
 802224a:	f024 0410 	bic.w	r4, r4, #16
 802224e:	6054      	str	r4, [r2, #4]
    ep->inInUse =  0U;
 8022250:	6854      	ldr	r4, [r2, #4]
     result = XMC_USBD_STATUS_ERROR;
  }
  else
  {
    /* disable the endpoint, deactivate it and only send naks */
    data.b.usbactep = 0U;
 8022252:	f361 31cf 	bfi	r1, r1, #15, #1
    data.b.epdis =  1U;
    data.b.snak =  1U;
 8022256:	f041 4190 	orr.w	r1, r1, #1207959552	; 0x48000000
    data.b.stall =  0U;
    ep->isConfigured =  0U;
    ep->isStalled =  0U;
    ep->outInUse =  0U;
    ep->inInUse =  0U;
 802225a:	f024 0408 	bic.w	r4, r4, #8
	daint_data_t daintmsk;
	XMC_USBD_STATUS_t result;
	uint32_t number_temp;
  data.d32 = 0U;  
  daintmsk.d32 = xmc_device.device_register->daintmsk;  
  number_temp = (uint32_t)((uint32_t)1U << (uint8_t)ep->address_u.address_st.number);
 802225e:	f04f 0c01 	mov.w	ip, #1
    ep->isConfigured =  0U;
    ep->isStalled =  0U;
    ep->outInUse =  0U;
    ep->inInUse =  0U;
    /* chose register based on the direction. Control Endpoint need both */
    if ((ep->address_u.address_st.direction == 1U) || (ep->type == (uint8_t)XMC_USBD_ENDPOINT_TYPE_CONTROL))
 8022262:	f01e 0f80 	tst.w	lr, #128	; 0x80
  {
    /* disable the endpoint, deactivate it and only send naks */
    data.b.usbactep = 0U;
    data.b.epdis =  1U;
    data.b.snak =  1U;
    data.b.stall =  0U;
 8022266:	f36f 5155 	bfc	r1, #21, #1
    ep->isConfigured =  0U;
    ep->isStalled =  0U;
    ep->outInUse =  0U;
    ep->inInUse =  0U;
 802226a:	6054      	str	r4, [r2, #4]
	daint_data_t daintmsk;
	XMC_USBD_STATUS_t result;
	uint32_t number_temp;
  data.d32 = 0U;  
  daintmsk.d32 = xmc_device.device_register->daintmsk;  
  number_temp = (uint32_t)((uint32_t)1U << (uint8_t)ep->address_u.address_st.number);
 802226c:	fa0c fc06 	lsl.w	ip, ip, r6
    ep->isConfigured =  0U;
    ep->isStalled =  0U;
    ep->outInUse =  0U;
    ep->inInUse =  0U;
    /* chose register based on the direction. Control Endpoint need both */
    if ((ep->address_u.address_st.direction == 1U) || (ep->type == (uint8_t)XMC_USBD_ENDPOINT_TYPE_CONTROL))
 8022270:	d02f      	beq.n	80222d2 <XMC_USBD_EndpointUnconfigure+0xbe>
    {
      /* disable endpoint configuration */
      xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = data.d32;
 8022272:	f106 0e6a 	add.w	lr, r6, #106	; 0x6a
      /* disable interrupts */
      daintmsk.ep.in = (uint16_t)((uint32_t)daintmsk.ep.in & (~(uint32_t)number_temp));
 8022276:	ea6f 040c 	mvn.w	r4, ip
    ep->inInUse =  0U;
    /* chose register based on the direction. Control Endpoint need both */
    if ((ep->address_u.address_st.direction == 1U) || (ep->type == (uint8_t)XMC_USBD_ENDPOINT_TYPE_CONTROL))
    {
      /* disable endpoint configuration */
      xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = data.d32;
 802227a:	f853 e02e 	ldr.w	lr, [r3, lr, lsl #2]
 802227e:	f8ce 1000 	str.w	r1, [lr]
      /* disable interrupts */
      daintmsk.ep.in = (uint16_t)((uint32_t)daintmsk.ep.in & (~(uint32_t)number_temp));
    }
    if ((ep->address_u.address_st.direction == 0U) || (ep->type == (uint8_t)XMC_USBD_ENDPOINT_TYPE_CONTROL))
 8022282:	7912      	ldrb	r2, [r2, #4]
    if ((ep->address_u.address_st.direction == 1U) || (ep->type == (uint8_t)XMC_USBD_ENDPOINT_TYPE_CONTROL))
    {
      /* disable endpoint configuration */
      xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = data.d32;
      /* disable interrupts */
      daintmsk.ep.in = (uint16_t)((uint32_t)daintmsk.ep.in & (~(uint32_t)number_temp));
 8022284:	fa1f fe84 	uxth.w	lr, r4
 8022288:	ea0e 0c05 	and.w	ip, lr, r5
    }
    if ((ep->address_u.address_st.direction == 0U) || (ep->type == (uint8_t)XMC_USBD_ENDPOINT_TYPE_CONTROL))
 802228c:	0792      	lsls	r2, r2, #30
    if ((ep->address_u.address_st.direction == 1U) || (ep->type == (uint8_t)XMC_USBD_ENDPOINT_TYPE_CONTROL))
    {
      /* disable endpoint configuration */
      xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = data.d32;
      /* disable interrupts */
      daintmsk.ep.in = (uint16_t)((uint32_t)daintmsk.ep.in & (~(uint32_t)number_temp));
 802228e:	f36c 050f 	bfi	r5, ip, #0, #16
    }
    if ((ep->address_u.address_st.direction == 0U) || (ep->type == (uint8_t)XMC_USBD_ENDPOINT_TYPE_CONTROL))
 8022292:	d10d      	bne.n	80222b0 <XMC_USBD_EndpointUnconfigure+0x9c>
    {
      xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl = data.d32;
      daintmsk.ep.out = (uint16_t)((uint32_t)daintmsk.ep.out & (~(uint32_t)number_temp));
      if(usbd_init->usbd_transfer_mode == XMC_USBD_USE_FIFO)
 8022294:	4a1e      	ldr	r2, [pc, #120]	; (8022310 <XMC_USBD_EndpointUnconfigure+0xfc>)
 8022296:	6812      	ldr	r2, [r2, #0]
      /* disable interrupts */
      daintmsk.ep.in = (uint16_t)((uint32_t)daintmsk.ep.in & (~(uint32_t)number_temp));
    }
    if ((ep->address_u.address_st.direction == 0U) || (ep->type == (uint8_t)XMC_USBD_ENDPOINT_TYPE_CONTROL))
    {
      xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl = data.d32;
 8022298:	eb03 0686 	add.w	r6, r3, r6, lsl #2
      daintmsk.ep.out = (uint16_t)((uint32_t)daintmsk.ep.out & (~(uint32_t)number_temp));
      if(usbd_init->usbd_transfer_mode == XMC_USBD_USE_FIFO)
 802229c:	7b52      	ldrb	r2, [r2, #13]
      /* disable interrupts */
      daintmsk.ep.in = (uint16_t)((uint32_t)daintmsk.ep.in & (~(uint32_t)number_temp));
    }
    if ((ep->address_u.address_st.direction == 0U) || (ep->type == (uint8_t)XMC_USBD_ENDPOINT_TYPE_CONTROL))
    {
      xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl = data.d32;
 802229e:	f8d6 61c4 	ldr.w	r6, [r6, #452]	; 0x1c4
      daintmsk.ep.out = (uint16_t)((uint32_t)daintmsk.ep.out & (~(uint32_t)number_temp));
 80222a2:	ea0e 4e15 	and.w	lr, lr, r5, lsr #16
      if(usbd_init->usbd_transfer_mode == XMC_USBD_USE_FIFO)
 80222a6:	2a01      	cmp	r2, #1
      /* disable interrupts */
      daintmsk.ep.in = (uint16_t)((uint32_t)daintmsk.ep.in & (~(uint32_t)number_temp));
    }
    if ((ep->address_u.address_st.direction == 0U) || (ep->type == (uint8_t)XMC_USBD_ENDPOINT_TYPE_CONTROL))
    {
      xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl = data.d32;
 80222a8:	6031      	str	r1, [r6, #0]
      daintmsk.ep.out = (uint16_t)((uint32_t)daintmsk.ep.out & (~(uint32_t)number_temp));
 80222aa:	f36e 451f 	bfi	r5, lr, #16, #16
      if(usbd_init->usbd_transfer_mode == XMC_USBD_USE_FIFO)
 80222ae:	d028      	beq.n	8022302 <XMC_USBD_EndpointUnconfigure+0xee>
      {
        xmc_device.device_register->dtknqr4_fifoemptymsk &= ~number_temp;
      }
    }
    xmc_device.device_register->daintmsk = daintmsk.d32;
    XMC_USBD_lUnassignFifo(ep->txFifoNum); /* free fifo */
 80222b0:	2234      	movs	r2, #52	; 0x34
 80222b2:	fb02 3000 	mla	r0, r2, r0, r3
      if(usbd_init->usbd_transfer_mode == XMC_USBD_USE_FIFO)
      {
        xmc_device.device_register->dtknqr4_fifoemptymsk &= ~number_temp;
      }
    }
    xmc_device.device_register->daintmsk = daintmsk.d32;
 80222b6:	61fd      	str	r5, [r7, #28]
    XMC_USBD_lUnassignFifo(ep->txFifoNum); /* free fifo */
 80222b8:	8880      	ldrh	r0, [r0, #4]
 * Mark an used tx fifo as free.
 * @param[in] fifo_nr Fifo number to free
 */
static void XMC_USBD_lUnassignFifo(const uint8_t fifo_nr) 
{
  xmc_device.txfifomsk = (uint16_t)((uint32_t)xmc_device.txfifomsk & (uint32_t)(~((uint32_t)((uint32_t)1U << fifo_nr))));
 80222ba:	f8b3 11fc 	ldrh.w	r1, [r3, #508]	; 0x1fc
 80222be:	f3c0 1083 	ubfx	r0, r0, #6, #4
 80222c2:	2201      	movs	r2, #1
 80222c4:	4082      	lsls	r2, r0
 80222c6:	ea21 0202 	bic.w	r2, r1, r2
 80222ca:	f8a3 21fc 	strh.w	r2, [r3, #508]	; 0x1fc
        xmc_device.device_register->dtknqr4_fifoemptymsk &= ~number_temp;
      }
    }
    xmc_device.device_register->daintmsk = daintmsk.d32;
    XMC_USBD_lUnassignFifo(ep->txFifoNum); /* free fifo */
    result = XMC_USBD_STATUS_OK;
 80222ce:	2000      	movs	r0, #0
 80222d0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    ep->isConfigured =  0U;
    ep->isStalled =  0U;
    ep->outInUse =  0U;
    ep->inInUse =  0U;
    /* chose register based on the direction. Control Endpoint need both */
    if ((ep->address_u.address_st.direction == 1U) || (ep->type == (uint8_t)XMC_USBD_ENDPOINT_TYPE_CONTROL))
 80222d2:	7912      	ldrb	r2, [r2, #4]
 80222d4:	0794      	lsls	r4, r2, #30
 80222d6:	d10f      	bne.n	80222f8 <XMC_USBD_EndpointUnconfigure+0xe4>
    {
      /* disable endpoint configuration */
      xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = data.d32;
 80222d8:	f106 026a 	add.w	r2, r6, #106	; 0x6a
      /* disable interrupts */
      daintmsk.ep.in = (uint16_t)((uint32_t)daintmsk.ep.in & (~(uint32_t)number_temp));
 80222dc:	ea6f 040c 	mvn.w	r4, ip
 80222e0:	fa1f fe84 	uxth.w	lr, r4
    ep->inInUse =  0U;
    /* chose register based on the direction. Control Endpoint need both */
    if ((ep->address_u.address_st.direction == 1U) || (ep->type == (uint8_t)XMC_USBD_ENDPOINT_TYPE_CONTROL))
    {
      /* disable endpoint configuration */
      xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = data.d32;
 80222e4:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
      /* disable interrupts */
      daintmsk.ep.in = (uint16_t)((uint32_t)daintmsk.ep.in & (~(uint32_t)number_temp));
 80222e8:	ea0e 0c05 	and.w	ip, lr, r5
 80222ec:	f36c 050f 	bfi	r5, ip, #0, #16
    ep->inInUse =  0U;
    /* chose register based on the direction. Control Endpoint need both */
    if ((ep->address_u.address_st.direction == 1U) || (ep->type == (uint8_t)XMC_USBD_ENDPOINT_TYPE_CONTROL))
    {
      /* disable endpoint configuration */
      xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = data.d32;
 80222f0:	6011      	str	r1, [r2, #0]
 80222f2:	e7cf      	b.n	8022294 <XMC_USBD_EndpointUnconfigure+0x80>
  daintmsk.d32 = xmc_device.device_register->daintmsk;  
  number_temp = (uint32_t)((uint32_t)1U << (uint8_t)ep->address_u.address_st.number);
  /* if not configured return an error */
  if (!ep->isConfigured)
  {
     result = XMC_USBD_STATUS_ERROR;
 80222f4:	2001      	movs	r0, #1
 80222f6:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80222f8:	ea6f 040c 	mvn.w	r4, ip
 80222fc:	fa1f fe84 	uxth.w	lr, r4
 8022300:	e7c8      	b.n	8022294 <XMC_USBD_EndpointUnconfigure+0x80>
    {
      xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl = data.d32;
      daintmsk.ep.out = (uint16_t)((uint32_t)daintmsk.ep.out & (~(uint32_t)number_temp));
      if(usbd_init->usbd_transfer_mode == XMC_USBD_USE_FIFO)
      {
        xmc_device.device_register->dtknqr4_fifoemptymsk &= ~number_temp;
 8022302:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8022304:	4014      	ands	r4, r2
 8022306:	637c      	str	r4, [r7, #52]	; 0x34
 8022308:	e7d2      	b.n	80222b0 <XMC_USBD_EndpointUnconfigure+0x9c>
 802230a:	bf00      	nop
 802230c:	1fff0094 	.word	0x1fff0094
 8022310:	1fff0090 	.word	0x1fff0090

08022314 <XMC_USBD_GetFrameNumber>:
 **/
uint16_t XMC_USBD_GetFrameNumber(void) 
{
  uint16_t result;
  dsts_data_t dsts;
  dsts.d32 = xmc_device.device_register->dsts;
 8022314:	4b03      	ldr	r3, [pc, #12]	; (8022324 <XMC_USBD_GetFrameNumber+0x10>)
 8022316:	f8d3 31a4 	ldr.w	r3, [r3, #420]	; 0x1a4
 802231a:	6898      	ldr	r0, [r3, #8]
  result = (uint16_t)dsts.b.soffn;
  return result;
}
 802231c:	f3c0 200d 	ubfx	r0, r0, #8, #14
 8022320:	4770      	bx	lr
 8022322:	bf00      	nop
 8022324:	1fff0094 	.word	0x1fff0094

08022328 <XMC_USBD_IsEnumDone>:
 * This should not be used for the actual USB enumeration completion status. For the actual USB enumeration status,
 * the application layer should check for the completion of USB standard request Set configuration.
 **/
uint32_t XMC_USBD_IsEnumDone(void)
{
  return (uint32_t)((uint8_t)xmc_device.IsConnected && (uint8_t)xmc_device.IsPowered);
 8022328:	4b05      	ldr	r3, [pc, #20]	; (8022340 <XMC_USBD_IsEnumDone+0x18>)
 802232a:	f893 01fe 	ldrb.w	r0, [r3, #510]	; 0x1fe
 802232e:	f000 0005 	and.w	r0, r0, #5
}
 8022332:	f1a0 0005 	sub.w	r0, r0, #5
 8022336:	fab0 f080 	clz	r0, r0
 802233a:	0940      	lsrs	r0, r0, #5
 802233c:	4770      	bx	lr
 802233e:	bf00      	nop
 8022340:	1fff0094 	.word	0x1fff0094

08022344 <XMC_USBD_Uninitialize>:
 **/
XMC_USBD_STATUS_t XMC_USBD_Uninitialize() 
{
  /* Disconnect the device */
  dctl_data_t dctl;
	dctl.d32 = xmc_device.device_register->dctl;
 8022344:	4807      	ldr	r0, [pc, #28]	; (8022364 <XMC_USBD_Uninitialize+0x20>)
 8022346:	f8d0 21a4 	ldr.w	r2, [r0, #420]	; 0x1a4

/**
 * Uninitializes the USB device
 **/
XMC_USBD_STATUS_t XMC_USBD_Uninitialize() 
{
 802234a:	b508      	push	{r3, lr}
  /* Disconnect the device */
  dctl_data_t dctl;
	dctl.d32 = xmc_device.device_register->dctl;
 802234c:	6853      	ldr	r3, [r2, #4]
  dctl.b.sftdiscon = 1U;
 802234e:	f043 0302 	orr.w	r3, r3, #2
  xmc_device.device_register->dctl = dctl.d32;
 8022352:	6053      	str	r3, [r2, #4]
  /* clean up */
  memset((void*)&xmc_device,0U,sizeof(xmc_device));
 8022354:	2100      	movs	r1, #0
 8022356:	f44f 7202 	mov.w	r2, #520	; 0x208
 802235a:	f00b f904 	bl	802d566 <memset>
  return XMC_USBD_STATUS_OK;
}
 802235e:	2000      	movs	r0, #0
 8022360:	bd08      	pop	{r3, pc}
 8022362:	bf00      	nop
 8022364:	1fff0094 	.word	0x1fff0094

08022368 <XMC_USBD_EndpointConfigure>:
 * Configures the given endpoint
 **/
XMC_USBD_STATUS_t XMC_USBD_EndpointConfigure(const uint8_t ep_addr,
		                                     const XMC_USBD_ENDPOINT_TYPE_t ep_type,
		                                     const uint16_t ep_max_packet_size) 
{
 8022368:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  daint_data_t daintmsk;
  XMC_USBD_EP_t *ep;
  daintmsk.d32 = xmc_device.device_register->daintmsk;  
 802236c:	4d9a      	ldr	r5, [pc, #616]	; (80225d8 <XMC_USBD_EndpointConfigure+0x270>)
  else
  {
    ep->maxTransferSize = (uint32_t)XMC_USBD_MAX_TRANSFER_SIZE_EP0;
  }
  /* transfer buffer */
  ep->inBuffer = XMC_USBD_EP_IN_BUFFER[ep->address_u.address_st.number];
 802236e:	f8df 826c 	ldr.w	r8, [pc, #620]	; 80225dc <XMC_USBD_EndpointConfigure+0x274>
		                                     const XMC_USBD_ENDPOINT_TYPE_t ep_type,
		                                     const uint16_t ep_max_packet_size) 
{
  daint_data_t daintmsk;
  XMC_USBD_EP_t *ep;
  daintmsk.d32 = xmc_device.device_register->daintmsk;  
 8022372:	f8d5 31a4 	ldr.w	r3, [r5, #420]	; 0x1a4
  }
  /* transfer buffer */
  ep->inBuffer = XMC_USBD_EP_IN_BUFFER[ep->address_u.address_st.number];
  ep->outBuffer = XMC_USBD_EP_OUT_BUFFER[ep->address_u.address_st.number];
  /* buffer size*/
  ep->inBufferSize = XMC_USBD_EP_IN_BUFFERSIZE[ep->address_u.address_st.number];
 8022376:	f8df a268 	ldr.w	sl, [pc, #616]	; 80225e0 <XMC_USBD_EndpointConfigure+0x278>
		                                     const XMC_USBD_ENDPOINT_TYPE_t ep_type,
		                                     const uint16_t ep_max_packet_size) 
{
  daint_data_t daintmsk;
  XMC_USBD_EP_t *ep;
  daintmsk.d32 = xmc_device.device_register->daintmsk;  
 802237a:	f8d3 e01c 	ldr.w	lr, [r3, #28]
  /* transfer buffer */
  ep->inBuffer = XMC_USBD_EP_IN_BUFFER[ep->address_u.address_st.number];
  ep->outBuffer = XMC_USBD_EP_OUT_BUFFER[ep->address_u.address_st.number];
  /* buffer size*/
  ep->inBufferSize = XMC_USBD_EP_IN_BUFFERSIZE[ep->address_u.address_st.number];
  ep->outBufferSize = XMC_USBD_EP_OUT_BUFFERSIZE[ep->address_u.address_st.number];
 802237e:	f8df 9264 	ldr.w	r9, [pc, #612]	; 80225e4 <XMC_USBD_EndpointConfigure+0x27c>
		                                     const uint16_t ep_max_packet_size) 
{
  daint_data_t daintmsk;
  XMC_USBD_EP_t *ep;
  daintmsk.d32 = xmc_device.device_register->daintmsk;  
  ep =&xmc_device.ep[ep_addr & (uint32_t)XMC_USBD_ENDPOINT_NUMBER_MASK];
 8022382:	f000 0c0f 	and.w	ip, r0, #15
  memset((void*)ep,0x0U,sizeof(XMC_USBD_EP_t)); /* clear endpoint structure */
 8022386:	2734      	movs	r7, #52	; 0x34
 8022388:	fb07 f70c 	mul.w	r7, r7, ip
 802238c:	19ee      	adds	r6, r5, r7
 802238e:	f106 0308 	add.w	r3, r6, #8
 8022392:	2400      	movs	r4, #0
 8022394:	51ec      	str	r4, [r5, r7]
 8022396:	6074      	str	r4, [r6, #4]
 8022398:	f843 4b04 	str.w	r4, [r3], #4
 802239c:	f843 4b04 	str.w	r4, [r3], #4
 80223a0:	f843 4b04 	str.w	r4, [r3], #4
 80223a4:	f843 4b04 	str.w	r4, [r3], #4
 80223a8:	f843 4b04 	str.w	r4, [r3], #4
 80223ac:	f843 4b04 	str.w	r4, [r3], #4
 80223b0:	f843 4b04 	str.w	r4, [r3], #4
 80223b4:	f843 4b04 	str.w	r4, [r3], #4
 80223b8:	f843 4b04 	str.w	r4, [r3], #4
 80223bc:	f843 4b04 	str.w	r4, [r3], #4
 80223c0:	601c      	str	r4, [r3, #0]
  /* do ep configuration */
  ep->address_u.address = ep_addr;
  ep->isConfigured = 1U;
 80223c2:	7933      	ldrb	r3, [r6, #4]
  XMC_USBD_EP_t *ep;
  daintmsk.d32 = xmc_device.device_register->daintmsk;  
  ep =&xmc_device.ep[ep_addr & (uint32_t)XMC_USBD_ENDPOINT_NUMBER_MASK];
  memset((void*)ep,0x0U,sizeof(XMC_USBD_EP_t)); /* clear endpoint structure */
  /* do ep configuration */
  ep->address_u.address = ep_addr;
 80223c4:	55e8      	strb	r0, [r5, r7]
  ep->isConfigured = 1U;
 80223c6:	f043 0304 	orr.w	r3, r3, #4
 80223ca:	7133      	strb	r3, [r6, #4]
  ep->maxPacketSize = (uint8_t)ep_max_packet_size;
 80223cc:	6874      	ldr	r4, [r6, #4]
 80223ce:	4633      	mov	r3, r6
 80223d0:	f362 24d1 	bfi	r4, r2, #11, #7
 80223d4:	f843 4f04 	str.w	r4, [r3, #4]!
  {
    ep->maxTransferSize = (uint32_t)XMC_USBD_MAX_TRANSFER_SIZE;
  }
  else
  {
    ep->maxTransferSize = (uint32_t)XMC_USBD_MAX_TRANSFER_SIZE_EP0;
 80223d8:	2800      	cmp	r0, #0
 80223da:	685c      	ldr	r4, [r3, #4]
 80223dc:	f64f 70c0 	movw	r0, #65472	; 0xffc0
 80223e0:	bf08      	it	eq
 80223e2:	2040      	moveq	r0, #64	; 0x40
 80223e4:	f360 0412 	bfi	r4, r0, #0, #19
 80223e8:	605c      	str	r4, [r3, #4]
  }
  /* transfer buffer */
  ep->inBuffer = XMC_USBD_EP_IN_BUFFER[ep->address_u.address_st.number];
 80223ea:	5deb      	ldrb	r3, [r5, r7]
 80223ec:	f003 030f 	and.w	r3, r3, #15
 80223f0:	0218      	lsls	r0, r3, #8
  ep->outBuffer = XMC_USBD_EP_OUT_BUFFER[ep->address_u.address_st.number];
 80223f2:	f508 6be0 	add.w	fp, r8, #1792	; 0x700
  else
  {
    ep->maxTransferSize = (uint32_t)XMC_USBD_MAX_TRANSFER_SIZE_EP0;
  }
  /* transfer buffer */
  ep->inBuffer = XMC_USBD_EP_IN_BUFFER[ep->address_u.address_st.number];
 80223f6:	eb08 0400 	add.w	r4, r8, r0
  ep->outBuffer = XMC_USBD_EP_OUT_BUFFER[ep->address_u.address_st.number];
 80223fa:	eb00 080b 	add.w	r8, r0, fp
  /* buffer size*/
  ep->inBufferSize = XMC_USBD_EP_IN_BUFFERSIZE[ep->address_u.address_st.number];
 80223fe:	f85a 0023 	ldr.w	r0, [sl, r3, lsl #2]
 8022402:	6230      	str	r0, [r6, #32]
  ep->outBufferSize = XMC_USBD_EP_OUT_BUFFERSIZE[ep->address_u.address_st.number];
 8022404:	f859 0023 	ldr.w	r0, [r9, r3, lsl #2]
 8022408:	6170      	str	r0, [r6, #20]
  else
  {
    ep->maxTransferSize = (uint32_t)XMC_USBD_MAX_TRANSFER_SIZE_EP0;
  }
  /* transfer buffer */
  ep->inBuffer = XMC_USBD_EP_IN_BUFFER[ep->address_u.address_st.number];
 802240a:	61f4      	str	r4, [r6, #28]
  ep->outBuffer = XMC_USBD_EP_OUT_BUFFER[ep->address_u.address_st.number];
 802240c:	f8c6 800c 	str.w	r8, [r6, #12]
  /* buffer size*/
  ep->inBufferSize = XMC_USBD_EP_IN_BUFFERSIZE[ep->address_u.address_st.number];
  ep->outBufferSize = XMC_USBD_EP_OUT_BUFFERSIZE[ep->address_u.address_st.number];
  /* is in */
  if ((ep->address_u.address_st.direction == 1U) || (ep_type == XMC_USBD_ENDPOINT_TYPE_CONTROL))
 8022410:	5de8      	ldrb	r0, [r5, r7]
 8022412:	0600      	lsls	r0, r0, #24
 8022414:	d41f      	bmi.n	8022456 <XMC_USBD_EndpointConfigure+0xee>
 8022416:	2900      	cmp	r1, #0
 8022418:	d07f      	beq.n	802251a <XMC_USBD_EndpointConfigure+0x1b2>
  }
  if ((ep->address_u.address_st.direction == 0U) || (ep_type == XMC_USBD_ENDPOINT_TYPE_CONTROL))
  {
    /* is out */
		depctl_data_t data;
		data.d32 = xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl;
 802241a:	eb05 0483 	add.w	r4, r5, r3, lsl #2
 802241e:	2001      	movs	r0, #1
 8022420:	f8d4 61c4 	ldr.w	r6, [r4, #452]	; 0x1c4
 8022424:	6834      	ldr	r4, [r6, #0]
 8022426:	4098      	lsls	r0, r3
		/*enable endpoint */
		data.b.usbactep = 1U;
 8022428:	f444 4400 	orr.w	r4, r4, #32768	; 0x8000
		/* set ep type */
		data.b.eptype = (uint8_t)ep_type;
 802242c:	f361 4493 	bfi	r4, r1, #18, #2
 8022430:	b280      	uxth	r0, r0
					break;
			}
		}
		else
		{
			data.b.mps = ep_max_packet_size;
 8022432:	f362 040a 	bfi	r4, r2, #0, #11
		}
		/* set first data0 pid */
		data.b.setd0pid = 1U;
 8022436:	f044 5480 	orr.w	r4, r4, #268435456	; 0x10000000
		/* clear stall */
		data.b.stall =(uint8_t) 0U;
 802243a:	f36f 5455 	bfc	r4, #21, #1
		xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl = data.d32; /* configure endpoint */
		daintmsk.ep.out |=(uint16_t) ((uint16_t)1U << (uint8_t)ep->address_u.address_st.number); /* enable interrupts */
 802243e:	ea40 401e 	orr.w	r0, r0, lr, lsr #16
		}
		/* set first data0 pid */
		data.b.setd0pid = 1U;
		/* clear stall */
		data.b.stall =(uint8_t) 0U;
		xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl = data.d32; /* configure endpoint */
 8022442:	6034      	str	r4, [r6, #0]
		daintmsk.ep.out |=(uint16_t) ((uint16_t)1U << (uint8_t)ep->address_u.address_st.number); /* enable interrupts */
 8022444:	f360 4e1f 	bfi	lr, r0, #16, #16
  }
  xmc_device.device_register->daintmsk = daintmsk.d32;
 8022448:	f8d5 31a4 	ldr.w	r3, [r5, #420]	; 0x1a4
  return XMC_USBD_STATUS_OK;
}
 802244c:	2000      	movs	r0, #0
		/* clear stall */
		data.b.stall =(uint8_t) 0U;
		xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl = data.d32; /* configure endpoint */
		daintmsk.ep.out |=(uint16_t) ((uint16_t)1U << (uint8_t)ep->address_u.address_st.number); /* enable interrupts */
  }
  xmc_device.device_register->daintmsk = daintmsk.d32;
 802244e:	f8c3 e01c 	str.w	lr, [r3, #28]
  return XMC_USBD_STATUS_OK;
}
 8022452:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  ep->outBufferSize = XMC_USBD_EP_OUT_BUFFERSIZE[ep->address_u.address_st.number];
  /* is in */
  if ((ep->address_u.address_st.direction == 1U) || (ep_type == XMC_USBD_ENDPOINT_TYPE_CONTROL))
  {
    depctl_data_t data;
    data.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl;
 8022456:	f103 006a 	add.w	r0, r3, #106	; 0x6a
 802245a:	f855 6020 	ldr.w	r6, [r5, r0, lsl #2]
 802245e:	6834      	ldr	r4, [r6, #0]
		/*enable endpoint */
		data.b.usbactep = 1U;
 8022460:	f444 4400 	orr.w	r4, r4, #32768	; 0x8000
		/* set ep type */
		data.b.eptype = (uint8_t)ep_type;
 8022464:	f361 4493 	bfi	r4, r1, #18, #2
		/* set mps */
    if (ep_type == XMC_USBD_ENDPOINT_TYPE_CONTROL)
 8022468:	2900      	cmp	r1, #0
 802246a:	d05f      	beq.n	802252c <XMC_USBD_EndpointConfigure+0x1c4>
				break;
			}
		}
		else
		{
			data.b.mps = ep_max_packet_size;
 802246c:	f362 040a 	bfi	r4, r2, #0, #11
 8022470:	f8b5 01fc 	ldrh.w	r0, [r5, #508]	; 0x1fc
		}
		/* set first data0 pid */
		data.b.setd0pid = 1U;
 8022474:	f044 5480 	orr.w	r4, r4, #268435456	; 0x10000000
static uint8_t XMC_USBD_lAssignTXFifo(void) 
{
  uint16_t mask = 1U;
  uint8_t i = 0U;
  uint8_t result = 0U;
  while( (i < (uint8_t)XMC_USBD_NUM_TX_FIFOS)&&((xmc_device.txfifomsk & mask) != 0U))
 8022478:	f010 0701 	ands.w	r7, r0, #1
			data.b.mps = ep_max_packet_size;
		}
		/* set first data0 pid */
		data.b.setd0pid = 1U;
		/* clear stall */
		data.b.stall = 0U;
 802247c:	f36f 5455 	bfc	r4, #21, #1
static uint8_t XMC_USBD_lAssignTXFifo(void) 
{
  uint16_t mask = 1U;
  uint8_t i = 0U;
  uint8_t result = 0U;
  while( (i < (uint8_t)XMC_USBD_NUM_TX_FIFOS)&&((xmc_device.txfifomsk & mask) != 0U))
 8022480:	f000 808e 	beq.w	80225a0 <XMC_USBD_EndpointConfigure+0x238>
 8022484:	0787      	lsls	r7, r0, #30
 8022486:	f140 808e 	bpl.w	80225a6 <XMC_USBD_EndpointConfigure+0x23e>
 802248a:	0747      	lsls	r7, r0, #29
 802248c:	f140 808f 	bpl.w	80225ae <XMC_USBD_EndpointConfigure+0x246>
 8022490:	0707      	lsls	r7, r0, #28
 8022492:	f140 8090 	bpl.w	80225b6 <XMC_USBD_EndpointConfigure+0x24e>
 8022496:	06c7      	lsls	r7, r0, #27
 8022498:	f140 8091 	bpl.w	80225be <XMC_USBD_EndpointConfigure+0x256>
 802249c:	0687      	lsls	r7, r0, #26
 802249e:	f140 8092 	bpl.w	80225c6 <XMC_USBD_EndpointConfigure+0x25e>
 80224a2:	0647      	lsls	r7, r0, #25
 80224a4:	f140 8093 	bpl.w	80225ce <XMC_USBD_EndpointConfigure+0x266>
  {
    mask = (uint16_t)(mask << 1U);
    i++;
  }
  if ((xmc_device.txfifomsk & mask) == 0U)
 80224a8:	0607      	lsls	r7, r0, #24
 80224aa:	d449      	bmi.n	8022540 <XMC_USBD_EndpointConfigure+0x1d8>
 80224ac:	2707      	movs	r7, #7
  uint16_t mask = 1U;
  uint8_t i = 0U;
  uint8_t result = 0U;
  while( (i < (uint8_t)XMC_USBD_NUM_TX_FIFOS)&&((xmc_device.txfifomsk & mask) != 0U))
  {
    mask = (uint16_t)(mask << 1U);
 80224ae:	f04f 0880 	mov.w	r8, #128	; 0x80
    i++;
  }
  if ((xmc_device.txfifomsk & mask) == 0U)
  {
    xmc_device.txfifomsk |= mask;
 80224b2:	ea48 0000 	orr.w	r0, r8, r0
 80224b6:	f8a5 01fc 	strh.w	r0, [r5, #508]	; 0x1fc
		/* set first data0 pid */
		data.b.setd0pid = 1U;
		/* clear stall */
		data.b.stall = 0U;
		/* set tx fifo */
		ep->txFifoNum = XMC_USBD_lAssignTXFifo(); /* get tx fifo */
 80224ba:	2034      	movs	r0, #52	; 0x34
 80224bc:	fb00 fc0c 	mul.w	ip, r0, ip
 80224c0:	eb05 090c 	add.w	r9, r5, ip
		data.b.txfnum = ep->txFifoNum;
 80224c4:	f367 5499 	bfi	r4, r7, #22, #4
		/* set first data0 pid */
		data.b.setd0pid = 1U;
		/* clear stall */
		data.b.stall = 0U;
		/* set tx fifo */
		ep->txFifoNum = XMC_USBD_lAssignTXFifo(); /* get tx fifo */
 80224c8:	f8b9 a004 	ldrh.w	sl, [r9, #4]
 80224cc:	f8df 8108 	ldr.w	r8, [pc, #264]	; 80225d8 <XMC_USBD_EndpointConfigure+0x270>
 80224d0:	f367 1a89 	bfi	sl, r7, #6, #4
 80224d4:	f8a9 a004 	strh.w	sl, [r9, #4]
		data.b.txfnum = ep->txFifoNum;
		xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = data.d32; /* configure endpoint */
		daintmsk.ep.in |= (uint16_t)((uint16_t)1U << (uint8_t)ep->address_u.address_st.number); /* enable interrupts for endpoint */
 80224d8:	2001      	movs	r0, #1
		/* clear stall */
		data.b.stall = 0U;
		/* set tx fifo */
		ep->txFifoNum = XMC_USBD_lAssignTXFifo(); /* get tx fifo */
		data.b.txfnum = ep->txFifoNum;
		xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = data.d32; /* configure endpoint */
 80224da:	6034      	str	r4, [r6, #0]
		daintmsk.ep.in |= (uint16_t)((uint16_t)1U << (uint8_t)ep->address_u.address_st.number); /* enable interrupts for endpoint */
 80224dc:	4098      	lsls	r0, r3
  }
  if ((ep->address_u.address_st.direction == 0U) || (ep_type == XMC_USBD_ENDPOINT_TYPE_CONTROL))
 80224de:	f815 400c 	ldrb.w	r4, [r5, ip]
		data.b.stall = 0U;
		/* set tx fifo */
		ep->txFifoNum = XMC_USBD_lAssignTXFifo(); /* get tx fifo */
		data.b.txfnum = ep->txFifoNum;
		xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = data.d32; /* configure endpoint */
		daintmsk.ep.in |= (uint16_t)((uint16_t)1U << (uint8_t)ep->address_u.address_st.number); /* enable interrupts for endpoint */
 80224e2:	b280      	uxth	r0, r0
 80224e4:	ea40 060e 	orr.w	r6, r0, lr
  }
  if ((ep->address_u.address_st.direction == 0U) || (ep_type == XMC_USBD_ENDPOINT_TYPE_CONTROL))
 80224e8:	0624      	lsls	r4, r4, #24
		data.b.stall = 0U;
		/* set tx fifo */
		ep->txFifoNum = XMC_USBD_lAssignTXFifo(); /* get tx fifo */
		data.b.txfnum = ep->txFifoNum;
		xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = data.d32; /* configure endpoint */
		daintmsk.ep.in |= (uint16_t)((uint16_t)1U << (uint8_t)ep->address_u.address_st.number); /* enable interrupts for endpoint */
 80224ea:	f366 0e0f 	bfi	lr, r6, #0, #16
  }
  if ((ep->address_u.address_st.direction == 0U) || (ep_type == XMC_USBD_ENDPOINT_TYPE_CONTROL))
 80224ee:	d529      	bpl.n	8022544 <XMC_USBD_EndpointConfigure+0x1dc>
 80224f0:	2900      	cmp	r1, #0
 80224f2:	d1a9      	bne.n	8022448 <XMC_USBD_EndpointConfigure+0xe0>
  {
    /* is out */
		depctl_data_t data;
		data.d32 = xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl;
 80224f4:	eb08 0383 	add.w	r3, r8, r3, lsl #2
 80224f8:	f8d3 61c4 	ldr.w	r6, [r3, #452]	; 0x1c4
 80224fc:	6834      	ldr	r4, [r6, #0]
		/*enable endpoint */
		data.b.usbactep = 1U;
 80224fe:	f444 4400 	orr.w	r4, r4, #32768	; 0x8000
		/* set ep type */
		data.b.eptype = (uint8_t)ep_type;
 8022502:	f361 4493 	bfi	r4, r1, #18, #2
    /* set mps */
    if (ep_type == XMC_USBD_ENDPOINT_TYPE_CONTROL)
		{
			switch(ep_max_packet_size)
 8022506:	2a10      	cmp	r2, #16
 8022508:	d03c      	beq.n	8022584 <XMC_USBD_EndpointConfigure+0x21c>
 802250a:	d934      	bls.n	8022576 <XMC_USBD_EndpointConfigure+0x20e>
 802250c:	2a20      	cmp	r2, #32
 802250e:	d02e      	beq.n	802256e <XMC_USBD_EndpointConfigure+0x206>
 8022510:	2a40      	cmp	r2, #64	; 0x40
 8022512:	d190      	bne.n	8022436 <XMC_USBD_EndpointConfigure+0xce>
			{
				case (64U):
					data.b.mps = 0x0U;
 8022514:	f36f 040a 	bfc	r4, #0, #11
					break;
 8022518:	e78d      	b.n	8022436 <XMC_USBD_EndpointConfigure+0xce>
  ep->outBufferSize = XMC_USBD_EP_OUT_BUFFERSIZE[ep->address_u.address_st.number];
  /* is in */
  if ((ep->address_u.address_st.direction == 1U) || (ep_type == XMC_USBD_ENDPOINT_TYPE_CONTROL))
  {
    depctl_data_t data;
    data.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl;
 802251a:	f103 006a 	add.w	r0, r3, #106	; 0x6a
 802251e:	f855 6020 	ldr.w	r6, [r5, r0, lsl #2]
 8022522:	6834      	ldr	r4, [r6, #0]
		/*enable endpoint */
		data.b.usbactep = 1U;
 8022524:	f444 4400 	orr.w	r4, r4, #32768	; 0x8000
		/* set ep type */
		data.b.eptype = (uint8_t)ep_type;
 8022528:	f361 4493 	bfi	r4, r1, #18, #2
		/* set mps */
    if (ep_type == XMC_USBD_ENDPOINT_TYPE_CONTROL)
    {
			switch(ep_max_packet_size)
 802252c:	2a10      	cmp	r2, #16
 802252e:	d031      	beq.n	8022594 <XMC_USBD_EndpointConfigure+0x22c>
 8022530:	d915      	bls.n	802255e <XMC_USBD_EndpointConfigure+0x1f6>
 8022532:	2a20      	cmp	r2, #32
 8022534:	d02a      	beq.n	802258c <XMC_USBD_EndpointConfigure+0x224>
 8022536:	2a40      	cmp	r2, #64	; 0x40
 8022538:	d19a      	bne.n	8022470 <XMC_USBD_EndpointConfigure+0x108>
			{
				case (64U):
				data.b.mps = 0x0U;
 802253a:	f36f 040a 	bfc	r4, #0, #11
				break;
 802253e:	e797      	b.n	8022470 <XMC_USBD_EndpointConfigure+0x108>
  while( (i < (uint8_t)XMC_USBD_NUM_TX_FIFOS)&&((xmc_device.txfifomsk & mask) != 0U))
  {
    mask = (uint16_t)(mask << 1U);
    i++;
  }
  if ((xmc_device.txfifomsk & mask) == 0U)
 8022540:	2700      	movs	r7, #0
 8022542:	e7ba      	b.n	80224ba <XMC_USBD_EndpointConfigure+0x152>
  }
  if ((ep->address_u.address_st.direction == 0U) || (ep_type == XMC_USBD_ENDPOINT_TYPE_CONTROL))
  {
    /* is out */
		depctl_data_t data;
		data.d32 = xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl;
 8022544:	eb08 0383 	add.w	r3, r8, r3, lsl #2
 8022548:	f8d3 61c4 	ldr.w	r6, [r3, #452]	; 0x1c4
 802254c:	6834      	ldr	r4, [r6, #0]
		/*enable endpoint */
		data.b.usbactep = 1U;
 802254e:	f444 4400 	orr.w	r4, r4, #32768	; 0x8000
		/* set ep type */
		data.b.eptype = (uint8_t)ep_type;
 8022552:	f361 4493 	bfi	r4, r1, #18, #2
    /* set mps */
    if (ep_type == XMC_USBD_ENDPOINT_TYPE_CONTROL)
 8022556:	2900      	cmp	r1, #0
 8022558:	f47f af6b 	bne.w	8022432 <XMC_USBD_EndpointConfigure+0xca>
 802255c:	e7d3      	b.n	8022506 <XMC_USBD_EndpointConfigure+0x19e>
		/* set ep type */
		data.b.eptype = (uint8_t)ep_type;
		/* set mps */
    if (ep_type == XMC_USBD_ENDPOINT_TYPE_CONTROL)
    {
			switch(ep_max_packet_size)
 802255e:	2a08      	cmp	r2, #8
 8022560:	d186      	bne.n	8022470 <XMC_USBD_EndpointConfigure+0x108>
				break;
				case (16U):
				data.b.mps = 0x2U;
				break;
				case (8U):
				data.b.mps = 0x3U;
 8022562:	2703      	movs	r7, #3
 8022564:	f855 6020 	ldr.w	r6, [r5, r0, lsl #2]
 8022568:	f367 040a 	bfi	r4, r7, #0, #11
				break;
 802256c:	e780      	b.n	8022470 <XMC_USBD_EndpointConfigure+0x108>
			{
				case (64U):
					data.b.mps = 0x0U;
					break;
				case (32U):
					data.b.mps = 0x1U;
 802256e:	2301      	movs	r3, #1
 8022570:	f363 040a 	bfi	r4, r3, #0, #11
					break;
 8022574:	e75f      	b.n	8022436 <XMC_USBD_EndpointConfigure+0xce>
		/* set ep type */
		data.b.eptype = (uint8_t)ep_type;
    /* set mps */
    if (ep_type == XMC_USBD_ENDPOINT_TYPE_CONTROL)
		{
			switch(ep_max_packet_size)
 8022576:	2a08      	cmp	r2, #8
 8022578:	f47f af5d 	bne.w	8022436 <XMC_USBD_EndpointConfigure+0xce>
					break;
				case (16U):
					data.b.mps = 0x2U;
					break;
				case (8U):
					data.b.mps = 0x3U;
 802257c:	2303      	movs	r3, #3
 802257e:	f363 040a 	bfi	r4, r3, #0, #11
					break;
 8022582:	e758      	b.n	8022436 <XMC_USBD_EndpointConfigure+0xce>
					break;
				case (32U):
					data.b.mps = 0x1U;
					break;
				case (16U):
					data.b.mps = 0x2U;
 8022584:	2302      	movs	r3, #2
 8022586:	f363 040a 	bfi	r4, r3, #0, #11
					break;
 802258a:	e754      	b.n	8022436 <XMC_USBD_EndpointConfigure+0xce>
			{
				case (64U):
				data.b.mps = 0x0U;
				break;
				case (32U):
				data.b.mps = 0x1U;
 802258c:	2001      	movs	r0, #1
 802258e:	f360 040a 	bfi	r4, r0, #0, #11
				break;
 8022592:	e76d      	b.n	8022470 <XMC_USBD_EndpointConfigure+0x108>
				case (16U):
				data.b.mps = 0x2U;
 8022594:	2702      	movs	r7, #2
 8022596:	f855 6020 	ldr.w	r6, [r5, r0, lsl #2]
 802259a:	f367 040a 	bfi	r4, r7, #0, #11
				break;
 802259e:	e767      	b.n	8022470 <XMC_USBD_EndpointConfigure+0x108>
 *
 * @return Fifo number for a free fifo
 */
static uint8_t XMC_USBD_lAssignTXFifo(void) 
{
  uint16_t mask = 1U;
 80225a0:	f04f 0801 	mov.w	r8, #1
 80225a4:	e785      	b.n	80224b2 <XMC_USBD_EndpointConfigure+0x14a>
  uint8_t i = 0U;
  uint8_t result = 0U;
  while( (i < (uint8_t)XMC_USBD_NUM_TX_FIFOS)&&((xmc_device.txfifomsk & mask) != 0U))
  {
    mask = (uint16_t)(mask << 1U);
    i++;
 80225a6:	2701      	movs	r7, #1
  uint16_t mask = 1U;
  uint8_t i = 0U;
  uint8_t result = 0U;
  while( (i < (uint8_t)XMC_USBD_NUM_TX_FIFOS)&&((xmc_device.txfifomsk & mask) != 0U))
  {
    mask = (uint16_t)(mask << 1U);
 80225a8:	f04f 0802 	mov.w	r8, #2
 80225ac:	e781      	b.n	80224b2 <XMC_USBD_EndpointConfigure+0x14a>
    i++;
 80225ae:	2702      	movs	r7, #2
  uint16_t mask = 1U;
  uint8_t i = 0U;
  uint8_t result = 0U;
  while( (i < (uint8_t)XMC_USBD_NUM_TX_FIFOS)&&((xmc_device.txfifomsk & mask) != 0U))
  {
    mask = (uint16_t)(mask << 1U);
 80225b0:	f04f 0804 	mov.w	r8, #4
 80225b4:	e77d      	b.n	80224b2 <XMC_USBD_EndpointConfigure+0x14a>
    i++;
 80225b6:	2703      	movs	r7, #3
  uint16_t mask = 1U;
  uint8_t i = 0U;
  uint8_t result = 0U;
  while( (i < (uint8_t)XMC_USBD_NUM_TX_FIFOS)&&((xmc_device.txfifomsk & mask) != 0U))
  {
    mask = (uint16_t)(mask << 1U);
 80225b8:	f04f 0808 	mov.w	r8, #8
 80225bc:	e779      	b.n	80224b2 <XMC_USBD_EndpointConfigure+0x14a>
    i++;
 80225be:	2704      	movs	r7, #4
  uint16_t mask = 1U;
  uint8_t i = 0U;
  uint8_t result = 0U;
  while( (i < (uint8_t)XMC_USBD_NUM_TX_FIFOS)&&((xmc_device.txfifomsk & mask) != 0U))
  {
    mask = (uint16_t)(mask << 1U);
 80225c0:	f04f 0810 	mov.w	r8, #16
 80225c4:	e775      	b.n	80224b2 <XMC_USBD_EndpointConfigure+0x14a>
    i++;
 80225c6:	2705      	movs	r7, #5
  uint16_t mask = 1U;
  uint8_t i = 0U;
  uint8_t result = 0U;
  while( (i < (uint8_t)XMC_USBD_NUM_TX_FIFOS)&&((xmc_device.txfifomsk & mask) != 0U))
  {
    mask = (uint16_t)(mask << 1U);
 80225c8:	f04f 0820 	mov.w	r8, #32
 80225cc:	e771      	b.n	80224b2 <XMC_USBD_EndpointConfigure+0x14a>
    i++;
 80225ce:	2706      	movs	r7, #6
  uint16_t mask = 1U;
  uint8_t i = 0U;
  uint8_t result = 0U;
  while( (i < (uint8_t)XMC_USBD_NUM_TX_FIFOS)&&((xmc_device.txfifomsk & mask) != 0U))
  {
    mask = (uint16_t)(mask << 1U);
 80225d0:	f04f 0840 	mov.w	r8, #64	; 0x40
 80225d4:	e76d      	b.n	80224b2 <XMC_USBD_EndpointConfigure+0x14a>
 80225d6:	bf00      	nop
 80225d8:	1fff0094 	.word	0x1fff0094
 80225dc:	20000000 	.word	0x20000000
 80225e0:	1ffe97c0 	.word	0x1ffe97c0
 80225e4:	1ffe97a4 	.word	0x1ffe97a4

080225e8 <XMC_USBD_EndpointRead>:

/**
 * Reads the number of bytes from the USB OUT endpoint
 **/
int32_t XMC_USBD_EndpointRead(const uint8_t ep_num,uint8_t * buffer,uint32_t length) 
{
 80225e8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  XMC_USBD_EP_t *ep = &xmc_device.ep[ep_num];
  if (length > ep->outBytesAvailable)
 80225ea:	4f0e      	ldr	r7, [pc, #56]	; (8022624 <XMC_USBD_EndpointRead+0x3c>)
 80225ec:	2434      	movs	r4, #52	; 0x34
 80225ee:	fb04 7400 	mla	r4, r4, r0, r7

/**
 * Reads the number of bytes from the USB OUT endpoint
 **/
int32_t XMC_USBD_EndpointRead(const uint8_t ep_num,uint8_t * buffer,uint32_t length) 
{
 80225f2:	4606      	mov	r6, r0
  XMC_USBD_EP_t *ep = &xmc_device.ep[ep_num];
  if (length > ep->outBytesAvailable)
 80225f4:	6925      	ldr	r5, [r4, #16]
  {
    length = ep->outBytesAvailable;
  }
  memcpy(buffer,&ep->outBuffer[ep->outOffset],length);
 80225f6:	69a3      	ldr	r3, [r4, #24]
 80225f8:	4295      	cmp	r5, r2
 80225fa:	4608      	mov	r0, r1
 80225fc:	68e1      	ldr	r1, [r4, #12]
 80225fe:	bf28      	it	cs
 8022600:	4615      	movcs	r5, r2
 8022602:	4419      	add	r1, r3
 8022604:	462a      	mov	r2, r5
 8022606:	f00a ffa3 	bl	802d550 <memcpy>
  ep->outBytesAvailable -= length;
 802260a:	6923      	ldr	r3, [r4, #16]
 802260c:	1b5b      	subs	r3, r3, r5
 802260e:	6123      	str	r3, [r4, #16]
  if (ep->outBytesAvailable)
 8022610:	b10b      	cbz	r3, 8022616 <XMC_USBD_EndpointRead+0x2e>
  {
    ep->outOffset += length;
 8022612:	69a3      	ldr	r3, [r4, #24]
 8022614:	442b      	add	r3, r5
 8022616:	2234      	movs	r2, #52	; 0x34
 8022618:	fb02 7606 	mla	r6, r2, r6, r7
  else
  {
    ep->outOffset = 0U;
  }
  return (int32_t)length;
}
 802261c:	4628      	mov	r0, r5
 802261e:	61b3      	str	r3, [r6, #24]
 8022620:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8022622:	bf00      	nop
 8022624:	1fff0094 	.word	0x1fff0094

08022628 <XMC_USBD_Init>:

/**
 * Initializes the USB device
 **/
XMC_USBD_STATUS_t XMC_USBD_Init(XMC_USBD_t *obj)
{
 8022628:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802262c:	4607      	mov	r7, r0
 802262e:	b083      	sub	sp, #12
 * Enables the USB0 module
 **/
void XMC_USBD_Enable(void) 
{
#if defined(CLOCK_GATING_SUPPORTED)
  XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_USB0);
 8022630:	4869      	ldr	r0, [pc, #420]	; (80227d8 <XMC_USBD_Init+0x1b0>)
	  XMC_USBD_EP_OUT_BUFFERSIZE[i] = XMC_USBD_EP0_BUFFER_SIZE;
	  XMC_USBD_EP_IN_BUFFERSIZE[i] 	= XMC_USBD_EP0_BUFFER_SIZE;
  }

  /* clear device status */
  memset((void*)&xmc_device,0x0U,sizeof(XMC_USBD_DEVICE_t));
 8022632:	4c6a      	ldr	r4, [pc, #424]	; (80227dc <XMC_USBD_Init+0x1b4>)
  usbd_init = obj;

  /* Filling out buffer size */
  for(i = 0U;i < (uint32_t)XMC_USBD_NUM_EPS;i++)
  {
	  XMC_USBD_EP_OUT_BUFFERSIZE[i] = XMC_USBD_EP0_BUFFER_SIZE;
 8022634:	4e6a      	ldr	r6, [pc, #424]	; (80227e0 <XMC_USBD_Init+0x1b8>)
	  XMC_USBD_EP_IN_BUFFERSIZE[i] 	= XMC_USBD_EP0_BUFFER_SIZE;
 8022636:	4d6b      	ldr	r5, [pc, #428]	; (80227e4 <XMC_USBD_Init+0x1bc>)
 * Enables the USB0 module
 **/
void XMC_USBD_Enable(void) 
{
#if defined(CLOCK_GATING_SUPPORTED)
  XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_USB0);
 8022638:	f7fe fd4e 	bl	80210d8 <XMC_SCU_CLOCK_UngatePeripheralClock>
#endif
  /* Reset and power up */
  XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_USB0);
 802263c:	4866      	ldr	r0, [pc, #408]	; (80227d8 <XMC_USBD_Init+0x1b0>)
 802263e:	f7fe fccf 	bl	8020fe0 <XMC_SCU_RESET_DeassertPeripheralReset>
  XMC_SCU_POWER_EnableUsb();
 8022642:	f7fe fd87 	bl	8021154 <XMC_SCU_POWER_EnableUsb>
  XMC_ASSERT("XMC_USBD_Init: obj.usbd_max_num_eps not of type XMC_USBD_MAX_NUM_EPS_t",
 		      XMC_USBD_CHECK_INPUT_MAX_NUM_EPS(obj->usbd_max_num_eps))
  
  XMC_USBD_Enable();
  
  usbd_init = obj;
 8022646:	4b68      	ldr	r3, [pc, #416]	; (80227e8 <XMC_USBD_Init+0x1c0>)
	  XMC_USBD_EP_OUT_BUFFERSIZE[i] = XMC_USBD_EP0_BUFFER_SIZE;
	  XMC_USBD_EP_IN_BUFFERSIZE[i] 	= XMC_USBD_EP0_BUFFER_SIZE;
  }

  /* clear device status */
  memset((void*)&xmc_device,0x0U,sizeof(XMC_USBD_DEVICE_t));
 8022648:	2100      	movs	r1, #0
  XMC_ASSERT("XMC_USBD_Init: obj.usbd_max_num_eps not of type XMC_USBD_MAX_NUM_EPS_t",
 		      XMC_USBD_CHECK_INPUT_MAX_NUM_EPS(obj->usbd_max_num_eps))
  
  XMC_USBD_Enable();
  
  usbd_init = obj;
 802264a:	601f      	str	r7, [r3, #0]
	  XMC_USBD_EP_OUT_BUFFERSIZE[i] = XMC_USBD_EP0_BUFFER_SIZE;
	  XMC_USBD_EP_IN_BUFFERSIZE[i] 	= XMC_USBD_EP0_BUFFER_SIZE;
  }

  /* clear device status */
  memset((void*)&xmc_device,0x0U,sizeof(XMC_USBD_DEVICE_t));
 802264c:	f44f 7202 	mov.w	r2, #520	; 0x208
  usbd_init = obj;

  /* Filling out buffer size */
  for(i = 0U;i < (uint32_t)XMC_USBD_NUM_EPS;i++)
  {
	  XMC_USBD_EP_OUT_BUFFERSIZE[i] = XMC_USBD_EP0_BUFFER_SIZE;
 8022650:	2340      	movs	r3, #64	; 0x40
	  XMC_USBD_EP_IN_BUFFERSIZE[i] 	= XMC_USBD_EP0_BUFFER_SIZE;
  }

  /* clear device status */
  memset((void*)&xmc_device,0x0U,sizeof(XMC_USBD_DEVICE_t));
 8022652:	4620      	mov	r0, r4
  usbd_init = obj;

  /* Filling out buffer size */
  for(i = 0U;i < (uint32_t)XMC_USBD_NUM_EPS;i++)
  {
	  XMC_USBD_EP_OUT_BUFFERSIZE[i] = XMC_USBD_EP0_BUFFER_SIZE;
 8022654:	6033      	str	r3, [r6, #0]
 8022656:	6073      	str	r3, [r6, #4]
 8022658:	60b3      	str	r3, [r6, #8]
 802265a:	60f3      	str	r3, [r6, #12]
 802265c:	6133      	str	r3, [r6, #16]
 802265e:	6173      	str	r3, [r6, #20]
 8022660:	61b3      	str	r3, [r6, #24]
	  XMC_USBD_EP_IN_BUFFERSIZE[i] 	= XMC_USBD_EP0_BUFFER_SIZE;
 8022662:	602b      	str	r3, [r5, #0]
 8022664:	606b      	str	r3, [r5, #4]
 8022666:	60ab      	str	r3, [r5, #8]
 8022668:	60eb      	str	r3, [r5, #12]
 802266a:	612b      	str	r3, [r5, #16]
 802266c:	616b      	str	r3, [r5, #20]
 802266e:	61ab      	str	r3, [r5, #24]
  }

  /* clear device status */
  memset((void*)&xmc_device,0x0U,sizeof(XMC_USBD_DEVICE_t));
 8022670:	f00a ff79 	bl	802d566 <memset>

  /* assign callbacks */
  xmc_device.DeviceEvent_cb = obj->cb_xmc_device_event;
  xmc_device.EndpointEvent_cb = obj->cb_endpoint_event;
  XMC_USBD_BASE_ADDRESS = (uint8_t *)(obj->usbd);
 8022674:	683b      	ldr	r3, [r7, #0]
  /* Done by driver core */
  /* configure ahb details */  
  gahbcfg.d32 = xmc_device.global_register->gahbcfg;
  gahbcfg.b.glblintrmsk = 1U; /* enable interrupts ( global mask ) */
  gahbcfg.b.nptxfemplvl_txfemplvl = 1U;
  if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
 8022676:	7b7d      	ldrb	r5, [r7, #13]
    						(i * XMC_USBD_TX_FIFO_OFFSET));
  }
  /* obj data structure for endpoint 0 */
  /* Done by driver core */
  /* configure ahb details */  
  gahbcfg.d32 = xmc_device.global_register->gahbcfg;
 8022678:	689a      	ldr	r2, [r3, #8]

  /* clear device status */
  memset((void*)&xmc_device,0x0U,sizeof(XMC_USBD_DEVICE_t));

  /* assign callbacks */
  xmc_device.DeviceEvent_cb = obj->cb_xmc_device_event;
 802267a:	6878      	ldr	r0, [r7, #4]
  xmc_device.EndpointEvent_cb = obj->cb_endpoint_event;
 802267c:	68be      	ldr	r6, [r7, #8]
  /* Done by driver core */
  /* configure ahb details */  
  gahbcfg.d32 = xmc_device.global_register->gahbcfg;
  gahbcfg.b.glblintrmsk = 1U; /* enable interrupts ( global mask ) */
  gahbcfg.b.nptxfemplvl_txfemplvl = 1U;
  if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
 802267e:	fab5 f185 	clz	r1, r5
  xmc_device.DeviceEvent_cb = obj->cb_xmc_device_event;
  xmc_device.EndpointEvent_cb = obj->cb_endpoint_event;
  XMC_USBD_BASE_ADDRESS = (uint8_t *)(obj->usbd);
  /* assign register address */
  xmc_device.global_register = (dwc_otg_core_global_regs_t*)(obj->usbd);
  xmc_device.device_register = ((dwc_otg_device_global_regs_t*)(XMC_USBD_BASE_ADDRESS + DWC_DEV_GLOBAL_REG_OFFSET));
 8022682:	f503 6a00 	add.w	sl, r3, #2048	; 0x800
  /* Done by driver core */
  /* configure ahb details */  
  gahbcfg.d32 = xmc_device.global_register->gahbcfg;
  gahbcfg.b.glblintrmsk = 1U; /* enable interrupts ( global mask ) */
  gahbcfg.b.nptxfemplvl_txfemplvl = 1U;
  if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
 8022686:	0949      	lsrs	r1, r1, #5
  /* assign register address */
  xmc_device.global_register = (dwc_otg_core_global_regs_t*)(obj->usbd);
  xmc_device.device_register = ((dwc_otg_device_global_regs_t*)(XMC_USBD_BASE_ADDRESS + DWC_DEV_GLOBAL_REG_OFFSET));
  for (i = 0U;i < (uint32_t)XMC_USBD_NUM_EPS;i++)
  {
    xmc_device.endpoint_in_register[i] = (dwc_otg_dev_in_ep_regs_t*)(XMC_USBD_BASE_ADDRESS + DWC_DEV_IN_EP_REG_OFFSET +
 8022688:	f503 6910 	add.w	r9, r3, #2304	; 0x900
  /* obj data structure for endpoint 0 */
  /* Done by driver core */
  /* configure ahb details */  
  gahbcfg.d32 = xmc_device.global_register->gahbcfg;
  gahbcfg.b.glblintrmsk = 1U; /* enable interrupts ( global mask ) */
  gahbcfg.b.nptxfemplvl_txfemplvl = 1U;
 802268c:	f042 0281 	orr.w	r2, r2, #129	; 0x81

  /* clear device status */
  memset((void*)&xmc_device,0x0U,sizeof(XMC_USBD_DEVICE_t));

  /* assign callbacks */
  xmc_device.DeviceEvent_cb = obj->cb_xmc_device_event;
 8022690:	f8c4 0200 	str.w	r0, [r4, #512]	; 0x200
  xmc_device.EndpointEvent_cb = obj->cb_endpoint_event;
 8022694:	f8c4 6204 	str.w	r6, [r4, #516]	; 0x204
  XMC_USBD_BASE_ADDRESS = (uint8_t *)(obj->usbd);
  /* assign register address */
  xmc_device.global_register = (dwc_otg_core_global_regs_t*)(obj->usbd);
  xmc_device.device_register = ((dwc_otg_device_global_regs_t*)(XMC_USBD_BASE_ADDRESS + DWC_DEV_GLOBAL_REG_OFFSET));
 8022698:	f8c4 a1a4 	str.w	sl, [r4, #420]	; 0x1a4
  for (i = 0U;i < (uint32_t)XMC_USBD_NUM_EPS;i++)
  {
    xmc_device.endpoint_in_register[i] = (dwc_otg_dev_in_ep_regs_t*)(XMC_USBD_BASE_ADDRESS + DWC_DEV_IN_EP_REG_OFFSET +
 802269c:	f8c4 91a8 	str.w	r9, [r4, #424]	; 0x1a8
 80226a0:	f361 1245 	bfi	r2, r1, #5, #1
 80226a4:	f503 6812 	add.w	r8, r3, #2336	; 0x920
 80226a8:	f503 6c14 	add.w	ip, r3, #2368	; 0x940
 80226ac:	f503 6e16 	add.w	lr, r3, #2400	; 0x960
 80226b0:	f503 6718 	add.w	r7, r3, #2432	; 0x980
 80226b4:	f503 601a 	add.w	r0, r3, #2464	; 0x9a0
 80226b8:	f503 6b1c 	add.w	fp, r3, #2496	; 0x9c0
    ((uint32_t)DWC_EP_REG_OFFSET*i));
  }
  for (i = 0U;i < (uint32_t)XMC_USBD_NUM_EPS;i++)
  {
    xmc_device.endpoint_out_register[i] = (dwc_otg_dev_out_ep_regs_t*)(XMC_USBD_BASE_ADDRESS +
    									  DWC_DEV_OUT_EP_REG_OFFSET +
 80226bc:	f503 6130 	add.w	r1, r3, #2816	; 0xb00
 80226c0:	f503 6632 	add.w	r6, r3, #2848	; 0xb20
 80226c4:	f503 6a34 	add.w	sl, r3, #2880	; 0xb40
 80226c8:	f503 6936 	add.w	r9, r3, #2912	; 0xb60
  /* assign register address */
  xmc_device.global_register = (dwc_otg_core_global_regs_t*)(obj->usbd);
  xmc_device.device_register = ((dwc_otg_device_global_regs_t*)(XMC_USBD_BASE_ADDRESS + DWC_DEV_GLOBAL_REG_OFFSET));
  for (i = 0U;i < (uint32_t)XMC_USBD_NUM_EPS;i++)
  {
    xmc_device.endpoint_in_register[i] = (dwc_otg_dev_in_ep_regs_t*)(XMC_USBD_BASE_ADDRESS + DWC_DEV_IN_EP_REG_OFFSET +
 80226cc:	f8c4 81ac 	str.w	r8, [r4, #428]	; 0x1ac
 80226d0:	f8c4 c1b0 	str.w	ip, [r4, #432]	; 0x1b0
 80226d4:	f8c4 e1b4 	str.w	lr, [r4, #436]	; 0x1b4
 80226d8:	f8c4 71b8 	str.w	r7, [r4, #440]	; 0x1b8
 80226dc:	f8c4 01bc 	str.w	r0, [r4, #444]	; 0x1bc
 80226e0:	f8c4 b1c0 	str.w	fp, [r4, #448]	; 0x1c0
    ((uint32_t)DWC_EP_REG_OFFSET*i));
  }
  for (i = 0U;i < (uint32_t)XMC_USBD_NUM_EPS;i++)
  {
    xmc_device.endpoint_out_register[i] = (dwc_otg_dev_out_ep_regs_t*)(XMC_USBD_BASE_ADDRESS +
 80226e4:	f8c4 11c4 	str.w	r1, [r4, #452]	; 0x1c4
 80226e8:	f8c4 61c8 	str.w	r6, [r4, #456]	; 0x1c8
 80226ec:	f8c4 a1cc 	str.w	sl, [r4, #460]	; 0x1cc
 80226f0:	f8c4 91d0 	str.w	r9, [r4, #464]	; 0x1d0
    									  ((uint32_t)DWC_EP_REG_OFFSET*i));
  }
  for (i = 0U;i < (uint32_t)XMC_USBD_NUM_TX_FIFOS;i++)
  {
    xmc_device.fifo[i] = (uint32_t*)(XMC_USBD_BASE_ADDRESS +
    						XMC_USBD_TX_FIFO_REG_OFFSET +
 80226f4:	f503 4180 	add.w	r1, r3, #16384	; 0x4000
    ((uint32_t)DWC_EP_REG_OFFSET*i));
  }
  for (i = 0U;i < (uint32_t)XMC_USBD_NUM_EPS;i++)
  {
    xmc_device.endpoint_out_register[i] = (dwc_otg_dev_out_ep_regs_t*)(XMC_USBD_BASE_ADDRESS +
    									  DWC_DEV_OUT_EP_REG_OFFSET +
 80226f8:	f503 6838 	add.w	r8, r3, #2944	; 0xb80
 80226fc:	f503 6c3a 	add.w	ip, r3, #2976	; 0xba0
 8022700:	f503 6e3c 	add.w	lr, r3, #3008	; 0xbc0
    									  ((uint32_t)DWC_EP_REG_OFFSET*i));
  }
  for (i = 0U;i < (uint32_t)XMC_USBD_NUM_TX_FIFOS;i++)
  {
    xmc_device.fifo[i] = (uint32_t*)(XMC_USBD_BASE_ADDRESS +
    						XMC_USBD_TX_FIFO_REG_OFFSET +
 8022704:	f503 5780 	add.w	r7, r3, #4096	; 0x1000
 8022708:	f503 5000 	add.w	r0, r3, #8192	; 0x2000
 802270c:	f503 5b40 	add.w	fp, r3, #12288	; 0x3000
 8022710:	f503 46a0 	add.w	r6, r3, #20480	; 0x5000
 8022714:	f503 4ac0 	add.w	sl, r3, #24576	; 0x6000
 8022718:	f503 49e0 	add.w	r9, r3, #28672	; 0x7000
    									  DWC_DEV_OUT_EP_REG_OFFSET +
    									  ((uint32_t)DWC_EP_REG_OFFSET*i));
  }
  for (i = 0U;i < (uint32_t)XMC_USBD_NUM_TX_FIFOS;i++)
  {
    xmc_device.fifo[i] = (uint32_t*)(XMC_USBD_BASE_ADDRESS +
 802271c:	f8c4 11ec 	str.w	r1, [r4, #492]	; 0x1ec
  /* assign callbacks */
  xmc_device.DeviceEvent_cb = obj->cb_xmc_device_event;
  xmc_device.EndpointEvent_cb = obj->cb_endpoint_event;
  XMC_USBD_BASE_ADDRESS = (uint8_t *)(obj->usbd);
  /* assign register address */
  xmc_device.global_register = (dwc_otg_core_global_regs_t*)(obj->usbd);
 8022720:	f8c4 31a0 	str.w	r3, [r4, #416]	; 0x1a0
    xmc_device.endpoint_in_register[i] = (dwc_otg_dev_in_ep_regs_t*)(XMC_USBD_BASE_ADDRESS + DWC_DEV_IN_EP_REG_OFFSET +
    ((uint32_t)DWC_EP_REG_OFFSET*i));
  }
  for (i = 0U;i < (uint32_t)XMC_USBD_NUM_EPS;i++)
  {
    xmc_device.endpoint_out_register[i] = (dwc_otg_dev_out_ep_regs_t*)(XMC_USBD_BASE_ADDRESS +
 8022724:	f8c4 81d4 	str.w	r8, [r4, #468]	; 0x1d4
 8022728:	f8c4 c1d8 	str.w	ip, [r4, #472]	; 0x1d8
 802272c:	f8c4 e1dc 	str.w	lr, [r4, #476]	; 0x1dc
    									  DWC_DEV_OUT_EP_REG_OFFSET +
    									  ((uint32_t)DWC_EP_REG_OFFSET*i));
  }
  for (i = 0U;i < (uint32_t)XMC_USBD_NUM_TX_FIFOS;i++)
  {
    xmc_device.fifo[i] = (uint32_t*)(XMC_USBD_BASE_ADDRESS +
 8022730:	f8c4 71e0 	str.w	r7, [r4, #480]	; 0x1e0
 8022734:	f8c4 01e4 	str.w	r0, [r4, #484]	; 0x1e4
 8022738:	f8c4 b1e8 	str.w	fp, [r4, #488]	; 0x1e8
 802273c:	f8c4 61f0 	str.w	r6, [r4, #496]	; 0x1f0
 8022740:	f8c4 a1f4 	str.w	sl, [r4, #500]	; 0x1f4
 8022744:	f8c4 91f8 	str.w	r9, [r4, #504]	; 0x1f8
  }
  else
  {
    gahbcfg.b.dmaenable = 0U;
  }
  xmc_device.global_register->gahbcfg = gahbcfg.d32;
 8022748:	609a      	str	r2, [r3, #8]
  /* configure usb details */  
  gusbcfg.d32= xmc_device.global_register->gusbcfg;
 802274a:	68d9      	ldr	r1, [r3, #12]
  gusbcfg.b.force_dev_mode = 1U; /* force us into device mode */
  gusbcfg.b.srpcap = 1U; /* enable session request protocoll */
 802274c:	f041 4180 	orr.w	r1, r1, #1073741824	; 0x40000000
 8022750:	f441 7180 	orr.w	r1, r1, #256	; 0x100
  xmc_device.global_register->gusbcfg = gusbcfg.d32;
 8022754:	60d9      	str	r1, [r3, #12]

  /* Device init */
  /* configure device speed */  
  dcfg.d32 = xmc_device.device_register->dcfg;
 8022756:	f8d3 2800 	ldr.w	r2, [r3, #2048]	; 0x800
  dcfg.b.devspd = XMC_USBD_DCFG_DEVSPD_FS;
 802275a:	f042 0203 	orr.w	r2, r2, #3
  dcfg.b.descdma = 0U;
 802275e:	f36f 52d7 	bfc	r2, #23, #1
  xmc_device.device_register->dcfg = dcfg.d32;
 8022762:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
  /* configure device functions */  
  dctl.d32 = xmc_device.device_register->dctl;
 8022766:	f8d3 2804 	ldr.w	r2, [r3, #2052]	; 0x804
 */
static void XMC_USBD_lFlushTXFifo(const uint8_t fifo_num) 
{
  volatile grstctl_t data;  
  uint32_t count;
  data.d32 = 0U;
 802276a:	2100      	movs	r1, #0
  dcfg.b.devspd = XMC_USBD_DCFG_DEVSPD_FS;
  dcfg.b.descdma = 0U;
  xmc_device.device_register->dcfg = dcfg.d32;
  /* configure device functions */  
  dctl.d32 = xmc_device.device_register->dctl;
  dctl.b.sftdiscon = 1U; /* disconnect the device until its connected by the user */
 802276c:	f042 0202 	orr.w	r2, r2, #2
  /* all other config is done by default register value */
  xmc_device.device_register->dctl = dctl.d32;
 8022770:	f8c3 2804 	str.w	r2, [r3, #2052]	; 0x804
 */
static void XMC_USBD_lFlushTXFifo(const uint8_t fifo_num) 
{
  volatile grstctl_t data;  
  uint32_t count;
  data.d32 = 0U;
 8022774:	9100      	str	r1, [sp, #0]
  /*flush fifo */
  data.b.txfflsh = 1U;
 8022776:	9a00      	ldr	r2, [sp, #0]
 8022778:	f042 0220 	orr.w	r2, r2, #32
 802277c:	9200      	str	r2, [sp, #0]
  data.b.txfnum = fifo_num;
 802277e:	9900      	ldr	r1, [sp, #0]
 8022780:	f421 61f8 	bic.w	r1, r1, #1984	; 0x7c0
 8022784:	f441 6180 	orr.w	r1, r1, #1024	; 0x400
 8022788:	9100      	str	r1, [sp, #0]
  xmc_device.global_register->grstctl = data.d32;
 802278a:	9a00      	ldr	r2, [sp, #0]
 802278c:	611a      	str	r2, [r3, #16]
  for (count = 0U;count < 1000U; count++){}
  do
  {
   data.d32 = xmc_device.global_register->grstctl;
 802278e:	691a      	ldr	r2, [r3, #16]
 8022790:	9200      	str	r2, [sp, #0]
  } while (data.b.txfflsh);
 8022792:	9a00      	ldr	r2, [sp, #0]
 8022794:	f3c2 1240 	ubfx	r2, r2, #5, #1
 8022798:	2a00      	cmp	r2, #0
 802279a:	d1f8      	bne.n	802278e <XMC_USBD_Init+0x166>
static void XMC_USBD_lFlushRXFifo(void) 
{
  volatile grstctl_t data;  
  uint32_t count;
	
	data.d32 = 0U;
 802279c:	9201      	str	r2, [sp, #4]
  data.b.rxfflsh = 1U;
 802279e:	9a01      	ldr	r2, [sp, #4]
 80227a0:	f042 0210 	orr.w	r2, r2, #16
 80227a4:	9201      	str	r2, [sp, #4]
  /* flush FIFO */
  xmc_device.global_register->grstctl = data.d32;
 80227a6:	9a01      	ldr	r2, [sp, #4]
 80227a8:	611a      	str	r2, [r3, #16]
  do
  {
    for (count = 0U; count < 1000U; count++){}
    data.d32 = xmc_device.global_register->grstctl;
 80227aa:	691a      	ldr	r2, [r3, #16]
 80227ac:	9201      	str	r2, [sp, #4]
  } while (data.b.rxfflsh);
 80227ae:	9801      	ldr	r0, [sp, #4]
 80227b0:	f3c0 1000 	ubfx	r0, r0, #4, #1
 80227b4:	2800      	cmp	r0, #0
 80227b6:	d1f8      	bne.n	80227aa <XMC_USBD_Init+0x182>
  gintmsk.b.usbsuspend = 1U;
  gintmsk.b.wkupintr = 1U;
  gintmsk.b.sofintr = 1U;
  if(obj->usbd_transfer_mode == XMC_USBD_USE_FIFO)
  {
    gintmsk.b.rxstsqlvl = 1U;
 80227b8:	490c      	ldr	r1, [pc, #48]	; (80227ec <XMC_USBD_Init+0x1c4>)
 80227ba:	4a0d      	ldr	r2, [pc, #52]	; (80227f0 <XMC_USBD_Init+0x1c8>)
  /* flush the fifos for proper operation */
  XMC_USBD_lFlushTXFifo((uint8_t)0x10U); /* 0x10 == all fifos, see doc */
  XMC_USBD_lFlushRXFifo();
  /* Enable Global Interrupts */
  /* clear interrupt status bits prior to unmasking */
  xmc_device.global_register->gintmsk = 0U; /* disable all interrupts */
 80227bc:	6198      	str	r0, [r3, #24]
  gintmsk.b.usbsuspend = 1U;
  gintmsk.b.wkupintr = 1U;
  gintmsk.b.sofintr = 1U;
  if(obj->usbd_transfer_mode == XMC_USBD_USE_FIFO)
  {
    gintmsk.b.rxstsqlvl = 1U;
 80227be:	2d01      	cmp	r5, #1
 80227c0:	bf18      	it	ne
 80227c2:	460a      	movne	r2, r1
  }
  gintmsk.b.outepintr = 1U;
  gintmsk.b.inepintr = 1U;
 80227c4:	f442 2240 	orr.w	r2, r2, #786432	; 0xc0000
  XMC_USBD_lFlushTXFifo((uint8_t)0x10U); /* 0x10 == all fifos, see doc */
  XMC_USBD_lFlushRXFifo();
  /* Enable Global Interrupts */
  /* clear interrupt status bits prior to unmasking */
  xmc_device.global_register->gintmsk = 0U; /* disable all interrupts */
  xmc_device.global_register->gintsts = 0xFFFFFFFFU; /* clear all interrupts */
 80227c8:	f04f 31ff 	mov.w	r1, #4294967295
 80227cc:	6159      	str	r1, [r3, #20]
  {
    gintmsk.b.rxstsqlvl = 1U;
  }
  gintmsk.b.outepintr = 1U;
  gintmsk.b.inepintr = 1U;
  xmc_device.global_register->gintmsk = gintmsk.d32;
 80227ce:	619a      	str	r2, [r3, #24]
  return XMC_USBD_STATUS_OK;
}
 80227d0:	b003      	add	sp, #12
 80227d2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80227d6:	bf00      	nop
 80227d8:	20000080 	.word	0x20000080
 80227dc:	1fff0094 	.word	0x1fff0094
 80227e0:	1ffe97a4 	.word	0x1ffe97a4
 80227e4:	1ffe97c0 	.word	0x1ffe97c0
 80227e8:	1fff0090 	.word	0x1fff0090
 80227ec:	c0003c0e 	.word	0xc0003c0e
 80227f0:	c0003c1e 	.word	0xc0003c1e

080227f4 <XMC_USBD_EndpointReadStart>:

/**
 * Prepares the endpoint to read next OUT packet
 **/
XMC_USBD_STATUS_t XMC_USBD_EndpointReadStart(const uint8_t ep_addr, uint32_t size) 
{
 80227f4:	b4f0      	push	{r4, r5, r6, r7}
  XMC_USBD_EP_t *ep = &xmc_device.ep[ep_addr & (uint8_t)XMC_USBD_EP_NUM_MASK];
 80227f6:	f000 000f 	and.w	r0, r0, #15
  XMC_USBD_STATUS_t result;
	
  if (ep->outInUse || !ep->isConfigured)
 80227fa:	2434      	movs	r4, #52	; 0x34
 80227fc:	4e33      	ldr	r6, [pc, #204]	; (80228cc <XMC_USBD_EndpointReadStart+0xd8>)
 80227fe:	fb04 f400 	mul.w	r4, r4, r0
 8022802:	1932      	adds	r2, r6, r4

/**
 * Prepares the endpoint to read next OUT packet
 **/
XMC_USBD_STATUS_t XMC_USBD_EndpointReadStart(const uint8_t ep_addr, uint32_t size) 
{
 8022804:	b082      	sub	sp, #8
  XMC_USBD_EP_t *ep = &xmc_device.ep[ep_addr & (uint8_t)XMC_USBD_EP_NUM_MASK];
  XMC_USBD_STATUS_t result;
	
  if (ep->outInUse || !ep->isConfigured)
 8022806:	6853      	ldr	r3, [r2, #4]
 8022808:	f3c3 1300 	ubfx	r3, r3, #4, #1
 802280c:	2b00      	cmp	r3, #0
 802280e:	d136      	bne.n	802287e <XMC_USBD_EndpointReadStart+0x8a>
 8022810:	7915      	ldrb	r5, [r2, #4]
 8022812:	076d      	lsls	r5, r5, #29
 8022814:	d533      	bpl.n	802287e <XMC_USBD_EndpointReadStart+0x8a>
{
  deptsiz_data_t data;
  depctl_data_t epctl;
	
  data.d32 =  0U;
  if ((ep->xferTotal - ep->xferLength) > ep->maxTransferSize)
 8022816:	6895      	ldr	r5, [r2, #8]
 8022818:	9501      	str	r5, [sp, #4]
 802281a:	6955      	ldr	r5, [r2, #20]
    }
    /* set ep values */
    ep->xferTotal = size;
    ep->xferCount = 0U;
    ep->xferLength = 0U;
    ep->xferBuffer = ep->outBuffer;
 802281c:	68d7      	ldr	r7, [r2, #12]
    {
      size = ep->outBufferSize;
    }
    /* set ep values */
    ep->xferTotal = size;
    ep->xferCount = 0U;
 802281e:	62d3      	str	r3, [r2, #44]	; 0x2c
 8022820:	42a9      	cmp	r1, r5
 8022822:	bf28      	it	cs
 8022824:	4629      	movcs	r1, r5
{
  deptsiz_data_t data;
  depctl_data_t epctl;
	
  data.d32 =  0U;
  if ((ep->xferTotal - ep->xferLength) > ep->maxTransferSize)
 8022826:	9d01      	ldr	r5, [sp, #4]
    /* set ep values */
    ep->xferTotal = size;
    ep->xferCount = 0U;
    ep->xferLength = 0U;
    ep->xferBuffer = ep->outBuffer;
    ep->outBytesAvailable = 0U;
 8022828:	6113      	str	r3, [r2, #16]
{
  deptsiz_data_t data;
  depctl_data_t epctl;
	
  data.d32 =  0U;
  if ((ep->xferTotal - ep->xferLength) > ep->maxTransferSize)
 802282a:	f3c5 0512 	ubfx	r5, r5, #0, #19
 802282e:	428d      	cmp	r5, r1
 8022830:	bf28      	it	cs
 8022832:	460d      	movcs	r5, r1
    if (size > ep->outBufferSize)
    {
      size = ep->outBufferSize;
    }
    /* set ep values */
    ep->xferTotal = size;
 8022834:	6311      	str	r1, [r2, #48]	; 0x30
 8022836:	6295      	str	r5, [r2, #40]	; 0x28
    ep->xferCount = 0U;
    ep->xferLength = 0U;
    ep->xferBuffer = ep->outBuffer;
 8022838:	6257      	str	r7, [r2, #36]	; 0x24
  }
  else
  {
    ep->xferLength = ep->xferTotal;
  }
  if (ep->address_u.address_st.number == 0U)
 802283a:	5d34      	ldrb	r4, [r6, r4]
 802283c:	0724      	lsls	r4, r4, #28
 802283e:	d022      	beq.n	8022886 <XMC_USBD_EndpointReadStart+0x92>
    ep0_data->b.xfersize = (uint8_t)ep->xferTotal;
  }
  else
  {
    /* If requested length is zero, just receive one zero length packet */
    if (ep->xferLength == 0U)
 8022840:	2d00      	cmp	r5, #0
 8022842:	d137      	bne.n	80228b4 <XMC_USBD_EndpointReadStart+0xc0>
    {
      data.b.xfersize = 0U;
      data.b.pktcnt = 1U;
 8022844:	2201      	movs	r2, #1
 8022846:	f362 43dc 	bfi	r3, r2, #19, #10
      /* setup endpoint to recive a amount of packages by given size */
      data.b.pktcnt = (uint16_t)(((ep->xferLength - ep->xferCount) + (ep->maxPacketSize -(uint32_t)1U))/ep->maxPacketSize);
      data.b.xfersize =(uint32_t)(ep->xferLength - ep->xferCount);
    }
  }
  if(usbd_init->usbd_transfer_mode == XMC_USBD_USE_DMA)
 802284a:	4a21      	ldr	r2, [pc, #132]	; (80228d0 <XMC_USBD_EndpointReadStart+0xdc>)
 802284c:	6812      	ldr	r2, [r2, #0]
 802284e:	7b52      	ldrb	r2, [r2, #13]
 8022850:	bb2a      	cbnz	r2, 802289e <XMC_USBD_EndpointReadStart+0xaa>
  {
    /* Programm dma address if needed */
    xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepdma = (uint32_t)(ep->xferBuffer);
 8022852:	2234      	movs	r2, #52	; 0x34
 8022854:	fb02 f000 	mul.w	r0, r2, r0
 8022858:	1831      	adds	r1, r6, r0
 802285a:	5c32      	ldrb	r2, [r6, r0]
 802285c:	6a49      	ldr	r1, [r1, #36]	; 0x24
 802285e:	f002 020f 	and.w	r2, r2, #15
 8022862:	eb06 0282 	add.w	r2, r6, r2, lsl #2
 8022866:	f8d2 21c4 	ldr.w	r2, [r2, #452]	; 0x1c4
 802286a:	6151      	str	r1, [r2, #20]
  }
  /* setup endpoint size and enable endpoint */
  xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doeptsiz = data.d32;
 802286c:	6113      	str	r3, [r2, #16]
 
  epctl.d32 = xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl;
 802286e:	6813      	ldr	r3, [r2, #0]
    ep->xferCount = 0U;
    ep->xferLength = 0U;
    ep->xferBuffer = ep->outBuffer;
    ep->outBytesAvailable = 0U;
    XMC_USBD_lStartReadXfer(ep);
    result= XMC_USBD_STATUS_OK;
 8022870:	2000      	movs	r0, #0
  /* setup endpoint size and enable endpoint */
  xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doeptsiz = data.d32;
 
  epctl.d32 = xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl;
  epctl.b.cnak = 1U;
  epctl.b.epena = 1U;
 8022872:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
  xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl = epctl.d32;
 8022876:	6013      	str	r3, [r2, #0]
    ep->outBytesAvailable = 0U;
    XMC_USBD_lStartReadXfer(ep);
    result= XMC_USBD_STATUS_OK;
  }
  return result;
}
 8022878:	b002      	add	sp, #8
 802287a:	bcf0      	pop	{r4, r5, r6, r7}
 802287c:	4770      	bx	lr
  XMC_USBD_EP_t *ep = &xmc_device.ep[ep_addr & (uint8_t)XMC_USBD_EP_NUM_MASK];
  XMC_USBD_STATUS_t result;
	
  if (ep->outInUse || !ep->isConfigured)
  {
    result = XMC_USBD_STATUS_ERROR;
 802287e:	2001      	movs	r0, #1
    ep->outBytesAvailable = 0U;
    XMC_USBD_lStartReadXfer(ep);
    result= XMC_USBD_STATUS_OK;
  }
  return result;
}
 8022880:	b002      	add	sp, #8
 8022882:	bcf0      	pop	{r4, r5, r6, r7}
 8022884:	4770      	bx	lr
  if (ep->address_u.address_st.number == 0U)
  {
	/* Setup the endpoint to receive 3 setup packages and one normal package.*/
	/* Cast the data pointer to use only one variable */
    deptsiz0_data_t *ep0_data = (deptsiz0_data_t*)&data;
    ep0_data->b.pktcnt = 0x1U;
 8022886:	2201      	movs	r2, #1
 8022888:	f362 43d4 	bfi	r3, r2, #19, #2
      /* setup endpoint to recive a amount of packages by given size */
      data.b.pktcnt = (uint16_t)(((ep->xferLength - ep->xferCount) + (ep->maxPacketSize -(uint32_t)1U))/ep->maxPacketSize);
      data.b.xfersize =(uint32_t)(ep->xferLength - ep->xferCount);
    }
  }
  if(usbd_init->usbd_transfer_mode == XMC_USBD_USE_DMA)
 802288c:	4a10      	ldr	r2, [pc, #64]	; (80228d0 <XMC_USBD_EndpointReadStart+0xdc>)
 802288e:	6812      	ldr	r2, [r2, #0]
 8022890:	7b52      	ldrb	r2, [r2, #13]
  {
	/* Setup the endpoint to receive 3 setup packages and one normal package.*/
	/* Cast the data pointer to use only one variable */
    deptsiz0_data_t *ep0_data = (deptsiz0_data_t*)&data;
    ep0_data->b.pktcnt = 0x1U;
    ep0_data->b.supcnt = 0x3U;
 8022892:	f043 43c0 	orr.w	r3, r3, #1610612736	; 0x60000000
    ep0_data->b.xfersize = (uint8_t)ep->xferTotal;
 8022896:	f361 0306 	bfi	r3, r1, #0, #7
      /* setup endpoint to recive a amount of packages by given size */
      data.b.pktcnt = (uint16_t)(((ep->xferLength - ep->xferCount) + (ep->maxPacketSize -(uint32_t)1U))/ep->maxPacketSize);
      data.b.xfersize =(uint32_t)(ep->xferLength - ep->xferCount);
    }
  }
  if(usbd_init->usbd_transfer_mode == XMC_USBD_USE_DMA)
 802289a:	2a00      	cmp	r2, #0
 802289c:	d0d9      	beq.n	8022852 <XMC_USBD_EndpointReadStart+0x5e>
 802289e:	2234      	movs	r2, #52	; 0x34
 80228a0:	fb02 f000 	mul.w	r0, r2, r0
 80228a4:	5c32      	ldrb	r2, [r6, r0]
 80228a6:	f002 020f 	and.w	r2, r2, #15
 80228aa:	eb06 0282 	add.w	r2, r6, r2, lsl #2
 80228ae:	f8d2 21c4 	ldr.w	r2, [r2, #452]	; 0x1c4
 80228b2:	e7db      	b.n	802286c <XMC_USBD_EndpointReadStart+0x78>
      data.b.pktcnt = 1U;
    }
    else
    {
      /* setup endpoint to recive a amount of packages by given size */
      data.b.pktcnt = (uint16_t)(((ep->xferLength - ep->xferCount) + (ep->maxPacketSize -(uint32_t)1U))/ep->maxPacketSize);
 80228b4:	6852      	ldr	r2, [r2, #4]
 80228b6:	f3c2 21c6 	ubfx	r1, r2, #11, #7
 80228ba:	1e4a      	subs	r2, r1, #1
 80228bc:	442a      	add	r2, r5
 80228be:	fbb2 f2f1 	udiv	r2, r2, r1
 80228c2:	f362 43dc 	bfi	r3, r2, #19, #10
      data.b.xfersize =(uint32_t)(ep->xferLength - ep->xferCount);
 80228c6:	f365 0312 	bfi	r3, r5, #0, #19
 80228ca:	e7be      	b.n	802284a <XMC_USBD_EndpointReadStart+0x56>
 80228cc:	1fff0094 	.word	0x1fff0094
 80228d0:	1fff0090 	.word	0x1fff0090

080228d4 <XMC_USBD_EndpointWrite>:

/**
 * Writes number of bytes in to the USB IN endpoint.
 **/
int32_t XMC_USBD_EndpointWrite(const uint8_t ep_num,const uint8_t * buffer,uint32_t length) 
{
 80228d4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  XMC_USBD_EP_t * ep = &xmc_device.ep[ep_num & (uint8_t)XMC_USBD_EP_NUM_MASK];
 80228d8:	f000 070f 	and.w	r7, r0, #15
  int32_t result;
  if (!ep->isConfigured)
 80228dc:	2634      	movs	r6, #52	; 0x34
 80228de:	4d39      	ldr	r5, [pc, #228]	; (80229c4 <XMC_USBD_EndpointWrite+0xf0>)
 80228e0:	fb06 f607 	mul.w	r6, r6, r7
 80228e4:	19ac      	adds	r4, r5, r6
 80228e6:	7923      	ldrb	r3, [r4, #4]
 80228e8:	075b      	lsls	r3, r3, #29
 80228ea:	d553      	bpl.n	8022994 <XMC_USBD_EndpointWrite+0xc0>
  {
    result = (int32_t)XMC_USBD_STATUS_ERROR;
  }
  else if (ep->inInUse == 1U)
 80228ec:	6863      	ldr	r3, [r4, #4]
 80228ee:	0718      	lsls	r0, r3, #28
 80228f0:	d457      	bmi.n	80229a2 <XMC_USBD_EndpointWrite+0xce>
  {
    result=(int32_t)0;
  }
  else
  {
    if (length > ep->inBufferSize)
 80228f2:	6a23      	ldr	r3, [r4, #32]
    {
      length = ep->inBufferSize;
    }
    /* copy data into input buffer for DMA and FIFO mode */
		memcpy(ep->inBuffer,(const void *)buffer,length);
 80228f4:	69e0      	ldr	r0, [r4, #28]
 80228f6:	429a      	cmp	r2, r3
 80228f8:	bf28      	it	cs
 80228fa:	461a      	movcs	r2, r3
 80228fc:	4691      	mov	r9, r2
 80228fe:	f00a fe27 	bl	802d550 <memcpy>
		ep->xferBuffer = ep->inBuffer;
    ep->xferTotal = length;
    /* set transfer values */
    ep->xferLength = 0U;
    ep->xferCount = 0U;
    ep->inInUse = 1U;
 8022902:	6863      	ldr	r3, [r4, #4]
    {
      length = ep->inBufferSize;
    }
    /* copy data into input buffer for DMA and FIFO mode */
		memcpy(ep->inBuffer,(const void *)buffer,length);
		ep->xferBuffer = ep->inBuffer;
 8022904:	f8d4 c01c 	ldr.w	ip, [r4, #28]
 8022908:	f8c4 c024 	str.w	ip, [r4, #36]	; 0x24
    ep->xferTotal = length;
    /* set transfer values */
    ep->xferLength = 0U;
    ep->xferCount = 0U;
    ep->inInUse = 1U;
 802290c:	f043 0308 	orr.w	r3, r3, #8
		memcpy(ep->inBuffer,(const void *)buffer,length);
		ep->xferBuffer = ep->inBuffer;
    ep->xferTotal = length;
    /* set transfer values */
    ep->xferLength = 0U;
    ep->xferCount = 0U;
 8022910:	2100      	movs	r1, #0
    ep->inInUse = 1U;
 8022912:	6063      	str	r3, [r4, #4]
		memcpy(ep->inBuffer,(const void *)buffer,length);
		ep->xferBuffer = ep->inBuffer;
    ep->xferTotal = length;
    /* set transfer values */
    ep->xferLength = 0U;
    ep->xferCount = 0U;
 8022914:	62e1      	str	r1, [r4, #44]	; 0x2c
      length = ep->inBufferSize;
    }
    /* copy data into input buffer for DMA and FIFO mode */
		memcpy(ep->inBuffer,(const void *)buffer,length);
		ep->xferBuffer = ep->inBuffer;
    ep->xferTotal = length;
 8022916:	f8c4 9030 	str.w	r9, [r4, #48]	; 0x30
{
  deptsiz_data_t size;
  depctl_data_t ctl;
	
  size.d32 = 0U;  
  ctl.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl;
 802291a:	5da8      	ldrb	r0, [r5, r6]

  if ((ep->xferTotal - ep->xferLength)  < ep->maxTransferSize)
 802291c:	68a3      	ldr	r3, [r4, #8]
{
  deptsiz_data_t size;
  depctl_data_t ctl;
	
  size.d32 = 0U;  
  ctl.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl;
 802291e:	f000 000f 	and.w	r0, r0, #15
 8022922:	f100 0e6a 	add.w	lr, r0, #106	; 0x6a

  if ((ep->xferTotal - ep->xferLength)  < ep->maxTransferSize)
 8022926:	f3c3 0212 	ubfx	r2, r3, #0, #19
{
  deptsiz_data_t size;
  depctl_data_t ctl;
	
  size.d32 = 0U;  
  ctl.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl;
 802292a:	f855 802e 	ldr.w	r8, [r5, lr, lsl #2]
 802292e:	454a      	cmp	r2, r9
 8022930:	bf28      	it	cs
 8022932:	464a      	movcs	r2, r9
 8022934:	f8d8 e000 	ldr.w	lr, [r8]
 8022938:	62a2      	str	r2, [r4, #40]	; 0x28
  }
  else
  {
    ep->xferLength += ep->maxTransferSize;
  }
  if (ep->xferLength == 0U)
 802293a:	b3aa      	cbz	r2, 80229a8 <XMC_USBD_EndpointWrite+0xd4>
    size.b.xfersize = 0U;
    size.b.pktcnt = 1U;
  }
  else
  {
    if (ep->address_u.address_st.number == 0U)
 802293c:	5dab      	ldrb	r3, [r5, r6]
 802293e:	071b      	lsls	r3, r3, #28
 8022940:	d02b      	beq.n	802299a <XMC_USBD_EndpointWrite+0xc6>
      size.b.xfersize = (uint32_t)(ep->xferLength - ep->xferCount);
    }
    else
    {
      size.b.xfersize =(uint32_t)(ep->xferLength - ep->xferCount);
      size.b.pktcnt = (uint16_t)(((uint16_t)(ep->xferLength - ep->xferCount) + (uint16_t)((uint16_t)ep->maxPacketSize - 1U))/
 8022942:	6863      	ldr	r3, [r4, #4]
 8022944:	f3c3 24c6 	ubfx	r4, r3, #11, #7
 8022948:	1e63      	subs	r3, r4, #1
 802294a:	b29b      	uxth	r3, r3
 802294c:	fa13 f382 	uxtah	r3, r3, r2
      /* ep->maxXferSize equals maxPacketSize */
      size.b.xfersize = (uint32_t)(ep->xferLength - ep->xferCount);
    }
    else
    {
      size.b.xfersize =(uint32_t)(ep->xferLength - ep->xferCount);
 8022950:	f3c2 0212 	ubfx	r2, r2, #0, #19
      size.b.pktcnt = (uint16_t)(((uint16_t)(ep->xferLength - ep->xferCount) + (uint16_t)((uint16_t)ep->maxPacketSize - 1U))/
 8022954:	fb93 f3f4 	sdiv	r3, r3, r4
 8022958:	f3c3 0309 	ubfx	r3, r3, #0, #10
    		 ep->maxPacketSize);
    }
    if(usbd_init->usbd_transfer_mode == XMC_USBD_USE_DMA)
 802295c:	4c1a      	ldr	r4, [pc, #104]	; (80229c8 <XMC_USBD_EndpointWrite+0xf4>)
 802295e:	6824      	ldr	r4, [r4, #0]
 8022960:	7b64      	ldrb	r4, [r4, #13]
 8022962:	f362 0112 	bfi	r1, r2, #0, #19
 8022966:	f363 41dc 	bfi	r1, r3, #19, #10
 802296a:	bb0c      	cbnz	r4, 80229b0 <XMC_USBD_EndpointWrite+0xdc>
    {
      /* Program dma*/
      xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepdma = (uint32_t)ep->xferBuffer;
 802296c:	f8c8 c014 	str.w	ip, [r8, #20]
			xmc_device.device_register->dtknqr4_fifoemptymsk |= (uint32_t)((uint32_t)1U << (uint8_t)ep->address_u.address_st.number);
    }
  }

  /* Program size of transfer and enable endpoint */
  xmc_device.endpoint_in_register[ep->address_u.address_st.number]->dieptsiz = size.d32;
 8022970:	2334      	movs	r3, #52	; 0x34
 8022972:	fb03 f707 	mul.w	r7, r3, r7
 8022976:	19ea      	adds	r2, r5, r7
 8022978:	5deb      	ldrb	r3, [r5, r7]
    ep->xferLength = 0U;
    ep->xferCount = 0U;
    ep->inInUse = 1U;
    /* start the transfer */
    XMC_USBD_lStartWriteXfer(ep);
    result=(int32_t)ep->xferTotal;
 802297a:	6b10      	ldr	r0, [r2, #48]	; 0x30
			xmc_device.device_register->dtknqr4_fifoemptymsk |= (uint32_t)((uint32_t)1U << (uint8_t)ep->address_u.address_st.number);
    }
  }

  /* Program size of transfer and enable endpoint */
  xmc_device.endpoint_in_register[ep->address_u.address_st.number]->dieptsiz = size.d32;
 802297c:	f003 030f 	and.w	r3, r3, #15
 8022980:	336a      	adds	r3, #106	; 0x6a
  ctl.b.epena = 1U;
  ctl.b.cnak = 1U;
 8022982:	f04e 4e04 	orr.w	lr, lr, #2214592512	; 0x84000000
			xmc_device.device_register->dtknqr4_fifoemptymsk |= (uint32_t)((uint32_t)1U << (uint8_t)ep->address_u.address_st.number);
    }
  }

  /* Program size of transfer and enable endpoint */
  xmc_device.endpoint_in_register[ep->address_u.address_st.number]->dieptsiz = size.d32;
 8022986:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
 802298a:	6119      	str	r1, [r3, #16]
  ctl.b.epena = 1U;
  ctl.b.cnak = 1U;
  xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = ctl.d32;
 802298c:	f8c3 e000 	str.w	lr, [r3]
 8022990:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
{
  XMC_USBD_EP_t * ep = &xmc_device.ep[ep_num & (uint8_t)XMC_USBD_EP_NUM_MASK];
  int32_t result;
  if (!ep->isConfigured)
  {
    result = (int32_t)XMC_USBD_STATUS_ERROR;
 8022994:	2001      	movs	r0, #1
 8022996:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  {
    if (ep->address_u.address_st.number == 0U)
    {
      size.b.pktcnt = 1U;
      /* ep->maxXferSize equals maxPacketSize */
      size.b.xfersize = (uint32_t)(ep->xferLength - ep->xferCount);
 802299a:	f3c2 0212 	ubfx	r2, r2, #0, #19
  }
  else
  {
    if (ep->address_u.address_st.number == 0U)
    {
      size.b.pktcnt = 1U;
 802299e:	2301      	movs	r3, #1
 80229a0:	e7dc      	b.n	802295c <XMC_USBD_EndpointWrite+0x88>
  {
    result = (int32_t)XMC_USBD_STATUS_ERROR;
  }
  else if (ep->inInUse == 1U)
  {
    result=(int32_t)0;
 80229a2:	2000      	movs	r0, #0
    /* start the transfer */
    XMC_USBD_lStartWriteXfer(ep);
    result=(int32_t)ep->xferTotal;
  }
  return result;
}
 80229a4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    ep->xferLength += ep->maxTransferSize;
  }
  if (ep->xferLength == 0U)
  {
    size.b.xfersize = 0U;
    size.b.pktcnt = 1U;
 80229a8:	2301      	movs	r3, #1
 80229aa:	f363 41dc 	bfi	r1, r3, #19, #10
 80229ae:	e7df      	b.n	8022970 <XMC_USBD_EndpointWrite+0x9c>
    if(usbd_init->usbd_transfer_mode == XMC_USBD_USE_DMA)
    {
      /* Program dma*/
      xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepdma = (uint32_t)ep->xferBuffer;
    }
    if(usbd_init->usbd_transfer_mode == XMC_USBD_USE_FIFO)
 80229b0:	2c01      	cmp	r4, #1
 80229b2:	d1dd      	bne.n	8022970 <XMC_USBD_EndpointWrite+0x9c>
    {
      /* enable fifo empty interrupt */
			xmc_device.device_register->dtknqr4_fifoemptymsk |= (uint32_t)((uint32_t)1U << (uint8_t)ep->address_u.address_st.number);
 80229b4:	f8d5 21a4 	ldr.w	r2, [r5, #420]	; 0x1a4
 80229b8:	6b53      	ldr	r3, [r2, #52]	; 0x34
 80229ba:	4084      	lsls	r4, r0
 80229bc:	431c      	orrs	r4, r3
 80229be:	6354      	str	r4, [r2, #52]	; 0x34
 80229c0:	e7d6      	b.n	8022970 <XMC_USBD_EndpointWrite+0x9c>
 80229c2:	bf00      	nop
 80229c4:	1fff0094 	.word	0x1fff0094
 80229c8:	1fff0090 	.word	0x1fff0090

080229cc <XMC_USBD_IRQHandler>:
 *
 * The handler first checks, which global interrupt has caused the interrupt
 * and then dispatches interrupt to the corresponding sub-handler.
 */
void XMC_USBD_IRQHandler(const XMC_USBD_t *const obj) 
{
 80229cc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  gintmsk_data_t gintmsk;
  gintsts_data_t data;
	
  gintmsk.d32 = xmc_device.global_register->gintmsk;
 80229d0:	4cb9      	ldr	r4, [pc, #740]	; (8022cb8 <XMC_USBD_IRQHandler+0x2ec>)
 80229d2:	f8d4 31a0 	ldr.w	r3, [r4, #416]	; 0x1a0
 80229d6:	699d      	ldr	r5, [r3, #24]
  data.d32 = xmc_device.global_register->gintsts & gintmsk.d32;
 80229d8:	695a      	ldr	r2, [r3, #20]
 *
 * The handler first checks, which global interrupt has caused the interrupt
 * and then dispatches interrupt to the corresponding sub-handler.
 */
void XMC_USBD_IRQHandler(const XMC_USBD_t *const obj) 
{
 80229da:	b08f      	sub	sp, #60	; 0x3c
  gintmsk_data_t gintmsk;
  gintsts_data_t data;
	
  gintmsk.d32 = xmc_device.global_register->gintmsk;
  data.d32 = xmc_device.global_register->gintsts & gintmsk.d32;
 80229dc:	ea02 0a05 	and.w	sl, r2, r5
	
  if (data.b.sofintr)
 80229e0:	fa5f f68a 	uxtb.w	r6, sl
 *
 * The handler first checks, which global interrupt has caused the interrupt
 * and then dispatches interrupt to the corresponding sub-handler.
 */
void XMC_USBD_IRQHandler(const XMC_USBD_t *const obj) 
{
 80229e4:	9001      	str	r0, [sp, #4]
  gintsts_data_t data;
	
  gintmsk.d32 = xmc_device.global_register->gintmsk;
  data.d32 = xmc_device.global_register->gintsts & gintmsk.d32;
	
  if (data.b.sofintr)
 80229e6:	0730      	lsls	r0, r6, #28
 80229e8:	f100 82eb 	bmi.w	8022fc2 <XMC_USBD_IRQHandler+0x5f6>
  {
    xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_SOF);
    XMC_USBD_ClearEvent(XMC_USBD_EVENT_SOF);
  }
  if(obj->usbd_transfer_mode == XMC_USBD_USE_FIFO)
 80229ec:	9a01      	ldr	r2, [sp, #4]
 80229ee:	7b52      	ldrb	r2, [r2, #13]
 80229f0:	2a01      	cmp	r2, #1
 80229f2:	f000 82f3 	beq.w	8022fdc <XMC_USBD_IRQHandler+0x610>
      XMC_USBD_lHandleRxFLvl(); /* handle the interrupt */
      gintmsk.b.rxstsqlvl = 1U;
      xmc_device.global_register->gintmsk = gintmsk.d32;
    }
  }
  if (data.b.erlysuspend)
 80229f6:	f3ca 2507 	ubfx	r5, sl, #8, #8
 80229fa:	0769      	lsls	r1, r5, #29
	  break;
    case (XMC_USBD_EVENT_SOF):
	  clear.b.sofintr = 1U;
	  break;
    case (XMC_USBD_EVENT_EARLYSUSPEND):
	  clear.b.erlysuspend = 1U;
 80229fc:	bf44      	itt	mi
 80229fe:	f44f 6280 	movmi.w	r2, #1024	; 0x400
	  clear.b.outepintr = 1U;
	  break;
		default:
		break;
	}
	xmc_device.global_register->gintsts = clear.d32;
 8022a02:	615a      	strmi	r2, [r3, #20]
  }
  if (data.b.erlysuspend)
  {
    XMC_USBD_ClearEvent(XMC_USBD_EVENT_EARLYSUSPEND);
  }
  if (data.b.usbsuspend)
 8022a04:	072a      	lsls	r2, r5, #28
 8022a06:	f100 82d2 	bmi.w	8022fae <XMC_USBD_IRQHandler+0x5e2>
  {
    xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_SUSPEND);
    XMC_USBD_ClearEvent(XMC_USBD_EVENT_SUSPEND);
  }
  if (data.b.wkupintr)
 8022a0a:	ea4f 661a 	mov.w	r6, sl, lsr #24
 8022a0e:	0637      	lsls	r7, r6, #24
 8022a10:	f100 82c3 	bmi.w	8022f9a <XMC_USBD_IRQHandler+0x5ce>
  {
    xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_REMOTE_WAKEUP);
    XMC_USBD_ClearEvent(XMC_USBD_EVENT_REMOTE_WAKEUP);
  }
  if (data.b.sessreqintr)
 8022a14:	0670      	lsls	r0, r6, #25
 8022a16:	f100 82b0 	bmi.w	8022f7a <XMC_USBD_IRQHandler+0x5ae>
  {
    xmc_device.IsPowered = 1U;
    xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_POWER_ON);
    XMC_USBD_ClearEvent(XMC_USBD_EVENT_POWER_ON);
  }
  if (data.b.usbreset)
 8022a1a:	06e9      	lsls	r1, r5, #27
 8022a1c:	f100 81f1 	bmi.w	8022e02 <XMC_USBD_IRQHandler+0x436>
  {
    XMC_USBD_lHandleUSBReset(obj);
  }
  if (data.b.enumdone)
 8022a20:	06aa      	lsls	r2, r5, #26
 8022a22:	f100 81d3 	bmi.w	8022dcc <XMC_USBD_IRQHandler+0x400>
  {
    XMC_USBD_lHandleEnumDone();
  }
  if (data.b.inepint)
 8022a26:	f41a 2f80 	tst.w	sl, #262144	; 0x40000
 8022a2a:	f040 8105 	bne.w	8022c38 <XMC_USBD_IRQHandler+0x26c>
  {
    XMC_USBD_lHandleIEPInt(obj);
  }
  if (data.b.outepintr)
 8022a2e:	f41a 2f00 	tst.w	sl, #524288	; 0x80000
 8022a32:	d118      	bne.n	8022a66 <XMC_USBD_IRQHandler+0x9a>
  {
		XMC_USBD_lHandleOEPInt(obj);
  }
	if (data.b.otgintr)
 8022a34:	f01a 0f04 	tst.w	sl, #4
 8022a38:	d102      	bne.n	8022a40 <XMC_USBD_IRQHandler+0x74>
  {
	  XMC_USBD_lHandleOTGInt();
  }

}
 8022a3a:	b00f      	add	sp, #60	; 0x3c
 8022a3c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
* It detects especially connect and disconnect events.
*/
static void XMC_USBD_lHandleOTGInt(void) 
{
  gotgint_data_t data;
  data.d32 = xmc_device.global_register->gotgint;
 8022a40:	685d      	ldr	r5, [r3, #4]
  if (data.b.sesenddet)
 8022a42:	0768      	lsls	r0, r5, #29
 8022a44:	d50b      	bpl.n	8022a5e <XMC_USBD_IRQHandler+0x92>
  {
		xmc_device.IsPowered = 0U;
 8022a46:	f894 31fe 	ldrb.w	r3, [r4, #510]	; 0x1fe
		xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_POWER_OFF);
 8022a4a:	f8d4 2200 	ldr.w	r2, [r4, #512]	; 0x200
{
  gotgint_data_t data;
  data.d32 = xmc_device.global_register->gotgint;
  if (data.b.sesenddet)
  {
		xmc_device.IsPowered = 0U;
 8022a4e:	f36f 0382 	bfc	r3, #2, #1
 8022a52:	f884 31fe 	strb.w	r3, [r4, #510]	; 0x1fe
		xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_POWER_OFF);
 8022a56:	2001      	movs	r0, #1
 8022a58:	4790      	blx	r2
 8022a5a:	f8d4 31a0 	ldr.w	r3, [r4, #416]	; 0x1a0
 **/
static void XMC_USBD_lClearEventOTG(uint32_t event)
{
  gotgint_data_t clear = { .d32 = 0U};
  clear.d32 = event;
  xmc_device.global_register->gotgint = clear.d32;
 8022a5e:	605d      	str	r5, [r3, #4]
	if (data.b.otgintr)
  {
	  XMC_USBD_lHandleOTGInt();
  }

}
 8022a60:	b00f      	add	sp, #60	; 0x3c
 8022a62:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  uint16_t temp;
  uint16_t temp1;
  uint16_t mask;
  uint8_t ep_num;
	
  daint.d32 = xmc_device.device_register->daint;
 8022a66:	f8d4 21a4 	ldr.w	r2, [r4, #420]	; 0x1a4
 8022a6a:	6993      	ldr	r3, [r2, #24]
  
  daintmsk.d32 = xmc_device.device_register->daintmsk;
 8022a6c:	69d7      	ldr	r7, [r2, #28]
  
  doepmsk.d32 = xmc_device.device_register->doepmsk;  
 8022a6e:	6952      	ldr	r2, [r2, #20]
 8022a70:	9202      	str	r2, [sp, #8]
  
  mask = daint.ep.out & daintmsk.ep.out;
 8022a72:	f3c3 430f 	ubfx	r3, r3, #16, #16
  ep_num = 0U;
  doeptsiz.d32 = 0U;
 8022a76:	2200      	movs	r2, #0
 
  while ((uint16_t)mask >> ep_num)
 8022a78:	ea13 4717 	ands.w	r7, r3, r7, lsr #16
  
  doepmsk.d32 = xmc_device.device_register->doepmsk;  
  
  mask = daint.ep.out & daintmsk.ep.out;
  ep_num = 0U;
  doeptsiz.d32 = 0U;
 8022a7c:	9203      	str	r2, [sp, #12]
 
  while ((uint16_t)mask >> ep_num)
 8022a7e:	f000 8097 	beq.w	8022bb0 <XMC_USBD_IRQHandler+0x1e4>
      }
	  /* Setup Phase Complete */
      if (doepint.b.setup)
      {
        /* ep0 not stalled any more */
        ep->isStalled = 0U;
 8022a82:	f8dd b004 	ldr.w	fp, [sp, #4]
 8022a86:	f8cd a010 	str.w	sl, [sp, #16]
 8022a8a:	4616      	mov	r6, r2
  
  mask = daint.ep.out & daintmsk.ep.out;
  ep_num = 0U;
  doeptsiz.d32 = 0U;
 
  while ((uint16_t)mask >> ep_num)
 8022a8c:	463b      	mov	r3, r7
 8022a8e:	4615      	mov	r5, r2
      }
	  /* Setup Phase Complete */
      if (doepint.b.setup)
      {
        /* ep0 not stalled any more */
        ep->isStalled = 0U;
 8022a90:	f04f 0c34 	mov.w	ip, #52	; 0x34
 8022a94:	46b8      	mov	r8, r7
 
  while ((uint16_t)mask >> ep_num)
  {
    temp1 = (mask >> (uint16_t)ep_num);
    temp = temp1 & 0x1U;
    if (temp)
 8022a96:	07df      	lsls	r7, r3, #31
 8022a98:	f140 8081 	bpl.w	8022b9e <XMC_USBD_IRQHandler+0x1d2>
    {
      /* load register data for endpoint */
      ep = &xmc_device.ep[ep_num];
      doepint.d32 = xmc_device.endpoint_out_register[ep_num]->doepint & doepmsk.d32;
 8022a9c:	f106 0970 	add.w	r9, r6, #112	; 0x70
 8022aa0:	eb04 0289 	add.w	r2, r4, r9, lsl #2
 8022aa4:	9902      	ldr	r1, [sp, #8]
 8022aa6:	6852      	ldr	r2, [r2, #4]
      if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
 8022aa8:	f89b 300d 	ldrb.w	r3, [fp, #13]
    temp = temp1 & 0x1U;
    if (temp)
    {
      /* load register data for endpoint */
      ep = &xmc_device.ep[ep_num];
      doepint.d32 = xmc_device.endpoint_out_register[ep_num]->doepint & doepmsk.d32;
 8022aac:	6897      	ldr	r7, [r2, #8]
 8022aae:	400f      	ands	r7, r1
      if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
      {
        doeptsiz.d32 = xmc_device.endpoint_out_register[ep_num]->doeptsiz;
      }
	  /* Setup Phase Complete */
      if (doepint.b.setup)
 8022ab0:	fa5f fa87 	uxtb.w	sl, r7
    if (temp)
    {
      /* load register data for endpoint */
      ep = &xmc_device.ep[ep_num];
      doepint.d32 = xmc_device.endpoint_out_register[ep_num]->doepint & doepmsk.d32;
      if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
 8022ab4:	2b00      	cmp	r3, #0
 8022ab6:	f040 8081 	bne.w	8022bbc <XMC_USBD_IRQHandler+0x1f0>
      {
        doeptsiz.d32 = xmc_device.endpoint_out_register[ep_num]->doeptsiz;
 8022aba:	6911      	ldr	r1, [r2, #16]
 8022abc:	9103      	str	r1, [sp, #12]
      }
	  /* Setup Phase Complete */
      if (doepint.b.setup)
 8022abe:	f01a 0f08 	tst.w	sl, #8
 8022ac2:	d021      	beq.n	8022b08 <XMC_USBD_IRQHandler+0x13c>
      {
        /* ep0 not stalled any more */
        ep->isStalled = 0U;
 8022ac4:	4a7c      	ldr	r2, [pc, #496]	; (8022cb8 <XMC_USBD_IRQHandler+0x2ec>)
 8022ac6:	fb0c 2006 	mla	r0, ip, r6, r2
        if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
        {
          /* calculate size for setup packet */
		  ep->outBytesAvailable = (uint32_t)(((uint32_t)XMC_USBD_SETUP_COUNT -
		  (uint32_t)((deptsiz0_data_t*)&doeptsiz)->b.supcnt)*(uint32_t)XMC_USBD_SETUP_SIZE);
 8022aca:	9a03      	ldr	r2, [sp, #12]
      }
	  /* Setup Phase Complete */
      if (doepint.b.setup)
      {
        /* ep0 not stalled any more */
        ep->isStalled = 0U;
 8022acc:	7901      	ldrb	r1, [r0, #4]
        if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
        {
          /* calculate size for setup packet */
		  ep->outBytesAvailable = (uint32_t)(((uint32_t)XMC_USBD_SETUP_COUNT -
		  (uint32_t)((deptsiz0_data_t*)&doeptsiz)->b.supcnt)*(uint32_t)XMC_USBD_SETUP_SIZE);
 8022ace:	f3c2 7241 	ubfx	r2, r2, #29, #2
        /* ep0 not stalled any more */
        ep->isStalled = 0U;
        if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
        {
          /* calculate size for setup packet */
		  ep->outBytesAvailable = (uint32_t)(((uint32_t)XMC_USBD_SETUP_COUNT -
 8022ad2:	00d2      	lsls	r2, r2, #3
      }
	  /* Setup Phase Complete */
      if (doepint.b.setup)
      {
        /* ep0 not stalled any more */
        ep->isStalled = 0U;
 8022ad4:	f363 1145 	bfi	r1, r3, #5, #1
        if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
        {
          /* calculate size for setup packet */
		  ep->outBytesAvailable = (uint32_t)(((uint32_t)XMC_USBD_SETUP_COUNT -
 8022ad8:	f1c2 0218 	rsb	r2, r2, #24
      }
	  /* Setup Phase Complete */
      if (doepint.b.setup)
      {
        /* ep0 not stalled any more */
        ep->isStalled = 0U;
 8022adc:	7101      	strb	r1, [r0, #4]
        if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
        {
          /* calculate size for setup packet */
		  ep->outBytesAvailable = (uint32_t)(((uint32_t)XMC_USBD_SETUP_COUNT -
 8022ade:	6102      	str	r2, [r0, #16]
        }
		if(obj->usbd_transfer_mode == XMC_USBD_USE_FIFO)
		{
			ep->outBytesAvailable += ep->xferCount;
		}
		ep->outInUse = 0U;
 8022ae0:	fb0c 4306 	mla	r3, ip, r6, r4
 8022ae4:	f8cd c004 	str.w	ip, [sp, #4]
 8022ae8:	685a      	ldr	r2, [r3, #4]
 8022aea:	f022 0210 	bic.w	r2, r2, #16
 8022aee:	605a      	str	r2, [r3, #4]
		xmc_device.EndpointEvent_cb(0U,XMC_USBD_EP_EVENT_SETUP); /* signal endpoint event */
 8022af0:	2000      	movs	r0, #0
 8022af2:	f8d4 3204 	ldr.w	r3, [r4, #516]	; 0x204
 8022af6:	4601      	mov	r1, r0
 8022af8:	4798      	blx	r3
 **/
void XMC_USBD_ClearEventOUTEP(uint32_t event,const uint8_t ep_num)
{
  doepint_data_t clear;
  clear.d32 = event;
  xmc_device.endpoint_out_register[ep_num]->doepint = clear.d32;
 8022afa:	eb04 0389 	add.w	r3, r4, r9, lsl #2
 8022afe:	2108      	movs	r1, #8
 8022b00:	685a      	ldr	r2, [r3, #4]
 8022b02:	f8dd c004 	ldr.w	ip, [sp, #4]
 8022b06:	6091      	str	r1, [r2, #8]
		ep->outInUse = 0U;
		xmc_device.EndpointEvent_cb(0U,XMC_USBD_EP_EVENT_SETUP); /* signal endpoint event */
				/* clear the interrupt */
		XMC_USBD_ClearEventOUTEP((uint32_t)XMC_USBD_EVENT_OUT_EP_SETUP,ep_num);
      }
      if (doepint.b.xfercompl)
 8022b08:	f01a 0f01 	tst.w	sl, #1
 8022b0c:	d046      	beq.n	8022b9c <XMC_USBD_IRQHandler+0x1d0>
      {
        if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
 8022b0e:	f89b 300d 	ldrb.w	r3, [fp, #13]
 8022b12:	2b00      	cmp	r3, #0
 8022b14:	d063      	beq.n	8022bde <XMC_USBD_IRQHandler+0x212>
 8022b16:	fb0c 4306 	mla	r3, ip, r6, r4
 8022b1a:	6a99      	ldr	r1, [r3, #40]	; 0x28
        {
          uint32_t bytes = (ep->xferLength - ep->xferCount) - doeptsiz.b.xfersize;
          ep->xferCount += bytes;
          ep->xferBuffer += bytes;
				}
        if (ep->xferTotal == ep->xferLength)
 8022b1c:	fb0c 4306 	mla	r3, ip, r6, r4
 8022b20:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8022b22:	428a      	cmp	r2, r1
 8022b24:	d072      	beq.n	8022c0c <XMC_USBD_IRQHandler+0x240>
{
  deptsiz_data_t data;
  depctl_data_t epctl;
	
  data.d32 =  0U;
  if ((ep->xferTotal - ep->xferLength) > ep->maxTransferSize)
 8022b26:	6898      	ldr	r0, [r3, #8]
 8022b28:	ebc1 0e02 	rsb	lr, r1, r2
 8022b2c:	f3c0 0012 	ubfx	r0, r0, #0, #19
 8022b30:	4586      	cmp	lr, r0
 8022b32:	fb0c fe06 	mul.w	lr, ip, r6
  {
    ep->xferLength += ep->maxTransferSize;
 8022b36:	bf88      	it	hi
 8022b38:	1809      	addhi	r1, r1, r0
 8022b3a:	eb04 000e 	add.w	r0, r4, lr
{
  deptsiz_data_t data;
  depctl_data_t epctl;
	
  data.d32 =  0U;
  if ((ep->xferTotal - ep->xferLength) > ep->maxTransferSize)
 8022b3e:	bf98      	it	ls
 8022b40:	4611      	movls	r1, r2
 8022b42:	6281      	str	r1, [r0, #40]	; 0x28
  }
  else
  {
    ep->xferLength = ep->xferTotal;
  }
  if (ep->address_u.address_st.number == 0U)
 8022b44:	f814 e00e 	ldrb.w	lr, [r4, lr]
 8022b48:	f01e 0f0f 	tst.w	lr, #15
static void XMC_USBD_lStartReadXfer(XMC_USBD_EP_t *const ep) 
{
  deptsiz_data_t data;
  depctl_data_t epctl;
	
  data.d32 =  0U;
 8022b4c:	f04f 0300 	mov.w	r3, #0
 8022b50:	f100 0a28 	add.w	sl, r0, #40	; 0x28
  }
  else
  {
    ep->xferLength = ep->xferTotal;
  }
  if (ep->address_u.address_st.number == 0U)
 8022b54:	f040 82ae 	bne.w	80230b4 <XMC_USBD_IRQHandler+0x6e8>
  {
	/* Setup the endpoint to receive 3 setup packages and one normal package.*/
	/* Cast the data pointer to use only one variable */
    deptsiz0_data_t *ep0_data = (deptsiz0_data_t*)&data;
    ep0_data->b.pktcnt = 0x1U;
 8022b58:	2101      	movs	r1, #1
 8022b5a:	f361 43d4 	bfi	r3, r1, #19, #2
    ep0_data->b.supcnt = 0x3U;
 8022b5e:	f043 43c0 	orr.w	r3, r3, #1610612736	; 0x60000000
    ep0_data->b.xfersize = (uint8_t)ep->xferTotal;
 8022b62:	f362 0306 	bfi	r3, r2, #0, #7
      /* setup endpoint to recive a amount of packages by given size */
      data.b.pktcnt = (uint16_t)(((ep->xferLength - ep->xferCount) + (ep->maxPacketSize -(uint32_t)1U))/ep->maxPacketSize);
      data.b.xfersize =(uint32_t)(ep->xferLength - ep->xferCount);
    }
  }
  if(usbd_init->usbd_transfer_mode == XMC_USBD_USE_DMA)
 8022b66:	4a55      	ldr	r2, [pc, #340]	; (8022cbc <XMC_USBD_IRQHandler+0x2f0>)
 8022b68:	6812      	ldr	r2, [r2, #0]
 8022b6a:	7b52      	ldrb	r2, [r2, #13]
  {
    /* Programm dma address if needed */
    xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepdma = (uint32_t)(ep->xferBuffer);
 8022b6c:	fb0c f606 	mul.w	r6, ip, r6
      /* setup endpoint to recive a amount of packages by given size */
      data.b.pktcnt = (uint16_t)(((ep->xferLength - ep->xferCount) + (ep->maxPacketSize -(uint32_t)1U))/ep->maxPacketSize);
      data.b.xfersize =(uint32_t)(ep->xferLength - ep->xferCount);
    }
  }
  if(usbd_init->usbd_transfer_mode == XMC_USBD_USE_DMA)
 8022b70:	2a00      	cmp	r2, #0
 8022b72:	f040 82a6 	bne.w	80230c2 <XMC_USBD_IRQHandler+0x6f6>
  {
    /* Programm dma address if needed */
    xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepdma = (uint32_t)(ep->xferBuffer);
 8022b76:	5da2      	ldrb	r2, [r4, r6]
 8022b78:	f002 020f 	and.w	r2, r2, #15
 8022b7c:	19a1      	adds	r1, r4, r6
 8022b7e:	eb04 0282 	add.w	r2, r4, r2, lsl #2
 8022b82:	6a48      	ldr	r0, [r1, #36]	; 0x24
 8022b84:	f8d2 11c4 	ldr.w	r1, [r2, #452]	; 0x1c4
 8022b88:	6148      	str	r0, [r1, #20]
  }
  /* setup endpoint size and enable endpoint */
  xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doeptsiz = data.d32;
 8022b8a:	610b      	str	r3, [r1, #16]
 
  epctl.d32 = xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl;
 8022b8c:	680b      	ldr	r3, [r1, #0]
 8022b8e:	eb04 0989 	add.w	r9, r4, r9, lsl #2
  epctl.b.cnak = 1U;
  epctl.b.epena = 1U;
 8022b92:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
 8022b96:	f8d9 2004 	ldr.w	r2, [r9, #4]
  xmc_device.endpoint_out_register[ep->address_u.address_st.number]->doepctl = epctl.d32;
 8022b9a:	600b      	str	r3, [r1, #0]
 **/
void XMC_USBD_ClearEventOUTEP(uint32_t event,const uint8_t ep_num)
{
  doepint_data_t clear;
  clear.d32 = event;
  xmc_device.endpoint_out_register[ep_num]->doepint = clear.d32;
 8022b9c:	6097      	str	r7, [r2, #8]

      }

      XMC_USBD_ClearEventOUTEP(doepint.d32,ep_num);
    }
    ep_num++;
 8022b9e:	3501      	adds	r5, #1
 8022ba0:	b2ed      	uxtb	r5, r5
  
  mask = daint.ep.out & daintmsk.ep.out;
  ep_num = 0U;
  doeptsiz.d32 = 0U;
 
  while ((uint16_t)mask >> ep_num)
 8022ba2:	fa58 f305 	asrs.w	r3, r8, r5
 8022ba6:	462e      	mov	r6, r5
 8022ba8:	f47f af75 	bne.w	8022a96 <XMC_USBD_IRQHandler+0xca>
 8022bac:	f8dd a010 	ldr.w	sl, [sp, #16]
	  clear.b.outepintr = 1U;
	  break;
		default:
		break;
	}
	xmc_device.global_register->gintsts = clear.d32;
 8022bb0:	f8d4 31a0 	ldr.w	r3, [r4, #416]	; 0x1a0
	  break;
    case (XMC_USBD_EVENT_ENUMDONE):
	  clear.b.enumdone = 1U;
	  break;
    case (XMC_USBD_EVENT_OUTEP):
	  clear.b.outepintr = 1U;
 8022bb4:	f44f 2200 	mov.w	r2, #524288	; 0x80000
	  break;
		default:
		break;
	}
	xmc_device.global_register->gintsts = clear.d32;
 8022bb8:	615a      	str	r2, [r3, #20]
 8022bba:	e73b      	b.n	8022a34 <XMC_USBD_IRQHandler+0x68>
      if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
      {
        doeptsiz.d32 = xmc_device.endpoint_out_register[ep_num]->doeptsiz;
      }
	  /* Setup Phase Complete */
      if (doepint.b.setup)
 8022bbc:	f01a 0f08 	tst.w	sl, #8
 8022bc0:	d0a2      	beq.n	8022b08 <XMC_USBD_IRQHandler+0x13c>
      {
        /* ep0 not stalled any more */
        ep->isStalled = 0U;
 8022bc2:	4a3d      	ldr	r2, [pc, #244]	; (8022cb8 <XMC_USBD_IRQHandler+0x2ec>)
 8022bc4:	fb0c 2106 	mla	r1, ip, r6, r2
        {
          /* calculate size for setup packet */
		  ep->outBytesAvailable = (uint32_t)(((uint32_t)XMC_USBD_SETUP_COUNT -
		  (uint32_t)((deptsiz0_data_t*)&doeptsiz)->b.supcnt)*(uint32_t)XMC_USBD_SETUP_SIZE);
        }
		if(obj->usbd_transfer_mode == XMC_USBD_USE_FIFO)
 8022bc8:	2b01      	cmp	r3, #1
      }
	  /* Setup Phase Complete */
      if (doepint.b.setup)
      {
        /* ep0 not stalled any more */
        ep->isStalled = 0U;
 8022bca:	790a      	ldrb	r2, [r1, #4]
 8022bcc:	f36f 1245 	bfc	r2, #5, #1
 8022bd0:	710a      	strb	r2, [r1, #4]
        {
          /* calculate size for setup packet */
		  ep->outBytesAvailable = (uint32_t)(((uint32_t)XMC_USBD_SETUP_COUNT -
		  (uint32_t)((deptsiz0_data_t*)&doeptsiz)->b.supcnt)*(uint32_t)XMC_USBD_SETUP_SIZE);
        }
		if(obj->usbd_transfer_mode == XMC_USBD_USE_FIFO)
 8022bd2:	d185      	bne.n	8022ae0 <XMC_USBD_IRQHandler+0x114>
		{
			ep->outBytesAvailable += ep->xferCount;
 8022bd4:	690b      	ldr	r3, [r1, #16]
 8022bd6:	6aca      	ldr	r2, [r1, #44]	; 0x2c
 8022bd8:	4413      	add	r3, r2
 8022bda:	610b      	str	r3, [r1, #16]
 8022bdc:	e780      	b.n	8022ae0 <XMC_USBD_IRQHandler+0x114>
      }
      if (doepint.b.xfercompl)
      {
        if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
        {
          uint32_t bytes = (ep->xferLength - ep->xferCount) - doeptsiz.b.xfersize;
 8022bde:	fb0c 4006 	mla	r0, ip, r6, r4
 8022be2:	9b03      	ldr	r3, [sp, #12]
 8022be4:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 8022be6:	6a81      	ldr	r1, [r0, #40]	; 0x28
 8022be8:	f3c3 0312 	ubfx	r3, r3, #0, #19
 8022bec:	ebc2 0e01 	rsb	lr, r2, r1
 8022bf0:	ebc3 030e 	rsb	r3, r3, lr
          ep->xferCount += bytes;
 8022bf4:	eb02 0e03 	add.w	lr, r2, r3
          ep->xferBuffer += bytes;
 8022bf8:	6a42      	ldr	r2, [r0, #36]	; 0x24
      if (doepint.b.xfercompl)
      {
        if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
        {
          uint32_t bytes = (ep->xferLength - ep->xferCount) - doeptsiz.b.xfersize;
          ep->xferCount += bytes;
 8022bfa:	f8c0 e02c 	str.w	lr, [r0, #44]	; 0x2c
          ep->xferBuffer += bytes;
 8022bfe:	4413      	add	r3, r2
 8022c00:	6243      	str	r3, [r0, #36]	; 0x24
				}
        if (ep->xferTotal == ep->xferLength)
 8022c02:	fb0c 4306 	mla	r3, ip, r6, r4
 8022c06:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8022c08:	428a      	cmp	r2, r1
 8022c0a:	d18c      	bne.n	8022b26 <XMC_USBD_IRQHandler+0x15a>
 8022c0c:	f8cd c004 	str.w	ip, [sp, #4]
        {
          ep->outBytesAvailable = ep->xferCount;
          ep->outInUse = 0U;
 8022c10:	685a      	ldr	r2, [r3, #4]
          ep->xferCount += bytes;
          ep->xferBuffer += bytes;
				}
        if (ep->xferTotal == ep->xferLength)
        {
          ep->outBytesAvailable = ep->xferCount;
 8022c12:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 8022c14:	6119      	str	r1, [r3, #16]
          ep->outInUse = 0U;
 8022c16:	f022 0210 	bic.w	r2, r2, #16
 8022c1a:	605a      	str	r2, [r3, #4]
          xmc_device.EndpointEvent_cb(ep_num,XMC_USBD_EP_EVENT_OUT);
 8022c1c:	4b26      	ldr	r3, [pc, #152]	; (8022cb8 <XMC_USBD_IRQHandler+0x2ec>)
 8022c1e:	4628      	mov	r0, r5
 8022c20:	f8d3 3204 	ldr.w	r3, [r3, #516]	; 0x204
 8022c24:	2101      	movs	r1, #1
 8022c26:	4798      	blx	r3
 8022c28:	4b23      	ldr	r3, [pc, #140]	; (8022cb8 <XMC_USBD_IRQHandler+0x2ec>)
 8022c2a:	f8dd c004 	ldr.w	ip, [sp, #4]
 8022c2e:	eb03 0989 	add.w	r9, r3, r9, lsl #2
 8022c32:	f8d9 2004 	ldr.w	r2, [r9, #4]
 8022c36:	e7b1      	b.n	8022b9c <XMC_USBD_IRQHandler+0x1d0>
  uint16_t temp1;
  uint16_t mask;
  uint8_t ep_num;
  uint32_t inepint;
	
  daint.d32 = xmc_device.device_register->daint;
 8022c38:	f8d4 31a4 	ldr.w	r3, [r4, #420]	; 0x1a4
 8022c3c:	699a      	ldr	r2, [r3, #24]
  
  diepmsk.d32 = xmc_device.device_register->diepmsk;
 8022c3e:	691b      	ldr	r3, [r3, #16]
 8022c40:	9303      	str	r3, [sp, #12]
  
  dieptsiz.d32 = 0U;
  mask = daint.ep.in;
  ep_num = 0U;
  
  while ((uint16_t)mask >> ep_num)
 8022c42:	b297      	uxth	r7, r2
 8022c44:	2f00      	cmp	r7, #0
 8022c46:	d061      	beq.n	8022d0c <XMC_USBD_IRQHandler+0x340>
 8022c48:	2600      	movs	r6, #0
 8022c4a:	46b6      	mov	lr, r6
 8022c4c:	463b      	mov	r3, r7
    if ((uint16_t)temp)
    {
      ep = &xmc_device.ep[ep_num];
			inepint = (uint32_t)xmc_device.endpoint_in_register[ep_num]->diepint;
      diepint.d32 = inepint &
      ((((uint32_t)((uint32_t)xmc_device.device_register->dtknqr4_fifoemptymsk >> ep->address_u.address_st.number) &
 8022c4e:	f04f 0b34 	mov.w	fp, #52	; 0x34
 8022c52:	f8cd a010 	str.w	sl, [sp, #16]
 8022c56:	46b9      	mov	r9, r7
  
  while ((uint16_t)mask >> ep_num)
  {
    temp1 = ((uint16_t)mask >> (uint16_t)ep_num);
    temp = (uint16_t)temp1 & (uint16_t)0x1U;
    if ((uint16_t)temp)
 8022c58:	07db      	lsls	r3, r3, #31
 8022c5a:	d54f      	bpl.n	8022cfc <XMC_USBD_IRQHandler+0x330>
    {
      ep = &xmc_device.ep[ep_num];
			inepint = (uint32_t)xmc_device.endpoint_in_register[ep_num]->diepint;
 8022c5c:	f10e 036a 	add.w	r3, lr, #106	; 0x6a
      diepint.d32 = inepint &
      ((((uint32_t)((uint32_t)xmc_device.device_register->dtknqr4_fifoemptymsk >> ep->address_u.address_st.number) &
 8022c60:	fb0b f00e 	mul.w	r0, fp, lr
    temp1 = ((uint16_t)mask >> (uint16_t)ep_num);
    temp = (uint16_t)temp1 & (uint16_t)0x1U;
    if ((uint16_t)temp)
    {
      ep = &xmc_device.ep[ep_num];
			inepint = (uint32_t)xmc_device.endpoint_in_register[ep_num]->diepint;
 8022c64:	9302      	str	r3, [sp, #8]
      diepint.d32 = inepint &
      ((((uint32_t)((uint32_t)xmc_device.device_register->dtknqr4_fifoemptymsk >> ep->address_u.address_st.number) &
 8022c66:	f8d4 a1a4 	ldr.w	sl, [r4, #420]	; 0x1a4
    temp1 = ((uint16_t)mask >> (uint16_t)ep_num);
    temp = (uint16_t)temp1 & (uint16_t)0x1U;
    if ((uint16_t)temp)
    {
      ep = &xmc_device.ep[ep_num];
			inepint = (uint32_t)xmc_device.endpoint_in_register[ep_num]->diepint;
 8022c6a:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
      diepint.d32 = inepint &
      ((((uint32_t)((uint32_t)xmc_device.device_register->dtknqr4_fifoemptymsk >> ep->address_u.address_st.number) &
 8022c6e:	f814 8000 	ldrb.w	r8, [r4, r0]
    temp1 = ((uint16_t)mask >> (uint16_t)ep_num);
    temp = (uint16_t)temp1 & (uint16_t)0x1U;
    if ((uint16_t)temp)
    {
      ep = &xmc_device.ep[ep_num];
			inepint = (uint32_t)xmc_device.endpoint_in_register[ep_num]->diepint;
 8022c72:	689d      	ldr	r5, [r3, #8]
      diepint.d32 = inepint &
      ((((uint32_t)((uint32_t)xmc_device.device_register->dtknqr4_fifoemptymsk >> ep->address_u.address_st.number) &
 8022c74:	f8da 1034 	ldr.w	r1, [sl, #52]	; 0x34
                     0x1U) << 7U) | (uint32_t)diepmsk.d32);
      if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
 8022c78:	9a01      	ldr	r2, [sp, #4]
    {
      ep = &xmc_device.ep[ep_num];
			inepint = (uint32_t)xmc_device.endpoint_in_register[ep_num]->diepint;
      diepint.d32 = inepint &
      ((((uint32_t)((uint32_t)xmc_device.device_register->dtknqr4_fifoemptymsk >> ep->address_u.address_st.number) &
                     0x1U) << 7U) | (uint32_t)diepmsk.d32);
 8022c7a:	9f03      	ldr	r7, [sp, #12]
      if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
 8022c7c:	7b52      	ldrb	r2, [r2, #13]
    if ((uint16_t)temp)
    {
      ep = &xmc_device.ep[ep_num];
			inepint = (uint32_t)xmc_device.endpoint_in_register[ep_num]->diepint;
      diepint.d32 = inepint &
      ((((uint32_t)((uint32_t)xmc_device.device_register->dtknqr4_fifoemptymsk >> ep->address_u.address_st.number) &
 8022c7e:	f008 0c0f 	and.w	ip, r8, #15
 8022c82:	fa21 f10c 	lsr.w	r1, r1, ip
                     0x1U) << 7U) | (uint32_t)diepmsk.d32);
 8022c86:	01c9      	lsls	r1, r1, #7
 8022c88:	b2c9      	uxtb	r1, r1
 8022c8a:	4339      	orrs	r1, r7
    if ((uint16_t)temp)
    {
      ep = &xmc_device.ep[ep_num];
			inepint = (uint32_t)xmc_device.endpoint_in_register[ep_num]->diepint;
      diepint.d32 = inepint &
      ((((uint32_t)((uint32_t)xmc_device.device_register->dtknqr4_fifoemptymsk >> ep->address_u.address_st.number) &
 8022c8c:	4420      	add	r0, r4
    temp = (uint16_t)temp1 & (uint16_t)0x1U;
    if ((uint16_t)temp)
    {
      ep = &xmc_device.ep[ep_num];
			inepint = (uint32_t)xmc_device.endpoint_in_register[ep_num]->diepint;
      diepint.d32 = inepint &
 8022c8e:	400d      	ands	r5, r1
      ((((uint32_t)((uint32_t)xmc_device.device_register->dtknqr4_fifoemptymsk >> ep->address_u.address_st.number) &
                     0x1U) << 7U) | (uint32_t)diepmsk.d32);
      if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
 8022c90:	b9b2      	cbnz	r2, 8022cc0 <XMC_USBD_IRQHandler+0x2f4>
          bytes = XMC_USBD_lWriteFifo(ep);
          ep->xferCount += bytes;
          ep->xferBuffer += bytes;
        }
      }
      if (diepint.b.xfercompl)
 8022c92:	07ef      	lsls	r7, r5, #31
      diepint.d32 = inepint &
      ((((uint32_t)((uint32_t)xmc_device.device_register->dtknqr4_fifoemptymsk >> ep->address_u.address_st.number) &
                     0x1U) << 7U) | (uint32_t)diepmsk.d32);
      if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
      {
        dieptsiz.d32 = xmc_device.endpoint_in_register[ep_num]->dieptsiz;
 8022c94:	691a      	ldr	r2, [r3, #16]
          bytes = XMC_USBD_lWriteFifo(ep);
          ep->xferCount += bytes;
          ep->xferBuffer += bytes;
        }
      }
      if (diepint.b.xfercompl)
 8022c96:	d530      	bpl.n	8022cfa <XMC_USBD_IRQHandler+0x32e>
      {
        if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
        {
          /* update xfer values */
          if ((dieptsiz.b.pktcnt == 0U) && (dieptsiz.b.xfersize == 0U))
 8022c98:	f022 4260 	bic.w	r2, r2, #3758096384	; 0xe0000000
 8022c9c:	2a00      	cmp	r2, #0
 8022c9e:	f000 8218 	beq.w	80230d2 <XMC_USBD_IRQHandler+0x706>
 8022ca2:	6a81      	ldr	r1, [r0, #40]	; 0x28
            uint32_t Bytes = ep->xferLength - ep->xferCount;
            ep->xferCount += Bytes;
            ep->xferBuffer += Bytes;
          }
        }
        if (ep->xferTotal==ep->xferLength)
 8022ca4:	fb0b 420e 	mla	r2, fp, lr, r4
 8022ca8:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8022caa:	428b      	cmp	r3, r1
 8022cac:	d133      	bne.n	8022d16 <XMC_USBD_IRQHandler+0x34a>
        {
          ep->inInUse = 0U;
 8022cae:	6853      	ldr	r3, [r2, #4]
 8022cb0:	f023 0308 	bic.w	r3, r3, #8
 8022cb4:	6053      	str	r3, [r2, #4]
 8022cb6:	e017      	b.n	8022ce8 <XMC_USBD_IRQHandler+0x31c>
 8022cb8:	1fff0094 	.word	0x1fff0094
 8022cbc:	1fff0090 	.word	0x1fff0090
                     0x1U) << 7U) | (uint32_t)diepmsk.d32);
      if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
      {
        dieptsiz.d32 = xmc_device.endpoint_in_register[ep_num]->dieptsiz;
      }
      if(obj->usbd_transfer_mode == XMC_USBD_USE_FIFO)
 8022cc0:	2a01      	cmp	r2, #1
 8022cc2:	d102      	bne.n	8022cca <XMC_USBD_IRQHandler+0x2fe>
      {
        if (diepint.b.emptyintr)
 8022cc4:	0629      	lsls	r1, r5, #24
 8022cc6:	f100 822a 	bmi.w	802311e <XMC_USBD_IRQHandler+0x752>
          bytes = XMC_USBD_lWriteFifo(ep);
          ep->xferCount += bytes;
          ep->xferBuffer += bytes;
        }
      }
      if (diepint.b.xfercompl)
 8022cca:	07e9      	lsls	r1, r5, #31
 8022ccc:	d515      	bpl.n	8022cfa <XMC_USBD_IRQHandler+0x32e>
            uint32_t Bytes = ep->xferLength - ep->xferCount;
            ep->xferCount += Bytes;
            ep->xferBuffer += Bytes;
          }
        }
        if (ep->xferTotal==ep->xferLength)
 8022cce:	fb0b 400e 	mla	r0, fp, lr, r4
 8022cd2:	6b03      	ldr	r3, [r0, #48]	; 0x30
 8022cd4:	6a81      	ldr	r1, [r0, #40]	; 0x28
 8022cd6:	428b      	cmp	r3, r1
 8022cd8:	d11d      	bne.n	8022d16 <XMC_USBD_IRQHandler+0x34a>
        {
          ep->inInUse = 0U;
 8022cda:	6843      	ldr	r3, [r0, #4]
          if(obj->usbd_transfer_mode == XMC_USBD_USE_FIFO)
 8022cdc:	2a01      	cmp	r2, #1
            ep->xferBuffer += Bytes;
          }
        }
        if (ep->xferTotal==ep->xferLength)
        {
          ep->inInUse = 0U;
 8022cde:	f023 0308 	bic.w	r3, r3, #8
 8022ce2:	6043      	str	r3, [r0, #4]
          if(obj->usbd_transfer_mode == XMC_USBD_USE_FIFO)
 8022ce4:	f000 8273 	beq.w	80231ce <XMC_USBD_IRQHandler+0x802>
          {
            /* mask fifo empty interrupt */
            xmc_device.device_register->dtknqr4_fifoemptymsk =
            (uint32_t)(xmc_device.device_register->dtknqr4_fifoemptymsk & ~(((uint32_t)1U << ep_num)));
          }
          xmc_device.EndpointEvent_cb(0x80U | ep_num,XMC_USBD_EP_EVENT_IN);
 8022ce8:	f8d4 3204 	ldr.w	r3, [r4, #516]	; 0x204
 8022cec:	f046 0080 	orr.w	r0, r6, #128	; 0x80
 8022cf0:	2102      	movs	r1, #2
 8022cf2:	4798      	blx	r3
 8022cf4:	9b02      	ldr	r3, [sp, #8]
 8022cf6:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 **/
void XMC_USBD_ClearEventINEP(uint32_t event,const uint8_t ep_num)
{
  diepint_data_t clear;
  clear.d32 = event;
  xmc_device.endpoint_in_register[ep_num]->diepint = clear.d32;
 8022cfa:	609d      	str	r5, [r3, #8]

      }

      XMC_USBD_ClearEventINEP((uint32_t)diepint.d32,ep_num);
    }
    ep_num++;
 8022cfc:	3601      	adds	r6, #1
 8022cfe:	b2f6      	uxtb	r6, r6
  
  dieptsiz.d32 = 0U;
  mask = daint.ep.in;
  ep_num = 0U;
  
  while ((uint16_t)mask >> ep_num)
 8022d00:	fa59 f306 	asrs.w	r3, r9, r6
 8022d04:	46b6      	mov	lr, r6
 8022d06:	d1a7      	bne.n	8022c58 <XMC_USBD_IRQHandler+0x28c>
 8022d08:	f8dd a010 	ldr.w	sl, [sp, #16]
	  clear.b.outepintr = 1U;
	  break;
		default:
		break;
	}
	xmc_device.global_register->gintsts = clear.d32;
 8022d0c:	f8d4 31a0 	ldr.w	r3, [r4, #416]	; 0x1a0
 8022d10:	2200      	movs	r2, #0
 8022d12:	615a      	str	r2, [r3, #20]
 8022d14:	e68b      	b.n	8022a2e <XMC_USBD_IRQHandler+0x62>
{
  deptsiz_data_t size;
  depctl_data_t ctl;
	
  size.d32 = 0U;  
  ctl.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl;
 8022d16:	fb0b f20e 	mul.w	r2, fp, lr
 8022d1a:	18a0      	adds	r0, r4, r2
 8022d1c:	5ca2      	ldrb	r2, [r4, r2]

  if ((ep->xferTotal - ep->xferLength)  < ep->maxTransferSize)
 8022d1e:	6880      	ldr	r0, [r0, #8]
 8022d20:	ebc1 0803 	rsb	r8, r1, r3
 8022d24:	f3c0 0c12 	ubfx	ip, r0, #0, #19
{
  deptsiz_data_t size;
  depctl_data_t ctl;
	
  size.d32 = 0U;  
  ctl.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl;
 8022d28:	f002 020f 	and.w	r2, r2, #15

  if ((ep->xferTotal - ep->xferLength)  < ep->maxTransferSize)
 8022d2c:	45e0      	cmp	r8, ip
{
  deptsiz_data_t size;
  depctl_data_t ctl;
	
  size.d32 = 0U;  
  ctl.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl;
 8022d2e:	9206      	str	r2, [sp, #24]
 8022d30:	f102 026a 	add.w	r2, r2, #106	; 0x6a
  {
    ep->xferLength = ep->xferTotal;
  }
  else
  {
    ep->xferLength += ep->maxTransferSize;
 8022d34:	bf28      	it	cs
 8022d36:	eb01 030c 	addcs.w	r3, r1, ip
 8022d3a:	fb0b fc0e 	mul.w	ip, fp, lr
{
  deptsiz_data_t size;
  depctl_data_t ctl;
	
  size.d32 = 0U;  
  ctl.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl;
 8022d3e:	f854 2022 	ldr.w	r2, [r4, r2, lsl #2]
 8022d42:	9205      	str	r2, [sp, #20]
 8022d44:	eb04 010c 	add.w	r1, r4, ip
 8022d48:	6812      	ldr	r2, [r2, #0]
 8022d4a:	628b      	str	r3, [r1, #40]	; 0x28
static void XMC_USBD_lStartWriteXfer(XMC_USBD_EP_t *const ep) 
{
  deptsiz_data_t size;
  depctl_data_t ctl;
	
  size.d32 = 0U;  
 8022d4c:	2000      	movs	r0, #0
 8022d4e:	f101 0828 	add.w	r8, r1, #40	; 0x28
  }
  else
  {
    ep->xferLength += ep->maxTransferSize;
  }
  if (ep->xferLength == 0U)
 8022d52:	2b00      	cmp	r3, #0
 8022d54:	f000 81dd 	beq.w	8023112 <XMC_USBD_IRQHandler+0x746>
    size.b.xfersize = 0U;
    size.b.pktcnt = 1U;
  }
  else
  {
    if (ep->address_u.address_st.number == 0U)
 8022d58:	f814 c00c 	ldrb.w	ip, [r4, ip]
 8022d5c:	f01c 0f0f 	tst.w	ip, #15
 8022d60:	f000 81cf 	beq.w	8023102 <XMC_USBD_IRQHandler+0x736>
      size.b.xfersize = (uint32_t)(ep->xferLength - ep->xferCount);
    }
    else
    {
      size.b.xfersize =(uint32_t)(ep->xferLength - ep->xferCount);
      size.b.pktcnt = (uint16_t)(((uint16_t)(ep->xferLength - ep->xferCount) + (uint16_t)((uint16_t)ep->maxPacketSize - 1U))/
 8022d64:	6849      	ldr	r1, [r1, #4]
      /* ep->maxXferSize equals maxPacketSize */
      size.b.xfersize = (uint32_t)(ep->xferLength - ep->xferCount);
    }
    else
    {
      size.b.xfersize =(uint32_t)(ep->xferLength - ep->xferCount);
 8022d66:	f8d8 7004 	ldr.w	r7, [r8, #4]
      size.b.pktcnt = (uint16_t)(((uint16_t)(ep->xferLength - ep->xferCount) + (uint16_t)((uint16_t)ep->maxPacketSize - 1U))/
 8022d6a:	f3c1 2cc6 	ubfx	ip, r1, #11, #7
 8022d6e:	f10c 38ff 	add.w	r8, ip, #4294967295
 8022d72:	1bd9      	subs	r1, r3, r7
      /* ep->maxXferSize equals maxPacketSize */
      size.b.xfersize = (uint32_t)(ep->xferLength - ep->xferCount);
    }
    else
    {
      size.b.xfersize =(uint32_t)(ep->xferLength - ep->xferCount);
 8022d74:	460b      	mov	r3, r1
      size.b.pktcnt = (uint16_t)(((uint16_t)(ep->xferLength - ep->xferCount) + (uint16_t)((uint16_t)ep->maxPacketSize - 1U))/
 8022d76:	fa1f f888 	uxth.w	r8, r8
 8022d7a:	fa18 f181 	uxtah	r1, r8, r1
      /* ep->maxXferSize equals maxPacketSize */
      size.b.xfersize = (uint32_t)(ep->xferLength - ep->xferCount);
    }
    else
    {
      size.b.xfersize =(uint32_t)(ep->xferLength - ep->xferCount);
 8022d7e:	f3c3 0312 	ubfx	r3, r3, #0, #19
      size.b.pktcnt = (uint16_t)(((uint16_t)(ep->xferLength - ep->xferCount) + (uint16_t)((uint16_t)ep->maxPacketSize - 1U))/
 8022d82:	fb91 fcfc 	sdiv	ip, r1, ip
 8022d86:	f3cc 0c09 	ubfx	ip, ip, #0, #10
    		 ep->maxPacketSize);
    }
    if(usbd_init->usbd_transfer_mode == XMC_USBD_USE_DMA)
 8022d8a:	49c2      	ldr	r1, [pc, #776]	; (8023094 <XMC_USBD_IRQHandler+0x6c8>)
 8022d8c:	6809      	ldr	r1, [r1, #0]
 8022d8e:	7b49      	ldrb	r1, [r1, #13]
 8022d90:	f363 0012 	bfi	r0, r3, #0, #19
 8022d94:	f36c 40dc 	bfi	r0, ip, #19, #10
 8022d98:	2900      	cmp	r1, #0
 8022d9a:	f040 820d 	bne.w	80231b8 <XMC_USBD_IRQHandler+0x7ec>
    {
      /* Program dma*/
      xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepdma = (uint32_t)ep->xferBuffer;
 8022d9e:	fb0b 430e 	mla	r3, fp, lr, r4
 8022da2:	9905      	ldr	r1, [sp, #20]
 8022da4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8022da6:	614b      	str	r3, [r1, #20]
			xmc_device.device_register->dtknqr4_fifoemptymsk |= (uint32_t)((uint32_t)1U << (uint8_t)ep->address_u.address_st.number);
    }
  }

  /* Program size of transfer and enable endpoint */
  xmc_device.endpoint_in_register[ep->address_u.address_st.number]->dieptsiz = size.d32;
 8022da8:	fb0b fe0e 	mul.w	lr, fp, lr
 8022dac:	9b02      	ldr	r3, [sp, #8]
 8022dae:	f814 100e 	ldrb.w	r1, [r4, lr]
 8022db2:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 8022db6:	f001 010f 	and.w	r1, r1, #15
 8022dba:	316a      	adds	r1, #106	; 0x6a
  ctl.b.epena = 1U;
  ctl.b.cnak = 1U;
 8022dbc:	f042 4204 	orr.w	r2, r2, #2214592512	; 0x84000000
			xmc_device.device_register->dtknqr4_fifoemptymsk |= (uint32_t)((uint32_t)1U << (uint8_t)ep->address_u.address_st.number);
    }
  }

  /* Program size of transfer and enable endpoint */
  xmc_device.endpoint_in_register[ep->address_u.address_st.number]->dieptsiz = size.d32;
 8022dc0:	f854 1021 	ldr.w	r1, [r4, r1, lsl #2]
 8022dc4:	6108      	str	r0, [r1, #16]
  ctl.b.epena = 1U;
  ctl.b.cnak = 1U;
  xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepctl = ctl.d32;
 8022dc6:	600a      	str	r2, [r1, #0]
 **/
void XMC_USBD_ClearEventINEP(uint32_t event,const uint8_t ep_num)
{
  diepint_data_t clear;
  clear.d32 = event;
  xmc_device.endpoint_in_register[ep_num]->diepint = clear.d32;
 8022dc8:	609d      	str	r5, [r3, #8]
 8022dca:	e797      	b.n	8022cfc <XMC_USBD_IRQHandler+0x330>
  /* Normaly we need to check dctl
   * We are always fullspeed, so max it up. */
  depctl_data_t epctl;
  gusbcfg_data_t gusbcfg;
	
  epctl.d32=xmc_device.endpoint_in_register[0U]->diepctl;
 8022dcc:	f8d4 11a8 	ldr.w	r1, [r4, #424]	; 0x1a8
  epctl.b.mps = 0x00U; /* 64 Byte, this is also automatically set for out ep */
  xmc_device.endpoint_in_register[0U]->diepctl = epctl.d32;

  /* update device connected flag */
  xmc_device.IsConnected = 1U;
 8022dd0:	f894 21fe 	ldrb.w	r2, [r4, #510]	; 0x1fe
  /* Normaly we need to check dctl
   * We are always fullspeed, so max it up. */
  depctl_data_t epctl;
  gusbcfg_data_t gusbcfg;
	
  epctl.d32=xmc_device.endpoint_in_register[0U]->diepctl;
 8022dd4:	680b      	ldr	r3, [r1, #0]

  /* update device connected flag */
  xmc_device.IsConnected = 1U;
  xmc_device.IsPowered = 1U;

  xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_CONNECT);
 8022dd6:	f8d4 5200 	ldr.w	r5, [r4, #512]	; 0x200
   * We are always fullspeed, so max it up. */
  depctl_data_t epctl;
  gusbcfg_data_t gusbcfg;
	
  epctl.d32=xmc_device.endpoint_in_register[0U]->diepctl;
  epctl.b.mps = 0x00U; /* 64 Byte, this is also automatically set for out ep */
 8022dda:	f36f 030a 	bfc	r3, #0, #11
  xmc_device.endpoint_in_register[0U]->diepctl = epctl.d32;

  /* update device connected flag */
  xmc_device.IsConnected = 1U;
  xmc_device.IsPowered = 1U;
 8022dde:	f042 0205 	orr.w	r2, r2, #5
  depctl_data_t epctl;
  gusbcfg_data_t gusbcfg;
	
  epctl.d32=xmc_device.endpoint_in_register[0U]->diepctl;
  epctl.b.mps = 0x00U; /* 64 Byte, this is also automatically set for out ep */
  xmc_device.endpoint_in_register[0U]->diepctl = epctl.d32;
 8022de2:	600b      	str	r3, [r1, #0]

  /* update device connected flag */
  xmc_device.IsConnected = 1U;
  xmc_device.IsPowered = 1U;

  xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_CONNECT);
 8022de4:	2002      	movs	r0, #2
  epctl.b.mps = 0x00U; /* 64 Byte, this is also automatically set for out ep */
  xmc_device.endpoint_in_register[0U]->diepctl = epctl.d32;

  /* update device connected flag */
  xmc_device.IsConnected = 1U;
  xmc_device.IsPowered = 1U;
 8022de6:	f884 21fe 	strb.w	r2, [r4, #510]	; 0x1fe

  xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_CONNECT);
 8022dea:	47a8      	blx	r5

  /* Set Trim */  
  gusbcfg.d32 = xmc_device.global_register->gusbcfg;
 8022dec:	f8d4 31a0 	ldr.w	r3, [r4, #416]	; 0x1a0
 8022df0:	68da      	ldr	r2, [r3, #12]
  gusbcfg.b.usbtrdtim = 9U; /* default value for LS/FS */
 8022df2:	2109      	movs	r1, #9
 8022df4:	f361 228d 	bfi	r2, r1, #10, #4
	  break;
    case (XMC_USBD_EVENT_EARLYSUSPEND):
	  clear.b.erlysuspend = 1U;
	  break;
    case (XMC_USBD_EVENT_ENUMDONE):
	  clear.b.enumdone = 1U;
 8022df8:	f44f 5100 	mov.w	r1, #8192	; 0x2000
  xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_CONNECT);

  /* Set Trim */  
  gusbcfg.d32 = xmc_device.global_register->gusbcfg;
  gusbcfg.b.usbtrdtim = 9U; /* default value for LS/FS */
  xmc_device.global_register->gusbcfg = gusbcfg.d32;
 8022dfc:	60da      	str	r2, [r3, #12]
	  clear.b.outepintr = 1U;
	  break;
		default:
		break;
	}
	xmc_device.global_register->gintsts = clear.d32;
 8022dfe:	6159      	str	r1, [r3, #20]
 8022e00:	e611      	b.n	8022a26 <XMC_USBD_IRQHandler+0x5a>
  fifosize_data_t gnptxfsiz;
  daint_data_t daint;
  dcfg_data_t dcfg;
	
  /* Clear the Remote Wakeup Signaling */
  dctl.d32 = xmc_device.device_register->dctl;
 8022e02:	f8d4 11a4 	ldr.w	r1, [r4, #420]	; 0x1a4
  xmc_device.device_register->dctl = dctl.d32;

  /* enable naks for all eps */
  for (i = 0U;i < (uint8_t)XMC_USBD_NUM_EPS;i++)
  {
    epctl.d32 = xmc_device.endpoint_out_register[i]->doepctl;
 8022e06:	f8d4 91c4 	ldr.w	r9, [r4, #452]	; 0x1c4
  fifosize_data_t gnptxfsiz;
  daint_data_t daint;
  dcfg_data_t dcfg;
	
  /* Clear the Remote Wakeup Signaling */
  dctl.d32 = xmc_device.device_register->dctl;
 8022e0a:	684a      	ldr	r2, [r1, #4]
  xmc_device.device_register->dctl = dctl.d32;

  /* enable naks for all eps */
  for (i = 0U;i < (uint8_t)XMC_USBD_NUM_EPS;i++)
  {
    epctl.d32 = xmc_device.endpoint_out_register[i]->doepctl;
 8022e0c:	f8d4 71d4 	ldr.w	r7, [r4, #468]	; 0x1d4
 8022e10:	f8d4 61d8 	ldr.w	r6, [r4, #472]	; 0x1d8
 8022e14:	f8d4 01dc 	ldr.w	r0, [r4, #476]	; 0x1dc
  daint_data_t daint;
  dcfg_data_t dcfg;
	
  /* Clear the Remote Wakeup Signaling */
  dctl.d32 = xmc_device.device_register->dctl;
  dctl.b.rmtwkupsig = 1U;
 8022e18:	f042 0201 	orr.w	r2, r2, #1
  xmc_device.device_register->dctl = dctl.d32;

  /* enable naks for all eps */
  for (i = 0U;i < (uint8_t)XMC_USBD_NUM_EPS;i++)
  {
    epctl.d32 = xmc_device.endpoint_out_register[i]->doepctl;
 8022e1c:	f504 78e4 	add.w	r8, r4, #456	; 0x1c8
 8022e20:	e898 5100 	ldmia.w	r8, {r8, ip, lr}
  dcfg_data_t dcfg;
	
  /* Clear the Remote Wakeup Signaling */
  dctl.d32 = xmc_device.device_register->dctl;
  dctl.b.rmtwkupsig = 1U;
  xmc_device.device_register->dctl = dctl.d32;
 8022e24:	604a      	str	r2, [r1, #4]

  /* enable naks for all eps */
  for (i = 0U;i < (uint8_t)XMC_USBD_NUM_EPS;i++)
  {
    epctl.d32 = xmc_device.endpoint_out_register[i]->doepctl;
 8022e26:	f8d9 2000 	ldr.w	r2, [r9]
		epctl.b.snak = 1U;
 8022e2a:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
		epctl.b.stall = 0U;
 8022e2e:	f36f 5255 	bfc	r2, #21, #1
		xmc_device.endpoint_out_register[i]->doepctl = epctl.d32;
 8022e32:	f8c9 2000 	str.w	r2, [r9]
  xmc_device.device_register->dctl = dctl.d32;

  /* enable naks for all eps */
  for (i = 0U;i < (uint8_t)XMC_USBD_NUM_EPS;i++)
  {
    epctl.d32 = xmc_device.endpoint_out_register[i]->doepctl;
 8022e36:	f8d8 2000 	ldr.w	r2, [r8]
  gnptxfsiz.b.startaddr = 64U;
  xmc_device.global_register->gnptxfsiz = gnptxfsiz.d32;
  /* calculate the size for the rest */
  for (i = 1U;i < (uint8_t)XMC_USBD_NUM_TX_FIFOS;i++)
  {
    xmc_device.global_register->dtxfsiz[i- 1U] = (uint32_t)(((256U + (i*(64U)))/4U) | ((uint32_t)16U << 16U));
 8022e3a:	f8df 9268 	ldr.w	r9, [pc, #616]	; 80230a4 <XMC_USBD_IRQHandler+0x6d8>

  /* enable naks for all eps */
  for (i = 0U;i < (uint8_t)XMC_USBD_NUM_EPS;i++)
  {
    epctl.d32 = xmc_device.endpoint_out_register[i]->doepctl;
		epctl.b.snak = 1U;
 8022e3e:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
		epctl.b.stall = 0U;
 8022e42:	f36f 5255 	bfc	r2, #21, #1
		xmc_device.endpoint_out_register[i]->doepctl = epctl.d32;
 8022e46:	f8c8 2000 	str.w	r2, [r8]
  xmc_device.device_register->dctl = dctl.d32;

  /* enable naks for all eps */
  for (i = 0U;i < (uint8_t)XMC_USBD_NUM_EPS;i++)
  {
    epctl.d32 = xmc_device.endpoint_out_register[i]->doepctl;
 8022e4a:	f8dc 2000 	ldr.w	r2, [ip]
  gnptxfsiz.b.startaddr = 64U;
  xmc_device.global_register->gnptxfsiz = gnptxfsiz.d32;
  /* calculate the size for the rest */
  for (i = 1U;i < (uint8_t)XMC_USBD_NUM_TX_FIFOS;i++)
  {
    xmc_device.global_register->dtxfsiz[i- 1U] = (uint32_t)(((256U + (i*(64U)))/4U) | ((uint32_t)16U << 16U));
 8022e4e:	f8df 8258 	ldr.w	r8, [pc, #600]	; 80230a8 <XMC_USBD_IRQHandler+0x6dc>

  /* enable naks for all eps */
  for (i = 0U;i < (uint8_t)XMC_USBD_NUM_EPS;i++)
  {
    epctl.d32 = xmc_device.endpoint_out_register[i]->doepctl;
		epctl.b.snak = 1U;
 8022e52:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
		epctl.b.stall = 0U;
 8022e56:	f36f 5255 	bfc	r2, #21, #1
		xmc_device.endpoint_out_register[i]->doepctl = epctl.d32;
 8022e5a:	f8cc 2000 	str.w	r2, [ip]
  xmc_device.device_register->dctl = dctl.d32;

  /* enable naks for all eps */
  for (i = 0U;i < (uint8_t)XMC_USBD_NUM_EPS;i++)
  {
    epctl.d32 = xmc_device.endpoint_out_register[i]->doepctl;
 8022e5e:	f8de 2000 	ldr.w	r2, [lr]
  gnptxfsiz.b.startaddr = 64U;
  xmc_device.global_register->gnptxfsiz = gnptxfsiz.d32;
  /* calculate the size for the rest */
  for (i = 1U;i < (uint8_t)XMC_USBD_NUM_TX_FIFOS;i++)
  {
    xmc_device.global_register->dtxfsiz[i- 1U] = (uint32_t)(((256U + (i*(64U)))/4U) | ((uint32_t)16U << 16U));
 8022e62:	f8df c248 	ldr.w	ip, [pc, #584]	; 80230ac <XMC_USBD_IRQHandler+0x6e0>

  /* enable naks for all eps */
  for (i = 0U;i < (uint8_t)XMC_USBD_NUM_EPS;i++)
  {
    epctl.d32 = xmc_device.endpoint_out_register[i]->doepctl;
		epctl.b.snak = 1U;
 8022e66:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
		epctl.b.stall = 0U;
 8022e6a:	f36f 5255 	bfc	r2, #21, #1
		xmc_device.endpoint_out_register[i]->doepctl = epctl.d32;
 8022e6e:	f8ce 2000 	str.w	r2, [lr]
  xmc_device.device_register->dctl = dctl.d32;

  /* enable naks for all eps */
  for (i = 0U;i < (uint8_t)XMC_USBD_NUM_EPS;i++)
  {
    epctl.d32 = xmc_device.endpoint_out_register[i]->doepctl;
 8022e72:	683a      	ldr	r2, [r7, #0]
  gnptxfsiz.b.startaddr = 64U;
  xmc_device.global_register->gnptxfsiz = gnptxfsiz.d32;
  /* calculate the size for the rest */
  for (i = 1U;i < (uint8_t)XMC_USBD_NUM_TX_FIFOS;i++)
  {
    xmc_device.global_register->dtxfsiz[i- 1U] = (uint32_t)(((256U + (i*(64U)))/4U) | ((uint32_t)16U << 16U));
 8022e74:	f8df e238 	ldr.w	lr, [pc, #568]	; 80230b0 <XMC_USBD_IRQHandler+0x6e4>

  /* enable naks for all eps */
  for (i = 0U;i < (uint8_t)XMC_USBD_NUM_EPS;i++)
  {
    epctl.d32 = xmc_device.endpoint_out_register[i]->doepctl;
		epctl.b.snak = 1U;
 8022e78:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
		epctl.b.stall = 0U;
 8022e7c:	f36f 5255 	bfc	r2, #21, #1
		xmc_device.endpoint_out_register[i]->doepctl = epctl.d32;
 8022e80:	603a      	str	r2, [r7, #0]
  xmc_device.device_register->dctl = dctl.d32;

  /* enable naks for all eps */
  for (i = 0U;i < (uint8_t)XMC_USBD_NUM_EPS;i++)
  {
    epctl.d32 = xmc_device.endpoint_out_register[i]->doepctl;
 8022e82:	6832      	ldr	r2, [r6, #0]
  gnptxfsiz.b.startaddr = 64U;
  xmc_device.global_register->gnptxfsiz = gnptxfsiz.d32;
  /* calculate the size for the rest */
  for (i = 1U;i < (uint8_t)XMC_USBD_NUM_TX_FIFOS;i++)
  {
    xmc_device.global_register->dtxfsiz[i- 1U] = (uint32_t)(((256U + (i*(64U)))/4U) | ((uint32_t)16U << 16U));
 8022e84:	4f84      	ldr	r7, [pc, #528]	; (8023098 <XMC_USBD_IRQHandler+0x6cc>)

  /* enable naks for all eps */
  for (i = 0U;i < (uint8_t)XMC_USBD_NUM_EPS;i++)
  {
    epctl.d32 = xmc_device.endpoint_out_register[i]->doepctl;
		epctl.b.snak = 1U;
 8022e86:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
		epctl.b.stall = 0U;
 8022e8a:	f36f 5255 	bfc	r2, #21, #1
		xmc_device.endpoint_out_register[i]->doepctl = epctl.d32;
 8022e8e:	6032      	str	r2, [r6, #0]
  xmc_device.device_register->dctl = dctl.d32;

  /* enable naks for all eps */
  for (i = 0U;i < (uint8_t)XMC_USBD_NUM_EPS;i++)
  {
    epctl.d32 = xmc_device.endpoint_out_register[i]->doepctl;
 8022e90:	6802      	ldr	r2, [r0, #0]
  gnptxfsiz.b.startaddr = 64U;
  xmc_device.global_register->gnptxfsiz = gnptxfsiz.d32;
  /* calculate the size for the rest */
  for (i = 1U;i < (uint8_t)XMC_USBD_NUM_TX_FIFOS;i++)
  {
    xmc_device.global_register->dtxfsiz[i- 1U] = (uint32_t)(((256U + (i*(64U)))/4U) | ((uint32_t)16U << 16U));
 8022e92:	4e82      	ldr	r6, [pc, #520]	; (802309c <XMC_USBD_IRQHandler+0x6d0>)

  /* enable naks for all eps */
  for (i = 0U;i < (uint8_t)XMC_USBD_NUM_EPS;i++)
  {
    epctl.d32 = xmc_device.endpoint_out_register[i]->doepctl;
		epctl.b.snak = 1U;
 8022e94:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
		epctl.b.stall = 0U;
 8022e98:	f36f 5255 	bfc	r2, #21, #1
		xmc_device.endpoint_out_register[i]->doepctl = epctl.d32;
 8022e9c:	6002      	str	r2, [r0, #0]
  }

  /* Configure fifos */
  /* Calculate the size of the rx fifo */
  xmc_device.global_register->grxfsiz = 64U;
 8022e9e:	2040      	movs	r0, #64	; 0x40
  /* Calculate the size of the tx fifo for ep 0 */  
  gnptxfsiz.d32 = 0U;
  gnptxfsiz.b.depth = 16U;
 8022ea0:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
		xmc_device.endpoint_out_register[i]->doepctl = epctl.d32;
  }

  /* Configure fifos */
  /* Calculate the size of the rx fifo */
  xmc_device.global_register->grxfsiz = 64U;
 8022ea4:	6258      	str	r0, [r3, #36]	; 0x24
  /* Calculate the size of the tx fifo for ep 0 */  
  gnptxfsiz.d32 = 0U;
  gnptxfsiz.b.depth = 16U;
  gnptxfsiz.b.startaddr = 64U;
 8022ea6:	f360 020f 	bfi	r2, r0, #0, #16
 */
static void XMC_USBD_lFlushTXFifo(const uint8_t fifo_num) 
{
  volatile grstctl_t data;  
  uint32_t count;
  data.d32 = 0U;
 8022eaa:	2000      	movs	r0, #0
  xmc_device.global_register->grxfsiz = 64U;
  /* Calculate the size of the tx fifo for ep 0 */  
  gnptxfsiz.d32 = 0U;
  gnptxfsiz.b.depth = 16U;
  gnptxfsiz.b.startaddr = 64U;
  xmc_device.global_register->gnptxfsiz = gnptxfsiz.d32;
 8022eac:	629a      	str	r2, [r3, #40]	; 0x28
  /* calculate the size for the rest */
  for (i = 1U;i < (uint8_t)XMC_USBD_NUM_TX_FIFOS;i++)
  {
    xmc_device.global_register->dtxfsiz[i- 1U] = (uint32_t)(((256U + (i*(64U)))/4U) | ((uint32_t)16U << 16U));
 8022eae:	f8c3 9104 	str.w	r9, [r3, #260]	; 0x104
 8022eb2:	f8c3 8108 	str.w	r8, [r3, #264]	; 0x108
 8022eb6:	f8c3 c10c 	str.w	ip, [r3, #268]	; 0x10c
 8022eba:	f8c3 e110 	str.w	lr, [r3, #272]	; 0x110
 8022ebe:	f8c3 7114 	str.w	r7, [r3, #276]	; 0x114
 8022ec2:	f8c3 6118 	str.w	r6, [r3, #280]	; 0x118
 */
static void XMC_USBD_lFlushTXFifo(const uint8_t fifo_num) 
{
  volatile grstctl_t data;  
  uint32_t count;
  data.d32 = 0U;
 8022ec6:	900d      	str	r0, [sp, #52]	; 0x34
  /*flush fifo */
  data.b.txfflsh = 1U;
 8022ec8:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8022eca:	f042 0220 	orr.w	r2, r2, #32
 8022ece:	920d      	str	r2, [sp, #52]	; 0x34
  data.b.txfnum = fifo_num;
 8022ed0:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8022ed2:	f422 62f8 	bic.w	r2, r2, #1984	; 0x7c0
 8022ed6:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8022eda:	920d      	str	r2, [sp, #52]	; 0x34
  xmc_device.global_register->grstctl = data.d32;
 8022edc:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8022ede:	611a      	str	r2, [r3, #16]
  for (count = 0U;count < 1000U; count++){}
  do
  {
   data.d32 = xmc_device.global_register->grstctl;
 8022ee0:	691a      	ldr	r2, [r3, #16]
 8022ee2:	920d      	str	r2, [sp, #52]	; 0x34
  } while (data.b.txfflsh);
 8022ee4:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8022ee6:	f3c2 1240 	ubfx	r2, r2, #5, #1
 8022eea:	2a00      	cmp	r2, #0
 8022eec:	d1f8      	bne.n	8022ee0 <XMC_USBD_IRQHandler+0x514>
 */
static void XMC_USBD_lFlushTXFifo(const uint8_t fifo_num) 
{
  volatile grstctl_t data;  
  uint32_t count;
  data.d32 = 0U;
 8022eee:	920c      	str	r2, [sp, #48]	; 0x30
  /*flush fifo */
  data.b.txfflsh = 1U;
 8022ef0:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8022ef2:	f042 0220 	orr.w	r2, r2, #32
 8022ef6:	920c      	str	r2, [sp, #48]	; 0x30
  data.b.txfnum = fifo_num;
 8022ef8:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8022efa:	f422 62f8 	bic.w	r2, r2, #1984	; 0x7c0
 8022efe:	920c      	str	r2, [sp, #48]	; 0x30
  xmc_device.global_register->grstctl = data.d32;
 8022f00:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8022f02:	611a      	str	r2, [r3, #16]
  for (count = 0U;count < 1000U; count++){}
  do
  {
   data.d32 = xmc_device.global_register->grstctl;
 8022f04:	691a      	ldr	r2, [r3, #16]
 8022f06:	920c      	str	r2, [sp, #48]	; 0x30
  } while (data.b.txfflsh);
 8022f08:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8022f0a:	f3c2 1240 	ubfx	r2, r2, #5, #1
 8022f0e:	2a00      	cmp	r2, #0
 8022f10:	d1f8      	bne.n	8022f04 <XMC_USBD_IRQHandler+0x538>
static void XMC_USBD_lFlushRXFifo(void) 
{
  volatile grstctl_t data;  
  uint32_t count;
	
	data.d32 = 0U;
 8022f12:	920b      	str	r2, [sp, #44]	; 0x2c
  data.b.rxfflsh = 1U;
 8022f14:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8022f16:	f042 0210 	orr.w	r2, r2, #16
 8022f1a:	920b      	str	r2, [sp, #44]	; 0x2c
  /* flush FIFO */
  xmc_device.global_register->grstctl = data.d32;
 8022f1c:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8022f1e:	611a      	str	r2, [r3, #16]
  do
  {
    for (count = 0U; count < 1000U; count++){}
    data.d32 = xmc_device.global_register->grstctl;
 8022f20:	691a      	ldr	r2, [r3, #16]
 8022f22:	920b      	str	r2, [sp, #44]	; 0x2c
  } while (data.b.rxfflsh);
 8022f24:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8022f26:	f3c2 1200 	ubfx	r2, r2, #4, #1
 8022f2a:	2a00      	cmp	r2, #0
 8022f2c:	d1f8      	bne.n	8022f20 <XMC_USBD_IRQHandler+0x554>
  XMC_USBD_lFlushRXFifo();
  /* Flush learning queue not needed due to fifo config */
  /* enable ep0 interrupts */  
  daint.d32 = 0U;
  daint.b.inep0 = 1U;
  daint.b.outep0 = 1U;
 8022f2e:	f04f 1301 	mov.w	r3, #65537	; 0x10001
  xmc_device.device_register->daintmsk = daint.d32;
 8022f32:	61cb      	str	r3, [r1, #28]
 **/
void XMC_USBD_EnableEventOUTEP(uint32_t event)
{
	doepint_data_t doepint;
	doepint.d32 = event;
	xmc_device.device_register->doepmsk |= doepint.d32;
 8022f34:	694b      	ldr	r3, [r1, #20]
  /* Clear device Address */  
  dcfg.d32 = xmc_device.device_register->dcfg;
  dcfg.b.devaddr = 0U;
  xmc_device.device_register->dcfg = dcfg.d32;

  if(obj->usbd_transfer_mode == XMC_USBD_USE_FIFO)
 8022f36:	9801      	ldr	r0, [sp, #4]
 **/
void XMC_USBD_EnableEventOUTEP(uint32_t event)
{
	doepint_data_t doepint;
	doepint.d32 = event;
	xmc_device.device_register->doepmsk |= doepint.d32;
 8022f38:	f043 030f 	orr.w	r3, r3, #15
  /* Clear device Address */  
  dcfg.d32 = xmc_device.device_register->dcfg;
  dcfg.b.devaddr = 0U;
  xmc_device.device_register->dcfg = dcfg.d32;

  if(obj->usbd_transfer_mode == XMC_USBD_USE_FIFO)
 8022f3c:	7b40      	ldrb	r0, [r0, #13]
 **/
void XMC_USBD_EnableEventOUTEP(uint32_t event)
{
	doepint_data_t doepint;
	doepint.d32 = event;
	xmc_device.device_register->doepmsk |= doepint.d32;
 8022f3e:	614b      	str	r3, [r1, #20]
 **/
void XMC_USBD_EnableEventINEP(uint32_t event)
{
	diepint_data_t diepint;
	diepint.d32 = event;
	xmc_device.device_register->diepmsk |= diepint.d32;
 8022f40:	690b      	ldr	r3, [r1, #16]
 8022f42:	f043 030f 	orr.w	r3, r3, #15
 8022f46:	610b      	str	r3, [r1, #16]
  XMC_USBD_EnableEventINEP(((uint32_t)XMC_USBD_EVENT_IN_EP_TX_COMPLET | (uint32_t)XMC_USBD_EVENT_IN_EP_DISABLED |
		  (uint32_t)XMC_USBD_EVENT_IN_EP_AHB_ERROR | (uint32_t)XMC_USBD_EVENT_IN_EP_TIMEOUT));


  /* Clear device Address */  
  dcfg.d32 = xmc_device.device_register->dcfg;
 8022f48:	680b      	ldr	r3, [r1, #0]
  dcfg.b.devaddr = 0U;
  xmc_device.device_register->dcfg = dcfg.d32;

  if(obj->usbd_transfer_mode == XMC_USBD_USE_FIFO)
 8022f4a:	2801      	cmp	r0, #1
		  (uint32_t)XMC_USBD_EVENT_IN_EP_AHB_ERROR | (uint32_t)XMC_USBD_EVENT_IN_EP_TIMEOUT));


  /* Clear device Address */  
  dcfg.d32 = xmc_device.device_register->dcfg;
  dcfg.b.devaddr = 0U;
 8022f4c:	f362 130a 	bfi	r3, r2, #4, #7
  xmc_device.device_register->dcfg = dcfg.d32;
 8022f50:	600b      	str	r3, [r1, #0]

  if(obj->usbd_transfer_mode == XMC_USBD_USE_FIFO)
  {
    /* Clear Empty interrupt */
    xmc_device.device_register->dtknqr4_fifoemptymsk = 0U;
 8022f52:	bf08      	it	eq
 8022f54:	634a      	streq	r2, [r1, #52]	; 0x34
  }

  xmc_device.ep[0U].outInUse = 0U;
 8022f56:	6863      	ldr	r3, [r4, #4]
  xmc_device.ep[0U].inInUse = 0U;

  xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_RESET);
 8022f58:	f8d4 2200 	ldr.w	r2, [r4, #512]	; 0x200
  {
    /* Clear Empty interrupt */
    xmc_device.device_register->dtknqr4_fifoemptymsk = 0U;
  }

  xmc_device.ep[0U].outInUse = 0U;
 8022f5c:	f023 0310 	bic.w	r3, r3, #16
 8022f60:	6063      	str	r3, [r4, #4]
  xmc_device.ep[0U].inInUse = 0U;
 8022f62:	6863      	ldr	r3, [r4, #4]
 8022f64:	f023 0308 	bic.w	r3, r3, #8
 8022f68:	6063      	str	r3, [r4, #4]

  xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_RESET);
 8022f6a:	2004      	movs	r0, #4
 8022f6c:	4790      	blx	r2
	  clear.b.outepintr = 1U;
	  break;
		default:
		break;
	}
	xmc_device.global_register->gintsts = clear.d32;
 8022f6e:	f8d4 31a0 	ldr.w	r3, [r4, #416]	; 0x1a0
  {
    case (XMC_USBD_EVENT_POWER_ON):
	  clear.b.sessreqintr = 1U;
	  break;
    case (XMC_USBD_EVENT_RESET):
	  clear.b.usbreset = 1U;
 8022f72:	f44f 5280 	mov.w	r2, #4096	; 0x1000
	  clear.b.outepintr = 1U;
	  break;
		default:
		break;
	}
	xmc_device.global_register->gintsts = clear.d32;
 8022f76:	615a      	str	r2, [r3, #20]
 8022f78:	e552      	b.n	8022a20 <XMC_USBD_IRQHandler+0x54>
    xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_REMOTE_WAKEUP);
    XMC_USBD_ClearEvent(XMC_USBD_EVENT_REMOTE_WAKEUP);
  }
  if (data.b.sessreqintr)
  {
    xmc_device.IsPowered = 1U;
 8022f7a:	f894 31fe 	ldrb.w	r3, [r4, #510]	; 0x1fe
    xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_POWER_ON);
 8022f7e:	f8d4 2200 	ldr.w	r2, [r4, #512]	; 0x200
    xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_REMOTE_WAKEUP);
    XMC_USBD_ClearEvent(XMC_USBD_EVENT_REMOTE_WAKEUP);
  }
  if (data.b.sessreqintr)
  {
    xmc_device.IsPowered = 1U;
 8022f82:	f043 0304 	orr.w	r3, r3, #4
 8022f86:	f884 31fe 	strb.w	r3, [r4, #510]	; 0x1fe
    xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_POWER_ON);
 8022f8a:	2000      	movs	r0, #0
 8022f8c:	4790      	blx	r2
	  clear.b.outepintr = 1U;
	  break;
		default:
		break;
	}
	xmc_device.global_register->gintsts = clear.d32;
 8022f8e:	f8d4 31a0 	ldr.w	r3, [r4, #416]	; 0x1a0
  gintsts_data_t clear;
  clear.d32 = 0U;
  switch(event)
  {
    case (XMC_USBD_EVENT_POWER_ON):
	  clear.b.sessreqintr = 1U;
 8022f92:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
	  clear.b.outepintr = 1U;
	  break;
		default:
		break;
	}
	xmc_device.global_register->gintsts = clear.d32;
 8022f96:	615a      	str	r2, [r3, #20]
 8022f98:	e53f      	b.n	8022a1a <XMC_USBD_IRQHandler+0x4e>
    xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_SUSPEND);
    XMC_USBD_ClearEvent(XMC_USBD_EVENT_SUSPEND);
  }
  if (data.b.wkupintr)
  {
    xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_REMOTE_WAKEUP);
 8022f9a:	f8d4 3200 	ldr.w	r3, [r4, #512]	; 0x200
 8022f9e:	2008      	movs	r0, #8
 8022fa0:	4798      	blx	r3
	  clear.b.outepintr = 1U;
	  break;
		default:
		break;
	}
	xmc_device.global_register->gintsts = clear.d32;
 8022fa2:	f8d4 31a0 	ldr.w	r3, [r4, #416]	; 0x1a0
	  break;
    case (XMC_USBD_EVENT_RESUME):
	  clear.b.wkupintr = 1U;
	  break;
    case (XMC_USBD_EVENT_REMOTE_WAKEUP):
	  clear.b.wkupintr = 1U;
 8022fa6:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
	  clear.b.outepintr = 1U;
	  break;
		default:
		break;
	}
	xmc_device.global_register->gintsts = clear.d32;
 8022faa:	615a      	str	r2, [r3, #20]
 8022fac:	e532      	b.n	8022a14 <XMC_USBD_IRQHandler+0x48>
  {
    XMC_USBD_ClearEvent(XMC_USBD_EVENT_EARLYSUSPEND);
  }
  if (data.b.usbsuspend)
  {
    xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_SUSPEND);
 8022fae:	f8d4 3200 	ldr.w	r3, [r4, #512]	; 0x200
 8022fb2:	2006      	movs	r0, #6
 8022fb4:	4798      	blx	r3
	  clear.b.outepintr = 1U;
	  break;
		default:
		break;
	}
	xmc_device.global_register->gintsts = clear.d32;
 8022fb6:	f8d4 31a0 	ldr.w	r3, [r4, #416]	; 0x1a0
	  break;
    case (XMC_USBD_EVENT_RESET):
	  clear.b.usbreset = 1U;
	  break;
    case (XMC_USBD_EVENT_SUSPEND):
	  clear.b.usbsuspend = 1U;
 8022fba:	f44f 6200 	mov.w	r2, #2048	; 0x800
	  clear.b.outepintr = 1U;
	  break;
		default:
		break;
	}
	xmc_device.global_register->gintsts = clear.d32;
 8022fbe:	615a      	str	r2, [r3, #20]
 8022fc0:	e523      	b.n	8022a0a <XMC_USBD_IRQHandler+0x3e>
  gintmsk.d32 = xmc_device.global_register->gintmsk;
  data.d32 = xmc_device.global_register->gintsts & gintmsk.d32;
	
  if (data.b.sofintr)
  {
    xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_SOF);
 8022fc2:	f8d4 3200 	ldr.w	r3, [r4, #512]	; 0x200
 8022fc6:	2009      	movs	r0, #9
 8022fc8:	4798      	blx	r3
	  clear.b.outepintr = 1U;
	  break;
		default:
		break;
	}
	xmc_device.global_register->gintsts = clear.d32;
 8022fca:	f8d4 31a0 	ldr.w	r3, [r4, #416]	; 0x1a0
	  break;
    case (XMC_USBD_EVENT_REMOTE_WAKEUP):
	  clear.b.wkupintr = 1U;
	  break;
    case (XMC_USBD_EVENT_SOF):
	  clear.b.sofintr = 1U;
 8022fce:	2208      	movs	r2, #8
	  clear.b.outepintr = 1U;
	  break;
		default:
		break;
	}
	xmc_device.global_register->gintsts = clear.d32;
 8022fd0:	615a      	str	r2, [r3, #20]
  if (data.b.sofintr)
  {
    xmc_device.DeviceEvent_cb(XMC_USBD_EVENT_SOF);
    XMC_USBD_ClearEvent(XMC_USBD_EVENT_SOF);
  }
  if(obj->usbd_transfer_mode == XMC_USBD_USE_FIFO)
 8022fd2:	9a01      	ldr	r2, [sp, #4]
 8022fd4:	7b52      	ldrb	r2, [r2, #13]
 8022fd6:	2a01      	cmp	r2, #1
 8022fd8:	f47f ad0d 	bne.w	80229f6 <XMC_USBD_IRQHandler+0x2a>
  {
    if (data.b.rxstsqlvl)
 8022fdc:	06f1      	lsls	r1, r6, #27
 8022fde:	f57f ad0a 	bpl.w	80229f6 <XMC_USBD_IRQHandler+0x2a>
    {
      /* Masked that interrupt so its only done once */
      gintmsk.b.rxstsqlvl = 0U;
 8022fe2:	f36f 1504 	bfc	r5, #4, #1
      xmc_device.global_register->gintmsk = gintmsk.d32;
 8022fe6:	619d      	str	r5, [r3, #24]
 * This function handles the interrupt, when the rx fifo is not empty anymore.
 */
static void XMC_USBD_lHandleRxFLvl(void) 
{
  device_grxsts_data_t data;	
  data.d32 = xmc_device.global_register->grxstsp;
 8022fe8:	6a1a      	ldr	r2, [r3, #32]

  switch (data.b.pktsts)
 8022fea:	f3c2 4143 	ubfx	r1, r2, #17, #4
 8022fee:	2902      	cmp	r1, #2
 8022ff0:	f000 80ff 	beq.w	80231f2 <XMC_USBD_IRQHandler+0x826>
 8022ff4:	2906      	cmp	r1, #6
 8022ff6:	d149      	bne.n	802308c <XMC_USBD_IRQHandler+0x6c0>
      break;
    case XMC_USBD_GRXSTS_PKTSTS_OUTDATA:
      XMC_USBD_lReadFifo((uint32_t)data.b.epnum,(uint32_t)data.b.bcnt);
      break;
    case XMC_USBD_GRXSTS_PKTSTS_SETUP:
      XMC_USBD_lReadFifo((uint32_t)data.b.epnum,(uint32_t)data.b.bcnt);
 8022ff8:	f002 070f 	and.w	r7, r2, #15
  uint32_t temp_data;
  uint32_t temp_word_count;
  volatile uint32_t *fifo = xmc_device.fifo[0U];
  uint32_t i;
  depctl_data_t data;
  data.d32 = xmc_device.endpoint_out_register[ep_num]->doepctl;
 8022ffc:	eb04 0187 	add.w	r1, r4, r7, lsl #2
      break;
    case XMC_USBD_GRXSTS_PKTSTS_OUTDATA:
      XMC_USBD_lReadFifo((uint32_t)data.b.epnum,(uint32_t)data.b.bcnt);
      break;
    case XMC_USBD_GRXSTS_PKTSTS_SETUP:
      XMC_USBD_lReadFifo((uint32_t)data.b.epnum,(uint32_t)data.b.bcnt);
 8023000:	f3c2 120a 	ubfx	r2, r2, #4, #11
  uint32_t temp_data;
  uint32_t temp_word_count;
  volatile uint32_t *fifo = xmc_device.fifo[0U];
  uint32_t i;
  depctl_data_t data;
  data.d32 = xmc_device.endpoint_out_register[ep_num]->doepctl;
 8023004:	f8d1 11c4 	ldr.w	r1, [r1, #452]	; 0x1c4
{
  XMC_USBD_EP_t * ep = &xmc_device.ep[ep_num];
  uint32_t word_count;
  uint32_t temp_data;
  uint32_t temp_word_count;
  volatile uint32_t *fifo = xmc_device.fifo[0U];
 8023008:	4825      	ldr	r0, [pc, #148]	; (80230a0 <XMC_USBD_IRQHandler+0x6d4>)
  uint32_t i;
  depctl_data_t data;
  data.d32 = xmc_device.endpoint_out_register[ep_num]->doepctl;
 802300a:	6809      	ldr	r1, [r1, #0]
{
  XMC_USBD_EP_t * ep = &xmc_device.ep[ep_num];
  uint32_t word_count;
  uint32_t temp_data;
  uint32_t temp_word_count;
  volatile uint32_t *fifo = xmc_device.fifo[0U];
 802300c:	f8d4 81e0 	ldr.w	r8, [r4, #480]	; 0x1e0
  depctl_data_t data;
  data.d32 = xmc_device.endpoint_out_register[ep_num]->doepctl;
  word_count = (byte_count >> 2U );
  temp_word_count = (word_count << 2U);
  /* Check if ep is enabled and has buffer */
  if (!data.b.usbactep)
 8023010:	040e      	lsls	r6, r1, #16
 8023012:	d53b      	bpl.n	802308c <XMC_USBD_IRQHandler+0x6c0>
  {
    /*Do Nothing*/
  }
  else if (ep->xferBuffer == NULL)
 8023014:	2134      	movs	r1, #52	; 0x34
 8023016:	fb01 0e07 	mla	lr, r1, r7, r0
 802301a:	f8de 0024 	ldr.w	r0, [lr, #36]	; 0x24
 802301e:	b3a8      	cbz	r0, 802308c <XMC_USBD_IRQHandler+0x6c0>
	/*Do Nothing*/
  }
  else
  {
    /* store the data */
    for (i = 0U;i < word_count; i++)
 8023020:	ea5f 0c92 	movs.w	ip, r2, lsr #2
 8023024:	d00b      	beq.n	802303e <XMC_USBD_IRQHandler+0x672>
 8023026:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
 802302a:	2100      	movs	r1, #0
 802302c:	e001      	b.n	8023032 <XMC_USBD_IRQHandler+0x666>
 802302e:	f8de 0024 	ldr.w	r0, [lr, #36]	; 0x24
    {
      *(((uint32_t*)ep->xferBuffer)+i) = *fifo;
 8023032:	f8d8 6000 	ldr.w	r6, [r8]
 8023036:	5046      	str	r6, [r0, r1]
 8023038:	3104      	adds	r1, #4
	/*Do Nothing*/
  }
  else
  {
    /* store the data */
    for (i = 0U;i < word_count; i++)
 802303a:	4561      	cmp	r1, ip
 802303c:	d1f7      	bne.n	802302e <XMC_USBD_IRQHandler+0x662>
    {
      *(((uint32_t*)ep->xferBuffer)+i) = *fifo;
    }
    /* space is not devidable by 4 */
    if (byte_count!=temp_word_count)
 802303e:	4562      	cmp	r2, ip
 8023040:	d01b      	beq.n	802307a <XMC_USBD_IRQHandler+0x6ae>
    {
      temp_data = *fifo;
 8023042:	f8d8 8000 	ldr.w	r8, [r8]
      for (i = 0U;(temp_word_count + i) < byte_count;i++)
 8023046:	d918      	bls.n	802307a <XMC_USBD_IRQHandler+0x6ae>
      {
        ep->xferBuffer[(word_count << 2)+i] = (uint8_t)((temp_data & ((uint32_t)0xFFU << (i * 8U))) >> (i * 8U));
 8023048:	f04f 0e34 	mov.w	lr, #52	; 0x34
    }
    /* space is not devidable by 4 */
    if (byte_count!=temp_word_count)
    {
      temp_data = *fifo;
      for (i = 0U;(temp_word_count + i) < byte_count;i++)
 802304c:	4663      	mov	r3, ip
      {
        ep->xferBuffer[(word_count << 2)+i] = (uint8_t)((temp_data & ((uint32_t)0xFFU << (i * 8U))) >> (i * 8U));
 802304e:	fb0e 4e07 	mla	lr, lr, r7, r4
    }
    /* space is not devidable by 4 */
    if (byte_count!=temp_word_count)
    {
      temp_data = *fifo;
      for (i = 0U;(temp_word_count + i) < byte_count;i++)
 8023052:	2600      	movs	r6, #0
      {
        ep->xferBuffer[(word_count << 2)+i] = (uint8_t)((temp_data & ((uint32_t)0xFFU << (i * 8U))) >> (i * 8U));
 8023054:	f04f 09ff 	mov.w	r9, #255	; 0xff
 8023058:	fa09 f106 	lsl.w	r1, r9, r6
 802305c:	ea01 0108 	and.w	r1, r1, r8
 8023060:	f8de 0024 	ldr.w	r0, [lr, #36]	; 0x24
 8023064:	f8df c038 	ldr.w	ip, [pc, #56]	; 80230a0 <XMC_USBD_IRQHandler+0x6d4>
 8023068:	40f1      	lsrs	r1, r6
 802306a:	54c1      	strb	r1, [r0, r3]
    }
    /* space is not devidable by 4 */
    if (byte_count!=temp_word_count)
    {
      temp_data = *fifo;
      for (i = 0U;(temp_word_count + i) < byte_count;i++)
 802306c:	3301      	adds	r3, #1
 802306e:	429a      	cmp	r2, r3
 8023070:	f106 0608 	add.w	r6, r6, #8
 8023074:	d1f0      	bne.n	8023058 <XMC_USBD_IRQHandler+0x68c>
 8023076:	f8dc 31a0 	ldr.w	r3, [ip, #416]	; 0x1a0
        ep->xferBuffer[(word_count << 2)+i] = (uint8_t)((temp_data & ((uint32_t)0xFFU << (i * 8U))) >> (i * 8U));
      }
    }

    /* save the amount of data */
    ep->xferCount += byte_count;
 802307a:	2634      	movs	r6, #52	; 0x34
 802307c:	fb06 4607 	mla	r6, r6, r7, r4
 8023080:	6af1      	ldr	r1, [r6, #44]	; 0x2c
    ep->xferBuffer += byte_count;
 8023082:	6a70      	ldr	r0, [r6, #36]	; 0x24
        ep->xferBuffer[(word_count << 2)+i] = (uint8_t)((temp_data & ((uint32_t)0xFFU << (i * 8U))) >> (i * 8U));
      }
    }

    /* save the amount of data */
    ep->xferCount += byte_count;
 8023084:	4411      	add	r1, r2
    ep->xferBuffer += byte_count;
 8023086:	4402      	add	r2, r0
        ep->xferBuffer[(word_count << 2)+i] = (uint8_t)((temp_data & ((uint32_t)0xFFU << (i * 8U))) >> (i * 8U));
      }
    }

    /* save the amount of data */
    ep->xferCount += byte_count;
 8023088:	62f1      	str	r1, [r6, #44]	; 0x2c
    ep->xferBuffer += byte_count;
 802308a:	6272      	str	r2, [r6, #36]	; 0x24
    {
      /* Masked that interrupt so its only done once */
      gintmsk.b.rxstsqlvl = 0U;
      xmc_device.global_register->gintmsk = gintmsk.d32;
      XMC_USBD_lHandleRxFLvl(); /* handle the interrupt */
      gintmsk.b.rxstsqlvl = 1U;
 802308c:	f045 0510 	orr.w	r5, r5, #16
      xmc_device.global_register->gintmsk = gintmsk.d32;
 8023090:	619d      	str	r5, [r3, #24]
 8023092:	e4b0      	b.n	80229f6 <XMC_USBD_IRQHandler+0x2a>
 8023094:	1fff0090 	.word	0x1fff0090
 8023098:	00100090 	.word	0x00100090
 802309c:	001000a0 	.word	0x001000a0
 80230a0:	1fff0094 	.word	0x1fff0094
 80230a4:	00100050 	.word	0x00100050
 80230a8:	00100060 	.word	0x00100060
 80230ac:	00100070 	.word	0x00100070
 80230b0:	00100080 	.word	0x00100080
    ep0_data->b.xfersize = (uint8_t)ep->xferTotal;
  }
  else
  {
    /* If requested length is zero, just receive one zero length packet */
    if (ep->xferLength == 0U)
 80230b4:	b9a9      	cbnz	r1, 80230e2 <XMC_USBD_IRQHandler+0x716>
    {
      data.b.xfersize = 0U;
 80230b6:	f361 0312 	bfi	r3, r1, #0, #19
      data.b.pktcnt = 1U;
 80230ba:	2201      	movs	r2, #1
 80230bc:	f362 43dc 	bfi	r3, r2, #19, #10
 80230c0:	e551      	b.n	8022b66 <XMC_USBD_IRQHandler+0x19a>
 80230c2:	5da2      	ldrb	r2, [r4, r6]
 80230c4:	f002 020f 	and.w	r2, r2, #15
 80230c8:	eb04 0282 	add.w	r2, r4, r2, lsl #2
 80230cc:	f8d2 11c4 	ldr.w	r1, [r2, #452]	; 0x1c4
 80230d0:	e55b      	b.n	8022b8a <XMC_USBD_IRQHandler+0x1be>
        if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
        {
          /* update xfer values */
          if ((dieptsiz.b.pktcnt == 0U) && (dieptsiz.b.xfersize == 0U))
          {
            uint32_t Bytes = ep->xferLength - ep->xferCount;
 80230d2:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 80230d4:	6a81      	ldr	r1, [r0, #40]	; 0x28
            ep->xferCount += Bytes;
            ep->xferBuffer += Bytes;
 80230d6:	6a43      	ldr	r3, [r0, #36]	; 0x24
        {
          /* update xfer values */
          if ((dieptsiz.b.pktcnt == 0U) && (dieptsiz.b.xfersize == 0U))
          {
            uint32_t Bytes = ep->xferLength - ep->xferCount;
            ep->xferCount += Bytes;
 80230d8:	62c1      	str	r1, [r0, #44]	; 0x2c
        if(obj->usbd_transfer_mode == XMC_USBD_USE_DMA)
        {
          /* update xfer values */
          if ((dieptsiz.b.pktcnt == 0U) && (dieptsiz.b.xfersize == 0U))
          {
            uint32_t Bytes = ep->xferLength - ep->xferCount;
 80230da:	1a8a      	subs	r2, r1, r2
            ep->xferCount += Bytes;
            ep->xferBuffer += Bytes;
 80230dc:	441a      	add	r2, r3
 80230de:	6242      	str	r2, [r0, #36]	; 0x24
 80230e0:	e5e0      	b.n	8022ca4 <XMC_USBD_IRQHandler+0x2d8>
      data.b.pktcnt = 1U;
    }
    else
    {
      /* setup endpoint to recive a amount of packages by given size */
      data.b.pktcnt = (uint16_t)(((ep->xferLength - ep->xferCount) + (ep->maxPacketSize -(uint32_t)1U))/ep->maxPacketSize);
 80230e2:	6842      	ldr	r2, [r0, #4]
 80230e4:	f8da 0004 	ldr.w	r0, [sl, #4]
 80230e8:	f3c2 22c6 	ubfx	r2, r2, #11, #7
 80230ec:	1a09      	subs	r1, r1, r0
 80230ee:	f102 3eff 	add.w	lr, r2, #4294967295
 80230f2:	448e      	add	lr, r1
 80230f4:	fbbe f2f2 	udiv	r2, lr, r2
 80230f8:	f362 43dc 	bfi	r3, r2, #19, #10
      data.b.xfersize =(uint32_t)(ep->xferLength - ep->xferCount);
 80230fc:	f361 0312 	bfi	r3, r1, #0, #19
 8023100:	e531      	b.n	8022b66 <XMC_USBD_IRQHandler+0x19a>
  {
    if (ep->address_u.address_st.number == 0U)
    {
      size.b.pktcnt = 1U;
      /* ep->maxXferSize equals maxPacketSize */
      size.b.xfersize = (uint32_t)(ep->xferLength - ep->xferCount);
 8023102:	f8d8 1004 	ldr.w	r1, [r8, #4]
 8023106:	1a5b      	subs	r3, r3, r1
 8023108:	f3c3 0312 	ubfx	r3, r3, #0, #19
  }
  else
  {
    if (ep->address_u.address_st.number == 0U)
    {
      size.b.pktcnt = 1U;
 802310c:	f04f 0c01 	mov.w	ip, #1
 8023110:	e63b      	b.n	8022d8a <XMC_USBD_IRQHandler+0x3be>
  {
    ep->xferLength += ep->maxTransferSize;
  }
  if (ep->xferLength == 0U)
  {
    size.b.xfersize = 0U;
 8023112:	f363 0012 	bfi	r0, r3, #0, #19
    size.b.pktcnt = 1U;
 8023116:	2301      	movs	r3, #1
 8023118:	f363 40dc 	bfi	r0, r3, #19, #10
 802311c:	e644      	b.n	8022da8 <XMC_USBD_IRQHandler+0x3dc>
  volatile uint32_t *fifo;
  uint32_t byte_count;
  uint32_t word_count;
  uint32_t result;
  uint32_t i;
  fifo = xmc_device.fifo[ep->address_u.address_st.number]; /* fifo */
 802311e:	f008 080f 	and.w	r8, r8, #15
  freeSpace.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->dtxfsts;
 8023122:	f108 016a 	add.w	r1, r8, #106	; 0x6a
 8023126:	4f5e      	ldr	r7, [pc, #376]	; (80232a0 <XMC_USBD_IRQHandler+0x8d4>)
 8023128:	f857 1021 	ldr.w	r1, [r7, r1, lsl #2]
  /* calculate the length and the amount of dwords to copy based on the fifo status */
  byte_count = ep->xferLength - ep->xferCount;
 802312c:	6ac7      	ldr	r7, [r0, #44]	; 0x2c
  uint32_t byte_count;
  uint32_t word_count;
  uint32_t result;
  uint32_t i;
  fifo = xmc_device.fifo[ep->address_u.address_st.number]; /* fifo */
  freeSpace.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->dtxfsts;
 802312e:	f8d1 c018 	ldr.w	ip, [r1, #24]
  volatile uint32_t *fifo;
  uint32_t byte_count;
  uint32_t word_count;
  uint32_t result;
  uint32_t i;
  fifo = xmc_device.fifo[ep->address_u.address_st.number]; /* fifo */
 8023132:	495b      	ldr	r1, [pc, #364]	; (80232a0 <XMC_USBD_IRQHandler+0x8d4>)
  freeSpace.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->dtxfsts;
  /* calculate the length and the amount of dwords to copy based on the fifo status */
  byte_count = ep->xferLength - ep->xferCount;
 8023134:	9706      	str	r7, [sp, #24]
  volatile uint32_t *fifo;
  uint32_t byte_count;
  uint32_t word_count;
  uint32_t result;
  uint32_t i;
  fifo = xmc_device.fifo[ep->address_u.address_st.number]; /* fifo */
 8023136:	f108 0878 	add.w	r8, r8, #120	; 0x78
 802313a:	f851 1028 	ldr.w	r1, [r1, r8, lsl #2]
 802313e:	9107      	str	r1, [sp, #28]
  freeSpace.d32 = xmc_device.endpoint_in_register[ep->address_u.address_st.number]->dtxfsts;
  /* calculate the length and the amount of dwords to copy based on the fifo status */
  byte_count = ep->xferLength - ep->xferCount;
  if (!byte_count)
 8023140:	6a81      	ldr	r1, [r0, #40]	; 0x28
 8023142:	1bc9      	subs	r1, r1, r7
 8023144:	9105      	str	r1, [sp, #20]
 8023146:	d051      	beq.n	80231ec <XMC_USBD_IRQHandler+0x820>
    result = 0U;
  }
  else
  {
    /* add the unaligned bytes to the word count to compare with the fifo space */
    word_count = ((uint32_t)byte_count + 3U) >> 2U;
 8023148:	f101 0803 	add.w	r8, r1, #3
    if (word_count > (uint32_t)freeSpace.b.txfspcavail )
 802314c:	fa1f fc8c 	uxth.w	ip, ip
    result = 0U;
  }
  else
  {
    /* add the unaligned bytes to the word count to compare with the fifo space */
    word_count = ((uint32_t)byte_count + 3U) >> 2U;
 8023150:	ea4f 0898 	mov.w	r8, r8, lsr #2
    if (word_count > (uint32_t)freeSpace.b.txfspcavail )
 8023154:	45e0      	cmp	r8, ip
 8023156:	d844      	bhi.n	80231e2 <XMC_USBD_IRQHandler+0x816>
 8023158:	fb0b 410e 	mla	r1, fp, lr, r4
      word_count = (uint32_t)freeSpace.b.txfspcavail;
      byte_count = (uint32_t)word_count << (uint32_t)2U;
    }

    /* copy data dword wise */
    for (i = 0U; i < word_count;ep->xferBuffer+= 4U)
 802315c:	f1b8 0f00 	cmp.w	r8, #0
 8023160:	f000 809b 	beq.w	802329a <XMC_USBD_IRQHandler+0x8ce>
 8023164:	9106      	str	r1, [sp, #24]
 8023166:	f8cd 9024 	str.w	r9, [sp, #36]	; 0x24
 802316a:	6a49      	ldr	r1, [r1, #36]	; 0x24
 802316c:	f8dd c01c 	ldr.w	ip, [sp, #28]
 8023170:	9f02      	ldr	r7, [sp, #8]
 8023172:	f8dd 9018 	ldr.w	r9, [sp, #24]
 8023176:	f8cd e020 	str.w	lr, [sp, #32]
 802317a:	2000      	movs	r0, #0
    {
      *fifo = *(uint32_t*)ep->xferBuffer;
 802317c:	6809      	ldr	r1, [r1, #0]
 802317e:	f8cc 1000 	str.w	r1, [ip]
      word_count = (uint32_t)freeSpace.b.txfspcavail;
      byte_count = (uint32_t)word_count << (uint32_t)2U;
    }

    /* copy data dword wise */
    for (i = 0U; i < word_count;ep->xferBuffer+= 4U)
 8023182:	f8d9 1024 	ldr.w	r1, [r9, #36]	; 0x24
    {
      *fifo = *(uint32_t*)ep->xferBuffer;
      i++;
 8023186:	3001      	adds	r0, #1
      word_count = (uint32_t)freeSpace.b.txfspcavail;
      byte_count = (uint32_t)word_count << (uint32_t)2U;
    }

    /* copy data dword wise */
    for (i = 0U; i < word_count;ep->xferBuffer+= 4U)
 8023188:	3104      	adds	r1, #4
 802318a:	4540      	cmp	r0, r8
 802318c:	f8c9 1024 	str.w	r1, [r9, #36]	; 0x24
 8023190:	d1f4      	bne.n	802317c <XMC_USBD_IRQHandler+0x7b0>
 8023192:	9806      	ldr	r0, [sp, #24]
 8023194:	f8dd e020 	ldr.w	lr, [sp, #32]
 8023198:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
 802319a:	f8dd 9024 	ldr.w	r9, [sp, #36]	; 0x24
 802319e:	9702      	str	r7, [sp, #8]
 80231a0:	9006      	str	r0, [sp, #24]
 80231a2:	4607      	mov	r7, r0
      {
        if (diepint.b.emptyintr)
        {
          uint32_t bytes;
          bytes = XMC_USBD_lWriteFifo(ep);
          ep->xferCount += bytes;
 80231a4:	46bc      	mov	ip, r7
 80231a6:	9f05      	ldr	r7, [sp, #20]
 80231a8:	fb0b 400e 	mla	r0, fp, lr, r4
 80231ac:	44bc      	add	ip, r7
          ep->xferBuffer += bytes;
 80231ae:	4439      	add	r1, r7
      {
        if (diepint.b.emptyintr)
        {
          uint32_t bytes;
          bytes = XMC_USBD_lWriteFifo(ep);
          ep->xferCount += bytes;
 80231b0:	f8c0 c02c 	str.w	ip, [r0, #44]	; 0x2c
          ep->xferBuffer += bytes;
 80231b4:	6241      	str	r1, [r0, #36]	; 0x24
 80231b6:	e588      	b.n	8022cca <XMC_USBD_IRQHandler+0x2fe>
    if(usbd_init->usbd_transfer_mode == XMC_USBD_USE_DMA)
    {
      /* Program dma*/
      xmc_device.endpoint_in_register[ep->address_u.address_st.number]->diepdma = (uint32_t)ep->xferBuffer;
    }
    if(usbd_init->usbd_transfer_mode == XMC_USBD_USE_FIFO)
 80231b8:	2901      	cmp	r1, #1
 80231ba:	f47f adf5 	bne.w	8022da8 <XMC_USBD_IRQHandler+0x3dc>
    {
      /* enable fifo empty interrupt */
			xmc_device.device_register->dtknqr4_fifoemptymsk |= (uint32_t)((uint32_t)1U << (uint8_t)ep->address_u.address_st.number);
 80231be:	9f06      	ldr	r7, [sp, #24]
 80231c0:	f8da 3034 	ldr.w	r3, [sl, #52]	; 0x34
 80231c4:	40b9      	lsls	r1, r7
 80231c6:	4319      	orrs	r1, r3
 80231c8:	f8ca 1034 	str.w	r1, [sl, #52]	; 0x34
 80231cc:	e5ec      	b.n	8022da8 <XMC_USBD_IRQHandler+0x3dc>
          ep->inInUse = 0U;
          if(obj->usbd_transfer_mode == XMC_USBD_USE_FIFO)
          {
            /* mask fifo empty interrupt */
            xmc_device.device_register->dtknqr4_fifoemptymsk =
            (uint32_t)(xmc_device.device_register->dtknqr4_fifoemptymsk & ~(((uint32_t)1U << ep_num)));
 80231ce:	4b34      	ldr	r3, [pc, #208]	; (80232a0 <XMC_USBD_IRQHandler+0x8d4>)
 80231d0:	f8d3 11a4 	ldr.w	r1, [r3, #420]	; 0x1a4
 80231d4:	6b4b      	ldr	r3, [r1, #52]	; 0x34
 80231d6:	fa02 f20e 	lsl.w	r2, r2, lr
 80231da:	ea23 0202 	bic.w	r2, r3, r2
        {
          ep->inInUse = 0U;
          if(obj->usbd_transfer_mode == XMC_USBD_USE_FIFO)
          {
            /* mask fifo empty interrupt */
            xmc_device.device_register->dtknqr4_fifoemptymsk =
 80231de:	634a      	str	r2, [r1, #52]	; 0x34
 80231e0:	e582      	b.n	8022ce8 <XMC_USBD_IRQHandler+0x31c>
    /* add the unaligned bytes to the word count to compare with the fifo space */
    word_count = ((uint32_t)byte_count + 3U) >> 2U;
    if (word_count > (uint32_t)freeSpace.b.txfspcavail )
    {
      word_count = (uint32_t)freeSpace.b.txfspcavail;
      byte_count = (uint32_t)word_count << (uint32_t)2U;
 80231e2:	ea4f 018c 	mov.w	r1, ip, lsl #2
 80231e6:	9105      	str	r1, [sp, #20]
 80231e8:	46e0      	mov	r8, ip
 80231ea:	e7b5      	b.n	8023158 <XMC_USBD_IRQHandler+0x78c>
 80231ec:	6a41      	ldr	r1, [r0, #36]	; 0x24
 80231ee:	9f06      	ldr	r7, [sp, #24]
 80231f0:	e7d8      	b.n	80231a4 <XMC_USBD_IRQHandler+0x7d8>
    case XMC_USBD_GRXSTS_PKTSTS_GOUTNAK:
      break;
    case XMC_USBD_GRXSTS_PKTSTS_OUTCMPL:
      break;
    case XMC_USBD_GRXSTS_PKTSTS_OUTDATA:
      XMC_USBD_lReadFifo((uint32_t)data.b.epnum,(uint32_t)data.b.bcnt);
 80231f2:	f002 070f 	and.w	r7, r2, #15
  uint32_t temp_data;
  uint32_t temp_word_count;
  volatile uint32_t *fifo = xmc_device.fifo[0U];
  uint32_t i;
  depctl_data_t data;
  data.d32 = xmc_device.endpoint_out_register[ep_num]->doepctl;
 80231f6:	eb04 0187 	add.w	r1, r4, r7, lsl #2
    case XMC_USBD_GRXSTS_PKTSTS_GOUTNAK:
      break;
    case XMC_USBD_GRXSTS_PKTSTS_OUTCMPL:
      break;
    case XMC_USBD_GRXSTS_PKTSTS_OUTDATA:
      XMC_USBD_lReadFifo((uint32_t)data.b.epnum,(uint32_t)data.b.bcnt);
 80231fa:	f3c2 100a 	ubfx	r0, r2, #4, #11
  uint32_t temp_data;
  uint32_t temp_word_count;
  volatile uint32_t *fifo = xmc_device.fifo[0U];
  uint32_t i;
  depctl_data_t data;
  data.d32 = xmc_device.endpoint_out_register[ep_num]->doepctl;
 80231fe:	f8d1 21c4 	ldr.w	r2, [r1, #452]	; 0x1c4
{
  XMC_USBD_EP_t * ep = &xmc_device.ep[ep_num];
  uint32_t word_count;
  uint32_t temp_data;
  uint32_t temp_word_count;
  volatile uint32_t *fifo = xmc_device.fifo[0U];
 8023202:	f8d4 c1e0 	ldr.w	ip, [r4, #480]	; 0x1e0
  uint32_t i;
  depctl_data_t data;
  data.d32 = xmc_device.endpoint_out_register[ep_num]->doepctl;
 8023206:	6812      	ldr	r2, [r2, #0]
{
  XMC_USBD_EP_t * ep = &xmc_device.ep[ep_num];
  uint32_t word_count;
  uint32_t temp_data;
  uint32_t temp_word_count;
  volatile uint32_t *fifo = xmc_device.fifo[0U];
 8023208:	4925      	ldr	r1, [pc, #148]	; (80232a0 <XMC_USBD_IRQHandler+0x8d4>)
  depctl_data_t data;
  data.d32 = xmc_device.endpoint_out_register[ep_num]->doepctl;
  word_count = (byte_count >> 2U );
  temp_word_count = (word_count << 2U);
  /* Check if ep is enabled and has buffer */
  if (!data.b.usbactep)
 802320a:	0412      	lsls	r2, r2, #16
 802320c:	f57f af3e 	bpl.w	802308c <XMC_USBD_IRQHandler+0x6c0>
  {
    /*Do Nothing*/
  }
  else if (ep->xferBuffer == NULL)
 8023210:	2234      	movs	r2, #52	; 0x34
 8023212:	fb02 1e07 	mla	lr, r2, r7, r1
 8023216:	f8de 1024 	ldr.w	r1, [lr, #36]	; 0x24
 802321a:	2900      	cmp	r1, #0
 802321c:	f43f af36 	beq.w	802308c <XMC_USBD_IRQHandler+0x6c0>
	/*Do Nothing*/
  }
  else
  {
    /* store the data */
    for (i = 0U;i < word_count; i++)
 8023220:	ea5f 0890 	movs.w	r8, r0, lsr #2
 8023224:	d00f      	beq.n	8023246 <XMC_USBD_IRQHandler+0x87a>
 8023226:	ea4f 0888 	mov.w	r8, r8, lsl #2
 802322a:	2200      	movs	r2, #0
 802322c:	e001      	b.n	8023232 <XMC_USBD_IRQHandler+0x866>
 802322e:	f8de 1024 	ldr.w	r1, [lr, #36]	; 0x24
    {
      *(((uint32_t*)ep->xferBuffer)+i) = *fifo;
 8023232:	f8dc 6000 	ldr.w	r6, [ip]
 8023236:	508e      	str	r6, [r1, r2]
 8023238:	3204      	adds	r2, #4
	/*Do Nothing*/
  }
  else
  {
    /* store the data */
    for (i = 0U;i < word_count; i++)
 802323a:	4542      	cmp	r2, r8
 802323c:	d1f7      	bne.n	802322e <XMC_USBD_IRQHandler+0x862>
 802323e:	2234      	movs	r2, #52	; 0x34
 8023240:	fb02 4207 	mla	r2, r2, r7, r4
 8023244:	6a51      	ldr	r1, [r2, #36]	; 0x24
    {
      *(((uint32_t*)ep->xferBuffer)+i) = *fifo;
    }
    /* space is not devidable by 4 */
    if (byte_count!=temp_word_count)
 8023246:	4540      	cmp	r0, r8
 8023248:	d01e      	beq.n	8023288 <XMC_USBD_IRQHandler+0x8bc>
    {
      temp_data = *fifo;
 802324a:	f8dc c000 	ldr.w	ip, [ip]
      for (i = 0U;(temp_word_count + i) < byte_count;i++)
 802324e:	d91b      	bls.n	8023288 <XMC_USBD_IRQHandler+0x8bc>
 8023250:	f04f 0e34 	mov.w	lr, #52	; 0x34
 8023254:	4643      	mov	r3, r8
 8023256:	fb0e 4e07 	mla	lr, lr, r7, r4
 802325a:	2600      	movs	r6, #0
      {
        ep->xferBuffer[(word_count << 2)+i] = (uint8_t)((temp_data & ((uint32_t)0xFFU << (i * 8U))) >> (i * 8U));
 802325c:	f04f 08ff 	mov.w	r8, #255	; 0xff
 8023260:	e001      	b.n	8023266 <XMC_USBD_IRQHandler+0x89a>
 8023262:	f8de 1024 	ldr.w	r1, [lr, #36]	; 0x24
 8023266:	fa08 f206 	lsl.w	r2, r8, r6
 802326a:	ea02 020c 	and.w	r2, r2, ip
 802326e:	40f2      	lsrs	r2, r6
 8023270:	54ca      	strb	r2, [r1, r3]
    }
    /* space is not devidable by 4 */
    if (byte_count!=temp_word_count)
    {
      temp_data = *fifo;
      for (i = 0U;(temp_word_count + i) < byte_count;i++)
 8023272:	3301      	adds	r3, #1
 8023274:	4298      	cmp	r0, r3
 8023276:	f106 0608 	add.w	r6, r6, #8
 802327a:	d1f2      	bne.n	8023262 <XMC_USBD_IRQHandler+0x896>
 802327c:	2234      	movs	r2, #52	; 0x34
 802327e:	fb02 4207 	mla	r2, r2, r7, r4
 8023282:	f8d4 31a0 	ldr.w	r3, [r4, #416]	; 0x1a0
 8023286:	6a51      	ldr	r1, [r2, #36]	; 0x24
        ep->xferBuffer[(word_count << 2)+i] = (uint8_t)((temp_data & ((uint32_t)0xFFU << (i * 8U))) >> (i * 8U));
      }
    }

    /* save the amount of data */
    ep->xferCount += byte_count;
 8023288:	2234      	movs	r2, #52	; 0x34
 802328a:	fb02 4707 	mla	r7, r2, r7, r4
    ep->xferBuffer += byte_count;
 802328e:	4401      	add	r1, r0
        ep->xferBuffer[(word_count << 2)+i] = (uint8_t)((temp_data & ((uint32_t)0xFFU << (i * 8U))) >> (i * 8U));
      }
    }

    /* save the amount of data */
    ep->xferCount += byte_count;
 8023290:	6afa      	ldr	r2, [r7, #44]	; 0x2c
    ep->xferBuffer += byte_count;
 8023292:	6279      	str	r1, [r7, #36]	; 0x24
        ep->xferBuffer[(word_count << 2)+i] = (uint8_t)((temp_data & ((uint32_t)0xFFU << (i * 8U))) >> (i * 8U));
      }
    }

    /* save the amount of data */
    ep->xferCount += byte_count;
 8023294:	4402      	add	r2, r0
 8023296:	62fa      	str	r2, [r7, #44]	; 0x2c
 8023298:	e6f8      	b.n	802308c <XMC_USBD_IRQHandler+0x6c0>
 802329a:	6a49      	ldr	r1, [r1, #36]	; 0x24
 802329c:	9f06      	ldr	r7, [sp, #24]
 802329e:	e781      	b.n	80231a4 <XMC_USBD_IRQHandler+0x7d8>
 80232a0:	1fff0094 	.word	0x1fff0094

080232a4 <XMC_USBD_Disable>:

/**
 * Disables the USB0 module
 **/
void XMC_USBD_Disable(void) 
{
 80232a4:	b510      	push	{r4, lr}
  /* Clear Reset and power up */
  XMC_SCU_RESET_AssertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_USB0);
 80232a6:	4c05      	ldr	r4, [pc, #20]	; (80232bc <XMC_USBD_Disable+0x18>)
 80232a8:	4620      	mov	r0, r4
 80232aa:	f7fd fe8d 	bl	8020fc8 <XMC_SCU_RESET_AssertPeripheralReset>
#if defined(CLOCK_GATING_SUPPORTED)
  XMC_SCU_CLOCK_GatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_USB0);
 80232ae:	4620      	mov	r0, r4
 80232b0:	f7fd ff06 	bl	80210c0 <XMC_SCU_CLOCK_GatePeripheralClock>
#endif
  XMC_SCU_POWER_DisableUsb();
}
 80232b4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  /* Clear Reset and power up */
  XMC_SCU_RESET_AssertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_USB0);
#if defined(CLOCK_GATING_SUPPORTED)
  XMC_SCU_CLOCK_GatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_USB0);
#endif
  XMC_SCU_POWER_DisableUsb();
 80232b8:	f7fd bf54 	b.w	8021164 <XMC_SCU_POWER_DisableUsb>
 80232bc:	20000080 	.word	0x20000080

080232c0 <XMC_USIC_CH_Enable>:

void XMC_USIC_CH_Enable(XMC_USIC_CH_t *const channel)
{
  XMC_ASSERT("XMC_USIC_CH_Enable: channel not valid", XMC_USIC_IsChannelValid(channel));

  if ((channel == XMC_USIC0_CH0) || (channel == XMC_USIC0_CH1))
 80232c0:	4b1b      	ldr	r3, [pc, #108]	; (8023330 <XMC_USIC_CH_Enable+0x70>)
 80232c2:	4298      	cmp	r0, r3
/*******************************************************************************
 * API IMPLEMENTATION
 *******************************************************************************/

void XMC_USIC_CH_Enable(XMC_USIC_CH_t *const channel)
{
 80232c4:	b510      	push	{r4, lr}
 80232c6:	4604      	mov	r4, r0
  XMC_ASSERT("XMC_USIC_CH_Enable: channel not valid", XMC_USIC_IsChannelValid(channel));

  if ((channel == XMC_USIC0_CH0) || (channel == XMC_USIC0_CH1))
 80232c8:	d01b      	beq.n	8023302 <XMC_USIC_CH_Enable+0x42>
 80232ca:	f503 7300 	add.w	r3, r3, #512	; 0x200
 80232ce:	4298      	cmp	r0, r3
 80232d0:	d017      	beq.n	8023302 <XMC_USIC_CH_Enable+0x42>
  {
    XMC_USIC_Enable(XMC_USIC0);
  }
#if defined(USIC1)
  else if((channel == XMC_USIC1_CH0) || (channel == XMC_USIC1_CH1))
 80232d2:	4b18      	ldr	r3, [pc, #96]	; (8023334 <XMC_USIC_CH_Enable+0x74>)
 80232d4:	4298      	cmp	r0, r3
 80232d6:	d024      	beq.n	8023322 <XMC_USIC_CH_Enable+0x62>
 80232d8:	f503 7300 	add.w	r3, r3, #512	; 0x200
 80232dc:	4298      	cmp	r0, r3
 80232de:	d020      	beq.n	8023322 <XMC_USIC_CH_Enable+0x62>
  {
    XMC_USIC_Enable(XMC_USIC1);
  }
#endif
#if defined(USIC2)
  else if((channel == XMC_USIC2_CH0) || (channel == XMC_USIC2_CH1))
 80232e0:	4b15      	ldr	r3, [pc, #84]	; (8023338 <XMC_USIC_CH_Enable+0x78>)
 80232e2:	4298      	cmp	r0, r3
 80232e4:	d016      	beq.n	8023314 <XMC_USIC_CH_Enable+0x54>
 80232e6:	f503 7300 	add.w	r3, r3, #512	; 0x200
 80232ea:	4298      	cmp	r0, r3
 80232ec:	d012      	beq.n	8023314 <XMC_USIC_CH_Enable+0x54>
  {
    XMC_ASSERT("USIC module not available", 0U/*Always*/);
  }

  /* USIC channel switched on*/
  channel->KSCFG = (USIC_CH_KSCFG_MODEN_Msk | USIC_CH_KSCFG_BPMODEN_Msk);
 80232ee:	2303      	movs	r3, #3
 80232f0:	60e3      	str	r3, [r4, #12]
  while ((channel->KSCFG & USIC_CH_KSCFG_MODEN_Msk) == 0U)
 80232f2:	68e3      	ldr	r3, [r4, #12]
 80232f4:	07db      	lsls	r3, r3, #31
 80232f6:	d5fc      	bpl.n	80232f2 <XMC_USIC_CH_Enable+0x32>
  {
    /* Wait till the channel is enabled */
  }

  /* Set USIC channel in IDLE mode */
  channel->CCR &= (uint32_t)~USIC_CH_CCR_MODE_Msk;
 80232f8:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80232fa:	f023 030f 	bic.w	r3, r3, #15
 80232fe:	6423      	str	r3, [r4, #64]	; 0x40
 8023300:	bd10      	pop	{r4, pc}
void XMC_USIC_Enable(XMC_USIC_t *const usic)
{
  if (usic == USIC0)
  {
#if defined(CLOCK_GATING_SUPPORTED)
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_USIC0);
 8023302:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8023306:	f7fd fee7 	bl	80210d8 <XMC_SCU_CLOCK_UngatePeripheralClock>
#endif
#if defined(PERIPHERAL_RESET_SUPPORTED)
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_USIC0);
 802330a:	f44f 6000 	mov.w	r0, #2048	; 0x800
 802330e:	f7fd fe67 	bl	8020fe0 <XMC_SCU_RESET_DeassertPeripheralReset>
 8023312:	e7ec      	b.n	80232ee <XMC_USIC_CH_Enable+0x2e>
#endif  
#if defined(USIC2)  
  else if (usic == USIC2)
  {
#if defined(CLOCK_GATING_SUPPORTED) 
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_USIC2);
 8023314:	4809      	ldr	r0, [pc, #36]	; (802333c <XMC_USIC_CH_Enable+0x7c>)
 8023316:	f7fd fedf 	bl	80210d8 <XMC_SCU_CLOCK_UngatePeripheralClock>
#endif
#if defined(PERIPHERAL_RESET_SUPPORTED)
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_USIC2);
 802331a:	4808      	ldr	r0, [pc, #32]	; (802333c <XMC_USIC_CH_Enable+0x7c>)
 802331c:	f7fd fe60 	bl	8020fe0 <XMC_SCU_RESET_DeassertPeripheralReset>
 8023320:	e7e5      	b.n	80232ee <XMC_USIC_CH_Enable+0x2e>
  }
#if defined(USIC1)  
  else if (usic == USIC1)
  {
#if defined(CLOCK_GATING_SUPPORTED)
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_USIC1);
 8023322:	4807      	ldr	r0, [pc, #28]	; (8023340 <XMC_USIC_CH_Enable+0x80>)
 8023324:	f7fd fed8 	bl	80210d8 <XMC_SCU_CLOCK_UngatePeripheralClock>
#endif	
#if defined(PERIPHERAL_RESET_SUPPORTED)
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_USIC1);
 8023328:	4805      	ldr	r0, [pc, #20]	; (8023340 <XMC_USIC_CH_Enable+0x80>)
 802332a:	f7fd fe59 	bl	8020fe0 <XMC_SCU_RESET_DeassertPeripheralReset>
 802332e:	e7de      	b.n	80232ee <XMC_USIC_CH_Enable+0x2e>
 8023330:	40030000 	.word	0x40030000
 8023334:	48020000 	.word	0x48020000
 8023338:	48024000 	.word	0x48024000
 802333c:	10000100 	.word	0x10000100
 8023340:	10000080 	.word	0x10000080

08023344 <XMC_USIC_CH_SetBaudrate>:
  
  uint32_t pdiv_frac;
  uint32_t pdiv_frac_min;

  /* The rate and peripheral clock are divided by 100 to be able to use only 32bit arithmetic */
  if ((rate >= 100U) && (oversampling != 0U))
 8023344:	2963      	cmp	r1, #99	; 0x63
 8023346:	d900      	bls.n	802334a <XMC_USIC_CH_SetBaudrate+0x6>
 8023348:	b90a      	cbnz	r2, 802334e <XMC_USIC_CH_SetBaudrate+0xa>
                    
    status = XMC_USIC_CH_STATUS_OK;
  }
  else 
  {
    status = XMC_USIC_CH_STATUS_ERROR;
 802334a:	2001      	movs	r0, #1
 802334c:	4770      	bx	lr
{
  channel->KSCFG = (uint32_t)((channel->KSCFG & (~USIC_CH_KSCFG_MODEN_Msk)) | USIC_CH_KSCFG_BPMODEN_Msk);
}

XMC_USIC_CH_STATUS_t XMC_USIC_CH_SetBaudrate(XMC_USIC_CH_t *const channel, uint32_t rate, uint32_t oversampling)
{
 802334e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8023352:	4617      	mov	r7, r2
 8023354:	460c      	mov	r4, r1
 8023356:	4606      	mov	r6, r0
  uint32_t pdiv_frac_min;

  /* The rate and peripheral clock are divided by 100 to be able to use only 32bit arithmetic */
  if ((rate >= 100U) && (oversampling != 0U))
  {
    peripheral_clock = XMC_SCU_CLOCK_GetPeripheralClockFrequency() / 100U;
 8023358:	f7fd fe5e 	bl	8021018 <XMC_SCU_CLOCK_GetPeripheralClockFrequency>
 802335c:	4d18      	ldr	r5, [pc, #96]	; (80233c0 <XMC_USIC_CH_SetBaudrate+0x7c>)
 802335e:	fba5 3200 	umull	r3, r2, r5, r0
    rate = rate / 100U;
 8023362:	fba5 3504 	umull	r3, r5, r5, r4
  uint32_t pdiv_frac_min;

  /* The rate and peripheral clock are divided by 100 to be able to use only 32bit arithmetic */
  if ((rate >= 100U) && (oversampling != 0U))
  {
    peripheral_clock = XMC_SCU_CLOCK_GetPeripheralClockFrequency() / 100U;
 8023366:	0952      	lsrs	r2, r2, #5
    rate = rate / 100U;
 8023368:	096d      	lsrs	r5, r5, #5

    clock_divider_min = 1U;
    pdiv_int_min = 1U;
    pdiv_frac_min = 0x3ffU;
 802336a:	f240 3eff 	movw	lr, #1023	; 0x3ff
  {
    peripheral_clock = XMC_SCU_CLOCK_GetPeripheralClockFrequency() / 100U;
    rate = rate / 100U;

    clock_divider_min = 1U;
    pdiv_int_min = 1U;
 802336e:	f04f 0c01 	mov.w	ip, #1
 8023372:	fb07 f505 	mul.w	r5, r7, r5
 8023376:	ebc2 2182 	rsb	r1, r2, r2, lsl #10
    pdiv_frac_min = 0x3ffU;

    for(clock_divider = 1023U; clock_divider > 0U; --clock_divider)
 802337a:	4670      	mov	r0, lr
  if ((rate >= 100U) && (oversampling != 0U))
  {
    peripheral_clock = XMC_SCU_CLOCK_GetPeripheralClockFrequency() / 100U;
    rate = rate / 100U;

    clock_divider_min = 1U;
 802337c:	46e0      	mov	r8, ip
    pdiv_int_min = 1U;
    pdiv_frac_min = 0x3ffU;

    for(clock_divider = 1023U; clock_divider > 0U; --clock_divider)
    {
      pdiv = ((peripheral_clock * clock_divider) / (rate * oversampling));
 802337e:	fbb1 f3f5 	udiv	r3, r1, r5
      pdiv_int = pdiv >> 10U;
 8023382:	0a9c      	lsrs	r4, r3, #10
      pdiv_frac = pdiv & 0x3ffU;

      if ((pdiv_int < 1024U) && (pdiv_frac < pdiv_frac_min))
 8023384:	f5b4 6f80 	cmp.w	r4, #1024	; 0x400

    for(clock_divider = 1023U; clock_divider > 0U; --clock_divider)
    {
      pdiv = ((peripheral_clock * clock_divider) / (rate * oversampling));
      pdiv_int = pdiv >> 10U;
      pdiv_frac = pdiv & 0x3ffU;
 8023388:	f3c3 0309 	ubfx	r3, r3, #0, #10
 802338c:	eba1 0102 	sub.w	r1, r1, r2

      if ((pdiv_int < 1024U) && (pdiv_frac < pdiv_frac_min))
 8023390:	d204      	bcs.n	802339c <XMC_USIC_CH_SetBaudrate+0x58>
 8023392:	4573      	cmp	r3, lr
 8023394:	d202      	bcs.n	802339c <XMC_USIC_CH_SetBaudrate+0x58>
 8023396:	469e      	mov	lr, r3
 8023398:	46a4      	mov	ip, r4
 802339a:	4680      	mov	r8, r0

    clock_divider_min = 1U;
    pdiv_int_min = 1U;
    pdiv_frac_min = 0x3ffU;

    for(clock_divider = 1023U; clock_divider > 0U; --clock_divider)
 802339c:	3801      	subs	r0, #1
 802339e:	d1ee      	bne.n	802337e <XMC_USIC_CH_SetBaudrate+0x3a>
        pdiv_int_min = pdiv_int;
        clock_divider_min = clock_divider;
      }
    }

    channel->FDR = XMC_USIC_CH_BRG_CLOCK_DIVIDER_MODE_FRACTIONAL |
 80233a0:	f448 4300 	orr.w	r3, r8, #32768	; 0x8000
 80233a4:	6133      	str	r3, [r6, #16]
                   (clock_divider_min << USIC_CH_FDR_STEP_Pos);

    channel->BRG = (channel->BRG & ~(USIC_CH_BRG_DCTQ_Msk |
 80233a6:	6972      	ldr	r2, [r6, #20]
 80233a8:	4b06      	ldr	r3, [pc, #24]	; (80233c4 <XMC_USIC_CH_SetBaudrate+0x80>)
                                     USIC_CH_BRG_PDIV_Msk |
                                     USIC_CH_BRG_PCTQ_Msk |
                                     USIC_CH_BRG_PPPEN_Msk)) |
                   ((oversampling - 1U) << USIC_CH_BRG_DCTQ_Pos) |
 80233aa:	3f01      	subs	r7, #1
    }

    channel->FDR = XMC_USIC_CH_BRG_CLOCK_DIVIDER_MODE_FRACTIONAL |
                   (clock_divider_min << USIC_CH_FDR_STEP_Pos);

    channel->BRG = (channel->BRG & ~(USIC_CH_BRG_DCTQ_Msk |
 80233ac:	4013      	ands	r3, r2
                                     USIC_CH_BRG_PDIV_Msk |
                                     USIC_CH_BRG_PCTQ_Msk |
                                     USIC_CH_BRG_PPPEN_Msk)) |
                   ((oversampling - 1U) << USIC_CH_BRG_DCTQ_Pos) |
                   ((pdiv_int_min - 1U) << USIC_CH_BRG_PDIV_Pos);
 80233ae:	f10c 3cff 	add.w	ip, ip, #4294967295
                   (clock_divider_min << USIC_CH_FDR_STEP_Pos);

    channel->BRG = (channel->BRG & ~(USIC_CH_BRG_DCTQ_Msk |
                                     USIC_CH_BRG_PDIV_Msk |
                                     USIC_CH_BRG_PCTQ_Msk |
                                     USIC_CH_BRG_PPPEN_Msk)) |
 80233b2:	ea43 2387 	orr.w	r3, r3, r7, lsl #10
                   ((oversampling - 1U) << USIC_CH_BRG_DCTQ_Pos) |
 80233b6:	ea43 430c 	orr.w	r3, r3, ip, lsl #16
    }

    channel->FDR = XMC_USIC_CH_BRG_CLOCK_DIVIDER_MODE_FRACTIONAL |
                   (clock_divider_min << USIC_CH_FDR_STEP_Pos);

    channel->BRG = (channel->BRG & ~(USIC_CH_BRG_DCTQ_Msk |
 80233ba:	6173      	str	r3, [r6, #20]
                                     USIC_CH_BRG_PCTQ_Msk |
                                     USIC_CH_BRG_PPPEN_Msk)) |
                   ((oversampling - 1U) << USIC_CH_BRG_DCTQ_Pos) |
                   ((pdiv_int_min - 1U) << USIC_CH_BRG_PDIV_Pos);
                    
    status = XMC_USIC_CH_STATUS_OK;
 80233bc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80233c0:	51eb851f 	.word	0x51eb851f
 80233c4:	fc0080ef 	.word	0xfc0080ef

080233c8 <XMC_VADC_GLOBAL_Init>:
}


/* API to initialize global resources */
void XMC_VADC_GLOBAL_Init(XMC_VADC_GLOBAL_t *const global_ptr, const XMC_VADC_GLOBAL_CONFIG_t *config)
{
 80233c8:	b538      	push	{r3, r4, r5, lr}
 80233ca:	460d      	mov	r5, r1
 80233cc:	4604      	mov	r4, r0
#if defined (COMPARATOR)
  COMPARATOR->ORCCTRL = (uint32_t)0xFF;
#endif

#if defined(CLOCK_GATING_SUPPORTED)
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_VADC);
 80233ce:	2001      	movs	r0, #1
 80233d0:	f7fd fe82 	bl	80210d8 <XMC_SCU_CLOCK_UngatePeripheralClock>
#endif

#if defined(PERIPHERAL_RESET_SUPPORTED)
  /* Reset the Hardware */
  XMC_SCU_RESET_DeassertPeripheralReset((XMC_SCU_PERIPHERAL_RESET_t)XMC_SCU_PERIPHERAL_RESET_VADC );
 80233d4:	2001      	movs	r0, #1
 80233d6:	f7fd fe03 	bl	8020fe0 <XMC_SCU_RESET_DeassertPeripheralReset>
  XMC_ASSERT("XMC_VADC_GLOBAL_Init:Wrong Module Pointer", (global_ptr == VADC))

  /* Enable the VADC module*/
  XMC_VADC_GLOBAL_EnableModule();

  global_ptr->CLC = (uint32_t)(config->clc);
 80233da:	696b      	ldr	r3, [r5, #20]
 80233dc:	6023      	str	r3, [r4, #0]

  /* Clock configuration */

#if (XMC_VADC_GROUP_AVAILABLE == 1U)
  global_ptr->GLOBCFG  = (uint32_t)(config->clock_config.globcfg | (uint32_t)(VADC_GLOBCFG_DIVWC_Msk));
 80233de:	686b      	ldr	r3, [r5, #4]
 80233e0:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80233e4:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
#endif

  /* ICLASS-0 configuration */
  global_ptr->GLOBICLASS[0] = (uint32_t)(config->class0.globiclass);
 80233e8:	68ab      	ldr	r3, [r5, #8]
 80233ea:	f8c4 30a0 	str.w	r3, [r4, #160]	; 0xa0

  /* ICLASS-1 configuration */
  global_ptr->GLOBICLASS[1] = (uint32_t)(config->class1.globiclass);
 80233ee:	68eb      	ldr	r3, [r5, #12]
 80233f0:	f8c4 30a4 	str.w	r3, [r4, #164]	; 0xa4


  /*Result generation related configuration */
  global_ptr->GLOBRCR = (uint32_t)(config->globrcr);
 80233f4:	692b      	ldr	r3, [r5, #16]
 80233f6:	f8c4 3280 	str.w	r3, [r4, #640]	; 0x280

#if (XMC_VADC_BOUNDARY_AVAILABLE == 1U)

  /* Boundaries */
  global_ptr->GLOBBOUND = (uint32_t)(config->globbound);
 80233fa:	682b      	ldr	r3, [r5, #0]
 80233fc:	f8c4 30b8 	str.w	r3, [r4, #184]	; 0xb8
 8023400:	bd38      	pop	{r3, r4, r5, pc}
 8023402:	bf00      	nop

08023404 <XMC_VADC_GLOBAL_InputClassInit>:
  XMC_ASSERT("XMC_VADC_GLOBAL_InputClassInit:Wrong Module Pointer", (global_ptr == VADC))
  XMC_ASSERT("XMC_VADC_GLOBAL_InputClassInit:Wrong Conversion Type", ((conv_type) <= XMC_VADC_GROUP_CONV_EMUX))
  XMC_ASSERT("XMC_VADC_GLOBAL_InputClassInit:Wrong ICLASS set number", (set_num < XMC_VADC_MAX_ICLASS_SET))

#if(XMC_VADC_EMUX_AVAILABLE == 1U)
  if (conv_type == XMC_VADC_GROUP_CONV_STD )
 8023404:	b12a      	cbz	r2, 8023412 <XMC_VADC_GLOBAL_InputClassInit+0xe>
                                      (uint32_t)(VADC_GLOBICLASS_CMS_Msk | VADC_GLOBICLASS_STCS_Msk);
#if(XMC_VADC_EMUX_AVAILABLE == 1U)
  }
  else
  {
    global_ptr->GLOBICLASS[set_num] = config.globiclass & (uint32_t)(VADC_GLOBICLASS_CME_Msk | VADC_GLOBICLASS_STCE_Msk);
 8023406:	4a06      	ldr	r2, [pc, #24]	; (8023420 <XMC_VADC_GLOBAL_InputClassInit+0x1c>)
 8023408:	3328      	adds	r3, #40	; 0x28
 802340a:	400a      	ands	r2, r1
 802340c:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
 8023410:	4770      	bx	lr

#if(XMC_VADC_EMUX_AVAILABLE == 1U)
  if (conv_type == XMC_VADC_GROUP_CONV_STD )
  {
#endif
    global_ptr->GLOBICLASS[set_num] = config.globiclass &
 8023412:	3328      	adds	r3, #40	; 0x28
 8023414:	f240 721f 	movw	r2, #1823	; 0x71f
 8023418:	400a      	ands	r2, r1
 802341a:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
 802341e:	4770      	bx	lr
 8023420:	071f0000 	.word	0x071f0000

08023424 <XMC_VADC_GLOBAL_StartupCalibration>:
  VADC_G_TypeDef *group_ptr;
#endif
  
  XMC_ASSERT("XMC_VADC_GLOBAL_StartupCalibration:Wrong Module Pointer", (global_ptr == VADC))

  global_ptr->GLOBCFG |= (uint32_t)VADC_GLOBCFG_SUCAL_Msk;
 8023424:	f8d0 3080 	ldr.w	r3, [r0, #128]	; 0x80
 8023428:	490c      	ldr	r1, [pc, #48]	; (802345c <XMC_VADC_GLOBAL_StartupCalibration+0x38>)
 802342a:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 802342e:	f8c0 3080 	str.w	r3, [r0, #128]	; 0x80
 8023432:	f101 0010 	add.w	r0, r1, #16

#if (XMC_VADC_GROUP_AVAILABLE == 1U)
  /* Loop until all active groups finish calibration */
  for(i=0U; i<XMC_VADC_MAXIMUM_NUM_GROUPS; i++)
  {
    group_ptr = g_xmc_vadc_group_array[i];
 8023436:	f851 2b04 	ldr.w	r2, [r1], #4
    if ( (group_ptr->ARBCFG) & (uint32_t)VADC_G_ARBCFG_ANONS_Msk)
 802343a:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
 802343e:	f413 3f40 	tst.w	r3, #196608	; 0x30000
 8023442:	d102      	bne.n	802344a <XMC_VADC_GLOBAL_StartupCalibration+0x26>

  global_ptr->GLOBCFG |= (uint32_t)VADC_GLOBCFG_SUCAL_Msk;

#if (XMC_VADC_GROUP_AVAILABLE == 1U)
  /* Loop until all active groups finish calibration */
  for(i=0U; i<XMC_VADC_MAXIMUM_NUM_GROUPS; i++)
 8023444:	4281      	cmp	r1, r0
 8023446:	d1f6      	bne.n	8023436 <XMC_VADC_GLOBAL_StartupCalibration+0x12>
         XMC_VADC_SHS_START_UP_CAL_ACTIVE )
  {
    /* NOP */
  }
#endif
}
 8023448:	4770      	bx	lr
  {
    group_ptr = g_xmc_vadc_group_array[i];
    if ( (group_ptr->ARBCFG) & (uint32_t)VADC_G_ARBCFG_ANONS_Msk)
    {
      /* This group is active. Loop until it finishes calibration */
      while((group_ptr->ARBCFG) & (uint32_t)VADC_G_ARBCFG_CAL_Msk)
 802344a:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
 802344e:	00db      	lsls	r3, r3, #3
 8023450:	d5f8      	bpl.n	8023444 <XMC_VADC_GLOBAL_StartupCalibration+0x20>
 8023452:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
 8023456:	00db      	lsls	r3, r3, #3
 8023458:	d4f7      	bmi.n	802344a <XMC_VADC_GLOBAL_StartupCalibration+0x26>
 802345a:	e7f3      	b.n	8023444 <XMC_VADC_GLOBAL_StartupCalibration+0x20>
 802345c:	0802f2e4 	.word	0x0802f2e4

08023460 <XMC_VADC_GROUP_Init>:
}

/* API to initialize an instance of group of VADC hardware */
#if (XMC_VADC_GROUP_AVAILABLE == 1U)  
void XMC_VADC_GROUP_Init( XMC_VADC_GROUP_t *const group_ptr, const XMC_VADC_GROUP_CONFIG_t *config)
{
 8023460:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8023464:	794b      	ldrb	r3, [r1, #5]
    sample_time      = (uint32_t) config.sampling_phase_emux_channel;
    conv_mode        = (XMC_VADC_CONVMODE_t)config.conversion_mode_emux;
  }

  /* Determine the class */
  conv_class  = group_ptr->ICLASS[set_num];
 8023466:	f8d0 50a0 	ldr.w	r5, [r0, #160]	; 0xa0
 802346a:	f891 a004 	ldrb.w	sl, [r1, #4]
 802346e:	78ce      	ldrb	r6, [r1, #3]
 8023470:	7acc      	ldrb	r4, [r1, #11]
 8023472:	f891 b007 	ldrb.w	fp, [r1, #7]
 8023476:	f891 9006 	ldrb.w	r9, [r1, #6]
 802347a:	f891 8009 	ldrb.w	r8, [r1, #9]
 802347e:	7a0a      	ldrb	r2, [r1, #8]
 8023480:	f891 c00a 	ldrb.w	ip, [r1, #10]
 8023484:	f8b1 e002 	ldrh.w	lr, [r1, #2]
 8023488:	780f      	ldrb	r7, [r1, #0]

  /* Program the class register */
  conv_class &= ~(conv_mode_mask);
 802348a:	f425 65e0 	bic.w	r5, r5, #1792	; 0x700
  conv_class |= (uint32_t)((uint32_t) conv_mode << conv_mode_pos);
 802348e:	f003 0307 	and.w	r3, r3, #7
 8023492:	ea45 2303 	orr.w	r3, r5, r3, lsl #8
  conv_class &= ~(sample_time_mask);
 8023496:	f023 031f 	bic.w	r3, r3, #31
  {
    conv_mode_pos    = (uint32_t) VADC_G_ICLASS_CMS_Pos;
    conv_mode_mask   = (uint32_t) VADC_G_ICLASS_CMS_Msk;
    sample_time_pos  = (uint32_t) VADC_G_ICLASS_STCS_Pos;
    sample_time_mask = (uint32_t) VADC_G_ICLASS_STCS_Msk;
    sample_time      = (uint32_t) config.sample_time_std_conv;
 802349a:	f00a 0a1f 	and.w	sl, sl, #31

  /* Program the class register */
  conv_class &= ~(conv_mode_mask);
  conv_class |= (uint32_t)((uint32_t) conv_mode << conv_mode_pos);
  conv_class &= ~(sample_time_mask);
  conv_class |= (uint32_t)(sample_time <<  sample_time_pos);
 802349e:	ea43 050a 	orr.w	r5, r3, sl
  group_ptr->ICLASS[set_num] = conv_class;
 80234a2:	f8c0 50a0 	str.w	r5, [r0, #160]	; 0xa0
    sample_time      = (uint32_t) config.sampling_phase_emux_channel;
    conv_mode        = (XMC_VADC_CONVMODE_t)config.conversion_mode_emux;
  }

  /* Determine the class */
  conv_class  = group_ptr->ICLASS[set_num];
 80234a6:	f8d0 30a0 	ldr.w	r3, [r0, #160]	; 0xa0

  /* Program the class register */
  conv_class &= ~(conv_mode_mask);
  conv_class |= (uint32_t)((uint32_t) conv_mode << conv_mode_pos);
 80234aa:	f00b 0b07 	and.w	fp, fp, #7

  /* Determine the class */
  conv_class  = group_ptr->ICLASS[set_num];

  /* Program the class register */
  conv_class &= ~(conv_mode_mask);
 80234ae:	f023 63e0 	bic.w	r3, r3, #117440512	; 0x7000000
  conv_class |= (uint32_t)((uint32_t) conv_mode << conv_mode_pos);
 80234b2:	ea43 630b 	orr.w	r3, r3, fp, lsl #24
  conv_class &= ~(sample_time_mask);
 80234b6:	f423 13f8 	bic.w	r3, r3, #2031616	; 0x1f0000
  {
    conv_mode_pos    = (uint32_t) VADC_G_ICLASS_CME_Pos;
    conv_mode_mask   = (uint32_t) VADC_G_ICLASS_CME_Msk;
    sample_time_pos  = (uint32_t) VADC_G_ICLASS_STCE_Pos;
    sample_time_mask = (uint32_t) VADC_G_ICLASS_STCE_Msk;
    sample_time      = (uint32_t) config.sampling_phase_emux_channel;
 80234ba:	f009 051f 	and.w	r5, r9, #31

  /* Program the class register */
  conv_class &= ~(conv_mode_mask);
  conv_class |= (uint32_t)((uint32_t) conv_mode << conv_mode_pos);
  conv_class &= ~(sample_time_mask);
  conv_class |= (uint32_t)(sample_time <<  sample_time_pos);
 80234be:	ea43 4505 	orr.w	r5, r3, r5, lsl #16
  group_ptr->ICLASS[set_num] = conv_class;
 80234c2:	f8c0 50a0 	str.w	r5, [r0, #160]	; 0xa0
    sample_time      = (uint32_t) config.sampling_phase_emux_channel;
    conv_mode        = (XMC_VADC_CONVMODE_t)config.conversion_mode_emux;
  }

  /* Determine the class */
  conv_class  = group_ptr->ICLASS[set_num];
 80234c6:	f8d0 30a4 	ldr.w	r3, [r0, #164]	; 0xa4

  /* Program the class register */
  conv_class &= ~(conv_mode_mask);
  conv_class |= (uint32_t)((uint32_t) conv_mode << conv_mode_pos);
 80234ca:	f008 0807 	and.w	r8, r8, #7

  /* Determine the class */
  conv_class  = group_ptr->ICLASS[set_num];

  /* Program the class register */
  conv_class &= ~(conv_mode_mask);
 80234ce:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
  conv_class |= (uint32_t)((uint32_t) conv_mode << conv_mode_pos);
 80234d2:	ea43 2308 	orr.w	r3, r3, r8, lsl #8
  {
    conv_mode_pos    = (uint32_t) VADC_G_ICLASS_CMS_Pos;
    conv_mode_mask   = (uint32_t) VADC_G_ICLASS_CMS_Msk;
    sample_time_pos  = (uint32_t) VADC_G_ICLASS_STCS_Pos;
    sample_time_mask = (uint32_t) VADC_G_ICLASS_STCS_Msk;
    sample_time      = (uint32_t) config.sample_time_std_conv;
 80234d6:	f002 021f 	and.w	r2, r2, #31
  conv_class  = group_ptr->ICLASS[set_num];

  /* Program the class register */
  conv_class &= ~(conv_mode_mask);
  conv_class |= (uint32_t)((uint32_t) conv_mode << conv_mode_pos);
  conv_class &= ~(sample_time_mask);
 80234da:	f023 031f 	bic.w	r3, r3, #31
  conv_class |= (uint32_t)(sample_time <<  sample_time_pos);
 80234de:	4313      	orrs	r3, r2
  group_ptr->ICLASS[set_num] = conv_class;
 80234e0:	f8c0 30a4 	str.w	r3, [r0, #164]	; 0xa4
    sample_time      = (uint32_t) config.sampling_phase_emux_channel;
    conv_mode        = (XMC_VADC_CONVMODE_t)config.conversion_mode_emux;
  }

  /* Determine the class */
  conv_class  = group_ptr->ICLASS[set_num];
 80234e4:	f8d0 50a4 	ldr.w	r5, [r0, #164]	; 0xa4

  /* Program the class register */
  conv_class &= ~(conv_mode_mask);
  conv_class |= (uint32_t)((uint32_t) conv_mode << conv_mode_pos);
 80234e8:	f004 0207 	and.w	r2, r4, #7

  /* Determine the class */
  conv_class  = group_ptr->ICLASS[set_num];

  /* Program the class register */
  conv_class &= ~(conv_mode_mask);
 80234ec:	f025 64e0 	bic.w	r4, r5, #117440512	; 0x7000000
  conv_class |= (uint32_t)((uint32_t) conv_mode << conv_mode_pos);
 80234f0:	ea44 6402 	orr.w	r4, r4, r2, lsl #24
  conv_class &= ~(sample_time_mask);
 80234f4:	f424 14f8 	bic.w	r4, r4, #2031616	; 0x1f0000
  {
    conv_mode_pos    = (uint32_t) VADC_G_ICLASS_CME_Pos;
    conv_mode_mask   = (uint32_t) VADC_G_ICLASS_CME_Msk;
    sample_time_pos  = (uint32_t) VADC_G_ICLASS_STCE_Pos;
    sample_time_mask = (uint32_t) VADC_G_ICLASS_STCE_Msk;
    sample_time      = (uint32_t) config.sampling_phase_emux_channel;
 80234f8:	f00c 021f 	and.w	r2, ip, #31

  /* Program the class register */
  conv_class &= ~(conv_mode_mask);
  conv_class |= (uint32_t)((uint32_t) conv_mode << conv_mode_pos);
  conv_class &= ~(sample_time_mask);
  conv_class |= (uint32_t)(sample_time <<  sample_time_pos);
 80234fc:	ea44 4202 	orr.w	r2, r4, r2, lsl #16
  group_ptr->ICLASS[set_num] = conv_class;
 8023500:	f8c0 20a4 	str.w	r2, [r0, #164]	; 0xa4
  XMC_VADC_GROUP_InputClassInit(group_ptr, config->class0, XMC_VADC_GROUP_CONV_STD, 0U);
  XMC_VADC_GROUP_InputClassInit(group_ptr, config->class0, XMC_VADC_GROUP_CONV_EMUX, 0U);
  XMC_VADC_GROUP_InputClassInit(group_ptr, config->class1, XMC_VADC_GROUP_CONV_STD, 1U);
  XMC_VADC_GROUP_InputClassInit(group_ptr, config->class1, XMC_VADC_GROUP_CONV_EMUX, 1U);

  group_ptr->ARBCFG = config->g_arbcfg;
 8023504:	690b      	ldr	r3, [r1, #16]
 8023506:	f8c0 3080 	str.w	r3, [r0, #128]	; 0x80
  uint32_t   emux_config;

  XMC_ASSERT("XMC_VADC_GROUP_ExternalMuxControlInit:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))

  emux_config = ((uint32_t)emux_cfg.starting_external_channel << (uint32_t)VADC_G_EMUXCTR_EMUXSET_Pos) |
              ((uint32_t)emux_cfg.connected_channel << (uint32_t)VADC_G_EMUXCTR_EMUXCH_Pos);
 802350a:	f3ce 0e09 	ubfx	lr, lr, #0, #10
{
  uint32_t   emux_config;

  XMC_ASSERT("XMC_VADC_GROUP_ExternalMuxControlInit:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))

  emux_config = ((uint32_t)emux_cfg.starting_external_channel << (uint32_t)VADC_G_EMUXCTR_EMUXSET_Pos) |
 802350e:	f007 0707 	and.w	r7, r7, #7

  group_ptr->BOUND = config->g_bound;
 8023512:	68cb      	ldr	r3, [r1, #12]
 8023514:	f8c0 30b8 	str.w	r3, [r0, #184]	; 0xb8
 8023518:	ea47 470e 	orr.w	r7, r7, lr, lsl #16
              ((uint32_t)emux_cfg.connected_channel << (uint32_t)VADC_G_EMUXCTR_EMUXCH_Pos);

  group_ptr->EMUXCTR  = emux_config;
 802351c:	f8c0 71f0 	str.w	r7, [r0, #496]	; 0x1f0
                ((uint32_t)emux_cfg.stce_usage << (uint32_t)VADC_G_EMUXCTR_EMXST_Pos);

#if (XMC_VADC_EMUX_CH_SEL_STYLE == 1U)
  emux_config |= ((uint32_t)emux_cfg.emux_channel_select_style << (uint32_t)VADC_G_EMUXCTR_EMXCSS_Pos);
#endif
  group_ptr->EMUXCTR  |= (emux_config | ((uint32_t)VADC_G_EMUXCTR_EMXWC_Msk)) ;
 8023520:	f8d0 21f0 	ldr.w	r2, [r0, #496]	; 0x1f0
 8023524:	f3c6 1300 	ubfx	r3, r6, #4, #1
 8023528:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
 802352c:	ea42 7203 	orr.w	r2, r2, r3, lsl #28
 8023530:	f3c6 0381 	ubfx	r3, r6, #2, #2
 8023534:	ea42 6283 	orr.w	r2, r2, r3, lsl #26
 8023538:	f3c6 1340 	ubfx	r3, r6, #5, #1
 802353c:	ea42 7243 	orr.w	r2, r2, r3, lsl #29
 8023540:	f3c6 1380 	ubfx	r3, r6, #6, #1
 8023544:	ea42 7383 	orr.w	r3, r2, r3, lsl #30
 8023548:	f8c0 31f0 	str.w	r3, [r0, #496]	; 0x1f0
 802354c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08023550 <XMC_VADC_GROUP_InputClassInit>:
}

/* API to program conversion characteristics */
void XMC_VADC_GROUP_InputClassInit(XMC_VADC_GROUP_t *const group_ptr, const XMC_VADC_GROUP_CLASS_t config,
                                          const XMC_VADC_GROUP_CONV_t conv_type, const uint32_t set_num)
{
 8023550:	b4f0      	push	{r4, r5, r6, r7}

  /* 
   * Obtain the mask and position macros of the parameters based on what is being requested - Standard channels vs
   * external mux channels.
   */
  if (XMC_VADC_GROUP_CONV_STD == conv_type)
 8023552:	b1ba      	cbz	r2, 8023584 <XMC_VADC_GROUP_InputClassInit+0x34>
  {
    conv_mode_pos    = (uint32_t) VADC_G_ICLASS_CME_Pos;
    conv_mode_mask   = (uint32_t) VADC_G_ICLASS_CME_Msk;
    sample_time_pos  = (uint32_t) VADC_G_ICLASS_STCE_Pos;
    sample_time_mask = (uint32_t) VADC_G_ICLASS_STCE_Msk;
    sample_time      = (uint32_t) config.sampling_phase_emux_channel;
 8023554:	f3c1 4204 	ubfx	r2, r1, #16, #5
    conv_mode        = (XMC_VADC_CONVMODE_t)config.conversion_mode_emux;
 8023558:	2510      	movs	r5, #16
 802355a:	f3c1 6102 	ubfx	r1, r1, #24, #3
 802355e:	f46f 16f8 	mvn.w	r6, #2031616	; 0x1f0000
 8023562:	2418      	movs	r4, #24
 8023564:	f06f 67e0 	mvn.w	r7, #117440512	; 0x7000000
 8023568:	eb00 0383 	add.w	r3, r0, r3, lsl #2
  /* Determine the class */
  conv_class  = group_ptr->ICLASS[set_num];

  /* Program the class register */
  conv_class &= ~(conv_mode_mask);
  conv_class |= (uint32_t)((uint32_t) conv_mode << conv_mode_pos);
 802356c:	40a1      	lsls	r1, r4
    sample_time      = (uint32_t) config.sampling_phase_emux_channel;
    conv_mode        = (XMC_VADC_CONVMODE_t)config.conversion_mode_emux;
  }

  /* Determine the class */
  conv_class  = group_ptr->ICLASS[set_num];
 802356e:	f8d3 40a0 	ldr.w	r4, [r3, #160]	; 0xa0

  /* Program the class register */
  conv_class &= ~(conv_mode_mask);
 8023572:	403c      	ands	r4, r7
  conv_class |= (uint32_t)((uint32_t) conv_mode << conv_mode_pos);
 8023574:	4321      	orrs	r1, r4
  conv_class &= ~(sample_time_mask);
  conv_class |= (uint32_t)(sample_time <<  sample_time_pos);
 8023576:	40aa      	lsls	r2, r5
  conv_class  = group_ptr->ICLASS[set_num];

  /* Program the class register */
  conv_class &= ~(conv_mode_mask);
  conv_class |= (uint32_t)((uint32_t) conv_mode << conv_mode_pos);
  conv_class &= ~(sample_time_mask);
 8023578:	4031      	ands	r1, r6
  conv_class |= (uint32_t)(sample_time <<  sample_time_pos);
 802357a:	4311      	orrs	r1, r2
  group_ptr->ICLASS[set_num] = conv_class;
 802357c:	f8c3 10a0 	str.w	r1, [r3, #160]	; 0xa0
}
 8023580:	bcf0      	pop	{r4, r5, r6, r7}
 8023582:	4770      	bx	lr
 8023584:	4615      	mov	r5, r2
 8023586:	f06f 061f 	mvn.w	r6, #31
  {
    conv_mode_pos    = (uint32_t) VADC_G_ICLASS_CMS_Pos;
    conv_mode_mask   = (uint32_t) VADC_G_ICLASS_CMS_Msk;
    sample_time_pos  = (uint32_t) VADC_G_ICLASS_STCS_Pos;
    sample_time_mask = (uint32_t) VADC_G_ICLASS_STCS_Msk;
    sample_time      = (uint32_t) config.sample_time_std_conv;
 802358a:	f001 021f 	and.w	r2, r1, #31
 802358e:	2408      	movs	r4, #8
    conv_mode        = (XMC_VADC_CONVMODE_t)config.conversion_mode_standard;
 8023590:	f3c1 2102 	ubfx	r1, r1, #8, #3
 8023594:	f46f 67e0 	mvn.w	r7, #1792	; 0x700
 8023598:	e7e6      	b.n	8023568 <XMC_VADC_GROUP_InputClassInit+0x18>
 802359a:	bf00      	nop

0802359c <XMC_VADC_GROUP_SetPowerMode>:
  uint32_t arbcfg;

  XMC_ASSERT("XMC_VADC_GROUP_SetPowerMode:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  XMC_ASSERT("XMC_VADC_GROUP_SetPowerMode:Wrong Power Mode", (power_mode <= XMC_VADC_GROUP_POWERMODE_NORMAL))

  arbcfg = group_ptr->ARBCFG;
 802359c:	f8d0 3080 	ldr.w	r3, [r0, #128]	; 0x80

  arbcfg &= ~((uint32_t)VADC_G_ARBCFG_ANONC_Msk);
 80235a0:	f023 0303 	bic.w	r3, r3, #3
  arbcfg |= (uint32_t)power_mode;
 80235a4:	4319      	orrs	r1, r3

  group_ptr->ARBCFG = arbcfg;
 80235a6:	f8c0 1080 	str.w	r1, [r0, #128]	; 0x80
 80235aa:	4770      	bx	lr

080235ac <XMC_VADC_GROUP_SetSyncSlave>:
    master_grp = master_grp + 1U;
  }
  #endif
  
  /* Program SYNCTR */
  synctr = group_ptr->SYNCTR;
 80235ac:	f8d0 30c0 	ldr.w	r3, [r0, #192]	; 0xc0
  XMC_ASSERT("XMC_VADC_GROUP_SetSyncSlave:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  
  #if (XMC_VADC_MULTIPLE_SLAVEGROUPS == 1U )

  /* Determine the coding of SYNCTR */
  if (slave_grp > master_grp)
 80235b0:	428a      	cmp	r2, r1
  {
    master_grp = master_grp + 1U;
 80235b2:	bf88      	it	hi
 80235b4:	3101      	addhi	r1, #1
  }
  #endif
  
  /* Program SYNCTR */
  synctr = group_ptr->SYNCTR;
  synctr   &= ~((uint32_t)VADC_G_SYNCTR_STSEL_Msk);
 80235b6:	f023 0303 	bic.w	r3, r3, #3
  synctr   |= master_grp;
 80235ba:	4319      	orrs	r1, r3
  group_ptr->SYNCTR = synctr;
 80235bc:	f8c0 10c0 	str.w	r1, [r0, #192]	; 0xc0
 80235c0:	4770      	bx	lr
 80235c2:	bf00      	nop

080235c4 <XMC_VADC_GROUP_SetSyncMaster>:
{
  uint32_t synctr;

  XMC_ASSERT("XMC_VADC_GROUP_SetSyncMaster:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))

  synctr = group_ptr->SYNCTR;
 80235c4:	f8d0 30c0 	ldr.w	r3, [r0, #192]	; 0xc0
  synctr   &= ~((uint32_t)VADC_G_SYNCTR_STSEL_Msk);
 80235c8:	f023 0303 	bic.w	r3, r3, #3
  group_ptr->SYNCTR = synctr;
 80235cc:	f8c0 30c0 	str.w	r3, [r0, #192]	; 0xc0
 80235d0:	4770      	bx	lr
 80235d2:	bf00      	nop

080235d4 <XMC_VADC_GROUP_CheckSlaveReadiness>:
  XMC_ASSERT("XMC_VADC_GROUP_CheckSlaveReadiness:Wrong Slave group", ((slave_group >= 0) && (slave_group <= (XMC_VADC_MAXIMUM_NUM_GROUPS - 1))))

  master_grp_num =0;
  for(i=0; i<XMC_VADC_MAXIMUM_NUM_GROUPS; i++)
  {
    if(g_xmc_vadc_group_array[i] == group_ptr)
 80235d4:	4b0e      	ldr	r3, [pc, #56]	; (8023610 <XMC_VADC_GROUP_CheckSlaveReadiness+0x3c>)
 80235d6:	4298      	cmp	r0, r3
 80235d8:	d010      	beq.n	80235fc <XMC_VADC_GROUP_CheckSlaveReadiness+0x28>
 80235da:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80235de:	4298      	cmp	r0, r3
 80235e0:	d011      	beq.n	8023606 <XMC_VADC_GROUP_CheckSlaveReadiness+0x32>
 80235e2:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80235e6:	4298      	cmp	r0, r3
 80235e8:	d00f      	beq.n	802360a <XMC_VADC_GROUP_CheckSlaveReadiness+0x36>

  if(slave_group < master_grp_num)
  {
    slave_group++;
  }
  group_ptr->SYNCTR |= (1U << (slave_group + XMC_VADC_SYNCTR_START_LOCATION));
 80235ea:	f8d0 20c0 	ldr.w	r2, [r0, #192]	; 0xc0
 80235ee:	3103      	adds	r1, #3
 80235f0:	2301      	movs	r3, #1
 80235f2:	408b      	lsls	r3, r1
 80235f4:	4313      	orrs	r3, r2
 80235f6:	f8c0 30c0 	str.w	r3, [r0, #192]	; 0xc0
 80235fa:	4770      	bx	lr
  uint32_t i,master_grp_num;
  XMC_ASSERT("XMC_VADC_GROUP_CheckSlaveReadiness:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  XMC_ASSERT("XMC_VADC_GROUP_CheckSlaveReadiness:Wrong Slave group", ((slave_group >= 0) && (slave_group <= (XMC_VADC_MAXIMUM_NUM_GROUPS - 1))))

  master_grp_num =0;
  for(i=0; i<XMC_VADC_MAXIMUM_NUM_GROUPS; i++)
 80235fc:	2301      	movs	r3, #1
      master_grp_num = i;
    }
  }


  if(slave_group < master_grp_num)
 80235fe:	4299      	cmp	r1, r3
  {
    slave_group++;
 8023600:	bf38      	it	cc
 8023602:	3101      	addcc	r1, #1
 8023604:	e7f1      	b.n	80235ea <XMC_VADC_GROUP_CheckSlaveReadiness+0x16>
  uint32_t i,master_grp_num;
  XMC_ASSERT("XMC_VADC_GROUP_CheckSlaveReadiness:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  XMC_ASSERT("XMC_VADC_GROUP_CheckSlaveReadiness:Wrong Slave group", ((slave_group >= 0) && (slave_group <= (XMC_VADC_MAXIMUM_NUM_GROUPS - 1))))

  master_grp_num =0;
  for(i=0; i<XMC_VADC_MAXIMUM_NUM_GROUPS; i++)
 8023606:	2302      	movs	r3, #2
 8023608:	e7f9      	b.n	80235fe <XMC_VADC_GROUP_CheckSlaveReadiness+0x2a>
 802360a:	2303      	movs	r3, #3
 802360c:	e7f7      	b.n	80235fe <XMC_VADC_GROUP_CheckSlaveReadiness+0x2a>
 802360e:	bf00      	nop
 8023610:	40004800 	.word	0x40004800

08023614 <XMC_VADC_GROUP_SetSyncSlaveReadySignal>:
                                            uint32_t eval_origin_group)
{
  XMC_ASSERT("XMC_VADC_GROUP_SetSyncSlaveReadySignal:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  XMC_ASSERT("XMC_VADC_GROUP_SetSyncSlaveReadySignal:Wrong Group numbers", (eval_waiting_group == eval_origin_group ))

  if(eval_origin_group < eval_waiting_group)
 8023614:	428a      	cmp	r2, r1
  {
	  eval_origin_group++;
 8023616:	bf38      	it	cc
 8023618:	3201      	addcc	r2, #1
  }
  group_ptr->SYNCTR |= (1U << (eval_origin_group + XMC_VADC_SYNCTR_START_LOCATION));
 802361a:	f8d0 10c0 	ldr.w	r1, [r0, #192]	; 0xc0
 802361e:	3203      	adds	r2, #3
 8023620:	2301      	movs	r3, #1
 8023622:	4093      	lsls	r3, r2
 8023624:	430b      	orrs	r3, r1
 8023626:	f8c0 30c0 	str.w	r3, [r0, #192]	; 0xc0
 802362a:	4770      	bx	lr

0802362c <XMC_VADC_GROUP_ScanInit>:
 *  XMC_VADC_GROUP_ScanEnableArbitrationSlot()<BR>
 */
__STATIC_INLINE void XMC_VADC_GROUP_ScanDisableArbitrationSlot(XMC_VADC_GROUP_t *const group_ptr)
{
  XMC_ASSERT("XMC_VADC_GROUP_ScanDisableArbitrationSlot:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  group_ptr->ARBPR &= ~((uint32_t)VADC_G_ARBPR_ASEN1_Msk);
 802362c:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
  /* Read in the existing contents of arbitration priority register */
  reg = group_ptr->ARBPR;

  /* Program the priority of the request source */
  reg &= ~(uint32_t)VADC_G_ARBPR_PRIO1_Msk;
  reg |= (uint32_t)((uint32_t)config->req_src_priority << VADC_G_ARBPR_PRIO1_Pos);
 8023630:	780a      	ldrb	r2, [r1, #0]
 8023632:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
 8023636:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84

  /* All configurations have to be performed with the arbitration slot disabled */
  XMC_VADC_GROUP_ScanDisableArbitrationSlot(group_ptr);
  
  /* Read in the existing contents of arbitration priority register */
  reg = group_ptr->ARBPR;
 802363a:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
#endif

#if (XMC_VADC_GSCAN_AVAILABLE == 1U)   
/* API to initialize the group scan hardware of a kernel */
void XMC_VADC_GROUP_ScanInit(XMC_VADC_GROUP_t *const group_ptr, const XMC_VADC_SCAN_CONFIG_t *config)
{
 802363e:	b410      	push	{r4}
  
  /* Read in the existing contents of arbitration priority register */
  reg = group_ptr->ARBPR;

  /* Program the priority of the request source */
  reg &= ~(uint32_t)VADC_G_ARBPR_PRIO1_Msk;
 8023640:	f023 0330 	bic.w	r3, r3, #48	; 0x30
  reg |= (uint32_t)((uint32_t)config->req_src_priority << VADC_G_ARBPR_PRIO1_Pos);
 8023644:	f3c2 0481 	ubfx	r4, r2, #2, #2
  
  /* Program the start mode */
  if (XMC_VADC_STARTMODE_WFS != (XMC_VADC_STARTMODE_t)(config->conv_start_mode))
 8023648:	f012 0203 	ands.w	r2, r2, #3
  /* Read in the existing contents of arbitration priority register */
  reg = group_ptr->ARBPR;

  /* Program the priority of the request source */
  reg &= ~(uint32_t)VADC_G_ARBPR_PRIO1_Msk;
  reg |= (uint32_t)((uint32_t)config->req_src_priority << VADC_G_ARBPR_PRIO1_Pos);
 802364c:	ea43 1304 	orr.w	r3, r3, r4, lsl #4
  
  /* Program the start mode */
  if (XMC_VADC_STARTMODE_WFS != (XMC_VADC_STARTMODE_t)(config->conv_start_mode))
 8023650:	d020      	beq.n	8023694 <XMC_VADC_GROUP_ScanInit+0x68>
  {
    reg |= (uint32_t)(VADC_G_ARBPR_CSM1_Msk);
 8023652:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  }

  group_ptr->ARBPR = reg;
 8023656:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84

  group_ptr->ASCTRL = (uint32_t)(config->asctrl |(VADC_G_ASCTRL_XTWC_Msk) |(VADC_G_ASCTRL_GTWC_Msk) |
 802365a:	684b      	ldr	r3, [r1, #4]
 802365c:	f043 2380 	orr.w	r3, r3, #2147516416	; 0x80008000
 8023660:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 8023664:	f8c0 3120 	str.w	r3, [r0, #288]	; 0x120
                                                 (VADC_G_ASCTRL_TMWC_Msk));

  group_ptr->ASMR  = (uint32_t)((config->asmr)| (uint32_t)((uint32_t)XMC_VADC_GATEMODE_IGNORE << VADC_G_ASMR_ENGT_Pos));
 8023668:	688b      	ldr	r3, [r1, #8]
  
  if (XMC_VADC_STARTMODE_CNR == (XMC_VADC_STARTMODE_t)(config->conv_start_mode))
 802366a:	2a02      	cmp	r2, #2
  group_ptr->ARBPR = reg;

  group_ptr->ASCTRL = (uint32_t)(config->asctrl |(VADC_G_ASCTRL_XTWC_Msk) |(VADC_G_ASCTRL_GTWC_Msk) |
                                                 (VADC_G_ASCTRL_TMWC_Msk));

  group_ptr->ASMR  = (uint32_t)((config->asmr)| (uint32_t)((uint32_t)XMC_VADC_GATEMODE_IGNORE << VADC_G_ASMR_ENGT_Pos));
 802366c:	f043 0301 	orr.w	r3, r3, #1
 8023670:	f8c0 3124 	str.w	r3, [r0, #292]	; 0x124
  
  if (XMC_VADC_STARTMODE_CNR == (XMC_VADC_STARTMODE_t)(config->conv_start_mode))
 8023674:	d105      	bne.n	8023682 <XMC_VADC_GROUP_ScanInit+0x56>
  {
    group_ptr->ASMR |= (uint32_t)VADC_G_ASMR_RPTDIS_Msk;
 8023676:	f8d0 3124 	ldr.w	r3, [r0, #292]	; 0x124
 802367a:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 802367e:	f8c0 3124 	str.w	r3, [r0, #292]	; 0x124
 *  XMC_VADC_GROUP_ScanDisableArbitrationSlot()<BR>
 */
__STATIC_INLINE void XMC_VADC_GROUP_ScanEnableArbitrationSlot(XMC_VADC_GROUP_t *const group_ptr)
{
  XMC_ASSERT("XMC_VADC_GROUP_ScanEnableArbitrationSlot:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  group_ptr->ARBPR |= (uint32_t)VADC_G_ARBPR_ASEN1_Msk;
 8023682:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
  }
  
  /* Enable arbitration slot now */
  XMC_VADC_GROUP_ScanEnableArbitrationSlot(group_ptr);
  
}
 8023686:	f85d 4b04 	ldr.w	r4, [sp], #4
 802368a:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 802368e:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
 8023692:	4770      	bx	lr
  if (XMC_VADC_STARTMODE_WFS != (XMC_VADC_STARTMODE_t)(config->conv_start_mode))
  {
    reg |= (uint32_t)(VADC_G_ARBPR_CSM1_Msk);
  }

  group_ptr->ARBPR = reg;
 8023694:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84

  group_ptr->ASCTRL = (uint32_t)(config->asctrl |(VADC_G_ASCTRL_XTWC_Msk) |(VADC_G_ASCTRL_GTWC_Msk) |
 8023698:	684b      	ldr	r3, [r1, #4]
 802369a:	f043 2380 	orr.w	r3, r3, #2147516416	; 0x80008000
 802369e:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 80236a2:	f8c0 3120 	str.w	r3, [r0, #288]	; 0x120
                                                 (VADC_G_ASCTRL_TMWC_Msk));

  group_ptr->ASMR  = (uint32_t)((config->asmr)| (uint32_t)((uint32_t)XMC_VADC_GATEMODE_IGNORE << VADC_G_ASMR_ENGT_Pos));
 80236a6:	688b      	ldr	r3, [r1, #8]
 80236a8:	f043 0301 	orr.w	r3, r3, #1
 80236ac:	f8c0 3124 	str.w	r3, [r0, #292]	; 0x124
 80236b0:	e7e7      	b.n	8023682 <XMC_VADC_GROUP_ScanInit+0x56>
 80236b2:	bf00      	nop

080236b4 <XMC_VADC_GROUP_ScanSetReqSrcEventInterruptNode>:

/* API to select a service request line (NVIC Node) for request source event */
void XMC_VADC_GROUP_ScanSetReqSrcEventInterruptNode(XMC_VADC_GROUP_t *const group_ptr, const XMC_VADC_SR_t sr)
{
  uint32_t sevnp;
  sevnp = group_ptr->SEVNP;
 80236b4:	f8d0 31c0 	ldr.w	r3, [r0, #448]	; 0x1c0

  XMC_ASSERT("XMC_VADC_GROUP_ScanSetReqSrcEventInterruptNode:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  XMC_ASSERT("XMC_VADC_GROUP_ScanSetReqSrcEventInterruptNode:Wrong Service Request", ((sr)  <= XMC_VADC_SR_SHARED_SR3))

  sevnp &= ~((uint32_t)VADC_G_SEVNP_SEV1NP_Msk);
 80236b8:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
  sevnp |= (uint32_t)((uint32_t)sr << VADC_G_SEVNP_SEV1NP_Pos);
 80236bc:	ea43 1101 	orr.w	r1, r3, r1, lsl #4

  group_ptr->SEVNP = sevnp;
 80236c0:	f8c0 11c0 	str.w	r1, [r0, #448]	; 0x1c0
 80236c4:	4770      	bx	lr
 80236c6:	bf00      	nop

080236c8 <XMC_VADC_GROUP_QueueInit>:
 *  XMC_VADC_GROUP_QueueEnableArbitrationSlot()<BR>
 */
__STATIC_INLINE void XMC_VADC_GROUP_QueueDisableArbitrationSlot(XMC_VADC_GROUP_t *const group_ptr)
{
  XMC_ASSERT("XMC_VADC_GROUP_QueueDisableArbitrationSlot:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr));
  group_ptr->ARBPR &= ~((uint32_t)VADC_G_ARBPR_ASEN0_Msk);
 80236c8:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
  
  reg = group_ptr->ARBPR;

  /* Request Source priority */
  reg &= ~((uint32_t)VADC_G_ARBPR_PRIO0_Msk);
  reg |= (uint32_t) ((uint32_t)config->req_src_priority << VADC_G_ARBPR_PRIO0_Pos);
 80236cc:	780a      	ldrb	r2, [r1, #0]
 80236ce:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 80236d2:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
  XMC_ASSERT("XMC_VADC_GROUP_QueueInit:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))

  /* Disable arbitration slot of the queue request source */
  XMC_VADC_GROUP_QueueDisableArbitrationSlot(group_ptr);
  
  reg = group_ptr->ARBPR;
 80236d6:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
}

#if (XMC_VADC_QUEUE_AVAILABLE == 1U)  
/* API to initialize queue request source */
void XMC_VADC_GROUP_QueueInit(XMC_VADC_GROUP_t *const group_ptr, const XMC_VADC_QUEUE_CONFIG_t *config)
{
 80236da:	b410      	push	{r4}
  XMC_VADC_GROUP_QueueDisableArbitrationSlot(group_ptr);
  
  reg = group_ptr->ARBPR;

  /* Request Source priority */
  reg &= ~((uint32_t)VADC_G_ARBPR_PRIO0_Msk);
 80236dc:	f023 0303 	bic.w	r3, r3, #3
  reg |= (uint32_t) ((uint32_t)config->req_src_priority << VADC_G_ARBPR_PRIO0_Pos);
 80236e0:	f3c2 0481 	ubfx	r4, r2, #2, #2

  /* Conversion Start mode */
  if (XMC_VADC_STARTMODE_WFS != (XMC_VADC_STARTMODE_t)config->conv_start_mode)
 80236e4:	f012 0203 	ands.w	r2, r2, #3
  
  reg = group_ptr->ARBPR;

  /* Request Source priority */
  reg &= ~((uint32_t)VADC_G_ARBPR_PRIO0_Msk);
  reg |= (uint32_t) ((uint32_t)config->req_src_priority << VADC_G_ARBPR_PRIO0_Pos);
 80236e8:	ea43 0304 	orr.w	r3, r3, r4

  /* Conversion Start mode */
  if (XMC_VADC_STARTMODE_WFS != (XMC_VADC_STARTMODE_t)config->conv_start_mode)
 80236ec:	d020      	beq.n	8023730 <XMC_VADC_GROUP_QueueInit+0x68>
  {
    reg |= (uint32_t)(VADC_G_ARBPR_CSM0_Msk);
 80236ee:	f043 0308 	orr.w	r3, r3, #8
  }

  group_ptr->ARBPR = reg;
 80236f2:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84


  group_ptr->QCTRL0 = (uint32_t)((config->qctrl0)|(uint32_t)(VADC_G_QCTRL0_XTWC_Msk)|
 80236f6:	684b      	ldr	r3, [r1, #4]
 80236f8:	f043 2380 	orr.w	r3, r3, #2147516416	; 0x80008000
 80236fc:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 8023700:	f8c0 3100 	str.w	r3, [r0, #256]	; 0x100
                                                    (uint32_t)(VADC_G_QCTRL0_TMWC_Msk)|
                                                    (uint32_t)(VADC_G_QCTRL0_GTWC_Msk));

  /* Gating mode */
  group_ptr->QMR0 = ((uint32_t)(config->qmr0) | (uint32_t)((uint32_t)XMC_VADC_GATEMODE_IGNORE << VADC_G_QMR0_ENGT_Pos));
 8023704:	688b      	ldr	r3, [r1, #8]

  if (XMC_VADC_STARTMODE_CNR == (XMC_VADC_STARTMODE_t)(config->conv_start_mode) )
 8023706:	2a02      	cmp	r2, #2
  group_ptr->QCTRL0 = (uint32_t)((config->qctrl0)|(uint32_t)(VADC_G_QCTRL0_XTWC_Msk)|
                                                    (uint32_t)(VADC_G_QCTRL0_TMWC_Msk)|
                                                    (uint32_t)(VADC_G_QCTRL0_GTWC_Msk));

  /* Gating mode */
  group_ptr->QMR0 = ((uint32_t)(config->qmr0) | (uint32_t)((uint32_t)XMC_VADC_GATEMODE_IGNORE << VADC_G_QMR0_ENGT_Pos));
 8023708:	f043 0301 	orr.w	r3, r3, #1
 802370c:	f8c0 3104 	str.w	r3, [r0, #260]	; 0x104

  if (XMC_VADC_STARTMODE_CNR == (XMC_VADC_STARTMODE_t)(config->conv_start_mode) )
 8023710:	d105      	bne.n	802371e <XMC_VADC_GROUP_QueueInit+0x56>
  {
    group_ptr->QMR0 |= (uint32_t)((uint32_t)1 << VADC_G_QMR0_RPTDIS_Pos);
 8023712:	f8d0 3104 	ldr.w	r3, [r0, #260]	; 0x104
 8023716:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 802371a:	f8c0 3104 	str.w	r3, [r0, #260]	; 0x104
 *  XMC_VADC_GROUP_QueueDisableArbitrationSlot()<BR>
 */
__STATIC_INLINE void XMC_VADC_GROUP_QueueEnableArbitrationSlot(XMC_VADC_GROUP_t *const group_ptr)
{
  XMC_ASSERT("XMC_VADC_GROUP_QueueEnableArbitrationSlot:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr));
  group_ptr->ARBPR |= (uint32_t)((uint32_t)1 << VADC_G_ARBPR_ASEN0_Pos);
 802371e:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
  }
  /* Enable arbitration slot for the queue request source */
  XMC_VADC_GROUP_QueueEnableArbitrationSlot(group_ptr);

}
 8023722:	f85d 4b04 	ldr.w	r4, [sp], #4
 8023726:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 802372a:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
 802372e:	4770      	bx	lr
  if (XMC_VADC_STARTMODE_WFS != (XMC_VADC_STARTMODE_t)config->conv_start_mode)
  {
    reg |= (uint32_t)(VADC_G_ARBPR_CSM0_Msk);
  }

  group_ptr->ARBPR = reg;
 8023730:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84


  group_ptr->QCTRL0 = (uint32_t)((config->qctrl0)|(uint32_t)(VADC_G_QCTRL0_XTWC_Msk)|
 8023734:	684b      	ldr	r3, [r1, #4]
 8023736:	f043 2380 	orr.w	r3, r3, #2147516416	; 0x80008000
 802373a:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 802373e:	f8c0 3100 	str.w	r3, [r0, #256]	; 0x100
                                                    (uint32_t)(VADC_G_QCTRL0_TMWC_Msk)|
                                                    (uint32_t)(VADC_G_QCTRL0_GTWC_Msk));

  /* Gating mode */
  group_ptr->QMR0 = ((uint32_t)(config->qmr0) | (uint32_t)((uint32_t)XMC_VADC_GATEMODE_IGNORE << VADC_G_QMR0_ENGT_Pos));
 8023742:	688b      	ldr	r3, [r1, #8]
 8023744:	f043 0301 	orr.w	r3, r3, #1
 8023748:	f8c0 3104 	str.w	r3, [r0, #260]	; 0x104
 802374c:	e7e7      	b.n	802371e <XMC_VADC_GROUP_QueueInit+0x56>
 802374e:	bf00      	nop

08023750 <XMC_VADC_GROUP_QueueSetReqSrcEventInterruptNode>:
  uint32_t sevnp;

  XMC_ASSERT("XMC_VADC_GROUP_QueueSetReqSrcEventInterruptNode:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  XMC_ASSERT("XMC_VADC_GROUP_QueueSetReqSrcEventInterruptNode:Wrong Service Request", ((sr)  <= XMC_VADC_SR_SHARED_SR3))

  sevnp = group_ptr->SEVNP;
 8023750:	f8d0 31c0 	ldr.w	r3, [r0, #448]	; 0x1c0

  sevnp &= ~((uint32_t)VADC_G_SEVNP_SEV0NP_Msk);
 8023754:	f023 030f 	bic.w	r3, r3, #15
  sevnp |= (uint32_t)((uint32_t)sr << VADC_G_SEVNP_SEV0NP_Pos);
 8023758:	4319      	orrs	r1, r3

  group_ptr->SEVNP = sevnp;
 802375a:	f8c0 11c0 	str.w	r1, [r0, #448]	; 0x1c0
 802375e:	4770      	bx	lr

08023760 <XMC_VADC_GROUP_ChannelInit>:

#if (XMC_VADC_GROUP_AVAILABLE ==1U)
/* API to initialize a channel unit */
void XMC_VADC_GROUP_ChannelInit(XMC_VADC_GROUP_t *const group_ptr, const uint32_t ch_num,
                                        const XMC_VADC_CHANNEL_CONFIG_t *config)
{
 8023760:	b430      	push	{r4, r5}


  XMC_ASSERT("XMC_VADC_GROUP_ChannelInit:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  XMC_ASSERT("XMC_VADC_GROUP_ChannelInit:Wrong Channel Number", ((ch_num) < XMC_VADC_NUM_CHANNELS_PER_GROUP))
  
  prio  = (uint32_t)config->channel_priority;
 8023762:	7b13      	ldrb	r3, [r2, #12]

  /* Priority channel */
  ch_assign  = group_ptr->CHASS;
 8023764:	f8d0 5088 	ldr.w	r5, [r0, #136]	; 0x88
  ch_assign &= ~((uint32_t)((uint32_t)1 << ch_num));
 8023768:	2401      	movs	r4, #1
 802376a:	408c      	lsls	r4, r1
 802376c:	ea25 0404 	bic.w	r4, r5, r4
  ch_assign |= (uint32_t)(prio << ch_num);
 8023770:	408b      	lsls	r3, r1
 8023772:	4323      	orrs	r3, r4
  group_ptr->CHASS = ch_assign;
 8023774:	f8c0 3088 	str.w	r3, [r0, #136]	; 0x88

  /* Alias channel */
  if (config->alias_channel >= (int32_t)0)
 8023778:	7b53      	ldrb	r3, [r2, #13]
 802377a:	061c      	lsls	r4, r3, #24
 802377c:	d40a      	bmi.n	8023794 <XMC_VADC_GROUP_ChannelInit+0x34>
  {
    mask = (uint32_t)0;
    if ((uint32_t)1 == ch_num)
 802377e:	2901      	cmp	r1, #1
 8023780:	d023      	beq.n	80237ca <XMC_VADC_GROUP_ChannelInit+0x6a>
    {
      mask = VADC_G_ALIAS_ALIAS1_Pos;
      group_ptr->ALIAS &= ~(uint32_t)(VADC_G_ALIAS_ALIAS1_Msk);
    }
    else if ((uint32_t)0 == ch_num)
 8023782:	b1c9      	cbz	r1, 80237b8 <XMC_VADC_GROUP_ChannelInit+0x58>
 8023784:	2500      	movs	r5, #0
    {
      mask = VADC_G_ALIAS_ALIAS0_Pos;
      group_ptr->ALIAS &= ~(uint32_t)(VADC_G_ALIAS_ALIAS0_Msk);
    }

    group_ptr->ALIAS |= (uint32_t)(config->alias_channel << mask);
 8023786:	f8d0 40b0 	ldr.w	r4, [r0, #176]	; 0xb0
 802378a:	b25b      	sxtb	r3, r3
 802378c:	40ab      	lsls	r3, r5
 802378e:	4323      	orrs	r3, r4
 8023790:	f8c0 30b0 	str.w	r3, [r0, #176]	; 0xb0
  }

  group_ptr->BFL |= config->bfl;
 8023794:	f8d0 40c8 	ldr.w	r4, [r0, #200]	; 0xc8
 8023798:	6853      	ldr	r3, [r2, #4]
 802379a:	4323      	orrs	r3, r4
 802379c:	f8c0 30c8 	str.w	r3, [r0, #200]	; 0xc8

#if (XMC_VADC_BOUNDARY_FLAG_SELECT == 1U)
  group_ptr->BFLC |= config->bflc;
 80237a0:	f8d0 40d0 	ldr.w	r4, [r0, #208]	; 0xd0
 80237a4:	6893      	ldr	r3, [r2, #8]
 80237a6:	4323      	orrs	r3, r4
 80237a8:	f8c0 30d0 	str.w	r3, [r0, #208]	; 0xd0
#endif
  /* Program the CHCTR register */
  group_ptr->CHCTR[ch_num] = config->chctr;
 80237ac:	3180      	adds	r1, #128	; 0x80
 80237ae:	6813      	ldr	r3, [r2, #0]
 80237b0:	f840 3021 	str.w	r3, [r0, r1, lsl #2]

}
 80237b4:	bc30      	pop	{r4, r5}
 80237b6:	4770      	bx	lr
      group_ptr->ALIAS &= ~(uint32_t)(VADC_G_ALIAS_ALIAS1_Msk);
    }
    else if ((uint32_t)0 == ch_num)
    {
      mask = VADC_G_ALIAS_ALIAS0_Pos;
      group_ptr->ALIAS &= ~(uint32_t)(VADC_G_ALIAS_ALIAS0_Msk);
 80237b8:	f8d0 30b0 	ldr.w	r3, [r0, #176]	; 0xb0
 80237bc:	f023 031f 	bic.w	r3, r3, #31
 80237c0:	f8c0 30b0 	str.w	r3, [r0, #176]	; 0xb0
 80237c4:	7b53      	ldrb	r3, [r2, #13]
 80237c6:	460d      	mov	r5, r1
 80237c8:	e7dd      	b.n	8023786 <XMC_VADC_GROUP_ChannelInit+0x26>
  {
    mask = (uint32_t)0;
    if ((uint32_t)1 == ch_num)
    {
      mask = VADC_G_ALIAS_ALIAS1_Pos;
      group_ptr->ALIAS &= ~(uint32_t)(VADC_G_ALIAS_ALIAS1_Msk);
 80237ca:	f8d0 30b0 	ldr.w	r3, [r0, #176]	; 0xb0
 80237ce:	f423 53f8 	bic.w	r3, r3, #7936	; 0x1f00
 80237d2:	f8c0 30b0 	str.w	r3, [r0, #176]	; 0xb0
 80237d6:	7b53      	ldrb	r3, [r2, #13]
 80237d8:	2508      	movs	r5, #8
 80237da:	e7d4      	b.n	8023786 <XMC_VADC_GROUP_ChannelInit+0x26>

080237dc <XMC_VADC_GROUP_SetResultInterruptNode>:

  XMC_ASSERT("XMC_VADC_GROUP_SetResultInterruptNode:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  XMC_ASSERT("XMC_VADC_GROUP_SetResultInterruptNode:Wrong Result Register", ((res_reg) < XMC_VADC_NUM_RESULT_REGISTERS))
  XMC_ASSERT("XMC_VADC_GROUP_SetResultInterruptNode:Wrong Service Request", ((sr)  <= XMC_VADC_SR_SHARED_SR3))

  if (res_reg <= 7U)
 80237dc:	2907      	cmp	r1, #7

/* API to select a service request line (NVIC Node) for result event of specified unit of result hardware */
void XMC_VADC_GROUP_SetResultInterruptNode(XMC_VADC_GROUP_t *const group_ptr,
                                           const uint32_t res_reg,
                                           const XMC_VADC_SR_t sr)
{
 80237de:	b410      	push	{r4}

  XMC_ASSERT("XMC_VADC_GROUP_SetResultInterruptNode:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  XMC_ASSERT("XMC_VADC_GROUP_SetResultInterruptNode:Wrong Result Register", ((res_reg) < XMC_VADC_NUM_RESULT_REGISTERS))
  XMC_ASSERT("XMC_VADC_GROUP_SetResultInterruptNode:Wrong Service Request", ((sr)  <= XMC_VADC_SR_SHARED_SR3))

  if (res_reg <= 7U)
 80237e0:	d910      	bls.n	8023804 <XMC_VADC_GROUP_SetResultInterruptNode+0x28>
    group_ptr->REVNP0 = route_mask;
  }
  else
  {
    route_mask = group_ptr->REVNP1;
    route_mask &= ~((uint32_t)((uint32_t)15 << (( res_reg - (uint32_t)8) * (uint32_t)4) ));
 80237e2:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
 80237e6:	3908      	subs	r1, #8
    route_mask |= (uint32_t)((uint32_t)sr << (res_reg * (uint32_t)4));
    group_ptr->REVNP0 = route_mask;
  }
  else
  {
    route_mask = group_ptr->REVNP1;
 80237e8:	f8d0 41b4 	ldr.w	r4, [r0, #436]	; 0x1b4
    route_mask &= ~((uint32_t)((uint32_t)15 << (( res_reg - (uint32_t)8) * (uint32_t)4) ));
 80237ec:	0089      	lsls	r1, r1, #2
 80237ee:	230f      	movs	r3, #15
 80237f0:	408b      	lsls	r3, r1
 80237f2:	ea24 0303 	bic.w	r3, r4, r3
    route_mask |= (uint32_t)((uint32_t)sr << ((res_reg - (uint32_t)8) * (uint32_t)4));
 80237f6:	408a      	lsls	r2, r1
 80237f8:	431a      	orrs	r2, r3
    group_ptr->REVNP1 = route_mask;
 80237fa:	f8c0 21b4 	str.w	r2, [r0, #436]	; 0x1b4
  }
}
 80237fe:	f85d 4b04 	ldr.w	r4, [sp], #4
 8023802:	4770      	bx	lr
  XMC_ASSERT("XMC_VADC_GROUP_SetResultInterruptNode:Wrong Result Register", ((res_reg) < XMC_VADC_NUM_RESULT_REGISTERS))
  XMC_ASSERT("XMC_VADC_GROUP_SetResultInterruptNode:Wrong Service Request", ((sr)  <= XMC_VADC_SR_SHARED_SR3))

  if (res_reg <= 7U)
  {
    route_mask  = group_ptr->REVNP0;
 8023804:	f8d0 41b0 	ldr.w	r4, [r0, #432]	; 0x1b0
    route_mask &= ~((uint32_t)((uint32_t)15 << (res_reg * (uint32_t)4) ));
 8023808:	0089      	lsls	r1, r1, #2
 802380a:	230f      	movs	r3, #15
 802380c:	408b      	lsls	r3, r1
 802380e:	ea24 0303 	bic.w	r3, r4, r3
    route_mask |= (uint32_t)((uint32_t)sr << (res_reg * (uint32_t)4));
 8023812:	408a      	lsls	r2, r1
 8023814:	431a      	orrs	r2, r3
    group_ptr->REVNP0 = route_mask;
 8023816:	f8c0 21b0 	str.w	r2, [r0, #432]	; 0x1b0
    route_mask = group_ptr->REVNP1;
    route_mask &= ~((uint32_t)((uint32_t)15 << (( res_reg - (uint32_t)8) * (uint32_t)4) ));
    route_mask |= (uint32_t)((uint32_t)sr << ((res_reg - (uint32_t)8) * (uint32_t)4));
    group_ptr->REVNP1 = route_mask;
  }
}
 802381a:	f85d 4b04 	ldr.w	r4, [sp], #4
 802381e:	4770      	bx	lr

08023820 <_sbrk>:
caddr_t _sbrk(int nbytes)
{
  static caddr_t heap_ptr = NULL;
  caddr_t base;

  if (heap_ptr == NULL) {
 8023820:	4a0c      	ldr	r2, [pc, #48]	; (8023854 <_sbrk+0x34>)

// defined in linker script
extern caddr_t Heap_Bank1_Start;
extern caddr_t Heap_Bank1_End;
caddr_t _sbrk(int nbytes)
{
 8023822:	b508      	push	{r3, lr}
  static caddr_t heap_ptr = NULL;
  caddr_t base;

  if (heap_ptr == NULL) {
 8023824:	6813      	ldr	r3, [r2, #0]
 8023826:	b18b      	cbz	r3, 802384c <_sbrk+0x2c>
  }

  base = heap_ptr;

  /* heap word alignment */
  nbytes = (nbytes + 3) & ~0x3U;
 8023828:	3003      	adds	r0, #3
 802382a:	f020 0003 	bic.w	r0, r0, #3
  if ((caddr_t)&Heap_Bank1_End > (heap_ptr + nbytes))
 802382e:	490a      	ldr	r1, [pc, #40]	; (8023858 <_sbrk+0x38>)
 8023830:	4418      	add	r0, r3
 8023832:	4288      	cmp	r0, r1
 8023834:	d202      	bcs.n	802383c <_sbrk+0x1c>
  {
    heap_ptr += nbytes;
 8023836:	6010      	str	r0, [r2, #0]
  {
    /* Heap overflow */
    errno = ENOMEM;
    return ((caddr_t)-1);
  }
}
 8023838:	4618      	mov	r0, r3
 802383a:	bd08      	pop	{r3, pc}
    return (base);
  }
  else
  {
    /* Heap overflow */
    errno = ENOMEM;
 802383c:	f009 fe72 	bl	802d524 <__errno>
 8023840:	230c      	movs	r3, #12
 8023842:	6003      	str	r3, [r0, #0]
    return ((caddr_t)-1);
 8023844:	f04f 33ff 	mov.w	r3, #4294967295
  }
}
 8023848:	4618      	mov	r0, r3
 802384a:	bd08      	pop	{r3, pc}
{
  static caddr_t heap_ptr = NULL;
  caddr_t base;

  if (heap_ptr == NULL) {
    heap_ptr = (caddr_t)&Heap_Bank1_Start;
 802384c:	4b03      	ldr	r3, [pc, #12]	; (802385c <_sbrk+0x3c>)
 802384e:	6013      	str	r3, [r2, #0]
 8023850:	e7ea      	b.n	8023828 <_sbrk+0x8>
 8023852:	bf00      	nop
 8023854:	1ffe97dc 	.word	0x1ffe97dc
 8023858:	2003ffc0 	.word	0x2003ffc0
 802385c:	20000e00 	.word	0x20000e00

08023860 <send_device_status_response.part.0>:
==============================================================================
   6. EXPORTED FUNCTIONS
==============================================================================
 */

uint16_t send_device_status_response()
 8023860:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
static uint8_t device_status_endpoint = 0;

static void fill_status_response(device_status_response_t *p_status_response)
{
	Device_Status_t *device_status = NULL;
	device_status = device_status_get_handle(device_status);
 8023864:	2000      	movs	r0, #0
 8023866:	f7fd f9ad 	bl	8020bc4 <device_status_get_handle>

	p_status_response->error_code = (uint16_t) device_status->latest_error;
 802386a:	f8d0 9004 	ldr.w	r9, [r0, #4]
	p_status_response->error_type = (uint8_t) device_status->state,
 802386e:	7806      	ldrb	r6, [r0, #0]
static void fill_status_response(device_status_response_t *p_status_response)
{
	Device_Status_t *device_status = NULL;
	device_status = device_status_get_handle(device_status);

	p_status_response->error_code = (uint16_t) device_status->latest_error;
 8023870:	fa1f f889 	uxth.w	r8, r9
	p_status_response->error_type = (uint8_t) device_status->state,
	p_status_response->frame_count = 0;
	if (device_status->state != STATE_NO_ERROR)
 8023874:	2e00      	cmp	r6, #0
 8023876:	f040 8091 	bne.w	802399c <send_device_status_response.part.0+0x13c>

		/* fetch device info an fill status response */
		fill_status_response(&status_response);

		static uint8_t message[512];  // allocate statically, rather then on the call stack!
		memset(message, 0, sizeof(message));
 802387a:	4d5e      	ldr	r5, [pc, #376]	; (80239f4 <send_device_status_response.part.0+0x194>)
		p_status_response->error_msg = device_status_get_error_description(device_status->latest_error);
		p_status_response->error_msg_size = strlen(p_status_response->error_msg) + 1;  // include the leading zero!
	}
	else
	{
		p_status_response->error_msg = "No Error";
 802387c:	4f5e      	ldr	r7, [pc, #376]	; (80239f8 <send_device_status_response.part.0+0x198>)

		/* fetch device info an fill status response */
		fill_status_response(&status_response);

		static uint8_t message[512];  // allocate statically, rather then on the call stack!
		memset(message, 0, sizeof(message));
 802387e:	4628      	mov	r0, r5
 8023880:	4631      	mov	r1, r6
 8023882:	f44f 7200 	mov.w	r2, #512	; 0x200
 8023886:	f009 fe6e 	bl	802d566 <memset>
}

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 802388a:	ea4f 2818 	mov.w	r8, r8, lsr #8
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 802388e:	234a      	movs	r3, #74	; 0x4a

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 8023890:	2409      	movs	r4, #9
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8023892:	706e      	strb	r6, [r5, #1]

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 8023894:	f885 9002 	strb.w	r9, [r5, #2]
}

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 8023898:	726e      	strb	r6, [r5, #9]
 802389a:	f885 8003 	strb.w	r8, [r5, #3]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 802389e:	702b      	strb	r3, [r5, #0]

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 80238a0:	722c      	strb	r4, [r5, #8]
 80238a2:	4a56      	ldr	r2, [pc, #344]	; (80239fc <send_device_status_response.part.0+0x19c>)
 80238a4:	f107 0308 	add.w	r3, r7, #8
 80238a8:	f102 0108 	add.w	r1, r2, #8
 80238ac:	42b9      	cmp	r1, r7
 80238ae:	bf88      	it	hi
 80238b0:	4293      	cmphi	r3, r2
 80238b2:	bf94      	ite	ls
 80238b4:	2301      	movls	r3, #1
 80238b6:	2300      	movhi	r3, #0
 80238b8:	2c0a      	cmp	r4, #10
 80238ba:	bf94      	ite	ls
 80238bc:	2300      	movls	r3, #0
 80238be:	f003 0301 	andhi.w	r3, r3, #1
 80238c2:	2b00      	cmp	r3, #0
 80238c4:	f000 808a 	beq.w	80239dc <send_device_status_response.part.0+0x17c>
 80238c8:	ea47 0302 	orr.w	r3, r7, r2
 80238cc:	075b      	lsls	r3, r3, #29
 80238ce:	f040 8085 	bne.w	80239dc <send_device_status_response.part.0+0x17c>
 80238d2:	f1a4 0e08 	sub.w	lr, r4, #8
 80238d6:	f3ce 0ecc 	ubfx	lr, lr, #3, #13
 80238da:	f10e 0e01 	add.w	lr, lr, #1
 80238de:	ea4f 03ce 	mov.w	r3, lr, lsl #3
 80238e2:	b29b      	uxth	r3, r3
 80238e4:	f1a7 0808 	sub.w	r8, r7, #8
		p_status_response->error_msg = device_status_get_error_description(device_status->latest_error);
		p_status_response->error_msg_size = strlen(p_status_response->error_msg) + 1;  // include the leading zero!
	}
	else
	{
		p_status_response->error_msg = "No Error";
 80238e8:	f04f 0c00 	mov.w	ip, #0
		offset += wr_payload_u32(message, offset, status_response.frame_count);		/*frame count*/
		offset += wr_payload_u16(message, offset, status_response.error_msg_size);		/*frame count*/

		for(uint16_t i=0; i<status_response.error_msg_size; i++ )
		{
			offset += wr_payload_u8(message, offset, status_response.error_msg[i]);
 80238ec:	e9f8 0102 	ldrd	r0, r1, [r8, #8]!
 80238f0:	f10c 0c01 	add.w	ip, ip, #1
 80238f4:	fa1f f98c 	uxth.w	r9, ip
 80238f8:	45ce      	cmp	lr, r9
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 80238fa:	e8e2 0102 	strd	r0, r1, [r2], #8
 80238fe:	d8f5      	bhi.n	80238ec <send_device_status_response.part.0+0x8c>
 8023900:	429c      	cmp	r4, r3
 8023902:	f103 000a 	add.w	r0, r3, #10
 8023906:	d047      	beq.n	8023998 <send_device_status_response.part.0+0x138>
		offset += wr_payload_u8(message, offset, status_response.error_type);		/*error type*/
		offset += wr_payload_u16(message, offset, status_response.error_code);		/*error code*/
		offset += wr_payload_u32(message, offset, status_response.frame_count);		/*frame count*/
		offset += wr_payload_u16(message, offset, status_response.error_msg_size);		/*frame count*/

		for(uint16_t i=0; i<status_response.error_msg_size; i++ )
 8023908:	1c59      	adds	r1, r3, #1
 802390a:	b289      	uxth	r1, r1
		{
			offset += wr_payload_u8(message, offset, status_response.error_msg[i]);
 802390c:	5cfa      	ldrb	r2, [r7, r3]
 802390e:	542a      	strb	r2, [r5, r0]
		offset += wr_payload_u8(message, offset, status_response.error_type);		/*error type*/
		offset += wr_payload_u16(message, offset, status_response.error_code);		/*error code*/
		offset += wr_payload_u32(message, offset, status_response.frame_count);		/*frame count*/
		offset += wr_payload_u16(message, offset, status_response.error_msg_size);		/*frame count*/

		for(uint16_t i=0; i<status_response.error_msg_size; i++ )
 8023910:	42a1      	cmp	r1, r4
 8023912:	4a38      	ldr	r2, [pc, #224]	; (80239f4 <send_device_status_response.part.0+0x194>)
		{
			offset += wr_payload_u8(message, offset, status_response.error_msg[i]);
 8023914:	f103 050b 	add.w	r5, r3, #11
		offset += wr_payload_u8(message, offset, status_response.error_type);		/*error type*/
		offset += wr_payload_u16(message, offset, status_response.error_code);		/*error code*/
		offset += wr_payload_u32(message, offset, status_response.frame_count);		/*frame count*/
		offset += wr_payload_u16(message, offset, status_response.error_msg_size);		/*frame count*/

		for(uint16_t i=0; i<status_response.error_msg_size; i++ )
 8023918:	d23e      	bcs.n	8023998 <send_device_status_response.part.0+0x138>
 802391a:	1c98      	adds	r0, r3, #2
 802391c:	b280      	uxth	r0, r0
		{
			offset += wr_payload_u8(message, offset, status_response.error_msg[i]);
 802391e:	5c79      	ldrb	r1, [r7, r1]
 8023920:	5551      	strb	r1, [r2, r5]
		offset += wr_payload_u8(message, offset, status_response.error_type);		/*error type*/
		offset += wr_payload_u16(message, offset, status_response.error_code);		/*error code*/
		offset += wr_payload_u32(message, offset, status_response.frame_count);		/*frame count*/
		offset += wr_payload_u16(message, offset, status_response.error_msg_size);		/*frame count*/

		for(uint16_t i=0; i<status_response.error_msg_size; i++ )
 8023922:	4284      	cmp	r4, r0
		{
			offset += wr_payload_u8(message, offset, status_response.error_msg[i]);
 8023924:	f103 050c 	add.w	r5, r3, #12
		offset += wr_payload_u8(message, offset, status_response.error_type);		/*error type*/
		offset += wr_payload_u16(message, offset, status_response.error_code);		/*error code*/
		offset += wr_payload_u32(message, offset, status_response.frame_count);		/*frame count*/
		offset += wr_payload_u16(message, offset, status_response.error_msg_size);		/*frame count*/

		for(uint16_t i=0; i<status_response.error_msg_size; i++ )
 8023928:	d936      	bls.n	8023998 <send_device_status_response.part.0+0x138>
 802392a:	1cd9      	adds	r1, r3, #3
 802392c:	b289      	uxth	r1, r1
		{
			offset += wr_payload_u8(message, offset, status_response.error_msg[i]);
 802392e:	5c38      	ldrb	r0, [r7, r0]
 8023930:	5550      	strb	r0, [r2, r5]
		offset += wr_payload_u8(message, offset, status_response.error_type);		/*error type*/
		offset += wr_payload_u16(message, offset, status_response.error_code);		/*error code*/
		offset += wr_payload_u32(message, offset, status_response.frame_count);		/*frame count*/
		offset += wr_payload_u16(message, offset, status_response.error_msg_size);		/*frame count*/

		for(uint16_t i=0; i<status_response.error_msg_size; i++ )
 8023932:	428c      	cmp	r4, r1
		{
			offset += wr_payload_u8(message, offset, status_response.error_msg[i]);
 8023934:	f103 050d 	add.w	r5, r3, #13
		offset += wr_payload_u8(message, offset, status_response.error_type);		/*error type*/
		offset += wr_payload_u16(message, offset, status_response.error_code);		/*error code*/
		offset += wr_payload_u32(message, offset, status_response.frame_count);		/*frame count*/
		offset += wr_payload_u16(message, offset, status_response.error_msg_size);		/*frame count*/

		for(uint16_t i=0; i<status_response.error_msg_size; i++ )
 8023938:	d92e      	bls.n	8023998 <send_device_status_response.part.0+0x138>
 802393a:	1d18      	adds	r0, r3, #4
 802393c:	b280      	uxth	r0, r0
		{
			offset += wr_payload_u8(message, offset, status_response.error_msg[i]);
 802393e:	5c79      	ldrb	r1, [r7, r1]
 8023940:	5551      	strb	r1, [r2, r5]
		offset += wr_payload_u8(message, offset, status_response.error_type);		/*error type*/
		offset += wr_payload_u16(message, offset, status_response.error_code);		/*error code*/
		offset += wr_payload_u32(message, offset, status_response.frame_count);		/*frame count*/
		offset += wr_payload_u16(message, offset, status_response.error_msg_size);		/*frame count*/

		for(uint16_t i=0; i<status_response.error_msg_size; i++ )
 8023942:	4284      	cmp	r4, r0
		{
			offset += wr_payload_u8(message, offset, status_response.error_msg[i]);
 8023944:	f103 050e 	add.w	r5, r3, #14
		offset += wr_payload_u8(message, offset, status_response.error_type);		/*error type*/
		offset += wr_payload_u16(message, offset, status_response.error_code);		/*error code*/
		offset += wr_payload_u32(message, offset, status_response.frame_count);		/*frame count*/
		offset += wr_payload_u16(message, offset, status_response.error_msg_size);		/*frame count*/

		for(uint16_t i=0; i<status_response.error_msg_size; i++ )
 8023948:	d926      	bls.n	8023998 <send_device_status_response.part.0+0x138>
 802394a:	1d59      	adds	r1, r3, #5
 802394c:	b289      	uxth	r1, r1
		{
			offset += wr_payload_u8(message, offset, status_response.error_msg[i]);
 802394e:	5c38      	ldrb	r0, [r7, r0]
 8023950:	5550      	strb	r0, [r2, r5]
		offset += wr_payload_u8(message, offset, status_response.error_type);		/*error type*/
		offset += wr_payload_u16(message, offset, status_response.error_code);		/*error code*/
		offset += wr_payload_u32(message, offset, status_response.frame_count);		/*frame count*/
		offset += wr_payload_u16(message, offset, status_response.error_msg_size);		/*frame count*/

		for(uint16_t i=0; i<status_response.error_msg_size; i++ )
 8023952:	428c      	cmp	r4, r1
		{
			offset += wr_payload_u8(message, offset, status_response.error_msg[i]);
 8023954:	f103 050f 	add.w	r5, r3, #15
		offset += wr_payload_u8(message, offset, status_response.error_type);		/*error type*/
		offset += wr_payload_u16(message, offset, status_response.error_code);		/*error code*/
		offset += wr_payload_u32(message, offset, status_response.frame_count);		/*frame count*/
		offset += wr_payload_u16(message, offset, status_response.error_msg_size);		/*frame count*/

		for(uint16_t i=0; i<status_response.error_msg_size; i++ )
 8023958:	d91e      	bls.n	8023998 <send_device_status_response.part.0+0x138>
 802395a:	1d98      	adds	r0, r3, #6
		{
			offset += wr_payload_u8(message, offset, status_response.error_msg[i]);
 802395c:	5c79      	ldrb	r1, [r7, r1]
 802395e:	5551      	strb	r1, [r2, r5]
		offset += wr_payload_u8(message, offset, status_response.error_type);		/*error type*/
		offset += wr_payload_u16(message, offset, status_response.error_code);		/*error code*/
		offset += wr_payload_u32(message, offset, status_response.frame_count);		/*frame count*/
		offset += wr_payload_u16(message, offset, status_response.error_msg_size);		/*frame count*/

		for(uint16_t i=0; i<status_response.error_msg_size; i++ )
 8023960:	b281      	uxth	r1, r0
 8023962:	428c      	cmp	r4, r1
		{
			offset += wr_payload_u8(message, offset, status_response.error_msg[i]);
 8023964:	f103 0310 	add.w	r3, r3, #16
		offset += wr_payload_u8(message, offset, status_response.error_type);		/*error type*/
		offset += wr_payload_u16(message, offset, status_response.error_code);		/*error code*/
		offset += wr_payload_u32(message, offset, status_response.frame_count);		/*frame count*/
		offset += wr_payload_u16(message, offset, status_response.error_msg_size);		/*frame count*/

		for(uint16_t i=0; i<status_response.error_msg_size; i++ )
 8023968:	d916      	bls.n	8023998 <send_device_status_response.part.0+0x138>
		{
			offset += wr_payload_u8(message, offset, status_response.error_msg[i]);
 802396a:	5c79      	ldrb	r1, [r7, r1]
 802396c:	54d1      	strb	r1, [r2, r3]
 802396e:	3c01      	subs	r4, #1
 8023970:	340b      	adds	r4, #11
 8023972:	b2a4      	uxth	r4, r4
		}

		/* send message */
		protocol_send_header(device_status_endpoint, offset);
 8023974:	4b22      	ldr	r3, [pc, #136]	; (8023a00 <send_device_status_response.part.0+0x1a0>)
 8023976:	4621      	mov	r1, r4
 8023978:	7818      	ldrb	r0, [r3, #0]
 802397a:	f000 ff2f 	bl	80247dc <protocol_send_header>
		protocol_send_payload(message, offset);
 802397e:	4621      	mov	r1, r4
 8023980:	481c      	ldr	r0, [pc, #112]	; (80239f4 <send_device_status_response.part.0+0x194>)
 8023982:	f000 ff3f 	bl	8024804 <protocol_send_payload>
		protocol_send_tail();
 8023986:	f000 ff3f 	bl	8024808 <protocol_send_tail>

		/* clean error, if not fatal */
		if (status_response.error_type != 4)
 802398a:	2e04      	cmp	r6, #4
 802398c:	d001      	beq.n	8023992 <send_device_status_response.part.0+0x132>
			device_status_clean();
 802398e:	f7fd f971 	bl	8020c74 <device_status_clean>
	}
	return RADAR_ERR_OK;
}
 8023992:	2000      	movs	r0, #0
 8023994:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8023998:	3c01      	subs	r4, #1
 802399a:	e7e9      	b.n	8023970 <send_device_status_response.part.0+0x110>
	p_status_response->error_code = (uint16_t) device_status->latest_error;
	p_status_response->error_type = (uint8_t) device_status->state,
	p_status_response->frame_count = 0;
	if (device_status->state != STATE_NO_ERROR)
	{
		p_status_response->error_msg = device_status_get_error_description(device_status->latest_error);
 802399c:	4648      	mov	r0, r9
 802399e:	f7fd f941 	bl	8020c24 <device_status_get_error_description>
 80239a2:	4607      	mov	r7, r0
		p_status_response->error_msg_size = strlen(p_status_response->error_msg) + 1;  // include the leading zero!
 80239a4:	f00a f95c 	bl	802dc60 <strlen>

		/* fetch device info an fill status response */
		fill_status_response(&status_response);

		static uint8_t message[512];  // allocate statically, rather then on the call stack!
		memset(message, 0, sizeof(message));
 80239a8:	4d12      	ldr	r5, [pc, #72]	; (80239f4 <send_device_status_response.part.0+0x194>)
	p_status_response->error_type = (uint8_t) device_status->state,
	p_status_response->frame_count = 0;
	if (device_status->state != STATE_NO_ERROR)
	{
		p_status_response->error_msg = device_status_get_error_description(device_status->latest_error);
		p_status_response->error_msg_size = strlen(p_status_response->error_msg) + 1;  // include the leading zero!
 80239aa:	3001      	adds	r0, #1
 80239ac:	b284      	uxth	r4, r0

		/* fetch device info an fill status response */
		fill_status_response(&status_response);

		static uint8_t message[512];  // allocate statically, rather then on the call stack!
		memset(message, 0, sizeof(message));
 80239ae:	f44f 7200 	mov.w	r2, #512	; 0x200
 80239b2:	4628      	mov	r0, r5
 80239b4:	2100      	movs	r1, #0
 80239b6:	f009 fdd6 	bl	802d566 <memset>
}

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 80239ba:	ea4f 2818 	mov.w	r8, r8, lsr #8
 80239be:	0a22      	lsrs	r2, r4, #8
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 80239c0:	234a      	movs	r3, #74	; 0x4a
 80239c2:	722c      	strb	r4, [r5, #8]
 80239c4:	706e      	strb	r6, [r5, #1]

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 80239c6:	f885 9002 	strb.w	r9, [r5, #2]
}

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 80239ca:	f885 8003 	strb.w	r8, [r5, #3]
 80239ce:	726a      	strb	r2, [r5, #9]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 80239d0:	702b      	strb	r3, [r5, #0]
		offset += wr_payload_u8(message, offset, status_response.error_type);		/*error type*/
		offset += wr_payload_u16(message, offset, status_response.error_code);		/*error code*/
		offset += wr_payload_u32(message, offset, status_response.frame_count);		/*frame count*/
		offset += wr_payload_u16(message, offset, status_response.error_msg_size);		/*frame count*/

		for(uint16_t i=0; i<status_response.error_msg_size; i++ )
 80239d2:	2c00      	cmp	r4, #0
 80239d4:	f47f af65 	bne.w	80238a2 <send_device_status_response.part.0+0x42>
 80239d8:	240a      	movs	r4, #10
 80239da:	e7cb      	b.n	8023974 <send_device_status_response.part.0+0x114>
 80239dc:	3c01      	subs	r4, #1
 80239de:	4b09      	ldr	r3, [pc, #36]	; (8023a04 <send_device_status_response.part.0+0x1a4>)
 80239e0:	fa17 f184 	uxtah	r1, r7, r4
 80239e4:	3f01      	subs	r7, #1
		{
			offset += wr_payload_u8(message, offset, status_response.error_msg[i]);
 80239e6:	f817 2f01 	ldrb.w	r2, [r7, #1]!
 80239ea:	f803 2f01 	strb.w	r2, [r3, #1]!
		offset += wr_payload_u8(message, offset, status_response.error_type);		/*error type*/
		offset += wr_payload_u16(message, offset, status_response.error_code);		/*error code*/
		offset += wr_payload_u32(message, offset, status_response.frame_count);		/*frame count*/
		offset += wr_payload_u16(message, offset, status_response.error_msg_size);		/*frame count*/

		for(uint16_t i=0; i<status_response.error_msg_size; i++ )
 80239ee:	428f      	cmp	r7, r1
 80239f0:	d1f9      	bne.n	80239e6 <send_device_status_response.part.0+0x186>
 80239f2:	e7bd      	b.n	8023970 <send_device_status_response.part.0+0x110>
 80239f4:	1ffe97e0 	.word	0x1ffe97e0
 80239f8:	0802f2f4 	.word	0x0802f2f4
 80239fc:	1ffe97ea 	.word	0x1ffe97ea
 8023a00:	1ffe99e0 	.word	0x1ffe99e0
 8023a04:	1ffe97e9 	.word	0x1ffe97e9

08023a08 <send_device_status_response>:
   6. EXPORTED FUNCTIONS
==============================================================================
 */

uint16_t send_device_status_response()
{
 8023a08:	b508      	push	{r3, lr}
	if (device_status_endpoint != 0)
 8023a0a:	4b03      	ldr	r3, [pc, #12]	; (8023a18 <send_device_status_response+0x10>)
 8023a0c:	781b      	ldrb	r3, [r3, #0]
 8023a0e:	b10b      	cbz	r3, 8023a14 <send_device_status_response+0xc>
 8023a10:	f7ff ff26 	bl	8023860 <send_device_status_response.part.0>
		/* clean error, if not fatal */
		if (status_response.error_type != 4)
			device_status_clean();
	}
	return RADAR_ERR_OK;
}
 8023a14:	2000      	movs	r0, #0
 8023a16:	bd08      	pop	{r3, pc}
 8023a18:	1ffe99e0 	.word	0x1ffe99e0

08023a1c <ep_device_status_handle_message>:

uint16_t ep_device_status_handle_message(uint8_t endpoint, uint8_t *message_data,
											uint16_t num_bytes,	void* context)
{
 8023a1c:	b508      	push	{r3, lr}
	/*store endpoint information*/

	device_status_endpoint = endpoint;

    switch (message_data[0])
 8023a1e:	780b      	ldrb	r3, [r1, #0]
uint16_t ep_device_status_handle_message(uint8_t endpoint, uint8_t *message_data,
											uint16_t num_bytes,	void* context)
{
	/*store endpoint information*/

	device_status_endpoint = endpoint;
 8023a20:	4a06      	ldr	r2, [pc, #24]	; (8023a3c <ep_device_status_handle_message+0x20>)

    switch (message_data[0])
 8023a22:	2b4b      	cmp	r3, #75	; 0x4b
uint16_t ep_device_status_handle_message(uint8_t endpoint, uint8_t *message_data,
											uint16_t num_bytes,	void* context)
{
	/*store endpoint information*/

	device_status_endpoint = endpoint;
 8023a24:	7010      	strb	r0, [r2, #0]

    switch (message_data[0])
 8023a26:	d002      	beq.n	8023a2e <ep_device_status_handle_message+0x12>
		return RADAR_ERR_OK;
	default:
		break;
    }

    return PROTOCOL_STATUS_INVALID_PAYLOAD;
 8023a28:	f64f 70ff 	movw	r0, #65535	; 0xffff
}
 8023a2c:	bd08      	pop	{r3, pc}
==============================================================================
 */

uint16_t send_device_status_response()
{
	if (device_status_endpoint != 0)
 8023a2e:	2800      	cmp	r0, #0
 8023a30:	d0fc      	beq.n	8023a2c <ep_device_status_handle_message+0x10>
 8023a32:	f7ff ff15 	bl	8023860 <send_device_status_response.part.0>

    switch (message_data[0])
    {
	case MSG_STATUS_REQ_IND:
		send_device_status_response();
		return RADAR_ERR_OK;
 8023a36:	2000      	movs	r0, #0
 8023a38:	bd08      	pop	{r3, pc}
 8023a3a:	bf00      	nop
 8023a3c:	1ffe99e0 	.word	0x1ffe99e0

08023a40 <ep_device_status_handle_change>:

    return PROTOCOL_STATUS_INVALID_PAYLOAD;
}

void ep_device_status_handle_change(uint8_t endpoint, void* context, uint32_t what)
{
 8023a40:	4770      	bx	lr
 8023a42:	bf00      	nop

08023a44 <send_consumption_response>:
/** @} */

/*  helper */

uint16_t send_consumption_response(uint8_t entries, consumption_response_t *pData )
{
 8023a44:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	uint8_t message[256];
	int16_t offset = 0;
	uint8_t endpoint = mcu_base_endpoint;
 8023a48:	4b2f      	ldr	r3, [pc, #188]	; (8023b08 <send_consumption_response+0xc4>)
/** @} */

/*  helper */

uint16_t send_consumption_response(uint8_t entries, consumption_response_t *pData )
{
 8023a4a:	b0c1      	sub	sp, #260	; 0x104
 8023a4c:	22d3      	movs	r2, #211	; 0xd3
 8023a4e:	4605      	mov	r5, r0
 8023a50:	f88d 0003 	strb.w	r0, [sp, #3]
 8023a54:	f88d 2000 	strb.w	r2, [sp]
	uint8_t message[256];
	int16_t offset = 0;
	uint8_t endpoint = mcu_base_endpoint;
 8023a58:	781e      	ldrb	r6, [r3, #0]

	offset += wr_payload_u8(message, offset, MSG_CONSUMPTION_RES);
	offset += sizeof(uint16_t); // reserve space for the total message size and write it later
	offset += wr_payload_u8(message, offset, entries);
	for(int i = 0; i < entries; i++) {
 8023a5a:	2800      	cmp	r0, #0
 8023a5c:	d050      	beq.n	8023b00 <send_consumption_response+0xbc>
 8023a5e:	460f      	mov	r7, r1
 8023a60:	f04f 0800 	mov.w	r8, #0
 8023a64:	2304      	movs	r3, #4
		offset += wr_payload_u8(message, offset, pData[i].index);
 8023a66:	f103 0901 	add.w	r9, r3, #1
 8023a6a:	b21b      	sxth	r3, r3
 8023a6c:	fa1f f989 	uxth.w	r9, r9
 8023a70:	7839      	ldrb	r1, [r7, #0]
 8023a72:	f80d 1003 	strb.w	r1, [sp, r3]
		offset += wr_payload_float(message, offset, pData[i].value);
 8023a76:	687a      	ldr	r2, [r7, #4]
 8023a78:	fa0f f189 	sxth.w	r1, r9
 8023a7c:	4668      	mov	r0, sp
 8023a7e:	f000 ff07 	bl	8024890 <wr_payload_float>

		uint8_t len = (uint8_t) strlen(pData[i].p_unit);
 8023a82:	68bc      	ldr	r4, [r7, #8]
	offset += wr_payload_u8(message, offset, MSG_CONSUMPTION_RES);
	offset += sizeof(uint16_t); // reserve space for the total message size and write it later
	offset += wr_payload_u8(message, offset, entries);
	for(int i = 0; i < entries; i++) {
		offset += wr_payload_u8(message, offset, pData[i].index);
		offset += wr_payload_float(message, offset, pData[i].value);
 8023a84:	4448      	add	r0, r9
 8023a86:	fa1f f980 	uxth.w	r9, r0

		uint8_t len = (uint8_t) strlen(pData[i].p_unit);
 8023a8a:	4620      	mov	r0, r4
 8023a8c:	f00a f8e8 	bl	802dc60 <strlen>
		offset += wr_payload_u8(message, offset, len);
 8023a90:	f109 0e01 	add.w	lr, r9, #1
 8023a94:	fa0f f989 	sxth.w	r9, r9
 8023a98:	fa1f fe8e 	uxth.w	lr, lr
		for(int k = 0; k < len; k++)
 8023a9c:	f010 0cff 	ands.w	ip, r0, #255	; 0xff
	offset += wr_payload_u8(message, offset, entries);
	for(int i = 0; i < entries; i++) {
		offset += wr_payload_u8(message, offset, pData[i].index);
		offset += wr_payload_float(message, offset, pData[i].value);

		uint8_t len = (uint8_t) strlen(pData[i].p_unit);
 8023aa0:	f80d 0009 	strb.w	r0, [sp, r9]
		offset += wr_payload_u8(message, offset, len);
 8023aa4:	fa1f f38e 	uxth.w	r3, lr
		for(int k = 0; k < len; k++)
 8023aa8:	d00f      	beq.n	8023aca <send_consumption_response+0x86>
 8023aaa:	4620      	mov	r0, r4
 8023aac:	eb04 010c 	add.w	r1, r4, ip
		{
			offset += wr_payload_u8(message, offset, pData[i].p_unit[k]);
 8023ab0:	f810 4b01 	ldrb.w	r4, [r0], #1
 8023ab4:	b21a      	sxth	r2, r3
		offset += wr_payload_u8(message, offset, pData[i].index);
		offset += wr_payload_float(message, offset, pData[i].value);

		uint8_t len = (uint8_t) strlen(pData[i].p_unit);
		offset += wr_payload_u8(message, offset, len);
		for(int k = 0; k < len; k++)
 8023ab6:	4288      	cmp	r0, r1
 8023ab8:	f103 0301 	add.w	r3, r3, #1
 8023abc:	f80d 4002 	strb.w	r4, [sp, r2]
 8023ac0:	b29b      	uxth	r3, r3
 8023ac2:	d1f5      	bne.n	8023ab0 <send_consumption_response+0x6c>
 8023ac4:	eb0e 000c 	add.w	r0, lr, ip
 8023ac8:	b283      	uxth	r3, r0
	uint8_t endpoint = mcu_base_endpoint;

	offset += wr_payload_u8(message, offset, MSG_CONSUMPTION_RES);
	offset += sizeof(uint16_t); // reserve space for the total message size and write it later
	offset += wr_payload_u8(message, offset, entries);
	for(int i = 0; i < entries; i++) {
 8023aca:	f108 0801 	add.w	r8, r8, #1
 8023ace:	45a8      	cmp	r8, r5
 8023ad0:	f107 070c 	add.w	r7, r7, #12
 8023ad4:	d1c7      	bne.n	8023a66 <send_consumption_response+0x22>
 8023ad6:	b29c      	uxth	r4, r3
 8023ad8:	0a25      	lsrs	r5, r4, #8
 8023ada:	b2db      	uxtb	r3, r3
		}
	}
	wr_payload_u16(message,1,offset);

	/* send message */
	protocol_send_header(endpoint, offset);
 8023adc:	4630      	mov	r0, r6
 8023ade:	4621      	mov	r1, r4

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 8023ae0:	f88d 3001 	strb.w	r3, [sp, #1]
}

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 8023ae4:	f88d 5002 	strb.w	r5, [sp, #2]
 8023ae8:	f000 fe78 	bl	80247dc <protocol_send_header>
	protocol_send_payload(message, offset);
 8023aec:	4668      	mov	r0, sp
 8023aee:	4621      	mov	r1, r4
 8023af0:	f000 fe88 	bl	8024804 <protocol_send_payload>
	protocol_send_tail();
 8023af4:	f000 fe88 	bl	8024808 <protocol_send_tail>

	return RADAR_ERR_OK;
}
 8023af8:	2000      	movs	r0, #0
 8023afa:	b041      	add	sp, #260	; 0x104
 8023afc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	uint8_t endpoint = mcu_base_endpoint;

	offset += wr_payload_u8(message, offset, MSG_CONSUMPTION_RES);
	offset += sizeof(uint16_t); // reserve space for the total message size and write it later
	offset += wr_payload_u8(message, offset, entries);
	for(int i = 0; i < entries; i++) {
 8023b00:	2304      	movs	r3, #4
 8023b02:	461c      	mov	r4, r3
 8023b04:	e7ea      	b.n	8023adc <send_consumption_response+0x98>
 8023b06:	bf00      	nop
 8023b08:	1ffe99e1 	.word	0x1ffe99e1

08023b0c <ep_radar_mcu_base_handle_message>:

uint32_t g_detected_rf_shield_id = 0;

uint16_t ep_radar_mcu_base_handle_message(uint8_t endpoint, uint8_t *message_data,
											uint16_t num_bytes,	void* context)
{
 8023b0c:	b5f0      	push	{r4, r5, r6, r7, lr}
	mcu_base_endpoint = endpoint;

	switch (message_data[0])
 8023b0e:	780b      	ldrb	r3, [r1, #0]
uint32_t g_detected_rf_shield_id = 0;

uint16_t ep_radar_mcu_base_handle_message(uint8_t endpoint, uint8_t *message_data,
											uint16_t num_bytes,	void* context)
{
	mcu_base_endpoint = endpoint;
 8023b10:	4c58      	ldr	r4, [pc, #352]	; (8023c74 <ep_radar_mcu_base_handle_message+0x168>)

	switch (message_data[0])
 8023b12:	3bd0      	subs	r3, #208	; 0xd0

uint32_t g_detected_rf_shield_id = 0;

uint16_t ep_radar_mcu_base_handle_message(uint8_t endpoint, uint8_t *message_data,
											uint16_t num_bytes,	void* context)
{
 8023b14:	b085      	sub	sp, #20
 8023b16:	4605      	mov	r5, r0
	mcu_base_endpoint = endpoint;
 8023b18:	7020      	strb	r0, [r4, #0]

	switch (message_data[0])
 8023b1a:	2b14      	cmp	r3, #20
 8023b1c:	d80f      	bhi.n	8023b3e <ep_radar_mcu_base_handle_message+0x32>
 8023b1e:	e8df f003 	tbb	[pc, r3]
 8023b22:	0e12      	.short	0x0e12
 8023b24:	0e0e0e39 	.word	0x0e0e0e39
 8023b28:	0e0e0e0e 	.word	0x0e0e0e0e
 8023b2c:	0e0e0e0e 	.word	0x0e0e0e0e
 8023b30:	0e490e0e 	.word	0x0e490e0e
 8023b34:	0e7b      	.short	0x0e7b
 8023b36:	0b          	.byte	0x0b
 8023b37:	00          	.byte	0x00
			return RADAR_ERR_OK;
		}
		break;

	case MSG_PARA_FACTORY_RESET_IND:
		if (num_bytes == 1)
 8023b38:	2a01      	cmp	r2, #1
 8023b3a:	f000 8089 	beq.w	8023c50 <ep_radar_mcu_base_handle_message+0x144>

	default:
		break;
	}

	return PROTOCOL_STATUS_INVALID_PAYLOAD;
 8023b3e:	f64f 70ff 	movw	r0, #65535	; 0xffff
}
 8023b42:	b005      	add	sp, #20
 8023b44:	bdf0      	pop	{r4, r5, r6, r7, pc}

	switch (message_data[0])
	{

	case MSG_CONSUMPTION_DEF_IND:
		if (num_bytes == 1)
 8023b46:	2a01      	cmp	r2, #1
 8023b48:	d1f9      	bne.n	8023b3e <ep_radar_mcu_base_handle_message+0x32>
		{
			static uint8_t message[512]; // allocate statically, rather then on the call stack!
			memset(message, 0, sizeof(message));
 8023b4a:	2100      	movs	r1, #0
 8023b4c:	f44f 7200 	mov.w	r2, #512	; 0x200
 8023b50:	4849      	ldr	r0, [pc, #292]	; (8023c78 <ep_radar_mcu_base_handle_message+0x16c>)
 8023b52:	f009 fd08 	bl	802d566 <memset>

			uint32_t offset = 0;
			para_consumption_def_t *p_consumption_def_list = radar_get_consumption_labels();
 8023b56:	f7fd f895 	bl	8020c84 <radar_get_consumption_labels>
			if (p_consumption_def_list == NULL)
 8023b5a:	2800      	cmp	r0, #0
 8023b5c:	f000 8088 	beq.w	8023c70 <ep_radar_mcu_base_handle_message+0x164>
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8023b60:	4c45      	ldr	r4, [pc, #276]	; (8023c78 <ep_radar_mcu_base_handle_message+0x16c>)
			}

			offset += wr_payload_u8(message, 0, MSG_CONSUMPTION_DEF_RES);
			offset += sizeof(uint16_t); // size if uint16

			offset += wr_payload_helper_string_list(message, offset, p_consumption_def_list->num_labels, p_consumption_def_list->p_consumption_labels);
 8023b62:	6843      	ldr	r3, [r0, #4]
 8023b64:	22d1      	movs	r2, #209	; 0xd1
 8023b66:	7022      	strb	r2, [r4, #0]
 8023b68:	6802      	ldr	r2, [r0, #0]
 8023b6a:	2103      	movs	r1, #3
 8023b6c:	4620      	mov	r0, r4
 8023b6e:	f000 feff 	bl	8024970 <wr_payload_helper_string_list>
 8023b72:	1cc3      	adds	r3, r0, #3

			// write size values of the message!
			wr_payload_u16(message, 1, (uint16_t)offset);
 8023b74:	b29e      	uxth	r6, r3
}

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 8023b76:	0a32      	lsrs	r2, r6, #8
    payload[offset    ] =  value        & 0xFF;
 8023b78:	7063      	strb	r3, [r4, #1]
}

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 8023b7a:	70a2      	strb	r2, [r4, #2]

			/* send message */
			protocol_send_header(endpoint, offset);
 8023b7c:	4628      	mov	r0, r5
 8023b7e:	4631      	mov	r1, r6
 8023b80:	f000 fe2c 	bl	80247dc <protocol_send_header>
			protocol_send_payload(message, offset);
 8023b84:	4620      	mov	r0, r4
 8023b86:	4631      	mov	r1, r6
 8023b88:	f000 fe3c 	bl	8024804 <protocol_send_payload>
			protocol_send_tail();
 8023b8c:	f000 fe3c 	bl	8024808 <protocol_send_tail>

			return RADAR_ERR_OK;
 8023b90:	2000      	movs	r0, #0
 8023b92:	e7d6      	b.n	8023b42 <ep_radar_mcu_base_handle_message+0x36>
		}
		break;
	case MSG_CONSUMPTION_IND:
		if (num_bytes == 5)
 8023b94:	2a05      	cmp	r2, #5
 8023b96:	d1d2      	bne.n	8023b3e <ep_radar_mcu_base_handle_message+0x32>
}

static inline uint32_t rd_payload_u32(const uint8_t* payload, size_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
 8023b98:	78cb      	ldrb	r3, [r1, #3]
                      ((uint32_t)payload[offset    ]));
}

static inline uint32_t rd_payload_u32(const uint8_t* payload, size_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
 8023b9a:	790c      	ldrb	r4, [r1, #4]
           (((uint32_t)payload[offset + 2]) << 16) |
           (((uint32_t)payload[offset + 1]) <<  8) |
            ((uint32_t)payload[offset    ]);
 8023b9c:	784a      	ldrb	r2, [r1, #1]

static inline uint32_t rd_payload_u32(const uint8_t* payload, size_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
           (((uint32_t)payload[offset + 1]) <<  8) |
 8023b9e:	7888      	ldrb	r0, [r1, #2]
}

static inline uint32_t rd_payload_u32(const uint8_t* payload, size_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
 8023ba0:	041b      	lsls	r3, r3, #16
                      ((uint32_t)payload[offset    ]));
}

static inline uint32_t rd_payload_u32(const uint8_t* payload, size_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
 8023ba2:	ea43 6304 	orr.w	r3, r3, r4, lsl #24
 8023ba6:	4313      	orrs	r3, r2
		{
			uint16_t in_offset = 1;
			uint32_t repeat_count = rd_payload_u32(message_data, in_offset);
			set_consumption_repeat_count(repeat_count);
 8023ba8:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
 8023bac:	f7fd f870 	bl	8020c90 <set_consumption_repeat_count>
			return RADAR_ERR_OK;
 8023bb0:	2000      	movs	r0, #0
 8023bb2:	e7c6      	b.n	8023b42 <ep_radar_mcu_base_handle_message+0x36>
		}
		break;

	case MSG_RF_SHIELD_ID_IND:
		if (num_bytes == 1)
 8023bb4:	2a01      	cmp	r2, #1
 8023bb6:	d1c2      	bne.n	8023b3e <ep_radar_mcu_base_handle_message+0x32>
		{
			/* we received a request to provide the detected RF shield id */

			static uint8_t message[200]; // allocate statically, rather then on the call stack!
			memset(message, 0, sizeof(message));
 8023bb8:	4830      	ldr	r0, [pc, #192]	; (8023c7c <ep_radar_mcu_base_handle_message+0x170>)
 8023bba:	2100      	movs	r1, #0
 8023bbc:	22c8      	movs	r2, #200	; 0xc8
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8023bbe:	4607      	mov	r7, r0
 8023bc0:	f009 fcd1 	bl	802d566 <memset>

			/* get rf board id variant */
			uint32_t index = ds_get_board_variant();
 8023bc4:	f7fc fa1c 	bl	8020000 <ds_get_board_variant>

			if (index == 0 || index > sizeof(rf_shield_info) / sizeof(rf_shield_info[0]) + 1 )
 8023bc8:	3801      	subs	r0, #1
 8023bca:	2803      	cmp	r0, #3
 8023bcc:	bf28      	it	cs
 8023bce:	2000      	movcs	r0, #0

			uint32_t offset = 0;
			offset += wr_payload_u8(message, offset, MSG_RF_SHIELD_ID_RES);
			offset += wr_payload_u8(message, offset, p_board_info->major_version);
			offset += wr_payload_u8(message, offset, p_board_info->minor_version);
			offset += wr_payload_string(message, offset, p_info->rf_shield_board_id);
 8023bd0:	4b2b      	ldr	r3, [pc, #172]	; (8023c80 <ep_radar_mcu_base_handle_message+0x174>)
 8023bd2:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8023bd6:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 8023bda:	23e1      	movs	r3, #225	; 0xe1
 8023bdc:	703b      	strb	r3, [r7, #0]
 8023bde:	2400      	movs	r4, #0
 8023be0:	2302      	movs	r3, #2
 8023be2:	707b      	strb	r3, [r7, #1]
 8023be4:	6882      	ldr	r2, [r0, #8]
 8023be6:	70bc      	strb	r4, [r7, #2]
 8023be8:	2103      	movs	r1, #3
 8023bea:	4638      	mov	r0, r7
 8023bec:	f000 fe5e 	bl	80248ac <wr_payload_string>
 8023bf0:	1cc6      	adds	r6, r0, #3
			offset += wr_payload_string(message, offset, p_board_info->description);
 8023bf2:	4a24      	ldr	r2, [pc, #144]	; (8023c84 <ep_radar_mcu_base_handle_message+0x178>)
 8023bf4:	4631      	mov	r1, r6
 8023bf6:	4638      	mov	r0, r7
 8023bf8:	f000 fe58 	bl	80248ac <wr_payload_string>
 8023bfc:	4430      	add	r0, r6

			/* send message */
			protocol_send_header(endpoint, offset);
 8023bfe:	b286      	uxth	r6, r0
 8023c00:	4631      	mov	r1, r6
 8023c02:	4628      	mov	r0, r5
 8023c04:	f000 fdea 	bl	80247dc <protocol_send_header>
			protocol_send_payload(message, offset);
 8023c08:	4638      	mov	r0, r7
 8023c0a:	4631      	mov	r1, r6
 8023c0c:	f000 fdfa 	bl	8024804 <protocol_send_payload>
			protocol_send_tail();
 8023c10:	f000 fdfa 	bl	8024808 <protocol_send_tail>
			return RADAR_ERR_OK;
 8023c14:	4620      	mov	r0, r4
 8023c16:	e794      	b.n	8023b42 <ep_radar_mcu_base_handle_message+0x36>
		}
		break;

	case MSG_STORE_PARAMETER_IND:
		if (num_bytes == 1)
 8023c18:	2a01      	cmp	r2, #1
 8023c1a:	d190      	bne.n	8023b3e <ep_radar_mcu_base_handle_message+0x32>
		{
			/* we received a request to store the Parameter persistent */
			static uint8_t message[10]; // allocate statically, rather then on the call stack!
			memset(message, 0, sizeof(message));
 8023c1c:	4e1a      	ldr	r6, [pc, #104]	; (8023c88 <ep_radar_mcu_base_handle_message+0x17c>)
 8023c1e:	9201      	str	r2, [sp, #4]
 8023c20:	2400      	movs	r4, #0
 8023c22:	8134      	strh	r4, [r6, #8]
 8023c24:	6034      	str	r4, [r6, #0]
 8023c26:	6074      	str	r4, [r6, #4]

			/* store the parameters persistent */
			ds_hw_para_store_persistent();
 8023c28:	f7fc fcc8 	bl	80205bc <ds_hw_para_store_persistent>
			ds_algo_para_store_persistent();
 8023c2c:	f7fc fc9a 	bl	8020564 <ds_algo_para_store_persistent>

			uint16_t offset = 0;
			offset += wr_payload_u8(message, 0, MSG_STORE_PARAMETER_RES);

			/* send message */
			protocol_send_header(endpoint, offset);
 8023c30:	9a01      	ldr	r2, [sp, #4]
 8023c32:	23e3      	movs	r3, #227	; 0xe3
 8023c34:	4628      	mov	r0, r5
 8023c36:	4611      	mov	r1, r2
 8023c38:	7033      	strb	r3, [r6, #0]
			/* restore parameter from factory settings! */
			ds_hw_para_factory_reset();
			ds_algo_para_factory_reset();

			/* send message */
			protocol_send_header(endpoint, offset);
 8023c3a:	f000 fdcf 	bl	80247dc <protocol_send_header>
			protocol_send_payload(message, offset);
 8023c3e:	9a01      	ldr	r2, [sp, #4]
 8023c40:	4630      	mov	r0, r6
 8023c42:	4611      	mov	r1, r2
 8023c44:	f000 fdde 	bl	8024804 <protocol_send_payload>
			protocol_send_tail();
 8023c48:	f000 fdde 	bl	8024808 <protocol_send_tail>
			return RADAR_ERR_OK;
 8023c4c:	4620      	mov	r0, r4
 8023c4e:	e778      	b.n	8023b42 <ep_radar_mcu_base_handle_message+0x36>
	case MSG_PARA_FACTORY_RESET_IND:
		if (num_bytes == 1)
		{
			/* we received a request to store the Parameter persistent */
			static uint8_t message[10]; // allocate statically, rather then on the call stack!
			memset(message, 0, sizeof(message));
 8023c50:	4e0e      	ldr	r6, [pc, #56]	; (8023c8c <ep_radar_mcu_base_handle_message+0x180>)
 8023c52:	9201      	str	r2, [sp, #4]
 8023c54:	21e5      	movs	r1, #229	; 0xe5
 8023c56:	2400      	movs	r4, #0
 8023c58:	6034      	str	r4, [r6, #0]
 8023c5a:	6074      	str	r4, [r6, #4]
 8023c5c:	7031      	strb	r1, [r6, #0]
 8023c5e:	8134      	strh	r4, [r6, #8]

			uint16_t offset = 0;
			offset += wr_payload_u8(message, 0, MSG_PARA_FACTORY_RESET_RES);

			/* restore parameter from factory settings! */
			ds_hw_para_factory_reset();
 8023c60:	f7fc fc8c 	bl	802057c <ds_hw_para_factory_reset>
			ds_algo_para_factory_reset();
 8023c64:	f7fc fc66 	bl	8020534 <ds_algo_para_factory_reset>

			/* send message */
			protocol_send_header(endpoint, offset);
 8023c68:	9a01      	ldr	r2, [sp, #4]
 8023c6a:	4628      	mov	r0, r5
 8023c6c:	4611      	mov	r1, r2
 8023c6e:	e7e4      	b.n	8023c3a <ep_radar_mcu_base_handle_message+0x12e>
			uint32_t offset = 0;
			para_consumption_def_t *p_consumption_def_list = radar_get_consumption_labels();
			if (p_consumption_def_list == NULL)
			{
				para_consumption_def_t empty_def = {.num_labels = 0};
				p_consumption_def_list = &empty_def;
 8023c70:	a802      	add	r0, sp, #8
 8023c72:	e775      	b.n	8023b60 <ep_radar_mcu_base_handle_message+0x54>
 8023c74:	1ffe99e1 	.word	0x1ffe99e1
 8023c78:	1ffe99e4 	.word	0x1ffe99e4
 8023c7c:	1ffe9be4 	.word	0x1ffe9be4
 8023c80:	1ffe90ac 	.word	0x1ffe90ac
 8023c84:	0802f300 	.word	0x0802f300
 8023c88:	1ffe9cac 	.word	0x1ffe9cac
 8023c8c:	1ffe9cb8 	.word	0x1ffe9cb8

08023c90 <ep_radar_mcu_base_handle_change>:
{
	Radar_Handle_t radar_driver = (Radar_Handle_t)context;

	(void)radar_driver; /* Suppress compiler warnings of unused variable */

	switch (what)
 8023c90:	2a14      	cmp	r2, #20
 8023c92:	d000      	beq.n	8023c96 <ep_radar_mcu_base_handle_change+0x6>
 8023c94:	4770      	bx	lr
}

//============================================================================

void ep_radar_mcu_base_handle_change(uint8_t endpoint, void* context, uint32_t what)
{
 8023c96:	b508      	push	{r3, lr}

	switch (what)
	{

	case EP_RADAR_CHNG_CURRENT_CONSUMPTION:
		inc_consumption_repeat_count(1);
 8023c98:	2001      	movs	r0, #1
 8023c9a:	f7fc ffff 	bl	8020c9c <inc_consumption_repeat_count>
		mcu_base_updates();
		break;
	default:
		break;
	}
}
 8023c9e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	switch (what)
	{

	case EP_RADAR_CHNG_CURRENT_CONSUMPTION:
		inc_consumption_repeat_count(1);
		mcu_base_updates();
 8023ca2:	f7fd b803 	b.w	8020cac <mcu_base_updates>
 8023ca6:	bf00      	nop

08023ca8 <send_result_response>:
   6. EXPORTED FUNCTIONS
==============================================================================
 */

void send_result_response(uint8_t endpoint, pulse_result_response_t *p_pulse_result)
{
 8023ca8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	static uint32_t result_cnt = 0; // zero init at startup!
	static uint8_t message[sizeof(pulse_result_response_t)+20];
	int16_t offset = 0;

	offset += wr_payload_u8(message, offset, MSG_RESULT_RES);
	offset += wr_payload_u32(message, offset, result_cnt);
 8023cac:	4e26      	ldr	r6, [pc, #152]	; (8023d48 <send_result_response+0xa0>)
 8023cae:	4d27      	ldr	r5, [pc, #156]	; (8023d4c <send_result_response+0xa4>)
 8023cb0:	6833      	ldr	r3, [r6, #0]
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 8023cb2:	706b      	strb	r3, [r5, #1]
   6. EXPORTED FUNCTIONS
==============================================================================
 */

void send_result_response(uint8_t endpoint, pulse_result_response_t *p_pulse_result)
{
 8023cb4:	4688      	mov	r8, r1
}

static inline size_t wr_payload_u32(uint8_t* payload, size_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8023cb6:	0e1c      	lsrs	r4, r3, #24
    payload[offset + 2] = (value >> 16) & 0xFF;
 8023cb8:	0c1a      	lsrs	r2, r3, #16
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8023cba:	2136      	movs	r1, #54	; 0x36
static inline size_t wr_payload_u32(uint8_t* payload, size_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
 8023cbc:	0a1b      	lsrs	r3, r3, #8
}

static inline size_t wr_payload_u32(uint8_t* payload, size_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8023cbe:	712c      	strb	r4, [r5, #4]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8023cc0:	7029      	strb	r1, [r5, #0]

static inline size_t wr_payload_u32(uint8_t* payload, size_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
 8023cc2:	70ea      	strb	r2, [r5, #3]
    payload[offset + 1] = (value >>  8) & 0xFF;
 8023cc4:	70ab      	strb	r3, [r5, #2]
	static uint8_t message[sizeof(pulse_result_response_t)+20];
	int16_t offset = 0;

	offset += wr_payload_u8(message, offset, MSG_RESULT_RES);
	offset += wr_payload_u32(message, offset, result_cnt);
	offset += wr_payload_u32(message, offset, p_pulse_result->frame_count);
 8023cc6:	f8d8 3000 	ldr.w	r3, [r8]
    payload[offset    ] =  value        & 0xFF;
 8023cca:	716b      	strb	r3, [r5, #5]
}

static inline size_t wr_payload_u32(uint8_t* payload, size_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8023ccc:	0e19      	lsrs	r1, r3, #24
    payload[offset + 2] = (value >> 16) & 0xFF;
 8023cce:	0c1a      	lsrs	r2, r3, #16
    payload[offset + 1] = (value >>  8) & 0xFF;
 8023cd0:	0a1b      	lsrs	r3, r3, #8
 8023cd2:	71ab      	strb	r3, [r5, #6]
}

static inline size_t wr_payload_u32(uint8_t* payload, size_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8023cd4:	7229      	strb	r1, [r5, #8]
    payload[offset + 2] = (value >> 16) & 0xFF;
 8023cd6:	71ea      	strb	r2, [r5, #7]
   6. EXPORTED FUNCTIONS
==============================================================================
 */

void send_result_response(uint8_t endpoint, pulse_result_response_t *p_pulse_result)
{
 8023cd8:	4607      	mov	r7, r0
	int16_t offset = 0;

	offset += wr_payload_u8(message, offset, MSG_RESULT_RES);
	offset += wr_payload_u32(message, offset, result_cnt);
	offset += wr_payload_u32(message, offset, p_pulse_result->frame_count);
	offset += wr_payload_float(message, offset, p_pulse_result->velocity_mps);
 8023cda:	f8d8 2004 	ldr.w	r2, [r8, #4]
 8023cde:	2109      	movs	r1, #9
 8023ce0:	4628      	mov	r0, r5
 8023ce2:	f000 fdd5 	bl	8024890 <wr_payload_float>
 8023ce6:	3009      	adds	r0, #9
 8023ce8:	b284      	uxth	r4, r0
	offset += wr_payload_float(message, offset, p_pulse_result->level_nu);
 8023cea:	b221      	sxth	r1, r4
 8023cec:	f8d8 2008 	ldr.w	r2, [r8, #8]
 8023cf0:	4628      	mov	r0, r5
 8023cf2:	f000 fdcd 	bl	8024890 <wr_payload_float>
 8023cf6:	4420      	add	r0, r4
 8023cf8:	b280      	uxth	r0, r0
	offset += wr_payload_u8(message, offset, p_pulse_result->target_departing_bool);
 8023cfa:	b203      	sxth	r3, r0
 8023cfc:	f898 200c 	ldrb.w	r2, [r8, #12]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8023d00:	54ea      	strb	r2, [r5, r3]
 8023d02:	1c43      	adds	r3, r0, #1
	offset += wr_payload_u8(message, offset, p_pulse_result->target_approaching_bool);
 8023d04:	b21b      	sxth	r3, r3
 8023d06:	f898 200d 	ldrb.w	r2, [r8, #13]
 8023d0a:	54ea      	strb	r2, [r5, r3]
 8023d0c:	1c83      	adds	r3, r0, #2
	offset += wr_payload_u8(message, offset, p_pulse_result->motion_detected_bool);
 8023d0e:	b21b      	sxth	r3, r3
 8023d10:	f898 200e 	ldrb.w	r2, [r8, #14]
 8023d14:	54ea      	strb	r2, [r5, r3]
 8023d16:	3003      	adds	r0, #3
 8023d18:	b284      	uxth	r4, r0
	offset += wr_payload_float(message, offset, p_pulse_result->doppler_frequency_hz);
 8023d1a:	f8d8 2010 	ldr.w	r2, [r8, #16]
 8023d1e:	b221      	sxth	r1, r4
 8023d20:	4628      	mov	r0, r5
 8023d22:	f000 fdb5 	bl	8024890 <wr_payload_float>
 8023d26:	4420      	add	r0, r4
 8023d28:	b284      	uxth	r4, r0

	/* send message */
	protocol_send_header(endpoint, offset);
 8023d2a:	4621      	mov	r1, r4
 8023d2c:	4638      	mov	r0, r7
 8023d2e:	f000 fd55 	bl	80247dc <protocol_send_header>
	protocol_send_payload(message, offset);
 8023d32:	4628      	mov	r0, r5
 8023d34:	4621      	mov	r1, r4
 8023d36:	f000 fd65 	bl	8024804 <protocol_send_payload>
	protocol_send_tail();
 8023d3a:	f000 fd65 	bl	8024808 <protocol_send_tail>

	result_cnt += 1;
 8023d3e:	6833      	ldr	r3, [r6, #0]
 8023d40:	3301      	adds	r3, #1
 8023d42:	6033      	str	r3, [r6, #0]
 8023d44:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8023d48:	1ffeb1ec 	.word	0x1ffeb1ec
 8023d4c:	1ffe9ec4 	.word	0x1ffe9ec4

08023d50 <send_parameter_values>:

//============================================================================


void send_parameter_values(uint8_t endpoint, pulse_para_values_t *p_para)
{
 8023d50:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8023d52:	4d27      	ldr	r5, [pc, #156]	; (8023df0 <send_parameter_values+0xa0>)
 8023d54:	2331      	movs	r3, #49	; 0x31
 8023d56:	702b      	strb	r3, [r5, #0]
 8023d58:	460f      	mov	r7, r1
 8023d5a:	4606      	mov	r6, r0
	size_t offset = 0;
	static uint8_t message[256];

	offset += wr_payload_u8(message,    offset, MSG_PARA_VALUES_RES);
	offset += wr_payload_float(message, offset, p_para->max_speed_mps);
 8023d5c:	680a      	ldr	r2, [r1, #0]
 8023d5e:	4628      	mov	r0, r5
 8023d60:	2101      	movs	r1, #1
 8023d62:	f000 fd95 	bl	8024890 <wr_payload_float>
 8023d66:	1c44      	adds	r4, r0, #1
	offset += wr_payload_float(message, offset, p_para->min_speed_mps);
 8023d68:	4621      	mov	r1, r4
 8023d6a:	687a      	ldr	r2, [r7, #4]
 8023d6c:	4628      	mov	r0, r5
 8023d6e:	f000 fd8f 	bl	8024890 <wr_payload_float>
 8023d72:	4404      	add	r4, r0
	offset += wr_payload_float(message, offset, p_para->frame_time_sec);
 8023d74:	4621      	mov	r1, r4
 8023d76:	68ba      	ldr	r2, [r7, #8]
 8023d78:	4628      	mov	r0, r5
 8023d7a:	f000 fd89 	bl	8024890 <wr_payload_float>

	offset += wr_payload_u16(message,   offset, p_para->number_of_samples_nu);
 8023d7e:	89bb      	ldrh	r3, [r7, #12]
	static uint8_t message[256];

	offset += wr_payload_u8(message,    offset, MSG_PARA_VALUES_RES);
	offset += wr_payload_float(message, offset, p_para->max_speed_mps);
	offset += wr_payload_float(message, offset, p_para->min_speed_mps);
	offset += wr_payload_float(message, offset, p_para->frame_time_sec);
 8023d80:	4420      	add	r0, r4
}

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 8023d82:	182a      	adds	r2, r5, r0
 8023d84:	0a19      	lsrs	r1, r3, #8
 8023d86:	7051      	strb	r1, [r2, #1]

	offset += wr_payload_u16(message,   offset, p_para->number_of_samples_nu);
 8023d88:	1c84      	adds	r4, r0, #2
    payload[offset    ] =  value        & 0xFF;
 8023d8a:	542b      	strb	r3, [r5, r0]
	offset += wr_payload_float(message, offset, p_para->sampling_freq_hz);
 8023d8c:	693a      	ldr	r2, [r7, #16]
 8023d8e:	4621      	mov	r1, r4
 8023d90:	4628      	mov	r0, r5
 8023d92:	f000 fd7d 	bl	8024890 <wr_payload_float>
 8023d96:	4404      	add	r4, r0
	offset += wr_payload_float(message, offset, p_para->doppler_sensitivity_nu);
 8023d98:	4621      	mov	r1, r4
 8023d9a:	697a      	ldr	r2, [r7, #20]
 8023d9c:	4628      	mov	r0, r5
 8023d9e:	f000 fd77 	bl	8024890 <wr_payload_float>
 8023da2:	4404      	add	r4, r0
	offset += wr_payload_float(message, offset, p_para->motion_sensitivity_nu);
 8023da4:	4621      	mov	r1, r4
 8023da6:	69ba      	ldr	r2, [r7, #24]
 8023da8:	4628      	mov	r0, r5
 8023daa:	f000 fd71 	bl	8024890 <wr_payload_float>
 8023dae:	4420      	add	r0, r4

	offset += wr_payload_u8(message,    offset, p_para->use_high_gain_doppler_bool);
 8023db0:	7f3b      	ldrb	r3, [r7, #28]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8023db2:	542b      	strb	r3, [r5, r0]
 8023db4:	182b      	adds	r3, r5, r0
	offset += wr_payload_u8(message,    offset, p_para->continuous_mode_bool);
 8023db6:	7f7a      	ldrb	r2, [r7, #29]
 8023db8:	705a      	strb	r2, [r3, #1]
	offset += wr_payload_u16(message,   offset, p_para->number_of_skip_samples_nu);
 8023dba:	8bfa      	ldrh	r2, [r7, #30]

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 8023dbc:	709a      	strb	r2, [r3, #2]
}

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 8023dbe:	0a12      	lsrs	r2, r2, #8
 8023dc0:	70da      	strb	r2, [r3, #3]
	offset += wr_payload_u32(message,   offset, p_para->pulse_width_usec);
 8023dc2:	6a3a      	ldr	r2, [r7, #32]
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 8023dc4:	711a      	strb	r2, [r3, #4]
 8023dc6:	3008      	adds	r0, #8

	/* send message */
	protocol_send_header(endpoint, offset);
 8023dc8:	b284      	uxth	r4, r0
}

static inline size_t wr_payload_u32(uint8_t* payload, size_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8023dca:	0e17      	lsrs	r7, r2, #24
 8023dcc:	4630      	mov	r0, r6
    payload[offset + 2] = (value >> 16) & 0xFF;
 8023dce:	0c16      	lsrs	r6, r2, #16
    payload[offset + 1] = (value >>  8) & 0xFF;
 8023dd0:	0a12      	lsrs	r2, r2, #8
 8023dd2:	4621      	mov	r1, r4
}

static inline size_t wr_payload_u32(uint8_t* payload, size_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8023dd4:	71df      	strb	r7, [r3, #7]
    payload[offset + 2] = (value >> 16) & 0xFF;
 8023dd6:	719e      	strb	r6, [r3, #6]
    payload[offset + 1] = (value >>  8) & 0xFF;
 8023dd8:	715a      	strb	r2, [r3, #5]
 8023dda:	f000 fcff 	bl	80247dc <protocol_send_header>
	protocol_send_payload(message, offset);
 8023dde:	4628      	mov	r0, r5
 8023de0:	4621      	mov	r1, r4
 8023de2:	f000 fd0f 	bl	8024804 <protocol_send_payload>
	protocol_send_tail();
}
 8023de6:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	offset += wr_payload_u32(message,   offset, p_para->pulse_width_usec);

	/* send message */
	protocol_send_header(endpoint, offset);
	protocol_send_payload(message, offset);
	protocol_send_tail();
 8023dea:	f000 bd0d 	b.w	8024808 <protocol_send_tail>
 8023dee:	bf00      	nop
 8023df0:	1ffe9eec 	.word	0x1ffe9eec

08023df4 <send_pulse_frame_data>:
}

//============================================================================

void send_pulse_frame_data(uint8_t endpoint, acq_buf_obj *p_acq_buf, device_settings_t *p_dev)
{
 8023df4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8023df8:	b091      	sub	sp, #68	; 0x44

	Frame_Info_t frame_info;

	frame_info.num_rx_antennas       = BSP_NUM_RX_ANTENNAS;
	frame_info.num_chirps            = p_acq_buf->params.num_of_chirps_per_frame;
	frame_info.rx_mask               = p_dev->rx_antenna_mask;
 8023dfa:	f892 3028 	ldrb.w	r3, [r2, #40]	; 0x28
	static uint8_t transport_buffer[BSP_MAX_ADC_BUFFER_SIZE_BYTES];

	Frame_Info_t frame_info;

	frame_info.num_rx_antennas       = BSP_NUM_RX_ANTENNAS;
	frame_info.num_chirps            = p_acq_buf->params.num_of_chirps_per_frame;
 8023dfe:	888a      	ldrh	r2, [r1, #4]
 8023e00:	9205      	str	r2, [sp, #20]
	frame_info.rx_mask               = p_dev->rx_antenna_mask;
	frame_info.adc_resolution        = 12;
	frame_info.interleaved_rx        = 0;
	frame_info.frame_number          = p_acq_buf->frame_counter;
	frame_info.data_format           = RADAR_RX_DATA_COMPLEX;
	frame_info.num_samples_per_chirp = p_acq_buf->params.num_of_samples_per_chirp;
 8023e02:	884a      	ldrh	r2, [r1, #2]
 8023e04:	9208      	str	r2, [sp, #32]
	frame_info.num_rx_antennas       = BSP_NUM_RX_ANTENNAS;
	frame_info.num_chirps            = p_acq_buf->params.num_of_chirps_per_frame;
	frame_info.rx_mask               = p_dev->rx_antenna_mask;
	frame_info.adc_resolution        = 12;
	frame_info.interleaved_rx        = 0;
	frame_info.frame_number          = p_acq_buf->frame_counter;
 8023e06:	6b4d      	ldr	r5, [r1, #52]	; 0x34
 8023e08:	9a05      	ldr	r2, [sp, #20]

	Frame_Info_t frame_info;

	frame_info.num_rx_antennas       = BSP_NUM_RX_ANTENNAS;
	frame_info.num_chirps            = p_acq_buf->params.num_of_chirps_per_frame;
	frame_info.rx_mask               = p_dev->rx_antenna_mask;
 8023e0a:	9301      	str	r3, [sp, #4]
}

//============================================================================

void send_pulse_frame_data(uint8_t endpoint, acq_buf_obj *p_acq_buf, device_settings_t *p_dev)
{
 8023e0c:	460c      	mov	r4, r1
 8023e0e:	9908      	ldr	r1, [sp, #32]
    payload[offset    ] =  value        & 0xFF;
 8023e10:	f88d 502d 	strb.w	r5, [sp, #45]	; 0x2d
	frame_info.frame_number          = p_acq_buf->frame_counter;
	frame_info.data_format           = RADAR_RX_DATA_COMPLEX;
	frame_info.num_samples_per_chirp = p_acq_buf->params.num_of_samples_per_chirp;

	/* Selection of Antenna to output is currently only supported for 12 Bit ADC resolution! */
	if (frame_info.rx_mask == 1)
 8023e14:	3b01      	subs	r3, #1
 8023e16:	fb01 f202 	mul.w	r2, r1, r2
 8023e1a:	2b01      	cmp	r3, #1
 8023e1c:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 8023e20:	bf94      	ite	ls
 8023e22:	2701      	movls	r7, #1
 8023e24:	2702      	movhi	r7, #2
 8023e26:	00d1      	lsls	r1, r2, #3
	num_samples = frame_info.num_chirps *
				  frame_info.num_samples_per_chirp *
				  num_used_ant *
				  (frame_info.data_format == RADAR_RX_DATA_REAL ? 1 : 2);

	data_size = num_samples * frame_info.adc_resolution;
 8023e28:	fb07 f101 	mul.w	r1, r7, r1
static inline size_t wr_payload_u32(uint8_t* payload, size_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
 8023e2c:	0a2a      	lsrs	r2, r5, #8
}

static inline size_t wr_payload_u32(uint8_t* payload, size_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8023e2e:	ea4f 6c15 	mov.w	ip, r5, lsr #24
    payload[offset + 2] = (value >> 16) & 0xFF;
 8023e32:	ea4f 4e15 	mov.w	lr, r5, lsr #16
    payload[offset + 1] = (value >>  8) & 0xFF;
 8023e36:	9b05      	ldr	r3, [sp, #20]
 8023e38:	9d08      	ldr	r5, [sp, #32]
    payload[offset    ] =  value        & 0xFF;
 8023e3a:	f8dd 8020 	ldr.w	r8, [sp, #32]
 8023e3e:	f8dd a014 	ldr.w	sl, [sp, #20]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8023e42:	f88d 7035 	strb.w	r7, [sp, #53]	; 0x35
	data_size = (data_size >> 3) + ((data_size & 0x07) ? 1 : 0);
 8023e46:	08c9      	lsrs	r1, r1, #3
 8023e48:	f04f 0947 	mov.w	r9, #71	; 0x47

	/* send message header */
	protocol_send_header(endpoint, data_size + sizeof(message_header));
 8023e4c:	3112      	adds	r1, #18
}

static inline size_t wr_payload_u32(uint8_t* payload, size_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8023e4e:	2600      	movs	r6, #0
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
 8023e50:	0a1b      	lsrs	r3, r3, #8
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8023e52:	2701      	movs	r7, #1
 8023e54:	b289      	uxth	r1, r1
 8023e56:	f89d b004 	ldrb.w	fp, [sp, #4]
 8023e5a:	f88d 902c 	strb.w	r9, [sp, #44]	; 0x2c
static inline size_t wr_payload_u32(uint8_t* payload, size_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
 8023e5e:	0a2d      	lsrs	r5, r5, #8
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8023e60:	f04f 090c 	mov.w	r9, #12
static inline size_t wr_payload_u32(uint8_t* payload, size_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
 8023e64:	f88d 202e 	strb.w	r2, [sp, #46]	; 0x2e
 8023e68:	f88d 3032 	strb.w	r3, [sp, #50]	; 0x32
}

static inline size_t wr_payload_u32(uint8_t* payload, size_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8023e6c:	f88d c030 	strb.w	ip, [sp, #48]	; 0x30
    payload[offset + 2] = (value >> 16) & 0xFF;
 8023e70:	f88d e02f 	strb.w	lr, [sp, #47]	; 0x2f
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8023e74:	f88d 703b 	strb.w	r7, [sp, #59]	; 0x3b
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 8023e78:	f88d a031 	strb.w	sl, [sp, #49]	; 0x31
 8023e7c:	f88d 8036 	strb.w	r8, [sp, #54]	; 0x36
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8023e80:	f88d b03a 	strb.w	fp, [sp, #58]	; 0x3a
}

static inline size_t wr_payload_u32(uint8_t* payload, size_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8023e84:	f88d 6034 	strb.w	r6, [sp, #52]	; 0x34
    payload[offset + 2] = (value >> 16) & 0xFF;
 8023e88:	f88d 6033 	strb.w	r6, [sp, #51]	; 0x33
}

static inline size_t wr_payload_u32(uint8_t* payload, size_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8023e8c:	f88d 6039 	strb.w	r6, [sp, #57]	; 0x39
    payload[offset + 2] = (value >> 16) & 0xFF;
 8023e90:	f88d 6038 	strb.w	r6, [sp, #56]	; 0x38
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8023e94:	f88d 603d 	strb.w	r6, [sp, #61]	; 0x3d
static inline size_t wr_payload_u32(uint8_t* payload, size_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
 8023e98:	f88d 5037 	strb.w	r5, [sp, #55]	; 0x37
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8023e9c:	f88d 903c 	strb.w	r9, [sp, #60]	; 0x3c
 8023ea0:	f000 fc9c 	bl	80247dc <protocol_send_header>
	protocol_send_payload(message_header, sizeof(message_header));
 8023ea4:	2112      	movs	r1, #18
 8023ea6:	a80b      	add	r0, sp, #44	; 0x2c
 8023ea8:	f000 fcac 	bl	8024804 <protocol_send_payload>

	uint8_t *destPtr = &transport_buffer[0];
	uint8_t *srcPtr = p_acq_buf->p_acq_buf;

	uint32_t channel_inc = frame_info.num_samples_per_chirp * sizeof(uint16_t);
 8023eac:	fa08 f107 	lsl.w	r1, r8, r7
 8023eb0:	4643      	mov	r3, r8
 8023eb2:	9103      	str	r1, [sp, #12]
	uint32_t chirp_inc = channel_inc * frame_info.num_rx_antennas * (frame_info.data_format == RADAR_RX_DATA_REAL ? 1 : 2);

	uint32_t processed_out_bytes = 0;

	for (uint32_t chirp = 0; chirp < frame_info.num_chirps; chirp++)
 8023eb4:	4652      	mov	r2, sl

	uint8_t *destPtr = &transport_buffer[0];
	uint8_t *srcPtr = p_acq_buf->p_acq_buf;

	uint32_t channel_inc = frame_info.num_samples_per_chirp * sizeof(uint16_t);
	uint32_t chirp_inc = channel_inc * frame_info.num_rx_antennas * (frame_info.data_format == RADAR_RX_DATA_REAL ? 1 : 2);
 8023eb6:	00d9      	lsls	r1, r3, #3
	/* send message header */
	protocol_send_header(endpoint, data_size + sizeof(message_header));
	protocol_send_payload(message_header, sizeof(message_header));

	uint8_t *destPtr = &transport_buffer[0];
	uint8_t *srcPtr = p_acq_buf->p_acq_buf;
 8023eb8:	6ae7      	ldr	r7, [r4, #44]	; 0x2c

	uint32_t channel_inc = frame_info.num_samples_per_chirp * sizeof(uint16_t);
	uint32_t chirp_inc = channel_inc * frame_info.num_rx_antennas * (frame_info.data_format == RADAR_RX_DATA_REAL ? 1 : 2);
 8023eba:	9107      	str	r1, [sp, #28]

	uint32_t processed_out_bytes = 0;

	for (uint32_t chirp = 0; chirp < frame_info.num_chirps; chirp++)
 8023ebc:	2a00      	cmp	r2, #0
 8023ebe:	d057      	beq.n	8023f70 <send_pulse_frame_data+0x17c>
 8023ec0:	f1a8 0302 	sub.w	r3, r8, #2
 8023ec4:	085b      	lsrs	r3, r3, #1
 8023ec6:	3301      	adds	r3, #1
 8023ec8:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8023ecc:	9306      	str	r3, [sp, #24]
 8023ece:	b29b      	uxth	r3, r3
 8023ed0:	4641      	mov	r1, r8
 8023ed2:	9309      	str	r3, [sp, #36]	; 0x24
 8023ed4:	f008 0301 	and.w	r3, r8, #1
 8023ed8:	9302      	str	r3, [sp, #8]
 8023eda:	4c2b      	ldr	r4, [pc, #172]	; (8023f88 <send_pulse_frame_data+0x194>)
 8023edc:	008b      	lsls	r3, r1, #2
 8023ede:	3704      	adds	r7, #4
 8023ee0:	9304      	str	r3, [sp, #16]
 8023ee2:	46b9      	mov	r9, r7
 8023ee4:	2500      	movs	r5, #0
	{
		for (uint32_t ant_idx = 0; ant_idx < frame_info.num_rx_antennas; ant_idx++) // max Ant mask!
		{
			uint8_t mask = (1 << ant_idx);
 8023ee6:	2301      	movs	r3, #1
			if ((mask & frame_info.rx_mask) != 0)
 8023ee8:	9a01      	ldr	r2, [sp, #4]

	for (uint32_t chirp = 0; chirp < frame_info.num_chirps; chirp++)
	{
		for (uint32_t ant_idx = 0; ant_idx < frame_info.num_rx_antennas; ant_idx++) // max Ant mask!
		{
			uint8_t mask = (1 << ant_idx);
 8023eea:	40ab      	lsls	r3, r5
			if ((mask & frame_info.rx_mask) != 0)
 8023eec:	421a      	tst	r2, r3
 8023eee:	d036      	beq.n	8023f5e <send_pulse_frame_data+0x16a>
 */

static size_t packing_helper_12Bit(uint8_t *p_dest, uint16_t *p_src, size_t numSamples)
{
	/* numBytes needs to be divided by 2 */
	if ((numSamples & 1) != 0)
 8023ef0:	9b02      	ldr	r3, [sp, #8]
 8023ef2:	46c8      	mov	r8, r9
 8023ef4:	f04f 0a02 	mov.w	sl, #2
 8023ef8:	b18b      	cbz	r3, 8023f1e <send_pulse_frame_data+0x12a>
 8023efa:	f64f 71ff 	movw	r1, #65535	; 0xffff
		return -1;
 8023efe:	f04f 3bff 	mov.w	fp, #4294967295
 8023f02:	9b03      	ldr	r3, [sp, #12]
				for (uint32_t ch_idx = 0; ch_idx < num_chan_per_ant; ch_idx++)
				{
					uint32_t in_offset = (chirp_inc * chirp) + (channel_inc * (ant_idx * num_chan_per_ant + ch_idx));
					size_t out_offset = packing_helper_12Bit(destPtr, (uint16_t *)&srcPtr[in_offset], frame_info.num_samples_per_chirp);

					protocol_send_payload((uint8_t*)destPtr, out_offset);
 8023f04:	4620      	mov	r0, r4
 8023f06:	4498      	add	r8, r3
 8023f08:	f000 fc7c 	bl	8024804 <protocol_send_payload>
		{
			uint8_t mask = (1 << ant_idx);
			if ((mask & frame_info.rx_mask) != 0)
			{
				uint32_t num_chan_per_ant = (frame_info.data_format == RADAR_RX_DATA_REAL ? 1 : 2);
				for (uint32_t ch_idx = 0; ch_idx < num_chan_per_ant; ch_idx++)
 8023f0c:	f1ba 0f01 	cmp.w	sl, #1
					uint32_t in_offset = (chirp_inc * chirp) + (channel_inc * (ant_idx * num_chan_per_ant + ch_idx));
					size_t out_offset = packing_helper_12Bit(destPtr, (uint16_t *)&srcPtr[in_offset], frame_info.num_samples_per_chirp);

					protocol_send_payload((uint8_t*)destPtr, out_offset);

					destPtr += out_offset;
 8023f10:	445c      	add	r4, fp
		{
			uint8_t mask = (1 << ant_idx);
			if ((mask & frame_info.rx_mask) != 0)
			{
				uint32_t num_chan_per_ant = (frame_info.data_format == RADAR_RX_DATA_REAL ? 1 : 2);
				for (uint32_t ch_idx = 0; ch_idx < num_chan_per_ant; ch_idx++)
 8023f12:	d024      	beq.n	8023f5e <send_pulse_frame_data+0x16a>
 */

static size_t packing_helper_12Bit(uint8_t *p_dest, uint16_t *p_src, size_t numSamples)
{
	/* numBytes needs to be divided by 2 */
	if ((numSamples & 1) != 0)
 8023f14:	9b02      	ldr	r3, [sp, #8]
 8023f16:	f04f 0a01 	mov.w	sl, #1
 8023f1a:	2b00      	cmp	r3, #0
 8023f1c:	d1ed      	bne.n	8023efa <send_pulse_frame_data+0x106>
		return -1;

	size_t   processed_output_bytes = 0;

	while (numSamples >= 2)
 8023f1e:	9b08      	ldr	r3, [sp, #32]
 8023f20:	2b01      	cmp	r3, #1
 8023f22:	d92c      	bls.n	8023f7e <send_pulse_frame_data+0x18a>
 8023f24:	9b06      	ldr	r3, [sp, #24]
 8023f26:	4641      	mov	r1, r8
 8023f28:	eb04 0c03 	add.w	ip, r4, r3
 8023f2c:	4622      	mov	r2, r4
	{
		/* pack two samples into one 32 bit word */
		uint32_t packed_word;
		packed_word  = *p_src++;
		packed_word |= *p_src++ << 12;
 8023f2e:	f831 0c02 	ldrh.w	r0, [r1, #-2]

	while (numSamples >= 2)
	{
		/* pack two samples into one 32 bit word */
		uint32_t packed_word;
		packed_word  = *p_src++;
 8023f32:	f831 3c04 	ldrh.w	r3, [r1, #-4]
		packed_word |= *p_src++ << 12;
 8023f36:	ea43 3300 	orr.w	r3, r3, r0, lsl #12
}

static inline size_t wr_payload_u32(uint8_t* payload, size_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8023f3a:	0e18      	lsrs	r0, r3, #24
 8023f3c:	70d0      	strb	r0, [r2, #3]
    payload[offset + 2] = (value >> 16) & 0xFF;
 8023f3e:	ea4f 4e13 	mov.w	lr, r3, lsr #16
    payload[offset + 1] = (value >>  8) & 0xFF;
 8023f42:	0a18      	lsrs	r0, r3, #8

static inline size_t wr_payload_u32(uint8_t* payload, size_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
 8023f44:	f882 e002 	strb.w	lr, [r2, #2]
    payload[offset + 1] = (value >>  8) & 0xFF;
 8023f48:	7050      	strb	r0, [r2, #1]
    payload[offset    ] =  value        & 0xFF;
 8023f4a:	f802 3b03 	strb.w	r3, [r2], #3
	if ((numSamples & 1) != 0)
		return -1;

	size_t   processed_output_bytes = 0;

	while (numSamples >= 2)
 8023f4e:	4562      	cmp	r2, ip
 8023f50:	f101 0104 	add.w	r1, r1, #4
 8023f54:	d1eb      	bne.n	8023f2e <send_pulse_frame_data+0x13a>
		/* write packed word into buffer */
		wr_payload_u32(p_dest, 0, packed_word);
		p_dest += 3;

		numSamples -= 2;
		processed_output_bytes += 3;
 8023f56:	9b06      	ldr	r3, [sp, #24]
	if ((numSamples & 1) != 0)
		return -1;

	size_t   processed_output_bytes = 0;

	while (numSamples >= 2)
 8023f58:	9909      	ldr	r1, [sp, #36]	; 0x24

		numSamples -= 2;
		processed_output_bytes += 3;
	}

	return processed_output_bytes;
 8023f5a:	469b      	mov	fp, r3
 8023f5c:	e7d1      	b.n	8023f02 <send_pulse_frame_data+0x10e>
 8023f5e:	9b04      	ldr	r3, [sp, #16]
 8023f60:	4499      	add	r9, r3

	uint32_t processed_out_bytes = 0;

	for (uint32_t chirp = 0; chirp < frame_info.num_chirps; chirp++)
	{
		for (uint32_t ant_idx = 0; ant_idx < frame_info.num_rx_antennas; ant_idx++) // max Ant mask!
 8023f62:	b155      	cbz	r5, 8023f7a <send_pulse_frame_data+0x186>
 8023f64:	9b07      	ldr	r3, [sp, #28]
 8023f66:	441f      	add	r7, r3
	uint32_t channel_inc = frame_info.num_samples_per_chirp * sizeof(uint16_t);
	uint32_t chirp_inc = channel_inc * frame_info.num_rx_antennas * (frame_info.data_format == RADAR_RX_DATA_REAL ? 1 : 2);

	uint32_t processed_out_bytes = 0;

	for (uint32_t chirp = 0; chirp < frame_info.num_chirps; chirp++)
 8023f68:	9b05      	ldr	r3, [sp, #20]
 8023f6a:	3601      	adds	r6, #1
 8023f6c:	42b3      	cmp	r3, r6
 8023f6e:	d1b8      	bne.n	8023ee2 <send_pulse_frame_data+0xee>
				}
			}
		}
	}

	protocol_send_tail();
 8023f70:	f000 fc4a 	bl	8024808 <protocol_send_tail>
}
 8023f74:	b011      	add	sp, #68	; 0x44
 8023f76:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8023f7a:	2501      	movs	r5, #1
 8023f7c:	e7b3      	b.n	8023ee6 <send_pulse_frame_data+0xf2>
	if ((numSamples & 1) != 0)
		return -1;

	size_t   processed_output_bytes = 0;

	while (numSamples >= 2)
 8023f7e:	9b02      	ldr	r3, [sp, #8]
 8023f80:	4619      	mov	r1, r3

		numSamples -= 2;
		processed_output_bytes += 3;
	}

	return processed_output_bytes;
 8023f82:	469b      	mov	fp, r3
 8023f84:	e7bd      	b.n	8023f02 <send_pulse_frame_data+0x10e>
 8023f86:	bf00      	nop
 8023f88:	1ffea1ec 	.word	0x1ffea1ec

08023f8c <ep_radar_s2glpulse_handle_message>:

//============================================================================

uint16_t ep_radar_s2glpulse_handle_message(uint8_t endpoint, uint8_t *message_data,
										   uint16_t num_bytes, void* context)
{
 8023f8c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8023f90:	4604      	mov	r4, r0
	switch (message_data[0])
 8023f92:	7808      	ldrb	r0, [r1, #0]
 8023f94:	3830      	subs	r0, #48	; 0x30

//============================================================================

uint16_t ep_radar_s2glpulse_handle_message(uint8_t endpoint, uint8_t *message_data,
										   uint16_t num_bytes, void* context)
{
 8023f96:	b089      	sub	sp, #36	; 0x24
	switch (message_data[0])
 8023f98:	2816      	cmp	r0, #22
 8023f9a:	d81b      	bhi.n	8023fd4 <ep_radar_s2glpulse_handle_message+0x48>
 8023f9c:	e8df f010 	tbh	[pc, r0, lsl #1]
 8023fa0:	001a001f 	.word	0x001a001f
 8023fa4:	001a002a 	.word	0x001a002a
 8023fa8:	018100f3 	.word	0x018100f3
 8023fac:	001a001a 	.word	0x001a001a
 8023fb0:	001a001a 	.word	0x001a001a
 8023fb4:	001a001a 	.word	0x001a001a
 8023fb8:	001a001a 	.word	0x001a001a
 8023fbc:	001a001a 	.word	0x001a001a
 8023fc0:	001a019a 	.word	0x001a019a
 8023fc4:	001a001a 	.word	0x001a001a
 8023fc8:	001a001a 	.word	0x001a001a
 8023fcc:	0017      	.short	0x0017
			return RADAR_ERR_OK;
		}
		break;

	case MSG_GET_RAW_DATA_IND:
		if (num_bytes == 5)
 8023fce:	2a05      	cmp	r2, #5
 8023fd0:	f000 81cc 	beq.w	802436c <ep_radar_s2glpulse_handle_message+0x3e0>
		break;

	default:
		break;
	}
	return PROTOCOL_STATUS_INVALID_PAYLOAD;
 8023fd4:	f64f 70ff 	movw	r0, #65535	; 0xffff
}
 8023fd8:	b009      	add	sp, #36	; 0x24
 8023fda:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
										   uint16_t num_bytes, void* context)
{
	switch (message_data[0])
	{
	case MSG_PARA_VALUES_IND:
		if (num_bytes == 1)
 8023fde:	2a01      	cmp	r2, #1
 8023fe0:	d1f8      	bne.n	8023fd4 <ep_radar_s2glpulse_handle_message+0x48>
		{
			copyStore2comPara(&g_parameter_pulse);
 8023fe2:	48b9      	ldr	r0, [pc, #740]	; (80242c8 <ep_radar_s2glpulse_handle_message+0x33c>)
 8023fe4:	f7fc fed2 	bl	8020d8c <copyStore2comPara>
			send_parameter_values(endpoint, &g_parameter_pulse);
 8023fe8:	4620      	mov	r0, r4
 8023fea:	49b7      	ldr	r1, [pc, #732]	; (80242c8 <ep_radar_s2glpulse_handle_message+0x33c>)
 8023fec:	f7ff feb0 	bl	8023d50 <send_parameter_values>

			return RADAR_ERR_OK;
 8023ff0:	2000      	movs	r0, #0
 8023ff2:	e7f1      	b.n	8023fd8 <ep_radar_s2glpulse_handle_message+0x4c>
		}
		break;

	case MSG_PARA_VALUES_DEF_IND:
		if (num_bytes == 1)
 8023ff4:	2a01      	cmp	r2, #1
 8023ff6:	d1ed      	bne.n	8023fd4 <ep_radar_s2glpulse_handle_message+0x48>
		{
			static uint8_t message[512]; // allocate statically, rather then on the call stack!
			memset(message, 0, sizeof(message));
 8023ff8:	4db4      	ldr	r5, [pc, #720]	; (80242cc <ep_radar_s2glpulse_handle_message+0x340>)
			size_t offset = 0;

			offset += wr_payload_u8(message, 0, MSG_PARA_VALUES_DEF_RES);
			offset += sizeof(uint16_t); // size if uint16

			offset += wr_payload_float(message, offset, c_para_value_def_list.max_speed_mps_lower_boundary);
 8023ffa:	4fb5      	ldr	r7, [pc, #724]	; (80242d0 <ep_radar_s2glpulse_handle_message+0x344>)

	case MSG_PARA_VALUES_DEF_IND:
		if (num_bytes == 1)
		{
			static uint8_t message[512]; // allocate statically, rather then on the call stack!
			memset(message, 0, sizeof(message));
 8023ffc:	2100      	movs	r1, #0
 8023ffe:	f44f 7200 	mov.w	r2, #512	; 0x200
 8024002:	4628      	mov	r0, r5
 8024004:	f009 faaf 	bl	802d566 <memset>
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024008:	2333      	movs	r3, #51	; 0x33
 802400a:	702b      	strb	r3, [r5, #0]
			size_t offset = 0;

			offset += wr_payload_u8(message, 0, MSG_PARA_VALUES_DEF_RES);
			offset += sizeof(uint16_t); // size if uint16

			offset += wr_payload_float(message, offset, c_para_value_def_list.max_speed_mps_lower_boundary);
 802400c:	683a      	ldr	r2, [r7, #0]
 802400e:	2103      	movs	r1, #3
 8024010:	4628      	mov	r0, r5
 8024012:	f000 fc3d 	bl	8024890 <wr_payload_float>
 8024016:	1cc6      	adds	r6, r0, #3
			offset += wr_payload_float(message, offset, c_para_value_def_list.max_speed_mps_upper_boundary);
 8024018:	4631      	mov	r1, r6
 802401a:	687a      	ldr	r2, [r7, #4]
 802401c:	4628      	mov	r0, r5
 802401e:	f000 fc37 	bl	8024890 <wr_payload_float>
 8024022:	4406      	add	r6, r0
			offset += wr_payload_float(message, offset, c_para_value_def_list.min_speed_mps_lower_boundary);
 8024024:	4631      	mov	r1, r6
 8024026:	68ba      	ldr	r2, [r7, #8]
 8024028:	4628      	mov	r0, r5
 802402a:	f000 fc31 	bl	8024890 <wr_payload_float>
 802402e:	4406      	add	r6, r0
			offset += wr_payload_float(message, offset, c_para_value_def_list.min_speed_mps_upper_boundary);
 8024030:	4631      	mov	r1, r6
 8024032:	68fa      	ldr	r2, [r7, #12]
 8024034:	4628      	mov	r0, r5
 8024036:	f000 fc2b 	bl	8024890 <wr_payload_float>
 802403a:	4406      	add	r6, r0
			offset += wr_payload_float(message, offset, c_para_value_def_list.frame_time_sec_lower_boundary);
 802403c:	4631      	mov	r1, r6
 802403e:	693a      	ldr	r2, [r7, #16]
 8024040:	4628      	mov	r0, r5
 8024042:	f000 fc25 	bl	8024890 <wr_payload_float>
 8024046:	4406      	add	r6, r0
			offset += wr_payload_float(message, offset, c_para_value_def_list.frame_time_sec_upper_boundary);
 8024048:	4631      	mov	r1, r6
 802404a:	697a      	ldr	r2, [r7, #20]
 802404c:	4628      	mov	r0, r5
 802404e:	f000 fc1f 	bl	8024890 <wr_payload_float>

			uint8_t size_elems = sizeof(c_para_value_def_list.sample_list) / sizeof(uint16_t);
			offset += wr_payload_u8(message, offset, size_elems);
			for (int n = 0; n < size_elems; n++)
			{
				offset += wr_payload_u16(message, offset, c_para_value_def_list.sample_list[n]);
 8024052:	f8b7 c01c 	ldrh.w	ip, [r7, #28]
 8024056:	f8b7 e01e 	ldrh.w	lr, [r7, #30]
 802405a:	8b39      	ldrh	r1, [r7, #24]
 802405c:	f8b7 801a 	ldrh.w	r8, [r7, #26]
			}

			offset += wr_payload_float(message, offset, c_para_value_def_list.sampling_freq_hz_lower_boundary);
 8024060:	6a3a      	ldr	r2, [r7, #32]
			offset += wr_payload_float(message, offset, c_para_value_def_list.max_speed_mps_lower_boundary);
			offset += wr_payload_float(message, offset, c_para_value_def_list.max_speed_mps_upper_boundary);
			offset += wr_payload_float(message, offset, c_para_value_def_list.min_speed_mps_lower_boundary);
			offset += wr_payload_float(message, offset, c_para_value_def_list.min_speed_mps_upper_boundary);
			offset += wr_payload_float(message, offset, c_para_value_def_list.frame_time_sec_lower_boundary);
			offset += wr_payload_float(message, offset, c_para_value_def_list.frame_time_sec_upper_boundary);
 8024062:	4430      	add	r0, r6
}

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024064:	182b      	adds	r3, r5, r0
 8024066:	f100 0609 	add.w	r6, r0, #9
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 802406a:	f04f 0904 	mov.w	r9, #4
 802406e:	f805 9000 	strb.w	r9, [r5, r0]
}

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024072:	ea4f 2a1c 	mov.w	sl, ip, lsr #8
 8024076:	ea4f 291e 	mov.w	r9, lr, lsr #8
 802407a:	9601      	str	r6, [sp, #4]
 802407c:	ea4f 2b11 	mov.w	fp, r1, lsr #8
 8024080:	ea4f 2618 	mov.w	r6, r8, lsr #8
    payload[offset    ] =  value        & 0xFF;
 8024084:	f883 c005 	strb.w	ip, [r3, #5]
 8024088:	f883 e007 	strb.w	lr, [r3, #7]
 802408c:	7059      	strb	r1, [r3, #1]
}

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 802408e:	f883 b002 	strb.w	fp, [r3, #2]
    payload[offset    ] =  value        & 0xFF;
 8024092:	f883 8003 	strb.w	r8, [r3, #3]
}

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024096:	711e      	strb	r6, [r3, #4]
 8024098:	f883 a006 	strb.w	sl, [r3, #6]
 802409c:	f883 9008 	strb.w	r9, [r3, #8]
			for (int n = 0; n < size_elems; n++)
			{
				offset += wr_payload_u16(message, offset, c_para_value_def_list.sample_list[n]);
			}

			offset += wr_payload_float(message, offset, c_para_value_def_list.sampling_freq_hz_lower_boundary);
 80240a0:	9901      	ldr	r1, [sp, #4]
 80240a2:	4628      	mov	r0, r5
 80240a4:	f000 fbf4 	bl	8024890 <wr_payload_float>
 80240a8:	9b01      	ldr	r3, [sp, #4]
			offset += wr_payload_float(message, offset, c_para_value_def_list.sampling_freq_hz_upper_boundary);
 80240aa:	6a7a      	ldr	r2, [r7, #36]	; 0x24
			for (int n = 0; n < size_elems; n++)
			{
				offset += wr_payload_u16(message, offset, c_para_value_def_list.sample_list[n]);
			}

			offset += wr_payload_float(message, offset, c_para_value_def_list.sampling_freq_hz_lower_boundary);
 80240ac:	4403      	add	r3, r0
			offset += wr_payload_float(message, offset, c_para_value_def_list.sampling_freq_hz_upper_boundary);
 80240ae:	4619      	mov	r1, r3
 80240b0:	4628      	mov	r0, r5
			for (int n = 0; n < size_elems; n++)
			{
				offset += wr_payload_u16(message, offset, c_para_value_def_list.sample_list[n]);
			}

			offset += wr_payload_float(message, offset, c_para_value_def_list.sampling_freq_hz_lower_boundary);
 80240b2:	461e      	mov	r6, r3
			offset += wr_payload_float(message, offset, c_para_value_def_list.sampling_freq_hz_upper_boundary);
 80240b4:	f000 fbec 	bl	8024890 <wr_payload_float>
 80240b8:	4406      	add	r6, r0
			offset += wr_payload_float(message, offset, c_para_value_def_list.doppler_sensitivity_nu_lower_boundary);
 80240ba:	4631      	mov	r1, r6
 80240bc:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80240be:	4628      	mov	r0, r5
 80240c0:	f000 fbe6 	bl	8024890 <wr_payload_float>
 80240c4:	4406      	add	r6, r0
			offset += wr_payload_float(message, offset, c_para_value_def_list.doppler_sensitivity_nu_upper_boundary);
 80240c6:	4631      	mov	r1, r6
 80240c8:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 80240ca:	4628      	mov	r0, r5
 80240cc:	f000 fbe0 	bl	8024890 <wr_payload_float>
 80240d0:	4406      	add	r6, r0
			offset += wr_payload_float(message, offset, c_para_value_def_list.motion_sensitivity_nu_lower_boundary);
 80240d2:	4631      	mov	r1, r6
 80240d4:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 80240d6:	4628      	mov	r0, r5
 80240d8:	f000 fbda 	bl	8024890 <wr_payload_float>
 80240dc:	4406      	add	r6, r0
			offset += wr_payload_float(message, offset, c_para_value_def_list.motion_sensitivity_nu_upper_boundary);
 80240de:	4631      	mov	r1, r6
 80240e0:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80240e2:	4628      	mov	r0, r5
 80240e4:	f000 fbd4 	bl	8024890 <wr_payload_float>

			offset += wr_payload_u32(message, offset, c_para_value_def_list.number_of_skip_samples_nu_lower_boundary);
 80240e8:	f8d7 c038 	ldr.w	ip, [r7, #56]	; 0x38
			offset += wr_payload_u32(message, offset, c_para_value_def_list.number_of_skip_samples_nu_upper_boundary);
 80240ec:	f8d7 e03c 	ldr.w	lr, [r7, #60]	; 0x3c

			offset += wr_payload_u32(message, offset, c_para_value_def_list.pulse_width_usec_lower_boundary);
 80240f0:	6c39      	ldr	r1, [r7, #64]	; 0x40
			offset += wr_payload_float(message, offset, c_para_value_def_list.sampling_freq_hz_lower_boundary);
			offset += wr_payload_float(message, offset, c_para_value_def_list.sampling_freq_hz_upper_boundary);
			offset += wr_payload_float(message, offset, c_para_value_def_list.doppler_sensitivity_nu_lower_boundary);
			offset += wr_payload_float(message, offset, c_para_value_def_list.doppler_sensitivity_nu_upper_boundary);
			offset += wr_payload_float(message, offset, c_para_value_def_list.motion_sensitivity_nu_lower_boundary);
			offset += wr_payload_float(message, offset, c_para_value_def_list.motion_sensitivity_nu_upper_boundary);
 80240f2:	1833      	adds	r3, r6, r0
}

static inline size_t wr_payload_u32(uint8_t* payload, size_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 80240f4:	18ea      	adds	r2, r5, r3

			offset += wr_payload_u32(message, offset, c_para_value_def_list.number_of_skip_samples_nu_lower_boundary);
			offset += wr_payload_u32(message, offset, c_para_value_def_list.number_of_skip_samples_nu_upper_boundary);

			offset += wr_payload_u32(message, offset, c_para_value_def_list.pulse_width_usec_lower_boundary);
			offset += wr_payload_u32(message, offset, c_para_value_def_list.pulse_width_usec_upper_boundary);
 80240f6:	6c7e      	ldr	r6, [r7, #68]	; 0x44
 80240f8:	f103 0810 	add.w	r8, r3, #16
 80240fc:	ea4f 6a1c 	mov.w	sl, ip, lsr #24
    payload[offset + 2] = (value >> 16) & 0xFF;
 8024100:	ea4f 491c 	mov.w	r9, ip, lsr #16
}

static inline size_t wr_payload_u32(uint8_t* payload, size_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8024104:	f882 a003 	strb.w	sl, [r2, #3]
    payload[offset + 2] = (value >> 16) & 0xFF;
 8024108:	f882 9002 	strb.w	r9, [r2, #2]

			// write size values of the message!
			wr_payload_u16(message, 1, (uint16_t)offset);
 802410c:	fa1f f788 	uxth.w	r7, r8

			/* send message */
			protocol_send_header(endpoint, offset);
 8024110:	4620      	mov	r0, r4
}

static inline size_t wr_payload_u32(uint8_t* payload, size_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8024112:	ea4f 6b1e 	mov.w	fp, lr, lsr #24
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024116:	ea4f 241c 	mov.w	r4, ip, lsr #8

static inline size_t wr_payload_u32(uint8_t* payload, size_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
 802411a:	ea4f 4a1e 	mov.w	sl, lr, lsr #16
    payload[offset + 1] = (value >>  8) & 0xFF;
 802411e:	ea4f 291e 	mov.w	r9, lr, lsr #8
 8024122:	7054      	strb	r4, [r2, #1]
    payload[offset    ] =  value        & 0xFF;
 8024124:	f805 c003 	strb.w	ip, [r5, r3]
}

static inline size_t wr_payload_u32(uint8_t* payload, size_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8024128:	0e0c      	lsrs	r4, r1, #24
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 802412a:	f882 e004 	strb.w	lr, [r2, #4]
}

static inline size_t wr_payload_u32(uint8_t* payload, size_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 802412e:	f882 b007 	strb.w	fp, [r2, #7]
    payload[offset + 2] = (value >> 16) & 0xFF;
 8024132:	f882 a006 	strb.w	sl, [r2, #6]
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024136:	f882 9005 	strb.w	r9, [r2, #5]

static inline size_t wr_payload_u32(uint8_t* payload, size_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
 802413a:	0c0b      	lsrs	r3, r1, #16
    payload[offset + 1] = (value >>  8) & 0xFF;
 802413c:	ea4f 2c11 	mov.w	ip, r1, lsr #8
}

static inline size_t wr_payload_u32(uint8_t* payload, size_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8024140:	ea4f 6e16 	mov.w	lr, r6, lsr #24
    payload[offset + 2] = (value >> 16) & 0xFF;
 8024144:	ea4f 4b16 	mov.w	fp, r6, lsr #16
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024148:	ea4f 2a16 	mov.w	sl, r6, lsr #8
}

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 802414c:	ea4f 2917 	mov.w	r9, r7, lsr #8
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 8024150:	7211      	strb	r1, [r2, #8]
 8024152:	7316      	strb	r6, [r2, #12]
}

static inline size_t wr_payload_u32(uint8_t* payload, size_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 8024154:	72d4      	strb	r4, [r2, #11]
    payload[offset + 2] = (value >> 16) & 0xFF;
 8024156:	7293      	strb	r3, [r2, #10]
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024158:	f882 c009 	strb.w	ip, [r2, #9]
}

static inline size_t wr_payload_u32(uint8_t* payload, size_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 802415c:	f882 e00f 	strb.w	lr, [r2, #15]
    payload[offset + 2] = (value >> 16) & 0xFF;
 8024160:	f882 b00e 	strb.w	fp, [r2, #14]
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024164:	f882 a00d 	strb.w	sl, [r2, #13]
 8024168:	4639      	mov	r1, r7

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 802416a:	f885 8001 	strb.w	r8, [r5, #1]
}

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 802416e:	f885 9002 	strb.w	r9, [r5, #2]
 8024172:	f000 fb33 	bl	80247dc <protocol_send_header>
			protocol_send_payload(message, offset);
 8024176:	4628      	mov	r0, r5
 8024178:	4639      	mov	r1, r7
 802417a:	f000 fb43 	bl	8024804 <protocol_send_payload>
			protocol_send_tail();
 802417e:	f000 fb43 	bl	8024808 <protocol_send_tail>

			return RADAR_ERR_OK;
 8024182:	2000      	movs	r0, #0
 8024184:	e728      	b.n	8023fd8 <ep_radar_s2glpulse_handle_message+0x4c>
		}
		break;

	case MSG_PARA_SET_VALUES_IND:
		if (num_bytes == 35)
 8024186:	2a23      	cmp	r2, #35	; 0x23
 8024188:	f47f af24 	bne.w	8023fd4 <ep_radar_s2glpulse_handle_message+0x48>

	temp_union data;

	data.u32_value =
    		(((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
 802418c:	7c4a      	ldrb	r2, [r1, #17]
		} temp_union;

	temp_union data;

	data.u32_value =
    		(((uint32_t)payload[offset + 3]) << 24) |
 802418e:	f891 8012 	ldrb.w	r8, [r1, #18]
           (((uint32_t)payload[offset + 2]) << 16) |
           (((uint32_t)payload[offset + 1]) <<  8) |
            ((uint32_t)payload[offset    ]);
 8024192:	7bce      	ldrb	r6, [r1, #15]
	temp_union data;

	data.u32_value =
    		(((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
           (((uint32_t)payload[offset + 1]) <<  8) |
 8024194:	7988      	ldrb	r0, [r1, #6]
 8024196:	f891 e010 	ldrb.w	lr, [r1, #16]
		{
			size_t offset = 1; // skip id

			g_parameter_pulse.max_speed_mps = rd_payload_float(message_data, offset);
 802419a:	4d4b      	ldr	r5, [pc, #300]	; (80242c8 <ep_radar_s2glpulse_handle_message+0x33c>)
 802419c:	9003      	str	r0, [sp, #12]

	temp_union data;

	data.u32_value =
    		(((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
 802419e:	0412      	lsls	r2, r2, #16
		} temp_union;

	temp_union data;

	data.u32_value =
    		(((uint32_t)payload[offset + 3]) << 24) |
 80241a0:	ea42 6208 	orr.w	r2, r2, r8, lsl #24
           (((uint32_t)payload[offset + 2]) << 16) |
           (((uint32_t)payload[offset + 1]) <<  8) |
 80241a4:	7a88      	ldrb	r0, [r1, #10]

	temp_union data;

	data.u32_value =
    		(((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
 80241a6:	f891 c015 	ldrb.w	ip, [r1, #21]
 80241aa:	9307      	str	r3, [sp, #28]
 80241ac:	4332      	orrs	r2, r6
           (((uint32_t)payload[offset + 1]) <<  8) |
            ((uint32_t)payload[offset    ]);
 80241ae:	784b      	ldrb	r3, [r1, #1]
	temp_union data;

	data.u32_value =
    		(((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
           (((uint32_t)payload[offset + 1]) <<  8) |
 80241b0:	9004      	str	r0, [sp, #16]
			offset += sizeof(float);
			g_parameter_pulse.frame_time_sec = rd_payload_float(message_data, offset);
			offset += sizeof(float);
			g_parameter_pulse.number_of_samples_nu = rd_payload_u16(message_data, offset);
			offset += sizeof(uint16_t);
			g_parameter_pulse.sampling_freq_hz = rd_payload_float(message_data, offset);
 80241b2:	ea42 2e0e 	orr.w	lr, r2, lr, lsl #8
                      ((uint16_t)payload[offset    ]));
}

static inline uint16_t rd_payload_u16(const uint8_t* payload, size_t offset)
{
    return (((uint16_t)payload[offset + 1]) <<  8) |
 80241b6:	7b88      	ldrb	r0, [r1, #14]

	data.u32_value =
    		(((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
           (((uint32_t)payload[offset + 1]) <<  8) |
            ((uint32_t)payload[offset    ]);
 80241b8:	794a      	ldrb	r2, [r1, #5]
		} temp_union;

	temp_union data;

	data.u32_value =
    		(((uint32_t)payload[offset + 3]) << 24) |
 80241ba:	f891 b004 	ldrb.w	fp, [r1, #4]
           (((uint32_t)payload[offset + 2]) << 16) |
 80241be:	78cf      	ldrb	r7, [r1, #3]
		} temp_union;

	temp_union data;

	data.u32_value =
    		(((uint32_t)payload[offset + 3]) << 24) |
 80241c0:	f891 a008 	ldrb.w	sl, [r1, #8]
           (((uint32_t)payload[offset + 2]) << 16) |
 80241c4:	79ce      	ldrb	r6, [r1, #7]
		} temp_union;

	temp_union data;

	data.u32_value =
    		(((uint32_t)payload[offset + 3]) << 24) |
 80241c6:	f891 900c 	ldrb.w	r9, [r1, #12]
           (((uint32_t)payload[offset + 2]) << 16) |
           (((uint32_t)payload[offset + 1]) <<  8) |
            ((uint32_t)payload[offset    ]);
 80241ca:	f891 8009 	ldrb.w	r8, [r1, #9]
 80241ce:	9301      	str	r3, [sp, #4]
 80241d0:	9202      	str	r2, [sp, #8]
	temp_union data;

	data.u32_value =
    		(((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
           (((uint32_t)payload[offset + 1]) <<  8) |
 80241d2:	788b      	ldrb	r3, [r1, #2]

	temp_union data;

	data.u32_value =
    		(((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
 80241d4:	7aca      	ldrb	r2, [r1, #11]
                      ((uint16_t)payload[offset    ]));
}

static inline uint16_t rd_payload_u16(const uint8_t* payload, size_t offset)
{
    return (((uint16_t)payload[offset + 1]) <<  8) |
 80241d6:	9005      	str	r0, [sp, #20]
 80241d8:	7b48      	ldrb	r0, [r1, #13]
 80241da:	f8c5 e010 	str.w	lr, [r5, #16]
		} temp_union;

	temp_union data;

	data.u32_value =
    		(((uint32_t)payload[offset + 3]) << 24) |
 80241de:	f891 e016 	ldrb.w	lr, [r1, #22]
                      ((uint16_t)payload[offset    ]));
}

static inline uint16_t rd_payload_u16(const uint8_t* payload, size_t offset)
{
    return (((uint16_t)payload[offset + 1]) <<  8) |
 80241e2:	9006      	str	r0, [sp, #24]

	temp_union data;

	data.u32_value =
    		(((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
 80241e4:	ea4f 4c0c 	mov.w	ip, ip, lsl #16
		} temp_union;

	temp_union data;

	data.u32_value =
    		(((uint32_t)payload[offset + 3]) << 24) |
 80241e8:	ea4c 6e0e 	orr.w	lr, ip, lr, lsl #24
           (((uint32_t)payload[offset + 2]) << 16) |
           (((uint32_t)payload[offset + 1]) <<  8) |
            ((uint32_t)payload[offset    ]);
 80241ec:	f891 c013 	ldrb.w	ip, [r1, #19]
 80241f0:	ea4e 0e0c 	orr.w	lr, lr, ip
	temp_union data;

	data.u32_value =
    		(((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
           (((uint32_t)payload[offset + 1]) <<  8) |
 80241f4:	f891 c014 	ldrb.w	ip, [r1, #20]

	temp_union data;

	data.u32_value =
    		(((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
 80241f8:	0412      	lsls	r2, r2, #16
			offset += sizeof(float);
			g_parameter_pulse.doppler_sensitivity_nu = rd_payload_float(message_data, offset);
 80241fa:	ea4e 2e0c 	orr.w	lr, lr, ip, lsl #8
 80241fe:	f8c5 e014 	str.w	lr, [r5, #20]
		} temp_union;

	temp_union data;

	data.u32_value =
    		(((uint32_t)payload[offset + 3]) << 24) |
 8024202:	ea42 6c09 	orr.w	ip, r2, r9, lsl #24
           (((uint32_t)payload[offset + 2]) << 16) |
 8024206:	f891 e019 	ldrb.w	lr, [r1, #25]
 802420a:	9a01      	ldr	r2, [sp, #4]
		} temp_union;

	temp_union data;

	data.u32_value =
    		(((uint32_t)payload[offset + 3]) << 24) |
 802420c:	7e88      	ldrb	r0, [r1, #26]
           (((uint32_t)payload[offset + 2]) << 16) |
 802420e:	043f      	lsls	r7, r7, #16
		} temp_union;

	temp_union data;

	data.u32_value =
    		(((uint32_t)payload[offset + 3]) << 24) |
 8024210:	ea47 670b 	orr.w	r7, r7, fp, lsl #24
           (((uint32_t)payload[offset + 2]) << 16) |
 8024214:	ea4f 4e0e 	mov.w	lr, lr, lsl #16
 8024218:	4317      	orrs	r7, r2
 802421a:	0436      	lsls	r6, r6, #16
 802421c:	9a02      	ldr	r2, [sp, #8]
		} temp_union;

	temp_union data;

	data.u32_value =
    		(((uint32_t)payload[offset + 3]) << 24) |
 802421e:	ea4e 6000 	orr.w	r0, lr, r0, lsl #24
 8024222:	ea46 660a 	orr.w	r6, r6, sl, lsl #24
           (((uint32_t)payload[offset + 2]) << 16) |
           (((uint32_t)payload[offset + 1]) <<  8) |
            ((uint32_t)payload[offset    ]);
 8024226:	f891 e017 	ldrb.w	lr, [r1, #23]
 802422a:	4316      	orrs	r6, r2
 802422c:	ea4c 0208 	orr.w	r2, ip, r8
	temp_union data;

	data.u32_value =
    		(((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
           (((uint32_t)payload[offset + 1]) <<  8) |
 8024230:	f891 c018 	ldrb.w	ip, [r1, #24]
 8024234:	ea40 000e 	orr.w	r0, r0, lr
			offset += sizeof(float);
			g_parameter_pulse.motion_sensitivity_nu = rd_payload_float(message_data, offset);
 8024238:	ea40 2c0c 	orr.w	ip, r0, ip, lsl #8
	case MSG_PARA_SET_VALUES_IND:
		if (num_bytes == 35)
		{
			size_t offset = 1; // skip id

			g_parameter_pulse.max_speed_mps = rd_payload_float(message_data, offset);
 802423c:	ea47 2703 	orr.w	r7, r7, r3, lsl #8
			offset += sizeof(float);
			g_parameter_pulse.min_speed_mps = rd_payload_float(message_data, offset);
			offset += sizeof(float);
			g_parameter_pulse.frame_time_sec = rd_payload_float(message_data, offset);
 8024240:	9804      	ldr	r0, [sp, #16]
		{
			size_t offset = 1; // skip id

			g_parameter_pulse.max_speed_mps = rd_payload_float(message_data, offset);
			offset += sizeof(float);
			g_parameter_pulse.min_speed_mps = rd_payload_float(message_data, offset);
 8024242:	9b03      	ldr	r3, [sp, #12]
			offset += sizeof(uint16_t);
			g_parameter_pulse.sampling_freq_hz = rd_payload_float(message_data, offset);
			offset += sizeof(float);
			g_parameter_pulse.doppler_sensitivity_nu = rd_payload_float(message_data, offset);
			offset += sizeof(float);
			g_parameter_pulse.motion_sensitivity_nu = rd_payload_float(message_data, offset);
 8024244:	f8c5 c018 	str.w	ip, [r5, #24]

			g_parameter_pulse.max_speed_mps = rd_payload_float(message_data, offset);
			offset += sizeof(float);
			g_parameter_pulse.min_speed_mps = rd_payload_float(message_data, offset);
			offset += sizeof(float);
			g_parameter_pulse.frame_time_sec = rd_payload_float(message_data, offset);
 8024248:	ea42 2e00 	orr.w	lr, r2, r0, lsl #8
		{
			size_t offset = 1; // skip id

			g_parameter_pulse.max_speed_mps = rd_payload_float(message_data, offset);
			offset += sizeof(float);
			g_parameter_pulse.min_speed_mps = rd_payload_float(message_data, offset);
 802424c:	ea46 2603 	orr.w	r6, r6, r3, lsl #8
                      ((uint16_t)payload[offset    ]));
}

static inline uint16_t rd_payload_u16(const uint8_t* payload, size_t offset)
{
    return (((uint16_t)payload[offset + 1]) <<  8) |
 8024250:	9805      	ldr	r0, [sp, #20]
 8024252:	9b06      	ldr	r3, [sp, #24]
 8024254:	606e      	str	r6, [r5, #4]
 8024256:	ea43 2200 	orr.w	r2, r3, r0, lsl #8
			offset += sizeof(float);
			g_parameter_pulse.frame_time_sec = rd_payload_float(message_data, offset);
			offset += sizeof(float);
			g_parameter_pulse.number_of_samples_nu = rd_payload_u16(message_data, offset);
 802425a:	81aa      	strh	r2, [r5, #12]
 *
 * \return The function returns the value read from the payload.
 */
static inline uint8_t rd_payload_u8(const uint8_t* payload, size_t offset)
{
    return payload[offset];
 802425c:	7eca      	ldrb	r2, [r1, #27]
			offset += sizeof(float);
			g_parameter_pulse.doppler_sensitivity_nu = rd_payload_float(message_data, offset);
			offset += sizeof(float);
			g_parameter_pulse.motion_sensitivity_nu = rd_payload_float(message_data, offset);
			offset += sizeof(float);
			g_parameter_pulse.use_high_gain_doppler_bool = rd_payload_u8(message_data, offset);
 802425e:	772a      	strb	r2, [r5, #28]
 8024260:	7f0a      	ldrb	r2, [r1, #28]
			offset += sizeof(uint8_t);
			g_parameter_pulse.continuous_mode_bool = rd_payload_u8(message_data, offset);
 8024262:	776a      	strb	r2, [r5, #29]
                      ((uint16_t)payload[offset    ]));
}

static inline uint16_t rd_payload_u16(const uint8_t* payload, size_t offset)
{
    return (((uint16_t)payload[offset + 1]) <<  8) |
 8024264:	7f4e      	ldrb	r6, [r1, #29]

			g_parameter_pulse.max_speed_mps = rd_payload_float(message_data, offset);
			offset += sizeof(float);
			g_parameter_pulse.min_speed_mps = rd_payload_float(message_data, offset);
			offset += sizeof(float);
			g_parameter_pulse.frame_time_sec = rd_payload_float(message_data, offset);
 8024266:	f8c5 e008 	str.w	lr, [r5, #8]
 802426a:	f891 e01e 	ldrb.w	lr, [r1, #30]
}

static inline uint32_t rd_payload_u32(const uint8_t* payload, size_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
 802426e:	f891 0021 	ldrb.w	r0, [r1, #33]	; 0x21
                      ((uint32_t)payload[offset    ]));
}

static inline uint32_t rd_payload_u32(const uint8_t* payload, size_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
 8024272:	f891 2022 	ldrb.w	r2, [r1, #34]	; 0x22
	case MSG_PARA_SET_VALUES_IND:
		if (num_bytes == 35)
		{
			size_t offset = 1; // skip id

			g_parameter_pulse.max_speed_mps = rd_payload_float(message_data, offset);
 8024276:	602f      	str	r7, [r5, #0]
                      ((uint16_t)payload[offset    ]));
}

static inline uint16_t rd_payload_u16(const uint8_t* payload, size_t offset)
{
    return (((uint16_t)payload[offset + 1]) <<  8) |
 8024278:	ea46 260e 	orr.w	r6, r6, lr, lsl #8
			offset += sizeof(float);
			g_parameter_pulse.use_high_gain_doppler_bool = rd_payload_u8(message_data, offset);
			offset += sizeof(uint8_t);
			g_parameter_pulse.continuous_mode_bool = rd_payload_u8(message_data, offset);
			offset += sizeof(uint8_t);
			g_parameter_pulse.number_of_skip_samples_nu = rd_payload_u16(message_data, offset);
 802427c:	83ee      	strh	r6, [r5, #30]

static inline uint32_t rd_payload_u32(const uint8_t* payload, size_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
           (((uint32_t)payload[offset + 1]) <<  8) |
 802427e:	f891 7020 	ldrb.w	r7, [r1, #32]
            ((uint32_t)payload[offset    ]);
 8024282:	7fc9      	ldrb	r1, [r1, #31]
}

static inline uint32_t rd_payload_u32(const uint8_t* payload, size_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
 8024284:	0400      	lsls	r0, r0, #16
                      ((uint32_t)payload[offset    ]));
}

static inline uint32_t rd_payload_u32(const uint8_t* payload, size_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
 8024286:	ea40 6202 	orr.w	r2, r0, r2, lsl #24
 802428a:	430a      	orrs	r2, r1
 802428c:	ea42 2207 	orr.w	r2, r2, r7, lsl #8
			offset += sizeof(uint16_t);
			g_parameter_pulse.pulse_width_usec = rd_payload_u32(message_data, offset);
			offset += sizeof(uint32_t);

			uint32_t status = copyComPara2Store(&g_parameter_pulse);
 8024290:	4628      	mov	r0, r5
			offset += sizeof(uint8_t);
			g_parameter_pulse.continuous_mode_bool = rd_payload_u8(message_data, offset);
			offset += sizeof(uint8_t);
			g_parameter_pulse.number_of_skip_samples_nu = rd_payload_u16(message_data, offset);
			offset += sizeof(uint16_t);
			g_parameter_pulse.pulse_width_usec = rd_payload_u32(message_data, offset);
 8024292:	622a      	str	r2, [r5, #32]
			offset += sizeof(uint32_t);

			uint32_t status = copyComPara2Store(&g_parameter_pulse);
 8024294:	f7fc fdbc 	bl	8020e10 <copyComPara2Store>
			if (status)
 8024298:	9b07      	ldr	r3, [sp, #28]
 802429a:	2800      	cmp	r0, #0
 802429c:	d175      	bne.n	802438a <ep_radar_s2glpulse_handle_message+0x3fe>
				protocol_broadcast_change(radar_driver, EP_RADAR_CHNG_CURRENT_CONSUMPTION);
				return RADAR_ERR_OK;
			}
			else
			{
				return RADAR_ERR_PARAMETER_OUT_OF_RANGE;
 802429e:	200c      	movs	r0, #12
 80242a0:	e69a      	b.n	8023fd8 <ep_radar_s2glpulse_handle_message+0x4c>
				error("wrong message size!");
			*/
		break;

	case MSG_RESULT_IND:
		if (num_bytes == 5)
 80242a2:	2a05      	cmp	r2, #5
 80242a4:	f47f ae96 	bne.w	8023fd4 <ep_radar_s2glpulse_handle_message+0x48>
           (((uint32_t)payload[offset + 2]) << 16) |
 80242a8:	78cb      	ldrb	r3, [r1, #3]
                      ((uint32_t)payload[offset    ]));
}

static inline uint32_t rd_payload_u32(const uint8_t* payload, size_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
 80242aa:	7908      	ldrb	r0, [r1, #4]
           (((uint32_t)payload[offset + 2]) << 16) |
           (((uint32_t)payload[offset + 1]) <<  8) |
            ((uint32_t)payload[offset    ]);
 80242ac:	784a      	ldrb	r2, [r1, #1]

static inline uint32_t rd_payload_u32(const uint8_t* payload, size_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
           (((uint32_t)payload[offset + 1]) <<  8) |
 80242ae:	7889      	ldrb	r1, [r1, #2]
}

static inline uint32_t rd_payload_u32(const uint8_t* payload, size_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
 80242b0:	041b      	lsls	r3, r3, #16
                      ((uint32_t)payload[offset    ]));
}

static inline uint32_t rd_payload_u32(const uint8_t* payload, size_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
 80242b2:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
 80242b6:	4313      	orrs	r3, r2
		{
			uint16_t in_offset = 1;
			uint32_t repeat_count = rd_payload_u32(message_data, in_offset);

			set_result_repeat_count(endpoint, repeat_count);
 80242b8:	4620      	mov	r0, r4
 80242ba:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
 80242be:	f7fc fd11 	bl	8020ce4 <set_result_repeat_count>

			return RADAR_ERR_OK;
 80242c2:	2000      	movs	r0, #0
 80242c4:	e688      	b.n	8023fd8 <ep_radar_s2glpulse_handle_message+0x4c>
 80242c6:	bf00      	nop
 80242c8:	1fff029c 	.word	0x1fff029c
 80242cc:	1ffe9cc4 	.word	0x1ffe9cc4
 80242d0:	0802f150 	.word	0x0802f150
		}
		break;

	case MSG_GET_SHIELD_INFO_IND:
		if (num_bytes == 1)
 80242d4:	2a01      	cmp	r2, #1
 80242d6:	f47f ae7d 	bne.w	8023fd4 <ep_radar_s2glpulse_handle_message+0x48>
		{

			static uint8_t message[512];
			uint16_t offset = 0;

			uint32_t index = ds_get_board_variant();
 80242da:	f7fb fe91 	bl	8020000 <ds_get_board_variant>

			if (index == 0 || index > sizeof(rf_shield_info) / sizeof(rf_shield_info[0]) + 1)
 80242de:	3801      	subs	r0, #1
 80242e0:	2803      	cmp	r0, #3
 80242e2:	bf28      	it	cs
 80242e4:	2000      	movcs	r0, #0
			}

			pulse_rf_shield_info_t *p_info = &rf_shield_info[index - 1];

			offset += wr_payload_u8(message, offset, MSG_GET_SHIELD_INFO_RES);
			offset += wr_payload_u32(message, offset, p_info->rf_frequency_khz);
 80242e6:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 80242ea:	0083      	lsls	r3, r0, #2
 80242ec:	4d2d      	ldr	r5, [pc, #180]	; (80243a4 <ep_radar_s2glpulse_handle_message+0x418>)
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 80242ee:	4f2e      	ldr	r7, [pc, #184]	; (80243a8 <ep_radar_s2glpulse_handle_message+0x41c>)
 80242f0:	58ea      	ldr	r2, [r5, r3]
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 80242f2:	707a      	strb	r2, [r7, #1]
 80242f4:	441d      	add	r5, r3
}

static inline size_t wr_payload_u32(uint8_t* payload, size_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 80242f6:	0e11      	lsrs	r1, r2, #24
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
 80242f8:	0a13      	lsrs	r3, r2, #8
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 80242fa:	f895 c005 	ldrb.w	ip, [r5, #5]
 80242fe:	f895 e006 	ldrb.w	lr, [r5, #6]
 8024302:	79ee      	ldrb	r6, [r5, #7]
 8024304:	f895 8004 	ldrb.w	r8, [r5, #4]
static inline size_t wr_payload_u32(uint8_t* payload, size_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024308:	70bb      	strb	r3, [r7, #2]

static inline size_t wr_payload_u32(uint8_t* payload, size_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
 802430a:	ea4f 4912 	mov.w	r9, r2, lsr #16
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 802430e:	f04f 0a41 	mov.w	sl, #65	; 0x41
 8024312:	f887 c006 	strb.w	ip, [r7, #6]
 8024316:	f887 e007 	strb.w	lr, [r7, #7]
			offset += wr_payload_u8(message, offset, p_info->major_rf_shield_version);
			offset += wr_payload_u8(message, offset, p_info->minor_rf_shield_version);
			offset += wr_payload_u8(message, offset, p_info->num_tx_antennas);
			offset += wr_payload_u8(message, offset, p_info->num_rx_antennas);

			offset += wr_payload_string(message, offset, p_info->rf_shield_board_id);
 802431a:	68aa      	ldr	r2, [r5, #8]
}

static inline size_t wr_payload_u32(uint8_t* payload, size_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 802431c:	7139      	strb	r1, [r7, #4]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 802431e:	723e      	strb	r6, [r7, #8]
 8024320:	2109      	movs	r1, #9
 8024322:	4638      	mov	r0, r7
 8024324:	f887 a000 	strb.w	sl, [r7]

static inline size_t wr_payload_u32(uint8_t* payload, size_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
 8024328:	f887 9003 	strb.w	r9, [r7, #3]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 802432c:	f887 8005 	strb.w	r8, [r7, #5]
 8024330:	f000 fabc 	bl	80248ac <wr_payload_string>
 8024334:	3009      	adds	r0, #9
 8024336:	b286      	uxth	r6, r0
			offset += wr_payload_string(message, offset, p_info->description);
 8024338:	4631      	mov	r1, r6
 802433a:	68ea      	ldr	r2, [r5, #12]
 802433c:	4638      	mov	r0, r7
 802433e:	f000 fab5 	bl	80248ac <wr_payload_string>
 8024342:	4430      	add	r0, r6
 8024344:	b286      	uxth	r6, r0
			offset += wr_payload_string(message, offset, p_info->modulation);
 8024346:	692a      	ldr	r2, [r5, #16]
 8024348:	4631      	mov	r1, r6
 802434a:	4638      	mov	r0, r7
 802434c:	f000 faae 	bl	80248ac <wr_payload_string>
 8024350:	4430      	add	r0, r6
 8024352:	b285      	uxth	r5, r0

			/* send message */
			protocol_send_header(endpoint, offset);
 8024354:	4629      	mov	r1, r5
 8024356:	4620      	mov	r0, r4
 8024358:	f000 fa40 	bl	80247dc <protocol_send_header>
			protocol_send_payload(message, offset);
 802435c:	4638      	mov	r0, r7
 802435e:	4629      	mov	r1, r5
 8024360:	f000 fa50 	bl	8024804 <protocol_send_payload>
			protocol_send_tail();
 8024364:	f000 fa50 	bl	8024808 <protocol_send_tail>

			return RADAR_ERR_OK;
 8024368:	2000      	movs	r0, #0
 802436a:	e635      	b.n	8023fd8 <ep_radar_s2glpulse_handle_message+0x4c>
}

static inline uint32_t rd_payload_u32(const uint8_t* payload, size_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
 802436c:	78cb      	ldrb	r3, [r1, #3]
                      ((uint32_t)payload[offset    ]));
}

static inline uint32_t rd_payload_u32(const uint8_t* payload, size_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
 802436e:	7908      	ldrb	r0, [r1, #4]
           (((uint32_t)payload[offset + 2]) << 16) |
           (((uint32_t)payload[offset + 1]) <<  8) |
            ((uint32_t)payload[offset    ]);
 8024370:	784a      	ldrb	r2, [r1, #1]

static inline uint32_t rd_payload_u32(const uint8_t* payload, size_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
           (((uint32_t)payload[offset + 1]) <<  8) |
 8024372:	7889      	ldrb	r1, [r1, #2]
}

static inline uint32_t rd_payload_u32(const uint8_t* payload, size_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
           (((uint32_t)payload[offset + 2]) << 16) |
 8024374:	041b      	lsls	r3, r3, #16
                      ((uint32_t)payload[offset    ]));
}

static inline uint32_t rd_payload_u32(const uint8_t* payload, size_t offset)
{
    return (((uint32_t)payload[offset + 3]) << 24) |
 8024376:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
 802437a:	4313      	orrs	r3, r2
		if (num_bytes == 5)
		{
			uint16_t in_offset = 1;
			uint32_t repeat_count = rd_payload_u32(message_data, in_offset);

			set_raw_data_repeat_count(endpoint, repeat_count);
 802437c:	4620      	mov	r0, r4
 802437e:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
 8024382:	f7fc fcb9 	bl	8020cf8 <set_raw_data_repeat_count>

			return RADAR_ERR_OK;
 8024386:	2000      	movs	r0, #0
 8024388:	e626      	b.n	8023fd8 <ep_radar_s2glpulse_handle_message+0x4c>

			uint32_t status = copyComPara2Store(&g_parameter_pulse);
			if (status)
			{
				/* send message */
				send_parameter_values(endpoint, &g_parameter_pulse);
 802438a:	4620      	mov	r0, r4
 802438c:	4629      	mov	r1, r5
 802438e:	9301      	str	r3, [sp, #4]
 8024390:	f7ff fcde 	bl	8023d50 <send_parameter_values>

				/* inform other endpoints of the change */
				Radar_Handle_t radar_driver = (Radar_Handle_t)context;

				protocol_broadcast_change(radar_driver, EP_RADAR_CHNG_CURRENT_CONSUMPTION);
 8024394:	9b01      	ldr	r3, [sp, #4]
 8024396:	2114      	movs	r1, #20
 8024398:	4618      	mov	r0, r3
 802439a:	f000 fa47 	bl	802482c <protocol_broadcast_change>
				return RADAR_ERR_OK;
 802439e:	2000      	movs	r0, #0
 80243a0:	e61a      	b.n	8023fd8 <ep_radar_s2glpulse_handle_message+0x4c>
 80243a2:	bf00      	nop
 80243a4:	1ffe90ac 	.word	0x1ffe90ac
 80243a8:	1ffe9fec 	.word	0x1ffe9fec

080243ac <ep_radar_s2glpulse_handle_change>:
}

//============================================================================

void ep_radar_s2glpulse_handle_change(uint8_t endpoint, void* context, uint32_t what)
{
 80243ac:	4770      	bx	lr
 80243ae:	bf00      	nop

080243b0 <receive_data>:
}

//============================================================================

static void receive_data(void)
{
 80243b0:	b530      	push	{r4, r5, lr}
    /* receive data from communication interface */
    uint16_t num_received_bytes = com_get_data(instance.receive_pointer,
 80243b2:	4c17      	ldr	r4, [pc, #92]	; (8024410 <receive_data+0x60>)
}

//============================================================================

static void receive_data(void)
{
 80243b4:	b083      	sub	sp, #12
    /* receive data from communication interface */
    uint16_t num_received_bytes = com_get_data(instance.receive_pointer,
 80243b6:	89a1      	ldrh	r1, [r4, #12]
 80243b8:	68a0      	ldr	r0, [r4, #8]
 80243ba:	f004 fcf9 	bl	8028db0 <com_get_data>
                                               instance.num_bytes_awaited);
    instance.receive_pointer += num_received_bytes;
 80243be:	68a2      	ldr	r2, [r4, #8]
    instance.num_bytes_awaited -= num_received_bytes;
 80243c0:	89a3      	ldrh	r3, [r4, #12]

    /* check for timeout */
    if (instance.get_time != NULL)
 80243c2:	6a21      	ldr	r1, [r4, #32]
static void receive_data(void)
{
    /* receive data from communication interface */
    uint16_t num_received_bytes = com_get_data(instance.receive_pointer,
                                               instance.num_bytes_awaited);
    instance.receive_pointer += num_received_bytes;
 80243c4:	4402      	add	r2, r0
    instance.num_bytes_awaited -= num_received_bytes;
 80243c6:	1a1b      	subs	r3, r3, r0
//============================================================================

static void receive_data(void)
{
    /* receive data from communication interface */
    uint16_t num_received_bytes = com_get_data(instance.receive_pointer,
 80243c8:	4605      	mov	r5, r0
                                               instance.num_bytes_awaited);
    instance.receive_pointer += num_received_bytes;
 80243ca:	60a2      	str	r2, [r4, #8]
    instance.num_bytes_awaited -= num_received_bytes;
 80243cc:	81a3      	strh	r3, [r4, #12]

    /* check for timeout */
    if (instance.get_time != NULL)
 80243ce:	b1e9      	cbz	r1, 802440c <receive_data+0x5c>
    {
        /* get current time */
        uint32_t current_time = instance.get_time();
 80243d0:	4788      	blx	r1

        /* if no data has been received, check the time since last received
         * bytes
         */
        if (num_received_bytes == 0)
 80243d2:	b9d5      	cbnz	r5, 802440a <receive_data+0x5a>
        {
        	if (instance.time_of_last_byte > current_time)
 80243d4:	6923      	ldr	r3, [r4, #16]
 80243d6:	4298      	cmp	r0, r3
 80243d8:	d317      	bcc.n	802440a <receive_data+0x5a>
        		/* Handle time wrap-around */
        		instance.time_of_last_byte = current_time;
        	}
        	else {

				if ((instance.state != PROTOCOL_STATE_IDLE) &&
 80243da:	7961      	ldrb	r1, [r4, #5]
 80243dc:	b1b1      	cbz	r1, 802440c <receive_data+0x5c>
					(current_time >= instance.time_of_last_byte +
 80243de:	6a62      	ldr	r2, [r4, #36]	; 0x24
 80243e0:	4413      	add	r3, r2
        		/* Handle time wrap-around */
        		instance.time_of_last_byte = current_time;
        	}
        	else {

				if ((instance.state != PROTOCOL_STATE_IDLE) &&
 80243e2:	4298      	cmp	r0, r3
 80243e4:	d312      	bcc.n	802440c <receive_data+0x5c>
					(current_time >= instance.time_of_last_byte +
									 instance.timeout_interval))
				{
					/* a timeout has occurred, reset protocol state */
					if (instance.state != PROTOCOL_STATE_CONFUSED)
 80243e6:	2904      	cmp	r1, #4
 80243e8:	d008      	beq.n	80243fc <receive_data+0x4c>
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 80243ea:	a802      	add	r0, sp, #8
 80243ec:	4b09      	ldr	r3, [pc, #36]	; (8024414 <receive_data+0x64>)
 80243ee:	f840 3d04 	str.w	r3, [r0, #-4]!
    wr_payload_u8 (status_message, 0, CNST_STARTBYTE_STATUS);
    wr_payload_u8 (status_message, 1, endpoint);
    wr_payload_u16(status_message, 2, status_code);

    /* now send message */
    com_send_data(status_message, sizeof(status_message));
 80243f2:	2104      	movs	r1, #4
 80243f4:	f004 fcda 	bl	8028dac <com_send_data>
    com_flush();
 80243f8:	f004 fcea 	bl	8028dd0 <com_flush>
//============================================================================

static void reset_state(void)
{
    /* set to idle state and store incoming data in message frame buffer */
    instance.state             = PROTOCOL_STATE_IDLE;
 80243fc:	2300      	movs	r3, #0
    instance.receive_pointer   = instance.message_frame;
 80243fe:	4a06      	ldr	r2, [pc, #24]	; (8024418 <receive_data+0x68>)
//============================================================================

static void reset_state(void)
{
    /* set to idle state and store incoming data in message frame buffer */
    instance.state             = PROTOCOL_STATE_IDLE;
 8024400:	7163      	strb	r3, [r4, #5]
    instance.receive_pointer   = instance.message_frame;
    instance.num_bytes_awaited = 4;
 8024402:	2304      	movs	r3, #4

static void reset_state(void)
{
    /* set to idle state and store incoming data in message frame buffer */
    instance.state             = PROTOCOL_STATE_IDLE;
    instance.receive_pointer   = instance.message_frame;
 8024404:	60a2      	str	r2, [r4, #8]
    instance.num_bytes_awaited = 4;
 8024406:	81a3      	strh	r3, [r4, #12]
 8024408:	e000      	b.n	802440c <receive_data+0x5c>
        else
        {
            /* data has been received, so remember current time for next
             * timeout check
             */
            instance.time_of_last_byte = current_time;
 802440a:	6120      	str	r0, [r4, #16]
        }
    }
}
 802440c:	b003      	add	sp, #12
 802440e:	bd30      	pop	{r4, r5, pc}
 8024410:	1ffeb1f0 	.word	0x1ffeb1f0
 8024414:	0001005b 	.word	0x0001005b
 8024418:	1ffeb204 	.word	0x1ffeb204

0802441c <protocol_init>:
 */

void protocol_init(Endpoint_t* endpoints, uint8_t num_endpoints,
                   uint32_t (*get_time)(void), uint32_t timeout_interval,
                   void (*do_system_reset)(void))
{
 802441c:	b538      	push	{r3, r4, r5, lr}
    /* initialize the internal state structure */
    instance.get_time = get_time;
 802441e:	4c0f      	ldr	r4, [pc, #60]	; (802445c <protocol_init+0x40>)
 */

void protocol_init(Endpoint_t* endpoints, uint8_t num_endpoints,
                   uint32_t (*get_time)(void), uint32_t timeout_interval,
                   void (*do_system_reset)(void))
{
 8024420:	9d04      	ldr	r5, [sp, #16]
    /* initialize the internal state structure */
    instance.get_time = get_time;
    instance.timeout_interval = timeout_interval;
 8024422:	6263      	str	r3, [r4, #36]	; 0x24
    instance.do_system_reset = do_system_reset;

    instance.endpoints = endpoints;
    instance.num_endpoints = num_endpoints;

    instance.state = PROTOCOL_STATE_IDLE;
 8024424:	2300      	movs	r3, #0
void protocol_init(Endpoint_t* endpoints, uint8_t num_endpoints,
                   uint32_t (*get_time)(void), uint32_t timeout_interval,
                   void (*do_system_reset)(void))
{
    /* initialize the internal state structure */
    instance.get_time = get_time;
 8024426:	6222      	str	r2, [r4, #32]
    instance.timeout_interval = timeout_interval;
    instance.do_system_reset = do_system_reset;

    instance.endpoints = endpoints;
 8024428:	6020      	str	r0, [r4, #0]
    instance.num_endpoints = num_endpoints;
 802442a:	7121      	strb	r1, [r4, #4]
                   void (*do_system_reset)(void))
{
    /* initialize the internal state structure */
    instance.get_time = get_time;
    instance.timeout_interval = timeout_interval;
    instance.do_system_reset = do_system_reset;
 802442c:	62a5      	str	r5, [r4, #40]	; 0x28

    instance.endpoints = endpoints;
    instance.num_endpoints = num_endpoints;

    instance.state = PROTOCOL_STATE_IDLE;
 802442e:	7163      	strb	r3, [r4, #5]
    instance.receive_pointer = NULL;
 8024430:	60a3      	str	r3, [r4, #8]
    instance.num_bytes_awaited = 0;
 8024432:	81a3      	strh	r3, [r4, #12]
    instance.time_of_last_byte = (get_time != NULL) ? instance.get_time() : 0;
 8024434:	b182      	cbz	r2, 8024458 <protocol_init+0x3c>
 8024436:	4790      	blx	r2
    instance.payload = data_payload;
 8024438:	4d09      	ldr	r5, [pc, #36]	; (8024460 <protocol_init+0x44>)
    instance.num_endpoints = num_endpoints;

    instance.state = PROTOCOL_STATE_IDLE;
    instance.receive_pointer = NULL;
    instance.num_bytes_awaited = 0;
    instance.time_of_last_byte = (get_time != NULL) ? instance.get_time() : 0;
 802443a:	6120      	str	r0, [r4, #16]
static void reset_state(void)
{
    /* set to idle state and store incoming data in message frame buffer */
    instance.state             = PROTOCOL_STATE_IDLE;
    instance.receive_pointer   = instance.message_frame;
    instance.num_bytes_awaited = 4;
 802443c:	2304      	movs	r3, #4

static void reset_state(void)
{
    /* set to idle state and store incoming data in message frame buffer */
    instance.state             = PROTOCOL_STATE_IDLE;
    instance.receive_pointer   = instance.message_frame;
 802443e:	4a09      	ldr	r2, [pc, #36]	; (8024464 <protocol_init+0x48>)

    instance.state = PROTOCOL_STATE_IDLE;
    instance.receive_pointer = NULL;
    instance.num_bytes_awaited = 0;
    instance.time_of_last_byte = (get_time != NULL) ? instance.get_time() : 0;
    instance.payload = data_payload;
 8024440:	61e5      	str	r5, [r4, #28]
	instance.max_payload = PROTOCOL_MAX_PAYLOAD_SIZE;
 8024442:	f44f 7000 	mov.w	r0, #512	; 0x200
//============================================================================

static void reset_state(void)
{
    /* set to idle state and store incoming data in message frame buffer */
    instance.state             = PROTOCOL_STATE_IDLE;
 8024446:	2100      	movs	r1, #0
    instance.state = PROTOCOL_STATE_IDLE;
    instance.receive_pointer = NULL;
    instance.num_bytes_awaited = 0;
    instance.time_of_last_byte = (get_time != NULL) ? instance.get_time() : 0;
    instance.payload = data_payload;
	instance.max_payload = PROTOCOL_MAX_PAYLOAD_SIZE;
 8024448:	62e0      	str	r0, [r4, #44]	; 0x2c
//============================================================================

static void reset_state(void)
{
    /* set to idle state and store incoming data in message frame buffer */
    instance.state             = PROTOCOL_STATE_IDLE;
 802444a:	7161      	strb	r1, [r4, #5]
    instance.receive_pointer   = instance.message_frame;
 802444c:	60a2      	str	r2, [r4, #8]
    instance.num_bytes_awaited = 4;
 802444e:	81a3      	strh	r3, [r4, #12]
    /* initialize state */
    reset_state();

    /* initialize communication interface */
    com_init();
}
 8024450:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}

    /* initialize state */
    reset_state();

    /* initialize communication interface */
    com_init();
 8024454:	f004 bca8 	b.w	8028da8 <com_init>
    instance.num_endpoints = num_endpoints;

    instance.state = PROTOCOL_STATE_IDLE;
    instance.receive_pointer = NULL;
    instance.num_bytes_awaited = 0;
    instance.time_of_last_byte = (get_time != NULL) ? instance.get_time() : 0;
 8024458:	4610      	mov	r0, r2
 802445a:	e7ed      	b.n	8024438 <protocol_init+0x1c>
 802445c:	1ffeb1f0 	.word	0x1ffeb1f0
 8024460:	1ffeb220 	.word	0x1ffeb220
 8024464:	1ffeb204 	.word	0x1ffeb204

08024468 <protocol_run>:
}

//============================================================================

void protocol_run(void)
{
 8024468:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if (instance.state != PROTOCOL_STATE_CONFUSED)
 802446c:	4ca1      	ldr	r4, [pc, #644]	; (80246f4 <protocol_run+0x28c>)
 802446e:	7963      	ldrb	r3, [r4, #5]
 8024470:	2b04      	cmp	r3, #4
}

//============================================================================

void protocol_run(void)
{
 8024472:	b092      	sub	sp, #72	; 0x48
	if (instance.state != PROTOCOL_STATE_CONFUSED)
 8024474:	d02b      	beq.n	80244ce <protocol_run+0x66>
    {
        /* if the protocol is in a defined state, read the next bytes from the
         * input stream
         */
        receive_data();
 8024476:	f7ff ff9b 	bl	80243b0 <receive_data>
        /*
         * now process data until the end of a message has been reached
         * (note the missing brakes, the fall through is intended to proceed
         * with the message, so don't wonder)
         */
        switch (instance.state)
 802447a:	7963      	ldrb	r3, [r4, #5]
 802447c:	2b03      	cmp	r3, #3
 802447e:	d824      	bhi.n	80244ca <protocol_run+0x62>
 8024480:	e8df f003 	tbb	[pc, r3]
 8024484:	70890207 	.word	0x70890207
            /* no break, fall through and continue with
             * PROTOCOL_STATE_RECEIVING_HEADER
             */

        case PROTOCOL_STATE_RECEIVING_HEADER:
            if (instance.num_bytes_awaited == 0)
 8024488:	89a3      	ldrh	r3, [r4, #12]
 802448a:	b153      	cbz	r3, 80244a2 <protocol_run+0x3a>
        /*
         * The receive_data function may switch the state back to idle, if a
         * timeout occurs, this is the  only way to get out of confused state.
         */
    }
}
 802448c:	b012      	add	sp, #72	; 0x48
 802448e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        {
        case PROTOCOL_STATE_IDLE:
            /* if at least one byte has been received, the state is not idle
             *  any more
             */
            if (instance.num_bytes_awaited < 4)
 8024492:	89a3      	ldrh	r3, [r4, #12]
 8024494:	4a97      	ldr	r2, [pc, #604]	; (80246f4 <protocol_run+0x28c>)
 8024496:	2b03      	cmp	r3, #3
 8024498:	d8f8      	bhi.n	802448c <protocol_run+0x24>
                instance.state = PROTOCOL_STATE_RECEIVING_HEADER;
 802449a:	2101      	movs	r1, #1
 802449c:	7151      	strb	r1, [r2, #5]
            /* no break, fall through and continue with
             * PROTOCOL_STATE_RECEIVING_HEADER
             */

        case PROTOCOL_STATE_RECEIVING_HEADER:
            if (instance.num_bytes_awaited == 0)
 802449e:	2b00      	cmp	r3, #0
 80244a0:	d1f4      	bne.n	802448c <protocol_run+0x24>
                sync_byte    = rd_payload_u8 (instance.message_frame, 0);
                endpoint     = rd_payload_u8 (instance.message_frame, 1);
                payload_size = rd_payload_u16(instance.message_frame, 2);

                /* check sync bye, message must be a payload message */
                if (sync_byte != CNST_STARTBYTE_DATA)
 80244a2:	7d23      	ldrb	r3, [r4, #20]
 *
 * \return The function returns the value read from the payload.
 */
static inline uint8_t rd_payload_u8(const uint8_t* payload, size_t offset)
{
    return payload[offset];
 80244a4:	4e93      	ldr	r6, [pc, #588]	; (80246f4 <protocol_run+0x28c>)
 80244a6:	7d60      	ldrb	r0, [r4, #21]
                      ((uint16_t)payload[offset    ]));
}

static inline uint16_t rd_payload_u16(const uint8_t* payload, size_t offset)
{
    return (((uint16_t)payload[offset + 1]) <<  8) |
 80244a8:	7de1      	ldrb	r1, [r4, #23]
            ((uint16_t)payload[offset    ]);
 80244aa:	7da2      	ldrb	r2, [r4, #22]
 80244ac:	2b5a      	cmp	r3, #90	; 0x5a
 80244ae:	d078      	beq.n	80245a2 <protocol_run+0x13a>
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 80244b0:	4b91      	ldr	r3, [pc, #580]	; (80246f8 <protocol_run+0x290>)
 80244b2:	ad12      	add	r5, sp, #72	; 0x48
 80244b4:	f845 3d40 	str.w	r3, [r5, #-64]!
                end_sequence = rd_payload_u16(instance.message_frame, 4);

                /* check end of payload sequence */
                if (end_sequence != CNST_END_OF_PAYLOAD)
                {
                    instance.state = PROTOCOL_STATE_CONFUSED;
 80244b8:	2304      	movs	r3, #4
    wr_payload_u8 (status_message, 0, CNST_STARTBYTE_STATUS);
    wr_payload_u8 (status_message, 1, endpoint);
    wr_payload_u16(status_message, 2, status_code);

    /* now send message */
    com_send_data(status_message, sizeof(status_message));
 80244ba:	4628      	mov	r0, r5
 80244bc:	4619      	mov	r1, r3
                end_sequence = rd_payload_u16(instance.message_frame, 4);

                /* check end of payload sequence */
                if (end_sequence != CNST_END_OF_PAYLOAD)
                {
                    instance.state = PROTOCOL_STATE_CONFUSED;
 80244be:	7173      	strb	r3, [r6, #5]
    wr_payload_u8 (status_message, 0, CNST_STARTBYTE_STATUS);
    wr_payload_u8 (status_message, 1, endpoint);
    wr_payload_u16(status_message, 2, status_code);

    /* now send message */
    com_send_data(status_message, sizeof(status_message));
 80244c0:	f004 fc74 	bl	8028dac <com_send_data>
    com_flush();
 80244c4:	f004 fc84 	bl	8028dd0 <com_flush>
 80244c8:	7973      	ldrb	r3, [r6, #5]
    }

    /* if state is confused, keep on reading into a dummy buffer, until
     * receive buffer is empty
     */
    if (instance.state == PROTOCOL_STATE_CONFUSED)
 80244ca:	2b04      	cmp	r3, #4
 80244cc:	d1de      	bne.n	802448c <protocol_run+0x24>
    {
        uint8_t dummy_buffer[64];
        do
        {
            instance.receive_pointer = dummy_buffer;
 80244ce:	4e89      	ldr	r6, [pc, #548]	; (80246f4 <protocol_run+0x28c>)
 80244d0:	ad02      	add	r5, sp, #8
            instance.num_bytes_awaited = sizeof(dummy_buffer);
 80244d2:	2740      	movs	r7, #64	; 0x40
//============================================================================

static void receive_data(void)
{
    /* receive data from communication interface */
    uint16_t num_received_bytes = com_get_data(instance.receive_pointer,
 80244d4:	2140      	movs	r1, #64	; 0x40
 80244d6:	4628      	mov	r0, r5
    if (instance.state == PROTOCOL_STATE_CONFUSED)
    {
        uint8_t dummy_buffer[64];
        do
        {
            instance.receive_pointer = dummy_buffer;
 80244d8:	60a5      	str	r5, [r4, #8]
            instance.num_bytes_awaited = sizeof(dummy_buffer);
 80244da:	81a7      	strh	r7, [r4, #12]
//============================================================================

static void receive_data(void)
{
    /* receive data from communication interface */
    uint16_t num_received_bytes = com_get_data(instance.receive_pointer,
 80244dc:	f004 fc68 	bl	8028db0 <com_get_data>
                                               instance.num_bytes_awaited);
    instance.receive_pointer += num_received_bytes;
    instance.num_bytes_awaited -= num_received_bytes;
 80244e0:	89a3      	ldrh	r3, [r4, #12]
static void receive_data(void)
{
    /* receive data from communication interface */
    uint16_t num_received_bytes = com_get_data(instance.receive_pointer,
                                               instance.num_bytes_awaited);
    instance.receive_pointer += num_received_bytes;
 80244e2:	68a2      	ldr	r2, [r4, #8]
    instance.num_bytes_awaited -= num_received_bytes;

    /* check for timeout */
    if (instance.get_time != NULL)
 80244e4:	6a21      	ldr	r1, [r4, #32]
{
    /* receive data from communication interface */
    uint16_t num_received_bytes = com_get_data(instance.receive_pointer,
                                               instance.num_bytes_awaited);
    instance.receive_pointer += num_received_bytes;
    instance.num_bytes_awaited -= num_received_bytes;
 80244e6:	1a1b      	subs	r3, r3, r0
 80244e8:	b29b      	uxth	r3, r3
static void receive_data(void)
{
    /* receive data from communication interface */
    uint16_t num_received_bytes = com_get_data(instance.receive_pointer,
                                               instance.num_bytes_awaited);
    instance.receive_pointer += num_received_bytes;
 80244ea:	4402      	add	r2, r0
//============================================================================

static void receive_data(void)
{
    /* receive data from communication interface */
    uint16_t num_received_bytes = com_get_data(instance.receive_pointer,
 80244ec:	4680      	mov	r8, r0
                                               instance.num_bytes_awaited);
    instance.receive_pointer += num_received_bytes;
    instance.num_bytes_awaited -= num_received_bytes;
 80244ee:	81a3      	strh	r3, [r4, #12]
static void receive_data(void)
{
    /* receive data from communication interface */
    uint16_t num_received_bytes = com_get_data(instance.receive_pointer,
                                               instance.num_bytes_awaited);
    instance.receive_pointer += num_received_bytes;
 80244f0:	60a2      	str	r2, [r4, #8]
    instance.num_bytes_awaited -= num_received_bytes;

    /* check for timeout */
    if (instance.get_time != NULL)
 80244f2:	b311      	cbz	r1, 802453a <protocol_run+0xd2>
    {
        /* get current time */
        uint32_t current_time = instance.get_time();
 80244f4:	4788      	blx	r1

        /* if no data has been received, check the time since last received
         * bytes
         */
        if (num_received_bytes == 0)
 80244f6:	f1b8 0f00 	cmp.w	r8, #0
 80244fa:	d121      	bne.n	8024540 <protocol_run+0xd8>
        {
        	if (instance.time_of_last_byte > current_time)
 80244fc:	6933      	ldr	r3, [r6, #16]
 80244fe:	4298      	cmp	r0, r3
 8024500:	d319      	bcc.n	8024536 <protocol_run+0xce>
        		/* Handle time wrap-around */
        		instance.time_of_last_byte = current_time;
        	}
        	else {

				if ((instance.state != PROTOCOL_STATE_IDLE) &&
 8024502:	7971      	ldrb	r1, [r6, #5]
 8024504:	b309      	cbz	r1, 802454a <protocol_run+0xe2>
					(current_time >= instance.time_of_last_byte +
 8024506:	6a72      	ldr	r2, [r6, #36]	; 0x24
 8024508:	4413      	add	r3, r2
        		/* Handle time wrap-around */
        		instance.time_of_last_byte = current_time;
        	}
        	else {

				if ((instance.state != PROTOCOL_STATE_IDLE) &&
 802450a:	4298      	cmp	r0, r3
 802450c:	d31d      	bcc.n	802454a <protocol_run+0xe2>
					(current_time >= instance.time_of_last_byte +
									 instance.timeout_interval))
				{
					/* a timeout has occurred, reset protocol state */
					if (instance.state != PROTOCOL_STATE_CONFUSED)
 802450e:	2904      	cmp	r1, #4
 8024510:	d008      	beq.n	8024524 <protocol_run+0xbc>
 8024512:	a812      	add	r0, sp, #72	; 0x48
 8024514:	4b79      	ldr	r3, [pc, #484]	; (80246fc <protocol_run+0x294>)
 8024516:	f840 3d44 	str.w	r3, [r0, #-68]!
    wr_payload_u8 (status_message, 0, CNST_STARTBYTE_STATUS);
    wr_payload_u8 (status_message, 1, endpoint);
    wr_payload_u16(status_message, 2, status_code);

    /* now send message */
    com_send_data(status_message, sizeof(status_message));
 802451a:	2104      	movs	r1, #4
 802451c:	f004 fc46 	bl	8028dac <com_send_data>
    com_flush();
 8024520:	f004 fc56 	bl	8028dd0 <com_flush>
//============================================================================

static void reset_state(void)
{
    /* set to idle state and store incoming data in message frame buffer */
    instance.state             = PROTOCOL_STATE_IDLE;
 8024524:	2300      	movs	r3, #0
    instance.receive_pointer   = instance.message_frame;
 8024526:	4a76      	ldr	r2, [pc, #472]	; (8024700 <protocol_run+0x298>)
//============================================================================

static void reset_state(void)
{
    /* set to idle state and store incoming data in message frame buffer */
    instance.state             = PROTOCOL_STATE_IDLE;
 8024528:	7163      	strb	r3, [r4, #5]
    instance.receive_pointer   = instance.message_frame;
    instance.num_bytes_awaited = 4;
 802452a:	2304      	movs	r3, #4

static void reset_state(void)
{
    /* set to idle state and store incoming data in message frame buffer */
    instance.state             = PROTOCOL_STATE_IDLE;
    instance.receive_pointer   = instance.message_frame;
 802452c:	60a2      	str	r2, [r4, #8]
    instance.num_bytes_awaited = 4;
 802452e:	81a3      	strh	r3, [r4, #12]
        /*
         * The receive_data function may switch the state back to idle, if a
         * timeout occurs, this is the  only way to get out of confused state.
         */
    }
}
 8024530:	b012      	add	sp, #72	; 0x48
 8024532:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8024536:	89b3      	ldrh	r3, [r6, #12]
        if (num_received_bytes == 0)
        {
        	if (instance.time_of_last_byte > current_time)
        	{
        		/* Handle time wrap-around */
        		instance.time_of_last_byte = current_time;
 8024538:	6130      	str	r0, [r6, #16]
        do
        {
            instance.receive_pointer = dummy_buffer;
            instance.num_bytes_awaited = sizeof(dummy_buffer);
            receive_data();
        } while (instance.num_bytes_awaited == 0);
 802453a:	2b00      	cmp	r3, #0
 802453c:	d0ca      	beq.n	80244d4 <protocol_run+0x6c>
 802453e:	e7a5      	b.n	802448c <protocol_run+0x24>
 8024540:	89b3      	ldrh	r3, [r6, #12]
        else
        {
            /* data has been received, so remember current time for next
             * timeout check
             */
            instance.time_of_last_byte = current_time;
 8024542:	6130      	str	r0, [r6, #16]
        do
        {
            instance.receive_pointer = dummy_buffer;
            instance.num_bytes_awaited = sizeof(dummy_buffer);
            receive_data();
        } while (instance.num_bytes_awaited == 0);
 8024544:	2b00      	cmp	r3, #0
 8024546:	d0c5      	beq.n	80244d4 <protocol_run+0x6c>
 8024548:	e7a0      	b.n	802448c <protocol_run+0x24>
 802454a:	89a3      	ldrh	r3, [r4, #12]
 802454c:	2b00      	cmp	r3, #0
 802454e:	d0c1      	beq.n	80244d4 <protocol_run+0x6c>
 8024550:	e79c      	b.n	802448c <protocol_run+0x24>

        case PROTOCOL_STATE_RECEIVING_PAYLOAD:
            if (instance.num_bytes_awaited == 0)
            {
                /* prepare for receiving message tail */
                instance.receive_pointer = instance.message_frame + 4;
 8024552:	f103 0018 	add.w	r0, r3, #24
                instance.num_bytes_awaited = 2;
 8024556:	2102      	movs	r1, #2
                instance.state = PROTOCOL_STATE_RECEIVING_TAIL;
 8024558:	2203      	movs	r2, #3

        case PROTOCOL_STATE_RECEIVING_PAYLOAD:
            if (instance.num_bytes_awaited == 0)
            {
                /* prepare for receiving message tail */
                instance.receive_pointer = instance.message_frame + 4;
 802455a:	6098      	str	r0, [r3, #8]
                instance.num_bytes_awaited = 2;
 802455c:	8199      	strh	r1, [r3, #12]
                instance.state = PROTOCOL_STATE_RECEIVING_TAIL;
 802455e:	715a      	strb	r2, [r3, #5]

                /* try to read payload */
                receive_data();
 8024560:	f7ff ff26 	bl	80243b0 <receive_data>
                 */
                break;
            }

        case PROTOCOL_STATE_RECEIVING_TAIL:
            if (instance.num_bytes_awaited == 0)
 8024564:	89a3      	ldrh	r3, [r4, #12]
 8024566:	4e63      	ldr	r6, [pc, #396]	; (80246f4 <protocol_run+0x28c>)
 8024568:	2b00      	cmp	r3, #0
 802456a:	d1ad      	bne.n	80244c8 <protocol_run+0x60>
                      ((uint16_t)payload[offset    ]));
}

static inline uint16_t rd_payload_u16(const uint8_t* payload, size_t offset)
{
    return (((uint16_t)payload[offset + 1]) <<  8) |
 802456c:	7e71      	ldrb	r1, [r6, #25]
 802456e:	7e33      	ldrb	r3, [r6, #24]
 *
 * \return The function returns the value read from the payload.
 */
static inline uint8_t rd_payload_u8(const uint8_t* payload, size_t offset)
{
    return payload[offset];
 8024570:	7d77      	ldrb	r7, [r6, #21]
                      ((uint16_t)payload[offset    ]));
}

static inline uint16_t rd_payload_u16(const uint8_t* payload, size_t offset)
{
    return (((uint16_t)payload[offset + 1]) <<  8) |
 8024572:	7df0      	ldrb	r0, [r6, #23]
            ((uint16_t)payload[offset    ]);
 8024574:	7db2      	ldrb	r2, [r6, #22]
                      ((uint16_t)payload[offset    ]));
}

static inline uint16_t rd_payload_u16(const uint8_t* payload, size_t offset)
{
    return (((uint16_t)payload[offset + 1]) <<  8) |
 8024576:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
                endpoint     = rd_payload_u8 (instance.message_frame, 1);
                payload_size = rd_payload_u16(instance.message_frame, 2);
                end_sequence = rd_payload_u16(instance.message_frame, 4);

                /* check end of payload sequence */
                if (end_sequence != CNST_END_OF_PAYLOAD)
 802457a:	f24e 01db 	movw	r1, #57563	; 0xe0db
 802457e:	428b      	cmp	r3, r1
 8024580:	d01b      	beq.n	80245ba <protocol_run+0x152>
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024582:	ad12      	add	r5, sp, #72	; 0x48
 8024584:	4b5f      	ldr	r3, [pc, #380]	; (8024704 <protocol_run+0x29c>)
 8024586:	e795      	b.n	80244b4 <protocol_run+0x4c>
                      instance.state = PROTOCOL_STATE_CONFUSED;
                      send_status_message(0, PROTOCOL_ERROR_OUT_OF_MEMORY);
                      break;
                    }

                    instance.receive_pointer = instance.payload;
 8024588:	69f1      	ldr	r1, [r6, #28]
                    instance.num_bytes_awaited = payload_size;
 802458a:	81b2      	strh	r2, [r6, #12]
                    instance.state = PROTOCOL_STATE_RECEIVING_PAYLOAD;
 802458c:	2302      	movs	r3, #2
                      instance.state = PROTOCOL_STATE_CONFUSED;
                      send_status_message(0, PROTOCOL_ERROR_OUT_OF_MEMORY);
                      break;
                    }

                    instance.receive_pointer = instance.payload;
 802458e:	60b1      	str	r1, [r6, #8]
                    instance.num_bytes_awaited = payload_size;
                    instance.state = PROTOCOL_STATE_RECEIVING_PAYLOAD;
 8024590:	7173      	strb	r3, [r6, #5]
                    send_status_message(0, PROTOCOL_ERROR_BAD_ENDPOINT_ID);
                    break;
                }

                /* try to read payload */
                receive_data();
 8024592:	f7ff ff0d 	bl	80243b0 <receive_data>
                 */
                break;
            }

        case PROTOCOL_STATE_RECEIVING_PAYLOAD:
            if (instance.num_bytes_awaited == 0)
 8024596:	89a2      	ldrh	r2, [r4, #12]
 8024598:	4b56      	ldr	r3, [pc, #344]	; (80246f4 <protocol_run+0x28c>)
 802459a:	2a00      	cmp	r2, #0
 802459c:	d0d9      	beq.n	8024552 <protocol_run+0xea>
 802459e:	795b      	ldrb	r3, [r3, #5]
 80245a0:	e793      	b.n	80244ca <protocol_run+0x62>
                    send_status_message(0, PROTOCOL_ERROR_BAD_MESSAGE_START);
                    break;
                }

                /* check message header for endpoint number */
                if (endpoint <= instance.num_endpoints)
 80245a2:	7933      	ldrb	r3, [r6, #4]
 80245a4:	4283      	cmp	r3, r0
 80245a6:	d329      	bcc.n	80245fc <protocol_run+0x194>
                {
                    /* check payload size (A message with no payload makes no
                     * sense)
                     */
                    if (payload_size == 0)
 80245a8:	ea52 2201 	orrs.w	r2, r2, r1, lsl #8
 80245ac:	d04a      	beq.n	8024644 <protocol_run+0x1dc>
                        send_status_message(0, PROTOCOL_ERROR_NO_PAYLOAD);
                        break;
                    }

                    /* prepare for receiving payload */
                    if (payload_size > instance.max_payload)
 80245ae:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 80245b0:	429a      	cmp	r2, r3
 80245b2:	d9e9      	bls.n	8024588 <protocol_run+0x120>
 80245b4:	ad12      	add	r5, sp, #72	; 0x48
 80245b6:	4b54      	ldr	r3, [pc, #336]	; (8024708 <protocol_run+0x2a0>)
 80245b8:	e77c      	b.n	80244b4 <protocol_run+0x4c>
                      ((uint16_t)payload[offset    ]));
}

static inline uint16_t rd_payload_u16(const uint8_t* payload, size_t offset)
{
    return (((uint16_t)payload[offset + 1]) <<  8) |
 80245ba:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
         	  /********** TIMING DEBUG - Protocol Start *************/
          	  #ifdef TIMING_DEBUG
                  	//DIGITAL_IO_SetOutputLow(&DIGITAL_IO_ARD_D9);
          	  #endif

                if (endpoint != 0)
 80245be:	b307      	cbz	r7, 8024602 <protocol_run+0x19a>
                    Endpoint_t* current_ep;

                    /* now send the payload package to the addressed endpoint
                     * and send the status code back
                     */
                    current_ep = &(instance.endpoints[endpoint-1]);
 80245c0:	6835      	ldr	r5, [r6, #0]
                    status_code = current_ep->handle_message(endpoint,
 80245c2:	69f1      	ldr	r1, [r6, #28]
                    Endpoint_t* current_ep;

                    /* now send the payload package to the addressed endpoint
                     * and send the status code back
                     */
                    current_ep = &(instance.endpoints[endpoint-1]);
 80245c4:	2014      	movs	r0, #20
 80245c6:	f06f 0313 	mvn.w	r3, #19
 80245ca:	fb10 3307 	smlabb	r3, r0, r7, r3
 80245ce:	442b      	add	r3, r5
                    status_code = current_ep->handle_message(endpoint,
 80245d0:	4638      	mov	r0, r7
 80245d2:	689d      	ldr	r5, [r3, #8]
 80245d4:	68db      	ldr	r3, [r3, #12]
 80245d6:	47a8      	blx	r5
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 80245d8:	225b      	movs	r2, #91	; 0x5b
 80245da:	4603      	mov	r3, r0
}

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 80245dc:	0a05      	lsrs	r5, r0, #8
    wr_payload_u8 (status_message, 0, CNST_STARTBYTE_STATUS);
    wr_payload_u8 (status_message, 1, endpoint);
    wr_payload_u16(status_message, 2, status_code);

    /* now send message */
    com_send_data(status_message, sizeof(status_message));
 80245de:	2104      	movs	r1, #4
 80245e0:	a802      	add	r0, sp, #8
    payload[offset    ] =  value        & 0xFF;
 80245e2:	f88d 300a 	strb.w	r3, [sp, #10]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 80245e6:	f88d 2008 	strb.w	r2, [sp, #8]
}

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 80245ea:	f88d 500b 	strb.w	r5, [sp, #11]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 80245ee:	f88d 7009 	strb.w	r7, [sp, #9]
 80245f2:	f004 fbdb 	bl	8028dac <com_send_data>
    com_flush();
 80245f6:	f004 fbeb 	bl	8028dd0 <com_flush>
 80245fa:	e793      	b.n	8024524 <protocol_run+0xbc>
 80245fc:	ad12      	add	r5, sp, #72	; 0x48
 80245fe:	4b43      	ldr	r3, [pc, #268]	; (802470c <protocol_run+0x2a4>)
 8024600:	e758      	b.n	80244b4 <protocol_run+0x4c>
 8024602:	69f3      	ldr	r3, [r6, #28]
 8024604:	f893 8000 	ldrb.w	r8, [r3]
//============================================================================

static uint16_t handle_message(uint8_t *message_data, uint16_t num_bytes)
{
    /* check command byte of received message */
    switch (message_data[0])
 8024608:	f1b8 0f01 	cmp.w	r8, #1
 802460c:	f000 8082 	beq.w	8024714 <protocol_run+0x2ac>
 8024610:	d31b      	bcc.n	802464a <protocol_run+0x1e2>
 8024612:	f1b8 0f02 	cmp.w	r8, #2
 8024616:	d102      	bne.n	802461e <protocol_run+0x1b6>
            return PROTOCOL_ERROR_OK;
        }
        break;

    case CNST_MSG_FIRMWARE_RESET:
        if (num_bytes == 1)
 8024618:	2a01      	cmp	r2, #1
 802461a:	f000 80cc 	beq.w	80247b6 <protocol_run+0x34e>
        {
            /* if user did not set system reset function, this feature is not
             * supported.
             */
            if (instance.do_system_reset == NULL)
 802461e:	27ff      	movs	r7, #255	; 0xff
 8024620:	ad02      	add	r5, sp, #8
 8024622:	225b      	movs	r2, #91	; 0x5b
 8024624:	2300      	movs	r3, #0
    wr_payload_u8 (status_message, 0, CNST_STARTBYTE_STATUS);
    wr_payload_u8 (status_message, 1, endpoint);
    wr_payload_u16(status_message, 2, status_code);

    /* now send message */
    com_send_data(status_message, sizeof(status_message));
 8024626:	4628      	mov	r0, r5
 8024628:	2104      	movs	r1, #4
 802462a:	f88d 2008 	strb.w	r2, [sp, #8]
 802462e:	f88d 3009 	strb.w	r3, [sp, #9]
}

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024632:	f88d 700b 	strb.w	r7, [sp, #11]
    payload[offset    ] =  value        & 0xFF;
 8024636:	f88d 700a 	strb.w	r7, [sp, #10]
 802463a:	f004 fbb7 	bl	8028dac <com_send_data>
    com_flush();
 802463e:	f004 fbc7 	bl	8028dd0 <com_flush>
 8024642:	e76f      	b.n	8024524 <protocol_run+0xbc>
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024644:	ad12      	add	r5, sp, #72	; 0x48
 8024646:	4b32      	ldr	r3, [pc, #200]	; (8024710 <protocol_run+0x2a8>)
 8024648:	e734      	b.n	80244b4 <protocol_run+0x4c>
{
    /* check command byte of received message */
    switch (message_data[0])
    {
    case CNST_MSG_QUERY_ENDPOINT_INFO:
        if (num_bytes == 1)
 802464a:	2a01      	cmp	r2, #1
 802464c:	d1e7      	bne.n	802461e <protocol_run+0x1b6>
    uint8_t i;

    /* setup message start (type und number of endpoints */
    uint8_t message_header[2];
    wr_payload_u8(message_header, 0, CNST_MSG_ENDPOINT_INFO);
    wr_payload_u8(message_header, 1, instance.num_endpoints);
 802464e:	7932      	ldrb	r2, [r6, #4]
 8024650:	f88d 2005 	strb.w	r2, [sp, #5]

    /* calculate message size and send start of message */
    protocol_send_header(0, 6 * instance.num_endpoints +
 8024654:	eb02 0342 	add.w	r3, r2, r2, lsl #1
 8024658:	005b      	lsls	r3, r3, #1
 802465a:	3302      	adds	r3, #2
 802465c:	b29b      	uxth	r3, r3
    uint8_t header[4];
    wr_payload_u8 (header, 0, CNST_STARTBYTE_DATA);
    wr_payload_u8 (header, 1, endpoint);
    wr_payload_u16(header, 2, num_bytes);

    com_send_data(header, sizeof(header));
 802465e:	ad02      	add	r5, sp, #8
}

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024660:	ea4f 2c13 	mov.w	ip, r3, lsr #8
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024664:	f04f 0e5a 	mov.w	lr, #90	; 0x5a
 8024668:	4628      	mov	r0, r5
 802466a:	2104      	movs	r1, #4

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 802466c:	f88d 300a 	strb.w	r3, [sp, #10]
}

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024670:	f88d c00b 	strb.w	ip, [sp, #11]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024674:	f88d e008 	strb.w	lr, [sp, #8]
 8024678:	f88d 7004 	strb.w	r7, [sp, #4]
 802467c:	f88d 7009 	strb.w	r7, [sp, #9]
 8024680:	f004 fb94 	bl	8028dac <com_send_data>
}

void protocol_send_payload(const uint8_t *message_data, uint16_t num_bytes)
{
    /* send the data through the communication stream interface */
    com_send_data(message_data, num_bytes);
 8024684:	a801      	add	r0, sp, #4
 8024686:	2102      	movs	r1, #2
 8024688:	f004 fb90 	bl	8028dac <com_send_data>
    protocol_send_header(0, 6 * instance.num_endpoints +
                            sizeof(message_header));
    protocol_send_payload(message_header, sizeof(message_header));

    /* now send type and version for each endpoint */
    for (i = 0; i < instance.num_endpoints; ++i)
 802468c:	7933      	ldrb	r3, [r6, #4]
 802468e:	b30b      	cbz	r3, 80246d4 <protocol_run+0x26c>
    {
        uint8_t ep_info[6];
        wr_payload_u32(ep_info, 0, instance.endpoints[i].endpoint_type);
 8024690:	b23a      	sxth	r2, r7
 8024692:	6821      	ldr	r1, [r4, #0]
 8024694:	eb02 0282 	add.w	r2, r2, r2, lsl #2
    protocol_send_header(0, 6 * instance.num_endpoints +
                            sizeof(message_header));
    protocol_send_payload(message_header, sizeof(message_header));

    /* now send type and version for each endpoint */
    for (i = 0; i < instance.num_endpoints; ++i)
 8024698:	3701      	adds	r7, #1
    {
        uint8_t ep_info[6];
        wr_payload_u32(ep_info, 0, instance.endpoints[i].endpoint_type);
 802469a:	f851 3022 	ldr.w	r3, [r1, r2, lsl #2]
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
    payload[offset + 2] = (value >> 16) & 0xFF;
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 802469e:	f88d 3008 	strb.w	r3, [sp, #8]
 80246a2:	eb01 0282 	add.w	r2, r1, r2, lsl #2
}

static inline size_t wr_payload_u32(uint8_t* payload, size_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 80246a6:	0e18      	lsrs	r0, r3, #24
    payload[offset + 2] = (value >> 16) & 0xFF;
 80246a8:	0c19      	lsrs	r1, r3, #16
    payload[offset + 1] = (value >>  8) & 0xFF;
 80246aa:	0a1b      	lsrs	r3, r3, #8
}

static inline size_t wr_payload_u32(uint8_t* payload, size_t offset,
                                  uint32_t value)
{
    payload[offset + 3] = (value >> 24) & 0xFF;
 80246ac:	f88d 000b 	strb.w	r0, [sp, #11]
    payload[offset + 2] = (value >> 16) & 0xFF;
 80246b0:	f88d 100a 	strb.w	r1, [sp, #10]
    payload[offset + 1] = (value >>  8) & 0xFF;
 80246b4:	f88d 3009 	strb.w	r3, [sp, #9]
        wr_payload_u16(ep_info, 4, instance.endpoints[i].endpoint_version);
 80246b8:	8893      	ldrh	r3, [r2, #4]

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 80246ba:	f88d 300c 	strb.w	r3, [sp, #12]
}

void protocol_send_payload(const uint8_t *message_data, uint16_t num_bytes)
{
    /* send the data through the communication stream interface */
    com_send_data(message_data, num_bytes);
 80246be:	4628      	mov	r0, r5
}

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 80246c0:	0a1b      	lsrs	r3, r3, #8
 80246c2:	2106      	movs	r1, #6
 80246c4:	f88d 300d 	strb.w	r3, [sp, #13]
 80246c8:	f004 fb70 	bl	8028dac <com_send_data>
    protocol_send_header(0, 6 * instance.num_endpoints +
                            sizeof(message_header));
    protocol_send_payload(message_header, sizeof(message_header));

    /* now send type and version for each endpoint */
    for (i = 0; i < instance.num_endpoints; ++i)
 80246cc:	7923      	ldrb	r3, [r4, #4]
 80246ce:	b2ff      	uxtb	r7, r7
 80246d0:	42bb      	cmp	r3, r7
 80246d2:	d8dd      	bhi.n	8024690 <protocol_run+0x228>
 80246d4:	22e0      	movs	r2, #224	; 0xe0
    payload[offset    ] =  value        & 0xFF;
 80246d6:	23db      	movs	r3, #219	; 0xdb
{
    /* setup message tail and send it */
    uint8_t tail[2];
    wr_payload_u16(tail, 0, CNST_END_OF_PAYLOAD);

    com_send_data(tail, sizeof(tail));
 80246d8:	4628      	mov	r0, r5
 80246da:	2102      	movs	r1, #2
}

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 80246dc:	f88d 2009 	strb.w	r2, [sp, #9]
    payload[offset    ] =  value        & 0xFF;
 80246e0:	f88d 3008 	strb.w	r3, [sp, #8]
        if (num_bytes == 1)
        {
            send_endpoint_info();
            {
            	extern void app_reset_protocol(void);
            	app_reset_protocol();
 80246e4:	4647      	mov	r7, r8
{
    /* setup message tail and send it */
    uint8_t tail[2];
    wr_payload_u16(tail, 0, CNST_END_OF_PAYLOAD);

    com_send_data(tail, sizeof(tail));
 80246e6:	f004 fb61 	bl	8028dac <com_send_data>
    com_flush();
 80246ea:	f004 fb71 	bl	8028dd0 <com_flush>
        if (num_bytes == 1)
        {
            send_endpoint_info();
            {
            	extern void app_reset_protocol(void);
            	app_reset_protocol();
 80246ee:	f005 fe9b 	bl	802a428 <app_reset_protocol>
 80246f2:	e796      	b.n	8024622 <protocol_run+0x1ba>
 80246f4:	1ffeb1f0 	.word	0x1ffeb1f0
 80246f8:	0002005b 	.word	0x0002005b
 80246fc:	0001005b 	.word	0x0001005b
 8024700:	1ffeb204 	.word	0x1ffeb204
 8024704:	0007005b 	.word	0x0007005b
 8024708:	0006005b 	.word	0x0006005b
 802470c:	0003005b 	.word	0x0003005b
 8024710:	0005005b 	.word	0x0005005b
            return PROTOCOL_ERROR_OK;
        }
        break;

    case CNST_MSG_QUERY_FW_INFO:
        if (num_bytes == 1)
 8024714:	2a01      	cmp	r2, #1
 8024716:	d182      	bne.n	802461e <protocol_run+0x1b6>
    uint16_t string_length = 0;

    /* setup message start (type and number of endpoints */
    uint8_t message[7];
    wr_payload_u8 (message, 0, CNST_MSG_FW_INFO);
    wr_payload_u16(message, 1, firmware_information.version_major);
 8024718:	f8df 80bc 	ldr.w	r8, [pc, #188]	; 80247d8 <protocol_run+0x370>
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 802471c:	f88d 2008 	strb.w	r2, [sp, #8]
 8024720:	f8b8 3004 	ldrh.w	r3, [r8, #4]
    wr_payload_u16(message, 3, firmware_information.version_minor);
 8024724:	f8b8 0006 	ldrh.w	r0, [r8, #6]
    wr_payload_u16(message, 5, firmware_information.version_build);
 8024728:	f8b8 1008 	ldrh.w	r1, [r8, #8]

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 802472c:	f88d 3009 	strb.w	r3, [sp, #9]
}

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024730:	0a06      	lsrs	r6, r0, #8
 8024732:	0a1b      	lsrs	r3, r3, #8

    /* count length of firmware description string */
    while (firmware_information.description[string_length] != 0)
 8024734:	f8d8 2000 	ldr.w	r2, [r8]
 8024738:	f88d 600c 	strb.w	r6, [sp, #12]
 802473c:	0a0d      	lsrs	r5, r1, #8
 802473e:	f88d 300a 	strb.w	r3, [sp, #10]
    payload[offset    ] =  value        & 0xFF;
 8024742:	f88d 000b 	strb.w	r0, [sp, #11]
 8024746:	f88d 100d 	strb.w	r1, [sp, #13]
}

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 802474a:	f88d 500e 	strb.w	r5, [sp, #14]
 802474e:	7813      	ldrb	r3, [r2, #0]
 8024750:	463e      	mov	r6, r7
 8024752:	b123      	cbz	r3, 802475e <protocol_run+0x2f6>
        ++string_length;
 8024754:	3601      	adds	r6, #1
 8024756:	b2b6      	uxth	r6, r6
    wr_payload_u16(message, 1, firmware_information.version_major);
    wr_payload_u16(message, 3, firmware_information.version_minor);
    wr_payload_u16(message, 5, firmware_information.version_build);

    /* count length of firmware description string */
    while (firmware_information.description[string_length] != 0)
 8024758:	5d93      	ldrb	r3, [r2, r6]
 802475a:	2b00      	cmp	r3, #0
 802475c:	d1fa      	bne.n	8024754 <protocol_run+0x2ec>
        ++string_length;
    ++string_length;

    /* send message */
    protocol_send_header(0, sizeof(message) + string_length);
 802475e:	f106 0308 	add.w	r3, r6, #8
 8024762:	b29b      	uxth	r3, r3
 8024764:	ea4f 2c13 	mov.w	ip, r3, lsr #8
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 8024768:	f04f 0e5a 	mov.w	lr, #90	; 0x5a
 802476c:	2200      	movs	r2, #0
    uint8_t header[4];
    wr_payload_u8 (header, 0, CNST_STARTBYTE_DATA);
    wr_payload_u8 (header, 1, endpoint);
    wr_payload_u16(header, 2, num_bytes);

    com_send_data(header, sizeof(header));
 802476e:	a801      	add	r0, sp, #4
 8024770:	2104      	movs	r1, #4
}

void protocol_send_payload(const uint8_t *message_data, uint16_t num_bytes)
{
    /* send the data through the communication stream interface */
    com_send_data(message_data, num_bytes);
 8024772:	ad02      	add	r5, sp, #8

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 8024774:	f88d 3006 	strb.w	r3, [sp, #6]
}

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024778:	f88d c007 	strb.w	ip, [sp, #7]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 802477c:	f88d e004 	strb.w	lr, [sp, #4]
 8024780:	f88d 2005 	strb.w	r2, [sp, #5]
    uint8_t header[4];
    wr_payload_u8 (header, 0, CNST_STARTBYTE_DATA);
    wr_payload_u8 (header, 1, endpoint);
    wr_payload_u16(header, 2, num_bytes);

    com_send_data(header, sizeof(header));
 8024784:	f004 fb12 	bl	8028dac <com_send_data>
}

void protocol_send_payload(const uint8_t *message_data, uint16_t num_bytes)
{
    /* send the data through the communication stream interface */
    com_send_data(message_data, num_bytes);
 8024788:	4628      	mov	r0, r5
 802478a:	2107      	movs	r1, #7
 802478c:	f004 fb0e 	bl	8028dac <com_send_data>
    wr_payload_u16(message, 5, firmware_information.version_build);

    /* count length of firmware description string */
    while (firmware_information.description[string_length] != 0)
        ++string_length;
    ++string_length;
 8024790:	1c71      	adds	r1, r6, #1
}

void protocol_send_payload(const uint8_t *message_data, uint16_t num_bytes)
{
    /* send the data through the communication stream interface */
    com_send_data(message_data, num_bytes);
 8024792:	f8d8 0000 	ldr.w	r0, [r8]
 8024796:	b289      	uxth	r1, r1
 8024798:	f004 fb08 	bl	8028dac <com_send_data>
}

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 802479c:	22e0      	movs	r2, #224	; 0xe0
    payload[offset    ] =  value        & 0xFF;
 802479e:	23db      	movs	r3, #219	; 0xdb
{
    /* setup message tail and send it */
    uint8_t tail[2];
    wr_payload_u16(tail, 0, CNST_END_OF_PAYLOAD);

    com_send_data(tail, sizeof(tail));
 80247a0:	a801      	add	r0, sp, #4
 80247a2:	2102      	movs	r1, #2
}

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 80247a4:	f88d 2005 	strb.w	r2, [sp, #5]
    payload[offset    ] =  value        & 0xFF;
 80247a8:	f88d 3004 	strb.w	r3, [sp, #4]
 80247ac:	f004 fafe 	bl	8028dac <com_send_data>
    com_flush();
 80247b0:	f004 fb0e 	bl	8028dd0 <com_flush>
 80247b4:	e735      	b.n	8024622 <protocol_run+0x1ba>
        if (num_bytes == 1)
        {
            /* if user did not set system reset function, this feature is not
             * supported.
             */
            if (instance.do_system_reset == NULL)
 80247b6:	6ab3      	ldr	r3, [r6, #40]	; 0x28
 80247b8:	2b00      	cmp	r3, #0
 80247ba:	f43f af30 	beq.w	802461e <protocol_run+0x1b6>
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 80247be:	ad12      	add	r5, sp, #72	; 0x48
 80247c0:	235b      	movs	r3, #91	; 0x5b
 80247c2:	f845 3d40 	str.w	r3, [r5, #-64]!
    wr_payload_u8 (status_message, 0, CNST_STARTBYTE_STATUS);
    wr_payload_u8 (status_message, 1, endpoint);
    wr_payload_u16(status_message, 2, status_code);

    /* now send message */
    com_send_data(status_message, sizeof(status_message));
 80247c6:	2104      	movs	r1, #4
 80247c8:	4628      	mov	r0, r5
 80247ca:	f004 faef 	bl	8028dac <com_send_data>
    com_flush();
 80247ce:	f004 faff 	bl	8028dd0 <com_flush>
             * possible.
             */
            send_status_message(0, PROTOCOL_ERROR_OK);

            /* now do the system reset */
            instance.do_system_reset();
 80247d2:	6ab3      	ldr	r3, [r6, #40]	; 0x28
 80247d4:	4798      	blx	r3
 80247d6:	e724      	b.n	8024622 <protocol_run+0x1ba>
 80247d8:	1ffe960c 	.word	0x1ffe960c

080247dc <protocol_send_header>:
}

//============================================================================

void protocol_send_header(uint8_t endpoint, uint16_t num_bytes)
{
 80247dc:	b510      	push	{r4, lr}
 80247de:	b082      	sub	sp, #8
 80247e0:	460b      	mov	r3, r1
}

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 80247e2:	0a0c      	lsrs	r4, r1, #8
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 80247e4:	f88d 0005 	strb.w	r0, [sp, #5]
 80247e8:	225a      	movs	r2, #90	; 0x5a
    uint8_t header[4];
    wr_payload_u8 (header, 0, CNST_STARTBYTE_DATA);
    wr_payload_u8 (header, 1, endpoint);
    wr_payload_u16(header, 2, num_bytes);

    com_send_data(header, sizeof(header));
 80247ea:	a801      	add	r0, sp, #4
 80247ec:	2104      	movs	r1, #4

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 80247ee:	f88d 3006 	strb.w	r3, [sp, #6]
}

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 80247f2:	f88d 4007 	strb.w	r4, [sp, #7]
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 80247f6:	f88d 2004 	strb.w	r2, [sp, #4]
 80247fa:	f004 fad7 	bl	8028dac <com_send_data>
}
 80247fe:	b002      	add	sp, #8
 8024800:	bd10      	pop	{r4, pc}
 8024802:	bf00      	nop

08024804 <protocol_send_payload>:

void protocol_send_payload(const uint8_t *message_data, uint16_t num_bytes)
{
    /* send the data through the communication stream interface */
    com_send_data(message_data, num_bytes);
 8024804:	f004 bad2 	b.w	8028dac <com_send_data>

08024808 <protocol_send_tail>:
}

void protocol_send_tail(void)
{
 8024808:	b500      	push	{lr}
 802480a:	b083      	sub	sp, #12

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
    payload[offset    ] =  value        & 0xFF;
 802480c:	a802      	add	r0, sp, #8
 802480e:	23db      	movs	r3, #219	; 0xdb
 8024810:	f800 3d04 	strb.w	r3, [r0, #-4]!
    /* setup message tail and send it */
    uint8_t tail[2];
    wr_payload_u16(tail, 0, CNST_END_OF_PAYLOAD);

    com_send_data(tail, sizeof(tail));
 8024814:	2102      	movs	r1, #2
}

static inline size_t wr_payload_u16(uint8_t* payload, size_t offset,
                                  uint16_t value)
{
    payload[offset + 1] = (value >>  8) & 0xFF;
 8024816:	23e0      	movs	r3, #224	; 0xe0
 8024818:	f88d 3005 	strb.w	r3, [sp, #5]
 802481c:	f004 fac6 	bl	8028dac <com_send_data>
    com_flush();
 8024820:	f004 fad6 	bl	8028dd0 <com_flush>
}
 8024824:	b003      	add	sp, #12
 8024826:	f85d fb04 	ldr.w	pc, [sp], #4
 802482a:	bf00      	nop

0802482c <protocol_broadcast_change>:

//============================================================================

void protocol_broadcast_change(void* context, uint32_t what)
{
 802482c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    uint8_t i;

    /* broadcast change notification to all endpoints that have a
     * handle_change function
     */
    for (i = 0; i < instance.num_endpoints; ++i)
 8024830:	4d16      	ldr	r5, [pc, #88]	; (802488c <protocol_broadcast_change+0x60>)
 8024832:	f895 e004 	ldrb.w	lr, [r5, #4]
 8024836:	f1be 0f00 	cmp.w	lr, #0
 802483a:	d01c      	beq.n	8024876 <protocol_broadcast_change+0x4a>
 802483c:	4689      	mov	r9, r1
 802483e:	4606      	mov	r6, r0
 8024840:	2401      	movs	r4, #1
    {
        if ((instance.endpoints[i].handle_change) &&
 8024842:	46a8      	mov	r8, r5
 8024844:	e006      	b.n	8024854 <protocol_broadcast_change+0x28>
 8024846:	68db      	ldr	r3, [r3, #12]
 8024848:	42b3      	cmp	r3, r6
 802484a:	d016      	beq.n	802487a <protocol_broadcast_change+0x4e>
 802484c:	3401      	adds	r4, #1
    uint8_t i;

    /* broadcast change notification to all endpoints that have a
     * handle_change function
     */
    for (i = 0; i < instance.num_endpoints; ++i)
 802484e:	4572      	cmp	r2, lr
 8024850:	b2e4      	uxtb	r4, r4
 8024852:	d210      	bcs.n	8024876 <protocol_broadcast_change+0x4a>
 8024854:	1e63      	subs	r3, r4, #1
    {
        if ((instance.endpoints[i].handle_change) &&
 8024856:	682a      	ldr	r2, [r5, #0]
 8024858:	b2db      	uxtb	r3, r3
 802485a:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 802485e:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8024862:	4622      	mov	r2, r4
 8024864:	691f      	ldr	r7, [r3, #16]
 8024866:	2f00      	cmp	r7, #0
 8024868:	d1ed      	bne.n	8024846 <protocol_broadcast_change+0x1a>
 802486a:	4622      	mov	r2, r4
    uint8_t i;

    /* broadcast change notification to all endpoints that have a
     * handle_change function
     */
    for (i = 0; i < instance.num_endpoints; ++i)
 802486c:	4572      	cmp	r2, lr
 802486e:	f104 0401 	add.w	r4, r4, #1
 8024872:	b2e4      	uxtb	r4, r4
 8024874:	d3ee      	bcc.n	8024854 <protocol_broadcast_change+0x28>
 8024876:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    {
        if ((instance.endpoints[i].handle_change) &&
            (instance.endpoints[i].context == context))
        {
            instance.endpoints[i].handle_change(i + 1, context, what);
 802487a:	464a      	mov	r2, r9
 802487c:	4620      	mov	r0, r4
 802487e:	4631      	mov	r1, r6
 8024880:	47b8      	blx	r7
 8024882:	f898 e004 	ldrb.w	lr, [r8, #4]
 8024886:	4622      	mov	r2, r4
 8024888:	e7e0      	b.n	802484c <protocol_broadcast_change+0x20>
 802488a:	bf00      	nop
 802488c:	1ffeb1f0 	.word	0x1ffeb1f0

08024890 <wr_payload_float>:
#define STATIC_ASSERT(test_for_true) _Static_assert((test_for_true), "(" #test_for_true ") failed")
#endif


size_t wr_payload_float(uint8_t* payload, size_t offset, float value)
{
 8024890:	b410      	push	{r4}
 8024892:	b083      	sub	sp, #12
		uint32_t u32_value;
		float float_value;
	} temp_union;

	temp_union data;
	data.float_value = value;
 8024894:	ab02      	add	r3, sp, #8
#define STATIC_ASSERT(test_for_true) _Static_assert((test_for_true), "(" #test_for_true ") failed")
#endif


size_t wr_payload_float(uint8_t* payload, size_t offset, float value)
{
 8024896:	4604      	mov	r4, r0
		uint32_t u32_value;
		float float_value;
	} temp_union;

	temp_union data;
	data.float_value = value;
 8024898:	f843 2d04 	str.w	r2, [r3, #-4]!

	memcpy(&payload[offset], &data.u32_value, sizeof(uint32_t));
 802489c:	6818      	ldr	r0, [r3, #0]
 802489e:	5060      	str	r0, [r4, r1]
    return sizeof(uint32_t);
}
 80248a0:	2004      	movs	r0, #4
 80248a2:	b003      	add	sp, #12
 80248a4:	f85d 4b04 	ldr.w	r4, [sp], #4
 80248a8:	4770      	bx	lr
 80248aa:	bf00      	nop

080248ac <wr_payload_string>:


size_t wr_payload_string(uint8_t *payload, size_t offset, char const *ptr)
{
 80248ac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80248ae:	4606      	mov	r6, r0
 80248b0:	460d      	mov	r5, r1
	size_t increment = 0;
	if (ptr)
 80248b2:	4614      	mov	r4, r2
 80248b4:	2a00      	cmp	r2, #0
 80248b6:	d056      	beq.n	8024966 <wr_payload_string+0xba>
	{
		uint8_t len = strlen(ptr);
 80248b8:	4610      	mov	r0, r2
 80248ba:	f009 f9d1 	bl	802dc60 <strlen>
 80248be:	5570      	strb	r0, [r6, r5]
		increment += wr_payload_u8(payload, offset + increment, len);  // attach the str len
		for(int k = 0; k < len; k++)
 80248c0:	f010 00ff 	ands.w	r0, r0, #255	; 0xff
 * \param[in] value    The value to be written into the payload buffer.
 */
static inline size_t wr_payload_u8(uint8_t* payload, size_t offset,
                                 uint8_t value)
{
    payload[offset] = value;
 80248c4:	eb06 0305 	add.w	r3, r6, r5
 80248c8:	d050      	beq.n	802496c <wr_payload_string+0xc0>
 80248ca:	1c6a      	adds	r2, r5, #1
 80248cc:	4432      	add	r2, r6
 80248ce:	ea44 0702 	orr.w	r7, r4, r2
 80248d2:	1d69      	adds	r1, r5, #5
 80248d4:	f017 0f03 	tst.w	r7, #3
 80248d8:	eb06 0701 	add.w	r7, r6, r1
 80248dc:	f104 0104 	add.w	r1, r4, #4
 80248e0:	bf0c      	ite	eq
 80248e2:	f04f 0e01 	moveq.w	lr, #1
 80248e6:	f04f 0e00 	movne.w	lr, #0
 80248ea:	42bc      	cmp	r4, r7
 80248ec:	bf38      	it	cc
 80248ee:	428a      	cmpcc	r2, r1
 80248f0:	bf2c      	ite	cs
 80248f2:	2101      	movcs	r1, #1
 80248f4:	2100      	movcc	r1, #0
 80248f6:	ea1e 0f01 	tst.w	lr, r1
 80248fa:	d029      	beq.n	8024950 <wr_payload_string+0xa4>
 80248fc:	2809      	cmp	r0, #9
 80248fe:	d927      	bls.n	8024950 <wr_payload_string+0xa4>
 8024900:	1f03      	subs	r3, r0, #4
 8024902:	089b      	lsrs	r3, r3, #2
 8024904:	3301      	adds	r3, #1
 8024906:	0099      	lsls	r1, r3, #2
 8024908:	f1a4 0e04 	sub.w	lr, r4, #4
 802490c:	2700      	movs	r7, #0
 802490e:	3701      	adds	r7, #1
		{
			increment += wr_payload_u8(payload, offset + increment, ptr[k]);
 8024910:	f85e cf04 	ldr.w	ip, [lr, #4]!
 8024914:	f842 cb04 	str.w	ip, [r2], #4
 8024918:	42bb      	cmp	r3, r7
 802491a:	d8f8      	bhi.n	802490e <wr_payload_string+0x62>
 802491c:	4288      	cmp	r0, r1
 802491e:	f101 0201 	add.w	r2, r1, #1
 8024922:	d013      	beq.n	802494c <wr_payload_string+0xa0>
 8024924:	18b7      	adds	r7, r6, r2
 8024926:	f814 e023 	ldrb.w	lr, [r4, r3, lsl #2]
 802492a:	f807 e005 	strb.w	lr, [r7, r5]
	size_t increment = 0;
	if (ptr)
	{
		uint8_t len = strlen(ptr);
		increment += wr_payload_u8(payload, offset + increment, len);  // attach the str len
		for(int k = 0; k < len; k++)
 802492e:	4282      	cmp	r2, r0
		{
			increment += wr_payload_u8(payload, offset + increment, ptr[k]);
 8024930:	f101 0302 	add.w	r3, r1, #2
	size_t increment = 0;
	if (ptr)
	{
		uint8_t len = strlen(ptr);
		increment += wr_payload_u8(payload, offset + increment, len);  // attach the str len
		for(int k = 0; k < len; k++)
 8024934:	da0a      	bge.n	802494c <wr_payload_string+0xa0>
 8024936:	4433      	add	r3, r6
		{
			increment += wr_payload_u8(payload, offset + increment, ptr[k]);
 8024938:	5ca2      	ldrb	r2, [r4, r2]
 802493a:	555a      	strb	r2, [r3, r5]
	size_t increment = 0;
	if (ptr)
	{
		uint8_t len = strlen(ptr);
		increment += wr_payload_u8(payload, offset + increment, len);  // attach the str len
		for(int k = 0; k < len; k++)
 802493c:	1c8b      	adds	r3, r1, #2
 802493e:	4298      	cmp	r0, r3
		{
			increment += wr_payload_u8(payload, offset + increment, ptr[k]);
 8024940:	f101 0103 	add.w	r1, r1, #3
	size_t increment = 0;
	if (ptr)
	{
		uint8_t len = strlen(ptr);
		increment += wr_payload_u8(payload, offset + increment, len);  // attach the str len
		for(int k = 0; k < len; k++)
 8024944:	dd02      	ble.n	802494c <wr_payload_string+0xa0>
 8024946:	4431      	add	r1, r6
		{
			increment += wr_payload_u8(payload, offset + increment, ptr[k]);
 8024948:	5ce3      	ldrb	r3, [r4, r3]
 802494a:	554b      	strb	r3, [r1, r5]
 802494c:	3001      	adds	r0, #1
 802494e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8024950:	4405      	add	r5, r0
 8024952:	442e      	add	r6, r5
 8024954:	3c01      	subs	r4, #1
 8024956:	f814 2f01 	ldrb.w	r2, [r4, #1]!
 802495a:	f803 2f01 	strb.w	r2, [r3, #1]!
	size_t increment = 0;
	if (ptr)
	{
		uint8_t len = strlen(ptr);
		increment += wr_payload_u8(payload, offset + increment, len);  // attach the str len
		for(int k = 0; k < len; k++)
 802495e:	42b3      	cmp	r3, r6
 8024960:	d1f9      	bne.n	8024956 <wr_payload_string+0xaa>
 8024962:	3001      	adds	r0, #1
 8024964:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8024966:	5572      	strb	r2, [r6, r5]
			increment += wr_payload_u8(payload, offset + increment, ptr[k]);
		}
	}
	else
	{
		increment += wr_payload_u8(payload, offset + increment, 0);  // attach the str len 0, to indicate empty string!!
 8024968:	2001      	movs	r0, #1
 802496a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
{
	size_t increment = 0;
	if (ptr)
	{
		uint8_t len = strlen(ptr);
		increment += wr_payload_u8(payload, offset + increment, len);  // attach the str len
 802496c:	2001      	movs	r0, #1
	else
	{
		increment += wr_payload_u8(payload, offset + increment, 0);  // attach the str len 0, to indicate empty string!!
	}
	return increment;
}
 802496e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08024970 <wr_payload_helper_string_list>:


size_t wr_payload_helper_string_list(uint8_t* payload, size_t offset, size_t elements,  char * const *pp_str)
{
 8024970:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8024974:	4681      	mov	r9, r0
 8024976:	b083      	sub	sp, #12
 8024978:	4688      	mov	r8, r1
	size_t increment = 0;
	increment += wr_payload_u8(payload, offset, elements);
 802497a:	5442      	strb	r2, [r0, r1]
	for(int i = 0; i < elements; i++)
 802497c:	2a00      	cmp	r2, #0
 802497e:	d077      	beq.n	8024a70 <wr_payload_helper_string_list+0x100>
 8024980:	2601      	movs	r6, #1
 8024982:	469a      	mov	sl, r3
 8024984:	eb03 0782 	add.w	r7, r3, r2, lsl #2
 8024988:	198b      	adds	r3, r1, r6
 802498a:	9300      	str	r3, [sp, #0]
 802498c:	1d4b      	adds	r3, r1, #5
 802498e:	9301      	str	r3, [sp, #4]
 8024990:	e052      	b.n	8024a38 <wr_payload_helper_string_list+0xc8>
size_t wr_payload_string(uint8_t *payload, size_t offset, char const *ptr)
{
	size_t increment = 0;
	if (ptr)
	{
		uint8_t len = strlen(ptr);
 8024992:	4620      	mov	r0, r4
 8024994:	f009 f964 	bl	802dc60 <strlen>
 8024998:	f809 0005 	strb.w	r0, [r9, r5]
		increment += wr_payload_u8(payload, offset + increment, len);  // attach the str len
		for(int k = 0; k < len; k++)
 802499c:	f010 00ff 	ands.w	r0, r0, #255	; 0xff
 80249a0:	eb09 0305 	add.w	r3, r9, r5
 80249a4:	d062      	beq.n	8024a6c <wr_payload_helper_string_list+0xfc>
 80249a6:	9a00      	ldr	r2, [sp, #0]
 80249a8:	9901      	ldr	r1, [sp, #4]
 80249aa:	4432      	add	r2, r6
 80249ac:	444a      	add	r2, r9
 80249ae:	ea42 0c04 	orr.w	ip, r2, r4
 80249b2:	eb01 0e06 	add.w	lr, r1, r6
 80249b6:	f01c 0f03 	tst.w	ip, #3
 80249ba:	f104 0104 	add.w	r1, r4, #4
 80249be:	44ce      	add	lr, r9
 80249c0:	bf0c      	ite	eq
 80249c2:	f04f 0c01 	moveq.w	ip, #1
 80249c6:	f04f 0c00 	movne.w	ip, #0
 80249ca:	4574      	cmp	r4, lr
 80249cc:	bf38      	it	cc
 80249ce:	428a      	cmpcc	r2, r1
 80249d0:	bf2c      	ite	cs
 80249d2:	2101      	movcs	r1, #1
 80249d4:	2100      	movcc	r1, #0
 80249d6:	ea1c 0f01 	tst.w	ip, r1
 80249da:	d03d      	beq.n	8024a58 <wr_payload_helper_string_list+0xe8>
 80249dc:	2809      	cmp	r0, #9
 80249de:	d93b      	bls.n	8024a58 <wr_payload_helper_string_list+0xe8>
 80249e0:	1f01      	subs	r1, r0, #4
 80249e2:	0889      	lsrs	r1, r1, #2
 80249e4:	3101      	adds	r1, #1
 80249e6:	008d      	lsls	r5, r1, #2
 80249e8:	f1a4 0c04 	sub.w	ip, r4, #4
 80249ec:	f04f 0e00 	mov.w	lr, #0
 80249f0:	469b      	mov	fp, r3
 80249f2:	f10e 0e01 	add.w	lr, lr, #1
		{
			increment += wr_payload_u8(payload, offset + increment, ptr[k]);
 80249f6:	f85c 3f04 	ldr.w	r3, [ip, #4]!
 80249fa:	f842 3b04 	str.w	r3, [r2], #4
 80249fe:	4571      	cmp	r1, lr
 8024a00:	d8f7      	bhi.n	80249f2 <wr_payload_helper_string_list+0x82>
 8024a02:	42a8      	cmp	r0, r5
 8024a04:	465b      	mov	r3, fp
 8024a06:	f105 0201 	add.w	r2, r5, #1
 8024a0a:	d011      	beq.n	8024a30 <wr_payload_helper_string_list+0xc0>
 8024a0c:	f814 1021 	ldrb.w	r1, [r4, r1, lsl #2]
 8024a10:	f80b 1002 	strb.w	r1, [fp, r2]
	size_t increment = 0;
	if (ptr)
	{
		uint8_t len = strlen(ptr);
		increment += wr_payload_u8(payload, offset + increment, len);  // attach the str len
		for(int k = 0; k < len; k++)
 8024a14:	4282      	cmp	r2, r0
		{
			increment += wr_payload_u8(payload, offset + increment, ptr[k]);
 8024a16:	f105 0102 	add.w	r1, r5, #2
	size_t increment = 0;
	if (ptr)
	{
		uint8_t len = strlen(ptr);
		increment += wr_payload_u8(payload, offset + increment, len);  // attach the str len
		for(int k = 0; k < len; k++)
 8024a1a:	da09      	bge.n	8024a30 <wr_payload_helper_string_list+0xc0>
		{
			increment += wr_payload_u8(payload, offset + increment, ptr[k]);
 8024a1c:	5ca2      	ldrb	r2, [r4, r2]
 8024a1e:	f80b 2001 	strb.w	r2, [fp, r1]
	size_t increment = 0;
	if (ptr)
	{
		uint8_t len = strlen(ptr);
		increment += wr_payload_u8(payload, offset + increment, len);  // attach the str len
		for(int k = 0; k < len; k++)
 8024a22:	4288      	cmp	r0, r1
 8024a24:	460a      	mov	r2, r1
		{
			increment += wr_payload_u8(payload, offset + increment, ptr[k]);
 8024a26:	f105 0503 	add.w	r5, r5, #3
	size_t increment = 0;
	if (ptr)
	{
		uint8_t len = strlen(ptr);
		increment += wr_payload_u8(payload, offset + increment, len);  // attach the str len
		for(int k = 0; k < len; k++)
 8024a2a:	dd01      	ble.n	8024a30 <wr_payload_helper_string_list+0xc0>
		{
			increment += wr_payload_u8(payload, offset + increment, ptr[k]);
 8024a2c:	5ca2      	ldrb	r2, [r4, r2]
 8024a2e:	555a      	strb	r2, [r3, r5]
 8024a30:	3001      	adds	r0, #1

size_t wr_payload_helper_string_list(uint8_t* payload, size_t offset, size_t elements,  char * const *pp_str)
{
	size_t increment = 0;
	increment += wr_payload_u8(payload, offset, elements);
	for(int i = 0; i < elements; i++)
 8024a32:	45ba      	cmp	sl, r7
	{
		const char *ptr = pp_str[i];
		increment += wr_payload_string(payload, offset + increment, ptr);
 8024a34:	4406      	add	r6, r0

size_t wr_payload_helper_string_list(uint8_t* payload, size_t offset, size_t elements,  char * const *pp_str)
{
	size_t increment = 0;
	increment += wr_payload_u8(payload, offset, elements);
	for(int i = 0; i < elements; i++)
 8024a36:	d00b      	beq.n	8024a50 <wr_payload_helper_string_list+0xe0>
	{
		const char *ptr = pp_str[i];
 8024a38:	f85a 4b04 	ldr.w	r4, [sl], #4
		increment += wr_payload_string(payload, offset + increment, ptr);
 8024a3c:	eb06 0508 	add.w	r5, r6, r8


size_t wr_payload_string(uint8_t *payload, size_t offset, char const *ptr)
{
	size_t increment = 0;
	if (ptr)
 8024a40:	2c00      	cmp	r4, #0
 8024a42:	d1a6      	bne.n	8024992 <wr_payload_helper_string_list+0x22>
			increment += wr_payload_u8(payload, offset + increment, ptr[k]);
		}
	}
	else
	{
		increment += wr_payload_u8(payload, offset + increment, 0);  // attach the str len 0, to indicate empty string!!
 8024a44:	2001      	movs	r0, #1

size_t wr_payload_helper_string_list(uint8_t* payload, size_t offset, size_t elements,  char * const *pp_str)
{
	size_t increment = 0;
	increment += wr_payload_u8(payload, offset, elements);
	for(int i = 0; i < elements; i++)
 8024a46:	45ba      	cmp	sl, r7
 8024a48:	f809 4005 	strb.w	r4, [r9, r5]
	{
		const char *ptr = pp_str[i];
		increment += wr_payload_string(payload, offset + increment, ptr);
 8024a4c:	4406      	add	r6, r0

size_t wr_payload_helper_string_list(uint8_t* payload, size_t offset, size_t elements,  char * const *pp_str)
{
	size_t increment = 0;
	increment += wr_payload_u8(payload, offset, elements);
	for(int i = 0; i < elements; i++)
 8024a4e:	d1f3      	bne.n	8024a38 <wr_payload_helper_string_list+0xc8>
	{
		const char *ptr = pp_str[i];
		increment += wr_payload_string(payload, offset + increment, ptr);
	}
	return increment;
}
 8024a50:	4630      	mov	r0, r6
 8024a52:	b003      	add	sp, #12
 8024a54:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8024a58:	4405      	add	r5, r0
 8024a5a:	444d      	add	r5, r9
 8024a5c:	3c01      	subs	r4, #1
	{
		uint8_t len = strlen(ptr);
		increment += wr_payload_u8(payload, offset + increment, len);  // attach the str len
		for(int k = 0; k < len; k++)
		{
			increment += wr_payload_u8(payload, offset + increment, ptr[k]);
 8024a5e:	f814 2f01 	ldrb.w	r2, [r4, #1]!
 8024a62:	f803 2f01 	strb.w	r2, [r3, #1]!
	size_t increment = 0;
	if (ptr)
	{
		uint8_t len = strlen(ptr);
		increment += wr_payload_u8(payload, offset + increment, len);  // attach the str len
		for(int k = 0; k < len; k++)
 8024a66:	42ab      	cmp	r3, r5
 8024a68:	d1f9      	bne.n	8024a5e <wr_payload_helper_string_list+0xee>
 8024a6a:	e7e1      	b.n	8024a30 <wr_payload_helper_string_list+0xc0>
{
	size_t increment = 0;
	if (ptr)
	{
		uint8_t len = strlen(ptr);
		increment += wr_payload_u8(payload, offset + increment, len);  // attach the str len
 8024a6c:	2001      	movs	r0, #1
 8024a6e:	e7e0      	b.n	8024a32 <wr_payload_helper_string_list+0xc2>


size_t wr_payload_helper_string_list(uint8_t* payload, size_t offset, size_t elements,  char * const *pp_str)
{
	size_t increment = 0;
	increment += wr_payload_u8(payload, offset, elements);
 8024a70:	2601      	movs	r6, #1
 8024a72:	e7ed      	b.n	8024a50 <wr_payload_helper_string_list+0xe0>

08024a74 <USBD_VCOM_Event_GetDescriptor>:
	const uint8_t  descriptor_type   = (w_value >> 8);
	const uint8_t  descriptor_number = (w_value & 0xFF);
	const void* address = NULL;
	uint16_t    size    = NO_DESCRIPTOR;

	switch (descriptor_type)
 8024a74:	0a03      	lsrs	r3, r0, #8
 8024a76:	2b02      	cmp	r3, #2
 8024a78:	d016      	beq.n	8024aa8 <USBD_VCOM_Event_GetDescriptor+0x34>
 8024a7a:	2b03      	cmp	r3, #3
 8024a7c:	d009      	beq.n	8024a92 <USBD_VCOM_Event_GetDescriptor+0x1e>
 8024a7e:	2b01      	cmp	r3, #1
 8024a80:	d003      	beq.n	8024a8a <USBD_VCOM_Event_GetDescriptor+0x16>
uint16_t USBD_VCOM_Event_GetDescriptor(const uint16_t w_value,
                                    const uint16_t w_index,
                                    const void** const descriptor_address)
{
	const uint8_t  descriptor_type   = (w_value >> 8);
	const uint8_t  descriptor_number = (w_value & 0xFF);
 8024a82:	2000      	movs	r0, #0
 8024a84:	4603      	mov	r3, r0
			}
			break;
	}

	(void)w_index;
	*descriptor_address = address;
 8024a86:	6013      	str	r3, [r2, #0]
	return size;
}
 8024a88:	4770      	bx	lr
	uint16_t    size    = NO_DESCRIPTOR;

	switch (descriptor_type)
	{
		case DTYPE_Device:
			address = &device_descriptor;
 8024a8a:	4b09      	ldr	r3, [pc, #36]	; (8024ab0 <USBD_VCOM_Event_GetDescriptor+0x3c>)
			}
			break;
	}

	(void)w_index;
	*descriptor_address = address;
 8024a8c:	6013      	str	r3, [r2, #0]

	switch (descriptor_type)
	{
		case DTYPE_Device:
			address = &device_descriptor;
			size    = sizeof(USB_Descriptor_Device_t);
 8024a8e:	2012      	movs	r0, #18
	}

	(void)w_index;
	*descriptor_address = address;
	return size;
}
 8024a90:	4770      	bx	lr
uint16_t USBD_VCOM_Event_GetDescriptor(const uint16_t w_value,
                                    const uint16_t w_index,
                                    const void** const descriptor_address)
{
	const uint8_t  descriptor_type   = (w_value >> 8);
	const uint8_t  descriptor_number = (w_value & 0xFF);
 8024a92:	b2c0      	uxtb	r0, r0
 8024a94:	2802      	cmp	r0, #2
 8024a96:	d8f4      	bhi.n	8024a82 <USBD_VCOM_Event_GetDescriptor+0xe>
 8024a98:	4b06      	ldr	r3, [pc, #24]	; (8024ab4 <USBD_VCOM_Event_GetDescriptor+0x40>)
 8024a9a:	4907      	ldr	r1, [pc, #28]	; (8024ab8 <USBD_VCOM_Event_GetDescriptor+0x44>)
 8024a9c:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
			}
			break;
	}

	(void)w_index;
	*descriptor_address = address;
 8024aa0:	6013      	str	r3, [r2, #0]
 8024aa2:	f831 0010 	ldrh.w	r0, [r1, r0, lsl #1]
	return size;
}
 8024aa6:	4770      	bx	lr
		case DTYPE_Device:
			address = &device_descriptor;
			size    = sizeof(USB_Descriptor_Device_t);
			break;
		case DTYPE_Configuration:
			address = &configuration_descriptor;
 8024aa8:	4b04      	ldr	r3, [pc, #16]	; (8024abc <USBD_VCOM_Event_GetDescriptor+0x48>)
			}
			break;
	}

	(void)w_index;
	*descriptor_address = address;
 8024aaa:	6013      	str	r3, [r2, #0]
			address = &device_descriptor;
			size    = sizeof(USB_Descriptor_Device_t);
			break;
		case DTYPE_Configuration:
			address = &configuration_descriptor;
			size    = sizeof(USB_Descriptor_Configuration_t);
 8024aac:	203e      	movs	r0, #62	; 0x3e
	}

	(void)w_index;
	*descriptor_address = address;
	return size;
}
 8024aae:	4770      	bx	lr
 8024ab0:	0802f388 	.word	0x0802f388
 8024ab4:	0802f46c 	.word	0x0802f46c
 8024ab8:	0802f478 	.word	0x0802f478
 8024abc:	0802f480 	.word	0x0802f480

08024ac0 <CDC_Device_ProcessControlRequest>:
	 *  packet, \c false otherwise.
	 */
	static inline bool Endpoint_IsSETUPReceived(void);
	static inline bool Endpoint_IsSETUPReceived(void)
	{
		return device.IsSetupRecieved;
 8024ac0:	4a45      	ldr	r2, [pc, #276]	; (8024bd8 <CDC_Device_ProcessControlRequest+0x118>)
 8024ac2:	f892 313e 	ldrb.w	r3, [r2, #318]	; 0x13e
 * API IMPLEMENTATION
 **********************************************************************************************************************/
void CDC_Device_ProcessControlRequest(
					USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
	if ((Endpoint_IsSETUPReceived() != 0) && (USB_ControlRequest.wIndex ==
 8024ac6:	079b      	lsls	r3, r3, #30
 8024ac8:	d510      	bpl.n	8024aec <CDC_Device_ProcessControlRequest+0x2c>
/**********************************************************************************************************************
 * API IMPLEMENTATION
 **********************************************************************************************************************/
void CDC_Device_ProcessControlRequest(
					USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
 8024aca:	b570      	push	{r4, r5, r6, lr}
	if ((Endpoint_IsSETUPReceived() != 0) && (USB_ControlRequest.wIndex ==
 8024acc:	4943      	ldr	r1, [pc, #268]	; (8024bdc <CDC_Device_ProcessControlRequest+0x11c>)
 8024ace:	7c84      	ldrb	r4, [r0, #18]
 8024ad0:	888b      	ldrh	r3, [r1, #4]
 8024ad2:	b29b      	uxth	r3, r3
 8024ad4:	429c      	cmp	r4, r3
 8024ad6:	d000      	beq.n	8024ada <CDC_Device_ProcessControlRequest+0x1a>
 8024ad8:	bd70      	pop	{r4, r5, r6, pc}
			CDCInterfaceInfo->Config.ControlInterfaceNumber))
	{

		switch (USB_ControlRequest.bRequest)
 8024ada:	784b      	ldrb	r3, [r1, #1]
 8024adc:	3b20      	subs	r3, #32
 8024ade:	4604      	mov	r4, r0
 8024ae0:	2b03      	cmp	r3, #3
 8024ae2:	d8f9      	bhi.n	8024ad8 <CDC_Device_ProcessControlRequest+0x18>
 8024ae4:	e8df f003 	tbb	[pc, r3]
 8024ae8:	03633f18 	.word	0x03633f18
 8024aec:	4770      	bx	lr

				}

				break;
			case CDC_REQ_SendBreak:
				if ((REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE) == USB_ControlRequest.bmRequestType)
 8024aee:	780b      	ldrb	r3, [r1, #0]
 8024af0:	493a      	ldr	r1, [pc, #232]	; (8024bdc <CDC_Device_ProcessControlRequest+0x11c>)
 8024af2:	2b21      	cmp	r3, #33	; 0x21
 8024af4:	d1f0      	bne.n	8024ad8 <CDC_Device_ProcessControlRequest+0x18>
				{
					Endpoint_ClearSETUP();
					Endpoint_ClearStatusStage();

					if(0 != cdc_class_events.Device_BreakSent)
 8024af6:	483a      	ldr	r0, [pc, #232]	; (8024be0 <CDC_Device_ProcessControlRequest+0x120>)
	 *  \note This is not applicable for non CONTROL type endpoints.
	 */
	static inline void Endpoint_ClearSETUP(void);
	static inline void Endpoint_ClearSETUP(void)
	{
		device.IsSetupRecieved = 0;
 8024af8:	f892 313e 	ldrb.w	r3, [r2, #318]	; 0x13e
 8024afc:	6885      	ldr	r5, [r0, #8]
 8024afe:	f023 0302 	bic.w	r3, r3, #2
 8024b02:	f882 313e 	strb.w	r3, [r2, #318]	; 0x13e
 8024b06:	2d00      	cmp	r5, #0
 8024b08:	d0e6      	beq.n	8024ad8 <CDC_Device_ProcessControlRequest+0x18>
					{
						cdc_class_events.Device_BreakSent(CDCInterfaceInfo,	(uint8_t)USB_ControlRequest.wValue);
 8024b0a:	8849      	ldrh	r1, [r1, #2]
 8024b0c:	4620      	mov	r0, r4
 8024b0e:	462b      	mov	r3, r5
 8024b10:	b2c9      	uxtb	r1, r1
				}

				break;
		}
	}
}
 8024b12:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
					Endpoint_ClearSETUP();
					Endpoint_ClearStatusStage();

					if(0 != cdc_class_events.Device_BreakSent)
					{
						cdc_class_events.Device_BreakSent(CDCInterfaceInfo,	(uint8_t)USB_ControlRequest.wValue);
 8024b16:	4718      	bx	r3
					Endpoint_ClearStatusStage();
				}

				break;
			case CDC_REQ_SetLineEncoding:
				if ((REQDIR_HOSTTODEVICE |REQTYPE_CLASS | REQREC_INTERFACE) == USB_ControlRequest.bmRequestType)
 8024b18:	780b      	ldrb	r3, [r1, #0]
 8024b1a:	2b21      	cmp	r3, #33	; 0x21
 8024b1c:	d1dc      	bne.n	8024ad8 <CDC_Device_ProcessControlRequest+0x18>
 8024b1e:	f892 013e 	ldrb.w	r0, [r2, #318]	; 0x13e
 8024b22:	f892 313c 	ldrb.w	r3, [r2, #316]	; 0x13c
				{
					Endpoint_ClearSETUP();

					while (!(Endpoint_IsOUTReceived()))
					{
						if (USB_DeviceState == DEVICE_STATE_Unattached)
 8024b26:	492f      	ldr	r1, [pc, #188]	; (8024be4 <CDC_Device_ProcessControlRequest+0x124>)
 8024b28:	f020 0002 	bic.w	r0, r0, #2
	 */
	static inline bool Endpoint_IsOUTReceived(void);
	static inline bool Endpoint_IsOUTReceived(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
		return ep->IsOutRecieved;
 8024b2c:	252c      	movs	r5, #44	; 0x2c
	 *  \note This is not applicable for non CONTROL type endpoints.
	 */
	static inline void Endpoint_ClearSETUP(void);
	static inline void Endpoint_ClearSETUP(void)
	{
		device.IsSetupRecieved = 0;
 8024b2e:	f882 013e 	strb.w	r0, [r2, #318]	; 0x13e
	 */
	static inline bool Endpoint_IsOUTReceived(void);
	static inline bool Endpoint_IsOUTReceived(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
		return ep->IsOutRecieved;
 8024b32:	fb05 2203 	mla	r2, r5, r3, r2
 8024b36:	e002      	b.n	8024b3e <CDC_Device_ProcessControlRequest+0x7e>
 8024b38:	780b      	ldrb	r3, [r1, #0]
 8024b3a:	2b00      	cmp	r3, #0
 8024b3c:	d0cc      	beq.n	8024ad8 <CDC_Device_ProcessControlRequest+0x18>
 8024b3e:	6893      	ldr	r3, [r2, #8]
			case CDC_REQ_SetLineEncoding:
				if ((REQDIR_HOSTTODEVICE |REQTYPE_CLASS | REQREC_INTERFACE) == USB_ControlRequest.bmRequestType)
				{
					Endpoint_ClearSETUP();

					while (!(Endpoint_IsOUTReceived()))
 8024b40:	069b      	lsls	r3, r3, #26
 8024b42:	d5f9      	bpl.n	8024b38 <CDC_Device_ProcessControlRequest+0x78>
					{
						if (USB_DeviceState == DEVICE_STATE_Unattached)
						  return;
					}

					CDCInterfaceInfo->State.LineEncoding.BaudRateBPS = Endpoint_Read_32_LE();
 8024b44:	f000 fc30 	bl	80253a8 <Endpoint_Read_32_LE>
 8024b48:	61a0      	str	r0, [r4, #24]
					CDCInterfaceInfo->State.LineEncoding.CharFormat  = Endpoint_Read_8();
 8024b4a:	f000 fc01 	bl	8025350 <Endpoint_Read_8>
 8024b4e:	7720      	strb	r0, [r4, #28]
					CDCInterfaceInfo->State.LineEncoding.ParityType  = Endpoint_Read_8();
 8024b50:	f000 fbfe 	bl	8025350 <Endpoint_Read_8>
 8024b54:	7760      	strb	r0, [r4, #29]
					CDCInterfaceInfo->State.LineEncoding.DataBits    = Endpoint_Read_8();
 8024b56:	f000 fbfb 	bl	8025350 <Endpoint_Read_8>

					//Endpoint_ClearOUT();
					Endpoint_ClearStatusStage();

					if(0 != cdc_class_events.LineEncodingChanged)
 8024b5a:	4b21      	ldr	r3, [pc, #132]	; (8024be0 <CDC_Device_ProcessControlRequest+0x120>)
					}

					CDCInterfaceInfo->State.LineEncoding.BaudRateBPS = Endpoint_Read_32_LE();
					CDCInterfaceInfo->State.LineEncoding.CharFormat  = Endpoint_Read_8();
					CDCInterfaceInfo->State.LineEncoding.ParityType  = Endpoint_Read_8();
					CDCInterfaceInfo->State.LineEncoding.DataBits    = Endpoint_Read_8();
 8024b5c:	77a0      	strb	r0, [r4, #30]

					//Endpoint_ClearOUT();
					Endpoint_ClearStatusStage();

					if(0 != cdc_class_events.LineEncodingChanged)
 8024b5e:	681b      	ldr	r3, [r3, #0]
 8024b60:	2b00      	cmp	r3, #0
 8024b62:	d134      	bne.n	8024bce <CDC_Device_ProcessControlRequest+0x10e>
 8024b64:	e7b8      	b.n	8024ad8 <CDC_Device_ProcessControlRequest+0x18>
	{

		switch (USB_ControlRequest.bRequest)
		{
			case CDC_REQ_GetLineEncoding:
				if ((REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE) == USB_ControlRequest.bmRequestType)
 8024b66:	780b      	ldrb	r3, [r1, #0]
 8024b68:	2ba1      	cmp	r3, #161	; 0xa1
 8024b6a:	d1b5      	bne.n	8024ad8 <CDC_Device_ProcessControlRequest+0x18>
	 *  \note This is not applicable for non CONTROL type endpoints.
	 */
	static inline void Endpoint_ClearSETUP(void);
	static inline void Endpoint_ClearSETUP(void)
	{
		device.IsSetupRecieved = 0;
 8024b6c:	f892 113e 	ldrb.w	r1, [r2, #318]	; 0x13e
 8024b70:	f892 313c 	ldrb.w	r3, [r2, #316]	; 0x13c
 8024b74:	f021 0102 	bic.w	r1, r1, #2
	 */
	static inline bool Endpoint_IsINReady(void);
	static inline bool Endpoint_IsINReady(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
		return ep->InInUse == 0 && ep->IsEnabled;
 8024b78:	202c      	movs	r0, #44	; 0x2c
	 *  \note This is not applicable for non CONTROL type endpoints.
	 */
	static inline void Endpoint_ClearSETUP(void);
	static inline void Endpoint_ClearSETUP(void)
	{
		device.IsSetupRecieved = 0;
 8024b7a:	f882 113e 	strb.w	r1, [r2, #318]	; 0x13e
	 */
	static inline bool Endpoint_IsINReady(void);
	static inline bool Endpoint_IsINReady(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
		return ep->InInUse == 0 && ep->IsEnabled;
 8024b7e:	fb00 2203 	mla	r2, r0, r3, r2
 8024b82:	6893      	ldr	r3, [r2, #8]
 8024b84:	06d8      	lsls	r0, r3, #27
 8024b86:	d4fc      	bmi.n	8024b82 <CDC_Device_ProcessControlRequest+0xc2>
 8024b88:	6893      	ldr	r3, [r2, #8]
 8024b8a:	0799      	lsls	r1, r3, #30
 8024b8c:	d5f9      	bpl.n	8024b82 <CDC_Device_ProcessControlRequest+0xc2>
				{
					Endpoint_ClearSETUP();

					while (!(Endpoint_IsINReady()));

					Endpoint_Write_32_LE(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS);
 8024b8e:	69a0      	ldr	r0, [r4, #24]
 8024b90:	f000 fbf4 	bl	802537c <Endpoint_Write_32_LE>
					Endpoint_Write_8(CDCInterfaceInfo->State.LineEncoding.CharFormat);
 8024b94:	7f20      	ldrb	r0, [r4, #28]
 8024b96:	f000 fbc5 	bl	8025324 <Endpoint_Write_8>
					Endpoint_Write_8(CDCInterfaceInfo->State.LineEncoding.ParityType);
 8024b9a:	7f60      	ldrb	r0, [r4, #29]
 8024b9c:	f000 fbc2 	bl	8025324 <Endpoint_Write_8>
					Endpoint_Write_8(CDCInterfaceInfo->State.LineEncoding.DataBits);
 8024ba0:	7fa0      	ldrb	r0, [r4, #30]
 8024ba2:	f000 fbbf 	bl	8025324 <Endpoint_Write_8>
				}

				break;
		}
	}
}
 8024ba6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
					Endpoint_Write_32_LE(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS);
					Endpoint_Write_8(CDCInterfaceInfo->State.LineEncoding.CharFormat);
					Endpoint_Write_8(CDCInterfaceInfo->State.LineEncoding.ParityType);
					Endpoint_Write_8(CDCInterfaceInfo->State.LineEncoding.DataBits);

					Endpoint_ClearIN();
 8024baa:	f000 bb6b 	b.w	8025284 <Endpoint_ClearIN>

				}

				break;
			case CDC_REQ_SetControlLineState:
				if ((REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE) == USB_ControlRequest.bmRequestType)
 8024bae:	780b      	ldrb	r3, [r1, #0]
 8024bb0:	490a      	ldr	r1, [pc, #40]	; (8024bdc <CDC_Device_ProcessControlRequest+0x11c>)
 8024bb2:	2b21      	cmp	r3, #33	; 0x21
 8024bb4:	d190      	bne.n	8024ad8 <CDC_Device_ProcessControlRequest+0x18>
	 *  \note This is not applicable for non CONTROL type endpoints.
	 */
	static inline void Endpoint_ClearSETUP(void);
	static inline void Endpoint_ClearSETUP(void)
	{
		device.IsSetupRecieved = 0;
 8024bb6:	f892 313e 	ldrb.w	r3, [r2, #318]	; 0x13e
					Endpoint_ClearSETUP();
					Endpoint_ClearStatusStage();

					CDCInterfaceInfo->State.ControlLineStates.HostToDevice = USB_ControlRequest.wValue;

					if(0 != cdc_class_events.ControLineStateChanged)
 8024bba:	4809      	ldr	r0, [pc, #36]	; (8024be0 <CDC_Device_ProcessControlRequest+0x120>)
 8024bbc:	f023 0302 	bic.w	r3, r3, #2
 8024bc0:	f882 313e 	strb.w	r3, [r2, #318]	; 0x13e
 8024bc4:	6843      	ldr	r3, [r0, #4]
				if ((REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE) == USB_ControlRequest.bmRequestType)
				{
					Endpoint_ClearSETUP();
					Endpoint_ClearStatusStage();

					CDCInterfaceInfo->State.ControlLineStates.HostToDevice = USB_ControlRequest.wValue;
 8024bc6:	884a      	ldrh	r2, [r1, #2]
 8024bc8:	82a2      	strh	r2, [r4, #20]

					if(0 != cdc_class_events.ControLineStateChanged)
 8024bca:	2b00      	cmp	r3, #0
 8024bcc:	d084      	beq.n	8024ad8 <CDC_Device_ProcessControlRequest+0x18>
					{
						cdc_class_events.ControLineStateChanged(CDCInterfaceInfo);
 8024bce:	4620      	mov	r0, r4
				}

				break;
		}
	}
}
 8024bd0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}

					CDCInterfaceInfo->State.ControlLineStates.HostToDevice = USB_ControlRequest.wValue;

					if(0 != cdc_class_events.ControLineStateChanged)
					{
						cdc_class_events.ControLineStateChanged(CDCInterfaceInfo);
 8024bd4:	4718      	bx	r3
 8024bd6:	bf00      	nop
 8024bd8:	1fff05b0 	.word	0x1fff05b0
 8024bdc:	1fff03a8 	.word	0x1fff03a8
 8024be0:	1ffe90d4 	.word	0x1ffe90d4
 8024be4:	1fff03a5 	.word	0x1fff03a5

08024be8 <CDC_Device_ConfigureEndpoints>:




bool CDC_Device_ConfigureEndpoints(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
 8024be8:	b538      	push	{r3, r4, r5, lr}
	bool status = true;
	memset(&CDCInterfaceInfo->State, 0x00, sizeof(CDCInterfaceInfo->State));

	CDCInterfaceInfo->Config.DataINEndpoint.Type       = EP_TYPE_BULK;
 8024bea:	2202      	movs	r2, #2


bool CDC_Device_ConfigureEndpoints(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
	bool status = true;
	memset(&CDCInterfaceInfo->State, 0x00, sizeof(CDCInterfaceInfo->State));
 8024bec:	2300      	movs	r3, #0

	CDCInterfaceInfo->Config.DataINEndpoint.Type       = EP_TYPE_BULK;
	CDCInterfaceInfo->Config.DataOUTEndpoint.Type      = EP_TYPE_BULK;
	CDCInterfaceInfo->Config.NotificationEndpoint.Type = EP_TYPE_INTERRUPT;
 8024bee:	2103      	movs	r1, #3


bool CDC_Device_ConfigureEndpoints(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
	bool status = true;
	memset(&CDCInterfaceInfo->State, 0x00, sizeof(CDCInterfaceInfo->State));
 8024bf0:	7503      	strb	r3, [r0, #20]
 8024bf2:	7543      	strb	r3, [r0, #21]
 8024bf4:	7583      	strb	r3, [r0, #22]
 8024bf6:	75c3      	strb	r3, [r0, #23]
 8024bf8:	7603      	strb	r3, [r0, #24]
 8024bfa:	7643      	strb	r3, [r0, #25]
 8024bfc:	7683      	strb	r3, [r0, #26]
 8024bfe:	76c3      	strb	r3, [r0, #27]
 8024c00:	7703      	strb	r3, [r0, #28]
 8024c02:	7743      	strb	r3, [r0, #29]
 8024c04:	7783      	strb	r3, [r0, #30]
 8024c06:	77c3      	strb	r3, [r0, #31]

	CDCInterfaceInfo->Config.DataINEndpoint.Type       = EP_TYPE_BULK;
 8024c08:	7102      	strb	r2, [r0, #4]
	CDCInterfaceInfo->Config.DataOUTEndpoint.Type      = EP_TYPE_BULK;
 8024c0a:	7282      	strb	r2, [r0, #10]
	CDCInterfaceInfo->Config.NotificationEndpoint.Type = EP_TYPE_INTERRUPT;
 8024c0c:	7401      	strb	r1, [r0, #16]

	if (!(Endpoint_ConfigureEndpointTable(&CDCInterfaceInfo->Config.DataINEndpoint, 1)))
 8024c0e:	2101      	movs	r1, #1




bool CDC_Device_ConfigureEndpoints(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
 8024c10:	4604      	mov	r4, r0

	CDCInterfaceInfo->Config.DataINEndpoint.Type       = EP_TYPE_BULK;
	CDCInterfaceInfo->Config.DataOUTEndpoint.Type      = EP_TYPE_BULK;
	CDCInterfaceInfo->Config.NotificationEndpoint.Type = EP_TYPE_INTERRUPT;

	if (!(Endpoint_ConfigureEndpointTable(&CDCInterfaceInfo->Config.DataINEndpoint, 1)))
 8024c12:	f000 fbdf 	bl	80253d4 <Endpoint_ConfigureEndpointTable>
	{
		status = false;
	}

	if (!(Endpoint_ConfigureEndpointTable(
 8024c16:	2101      	movs	r1, #1

	CDCInterfaceInfo->Config.DataINEndpoint.Type       = EP_TYPE_BULK;
	CDCInterfaceInfo->Config.DataOUTEndpoint.Type      = EP_TYPE_BULK;
	CDCInterfaceInfo->Config.NotificationEndpoint.Type = EP_TYPE_INTERRUPT;

	if (!(Endpoint_ConfigureEndpointTable(&CDCInterfaceInfo->Config.DataINEndpoint, 1)))
 8024c18:	4605      	mov	r5, r0
	{
		status = false;
	}

	if (!(Endpoint_ConfigureEndpointTable(
 8024c1a:	1da0      	adds	r0, r4, #6
 8024c1c:	f000 fbda 	bl	80253d4 <Endpoint_ConfigureEndpointTable>
							&CDCInterfaceInfo->Config.DataOUTEndpoint, 1)))
	{
		status = false;
	}

	if (!(Endpoint_ConfigureEndpointTable(
 8024c20:	2101      	movs	r1, #1
	if (!(Endpoint_ConfigureEndpointTable(&CDCInterfaceInfo->Config.DataINEndpoint, 1)))
	{
		status = false;
	}

	if (!(Endpoint_ConfigureEndpointTable(
 8024c22:	2800      	cmp	r0, #0
							&CDCInterfaceInfo->Config.DataOUTEndpoint, 1)))
	{
		status = false;
	}

	if (!(Endpoint_ConfigureEndpointTable(
 8024c24:	f104 000c 	add.w	r0, r4, #12
	}

	if (!(Endpoint_ConfigureEndpointTable(
							&CDCInterfaceInfo->Config.DataOUTEndpoint, 1)))
	{
		status = false;
 8024c28:	bf08      	it	eq
 8024c2a:	2500      	moveq	r5, #0
	}

	if (!(Endpoint_ConfigureEndpointTable(
 8024c2c:	f000 fbd2 	bl	80253d4 <Endpoint_ConfigureEndpointTable>
 8024c30:	2800      	cmp	r0, #0
	{
		status = false;
	}

	return status;
}
 8024c32:	bf14      	ite	ne
 8024c34:	4628      	movne	r0, r5
 8024c36:	2000      	moveq	r0, #0
 8024c38:	bd38      	pop	{r3, r4, r5, pc}
 8024c3a:	bf00      	nop

08024c3c <CDC_Device_USBTask>:

void CDC_Device_USBTask(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
	if ((USB_DeviceState == DEVICE_STATE_Configured) &&	(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS != 0))
 8024c3c:	4b1c      	ldr	r3, [pc, #112]	; (8024cb0 <CDC_Device_USBTask+0x74>)
 8024c3e:	781a      	ldrb	r2, [r3, #0]
 8024c40:	2a04      	cmp	r2, #4
 8024c42:	d000      	beq.n	8024c46 <CDC_Device_USBTask+0xa>
		{
		  CDC_Device_Flush(CDCInterfaceInfo);
		}
		#endif
	}
}
 8024c44:	4770      	bx	lr
	return status;
}

void CDC_Device_USBTask(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
	if ((USB_DeviceState == DEVICE_STATE_Configured) &&	(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS != 0))
 8024c46:	6982      	ldr	r2, [r0, #24]
 8024c48:	2a00      	cmp	r2, #0
 8024c4a:	d0fb      	beq.n	8024c44 <CDC_Device_USBTask+0x8>

	return status;
}

void CDC_Device_USBTask(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
 8024c4c:	b470      	push	{r4, r5, r6}
	if ((USB_DeviceState == DEVICE_STATE_Configured) &&	(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS != 0))
	{
		#if !defined(NO_CLASS_DRIVER_AUTOFLUSH)
		Endpoint_SelectEndpoint(CDCInterfaceInfo->Config.DataINEndpoint.Address);
 8024c4e:	7802      	ldrb	r2, [r0, #0]
	 *  \param[in] Address Endpoint address to select.
	 */
	static inline void Endpoint_SelectEndpoint(const uint8_t Address);
	static inline void Endpoint_SelectEndpoint(const uint8_t Address)
	{
		device.CurrentEndpoint = Address & ENDPOINT_EPNUM_MASK;
 8024c50:	4918      	ldr	r1, [pc, #96]	; (8024cb4 <CDC_Device_USBTask+0x78>)
 8024c52:	f002 040f 	and.w	r4, r2, #15
	 */
	static inline bool Endpoint_IsINReady(void);
	static inline bool Endpoint_IsINReady(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
		return ep->InInUse == 0 && ep->IsEnabled;
 8024c56:	262c      	movs	r6, #44	; 0x2c
	 */
	static inline void Endpoint_SelectEndpoint(const uint8_t Address);
	static inline void Endpoint_SelectEndpoint(const uint8_t Address)
	{
		device.CurrentEndpoint = Address & ENDPOINT_EPNUM_MASK;
		device.CurrentDirection = (Address & ENDPOINT_DIR_MASK);
 8024c58:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
	 */
	static inline bool Endpoint_IsINReady(void);
	static inline bool Endpoint_IsINReady(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
		return ep->InInUse == 0 && ep->IsEnabled;
 8024c5c:	fb06 1504 	mla	r5, r6, r4, r1
	 *  \param[in] Address Endpoint address to select.
	 */
	static inline void Endpoint_SelectEndpoint(const uint8_t Address);
	static inline void Endpoint_SelectEndpoint(const uint8_t Address)
	{
		device.CurrentEndpoint = Address & ENDPOINT_EPNUM_MASK;
 8024c60:	f881 413c 	strb.w	r4, [r1, #316]	; 0x13c
		device.CurrentDirection = (Address & ENDPOINT_DIR_MASK);
 8024c64:	f881 213d 	strb.w	r2, [r1, #317]	; 0x13d
	 */
	static inline bool Endpoint_IsINReady(void);
	static inline bool Endpoint_IsINReady(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
		return ep->InInUse == 0 && ep->IsEnabled;
 8024c68:	68aa      	ldr	r2, [r5, #8]
 8024c6a:	06d4      	lsls	r4, r2, #27
 8024c6c:	d405      	bmi.n	8024c7a <CDC_Device_USBTask+0x3e>
 8024c6e:	68aa      	ldr	r2, [r5, #8]
 8024c70:	0792      	lsls	r2, r2, #30
 8024c72:	d502      	bpl.n	8024c7a <CDC_Device_USBTask+0x3e>
}

uint8_t CDC_Device_Flush(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
	uint8_t status = 0;
	if ((USB_DeviceState == DEVICE_STATE_Configured) &&	(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS != 0))
 8024c74:	781b      	ldrb	r3, [r3, #0]
 8024c76:	2b04      	cmp	r3, #4
 8024c78:	d001      	beq.n	8024c7e <CDC_Device_USBTask+0x42>
		{
		  CDC_Device_Flush(CDCInterfaceInfo);
		}
		#endif
	}
}
 8024c7a:	bc70      	pop	{r4, r5, r6}
 8024c7c:	4770      	bx	lr
}

uint8_t CDC_Device_Flush(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
	uint8_t status = 0;
	if ((USB_DeviceState == DEVICE_STATE_Configured) &&	(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS != 0))
 8024c7e:	6983      	ldr	r3, [r0, #24]
 8024c80:	2b00      	cmp	r3, #0
 8024c82:	d0fa      	beq.n	8024c7a <CDC_Device_USBTask+0x3e>
	{
		Endpoint_SelectEndpoint(CDCInterfaceInfo->Config.DataINEndpoint.Address);
 8024c84:	7803      	ldrb	r3, [r0, #0]
	 *  \param[in] Address Endpoint address to select.
	 */
	static inline void Endpoint_SelectEndpoint(const uint8_t Address);
	static inline void Endpoint_SelectEndpoint(const uint8_t Address)
	{
		device.CurrentEndpoint = Address & ENDPOINT_EPNUM_MASK;
 8024c86:	f003 020f 	and.w	r2, r3, #15
	 */
	static inline uint16_t Endpoint_BytesInEndpoint(void);
	static inline uint16_t Endpoint_BytesInEndpoint(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
		if (ep->Direction)
 8024c8a:	fb06 1602 	mla	r6, r6, r2, r1
	 */
	static inline void Endpoint_SelectEndpoint(const uint8_t Address);
	static inline void Endpoint_SelectEndpoint(const uint8_t Address)
	{
		device.CurrentEndpoint = Address & ENDPOINT_EPNUM_MASK;
		device.CurrentDirection = (Address & ENDPOINT_DIR_MASK);
 8024c8e:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
	 *  \param[in] Address Endpoint address to select.
	 */
	static inline void Endpoint_SelectEndpoint(const uint8_t Address);
	static inline void Endpoint_SelectEndpoint(const uint8_t Address)
	{
		device.CurrentEndpoint = Address & ENDPOINT_EPNUM_MASK;
 8024c92:	f881 213c 	strb.w	r2, [r1, #316]	; 0x13c
		device.CurrentDirection = (Address & ENDPOINT_DIR_MASK);
 8024c96:	f881 313d 	strb.w	r3, [r1, #317]	; 0x13d
	 */
	static inline uint16_t Endpoint_BytesInEndpoint(void);
	static inline uint16_t Endpoint_BytesInEndpoint(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
		if (ep->Direction)
 8024c9a:	7933      	ldrb	r3, [r6, #4]
 8024c9c:	061b      	lsls	r3, r3, #24
			return (uint16_t)(ep->InBytesAvailable);
 8024c9e:	bf4c      	ite	mi
 8024ca0:	8bb3      	ldrhmi	r3, [r6, #28]
		else
			return (uint16_t)(ep->OutBytesAvailable);
 8024ca2:	89b3      	ldrhpl	r3, [r6, #12]

		if (Endpoint_BytesInEndpoint())
 8024ca4:	2b00      	cmp	r3, #0
 8024ca6:	d0e8      	beq.n	8024c7a <CDC_Device_USBTask+0x3e>
		{
		  CDC_Device_Flush(CDCInterfaceInfo);
		}
		#endif
	}
}
 8024ca8:	bc70      	pop	{r4, r5, r6}
	{
		Endpoint_SelectEndpoint(CDCInterfaceInfo->Config.DataINEndpoint.Address);

		if (Endpoint_BytesInEndpoint())
		{
			Endpoint_ClearIN();
 8024caa:	f000 baeb 	b.w	8025284 <Endpoint_ClearIN>
 8024cae:	bf00      	nop
 8024cb0:	1fff03a5 	.word	0x1fff03a5
 8024cb4:	1fff05b0 	.word	0x1fff05b0

08024cb8 <CDC_Device_SendData>:
uint8_t CDC_Device_SendData(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo,
                            const void* const Buffer,
                            const uint16_t Length)
{
	uint8_t status = 0;
	if ((USB_DeviceState == DEVICE_STATE_Configured) &&	(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS != 0))
 8024cb8:	4b0c      	ldr	r3, [pc, #48]	; (8024cec <CDC_Device_SendData+0x34>)
 8024cba:	781b      	ldrb	r3, [r3, #0]
 8024cbc:	2b04      	cmp	r3, #4
 8024cbe:	d001      	beq.n	8024cc4 <CDC_Device_SendData+0xc>
	else
	{
		status = ENDPOINT_RWSTREAM_DeviceDisconnected;
	}
	return status;
}
 8024cc0:	2002      	movs	r0, #2
 8024cc2:	4770      	bx	lr
uint8_t CDC_Device_SendData(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo,
                            const void* const Buffer,
                            const uint16_t Length)
{
	uint8_t status = 0;
	if ((USB_DeviceState == DEVICE_STATE_Configured) &&	(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS != 0))
 8024cc4:	6983      	ldr	r3, [r0, #24]
 8024cc6:	2b00      	cmp	r3, #0
 8024cc8:	d0fa      	beq.n	8024cc0 <CDC_Device_SendData+0x8>
}

uint8_t CDC_Device_SendData(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo,
                            const void* const Buffer,
                            const uint16_t Length)
{
 8024cca:	b430      	push	{r4, r5}
	uint8_t status = 0;
	if ((USB_DeviceState == DEVICE_STATE_Configured) &&	(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS != 0))
	{

		Endpoint_SelectEndpoint(CDCInterfaceInfo->Config.DataINEndpoint.Address);
 8024ccc:	7803      	ldrb	r3, [r0, #0]
	 *  \param[in] Address Endpoint address to select.
	 */
	static inline void Endpoint_SelectEndpoint(const uint8_t Address);
	static inline void Endpoint_SelectEndpoint(const uint8_t Address)
	{
		device.CurrentEndpoint = Address & ENDPOINT_EPNUM_MASK;
 8024cce:	4c08      	ldr	r4, [pc, #32]	; (8024cf0 <CDC_Device_SendData+0x38>)
 8024cd0:	f003 050f 	and.w	r5, r3, #15
		device.CurrentDirection = (Address & ENDPOINT_DIR_MASK);
 8024cd4:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
		status = Endpoint_Write_Stream_LE(Buffer, Length, NULL);
 8024cd8:	4608      	mov	r0, r1
	 *  \param[in] Address Endpoint address to select.
	 */
	static inline void Endpoint_SelectEndpoint(const uint8_t Address);
	static inline void Endpoint_SelectEndpoint(const uint8_t Address)
	{
		device.CurrentEndpoint = Address & ENDPOINT_EPNUM_MASK;
 8024cda:	f884 513c 	strb.w	r5, [r4, #316]	; 0x13c
 8024cde:	4611      	mov	r1, r2
		device.CurrentDirection = (Address & ENDPOINT_DIR_MASK);
 8024ce0:	f884 313d 	strb.w	r3, [r4, #317]	; 0x13d
 8024ce4:	2200      	movs	r2, #0
	else
	{
		status = ENDPOINT_RWSTREAM_DeviceDisconnected;
	}
	return status;
}
 8024ce6:	bc30      	pop	{r4, r5}
	uint8_t status = 0;
	if ((USB_DeviceState == DEVICE_STATE_Configured) &&	(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS != 0))
	{

		Endpoint_SelectEndpoint(CDCInterfaceInfo->Config.DataINEndpoint.Address);
		status = Endpoint_Write_Stream_LE(Buffer, Length, NULL);
 8024ce8:	f000 b9b4 	b.w	8025054 <Endpoint_Write_Stream_LE>
 8024cec:	1fff03a5 	.word	0x1fff03a5
 8024cf0:	1fff05b0 	.word	0x1fff05b0

08024cf4 <CDC_Device_Flush>:
	return status;

}

uint8_t CDC_Device_Flush(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
 8024cf4:	b508      	push	{r3, lr}
	uint8_t status = 0;
	if ((USB_DeviceState == DEVICE_STATE_Configured) &&	(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS != 0))
 8024cf6:	4b10      	ldr	r3, [pc, #64]	; (8024d38 <CDC_Device_Flush+0x44>)
 8024cf8:	781b      	ldrb	r3, [r3, #0]
 8024cfa:	2b04      	cmp	r3, #4
 8024cfc:	d001      	beq.n	8024d02 <CDC_Device_Flush+0xe>

		status = ENDPOINT_READYWAIT_NoError;
	}
	else
	{
		status = ENDPOINT_RWSTREAM_DeviceDisconnected;
 8024cfe:	2002      	movs	r0, #2
	}

	return status;
}
 8024d00:	bd08      	pop	{r3, pc}
}

uint8_t CDC_Device_Flush(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
	uint8_t status = 0;
	if ((USB_DeviceState == DEVICE_STATE_Configured) &&	(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS != 0))
 8024d02:	6983      	ldr	r3, [r0, #24]
 8024d04:	2b00      	cmp	r3, #0
 8024d06:	d0fa      	beq.n	8024cfe <CDC_Device_Flush+0xa>
	{
		Endpoint_SelectEndpoint(CDCInterfaceInfo->Config.DataINEndpoint.Address);
 8024d08:	7803      	ldrb	r3, [r0, #0]
	 *  \param[in] Address Endpoint address to select.
	 */
	static inline void Endpoint_SelectEndpoint(const uint8_t Address);
	static inline void Endpoint_SelectEndpoint(const uint8_t Address)
	{
		device.CurrentEndpoint = Address & ENDPOINT_EPNUM_MASK;
 8024d0a:	490c      	ldr	r1, [pc, #48]	; (8024d3c <CDC_Device_Flush+0x48>)
 8024d0c:	f003 000f 	and.w	r0, r3, #15
	 */
	static inline uint16_t Endpoint_BytesInEndpoint(void);
	static inline uint16_t Endpoint_BytesInEndpoint(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
		if (ep->Direction)
 8024d10:	222c      	movs	r2, #44	; 0x2c
 8024d12:	fb02 1200 	mla	r2, r2, r0, r1
	 */
	static inline void Endpoint_SelectEndpoint(const uint8_t Address);
	static inline void Endpoint_SelectEndpoint(const uint8_t Address)
	{
		device.CurrentEndpoint = Address & ENDPOINT_EPNUM_MASK;
		device.CurrentDirection = (Address & ENDPOINT_DIR_MASK);
 8024d16:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
	 *  \param[in] Address Endpoint address to select.
	 */
	static inline void Endpoint_SelectEndpoint(const uint8_t Address);
	static inline void Endpoint_SelectEndpoint(const uint8_t Address)
	{
		device.CurrentEndpoint = Address & ENDPOINT_EPNUM_MASK;
 8024d1a:	f881 013c 	strb.w	r0, [r1, #316]	; 0x13c
		device.CurrentDirection = (Address & ENDPOINT_DIR_MASK);
 8024d1e:	f881 313d 	strb.w	r3, [r1, #317]	; 0x13d
	 */
	static inline uint16_t Endpoint_BytesInEndpoint(void);
	static inline uint16_t Endpoint_BytesInEndpoint(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
		if (ep->Direction)
 8024d22:	7913      	ldrb	r3, [r2, #4]
 8024d24:	061b      	lsls	r3, r3, #24
			return (uint16_t)(ep->InBytesAvailable);
 8024d26:	bf4c      	ite	mi
 8024d28:	8b90      	ldrhmi	r0, [r2, #28]
		else
			return (uint16_t)(ep->OutBytesAvailable);
 8024d2a:	8990      	ldrhpl	r0, [r2, #12]

		if (Endpoint_BytesInEndpoint())
 8024d2c:	2800      	cmp	r0, #0
 8024d2e:	d0e7      	beq.n	8024d00 <CDC_Device_Flush+0xc>
		{
			Endpoint_ClearIN();
 8024d30:	f000 faa8 	bl	8025284 <Endpoint_ClearIN>
 8024d34:	2000      	movs	r0, #0
 8024d36:	bd08      	pop	{r3, pc}
 8024d38:	1fff03a5 	.word	0x1fff03a5
 8024d3c:	1fff05b0 	.word	0x1fff05b0

08024d40 <CDC_Device_BytesReceived>:

	return status;
}

uint16_t CDC_Device_BytesReceived(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
 8024d40:	b508      	push	{r3, lr}
	uint16_t bytes = 0;
	if ((USB_DeviceState == DEVICE_STATE_Configured) &&	(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS != 0))
 8024d42:	4b13      	ldr	r3, [pc, #76]	; (8024d90 <CDC_Device_BytesReceived+0x50>)
 8024d44:	781b      	ldrb	r3, [r3, #0]
 8024d46:	2b04      	cmp	r3, #4
 8024d48:	d001      	beq.n	8024d4e <CDC_Device_BytesReceived+0xe>
		if (Endpoint_IsOUTReceived())
		{
			if (!(Endpoint_BytesInEndpoint()))
			{
				Endpoint_ClearOUT();
				bytes = 0;
 8024d4a:	2000      	movs	r0, #0
			bytes = 0;
		}
	}

	return bytes;
}
 8024d4c:	bd08      	pop	{r3, pc}
}

uint16_t CDC_Device_BytesReceived(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
	uint16_t bytes = 0;
	if ((USB_DeviceState == DEVICE_STATE_Configured) &&	(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS != 0))
 8024d4e:	6983      	ldr	r3, [r0, #24]
 8024d50:	2b00      	cmp	r3, #0
 8024d52:	d0fa      	beq.n	8024d4a <CDC_Device_BytesReceived+0xa>
	{

		Endpoint_SelectEndpoint(CDCInterfaceInfo->Config.DataOUTEndpoint.Address);
 8024d54:	7982      	ldrb	r2, [r0, #6]
	 *  \param[in] Address Endpoint address to select.
	 */
	static inline void Endpoint_SelectEndpoint(const uint8_t Address);
	static inline void Endpoint_SelectEndpoint(const uint8_t Address)
	{
		device.CurrentEndpoint = Address & ENDPOINT_EPNUM_MASK;
 8024d56:	490f      	ldr	r1, [pc, #60]	; (8024d94 <CDC_Device_BytesReceived+0x54>)
 8024d58:	f002 000f 	and.w	r0, r2, #15
	 */
	static inline bool Endpoint_IsOUTReceived(void);
	static inline bool Endpoint_IsOUTReceived(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
		return ep->IsOutRecieved;
 8024d5c:	232c      	movs	r3, #44	; 0x2c
	 */
	static inline void Endpoint_SelectEndpoint(const uint8_t Address);
	static inline void Endpoint_SelectEndpoint(const uint8_t Address)
	{
		device.CurrentEndpoint = Address & ENDPOINT_EPNUM_MASK;
		device.CurrentDirection = (Address & ENDPOINT_DIR_MASK);
 8024d5e:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
	 */
	static inline bool Endpoint_IsOUTReceived(void);
	static inline bool Endpoint_IsOUTReceived(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
		return ep->IsOutRecieved;
 8024d62:	fb03 1300 	mla	r3, r3, r0, r1
	 */
	static inline void Endpoint_SelectEndpoint(const uint8_t Address);
	static inline void Endpoint_SelectEndpoint(const uint8_t Address)
	{
		device.CurrentEndpoint = Address & ENDPOINT_EPNUM_MASK;
		device.CurrentDirection = (Address & ENDPOINT_DIR_MASK);
 8024d66:	f881 213d 	strb.w	r2, [r1, #317]	; 0x13d
	 *  \param[in] Address Endpoint address to select.
	 */
	static inline void Endpoint_SelectEndpoint(const uint8_t Address);
	static inline void Endpoint_SelectEndpoint(const uint8_t Address)
	{
		device.CurrentEndpoint = Address & ENDPOINT_EPNUM_MASK;
 8024d6a:	f881 013c 	strb.w	r0, [r1, #316]	; 0x13c
	 */
	static inline bool Endpoint_IsOUTReceived(void);
	static inline bool Endpoint_IsOUTReceived(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
		return ep->IsOutRecieved;
 8024d6e:	689a      	ldr	r2, [r3, #8]

		if (Endpoint_IsOUTReceived())
 8024d70:	0691      	lsls	r1, r2, #26
 8024d72:	d5ea      	bpl.n	8024d4a <CDC_Device_BytesReceived+0xa>
	 */
	static inline uint16_t Endpoint_BytesInEndpoint(void);
	static inline uint16_t Endpoint_BytesInEndpoint(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
		if (ep->Direction)
 8024d74:	791a      	ldrb	r2, [r3, #4]
 8024d76:	0612      	lsls	r2, r2, #24
 8024d78:	d505      	bpl.n	8024d86 <CDC_Device_BytesReceived+0x46>
			return (uint16_t)(ep->InBytesAvailable);
 8024d7a:	8b98      	ldrh	r0, [r3, #28]
		{
			if (!(Endpoint_BytesInEndpoint()))
 8024d7c:	2800      	cmp	r0, #0
 8024d7e:	d1e5      	bne.n	8024d4c <CDC_Device_BytesReceived+0xc>
			{
				Endpoint_ClearOUT();
 8024d80:	f000 fa54 	bl	802522c <Endpoint_ClearOUT>
 8024d84:	e7e1      	b.n	8024d4a <CDC_Device_BytesReceived+0xa>
		else
			return (uint16_t)(ep->OutBytesAvailable);
 8024d86:	8998      	ldrh	r0, [r3, #12]

		Endpoint_SelectEndpoint(CDCInterfaceInfo->Config.DataOUTEndpoint.Address);

		if (Endpoint_IsOUTReceived())
		{
			if (!(Endpoint_BytesInEndpoint()))
 8024d88:	2800      	cmp	r0, #0
 8024d8a:	d1df      	bne.n	8024d4c <CDC_Device_BytesReceived+0xc>
 8024d8c:	e7f8      	b.n	8024d80 <CDC_Device_BytesReceived+0x40>
 8024d8e:	bf00      	nop
 8024d90:	1fff03a5 	.word	0x1fff03a5
 8024d94:	1fff05b0 	.word	0x1fff05b0

08024d98 <USBD_VCOM_CDCClass_Event_LineEncodingChanged>:
 * as a parameter.*/
void USBD_VCOM_CDCClass_Event_LineEncodingChanged(USB_ClassInfo_CDC_Device_t* const cdc_interface_info)
{
  /*set here the global volatile flag(which can be polled from the top level application) to indicate
   * the event. */
  cdc_event_flags.line_encoding_event_flag = 1U;
 8024d98:	4b01      	ldr	r3, [pc, #4]	; (8024da0 <USBD_VCOM_CDCClass_Event_LineEncodingChanged+0x8>)
 8024d9a:	2201      	movs	r2, #1
 8024d9c:	701a      	strb	r2, [r3, #0]
 8024d9e:	4770      	bx	lr
 8024da0:	1fff0300 	.word	0x1fff0300

08024da4 <USBD_VCOM_CDCClass_Event_ControlLineStateChanged>:
 * line states, such as DTR).The new control line states are available in the ControlLineStates.HostToDevice
 * value inside the CDC interface structure passed as a parameter. */
void USBD_VCOM_CDCClass_Event_ControlLineStateChanged(USB_ClassInfo_CDC_Device_t* const cdc_interface_info)
{
  /*set here the global volatile flag(which can be polled from the top level application) to indicate the event */
  cdc_event_flags.control_line_state_change_event_flag = 1U;
 8024da4:	4b01      	ldr	r3, [pc, #4]	; (8024dac <USBD_VCOM_CDCClass_Event_ControlLineStateChanged+0x8>)
 8024da6:	2201      	movs	r2, #1
 8024da8:	705a      	strb	r2, [r3, #1]
 8024daa:	4770      	bx	lr
 8024dac:	1fff0300 	.word	0x1fff0300

08024db0 <USBD_VCOM_CDCClass_Event_BreakSent>:
/*CDC class driver event for a send break request sent to the device from the host.
 * This is generally used to separate data or to indicate a special condition to the receiving device.*/
void USBD_VCOM_CDCClass_Event_BreakSent(USB_ClassInfo_CDC_Device_t* const cdc_interface_info,	const uint8_t duration)
{
  /*set here the global volatile flag(which can be polled from the top level application) to indicate the event */
  cdc_event_flags.break_event_flag = 1U;
 8024db0:	4b01      	ldr	r3, [pc, #4]	; (8024db8 <USBD_VCOM_CDCClass_Event_BreakSent+0x8>)
 8024db2:	2201      	movs	r2, #1
 8024db4:	709a      	strb	r2, [r3, #2]
 8024db6:	4770      	bx	lr
 8024db8:	1fff0300 	.word	0x1fff0300

08024dbc <USBD_VCOM_Event_ConfigurationChanged>:

}

/* Event handler for the USB Configuration Changed event. */
void USBD_VCOM_Event_ConfigurationChanged(void)
{
 8024dbc:	b508      	push	{r3, lr}
  USBD_SetEndpointBuffer(((uint8_t)CDC_IN_EP_MASK|(uint8_t)CDC_NOTIFICATION_EPNUM), notification_ep_buf, 
 8024dbe:	2081      	movs	r0, #129	; 0x81
 8024dc0:	490e      	ldr	r1, [pc, #56]	; (8024dfc <USBD_VCOM_Event_ConfigurationChanged+0x40>)
 8024dc2:	2240      	movs	r2, #64	; 0x40
 8024dc4:	f000 fff6 	bl	8025db4 <USBD_SetEndpointBuffer>
  (uint16_t)USB_FS_MAXPKT_SIZE);
  USBD_SetEndpointBuffer(((uint8_t)CDC_IN_EP_MASK|(uint8_t)CDC_TX_EPNUM), tx_ep_buf, (uint16_t)USB_FS_MAXPKT_SIZE);
 8024dc8:	2082      	movs	r0, #130	; 0x82
 8024dca:	490d      	ldr	r1, [pc, #52]	; (8024e00 <USBD_VCOM_Event_ConfigurationChanged+0x44>)
 8024dcc:	2240      	movs	r2, #64	; 0x40
 8024dce:	f000 fff1 	bl	8025db4 <USBD_SetEndpointBuffer>
  USBD_SetEndpointBuffer((CDC_RX_EPNUM), rx_ep_buf, (uint16_t)USB_FS_MAXPKT_SIZE);
 8024dd2:	2003      	movs	r0, #3
 8024dd4:	490b      	ldr	r1, [pc, #44]	; (8024e04 <USBD_VCOM_Event_ConfigurationChanged+0x48>)
 8024dd6:	2240      	movs	r2, #64	; 0x40
 8024dd8:	f000 ffec 	bl	8025db4 <USBD_SetEndpointBuffer>
  if (true == CDC_Device_ConfigureEndpoints(&USBD_VCOM_cdc_interface))
 8024ddc:	480a      	ldr	r0, [pc, #40]	; (8024e08 <USBD_VCOM_Event_ConfigurationChanged+0x4c>)
 8024dde:	f7ff ff03 	bl	8024be8 <CDC_Device_ConfigureEndpoints>
 8024de2:	b148      	cbz	r0, 8024df8 <USBD_VCOM_Event_ConfigurationChanged+0x3c>
  {
    device.IsConfigured = 1U;
 8024de4:	4a09      	ldr	r2, [pc, #36]	; (8024e0c <USBD_VCOM_Event_ConfigurationChanged+0x50>)
    USB_DeviceState = (uint8_t)DEVICE_STATE_Configured;
 8024de6:	490a      	ldr	r1, [pc, #40]	; (8024e10 <USBD_VCOM_Event_ConfigurationChanged+0x54>)
  (uint16_t)USB_FS_MAXPKT_SIZE);
  USBD_SetEndpointBuffer(((uint8_t)CDC_IN_EP_MASK|(uint8_t)CDC_TX_EPNUM), tx_ep_buf, (uint16_t)USB_FS_MAXPKT_SIZE);
  USBD_SetEndpointBuffer((CDC_RX_EPNUM), rx_ep_buf, (uint16_t)USB_FS_MAXPKT_SIZE);
  if (true == CDC_Device_ConfigureEndpoints(&USBD_VCOM_cdc_interface))
  {
    device.IsConfigured = 1U;
 8024de8:	f892 313e 	ldrb.w	r3, [r2, #318]	; 0x13e
    USB_DeviceState = (uint8_t)DEVICE_STATE_Configured;
 8024dec:	2004      	movs	r0, #4
  (uint16_t)USB_FS_MAXPKT_SIZE);
  USBD_SetEndpointBuffer(((uint8_t)CDC_IN_EP_MASK|(uint8_t)CDC_TX_EPNUM), tx_ep_buf, (uint16_t)USB_FS_MAXPKT_SIZE);
  USBD_SetEndpointBuffer((CDC_RX_EPNUM), rx_ep_buf, (uint16_t)USB_FS_MAXPKT_SIZE);
  if (true == CDC_Device_ConfigureEndpoints(&USBD_VCOM_cdc_interface))
  {
    device.IsConfigured = 1U;
 8024dee:	f043 0301 	orr.w	r3, r3, #1
 8024df2:	f882 313e 	strb.w	r3, [r2, #318]	; 0x13e
    USB_DeviceState = (uint8_t)DEVICE_STATE_Configured;
 8024df6:	7008      	strb	r0, [r1, #0]
 8024df8:	bd08      	pop	{r3, pc}
 8024dfa:	bf00      	nop
 8024dfc:	1fff0304 	.word	0x1fff0304
 8024e00:	1fff02c0 	.word	0x1fff02c0
 8024e04:	1fff0344 	.word	0x1fff0344
 8024e08:	1fff0384 	.word	0x1fff0384
 8024e0c:	1fff05b0 	.word	0x1fff05b0
 8024e10:	1fff03a5 	.word	0x1fff03a5

08024e14 <USBD_VCOM_Event_ControlRequest>:
}

/* Event handler for the USB Control Request reception event. */
void USBD_VCOM_Event_ControlRequest(void)
{
  CDC_Device_ProcessControlRequest(&USBD_VCOM_cdc_interface);
 8024e14:	4801      	ldr	r0, [pc, #4]	; (8024e1c <USBD_VCOM_Event_ControlRequest+0x8>)
 8024e16:	f7ff be53 	b.w	8024ac0 <CDC_Device_ProcessControlRequest>
 8024e1a:	bf00      	nop
 8024e1c:	1fff0384 	.word	0x1fff0384

08024e20 <USBD_VCOM_Event_Reset>:

/* Event handler for the USB reset event. */
void USBD_VCOM_Event_Reset(void)
{
  /*For self powered devices, reinitialize USB*/
  if (device.IsConfigured)
 8024e20:	492d      	ldr	r1, [pc, #180]	; (8024ed8 <USBD_VCOM_Event_Reset+0xb8>)
 8024e22:	f891 213e 	ldrb.w	r2, [r1, #318]	; 0x13e
 8024e26:	07d3      	lsls	r3, r2, #31
 8024e28:	d400      	bmi.n	8024e2c <USBD_VCOM_Event_Reset+0xc>
 8024e2a:	4770      	bx	lr

  /*Register USB event call backs*/
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
 8024e2c:	482b      	ldr	r0, [pc, #172]	; (8024edc <USBD_VCOM_Event_Reset+0xbc>)
  USBD_VCOM_STATUS_t status = USBD_VCOM_STATUS_SUCCESS;

  XMC_ASSERT("USBD_VCOM_Init: vcom_handle not valid", (vcom_handle != NULL));

  /*Initialize CDC interface*/
  USBD_VCOM_cdc_interface.Config.ControlInterfaceNumber = 0U;
 8024e2e:	4b2c      	ldr	r3, [pc, #176]	; (8024ee0 <USBD_VCOM_Event_Reset+0xc0>)

  /*Register USB event call backs*/
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
 8024e30:	6800      	ldr	r0, [r0, #0]
  CDC_Device_ProcessControlRequest(&USBD_VCOM_cdc_interface);
}

/* Event handler for the USB reset event. */
void USBD_VCOM_Event_Reset(void)
{
 8024e32:	e92d 4ef0 	stmdb	sp!, {r4, r5, r6, r7, r9, sl, fp, lr}
  /*For self powered devices, reinitialize USB*/
  if (device.IsConfigured)
  {
    device.IsConfigured = 0U;
 8024e36:	f36f 0200 	bfc	r2, #0, #1
  USBD_VCOM_STATUS_t status = USBD_VCOM_STATUS_SUCCESS;

  XMC_ASSERT("USBD_VCOM_Init: vcom_handle not valid", (vcom_handle != NULL));

  /*Initialize CDC interface*/
  USBD_VCOM_cdc_interface.Config.ControlInterfaceNumber = 0U;
 8024e3a:	f04f 0a00 	mov.w	sl, #0
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Address = (ENDPOINT_DIR_IN | CDC_TX_EPNUM);
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Address = CDC_RX_EPNUM;
 8024e3e:	f04f 0903 	mov.w	r9, #3

  /*Register USB event call backs*/
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
 8024e42:	4c28      	ldr	r4, [pc, #160]	; (8024ee4 <USBD_VCOM_Event_Reset+0xc4>)
void USBD_VCOM_Event_Reset(void)
{
  /*For self powered devices, reinitialize USB*/
  if (device.IsConfigured)
  {
    device.IsConfigured = 0U;
 8024e44:	f881 213e 	strb.w	r2, [r1, #318]	; 0x13e
  USBD_VCOM_STATUS_t status = USBD_VCOM_STATUS_SUCCESS;

  XMC_ASSERT("USBD_VCOM_Init: vcom_handle not valid", (vcom_handle != NULL));

  /*Initialize CDC interface*/
  USBD_VCOM_cdc_interface.Config.ControlInterfaceNumber = 0U;
 8024e48:	f883 a012 	strb.w	sl, [r3, #18]
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Address = (ENDPOINT_DIR_IN | CDC_NOTIFICATION_EPNUM);
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Size = CDC_NOTIFICATION_EPSIZE;
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Type = (uint8_t)EP_TYPE_INTERRUPT;
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Banks = 0U;
 8024e4c:	f883 a011 	strb.w	sl, [r3, #17]
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Address = (ENDPOINT_DIR_IN | CDC_NOTIFICATION_EPNUM);
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Size = CDC_NOTIFICATION_EPSIZE;
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Type = (uint8_t)EP_TYPE_INTERRUPT;
 8024e50:	f883 9010 	strb.w	r9, [r3, #16]

  /*Register USB event call backs*/
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
 8024e54:	6902      	ldr	r2, [r0, #16]
    USBD_handle->event_cb->config_changed = event_callback->config_changed;
    USBD_handle->event_cb->connect = event_callback->connect;
    USBD_handle->event_cb->control_request = event_callback->control_request;
    USBD_handle->event_cb->disconnect = event_callback->disconnect;
    USBD_handle->event_cb->get_descriptor = event_callback->get_descriptor;
 8024e56:	6966      	ldr	r6, [r4, #20]
 8024e58:	6156      	str	r6, [r2, #20]
    USBD_handle->event_cb->suspend = event_callback->suspend;
 8024e5a:	69e6      	ldr	r6, [r4, #28]
 8024e5c:	61d6      	str	r6, [r2, #28]
    USBD_handle->event_cb->wakeup = event_callback->wakeup;
 8024e5e:	69a6      	ldr	r6, [r4, #24]
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Address = CDC_RX_EPNUM;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Banks = 0U;
 8024e60:	f883 a00b 	strb.w	sl, [r3, #11]
  CDC_Device_ProcessControlRequest(&USBD_VCOM_cdc_interface);
}

/* Event handler for the USB reset event. */
void USBD_VCOM_Event_Reset(void)
{
 8024e64:	b082      	sub	sp, #8
  /*Initialize CDC interface*/
  USBD_VCOM_cdc_interface.Config.ControlInterfaceNumber = 0U;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Address = (ENDPOINT_DIR_IN | CDC_TX_EPNUM);
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Banks = 0U;
 8024e66:	f883 a005 	strb.w	sl, [r3, #5]
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Address = CDC_RX_EPNUM;
 8024e6a:	f883 9006 	strb.w	r9, [r3, #6]
    USBD_handle->event_cb->connect = event_callback->connect;
    USBD_handle->event_cb->control_request = event_callback->control_request;
    USBD_handle->event_cb->disconnect = event_callback->disconnect;
    USBD_handle->event_cb->get_descriptor = event_callback->get_descriptor;
    USBD_handle->event_cb->suspend = event_callback->suspend;
    USBD_handle->event_cb->wakeup = event_callback->wakeup;
 8024e6e:	6196      	str	r6, [r2, #24]
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Address = CDC_RX_EPNUM;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Address = (ENDPOINT_DIR_IN | CDC_NOTIFICATION_EPNUM);
 8024e70:	f04f 0a81 	mov.w	sl, #129	; 0x81

  /*Register USB event call backs*/
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
 8024e74:	6926      	ldr	r6, [r4, #16]
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Address = CDC_RX_EPNUM;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Address = (ENDPOINT_DIR_IN | CDC_NOTIFICATION_EPNUM);
 8024e76:	f883 a00c 	strb.w	sl, [r3, #12]
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Size = CDC_NOTIFICATION_EPSIZE;
 8024e7a:	f04f 0908 	mov.w	r9, #8
 8024e7e:	f8a3 900e 	strh.w	r9, [r3, #14]
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
    USBD_handle->event_cb->config_changed = event_callback->config_changed;
    USBD_handle->event_cb->connect = event_callback->connect;
 8024e82:	6821      	ldr	r1, [r4, #0]
  /*Register USB event call backs*/
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
    USBD_handle->event_cb->config_changed = event_callback->config_changed;
 8024e84:	68a7      	ldr	r7, [r4, #8]
    USBD_handle->event_cb->connect = event_callback->connect;
    USBD_handle->event_cb->control_request = event_callback->control_request;
 8024e86:	68e5      	ldr	r5, [r4, #12]

  /*Register USB event call backs*/
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
 8024e88:	6116      	str	r6, [r2, #16]
  XMC_ASSERT("USBD_VCOM_Init: vcom_handle not valid", (vcom_handle != NULL));

  /*Initialize CDC interface*/
  USBD_VCOM_cdc_interface.Config.ControlInterfaceNumber = 0U;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Address = (ENDPOINT_DIR_IN | CDC_TX_EPNUM);
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Size = CDC_TXRX_EPSIZE;
 8024e8a:	f04f 0b40 	mov.w	fp, #64	; 0x40
    USBD_handle->event_cb->control_request = event_callback->control_request;
    USBD_handle->event_cb->disconnect = event_callback->disconnect;
    USBD_handle->event_cb->get_descriptor = event_callback->get_descriptor;
    USBD_handle->event_cb->suspend = event_callback->suspend;
    USBD_handle->event_cb->wakeup = event_callback->wakeup;
    USBD_handle->event_cb->start_of_frame = event_callback->start_of_frame;
 8024e8e:	6a26      	ldr	r6, [r4, #32]
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Address = (ENDPOINT_DIR_IN | CDC_TX_EPNUM);
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Address = CDC_RX_EPNUM;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Size = CDC_TXRX_EPSIZE;
 8024e90:	f8a3 b008 	strh.w	fp, [r3, #8]

  /*Initialize CDC interface*/
  USBD_VCOM_cdc_interface.Config.ControlInterfaceNumber = 0U;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Address = (ENDPOINT_DIR_IN | CDC_TX_EPNUM);
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Type = (uint8_t)EP_TYPE_BULK;
 8024e94:	f04f 0a02 	mov.w	sl, #2

  XMC_ASSERT("USBD_VCOM_Init: vcom_handle not valid", (vcom_handle != NULL));

  /*Initialize CDC interface*/
  USBD_VCOM_cdc_interface.Config.ControlInterfaceNumber = 0U;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Address = (ENDPOINT_DIR_IN | CDC_TX_EPNUM);
 8024e98:	f04f 0982 	mov.w	r9, #130	; 0x82
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Address = CDC_RX_EPNUM;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Type = (uint8_t)EP_TYPE_BULK;
 8024e9c:	f883 a00a 	strb.w	sl, [r3, #10]
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
    USBD_handle->event_cb->config_changed = event_callback->config_changed;
    USBD_handle->event_cb->connect = event_callback->connect;
 8024ea0:	9101      	str	r1, [sp, #4]
  XMC_ASSERT("USBD_VCOM_Init: vcom_handle not valid", (vcom_handle != NULL));

  /*Initialize CDC interface*/
  USBD_VCOM_cdc_interface.Config.ControlInterfaceNumber = 0U;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Address = (ENDPOINT_DIR_IN | CDC_TX_EPNUM);
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Size = CDC_TXRX_EPSIZE;
 8024ea2:	f8a3 b002 	strh.w	fp, [r3, #2]
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
    USBD_handle->event_cb->config_changed = event_callback->config_changed;
    USBD_handle->event_cb->connect = event_callback->connect;
    USBD_handle->event_cb->control_request = event_callback->control_request;
    USBD_handle->event_cb->disconnect = event_callback->disconnect;
 8024ea6:	6861      	ldr	r1, [r4, #4]

  /*Initialize CDC interface*/
  USBD_VCOM_cdc_interface.Config.ControlInterfaceNumber = 0U;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Address = (ENDPOINT_DIR_IN | CDC_TX_EPNUM);
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Type = (uint8_t)EP_TYPE_BULK;
 8024ea8:	f883 a004 	strb.w	sl, [r3, #4]

  XMC_ASSERT("USBD_VCOM_Init: vcom_handle not valid", (vcom_handle != NULL));

  /*Initialize CDC interface*/
  USBD_VCOM_cdc_interface.Config.ControlInterfaceNumber = 0U;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Address = (ENDPOINT_DIR_IN | CDC_TX_EPNUM);
 8024eac:	f883 9000 	strb.w	r9, [r3]
    USBD_handle->event_cb->control_request = event_callback->control_request;
    USBD_handle->event_cb->disconnect = event_callback->disconnect;
    USBD_handle->event_cb->get_descriptor = event_callback->get_descriptor;
    USBD_handle->event_cb->suspend = event_callback->suspend;
    USBD_handle->event_cb->wakeup = event_callback->wakeup;
    USBD_handle->event_cb->start_of_frame = event_callback->start_of_frame;
 8024eb0:	6216      	str	r6, [r2, #32]
  /*Register USB event call backs*/
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
    USBD_handle->event_cb->config_changed = event_callback->config_changed;
 8024eb2:	6097      	str	r7, [r2, #8]
    USBD_handle->event_cb->connect = event_callback->connect;
    USBD_handle->event_cb->control_request = event_callback->control_request;
 8024eb4:	60d5      	str	r5, [r2, #12]
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
    USBD_handle->event_cb->config_changed = event_callback->config_changed;
    USBD_handle->event_cb->connect = event_callback->connect;
 8024eb6:	9b01      	ldr	r3, [sp, #4]
 8024eb8:	6013      	str	r3, [r2, #0]
    USBD_handle->event_cb->disconnect = event_callback->disconnect;
    USBD_handle->event_cb->get_descriptor = event_callback->get_descriptor;
    USBD_handle->event_cb->suspend = event_callback->suspend;
    USBD_handle->event_cb->wakeup = event_callback->wakeup;
    USBD_handle->event_cb->start_of_frame = event_callback->start_of_frame;
    USBD_handle->event_cb->reset = event_callback->reset;
 8024eba:	6a63      	ldr	r3, [r4, #36]	; 0x24
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
    USBD_handle->event_cb->config_changed = event_callback->config_changed;
    USBD_handle->event_cb->connect = event_callback->connect;
    USBD_handle->event_cb->control_request = event_callback->control_request;
    USBD_handle->event_cb->disconnect = event_callback->disconnect;
 8024ebc:	6051      	str	r1, [r2, #4]
    USBD_handle->event_cb->get_descriptor = event_callback->get_descriptor;
    USBD_handle->event_cb->suspend = event_callback->suspend;
    USBD_handle->event_cb->wakeup = event_callback->wakeup;
    USBD_handle->event_cb->start_of_frame = event_callback->start_of_frame;
    USBD_handle->event_cb->reset = event_callback->reset;
 8024ebe:	6253      	str	r3, [r2, #36]	; 0x24
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Banks = 0U;

  /*Register the required USB events*/
  if (USBD_VCOM_STATUS_SUCCESS == USBD_VCOM_Register_USBEvent_CB(&usbd_vcom_events))
  {
    if (USBD_VCOM_STATUS_SUCCESS != (USBD_VCOM_STATUS_t)USBD_Init(USBD_handle))
 8024ec0:	f000 fee2 	bl	8025c88 <USBD_Init>
 8024ec4:	b110      	cbz	r0, 8024ecc <USBD_VCOM_Event_Reset+0xac>
      if (USBD_VCOM_STATUS_SUCCESS != USBD_VCOM_Connect())
      {
      }
    }
  }
}
 8024ec6:	b002      	add	sp, #8
 8024ec8:	e8bd 8ef0 	ldmia.w	sp!, {r4, r5, r6, r7, r9, sl, fp, pc}
 8024ecc:	b002      	add	sp, #8
 8024ece:	e8bd 4ef0 	ldmia.w	sp!, {r4, r5, r6, r7, r9, sl, fp, lr}
}

/*The API to connect the VCOM device to USB host*/
USBD_VCOM_STATUS_t USBD_VCOM_Connect(void)
{
  return (USBD_VCOM_STATUS_t)USBD_Connect();
 8024ed2:	f000 bf63 	b.w	8025d9c <USBD_Connect>
 8024ed6:	bf00      	nop
 8024ed8:	1fff05b0 	.word	0x1fff05b0
 8024edc:	1ffe9108 	.word	0x1ffe9108
 8024ee0:	1fff0384 	.word	0x1fff0384
 8024ee4:	1ffe90e0 	.word	0x1ffe90e0

08024ee8 <USBD_VCOM_Init>:

  /*Register USB event call backs*/
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
 8024ee8:	4a26      	ldr	r2, [pc, #152]	; (8024f84 <USBD_VCOM_Init+0x9c>)
  USBD_VCOM_STATUS_t status = USBD_VCOM_STATUS_SUCCESS;

  XMC_ASSERT("USBD_VCOM_Init: vcom_handle not valid", (vcom_handle != NULL));

  /*Initialize CDC interface*/
  USBD_VCOM_cdc_interface.Config.ControlInterfaceNumber = 0U;
 8024eea:	4b27      	ldr	r3, [pc, #156]	; (8024f88 <USBD_VCOM_Init+0xa0>)

  /*Register USB event call backs*/
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
 8024eec:	6810      	ldr	r0, [r2, #0]
 8024eee:	4927      	ldr	r1, [pc, #156]	; (8024f8c <USBD_VCOM_Init+0xa4>)
}


/*The function initializes the USB core layer and register USB event call backs. */
USBD_VCOM_STATUS_t USBD_VCOM_Init(USBD_VCOM_t *vcom_handle)
{
 8024ef0:	e92d 4ef0 	stmdb	sp!, {r4, r5, r6, r7, r9, sl, fp, lr}
  USBD_VCOM_STATUS_t status = USBD_VCOM_STATUS_SUCCESS;

  XMC_ASSERT("USBD_VCOM_Init: vcom_handle not valid", (vcom_handle != NULL));

  /*Initialize CDC interface*/
  USBD_VCOM_cdc_interface.Config.ControlInterfaceNumber = 0U;
 8024ef4:	f04f 0a00 	mov.w	sl, #0
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Address = (ENDPOINT_DIR_IN | CDC_TX_EPNUM);
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Address = CDC_RX_EPNUM;
 8024ef8:	f04f 0903 	mov.w	r9, #3
  USBD_VCOM_STATUS_t status = USBD_VCOM_STATUS_SUCCESS;

  XMC_ASSERT("USBD_VCOM_Init: vcom_handle not valid", (vcom_handle != NULL));

  /*Initialize CDC interface*/
  USBD_VCOM_cdc_interface.Config.ControlInterfaceNumber = 0U;
 8024efc:	f883 a012 	strb.w	sl, [r3, #18]
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Address = (ENDPOINT_DIR_IN | CDC_NOTIFICATION_EPNUM);
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Size = CDC_NOTIFICATION_EPSIZE;
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Type = (uint8_t)EP_TYPE_INTERRUPT;
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Banks = 0U;
 8024f00:	f883 a011 	strb.w	sl, [r3, #17]
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Address = (ENDPOINT_DIR_IN | CDC_NOTIFICATION_EPNUM);
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Size = CDC_NOTIFICATION_EPSIZE;
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Type = (uint8_t)EP_TYPE_INTERRUPT;
 8024f04:	f883 9010 	strb.w	r9, [r3, #16]

  /*Register USB event call backs*/
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
 8024f08:	6902      	ldr	r2, [r0, #16]
    USBD_handle->event_cb->config_changed = event_callback->config_changed;
    USBD_handle->event_cb->connect = event_callback->connect;
    USBD_handle->event_cb->control_request = event_callback->control_request;
    USBD_handle->event_cb->disconnect = event_callback->disconnect;
    USBD_handle->event_cb->get_descriptor = event_callback->get_descriptor;
 8024f0a:	694e      	ldr	r6, [r1, #20]
 8024f0c:	6156      	str	r6, [r2, #20]
    USBD_handle->event_cb->suspend = event_callback->suspend;
 8024f0e:	69ce      	ldr	r6, [r1, #28]
 8024f10:	61d6      	str	r6, [r2, #28]
}


/*The function initializes the USB core layer and register USB event call backs. */
USBD_VCOM_STATUS_t USBD_VCOM_Init(USBD_VCOM_t *vcom_handle)
{
 8024f12:	b082      	sub	sp, #8
    USBD_handle->event_cb->connect = event_callback->connect;
    USBD_handle->event_cb->control_request = event_callback->control_request;
    USBD_handle->event_cb->disconnect = event_callback->disconnect;
    USBD_handle->event_cb->get_descriptor = event_callback->get_descriptor;
    USBD_handle->event_cb->suspend = event_callback->suspend;
    USBD_handle->event_cb->wakeup = event_callback->wakeup;
 8024f14:	698e      	ldr	r6, [r1, #24]
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
    USBD_handle->event_cb->config_changed = event_callback->config_changed;
    USBD_handle->event_cb->connect = event_callback->connect;
 8024f16:	680c      	ldr	r4, [r1, #0]
    USBD_handle->event_cb->control_request = event_callback->control_request;
    USBD_handle->event_cb->disconnect = event_callback->disconnect;
    USBD_handle->event_cb->get_descriptor = event_callback->get_descriptor;
    USBD_handle->event_cb->suspend = event_callback->suspend;
    USBD_handle->event_cb->wakeup = event_callback->wakeup;
 8024f18:	6196      	str	r6, [r2, #24]
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Address = CDC_RX_EPNUM;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Banks = 0U;
 8024f1a:	f883 a00b 	strb.w	sl, [r3, #11]

  /*Register USB event call backs*/
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
 8024f1e:	690e      	ldr	r6, [r1, #16]
  /*Initialize CDC interface*/
  USBD_VCOM_cdc_interface.Config.ControlInterfaceNumber = 0U;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Address = (ENDPOINT_DIR_IN | CDC_TX_EPNUM);
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Banks = 0U;
 8024f20:	f883 a005 	strb.w	sl, [r3, #5]
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Address = CDC_RX_EPNUM;
 8024f24:	f883 9006 	strb.w	r9, [r3, #6]
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Address = (ENDPOINT_DIR_IN | CDC_NOTIFICATION_EPNUM);
 8024f28:	f04f 0a81 	mov.w	sl, #129	; 0x81
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Size = CDC_NOTIFICATION_EPSIZE;
 8024f2c:	f04f 0908 	mov.w	r9, #8
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
    USBD_handle->event_cb->config_changed = event_callback->config_changed;
    USBD_handle->event_cb->connect = event_callback->connect;
    USBD_handle->event_cb->control_request = event_callback->control_request;
 8024f30:	68cd      	ldr	r5, [r1, #12]
  /*Register USB event call backs*/
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
    USBD_handle->event_cb->config_changed = event_callback->config_changed;
 8024f32:	688f      	ldr	r7, [r1, #8]

  /*Register USB event call backs*/
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
 8024f34:	6116      	str	r6, [r2, #16]
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Address = CDC_RX_EPNUM;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Address = (ENDPOINT_DIR_IN | CDC_NOTIFICATION_EPNUM);
 8024f36:	f883 a00c 	strb.w	sl, [r3, #12]
    USBD_handle->event_cb->control_request = event_callback->control_request;
    USBD_handle->event_cb->disconnect = event_callback->disconnect;
    USBD_handle->event_cb->get_descriptor = event_callback->get_descriptor;
    USBD_handle->event_cb->suspend = event_callback->suspend;
    USBD_handle->event_cb->wakeup = event_callback->wakeup;
    USBD_handle->event_cb->start_of_frame = event_callback->start_of_frame;
 8024f3a:	6a0e      	ldr	r6, [r1, #32]
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Address = CDC_RX_EPNUM;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Address = (ENDPOINT_DIR_IN | CDC_NOTIFICATION_EPNUM);
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Size = CDC_NOTIFICATION_EPSIZE;
 8024f3c:	f8a3 900e 	strh.w	r9, [r3, #14]
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
    USBD_handle->event_cb->config_changed = event_callback->config_changed;
    USBD_handle->event_cb->connect = event_callback->connect;
 8024f40:	9401      	str	r4, [sp, #4]
  XMC_ASSERT("USBD_VCOM_Init: vcom_handle not valid", (vcom_handle != NULL));

  /*Initialize CDC interface*/
  USBD_VCOM_cdc_interface.Config.ControlInterfaceNumber = 0U;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Address = (ENDPOINT_DIR_IN | CDC_TX_EPNUM);
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Size = CDC_TXRX_EPSIZE;
 8024f42:	f04f 0b40 	mov.w	fp, #64	; 0x40
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Type = (uint8_t)EP_TYPE_BULK;
 8024f46:	f04f 0a02 	mov.w	sl, #2

  XMC_ASSERT("USBD_VCOM_Init: vcom_handle not valid", (vcom_handle != NULL));

  /*Initialize CDC interface*/
  USBD_VCOM_cdc_interface.Config.ControlInterfaceNumber = 0U;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Address = (ENDPOINT_DIR_IN | CDC_TX_EPNUM);
 8024f4a:	f04f 0982 	mov.w	r9, #130	; 0x82
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
    USBD_handle->event_cb->config_changed = event_callback->config_changed;
    USBD_handle->event_cb->connect = event_callback->connect;
    USBD_handle->event_cb->control_request = event_callback->control_request;
    USBD_handle->event_cb->disconnect = event_callback->disconnect;
 8024f4e:	684c      	ldr	r4, [r1, #4]
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Address = (ENDPOINT_DIR_IN | CDC_TX_EPNUM);
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Address = CDC_RX_EPNUM;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Size = CDC_TXRX_EPSIZE;
 8024f50:	f8a3 b008 	strh.w	fp, [r3, #8]
    USBD_handle->event_cb->control_request = event_callback->control_request;
    USBD_handle->event_cb->disconnect = event_callback->disconnect;
    USBD_handle->event_cb->get_descriptor = event_callback->get_descriptor;
    USBD_handle->event_cb->suspend = event_callback->suspend;
    USBD_handle->event_cb->wakeup = event_callback->wakeup;
    USBD_handle->event_cb->start_of_frame = event_callback->start_of_frame;
 8024f54:	6216      	str	r6, [r2, #32]
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Type = (uint8_t)EP_TYPE_BULK;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Banks = 0U;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Address = CDC_RX_EPNUM;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Size = CDC_TXRX_EPSIZE;
  USBD_VCOM_cdc_interface.Config.DataOUTEndpoint.Type = (uint8_t)EP_TYPE_BULK;
 8024f56:	f883 a00a 	strb.w	sl, [r3, #10]
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
    USBD_handle->event_cb->config_changed = event_callback->config_changed;
    USBD_handle->event_cb->connect = event_callback->connect;
    USBD_handle->event_cb->control_request = event_callback->control_request;
 8024f5a:	60d5      	str	r5, [r2, #12]
  /*Register USB event call backs*/
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
    USBD_handle->event_cb->config_changed = event_callback->config_changed;
 8024f5c:	6097      	str	r7, [r2, #8]
  XMC_ASSERT("USBD_VCOM_Init: vcom_handle not valid", (vcom_handle != NULL));

  /*Initialize CDC interface*/
  USBD_VCOM_cdc_interface.Config.ControlInterfaceNumber = 0U;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Address = (ENDPOINT_DIR_IN | CDC_TX_EPNUM);
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Size = CDC_TXRX_EPSIZE;
 8024f5e:	f8a3 b002 	strh.w	fp, [r3, #2]
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Type = (uint8_t)EP_TYPE_BULK;
 8024f62:	f883 a004 	strb.w	sl, [r3, #4]

  XMC_ASSERT("USBD_VCOM_Init: vcom_handle not valid", (vcom_handle != NULL));

  /*Initialize CDC interface*/
  USBD_VCOM_cdc_interface.Config.ControlInterfaceNumber = 0U;
  USBD_VCOM_cdc_interface.Config.DataINEndpoint.Address = (ENDPOINT_DIR_IN | CDC_TX_EPNUM);
 8024f66:	f883 9000 	strb.w	r9, [r3]
  if (event_callback != NULL)
  {
    /*NULL checks for the event callbacks are done in the low level APP USBD*/
    USBD_handle->event_cb->set_address = event_callback->set_address;
    USBD_handle->event_cb->config_changed = event_callback->config_changed;
    USBD_handle->event_cb->connect = event_callback->connect;
 8024f6a:	9b01      	ldr	r3, [sp, #4]
    USBD_handle->event_cb->control_request = event_callback->control_request;
    USBD_handle->event_cb->disconnect = event_callback->disconnect;
 8024f6c:	e882 0018 	stmia.w	r2, {r3, r4}
    USBD_handle->event_cb->get_descriptor = event_callback->get_descriptor;
    USBD_handle->event_cb->suspend = event_callback->suspend;
    USBD_handle->event_cb->wakeup = event_callback->wakeup;
    USBD_handle->event_cb->start_of_frame = event_callback->start_of_frame;
    USBD_handle->event_cb->reset = event_callback->reset;
 8024f70:	6a4b      	ldr	r3, [r1, #36]	; 0x24
 8024f72:	6253      	str	r3, [r2, #36]	; 0x24
  USBD_VCOM_cdc_interface.Config.NotificationEndpoint.Banks = 0U;

  /*Register the required USB events*/
  if (USBD_VCOM_STATUS_SUCCESS == USBD_VCOM_Register_USBEvent_CB(&usbd_vcom_events))
  {
    if (USBD_VCOM_STATUS_SUCCESS != (USBD_VCOM_STATUS_t)USBD_Init(USBD_handle))
 8024f74:	f000 fe88 	bl	8025c88 <USBD_Init>
  }
  /*Remove the compilation warning*/
  (void)vcom_handle;

  return status;
}
 8024f78:	3000      	adds	r0, #0
 8024f7a:	bf18      	it	ne
 8024f7c:	2001      	movne	r0, #1
 8024f7e:	b002      	add	sp, #8
 8024f80:	e8bd 8ef0 	ldmia.w	sp!, {r4, r5, r6, r7, r9, sl, fp, pc}
 8024f84:	1ffe9108 	.word	0x1ffe9108
 8024f88:	1fff0384 	.word	0x1fff0384
 8024f8c:	1ffe90e0 	.word	0x1ffe90e0

08024f90 <USBD_VCOM_IsEnumDone>:

/*The function check if the enumeration has been done already. */
uint32_t USBD_VCOM_IsEnumDone(void)
{
 8024f90:	b508      	push	{r3, lr}
  return (uint32_t)(USBD_IsEnumDone() && (USB_DeviceState == (uint8_t)DEVICE_STATE_Configured));
 8024f92:	f000 ff09 	bl	8025da8 <USBD_IsEnumDone>
 8024f96:	b130      	cbz	r0, 8024fa6 <USBD_VCOM_IsEnumDone+0x16>
 8024f98:	4b03      	ldr	r3, [pc, #12]	; (8024fa8 <USBD_VCOM_IsEnumDone+0x18>)
 8024f9a:	7818      	ldrb	r0, [r3, #0]
 8024f9c:	f1a0 0004 	sub.w	r0, r0, #4
 8024fa0:	fab0 f080 	clz	r0, r0
 8024fa4:	0940      	lsrs	r0, r0, #5
}
 8024fa6:	bd08      	pop	{r3, pc}
 8024fa8:	1fff03a5 	.word	0x1fff03a5

08024fac <USBD_VCOM_SendData>:
  return status;
}

/* This function sends multiple bytes to the USB host. */
USBD_VCOM_STATUS_t USBD_VCOM_SendData(const int8_t* const data_buffer, const uint16_t length)
{
 8024fac:	b510      	push	{r4, lr}
  USBD_VCOM_STATUS_t status = USBD_VCOM_STATUS_SUCCESS;

  if ((length == 0U) || (data_buffer == NULL))
 8024fae:	b911      	cbnz	r1, 8024fb6 <USBD_VCOM_SendData+0xa>
  {
    status = USBD_VCOM_STATUS_CDC_ERROR;		  
 8024fb0:	2406      	movs	r4, #6
    {
      status = USBD_VCOM_STATUS_CDC_ERROR;
    }
  }
  return status;
}
 8024fb2:	4620      	mov	r0, r4
 8024fb4:	bd10      	pop	{r4, pc}
/* This function sends multiple bytes to the USB host. */
USBD_VCOM_STATUS_t USBD_VCOM_SendData(const int8_t* const data_buffer, const uint16_t length)
{
  USBD_VCOM_STATUS_t status = USBD_VCOM_STATUS_SUCCESS;

  if ((length == 0U) || (data_buffer == NULL))
 8024fb6:	2800      	cmp	r0, #0
 8024fb8:	d0fa      	beq.n	8024fb0 <USBD_VCOM_SendData+0x4>
 8024fba:	460a      	mov	r2, r1
 8024fbc:	4601      	mov	r1, r0
  }
  else
  {
    /* Send data to USB host.*/
    if ((uint8_t)ENDPOINT_RWSTREAM_NoError !=
        CDC_Device_SendData(&USBD_VCOM_cdc_interface, (const int8_t *)data_buffer, length))
 8024fbe:	4807      	ldr	r0, [pc, #28]	; (8024fdc <USBD_VCOM_SendData+0x30>)
 8024fc0:	f7ff fe7a 	bl	8024cb8 <CDC_Device_SendData>
    status = USBD_VCOM_STATUS_CDC_ERROR;		  
  }
  else
  {
    /* Send data to USB host.*/
    if ((uint8_t)ENDPOINT_RWSTREAM_NoError !=
 8024fc4:	2800      	cmp	r0, #0
        CDC_Device_SendData(&USBD_VCOM_cdc_interface, (const int8_t *)data_buffer, length))
    {
      status = USBD_VCOM_STATUS_CDC_ERROR;
    }
    if ((uint8_t)ENDPOINT_READYWAIT_NoError != CDC_Device_Flush(&USBD_VCOM_cdc_interface))
 8024fc6:	4805      	ldr	r0, [pc, #20]	; (8024fdc <USBD_VCOM_SendData+0x30>)
  {
    /* Send data to USB host.*/
    if ((uint8_t)ENDPOINT_RWSTREAM_NoError !=
        CDC_Device_SendData(&USBD_VCOM_cdc_interface, (const int8_t *)data_buffer, length))
    {
      status = USBD_VCOM_STATUS_CDC_ERROR;
 8024fc8:	bf14      	ite	ne
 8024fca:	2406      	movne	r4, #6
 8024fcc:	2400      	moveq	r4, #0
    }
    if ((uint8_t)ENDPOINT_READYWAIT_NoError != CDC_Device_Flush(&USBD_VCOM_cdc_interface))
 8024fce:	f7ff fe91 	bl	8024cf4 <CDC_Device_Flush>
 8024fd2:	2800      	cmp	r0, #0
    {
      status = USBD_VCOM_STATUS_CDC_ERROR;
 8024fd4:	bf18      	it	ne
 8024fd6:	2406      	movne	r4, #6
    }
  }
  return status;
}
 8024fd8:	4620      	mov	r0, r4
 8024fda:	bd10      	pop	{r4, pc}
 8024fdc:	1fff0384 	.word	0x1fff0384

08024fe0 <USBD_VCOM_ReceiveData>:
  return status;
}

/* This function receives number of bytes from the USB host.*/
USBD_VCOM_STATUS_t USBD_VCOM_ReceiveData(int8_t* data_buffer, uint16_t data_byte)
{
 8024fe0:	b530      	push	{r4, r5, lr}
 8024fe2:	b083      	sub	sp, #12
  USBD_VCOM_STATUS_t status = USBD_VCOM_STATUS_SUCCESS;
  uint16_t bytes_processed = 0U;
 8024fe4:	2300      	movs	r3, #0
 8024fe6:	f8ad 3006 	strh.w	r3, [sp, #6]
  uint8_t ret = 0U;

  if ((data_byte > 0U) && (data_buffer != NULL))
 8024fea:	b911      	cbnz	r1, 8024ff2 <USBD_VCOM_ReceiveData+0x12>
      status = USBD_VCOM_STATUS_CDC_ERROR;
    }
  }
  else
  {
    status = USBD_VCOM_STATUS_CDC_ERROR;
 8024fec:	2006      	movs	r0, #6
  }

  return status;
}
 8024fee:	b003      	add	sp, #12
 8024ff0:	bd30      	pop	{r4, r5, pc}
{
  USBD_VCOM_STATUS_t status = USBD_VCOM_STATUS_SUCCESS;
  uint16_t bytes_processed = 0U;
  uint8_t ret = 0U;

  if ((data_byte > 0U) && (data_buffer != NULL))
 8024ff2:	2800      	cmp	r0, #0
 8024ff4:	d0fa      	beq.n	8024fec <USBD_VCOM_ReceiveData+0xc>
	 *  \param[in] Address Endpoint address to select.
	 */
	static inline void Endpoint_SelectEndpoint(const uint8_t Address);
	static inline void Endpoint_SelectEndpoint(const uint8_t Address)
	{
		device.CurrentEndpoint = Address & ENDPOINT_EPNUM_MASK;
 8024ff6:	4a0b      	ldr	r2, [pc, #44]	; (8025024 <USBD_VCOM_ReceiveData+0x44>)
 8024ff8:	460c      	mov	r4, r1
 8024ffa:	2103      	movs	r1, #3
 8024ffc:	4605      	mov	r5, r0
		device.CurrentDirection = (Address & ENDPOINT_DIR_MASK);
 8024ffe:	f882 313d 	strb.w	r3, [r2, #317]	; 0x13d
	 *  \param[in] Address Endpoint address to select.
	 */
	static inline void Endpoint_SelectEndpoint(const uint8_t Address);
	static inline void Endpoint_SelectEndpoint(const uint8_t Address)
	{
		device.CurrentEndpoint = Address & ENDPOINT_EPNUM_MASK;
 8025002:	f882 113c 	strb.w	r1, [r2, #316]	; 0x13c
  {
    /* Fix for new read/write */
    Endpoint_SelectEndpoint(CDC_RX_EPNUM);
    while ((uint8_t)ENDPOINT_RWSTREAM_IncompleteTransfer == 
 8025006:	4628      	mov	r0, r5
 8025008:	4621      	mov	r1, r4
 802500a:	f10d 0206 	add.w	r2, sp, #6
 802500e:	f000 f871 	bl	80250f4 <Endpoint_Read_Stream_LE>
 8025012:	2805      	cmp	r0, #5
 8025014:	d0f7      	beq.n	8025006 <USBD_VCOM_ReceiveData+0x26>
    (ret = Endpoint_Read_Stream_LE(data_buffer, data_byte,	&bytes_processed)))
    {      
    }      
    if ((uint8_t)ENDPOINT_RWSTREAM_NoError != ret )
    {
      status = USBD_VCOM_STATUS_CDC_ERROR;
 8025016:	2800      	cmp	r0, #0
 8025018:	bf0c      	ite	eq
 802501a:	2000      	moveq	r0, #0
 802501c:	2006      	movne	r0, #6
  {
    status = USBD_VCOM_STATUS_CDC_ERROR;
  }

  return status;
}
 802501e:	b003      	add	sp, #12
 8025020:	bd30      	pop	{r4, r5, pc}
 8025022:	bf00      	nop
 8025024:	1fff05b0 	.word	0x1fff05b0

08025028 <USBD_VCOM_BytesReceived>:
  return status;
}

/* This function checks number of bytes received from the USB host. */
uint16_t USBD_VCOM_BytesReceived(void)
{
 8025028:	b538      	push	{r3, r4, r5, lr}
 */
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 802502a:	4c07      	ldr	r4, [pc, #28]	; (8025048 <USBD_VCOM_BytesReceived+0x20>)
 802502c:	f44f 6500 	mov.w	r5, #2048	; 0x800
 8025030:	f8c4 508c 	str.w	r5, [r4, #140]	; 0x8c
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 8025034:	f3bf 8f4f 	dsb	sy
           so that all instructions following the ISB are fetched from cache or memory,
           after the instruction has been completed.
 */
__attribute__((always_inline)) __STATIC_INLINE void __ISB(void)
{
  __ASM volatile ("isb 0xF":::"memory");
 8025038:	f3bf 8f6f 	isb	sy
  uint16_t bytes = 0U;

  /* Check if bytes are received from host */
  NVIC_DisableIRQ(USB0_0_IRQn);
  bytes = CDC_Device_BytesReceived(&USBD_VCOM_cdc_interface);
 802503c:	4803      	ldr	r0, [pc, #12]	; (802504c <USBD_VCOM_BytesReceived+0x24>)
 802503e:	f7ff fe7f 	bl	8024d40 <CDC_Device_BytesReceived>
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8025042:	60e5      	str	r5, [r4, #12]
  NVIC_EnableIRQ(USB0_0_IRQn);	
    
  return bytes;
}
 8025044:	bd38      	pop	{r3, r4, r5, pc}
 8025046:	bf00      	nop
 8025048:	e000e100 	.word	0xe000e100
 802504c:	1fff0384 	.word	0x1fff0384

08025050 <USBD_VCOM_Connect>:
}

/*The API to connect the VCOM device to USB host*/
USBD_VCOM_STATUS_t USBD_VCOM_Connect(void)
{
  return (USBD_VCOM_STATUS_t)USBD_Connect();
 8025050:	f000 bea4 	b.w	8025d9c <USBD_Connect>

08025054 <Endpoint_Write_Stream_LE>:
/*Flag to indicate the zlp to be sent or not*/
volatile uint8_t zlp_flag = 0;

uint8_t Endpoint_Write_Stream_LE (const void *const Buffer, uint16_t Length,
											uint16_t *const BytesProcessed)
{
 8025054:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	USBD_Endpoint_t* ep = &device.Endpoints[device.CurrentEndpoint];
 8025058:	4b25      	ldr	r3, [pc, #148]	; (80250f0 <Endpoint_Write_Stream_LE+0x9c>)
/*Flag to indicate the zlp to be sent or not*/
volatile uint8_t zlp_flag = 0;

uint8_t Endpoint_Write_Stream_LE (const void *const Buffer, uint16_t Length,
											uint16_t *const BytesProcessed)
{
 802505a:	460c      	mov	r4, r1
 802505c:	4680      	mov	r8, r0
	USBD_Endpoint_t* ep = &device.Endpoints[device.CurrentEndpoint];
 802505e:	f893 113c 	ldrb.w	r1, [r3, #316]	; 0x13c
	uint16_t Bytes = 0;
	uint16_t BytesTransfered = 0;
	uint8_t ErrorCode;

	if (BytesProcessed!=NULL) 
 8025062:	4691      	mov	r9, r2
 8025064:	2a00      	cmp	r2, #0
 8025066:	d03b      	beq.n	80250e0 <Endpoint_Write_Stream_LE+0x8c>
	{
		Length -= *BytesProcessed;
 8025068:	8817      	ldrh	r7, [r2, #0]
 802506a:	1be4      	subs	r4, r4, r7
 802506c:	b2a4      	uxth	r4, r4
		BytesTransfered = *BytesProcessed;
	}

	while (Length) 
	{
		if (ep->InInUse)
 802506e:	262c      	movs	r6, #44	; 0x2c
 8025070:	fb06 3601 	mla	r6, r6, r1, r3
	{
		Length -= *BytesProcessed;
		BytesTransfered = *BytesProcessed;
	}

	while (Length) 
 8025074:	b1f4      	cbz	r4, 80250b4 <Endpoint_Write_Stream_LE+0x60>
	{
		if (ep->InInUse)
 8025076:	68b3      	ldr	r3, [r6, #8]
 8025078:	06db      	lsls	r3, r3, #27
 802507a:	d4fc      	bmi.n	8025076 <Endpoint_Write_Stream_LE+0x22>
		{
			continue;
		}
		if (Endpoint_IsReadWriteAllowed()) 
 802507c:	f000 f93a 	bl	80252f4 <Endpoint_IsReadWriteAllowed>
 8025080:	b1f8      	cbz	r0, 80250c2 <Endpoint_Write_Stream_LE+0x6e>
		{
			if((ep->InBufferLength - ep->InBytesAvailable)  > Length)
 8025082:	6a75      	ldr	r5, [r6, #36]	; 0x24
 8025084:	69f0      	ldr	r0, [r6, #28]
 8025086:	1a2d      	subs	r5, r5, r0
 8025088:	42a5      	cmp	r5, r4
 802508a:	d816      	bhi.n	80250ba <Endpoint_Write_Stream_LE+0x66>
			{
				Bytes = Length;
			}
			else
			{
				Bytes = (ep->InBufferLength - ep->InBytesAvailable);
 802508c:	b2ad      	uxth	r5, r5
 802508e:	1b64      	subs	r4, r4, r5
 8025090:	fa1f fb84 	uxth.w	fp, r4
 8025094:	462c      	mov	r4, r5
			}
			memcpy(ep->InBuffer + ep->InBytesAvailable,(uint8_t*)Buffer + BytesTransfered,Bytes);
 8025096:	6a33      	ldr	r3, [r6, #32]
 8025098:	eb08 0107 	add.w	r1, r8, r7
 802509c:	462a      	mov	r2, r5
 802509e:	4418      	add	r0, r3
 80250a0:	f008 fa56 	bl	802d550 <memcpy>
			ep->InBytesAvailable += Bytes;
 80250a4:	69f3      	ldr	r3, [r6, #28]
			BytesTransfered += Bytes;
 80250a6:	4427      	add	r7, r4
			else
			{
				Bytes = (ep->InBufferLength - ep->InBytesAvailable);
			}
			memcpy(ep->InBuffer + ep->InBytesAvailable,(uint8_t*)Buffer + BytesTransfered,Bytes);
			ep->InBytesAvailable += Bytes;
 80250a8:	441d      	add	r5, r3
			BytesTransfered += Bytes;
			Length -= Bytes;
 80250aa:	465c      	mov	r4, fp
			{
				Bytes = (ep->InBufferLength - ep->InBytesAvailable);
			}
			memcpy(ep->InBuffer + ep->InBytesAvailable,(uint8_t*)Buffer + BytesTransfered,Bytes);
			ep->InBytesAvailable += Bytes;
			BytesTransfered += Bytes;
 80250ac:	b2bf      	uxth	r7, r7
			else
			{
				Bytes = (ep->InBufferLength - ep->InBytesAvailable);
			}
			memcpy(ep->InBuffer + ep->InBytesAvailable,(uint8_t*)Buffer + BytesTransfered,Bytes);
			ep->InBytesAvailable += Bytes;
 80250ae:	61f5      	str	r5, [r6, #28]
	{
		Length -= *BytesProcessed;
		BytesTransfered = *BytesProcessed;
	}

	while (Length) 
 80250b0:	2c00      	cmp	r4, #0
 80250b2:	d1e0      	bne.n	8025076 <Endpoint_Write_Stream_LE+0x22>
				return ErrorCode;
			}
		}
	}
	
	return ENDPOINT_RWSTREAM_NoError;
 80250b4:	4620      	mov	r0, r4
}
 80250b6:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80250ba:	4625      	mov	r5, r4
 80250bc:	f04f 0b00 	mov.w	fp, #0
 80250c0:	e7e9      	b.n	8025096 <Endpoint_Write_Stream_LE+0x42>
			BytesTransfered += Bytes;
			Length -= Bytes;
		}
		else 
		{
			Endpoint_ClearIN();
 80250c2:	f000 f8df 	bl	8025284 <Endpoint_ClearIN>
			if(Length < ep->MaxPacketSize)
 80250c6:	8933      	ldrh	r3, [r6, #8]
 80250c8:	f3c3 1386 	ubfx	r3, r3, #6, #7
 80250cc:	429c      	cmp	r4, r3
 80250ce:	da02      	bge.n	80250d6 <Endpoint_Write_Stream_LE+0x82>
			{
				if (BytesProcessed!=NULL) 
 80250d0:	f1b9 0f00 	cmp.w	r9, #0
 80250d4:	d106      	bne.n	80250e4 <Endpoint_Write_Stream_LE+0x90>
					*BytesProcessed = BytesTransfered;
					return ENDPOINT_RWSTREAM_IncompleteTransfer;
				}
			}

			ErrorCode = Endpoint_WaitUntilReady();
 80250d6:	f000 f85d 	bl	8025194 <Endpoint_WaitUntilReady>
			if (ErrorCode) 
 80250da:	2800      	cmp	r0, #0
 80250dc:	d0ca      	beq.n	8025074 <Endpoint_Write_Stream_LE+0x20>
 80250de:	e7ea      	b.n	80250b6 <Endpoint_Write_Stream_LE+0x62>
uint8_t Endpoint_Write_Stream_LE (const void *const Buffer, uint16_t Length,
											uint16_t *const BytesProcessed)
{
	USBD_Endpoint_t* ep = &device.Endpoints[device.CurrentEndpoint];
	uint16_t Bytes = 0;
	uint16_t BytesTransfered = 0;
 80250e0:	4617      	mov	r7, r2
 80250e2:	e7c4      	b.n	802506e <Endpoint_Write_Stream_LE+0x1a>
			Endpoint_ClearIN();
			if(Length < ep->MaxPacketSize)
			{
				if (BytesProcessed!=NULL) 
				{
					*BytesProcessed = BytesTransfered;
 80250e4:	f8a9 7000 	strh.w	r7, [r9]
					return ENDPOINT_RWSTREAM_IncompleteTransfer;
 80250e8:	2005      	movs	r0, #5
 80250ea:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80250ee:	bf00      	nop
 80250f0:	1fff05b0 	.word	0x1fff05b0

080250f4 <Endpoint_Read_Stream_LE>:
	return ENDPOINT_RWSTREAM_NoError;
}

uint8_t	Endpoint_Read_Stream_LE (void *const Buffer, uint16_t Length,
									uint16_t *const BytesProcessed)
{
 80250f4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	USBD_Endpoint_t* ep = &device.Endpoints[device.CurrentEndpoint];
 80250f8:	4b25      	ldr	r3, [pc, #148]	; (8025190 <Endpoint_Read_Stream_LE+0x9c>)
	return ENDPOINT_RWSTREAM_NoError;
}

uint8_t	Endpoint_Read_Stream_LE (void *const Buffer, uint16_t Length,
									uint16_t *const BytesProcessed)
{
 80250fa:	460c      	mov	r4, r1
 80250fc:	4681      	mov	r9, r0
	USBD_Endpoint_t* ep = &device.Endpoints[device.CurrentEndpoint];
 80250fe:	f893 113c 	ldrb.w	r1, [r3, #316]	; 0x13c
	uint16_t Bytes = 0;
	uint16_t BytesTransfered = 0;
	uint8_t ErrorCode;

	if (BytesProcessed!=NULL) 
 8025102:	4692      	mov	sl, r2
 8025104:	2a00      	cmp	r2, #0
 8025106:	d03b      	beq.n	8025180 <Endpoint_Read_Stream_LE+0x8c>
	{
		Length -= *BytesProcessed;
 8025108:	f8b2 8000 	ldrh.w	r8, [r2]
 802510c:	ebc8 0404 	rsb	r4, r8, r4
 8025110:	b2a4      	uxth	r4, r4
		BytesTransfered = *BytesProcessed;
	}

	while (Length) 
	{
		if (ep->OutInUse)
 8025112:	252c      	movs	r5, #44	; 0x2c
 8025114:	fb05 3501 	mla	r5, r5, r1, r3
	{
		Length -= *BytesProcessed;
		BytesTransfered = *BytesProcessed;
	}

	while (Length) 
 8025118:	b30c      	cbz	r4, 802515e <Endpoint_Read_Stream_LE+0x6a>
	{
		if (ep->OutInUse)
 802511a:	68ab      	ldr	r3, [r5, #8]
 802511c:	071b      	lsls	r3, r3, #28
 802511e:	d4fc      	bmi.n	802511a <Endpoint_Read_Stream_LE+0x26>
		{
			continue;
		}
		if (Endpoint_IsReadWriteAllowed()) 
 8025120:	f000 f8e8 	bl	80252f4 <Endpoint_IsReadWriteAllowed>
 8025124:	b310      	cbz	r0, 802516c <Endpoint_Read_Stream_LE+0x78>
		{
			if(ep->OutBytesAvailable  > Length)
 8025126:	68ee      	ldr	r6, [r5, #12]
 8025128:	42a6      	cmp	r6, r4
 802512a:	d81b      	bhi.n	8025164 <Endpoint_Read_Stream_LE+0x70>
			{
				Bytes = Length;
			}
			else
			{
				Bytes = (uint16_t)ep->OutBytesAvailable;
 802512c:	b2b3      	uxth	r3, r6
 802512e:	1ae4      	subs	r4, r4, r3
 8025130:	fa1f fb84 	uxth.w	fp, r4
 8025134:	461c      	mov	r4, r3
			}

			memcpy((uint8_t*)Buffer + BytesTransfered,
									ep->OutBuffer + ep->OutOffset,Bytes);
 8025136:	692b      	ldr	r3, [r5, #16]
 8025138:	6969      	ldr	r1, [r5, #20]
			else
			{
				Bytes = (uint16_t)ep->OutBytesAvailable;
			}

			memcpy((uint8_t*)Buffer + BytesTransfered,
 802513a:	4632      	mov	r2, r6
 802513c:	eb09 0008 	add.w	r0, r9, r8
 8025140:	4419      	add	r1, r3
 8025142:	f008 fa05 	bl	802d550 <memcpy>
									ep->OutBuffer + ep->OutOffset,Bytes);
			ep->OutBytesAvailable -= Bytes;
 8025146:	68ea      	ldr	r2, [r5, #12]
			ep->OutOffset += Bytes;
 8025148:	692b      	ldr	r3, [r5, #16]
			BytesTransfered += Bytes;
 802514a:	44a0      	add	r8, r4
				Bytes = (uint16_t)ep->OutBytesAvailable;
			}

			memcpy((uint8_t*)Buffer + BytesTransfered,
									ep->OutBuffer + ep->OutOffset,Bytes);
			ep->OutBytesAvailable -= Bytes;
 802514c:	1b92      	subs	r2, r2, r6
			ep->OutOffset += Bytes;
			BytesTransfered += Bytes;
			Length -= Bytes;
 802514e:	465c      	mov	r4, fp
			}

			memcpy((uint8_t*)Buffer + BytesTransfered,
									ep->OutBuffer + ep->OutOffset,Bytes);
			ep->OutBytesAvailable -= Bytes;
			ep->OutOffset += Bytes;
 8025150:	441e      	add	r6, r3
			BytesTransfered += Bytes;
 8025152:	fa1f f888 	uxth.w	r8, r8
				Bytes = (uint16_t)ep->OutBytesAvailable;
			}

			memcpy((uint8_t*)Buffer + BytesTransfered,
									ep->OutBuffer + ep->OutOffset,Bytes);
			ep->OutBytesAvailable -= Bytes;
 8025156:	60ea      	str	r2, [r5, #12]
			ep->OutOffset += Bytes;
 8025158:	612e      	str	r6, [r5, #16]
	{
		Length -= *BytesProcessed;
		BytesTransfered = *BytesProcessed;
	}

	while (Length) 
 802515a:	2c00      	cmp	r4, #0
 802515c:	d1dd      	bne.n	802511a <Endpoint_Read_Stream_LE+0x26>
			{
				return ErrorCode;
			}
		}
	}
	return ENDPOINT_RWSTREAM_NoError;
 802515e:	4620      	mov	r0, r4
}
 8025160:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8025164:	4626      	mov	r6, r4
 8025166:	f04f 0b00 	mov.w	fp, #0
 802516a:	e7e4      	b.n	8025136 <Endpoint_Read_Stream_LE+0x42>
			BytesTransfered += Bytes;
			Length -= Bytes;
		}
		else 
		{
			Endpoint_ClearOUT();
 802516c:	f000 f85e 	bl	802522c <Endpoint_ClearOUT>
			if (BytesProcessed != NULL) 
 8025170:	f1ba 0f00 	cmp.w	sl, #0
 8025174:	d106      	bne.n	8025184 <Endpoint_Read_Stream_LE+0x90>
			{
				*BytesProcessed = BytesTransfered;
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
			}

			ErrorCode = Endpoint_WaitUntilReady();
 8025176:	f000 f80d 	bl	8025194 <Endpoint_WaitUntilReady>
			if (ErrorCode) 
 802517a:	2800      	cmp	r0, #0
 802517c:	d0cc      	beq.n	8025118 <Endpoint_Read_Stream_LE+0x24>
 802517e:	e7ef      	b.n	8025160 <Endpoint_Read_Stream_LE+0x6c>
uint8_t	Endpoint_Read_Stream_LE (void *const Buffer, uint16_t Length,
									uint16_t *const BytesProcessed)
{
	USBD_Endpoint_t* ep = &device.Endpoints[device.CurrentEndpoint];
	uint16_t Bytes = 0;
	uint16_t BytesTransfered = 0;
 8025180:	4690      	mov	r8, r2
 8025182:	e7c6      	b.n	8025112 <Endpoint_Read_Stream_LE+0x1e>
		else 
		{
			Endpoint_ClearOUT();
			if (BytesProcessed != NULL) 
			{
				*BytesProcessed = BytesTransfered;
 8025184:	f8aa 8000 	strh.w	r8, [sl]
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
 8025188:	2005      	movs	r0, #5
 802518a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802518e:	bf00      	nop
 8025190:	1fff05b0 	.word	0x1fff05b0

08025194 <Endpoint_WaitUntilReady>:

#define USB_STREAM_TIMEOUT_MS 100


uint8_t Endpoint_WaitUntilReady(void)
{
 8025194:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 *
 *  \return Current USB frame number from the USB controller.
 */
static inline uint16_t USB_Device_GetFrameNumber(void);
static inline uint16_t USB_Device_GetFrameNumber() {
	return device.Driver->GetFrameNumber();
 8025198:	4c22      	ldr	r4, [pc, #136]	; (8025224 <Endpoint_WaitUntilReady+0x90>)
			{
			  return ENDPOINT_READYWAIT_NoError;
			}
		}

		uint8_t USB_DeviceState_LCL = USB_DeviceState;
 802519a:	4d23      	ldr	r5, [pc, #140]	; (8025228 <Endpoint_WaitUntilReady+0x94>)
 802519c:	6823      	ldr	r3, [r4, #0]
 802519e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80251a0:	4798      	blx	r3
	 */
	static inline bool Endpoint_IsStalled(void);
	static inline bool Endpoint_IsStalled(void)
	{
		bool status = false;
		if(device.Endpoints[device.CurrentEndpoint].IsHalted == 1)
 80251a2:	46a1      	mov	r9, r4
 80251a4:	4680      	mov	r8, r0


uint8_t Endpoint_WaitUntilReady(void)
{
	#if (USB_STREAM_TIMEOUT_MS < 0xFF)
	uint8_t  TimeoutMSRem = USB_STREAM_TIMEOUT_MS;
 80251a6:	2664      	movs	r6, #100	; 0x64
	 */
	static inline uint8_t Endpoint_GetEndpointDirection(void);
	static inline uint8_t Endpoint_GetEndpointDirection(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
		return ep->Address & ENDPOINT_DIR_MASK;
 80251a8:	272c      	movs	r7, #44	; 0x2c
	 *  \c ENDPOINT_DIR_* mask.
	 */
	static inline uint8_t Endpoint_GetEndpointDirection(void);
	static inline uint8_t Endpoint_GetEndpointDirection(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
 80251aa:	f894 313c 	ldrb.w	r3, [r4, #316]	; 0x13c
		return ep->Address & ENDPOINT_DIR_MASK;
 80251ae:	fb07 4203 	mla	r2, r7, r3, r4
 80251b2:	7911      	ldrb	r1, [r2, #4]

	uint16_t PreviousFrameNumber = USB_Device_GetFrameNumber();

	for (;;)
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
 80251b4:	0608      	lsls	r0, r1, #24
 80251b6:	d41a      	bmi.n	80251ee <Endpoint_WaitUntilReady+0x5a>
	 */
	static inline bool Endpoint_IsOUTReceived(void);
	static inline bool Endpoint_IsOUTReceived(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
		return ep->IsOutRecieved;
 80251b8:	6892      	ldr	r2, [r2, #8]
			  return ENDPOINT_READYWAIT_NoError;
			}
		}
		else
		{
			if (Endpoint_IsOUTReceived())
 80251ba:	0692      	lsls	r2, r2, #26
 80251bc:	d42b      	bmi.n	8025216 <Endpoint_WaitUntilReady+0x82>
			{
			  return ENDPOINT_READYWAIT_NoError;
			}
		}

		uint8_t USB_DeviceState_LCL = USB_DeviceState;
 80251be:	782a      	ldrb	r2, [r5, #0]

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
 80251c0:	f002 01ff 	and.w	r1, r2, #255	; 0xff
 80251c4:	b322      	cbz	r2, 8025210 <Endpoint_WaitUntilReady+0x7c>
		{
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
		}
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
 80251c6:	2905      	cmp	r1, #5
 80251c8:	d01f      	beq.n	802520a <Endpoint_WaitUntilReady+0x76>
	 */
	static inline bool Endpoint_IsStalled(void);
	static inline bool Endpoint_IsStalled(void)
	{
		bool status = false;
		if(device.Endpoints[device.CurrentEndpoint].IsHalted == 1)
 80251ca:	fb07 4303 	mla	r3, r7, r3, r4
 80251ce:	6898      	ldr	r0, [r3, #8]
 80251d0:	f3c0 0080 	ubfx	r0, r0, #2, #1
 80251d4:	b9a8      	cbnz	r0, 8025202 <Endpoint_WaitUntilReady+0x6e>
 80251d6:	f8d9 3000 	ldr.w	r3, [r9]
 80251da:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80251dc:	4798      	blx	r3
		  return ENDPOINT_READYWAIT_EndpointStalled;
		}

		uint16_t CurrentFrameNumber = USB_Device_GetFrameNumber();

		if (CurrentFrameNumber != PreviousFrameNumber)
 80251de:	4580      	cmp	r8, r0
 80251e0:	d011      	beq.n	8025206 <Endpoint_WaitUntilReady+0x72>
		{
			PreviousFrameNumber = CurrentFrameNumber;

			if (!(TimeoutMSRem--))
 80251e2:	1e73      	subs	r3, r6, #1
 80251e4:	b2db      	uxtb	r3, r3
 80251e6:	b1ce      	cbz	r6, 802521c <Endpoint_WaitUntilReady+0x88>
 80251e8:	4680      	mov	r8, r0
 80251ea:	461e      	mov	r6, r3
 80251ec:	e7dd      	b.n	80251aa <Endpoint_WaitUntilReady+0x16>
	 */
	static inline bool Endpoint_IsINReady(void);
	static inline bool Endpoint_IsINReady(void)
	{
		USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
		return ep->InInUse == 0 && ep->IsEnabled;
 80251ee:	6890      	ldr	r0, [r2, #8]
 80251f0:	f3c0 1000 	ubfx	r0, r0, #4, #1
 80251f4:	2800      	cmp	r0, #0
 80251f6:	d1e2      	bne.n	80251be <Endpoint_WaitUntilReady+0x2a>
 80251f8:	6892      	ldr	r2, [r2, #8]
 80251fa:	0791      	lsls	r1, r2, #30
 80251fc:	d5df      	bpl.n	80251be <Endpoint_WaitUntilReady+0x2a>
			{
			  return ENDPOINT_READYWAIT_Timeout;
			}
		}
	}
}
 80251fe:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8025202:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8025206:	4633      	mov	r3, r6
 8025208:	e7ee      	b.n	80251e8 <Endpoint_WaitUntilReady+0x54>
		{
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
		}
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		{
		  return ENDPOINT_READYWAIT_BusSuspended;
 802520a:	2003      	movs	r0, #3
 802520c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		{
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
 8025210:	2002      	movs	r0, #2
 8025212:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
		{
			if (Endpoint_IsINReady())
			{
			  return ENDPOINT_READYWAIT_NoError;
 8025216:	2000      	movs	r0, #0
 8025218:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		{
			PreviousFrameNumber = CurrentFrameNumber;

			if (!(TimeoutMSRem--))
			{
			  return ENDPOINT_READYWAIT_Timeout;
 802521c:	2004      	movs	r0, #4
 802521e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8025222:	bf00      	nop
 8025224:	1fff05b0 	.word	0x1fff05b0
 8025228:	1fff03a5 	.word	0x1fff03a5

0802522c <Endpoint_ClearOUT>:
		}
	}
}

void Endpoint_ClearOUT(void) 
{
 802522c:	b570      	push	{r4, r5, r6, lr}
	USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
 802522e:	4d14      	ldr	r5, [pc, #80]	; (8025280 <Endpoint_ClearOUT+0x54>)
 8025230:	f895 313c 	ldrb.w	r3, [r5, #316]	; 0x13c
	/* if we have data left which isn't read yet, we leave this routine to
	 * not override it */
	if (ep->IsEnabled == 0)
 8025234:	242c      	movs	r4, #44	; 0x2c
 8025236:	fb04 5403 	mla	r4, r4, r3, r5
 802523a:	68a3      	ldr	r3, [r4, #8]
 802523c:	079a      	lsls	r2, r3, #30
 802523e:	d400      	bmi.n	8025242 <Endpoint_ClearOUT+0x16>
 8025240:	bd70      	pop	{r4, r5, r6, pc}
	{
		return;
	}
	/* First Check whether we have data in the driver */
	ep->OutBytesAvailable = device.Driver->EndpointRead(ep->Address,ep->OutBuffer,ep->OutBufferLength);
 8025242:	682b      	ldr	r3, [r5, #0]
 8025244:	6961      	ldr	r1, [r4, #20]
 8025246:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8025248:	69a2      	ldr	r2, [r4, #24]
 802524a:	7920      	ldrb	r0, [r4, #4]
 802524c:	4798      	blx	r3
	ep->OutOffset = 0;
	/* If we didn't request new data and all data has been read, request new */
	if (!ep->OutInUse && !ep->OutBytesAvailable) 
 802524e:	68a3      	ldr	r3, [r4, #8]
	if (ep->IsEnabled == 0)
	{
		return;
	}
	/* First Check whether we have data in the driver */
	ep->OutBytesAvailable = device.Driver->EndpointRead(ep->Address,ep->OutBuffer,ep->OutBufferLength);
 8025250:	60e0      	str	r0, [r4, #12]
	ep->OutOffset = 0;
 8025252:	2100      	movs	r1, #0
	/* If we didn't request new data and all data has been read, request new */
	if (!ep->OutInUse && !ep->OutBytesAvailable) 
 8025254:	071b      	lsls	r3, r3, #28
	if (ep->IsEnabled == 0)
	{
		return;
	}
	/* First Check whether we have data in the driver */
	ep->OutBytesAvailable = device.Driver->EndpointRead(ep->Address,ep->OutBuffer,ep->OutBufferLength);
 8025256:	4602      	mov	r2, r0
	ep->OutOffset = 0;
 8025258:	6121      	str	r1, [r4, #16]
	/* If we didn't request new data and all data has been read, request new */
	if (!ep->OutInUse && !ep->OutBytesAvailable) 
 802525a:	d4f1      	bmi.n	8025240 <Endpoint_ClearOUT+0x14>
 802525c:	2800      	cmp	r0, #0
 802525e:	d1ef      	bne.n	8025240 <Endpoint_ClearOUT+0x14>
	{
		ep->OutInUse = true;
 8025260:	8923      	ldrh	r3, [r4, #8]
		ep->IsOutRecieved = 0;
		device.Driver->EndpointReadStart(ep->Address,ep->OutBufferLength);
 8025262:	7920      	ldrb	r0, [r4, #4]
 8025264:	69a1      	ldr	r1, [r4, #24]
	ep->OutBytesAvailable = device.Driver->EndpointRead(ep->Address,ep->OutBuffer,ep->OutBufferLength);
	ep->OutOffset = 0;
	/* If we didn't request new data and all data has been read, request new */
	if (!ep->OutInUse && !ep->OutBytesAvailable) 
	{
		ep->OutInUse = true;
 8025266:	f043 0308 	orr.w	r3, r3, #8
 802526a:	8123      	strh	r3, [r4, #8]
		ep->IsOutRecieved = 0;
 802526c:	8923      	ldrh	r3, [r4, #8]
 802526e:	f362 1345 	bfi	r3, r2, #5, #1
 8025272:	8123      	strh	r3, [r4, #8]
		device.Driver->EndpointReadStart(ep->Address,ep->OutBufferLength);
 8025274:	682b      	ldr	r3, [r5, #0]
	}
}
 8025276:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	/* If we didn't request new data and all data has been read, request new */
	if (!ep->OutInUse && !ep->OutBytesAvailable) 
	{
		ep->OutInUse = true;
		ep->IsOutRecieved = 0;
		device.Driver->EndpointReadStart(ep->Address,ep->OutBufferLength);
 802527a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 802527c:	4718      	bx	r3
 802527e:	bf00      	nop
 8025280:	1fff05b0 	.word	0x1fff05b0

08025284 <Endpoint_ClearIN>:
	}
}

void Endpoint_ClearIN(void)
{
 8025284:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
 8025286:	4919      	ldr	r1, [pc, #100]	; (80252ec <Endpoint_ClearIN+0x68>)
 8025288:	f891 313c 	ldrb.w	r3, [r1, #316]	; 0x13c
	int32_t data_count;
	/* don't clear if in use or not enabled */
	if (ep->InInUse == 1 || ep->IsEnabled == 0)
 802528c:	222c      	movs	r2, #44	; 0x2c
 802528e:	fb02 1303 	mla	r3, r2, r3, r1
 8025292:	689a      	ldr	r2, [r3, #8]
 8025294:	06d0      	lsls	r0, r2, #27
 8025296:	d402      	bmi.n	802529e <Endpoint_ClearIN+0x1a>
 8025298:	689a      	ldr	r2, [r3, #8]
 802529a:	0792      	lsls	r2, r2, #30
 802529c:	d400      	bmi.n	80252a0 <Endpoint_ClearIN+0x1c>
 802529e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return;
	ep->InInUse = true;
 80252a0:	8918      	ldrh	r0, [r3, #8]
	/* store transfer information to loop over, if underlying is smaller */
	ep->InDataBuffer = ep->InBuffer;
 80252a2:	6a1f      	ldr	r7, [r3, #32]
 */
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 80252a4:	4e12      	ldr	r6, [pc, #72]	; (80252f0 <Endpoint_ClearIN+0x6c>)
	USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
	int32_t data_count;
	/* don't clear if in use or not enabled */
	if (ep->InInUse == 1 || ep->IsEnabled == 0)
		return;
	ep->InInUse = true;
 80252a6:	f040 0010 	orr.w	r0, r0, #16
	/* store transfer information to loop over, if underlying is smaller */
	ep->InDataBuffer = ep->InBuffer;
 80252aa:	f103 0528 	add.w	r5, r3, #40	; 0x28
	ep->InDataLeft = ep->InBytesAvailable;
 80252ae:	f103 0420 	add.w	r4, r3, #32
	USBD_Endpoint_t *ep = &device.Endpoints[device.CurrentEndpoint];
	int32_t data_count;
	/* don't clear if in use or not enabled */
	if (ep->InInUse == 1 || ep->IsEnabled == 0)
		return;
	ep->InInUse = true;
 80252b2:	8118      	strh	r0, [r3, #8]
	/* store transfer information to loop over, if underlying is smaller */
	ep->InDataBuffer = ep->InBuffer;
	ep->InDataLeft = ep->InBytesAvailable;
 80252b4:	69d8      	ldr	r0, [r3, #28]
 80252b6:	60a0      	str	r0, [r4, #8]
	/* don't clear if in use or not enabled */
	if (ep->InInUse == 1 || ep->IsEnabled == 0)
		return;
	ep->InInUse = true;
	/* store transfer information to loop over, if underlying is smaller */
	ep->InDataBuffer = ep->InBuffer;
 80252b8:	606f      	str	r7, [r5, #4]
	ep->InDataLeft = ep->InBytesAvailable;
	ep->InBytesAvailable = 0;
 80252ba:	2000      	movs	r0, #0
 80252bc:	f44f 6700 	mov.w	r7, #2048	; 0x800
 80252c0:	61d8      	str	r0, [r3, #28]
 80252c2:	f8c6 708c 	str.w	r7, [r6, #140]	; 0x8c
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 80252c6:	f3bf 8f4f 	dsb	sy
           so that all instructions following the ISB are fetched from cache or memory,
           after the instruction has been completed.
 */
__attribute__((always_inline)) __STATIC_INLINE void __ISB(void)
{
  __ASM volatile ("isb 0xF":::"memory");
 80252ca:	f3bf 8f6f 	isb	sy
	/* make next 3 operations atomic. Do not get interrupted.*/
	NVIC_DisableIRQ(USB0_0_IRQn);
	data_count = device.Driver->EndpointWrite(ep->Address,
 80252ce:	680a      	ldr	r2, [r1, #0]
 80252d0:	7918      	ldrb	r0, [r3, #4]
 80252d2:	6869      	ldr	r1, [r5, #4]
 80252d4:	6b13      	ldr	r3, [r2, #48]	; 0x30
 80252d6:	68a2      	ldr	r2, [r4, #8]
 80252d8:	4798      	blx	r3
			ep->InDataBuffer,ep->InDataLeft);
	ep->InDataBuffer += data_count;
 80252da:	686a      	ldr	r2, [r5, #4]
	ep->InDataLeft -= data_count;
 80252dc:	68a3      	ldr	r3, [r4, #8]
	ep->InBytesAvailable = 0;
	/* make next 3 operations atomic. Do not get interrupted.*/
	NVIC_DisableIRQ(USB0_0_IRQn);
	data_count = device.Driver->EndpointWrite(ep->Address,
			ep->InDataBuffer,ep->InDataLeft);
	ep->InDataBuffer += data_count;
 80252de:	4402      	add	r2, r0
	ep->InDataLeft -= data_count;
 80252e0:	1a1b      	subs	r3, r3, r0
	ep->InBytesAvailable = 0;
	/* make next 3 operations atomic. Do not get interrupted.*/
	NVIC_DisableIRQ(USB0_0_IRQn);
	data_count = device.Driver->EndpointWrite(ep->Address,
			ep->InDataBuffer,ep->InDataLeft);
	ep->InDataBuffer += data_count;
 80252e2:	606a      	str	r2, [r5, #4]
	ep->InDataLeft -= data_count;
 80252e4:	60a3      	str	r3, [r4, #8]
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 80252e6:	60f7      	str	r7, [r6, #12]
 80252e8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80252ea:	bf00      	nop
 80252ec:	1fff05b0 	.word	0x1fff05b0
 80252f0:	e000e100 	.word	0xe000e100

080252f4 <Endpoint_IsReadWriteAllowed>:
	NVIC_EnableIRQ(USB0_0_IRQn);

}

bool Endpoint_IsReadWriteAllowed() {
	USBD_Endpoint_t *EndPoint = &device.Endpoints[device.CurrentEndpoint];
 80252f4:	4b0a      	ldr	r3, [pc, #40]	; (8025320 <Endpoint_IsReadWriteAllowed+0x2c>)
 80252f6:	f893 213c 	ldrb.w	r2, [r3, #316]	; 0x13c
	bool Retval = false;

	if(EndPoint->Direction)
 80252fa:	212c      	movs	r1, #44	; 0x2c
 80252fc:	fb01 3302 	mla	r3, r1, r2, r3
 8025300:	791a      	ldrb	r2, [r3, #4]
 8025302:	0612      	lsls	r2, r2, #24
 8025304:	d404      	bmi.n	8025310 <Endpoint_IsReadWriteAllowed+0x1c>
		Retval = (EndPoint->InBytesAvailable < EndPoint->InBufferLength)
														? true : false;
	}
	else
	{
		Retval = (EndPoint->OutBytesAvailable > 0) ? true : false;
 8025306:	68d8      	ldr	r0, [r3, #12]
 8025308:	3000      	adds	r0, #0
 802530a:	bf18      	it	ne
 802530c:	2001      	movne	r0, #1
	}
	return Retval;
}
 802530e:	4770      	bx	lr
	USBD_Endpoint_t *EndPoint = &device.Endpoints[device.CurrentEndpoint];
	bool Retval = false;

	if(EndPoint->Direction)
	{
		Retval = (EndPoint->InBytesAvailable < EndPoint->InBufferLength)
 8025310:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8025312:	69da      	ldr	r2, [r3, #28]
 8025314:	4282      	cmp	r2, r0
 8025316:	bf2c      	ite	cs
 8025318:	2000      	movcs	r0, #0
 802531a:	2001      	movcc	r0, #1
 802531c:	4770      	bx	lr
 802531e:	bf00      	nop
 8025320:	1fff05b0 	.word	0x1fff05b0

08025324 <Endpoint_Write_8>:
	}
	return Retval;
}

void Endpoint_Write_8(const uint8_t Data) {
	USBD_Endpoint_t *EndPoint = &device.Endpoints[device.CurrentEndpoint];
 8025324:	4a09      	ldr	r2, [pc, #36]	; (802534c <Endpoint_Write_8+0x28>)
 8025326:	f892 313c 	ldrb.w	r3, [r2, #316]	; 0x13c
 802532a:	212c      	movs	r1, #44	; 0x2c
 802532c:	fb01 2203 	mla	r2, r1, r3, r2
 8025330:	f102 0318 	add.w	r3, r2, #24
 8025334:	6a51      	ldr	r1, [r2, #36]	; 0x24
 8025336:	685a      	ldr	r2, [r3, #4]
 8025338:	428a      	cmp	r2, r1
 802533a:	d300      	bcc.n	802533e <Endpoint_Write_8+0x1a>
 802533c:	e7fe      	b.n	802533c <Endpoint_Write_8+0x18>

	 do
	  {
	    if(EndPoint->InBytesAvailable < EndPoint->InBufferLength)
	    {
	      EndPoint->InBuffer[EndPoint->InBytesAvailable] = Data;
 802533e:	6899      	ldr	r1, [r3, #8]
 8025340:	5488      	strb	r0, [r1, r2]
	      EndPoint->InBytesAvailable++;
 8025342:	685a      	ldr	r2, [r3, #4]
 8025344:	3201      	adds	r2, #1
 8025346:	605a      	str	r2, [r3, #4]
 8025348:	4770      	bx	lr
 802534a:	bf00      	nop
 802534c:	1fff05b0 	.word	0x1fff05b0

08025350 <Endpoint_Read_8>:
	    }
	  }while(!Success);
}

uint8_t Endpoint_Read_8() {
	USBD_Endpoint_t *EndPoint = &device.Endpoints[device.CurrentEndpoint];
 8025350:	4b09      	ldr	r3, [pc, #36]	; (8025378 <Endpoint_Read_8+0x28>)
 8025352:	f893 213c 	ldrb.w	r2, [r3, #316]	; 0x13c
 8025356:	212c      	movs	r1, #44	; 0x2c
 8025358:	fb01 3302 	mla	r3, r1, r2, r3
 802535c:	f103 0208 	add.w	r2, r3, #8
 8025360:	6851      	ldr	r1, [r2, #4]
 8025362:	b901      	cbnz	r1, 8025366 <Endpoint_Read_8+0x16>
 8025364:	e7fe      	b.n	8025364 <Endpoint_Read_8+0x14>

	 do
	  {
		if(EndPoint->OutBytesAvailable > 0)
		{
		  data = EndPoint->OutBuffer[EndPoint->OutOffset];
 8025366:	6958      	ldr	r0, [r3, #20]
 8025368:	6893      	ldr	r3, [r2, #8]
		  EndPoint->OutOffset++;
		  EndPoint->OutBytesAvailable--;
 802536a:	3901      	subs	r1, #1

	 do
	  {
		if(EndPoint->OutBytesAvailable > 0)
		{
		  data = EndPoint->OutBuffer[EndPoint->OutOffset];
 802536c:	5cc0      	ldrb	r0, [r0, r3]
		  EndPoint->OutOffset++;
		  EndPoint->OutBytesAvailable--;
 802536e:	6051      	str	r1, [r2, #4]
	 do
	  {
		if(EndPoint->OutBytesAvailable > 0)
		{
		  data = EndPoint->OutBuffer[EndPoint->OutOffset];
		  EndPoint->OutOffset++;
 8025370:	3301      	adds	r3, #1
 8025372:	6093      	str	r3, [r2, #8]

		  Success = true;
		}
	  }while(!Success);
	 return data;
}
 8025374:	4770      	bx	lr
 8025376:	bf00      	nop
 8025378:	1fff05b0 	.word	0x1fff05b0

0802537c <Endpoint_Write_32_LE>:

void Endpoint_Write_32_LE(const uint32_t Data) {
	USBD_Endpoint_t *EndPoint = &device.Endpoints[device.CurrentEndpoint];
 802537c:	4a09      	ldr	r2, [pc, #36]	; (80253a4 <Endpoint_Write_32_LE+0x28>)
 802537e:	f892 313c 	ldrb.w	r3, [r2, #316]	; 0x13c
 8025382:	212c      	movs	r1, #44	; 0x2c
 8025384:	fb01 2203 	mla	r2, r1, r3, r2
 8025388:	f102 0318 	add.w	r3, r2, #24
 802538c:	6a52      	ldr	r2, [r2, #36]	; 0x24
 802538e:	6859      	ldr	r1, [r3, #4]
 8025390:	3a03      	subs	r2, #3
 8025392:	4291      	cmp	r1, r2
 8025394:	d300      	bcc.n	8025398 <Endpoint_Write_32_LE+0x1c>
 8025396:	e7fe      	b.n	8025396 <Endpoint_Write_32_LE+0x1a>
	bool Success = false;

	do {
		if(EndPoint->InBytesAvailable < (EndPoint->InBufferLength - 3)) {
			*(uint32_t*)(EndPoint->InBuffer + EndPoint->InBytesAvailable) =
 8025398:	689a      	ldr	r2, [r3, #8]
 802539a:	5050      	str	r0, [r2, r1]
																		Data;
			EndPoint->InBytesAvailable+=4;
 802539c:	685a      	ldr	r2, [r3, #4]
 802539e:	3204      	adds	r2, #4
 80253a0:	605a      	str	r2, [r3, #4]
 80253a2:	4770      	bx	lr
 80253a4:	1fff05b0 	.word	0x1fff05b0

080253a8 <Endpoint_Read_32_LE>:
		}
	}while(!Success);
}

uint32_t Endpoint_Read_32_LE() {
	USBD_Endpoint_t *EndPoint = &device.Endpoints[device.CurrentEndpoint];
 80253a8:	4b09      	ldr	r3, [pc, #36]	; (80253d0 <Endpoint_Read_32_LE+0x28>)
 80253aa:	f893 213c 	ldrb.w	r2, [r3, #316]	; 0x13c
 80253ae:	212c      	movs	r1, #44	; 0x2c
 80253b0:	fb01 3302 	mla	r3, r1, r2, r3
 80253b4:	f103 0208 	add.w	r2, r3, #8
 80253b8:	6851      	ldr	r1, [r2, #4]
 80253ba:	2903      	cmp	r1, #3
 80253bc:	d800      	bhi.n	80253c0 <Endpoint_Read_32_LE+0x18>
 80253be:	e7fe      	b.n	80253be <Endpoint_Read_32_LE+0x16>
	bool Success = false;
	uint32_t data = 0;

	do {
		if(EndPoint->OutBytesAvailable > 3) {
			data = *(uint32_t*)(EndPoint->OutBuffer + EndPoint->OutOffset);
 80253c0:	6958      	ldr	r0, [r3, #20]
 80253c2:	6893      	ldr	r3, [r2, #8]
			EndPoint->OutOffset+=4;
			EndPoint->OutBytesAvailable-=4;
 80253c4:	3904      	subs	r1, #4
	bool Success = false;
	uint32_t data = 0;

	do {
		if(EndPoint->OutBytesAvailable > 3) {
			data = *(uint32_t*)(EndPoint->OutBuffer + EndPoint->OutOffset);
 80253c6:	58c0      	ldr	r0, [r0, r3]
			EndPoint->OutOffset+=4;
			EndPoint->OutBytesAvailable-=4;
 80253c8:	6051      	str	r1, [r2, #4]
	uint32_t data = 0;

	do {
		if(EndPoint->OutBytesAvailable > 3) {
			data = *(uint32_t*)(EndPoint->OutBuffer + EndPoint->OutOffset);
			EndPoint->OutOffset+=4;
 80253ca:	3304      	adds	r3, #4
 80253cc:	6093      	str	r3, [r2, #8]

			Success = true;
		}
	} while(!Success);
	return data;
}
 80253ce:	4770      	bx	lr
 80253d0:	1fff05b0 	.word	0x1fff05b0

080253d4 <Endpoint_ConfigureEndpointTable>:

bool Endpoint_ConfigureEndpointTable(const USB_Endpoint_Table_t* const Table,
			                                     const uint8_t Entries) {
	uint8_t i;
	uint8_t Number;
	for (i=0;i<Entries;i++) {
 80253d4:	2900      	cmp	r1, #0
 80253d6:	d042      	beq.n	802545e <Endpoint_ConfigureEndpointTable+0x8a>
	} while(!Success);
	return data;
}

bool Endpoint_ConfigureEndpointTable(const USB_Endpoint_Table_t* const Table,
			                                     const uint8_t Entries) {
 80253d8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80253dc:	1e4d      	subs	r5, r1, #1
 80253de:	b2e9      	uxtb	r1, r5
 80253e0:	4f20      	ldr	r7, [pc, #128]	; (8025464 <Endpoint_ConfigureEndpointTable+0x90>)
 80253e2:	2506      	movs	r5, #6
 80253e4:	fb05 0501 	mla	r5, r5, r1, r0
 80253e8:	350a      	adds	r5, #10
 80253ea:	f100 0904 	add.w	r9, r0, #4
	uint8_t i;
	uint8_t Number;
	for (i=0;i<Entries;i++) {
		Number = Table[i].Address & ENDPOINT_EPNUM_MASK;
		/* Configure endpoint in device controller driver */
		if (device.Driver->EndpointConfigure(Table[i].Address,
 80253ee:	463e      	mov	r6, r7
				(XMC_USBD_ENDPOINT_TYPE_t)Table[i].Type,Table[i].Size) !=
																XMC_USBD_STATUS_OK)
			return false;
		/* Set device core values */
		device.Endpoints[Number].Address = Table[i].Address;
 80253f0:	f04f 082c 	mov.w	r8, #44	; 0x2c
 80253f4:	e01c      	b.n	8025430 <Endpoint_ConfigureEndpointTable+0x5c>
 80253f6:	f819 2c04 	ldrb.w	r2, [r9, #-4]
 80253fa:	711a      	strb	r2, [r3, #4]
		device.Endpoints[Number].MaxPacketSize = Table[i].Size;
 80253fc:	f839 2c02 	ldrh.w	r2, [r9, #-2]
 8025400:	8919      	ldrh	r1, [r3, #8]
 8025402:	f362 118c 	bfi	r1, r2, #6, #7
		device.Endpoints[Number].IsConfigured = 1;
 8025406:	b2ca      	uxtb	r2, r1
 8025408:	f042 0201 	orr.w	r2, r2, #1
				(XMC_USBD_ENDPOINT_TYPE_t)Table[i].Type,Table[i].Size) !=
																XMC_USBD_STATUS_OK)
			return false;
		/* Set device core values */
		device.Endpoints[Number].Address = Table[i].Address;
		device.Endpoints[Number].MaxPacketSize = Table[i].Size;
 802540c:	8119      	strh	r1, [r3, #8]
		device.Endpoints[Number].IsConfigured = 1;
 802540e:	721a      	strb	r2, [r3, #8]
		device.Endpoints[Number].IsEnabled = 1;
 8025410:	891a      	ldrh	r2, [r3, #8]
 8025412:	f042 0202 	orr.w	r2, r2, #2
 8025416:	811a      	strh	r2, [r3, #8]
		/* Start read for out endpoints */
		if (!(Table[i].Address & ENDPOINT_DIR_MASK))
 8025418:	f819 0c04 	ldrb.w	r0, [r9, #-4]
 802541c:	0602      	lsls	r2, r0, #24
 802541e:	f109 0906 	add.w	r9, r9, #6
 8025422:	d403      	bmi.n	802542c <Endpoint_ConfigureEndpointTable+0x58>
			device.Driver->EndpointReadStart(Table[i].Address,
 8025424:	6832      	ldr	r2, [r6, #0]
 8025426:	6999      	ldr	r1, [r3, #24]
 8025428:	6a93      	ldr	r3, [r2, #40]	; 0x28
 802542a:	4798      	blx	r3

bool Endpoint_ConfigureEndpointTable(const USB_Endpoint_Table_t* const Table,
			                                     const uint8_t Entries) {
	uint8_t i;
	uint8_t Number;
	for (i=0;i<Entries;i++) {
 802542c:	45a9      	cmp	r9, r5
 802542e:	d013      	beq.n	8025458 <Endpoint_ConfigureEndpointTable+0x84>
		Number = Table[i].Address & ENDPOINT_EPNUM_MASK;
 8025430:	f819 3c04 	ldrb.w	r3, [r9, #-4]
		/* Configure endpoint in device controller driver */
		if (device.Driver->EndpointConfigure(Table[i].Address,
 8025434:	683a      	ldr	r2, [r7, #0]
 8025436:	f899 1000 	ldrb.w	r1, [r9]
 802543a:	f8d2 c01c 	ldr.w	ip, [r2, #28]
 802543e:	f839 2c02 	ldrh.w	r2, [r9, #-2]
 8025442:	4618      	mov	r0, r3
bool Endpoint_ConfigureEndpointTable(const USB_Endpoint_Table_t* const Table,
			                                     const uint8_t Entries) {
	uint8_t i;
	uint8_t Number;
	for (i=0;i<Entries;i++) {
		Number = Table[i].Address & ENDPOINT_EPNUM_MASK;
 8025444:	f003 040f 	and.w	r4, r3, #15
		/* Configure endpoint in device controller driver */
		if (device.Driver->EndpointConfigure(Table[i].Address,
 8025448:	47e0      	blx	ip
				(XMC_USBD_ENDPOINT_TYPE_t)Table[i].Type,Table[i].Size) !=
																XMC_USBD_STATUS_OK)
			return false;
		/* Set device core values */
		device.Endpoints[Number].Address = Table[i].Address;
 802544a:	fb08 6304 	mla	r3, r8, r4, r6
	uint8_t i;
	uint8_t Number;
	for (i=0;i<Entries;i++) {
		Number = Table[i].Address & ENDPOINT_EPNUM_MASK;
		/* Configure endpoint in device controller driver */
		if (device.Driver->EndpointConfigure(Table[i].Address,
 802544e:	2800      	cmp	r0, #0
 8025450:	d0d1      	beq.n	80253f6 <Endpoint_ConfigureEndpointTable+0x22>
				(XMC_USBD_ENDPOINT_TYPE_t)Table[i].Type,Table[i].Size) !=
																XMC_USBD_STATUS_OK)
			return false;
 8025452:	2000      	movs	r0, #0
		if (!(Table[i].Address & ENDPOINT_DIR_MASK))
			device.Driver->EndpointReadStart(Table[i].Address,
					device.Endpoints[Number].OutBufferLength);
	}
	return true;
}
 8025454:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		/* Start read for out endpoints */
		if (!(Table[i].Address & ENDPOINT_DIR_MASK))
			device.Driver->EndpointReadStart(Table[i].Address,
					device.Endpoints[Number].OutBufferLength);
	}
	return true;
 8025458:	2001      	movs	r0, #1
 802545a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 802545e:	2001      	movs	r0, #1
}
 8025460:	4770      	bx	lr
 8025462:	bf00      	nop
 8025464:	1fff05b0 	.word	0x1fff05b0

08025468 <USBD_SignalDeviceEventHandler>:
 */
static void USBD_SignalDeviceEventHandler(XMC_USBD_EVENT_t event)
{
  uint32_t i;

  switch (event)
 8025468:	2809      	cmp	r0, #9
 802546a:	d80e      	bhi.n	802548a <USBD_SignalDeviceEventHandler+0x22>
 802546c:	e8df f010 	tbh	[pc, r0, lsl #1]
 8025470:	0019000a 	.word	0x0019000a
 8025474:	002a0023 	.word	0x002a0023
 8025478:	000d0034 	.word	0x000d0034
 802547c:	000e00e8 	.word	0x000e00e8
 8025480:	00f6000d 	.word	0x00f6000d
      {
        device.events->disconnect();
      }
      break;
    case XMC_USBD_EVENT_POWER_ON:
      USB_DeviceState = (uint8_t)DEVICE_STATE_Powered;
 8025484:	4bb7      	ldr	r3, [pc, #732]	; (8025764 <USBD_SignalDeviceEventHandler+0x2fc>)
 8025486:	2201      	movs	r2, #1
 8025488:	701a      	strb	r2, [r3, #0]
 802548a:	4770      	bx	lr
      break;
    case XMC_USBD_EVENT_REMOTE_WAKEUP:
      break;
    case XMC_USBD_EVENT_RESUME:
      USB_DeviceState = (uint8_t)device.pre_suspend_device_state;
 802548c:	4bb6      	ldr	r3, [pc, #728]	; (8025768 <USBD_SignalDeviceEventHandler+0x300>)
 802548e:	4ab5      	ldr	r2, [pc, #724]	; (8025764 <USBD_SignalDeviceEventHandler+0x2fc>)
      if (NULL != device.events->wakeup)
 8025490:	f8d3 0140 	ldr.w	r0, [r3, #320]	; 0x140
      USB_DeviceState = (uint8_t)DEVICE_STATE_Powered;
      break;
    case XMC_USBD_EVENT_REMOTE_WAKEUP:
      break;
    case XMC_USBD_EVENT_RESUME:
      USB_DeviceState = (uint8_t)device.pre_suspend_device_state;
 8025494:	f893 113a 	ldrb.w	r1, [r3, #314]	; 0x13a
      if (NULL != device.events->wakeup)
 8025498:	6983      	ldr	r3, [r0, #24]
      USB_DeviceState = (uint8_t)DEVICE_STATE_Powered;
      break;
    case XMC_USBD_EVENT_REMOTE_WAKEUP:
      break;
    case XMC_USBD_EVENT_RESUME:
      USB_DeviceState = (uint8_t)device.pre_suspend_device_state;
 802549a:	7011      	strb	r1, [r2, #0]
      if (NULL != device.events->wakeup)
 802549c:	2b00      	cmp	r3, #0
 802549e:	d0f4      	beq.n	802548a <USBD_SignalDeviceEventHandler+0x22>
      {
        device.events->wakeup();
 80254a0:	4718      	bx	r3
        device.events->disconnect();
      }
      break;
    case XMC_USBD_EVENT_POWER_OFF:
      USB_DeviceState = (uint8_t)DEVICE_STATE_Unattached;
      if (NULL != device.events->disconnect)
 80254a2:	4bb1      	ldr	r3, [pc, #708]	; (8025768 <USBD_SignalDeviceEventHandler+0x300>)
      {
        device.events->disconnect();
      }
      break;
    case XMC_USBD_EVENT_POWER_OFF:
      USB_DeviceState = (uint8_t)DEVICE_STATE_Unattached;
 80254a4:	4aaf      	ldr	r2, [pc, #700]	; (8025764 <USBD_SignalDeviceEventHandler+0x2fc>)
      if (NULL != device.events->disconnect)
 80254a6:	f8d3 3140 	ldr.w	r3, [r3, #320]	; 0x140
 80254aa:	685b      	ldr	r3, [r3, #4]
      {
        device.events->disconnect();
      }
      break;
    case XMC_USBD_EVENT_POWER_OFF:
      USB_DeviceState = (uint8_t)DEVICE_STATE_Unattached;
 80254ac:	2100      	movs	r1, #0
 80254ae:	7011      	strb	r1, [r2, #0]
      if (NULL != device.events->disconnect)
 80254b0:	2b00      	cmp	r3, #0
 80254b2:	d1f5      	bne.n	80254a0 <USBD_SignalDeviceEventHandler+0x38>
 80254b4:	e7e9      	b.n	802548a <USBD_SignalDeviceEventHandler+0x22>
      {
        device.events->start_of_frame();
      }
      break;
    case XMC_USBD_EVENT_CONNECT:
      if (NULL != device.events->connect)
 80254b6:	4bac      	ldr	r3, [pc, #688]	; (8025768 <USBD_SignalDeviceEventHandler+0x300>)
 80254b8:	f8d3 3140 	ldr.w	r3, [r3, #320]	; 0x140
 80254bc:	681b      	ldr	r3, [r3, #0]
 80254be:	2b00      	cmp	r3, #0
 80254c0:	d1ee      	bne.n	80254a0 <USBD_SignalDeviceEventHandler+0x38>
 80254c2:	e7e2      	b.n	802548a <USBD_SignalDeviceEventHandler+0x22>
        device.events->connect();
      }
      break;
    case XMC_USBD_EVENT_DISCONNECT:
      USB_DeviceState = (uint8_t)DEVICE_STATE_Powered;
      if (NULL != device.events->disconnect)
 80254c4:	4ba8      	ldr	r3, [pc, #672]	; (8025768 <USBD_SignalDeviceEventHandler+0x300>)
      {
        device.events->connect();
      }
      break;
    case XMC_USBD_EVENT_DISCONNECT:
      USB_DeviceState = (uint8_t)DEVICE_STATE_Powered;
 80254c6:	4aa7      	ldr	r2, [pc, #668]	; (8025764 <USBD_SignalDeviceEventHandler+0x2fc>)
      if (NULL != device.events->disconnect)
 80254c8:	f8d3 3140 	ldr.w	r3, [r3, #320]	; 0x140
 80254cc:	685b      	ldr	r3, [r3, #4]
      {
        device.events->connect();
      }
      break;
    case XMC_USBD_EVENT_DISCONNECT:
      USB_DeviceState = (uint8_t)DEVICE_STATE_Powered;
 80254ce:	2101      	movs	r1, #1
 80254d0:	7011      	strb	r1, [r2, #0]
      if (NULL != device.events->disconnect)
 80254d2:	2b00      	cmp	r3, #0
 80254d4:	d1e4      	bne.n	80254a0 <USBD_SignalDeviceEventHandler+0x38>
 80254d6:	e7d8      	b.n	802548a <USBD_SignalDeviceEventHandler+0x22>
 * The device can have several events, by which it notifies the application about the occurance of event.
 * Not all events are available on all chip series. (Power Events are only supported on XMC4500)
 *
 */
static void USBD_SignalDeviceEventHandler(XMC_USBD_EVENT_t event)
{
 80254d8:	b570      	push	{r4, r5, r6, lr}
  uint32_t i;

  switch (event)
  {
    case XMC_USBD_EVENT_RESET:
      USB_DeviceState = (uint8_t)DEVICE_STATE_Default;
 80254da:	4ba2      	ldr	r3, [pc, #648]	; (8025764 <USBD_SignalDeviceEventHandler+0x2fc>)
      device.ep0_state = USBD_EP0_STATE_IDLE;
 80254dc:	4ca2      	ldr	r4, [pc, #648]	; (8025768 <USBD_SignalDeviceEventHandler+0x300>)
  uint32_t i;

  switch (event)
  {
    case XMC_USBD_EVENT_RESET:
      USB_DeviceState = (uint8_t)DEVICE_STATE_Default;
 80254de:	2202      	movs	r2, #2
 80254e0:	701a      	strb	r2, [r3, #0]
      device.ep0_state = USBD_EP0_STATE_IDLE;
      device.remote_wakeup = (uint8_t)0;
      /* Reset endpoints and configuration */
      for (i = ((uint32_t)XMC_USBD_NUM_EPS); i > 0U; i--)
      {
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].InInUse = (uint8_t)0;
 80254e2:	8922      	ldrh	r2, [r4, #8]
  switch (event)
  {
    case XMC_USBD_EVENT_RESET:
      USB_DeviceState = (uint8_t)DEVICE_STATE_Default;
      device.ep0_state = USBD_EP0_STATE_IDLE;
      device.remote_wakeup = (uint8_t)0;
 80254e4:	f894 313e 	ldrb.w	r3, [r4, #318]	; 0x13e
      /* Reset endpoints and configuration */
      for (i = ((uint32_t)XMC_USBD_NUM_EPS); i > 0U; i--)
      {
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].InInUse = (uint8_t)0;
 80254e8:	f36f 1204 	bfc	r2, #4, #1
 80254ec:	8122      	strh	r2, [r4, #8]
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
 80254ee:	8922      	ldrh	r2, [r4, #8]
 80254f0:	f36f 02c3 	bfc	r2, #3, #1
 80254f4:	8122      	strh	r2, [r4, #8]
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
 80254f6:	8922      	ldrh	r2, [r4, #8]
 80254f8:	f36f 0282 	bfc	r2, #2, #1
 80254fc:	8122      	strh	r2, [r4, #8]
      device.ep0_state = USBD_EP0_STATE_IDLE;
      device.remote_wakeup = (uint8_t)0;
      /* Reset endpoints and configuration */
      for (i = ((uint32_t)XMC_USBD_NUM_EPS); i > 0U; i--)
      {
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].InInUse = (uint8_t)0;
 80254fe:	8ea2      	ldrh	r2, [r4, #52]	; 0x34
 8025500:	f36f 1204 	bfc	r2, #4, #1
 8025504:	86a2      	strh	r2, [r4, #52]	; 0x34
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
 8025506:	8ea2      	ldrh	r2, [r4, #52]	; 0x34
 8025508:	f36f 02c3 	bfc	r2, #3, #1
 802550c:	86a2      	strh	r2, [r4, #52]	; 0x34
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
 802550e:	8ea2      	ldrh	r2, [r4, #52]	; 0x34
 8025510:	f36f 0282 	bfc	r2, #2, #1
 8025514:	86a2      	strh	r2, [r4, #52]	; 0x34
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
           (device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured))
 8025516:	f894 2034 	ldrb.w	r2, [r4, #52]	; 0x34
  switch (event)
  {
    case XMC_USBD_EVENT_RESET:
      USB_DeviceState = (uint8_t)DEVICE_STATE_Default;
      device.ep0_state = USBD_EP0_STATE_IDLE;
      device.remote_wakeup = (uint8_t)0;
 802551a:	f36f 0382 	bfc	r3, #2, #1

  switch (event)
  {
    case XMC_USBD_EVENT_RESET:
      USB_DeviceState = (uint8_t)DEVICE_STATE_Default;
      device.ep0_state = USBD_EP0_STATE_IDLE;
 802551e:	2101      	movs	r1, #1
      device.remote_wakeup = (uint8_t)0;
 8025520:	f884 313e 	strb.w	r3, [r4, #318]	; 0x13e
      for (i = ((uint32_t)XMC_USBD_NUM_EPS); i > 0U; i--)
      {
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].InInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
 8025524:	07d3      	lsls	r3, r2, #31

  switch (event)
  {
    case XMC_USBD_EVENT_RESET:
      USB_DeviceState = (uint8_t)DEVICE_STATE_Default;
      device.ep0_state = USBD_EP0_STATE_IDLE;
 8025526:	f884 113b 	strb.w	r1, [r4, #315]	; 0x13b
      for (i = ((uint32_t)XMC_USBD_NUM_EPS); i > 0U; i--)
      {
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].InInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
 802552a:	f100 809f 	bmi.w	802566c <USBD_SignalDeviceEventHandler+0x204>
      device.ep0_state = USBD_EP0_STATE_IDLE;
      device.remote_wakeup = (uint8_t)0;
      /* Reset endpoints and configuration */
      for (i = ((uint32_t)XMC_USBD_NUM_EPS); i > 0U; i--)
      {
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].InInUse = (uint8_t)0;
 802552e:	f8b4 3060 	ldrh.w	r3, [r4, #96]	; 0x60
 8025532:	4d8d      	ldr	r5, [pc, #564]	; (8025768 <USBD_SignalDeviceEventHandler+0x300>)
 8025534:	f36f 1304 	bfc	r3, #4, #1
 8025538:	f8a4 3060 	strh.w	r3, [r4, #96]	; 0x60
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
 802553c:	f8b4 3060 	ldrh.w	r3, [r4, #96]	; 0x60
 8025540:	f36f 03c3 	bfc	r3, #3, #1
 8025544:	f8a4 3060 	strh.w	r3, [r4, #96]	; 0x60
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
 8025548:	f8b4 3060 	ldrh.w	r3, [r4, #96]	; 0x60
 802554c:	f36f 0382 	bfc	r3, #2, #1
 8025550:	f8a4 3060 	strh.w	r3, [r4, #96]	; 0x60
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
           (device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured))
 8025554:	f894 3060 	ldrb.w	r3, [r4, #96]	; 0x60
      for (i = ((uint32_t)XMC_USBD_NUM_EPS); i > 0U; i--)
      {
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].InInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
 8025558:	07de      	lsls	r6, r3, #31
 802555a:	f100 80ec 	bmi.w	8025736 <USBD_SignalDeviceEventHandler+0x2ce>
      device.ep0_state = USBD_EP0_STATE_IDLE;
      device.remote_wakeup = (uint8_t)0;
      /* Reset endpoints and configuration */
      for (i = ((uint32_t)XMC_USBD_NUM_EPS); i > 0U; i--)
      {
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].InInUse = (uint8_t)0;
 802555e:	f8b4 308c 	ldrh.w	r3, [r4, #140]	; 0x8c
 8025562:	4d81      	ldr	r5, [pc, #516]	; (8025768 <USBD_SignalDeviceEventHandler+0x300>)
 8025564:	f36f 1304 	bfc	r3, #4, #1
 8025568:	f8a4 308c 	strh.w	r3, [r4, #140]	; 0x8c
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
 802556c:	f8b4 308c 	ldrh.w	r3, [r4, #140]	; 0x8c
 8025570:	f36f 03c3 	bfc	r3, #3, #1
 8025574:	f8a4 308c 	strh.w	r3, [r4, #140]	; 0x8c
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
 8025578:	f8b4 308c 	ldrh.w	r3, [r4, #140]	; 0x8c
 802557c:	f36f 0382 	bfc	r3, #2, #1
 8025580:	f8a4 308c 	strh.w	r3, [r4, #140]	; 0x8c
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
           (device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured))
 8025584:	f894 308c 	ldrb.w	r3, [r4, #140]	; 0x8c
      for (i = ((uint32_t)XMC_USBD_NUM_EPS); i > 0U; i--)
      {
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].InInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
 8025588:	07d8      	lsls	r0, r3, #31
 802558a:	f100 80bf 	bmi.w	802570c <USBD_SignalDeviceEventHandler+0x2a4>
      device.ep0_state = USBD_EP0_STATE_IDLE;
      device.remote_wakeup = (uint8_t)0;
      /* Reset endpoints and configuration */
      for (i = ((uint32_t)XMC_USBD_NUM_EPS); i > 0U; i--)
      {
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].InInUse = (uint8_t)0;
 802558e:	f8b4 30b8 	ldrh.w	r3, [r4, #184]	; 0xb8
 8025592:	4d75      	ldr	r5, [pc, #468]	; (8025768 <USBD_SignalDeviceEventHandler+0x300>)
 8025594:	f36f 1304 	bfc	r3, #4, #1
 8025598:	f8a4 30b8 	strh.w	r3, [r4, #184]	; 0xb8
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
 802559c:	f8b4 30b8 	ldrh.w	r3, [r4, #184]	; 0xb8
 80255a0:	f36f 03c3 	bfc	r3, #3, #1
 80255a4:	f8a4 30b8 	strh.w	r3, [r4, #184]	; 0xb8
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
 80255a8:	f8b4 30b8 	ldrh.w	r3, [r4, #184]	; 0xb8
 80255ac:	f36f 0382 	bfc	r3, #2, #1
 80255b0:	f8a4 30b8 	strh.w	r3, [r4, #184]	; 0xb8
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
           (device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured))
 80255b4:	f894 30b8 	ldrb.w	r3, [r4, #184]	; 0xb8
      for (i = ((uint32_t)XMC_USBD_NUM_EPS); i > 0U; i--)
      {
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].InInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
 80255b8:	07d9      	lsls	r1, r3, #31
 80255ba:	f100 8092 	bmi.w	80256e2 <USBD_SignalDeviceEventHandler+0x27a>
      device.ep0_state = USBD_EP0_STATE_IDLE;
      device.remote_wakeup = (uint8_t)0;
      /* Reset endpoints and configuration */
      for (i = ((uint32_t)XMC_USBD_NUM_EPS); i > 0U; i--)
      {
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].InInUse = (uint8_t)0;
 80255be:	f8b4 30e4 	ldrh.w	r3, [r4, #228]	; 0xe4
 80255c2:	4d69      	ldr	r5, [pc, #420]	; (8025768 <USBD_SignalDeviceEventHandler+0x300>)
 80255c4:	f36f 1304 	bfc	r3, #4, #1
 80255c8:	f8a4 30e4 	strh.w	r3, [r4, #228]	; 0xe4
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
 80255cc:	f8b4 30e4 	ldrh.w	r3, [r4, #228]	; 0xe4
 80255d0:	f36f 03c3 	bfc	r3, #3, #1
 80255d4:	f8a4 30e4 	strh.w	r3, [r4, #228]	; 0xe4
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
 80255d8:	f8b4 30e4 	ldrh.w	r3, [r4, #228]	; 0xe4
 80255dc:	f36f 0382 	bfc	r3, #2, #1
 80255e0:	f8a4 30e4 	strh.w	r3, [r4, #228]	; 0xe4
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
           (device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured))
 80255e4:	f894 30e4 	ldrb.w	r3, [r4, #228]	; 0xe4
      for (i = ((uint32_t)XMC_USBD_NUM_EPS); i > 0U; i--)
      {
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].InInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
 80255e8:	07da      	lsls	r2, r3, #31
 80255ea:	d466      	bmi.n	80256ba <USBD_SignalDeviceEventHandler+0x252>
      device.ep0_state = USBD_EP0_STATE_IDLE;
      device.remote_wakeup = (uint8_t)0;
      /* Reset endpoints and configuration */
      for (i = ((uint32_t)XMC_USBD_NUM_EPS); i > 0U; i--)
      {
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].InInUse = (uint8_t)0;
 80255ec:	f8b4 3110 	ldrh.w	r3, [r4, #272]	; 0x110
 80255f0:	4d5d      	ldr	r5, [pc, #372]	; (8025768 <USBD_SignalDeviceEventHandler+0x300>)
 80255f2:	f36f 1304 	bfc	r3, #4, #1
 80255f6:	f8a4 3110 	strh.w	r3, [r4, #272]	; 0x110
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
 80255fa:	f8b4 3110 	ldrh.w	r3, [r4, #272]	; 0x110
 80255fe:	f36f 03c3 	bfc	r3, #3, #1
 8025602:	f8a4 3110 	strh.w	r3, [r4, #272]	; 0x110
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
 8025606:	f8b4 3110 	ldrh.w	r3, [r4, #272]	; 0x110
 802560a:	f36f 0382 	bfc	r3, #2, #1
 802560e:	f8a4 3110 	strh.w	r3, [r4, #272]	; 0x110
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
           (device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured))
 8025612:	f894 3110 	ldrb.w	r3, [r4, #272]	; 0x110
      for (i = ((uint32_t)XMC_USBD_NUM_EPS); i > 0U; i--)
      {
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].InInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
 8025616:	07db      	lsls	r3, r3, #31
 8025618:	d43b      	bmi.n	8025692 <USBD_SignalDeviceEventHandler+0x22a>
            device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured = (uint8_t)0;
            device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsEnabled = (uint8_t)0;
          }
        }
      }
      device.configuration = (uint8_t)0;
 802561a:	2300      	movs	r3, #0
      for (i = ((uint32_t)NUM_INTERFACES); i > 0U; i--)
      {
        device.interface_settings[((uint32_t)NUM_INTERFACES - i)] = (uint8_t)0;
      }
      device.Driver->EndpointReadStart((uint8_t)device.Endpoints[0].Address,(uint32_t)USBD_EP0_3SETUP_PKT_SIZE);
 802561c:	6822      	ldr	r2, [r4, #0]
            device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured = (uint8_t)0;
            device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsEnabled = (uint8_t)0;
          }
        }
      }
      device.configuration = (uint8_t)0;
 802561e:	f884 3139 	strb.w	r3, [r4, #313]	; 0x139
      for (i = ((uint32_t)NUM_INTERFACES); i > 0U; i--)
      {
        device.interface_settings[((uint32_t)NUM_INTERFACES - i)] = (uint8_t)0;
 8025622:	f884 3138 	strb.w	r3, [r4, #312]	; 0x138
      }
      device.Driver->EndpointReadStart((uint8_t)device.Endpoints[0].Address,(uint32_t)USBD_EP0_3SETUP_PKT_SIZE);
 8025626:	6a93      	ldr	r3, [r2, #40]	; 0x28
 8025628:	7920      	ldrb	r0, [r4, #4]
 802562a:	2118      	movs	r1, #24
 802562c:	4798      	blx	r3
      if (NULL != device.events->reset)
 802562e:	f8d4 3140 	ldr.w	r3, [r4, #320]	; 0x140
 8025632:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8025634:	2b00      	cmp	r3, #0
 8025636:	f000 8093 	beq.w	8025760 <USBD_SignalDeviceEventHandler+0x2f8>
      }
      break;
    default:
      break;
  }
}
 802563a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        device.interface_settings[((uint32_t)NUM_INTERFACES - i)] = (uint8_t)0;
      }
      device.Driver->EndpointReadStart((uint8_t)device.Endpoints[0].Address,(uint32_t)USBD_EP0_3SETUP_PKT_SIZE);
      if (NULL != device.events->reset)
      {
        device.events->reset();
 802563e:	4718      	bx	r3
      {
        device.events->wakeup();
      }
      break;
    case XMC_USBD_EVENT_SUSPEND:
      device.pre_suspend_device_state = USB_DeviceState;
 8025640:	4a49      	ldr	r2, [pc, #292]	; (8025768 <USBD_SignalDeviceEventHandler+0x300>)
 8025642:	4b48      	ldr	r3, [pc, #288]	; (8025764 <USBD_SignalDeviceEventHandler+0x2fc>)
      USB_DeviceState = (uint8_t)DEVICE_STATE_Suspended;
      if (NULL != device.events->suspend)
 8025644:	f8d2 1140 	ldr.w	r1, [r2, #320]	; 0x140
      {
        device.events->wakeup();
      }
      break;
    case XMC_USBD_EVENT_SUSPEND:
      device.pre_suspend_device_state = USB_DeviceState;
 8025648:	7818      	ldrb	r0, [r3, #0]
 802564a:	f882 013a 	strb.w	r0, [r2, #314]	; 0x13a
      USB_DeviceState = (uint8_t)DEVICE_STATE_Suspended;
      if (NULL != device.events->suspend)
 802564e:	69ca      	ldr	r2, [r1, #28]
        device.events->wakeup();
      }
      break;
    case XMC_USBD_EVENT_SUSPEND:
      device.pre_suspend_device_state = USB_DeviceState;
      USB_DeviceState = (uint8_t)DEVICE_STATE_Suspended;
 8025650:	2105      	movs	r1, #5
 8025652:	7019      	strb	r1, [r3, #0]
      if (NULL != device.events->suspend)
 8025654:	2a00      	cmp	r2, #0
 8025656:	f43f af18 	beq.w	802548a <USBD_SignalDeviceEventHandler+0x22>
      {
        device.events->suspend();
 802565a:	4710      	bx	r2
      {
        device.events->reset();
      }
      break;
    case XMC_USBD_EVENT_SOF:
      if (NULL != device.events->start_of_frame)
 802565c:	4b42      	ldr	r3, [pc, #264]	; (8025768 <USBD_SignalDeviceEventHandler+0x300>)
 802565e:	f8d3 3140 	ldr.w	r3, [r3, #320]	; 0x140
 8025662:	6a1b      	ldr	r3, [r3, #32]
 8025664:	2b00      	cmp	r3, #0
 8025666:	f47f af1b 	bne.w	80254a0 <USBD_SignalDeviceEventHandler+0x38>
 802566a:	e70e      	b.n	802548a <USBD_SignalDeviceEventHandler+0x22>
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
           (device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured))
        {
          if (USBD_STATUS_SUCCESS == 
          (USBD_STATUS_t)device.Driver->EndpointUnconfigure
 802566c:	6823      	ldr	r3, [r4, #0]
 802566e:	f894 0030 	ldrb.w	r0, [r4, #48]	; 0x30
 8025672:	6a1b      	ldr	r3, [r3, #32]
 8025674:	4798      	blx	r3
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
           (device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured))
        {
          if (USBD_STATUS_SUCCESS == 
 8025676:	2800      	cmp	r0, #0
 8025678:	f47f af59 	bne.w	802552e <USBD_SignalDeviceEventHandler+0xc6>
          (USBD_STATUS_t)device.Driver->EndpointUnconfigure
          ((uint8_t)device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].Address))
          {
            device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured = (uint8_t)0;
 802567c:	f894 3034 	ldrb.w	r3, [r4, #52]	; 0x34
 8025680:	f360 0300 	bfi	r3, r0, #0, #1
 8025684:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
            device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsEnabled = (uint8_t)0;
 8025688:	8ea3      	ldrh	r3, [r4, #52]	; 0x34
 802568a:	f360 0341 	bfi	r3, r0, #1, #1
 802568e:	86a3      	strh	r3, [r4, #52]	; 0x34
 8025690:	e74d      	b.n	802552e <USBD_SignalDeviceEventHandler+0xc6>
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
           (device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured))
        {
          if (USBD_STATUS_SUCCESS == 
          (USBD_STATUS_t)device.Driver->EndpointUnconfigure
 8025692:	682b      	ldr	r3, [r5, #0]
 8025694:	f895 010c 	ldrb.w	r0, [r5, #268]	; 0x10c
 8025698:	6a1b      	ldr	r3, [r3, #32]
 802569a:	4798      	blx	r3
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
           (device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured))
        {
          if (USBD_STATUS_SUCCESS == 
 802569c:	2800      	cmp	r0, #0
 802569e:	d1bc      	bne.n	802561a <USBD_SignalDeviceEventHandler+0x1b2>
          (USBD_STATUS_t)device.Driver->EndpointUnconfigure
          ((uint8_t)device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].Address))
          {
            device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured = (uint8_t)0;
 80256a0:	f895 3110 	ldrb.w	r3, [r5, #272]	; 0x110
 80256a4:	f360 0300 	bfi	r3, r0, #0, #1
 80256a8:	f885 3110 	strb.w	r3, [r5, #272]	; 0x110
            device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsEnabled = (uint8_t)0;
 80256ac:	f8b5 3110 	ldrh.w	r3, [r5, #272]	; 0x110
 80256b0:	f360 0341 	bfi	r3, r0, #1, #1
 80256b4:	f8a5 3110 	strh.w	r3, [r5, #272]	; 0x110
 80256b8:	e7af      	b.n	802561a <USBD_SignalDeviceEventHandler+0x1b2>
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
           (device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured))
        {
          if (USBD_STATUS_SUCCESS == 
          (USBD_STATUS_t)device.Driver->EndpointUnconfigure
 80256ba:	682b      	ldr	r3, [r5, #0]
 80256bc:	f895 00e0 	ldrb.w	r0, [r5, #224]	; 0xe0
 80256c0:	6a1b      	ldr	r3, [r3, #32]
 80256c2:	4798      	blx	r3
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
           (device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured))
        {
          if (USBD_STATUS_SUCCESS == 
 80256c4:	2800      	cmp	r0, #0
 80256c6:	d191      	bne.n	80255ec <USBD_SignalDeviceEventHandler+0x184>
          (USBD_STATUS_t)device.Driver->EndpointUnconfigure
          ((uint8_t)device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].Address))
          {
            device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured = (uint8_t)0;
 80256c8:	f895 30e4 	ldrb.w	r3, [r5, #228]	; 0xe4
 80256cc:	f360 0300 	bfi	r3, r0, #0, #1
 80256d0:	f885 30e4 	strb.w	r3, [r5, #228]	; 0xe4
            device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsEnabled = (uint8_t)0;
 80256d4:	f8b5 30e4 	ldrh.w	r3, [r5, #228]	; 0xe4
 80256d8:	f360 0341 	bfi	r3, r0, #1, #1
 80256dc:	f8a5 30e4 	strh.w	r3, [r5, #228]	; 0xe4
 80256e0:	e784      	b.n	80255ec <USBD_SignalDeviceEventHandler+0x184>
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
           (device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured))
        {
          if (USBD_STATUS_SUCCESS == 
          (USBD_STATUS_t)device.Driver->EndpointUnconfigure
 80256e2:	682b      	ldr	r3, [r5, #0]
 80256e4:	f895 00b4 	ldrb.w	r0, [r5, #180]	; 0xb4
 80256e8:	6a1b      	ldr	r3, [r3, #32]
 80256ea:	4798      	blx	r3
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
           (device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured))
        {
          if (USBD_STATUS_SUCCESS == 
 80256ec:	2800      	cmp	r0, #0
 80256ee:	f47f af66 	bne.w	80255be <USBD_SignalDeviceEventHandler+0x156>
          (USBD_STATUS_t)device.Driver->EndpointUnconfigure
          ((uint8_t)device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].Address))
          {
            device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured = (uint8_t)0;
 80256f2:	f895 30b8 	ldrb.w	r3, [r5, #184]	; 0xb8
 80256f6:	f360 0300 	bfi	r3, r0, #0, #1
 80256fa:	f885 30b8 	strb.w	r3, [r5, #184]	; 0xb8
            device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsEnabled = (uint8_t)0;
 80256fe:	f8b5 30b8 	ldrh.w	r3, [r5, #184]	; 0xb8
 8025702:	f360 0341 	bfi	r3, r0, #1, #1
 8025706:	f8a5 30b8 	strh.w	r3, [r5, #184]	; 0xb8
 802570a:	e758      	b.n	80255be <USBD_SignalDeviceEventHandler+0x156>
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
           (device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured))
        {
          if (USBD_STATUS_SUCCESS == 
          (USBD_STATUS_t)device.Driver->EndpointUnconfigure
 802570c:	682b      	ldr	r3, [r5, #0]
 802570e:	f895 0088 	ldrb.w	r0, [r5, #136]	; 0x88
 8025712:	6a1b      	ldr	r3, [r3, #32]
 8025714:	4798      	blx	r3
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
           (device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured))
        {
          if (USBD_STATUS_SUCCESS == 
 8025716:	2800      	cmp	r0, #0
 8025718:	f47f af39 	bne.w	802558e <USBD_SignalDeviceEventHandler+0x126>
          (USBD_STATUS_t)device.Driver->EndpointUnconfigure
          ((uint8_t)device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].Address))
          {
            device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured = (uint8_t)0;
 802571c:	f895 308c 	ldrb.w	r3, [r5, #140]	; 0x8c
 8025720:	f360 0300 	bfi	r3, r0, #0, #1
 8025724:	f885 308c 	strb.w	r3, [r5, #140]	; 0x8c
            device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsEnabled = (uint8_t)0;
 8025728:	f8b5 308c 	ldrh.w	r3, [r5, #140]	; 0x8c
 802572c:	f360 0341 	bfi	r3, r0, #1, #1
 8025730:	f8a5 308c 	strh.w	r3, [r5, #140]	; 0x8c
 8025734:	e72b      	b.n	802558e <USBD_SignalDeviceEventHandler+0x126>
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
           (device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured))
        {
          if (USBD_STATUS_SUCCESS == 
          (USBD_STATUS_t)device.Driver->EndpointUnconfigure
 8025736:	682b      	ldr	r3, [r5, #0]
 8025738:	f895 005c 	ldrb.w	r0, [r5, #92]	; 0x5c
 802573c:	6a1b      	ldr	r3, [r3, #32]
 802573e:	4798      	blx	r3
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].OutInUse = (uint8_t)0;
        device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsHalted = (uint8_t)0;
        if ((((uint32_t)XMC_USBD_NUM_EPS - i) != 0U) && 
           (device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured))
        {
          if (USBD_STATUS_SUCCESS == 
 8025740:	2800      	cmp	r0, #0
 8025742:	f47f af0c 	bne.w	802555e <USBD_SignalDeviceEventHandler+0xf6>
          (USBD_STATUS_t)device.Driver->EndpointUnconfigure
          ((uint8_t)device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].Address))
          {
            device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsConfigured = (uint8_t)0;
 8025746:	f895 3060 	ldrb.w	r3, [r5, #96]	; 0x60
 802574a:	f360 0300 	bfi	r3, r0, #0, #1
 802574e:	f885 3060 	strb.w	r3, [r5, #96]	; 0x60
            device.Endpoints[((uint32_t)XMC_USBD_NUM_EPS - i)].IsEnabled = (uint8_t)0;
 8025752:	f8b5 3060 	ldrh.w	r3, [r5, #96]	; 0x60
 8025756:	f360 0341 	bfi	r3, r0, #1, #1
 802575a:	f8a5 3060 	strh.w	r3, [r5, #96]	; 0x60
 802575e:	e6fe      	b.n	802555e <USBD_SignalDeviceEventHandler+0xf6>
 8025760:	bd70      	pop	{r4, r5, r6, pc}
 8025762:	bf00      	nop
 8025764:	1fff03a5 	.word	0x1fff03a5
 8025768:	1fff05b0 	.word	0x1fff05b0

0802576c <USBD_HandleEP0_Stall>:
 *
 * Stalls EP0 and then restarts a new transfer including setting EP0 state to
 * 																\ref USBD_EP0_STATE_IDLE.
 */
static void USBD_HandleEP0_Stall(void)
{
 802576c:	b510      	push	{r4, lr}
  /* When we stall ep0 as protocol stall, we go back into idle state and
  * start a new read */
  if (USBD_STATUS_SUCCESS == (USBD_STATUS_t)device.Driver->EndpointStall(ENDPOINT_DIR_IN | 0U,1U))
 802576e:	4c08      	ldr	r4, [pc, #32]	; (8025790 <USBD_HandleEP0_Stall+0x24>)
 8025770:	6823      	ldr	r3, [r4, #0]
 8025772:	2080      	movs	r0, #128	; 0x80
 8025774:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8025776:	2101      	movs	r1, #1
 8025778:	4798      	blx	r3
 802577a:	b100      	cbz	r0, 802577e <USBD_HandleEP0_Stall+0x12>
 802577c:	bd10      	pop	{r4, pc}
  {
    device.ep0_state = USBD_EP0_STATE_IDLE;
    if ( USBD_STATUS_SUCCESS != (USBD_STATUS_t)device.Driver->EndpointReadStart(0U,USBD_EP0_3SETUP_PKT_SIZE))
 802577e:	6823      	ldr	r3, [r4, #0]
{
  /* When we stall ep0 as protocol stall, we go back into idle state and
  * start a new read */
  if (USBD_STATUS_SUCCESS == (USBD_STATUS_t)device.Driver->EndpointStall(ENDPOINT_DIR_IN | 0U,1U))
  {
    device.ep0_state = USBD_EP0_STATE_IDLE;
 8025780:	2201      	movs	r2, #1
    if ( USBD_STATUS_SUCCESS != (USBD_STATUS_t)device.Driver->EndpointReadStart(0U,USBD_EP0_3SETUP_PKT_SIZE))
 8025782:	6a9b      	ldr	r3, [r3, #40]	; 0x28
{
  /* When we stall ep0 as protocol stall, we go back into idle state and
  * start a new read */
  if (USBD_STATUS_SUCCESS == (USBD_STATUS_t)device.Driver->EndpointStall(ENDPOINT_DIR_IN | 0U,1U))
  {
    device.ep0_state = USBD_EP0_STATE_IDLE;
 8025784:	f884 213b 	strb.w	r2, [r4, #315]	; 0x13b
    if ( USBD_STATUS_SUCCESS != (USBD_STATUS_t)device.Driver->EndpointReadStart(0U,USBD_EP0_3SETUP_PKT_SIZE))
 8025788:	2118      	movs	r1, #24
    {
      XMC_ASSERT("USBD_HandleEP0_Stall: EndpointReadStart failed", 0);
    }
  }
}
 802578a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  /* When we stall ep0 as protocol stall, we go back into idle state and
  * start a new read */
  if (USBD_STATUS_SUCCESS == (USBD_STATUS_t)device.Driver->EndpointStall(ENDPOINT_DIR_IN | 0U,1U))
  {
    device.ep0_state = USBD_EP0_STATE_IDLE;
    if ( USBD_STATUS_SUCCESS != (USBD_STATUS_t)device.Driver->EndpointReadStart(0U,USBD_EP0_3SETUP_PKT_SIZE))
 802578e:	4718      	bx	r3
 8025790:	1fff05b0 	.word	0x1fff05b0

08025794 <USBD_Handle_DeviceRequest>:
 * handle some custom request or override the request handling in this function.
 * If the user has handled the request, he has to call \ref Endpoint_ClearSETUP.
 *
 */
static void USBD_Handle_DeviceRequest(void)
{
 8025794:	b570      	push	{r4, r5, r6, lr}
  

  value = (uint32_t)USB_ControlRequest.wValue & (uint32_t)USBD_BYTE_MASK;

  /* Handling of class/vendor requests */
  if (NULL != device.events->control_request)
 8025796:	4ca2      	ldr	r4, [pc, #648]	; (8025a20 <USBD_Handle_DeviceRequest+0x28c>)
  uint32_t value;
  uint32_t tmp_value;
  uint32_t tmp_index;
  

  value = (uint32_t)USB_ControlRequest.wValue & (uint32_t)USBD_BYTE_MASK;
 8025798:	4ea2      	ldr	r6, [pc, #648]	; (8025a24 <USBD_Handle_DeviceRequest+0x290>)

  /* Handling of class/vendor requests */
  if (NULL != device.events->control_request)
 802579a:	f8d4 3140 	ldr.w	r3, [r4, #320]	; 0x140
  uint32_t value;
  uint32_t tmp_value;
  uint32_t tmp_index;
  

  value = (uint32_t)USB_ControlRequest.wValue & (uint32_t)USBD_BYTE_MASK;
 802579e:	8870      	ldrh	r0, [r6, #2]

  /* Handling of class/vendor requests */
  if (NULL != device.events->control_request)
 80257a0:	68da      	ldr	r2, [r3, #12]
 * handle some custom request or override the request handling in this function.
 * If the user has handled the request, he has to call \ref Endpoint_ClearSETUP.
 *
 */
static void USBD_Handle_DeviceRequest(void)
{
 80257a2:	b082      	sub	sp, #8
  uint32_t length = 0U;
  uint32_t ret;
  void *buffer = NULL;
 80257a4:	2300      	movs	r3, #0
  uint32_t value;
  uint32_t tmp_value;
  uint32_t tmp_index;
  

  value = (uint32_t)USB_ControlRequest.wValue & (uint32_t)USBD_BYTE_MASK;
 80257a6:	b285      	uxth	r5, r0
 */
static void USBD_Handle_DeviceRequest(void)
{
  uint32_t length = 0U;
  uint32_t ret;
  void *buffer = NULL;
 80257a8:	9300      	str	r3, [sp, #0]
  uint32_t status = 0U;
 80257aa:	9301      	str	r3, [sp, #4]
  

  value = (uint32_t)USB_ControlRequest.wValue & (uint32_t)USBD_BYTE_MASK;

  /* Handling of class/vendor requests */
  if (NULL != device.events->control_request)
 80257ac:	b102      	cbz	r2, 80257b0 <USBD_Handle_DeviceRequest+0x1c>
  {
    device.events->control_request();
 80257ae:	4790      	blx	r2
  }

  if (1U == device.IsSetupRecieved)
 80257b0:	f894 313e 	ldrb.w	r3, [r4, #318]	; 0x13e
 80257b4:	079b      	lsls	r3, r3, #30
 80257b6:	d407      	bmi.n	80257c8 <USBD_Handle_DeviceRequest+0x34>
      default:
        USBD_HandleEP0_Stall();
        break;
    }
  }
  device.IsSetupRecieved = 0U;
 80257b8:	f894 313e 	ldrb.w	r3, [r4, #318]	; 0x13e
 80257bc:	f023 0302 	bic.w	r3, r3, #2
 80257c0:	f884 313e 	strb.w	r3, [r4, #318]	; 0x13e
}
 80257c4:	b002      	add	sp, #8
 80257c6:	bd70      	pop	{r4, r5, r6, pc}
  }

  if (1U == device.IsSetupRecieved)
  {
    /* default request handling */
    switch (USB_ControlRequest.bRequest)
 80257c8:	7873      	ldrb	r3, [r6, #1]
  uint32_t value;
  uint32_t tmp_value;
  uint32_t tmp_index;
  

  value = (uint32_t)USB_ControlRequest.wValue & (uint32_t)USBD_BYTE_MASK;
 80257ca:	b2ed      	uxtb	r5, r5
  }

  if (1U == device.IsSetupRecieved)
  {
    /* default request handling */
    switch (USB_ControlRequest.bRequest)
 80257cc:	2b0c      	cmp	r3, #12
 80257ce:	d816      	bhi.n	80257fe <USBD_Handle_DeviceRequest+0x6a>
 80257d0:	e8df f013 	tbh	[pc, r3, lsl #1]
 80257d4:	00be0025 	.word	0x00be0025
 80257d8:	009d0015 	.word	0x009d0015
 80257dc:	00d00015 	.word	0x00d00015
 80257e0:	00150056 	.word	0x00150056
 80257e4:	008a0083 	.word	0x008a0083
 80257e8:	0078000d 	.word	0x0078000d
 80257ec:	0015      	.short	0x0015
          device.Endpoints[0].InDataBuffer = (uint8_t *)buffer + ret;
        }
        break;

      case REQ_GetInterface:
        if ((uint8_t)DEVICE_STATE_Configured == USB_DeviceState)
 80257ee:	4b8e      	ldr	r3, [pc, #568]	; (8025a28 <USBD_Handle_DeviceRequest+0x294>)
 80257f0:	781a      	ldrb	r2, [r3, #0]
 80257f2:	2a04      	cmp	r2, #4
 80257f4:	f000 8136 	beq.w	8025a64 <USBD_Handle_DeviceRequest+0x2d0>
          tmp_value = (uint32_t)USB_ControlRequest.wValue;
          tmp_index = (uint32_t)USB_ControlRequest.wIndex;
          device.interface_settings[tmp_index] =	(uint8_t)tmp_value;
          break;
        }
        if ((uint8_t)DEVICE_STATE_Addressed == USB_DeviceState)
 80257f8:	781b      	ldrb	r3, [r3, #0]
 80257fa:	2b03      	cmp	r3, #3
 80257fc:	d1dc      	bne.n	80257b8 <USBD_Handle_DeviceRequest+0x24>
 */
static void USBD_HandleEP0_Stall(void)
{
  /* When we stall ep0 as protocol stall, we go back into idle state and
  * start a new read */
  if (USBD_STATUS_SUCCESS == (USBD_STATUS_t)device.Driver->EndpointStall(ENDPOINT_DIR_IN | 0U,1U))
 80257fe:	6823      	ldr	r3, [r4, #0]
 8025800:	4d87      	ldr	r5, [pc, #540]	; (8025a20 <USBD_Handle_DeviceRequest+0x28c>)
 8025802:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8025804:	2080      	movs	r0, #128	; 0x80
 8025806:	2101      	movs	r1, #1
 8025808:	4798      	blx	r3
 802580a:	2800      	cmp	r0, #0
 802580c:	d1d4      	bne.n	80257b8 <USBD_Handle_DeviceRequest+0x24>
  {
    device.ep0_state = USBD_EP0_STATE_IDLE;
    if ( USBD_STATUS_SUCCESS != (USBD_STATUS_t)device.Driver->EndpointReadStart(0U,USBD_EP0_3SETUP_PKT_SIZE))
 802580e:	682b      	ldr	r3, [r5, #0]
{
  /* When we stall ep0 as protocol stall, we go back into idle state and
  * start a new read */
  if (USBD_STATUS_SUCCESS == (USBD_STATUS_t)device.Driver->EndpointStall(ENDPOINT_DIR_IN | 0U,1U))
  {
    device.ep0_state = USBD_EP0_STATE_IDLE;
 8025810:	2201      	movs	r2, #1
    if ( USBD_STATUS_SUCCESS != (USBD_STATUS_t)device.Driver->EndpointReadStart(0U,USBD_EP0_3SETUP_PKT_SIZE))
 8025812:	6a9b      	ldr	r3, [r3, #40]	; 0x28
{
  /* When we stall ep0 as protocol stall, we go back into idle state and
  * start a new read */
  if (USBD_STATUS_SUCCESS == (USBD_STATUS_t)device.Driver->EndpointStall(ENDPOINT_DIR_IN | 0U,1U))
  {
    device.ep0_state = USBD_EP0_STATE_IDLE;
 8025814:	f885 213b 	strb.w	r2, [r5, #315]	; 0x13b
    if ( USBD_STATUS_SUCCESS != (USBD_STATUS_t)device.Driver->EndpointReadStart(0U,USBD_EP0_3SETUP_PKT_SIZE))
 8025818:	2118      	movs	r1, #24
 802581a:	4798      	blx	r3
 802581c:	e7cc      	b.n	80257b8 <USBD_Handle_DeviceRequest+0x24>
          break;
        }
        break;

      case REQ_GetStatus:
        if (REQREC_DEVICE == ((uint32_t)USB_ControlRequest.bmRequestType & REQ_RECIPIENT_MASK))
 802581e:	7830      	ldrb	r0, [r6, #0]
 8025820:	4b80      	ldr	r3, [pc, #512]	; (8025a24 <USBD_Handle_DeviceRequest+0x290>)
 8025822:	f010 0003 	ands.w	r0, r0, #3
 8025826:	f000 8103 	beq.w	8025a30 <USBD_Handle_DeviceRequest+0x29c>
          {
            XMC_ASSERT("USBD_Handle_DeviceRequest: EndpointWrite failed on REQ_GetStatus", 0);
          }          
          break;
        }
        if ((REQREC_INTERFACE == ((uint32_t)USB_ControlRequest.bmRequestType & REQ_RECIPIENT_MASK)) &&
 802582a:	781b      	ldrb	r3, [r3, #0]
 802582c:	f003 0303 	and.w	r3, r3, #3
 8025830:	2b01      	cmp	r3, #1
 8025832:	f000 80e7 	beq.w	8025a04 <USBD_Handle_DeviceRequest+0x270>
            XMC_ASSERT("USBD_Handle_DeviceRequest: EndpointWrite failed on REQ_GetStatus- REQREC_INTERFACE", 0);
          }          
          break;
        }

        if (REQREC_ENDPOINT == ((uint32_t)USB_ControlRequest.bmRequestType & REQ_RECIPIENT_MASK))
 8025836:	7833      	ldrb	r3, [r6, #0]
 8025838:	4a7a      	ldr	r2, [pc, #488]	; (8025a24 <USBD_Handle_DeviceRequest+0x290>)
 802583a:	f003 0303 	and.w	r3, r3, #3
 802583e:	2b02      	cmp	r3, #2
 8025840:	d1dd      	bne.n	80257fe <USBD_Handle_DeviceRequest+0x6a>
        {
          index = (uint32_t)(USB_ControlRequest.wIndex & USBD_BYTE_MASK & ENDPOINT_EPNUM_MASK);
          if ((((uint8_t)DEVICE_STATE_Configured == USB_DeviceState) || ((uint16_t)0 == USB_ControlRequest.wIndex)) &&
 8025842:	4979      	ldr	r1, [pc, #484]	; (8025a28 <USBD_Handle_DeviceRequest+0x294>)
          break;
        }

        if (REQREC_ENDPOINT == ((uint32_t)USB_ControlRequest.bmRequestType & REQ_RECIPIENT_MASK))
        {
          index = (uint32_t)(USB_ControlRequest.wIndex & USBD_BYTE_MASK & ENDPOINT_EPNUM_MASK);
 8025844:	8893      	ldrh	r3, [r2, #4]
          if ((((uint8_t)DEVICE_STATE_Configured == USB_DeviceState) || ((uint16_t)0 == USB_ControlRequest.wIndex)) &&
 8025846:	7809      	ldrb	r1, [r1, #0]
 8025848:	2904      	cmp	r1, #4
          break;
        }

        if (REQREC_ENDPOINT == ((uint32_t)USB_ControlRequest.bmRequestType & REQ_RECIPIENT_MASK))
        {
          index = (uint32_t)(USB_ControlRequest.wIndex & USBD_BYTE_MASK & ENDPOINT_EPNUM_MASK);
 802584a:	b29b      	uxth	r3, r3
          if ((((uint8_t)DEVICE_STATE_Configured == USB_DeviceState) || ((uint16_t)0 == USB_ControlRequest.wIndex)) &&
 802584c:	d003      	beq.n	8025856 <USBD_Handle_DeviceRequest+0xc2>
 802584e:	8892      	ldrh	r2, [r2, #4]
 8025850:	b292      	uxth	r2, r2
 8025852:	2a00      	cmp	r2, #0
 8025854:	d1d3      	bne.n	80257fe <USBD_Handle_DeviceRequest+0x6a>
              (1U == device.Endpoints[index].IsConfigured))
 8025856:	222c      	movs	r2, #44	; 0x2c
          break;
        }

        if (REQREC_ENDPOINT == ((uint32_t)USB_ControlRequest.bmRequestType & REQ_RECIPIENT_MASK))
        {
          index = (uint32_t)(USB_ControlRequest.wIndex & USBD_BYTE_MASK & ENDPOINT_EPNUM_MASK);
 8025858:	f003 030f 	and.w	r3, r3, #15
          if ((((uint8_t)DEVICE_STATE_Configured == USB_DeviceState) || ((uint16_t)0 == USB_ControlRequest.wIndex)) &&
              (1U == device.Endpoints[index].IsConfigured))
 802585c:	fb02 4303 	mla	r3, r2, r3, r4
 8025860:	496f      	ldr	r1, [pc, #444]	; (8025a20 <USBD_Handle_DeviceRequest+0x28c>)
 8025862:	7a1a      	ldrb	r2, [r3, #8]
        }

        if (REQREC_ENDPOINT == ((uint32_t)USB_ControlRequest.bmRequestType & REQ_RECIPIENT_MASK))
        {
          index = (uint32_t)(USB_ControlRequest.wIndex & USBD_BYTE_MASK & ENDPOINT_EPNUM_MASK);
          if ((((uint8_t)DEVICE_STATE_Configured == USB_DeviceState) || ((uint16_t)0 == USB_ControlRequest.wIndex)) &&
 8025864:	07d0      	lsls	r0, r2, #31
 8025866:	d5ca      	bpl.n	80257fe <USBD_Handle_DeviceRequest+0x6a>
              (1U == device.Endpoints[index].IsConfigured))
          {
            status = (uint32_t)device.Endpoints[index].IsHalted;
 8025868:	689b      	ldr	r3, [r3, #8]
            if (0U == (uint32_t)device.Driver->EndpointWrite(0U, (uint8_t*)&status, USBD_WORD_SIZE))
 802586a:	680a      	ldr	r2, [r1, #0]
        {
          index = (uint32_t)(USB_ControlRequest.wIndex & USBD_BYTE_MASK & ENDPOINT_EPNUM_MASK);
          if ((((uint8_t)DEVICE_STATE_Configured == USB_DeviceState) || ((uint16_t)0 == USB_ControlRequest.wIndex)) &&
              (1U == device.Endpoints[index].IsConfigured))
          {
            status = (uint32_t)device.Endpoints[index].IsHalted;
 802586c:	a902      	add	r1, sp, #8
 802586e:	f3c3 0380 	ubfx	r3, r3, #2, #1
 8025872:	f841 3d04 	str.w	r3, [r1, #-4]!
            if (0U == (uint32_t)device.Driver->EndpointWrite(0U, (uint8_t*)&status, USBD_WORD_SIZE))
 8025876:	2000      	movs	r0, #0
 8025878:	6b13      	ldr	r3, [r2, #48]	; 0x30
 802587a:	2202      	movs	r2, #2
 802587c:	4798      	blx	r3
            {
              XMC_ASSERT("USBD_Handle_DeviceRequest: EndpointWrite failed on REQ_GetStatus- REQREC_ENDPOINT", 0);
            }              
            break;
 802587e:	e79b      	b.n	80257b8 <USBD_Handle_DeviceRequest+0x24>
          XMC_ASSERT("USBD_Handle_DeviceRequest: EndpointWrite failed on get configuration request", 0);
        }
        break;

      case REQ_GetDescriptor:
        if (NULL != device.events->get_descriptor)
 8025880:	f8d4 3140 	ldr.w	r3, [r4, #320]	; 0x140
 8025884:	695b      	ldr	r3, [r3, #20]
 8025886:	2b00      	cmp	r3, #0
 8025888:	d0b9      	beq.n	80257fe <USBD_Handle_DeviceRequest+0x6a>
        {
          tmp_value = (uint32_t)USB_ControlRequest.wValue;
 802588a:	8870      	ldrh	r0, [r6, #2]
          tmp_index = (uint32_t)USB_ControlRequest.wIndex;
 802588c:	88b1      	ldrh	r1, [r6, #4]
        break;

      case REQ_GetDescriptor:
        if (NULL != device.events->get_descriptor)
        {
          tmp_value = (uint32_t)USB_ControlRequest.wValue;
 802588e:	4e65      	ldr	r6, [pc, #404]	; (8025a24 <USBD_Handle_DeviceRequest+0x290>)
          tmp_index = (uint32_t)USB_ControlRequest.wIndex;
          length = (uint32_t)device.events->get_descriptor((uint16_t)tmp_value, (uint16_t)tmp_index, (void*)&buffer);
 8025890:	b280      	uxth	r0, r0
 8025892:	b289      	uxth	r1, r1
 8025894:	466a      	mov	r2, sp
 8025896:	4798      	blx	r3
        }

        if (0U == length)
 8025898:	4605      	mov	r5, r0
 802589a:	2800      	cmp	r0, #0
 802589c:	d0af      	beq.n	80257fe <USBD_Handle_DeviceRequest+0x6a>
        {
          USBD_HandleEP0_Stall();
        }
        else
        {
          if (length >= (uint32_t)USB_ControlRequest.wLength)
 802589e:	88f3      	ldrh	r3, [r6, #6]
          {
            length = (uint32_t)USB_ControlRequest.wLength;
          }

          ret = (uint32_t)device.Driver->EndpointWrite(0U,buffer,length);
 80258a0:	9900      	ldr	r1, [sp, #0]
        {
          USBD_HandleEP0_Stall();
        }
        else
        {
          if (length >= (uint32_t)USB_ControlRequest.wLength)
 80258a2:	b29b      	uxth	r3, r3
 80258a4:	4298      	cmp	r0, r3
          {
            length = (uint32_t)USB_ControlRequest.wLength;
 80258a6:	bf28      	it	cs
 80258a8:	88f5      	ldrhcs	r5, [r6, #6]
          }

          ret = (uint32_t)device.Driver->EndpointWrite(0U,buffer,length);
 80258aa:	6823      	ldr	r3, [r4, #0]
        }
        else
        {
          if (length >= (uint32_t)USB_ControlRequest.wLength)
          {
            length = (uint32_t)USB_ControlRequest.wLength;
 80258ac:	bf28      	it	cs
 80258ae:	b2ad      	uxthcs	r5, r5
          }

          ret = (uint32_t)device.Driver->EndpointWrite(0U,buffer,length);
 80258b0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80258b2:	462a      	mov	r2, r5
 80258b4:	2000      	movs	r0, #0
 80258b6:	4798      	blx	r3
          device.Endpoints[0].InDataLeft = length - ret;
          device.Endpoints[0].InDataBuffer = (uint8_t *)buffer + ret;
 80258b8:	9b00      	ldr	r3, [sp, #0]
          {
            length = (uint32_t)USB_ControlRequest.wLength;
          }

          ret = (uint32_t)device.Driver->EndpointWrite(0U,buffer,length);
          device.Endpoints[0].InDataLeft = length - ret;
 80258ba:	1a2d      	subs	r5, r5, r0
          device.Endpoints[0].InDataBuffer = (uint8_t *)buffer + ret;
 80258bc:	4418      	add	r0, r3
          {
            length = (uint32_t)USB_ControlRequest.wLength;
          }

          ret = (uint32_t)device.Driver->EndpointWrite(0U,buffer,length);
          device.Endpoints[0].InDataLeft = length - ret;
 80258be:	62a5      	str	r5, [r4, #40]	; 0x28
          device.Endpoints[0].InDataBuffer = (uint8_t *)buffer + ret;
 80258c0:	62e0      	str	r0, [r4, #44]	; 0x2c
 80258c2:	e779      	b.n	80257b8 <USBD_Handle_DeviceRequest+0x24>
        /* Set Descriptor not supported, so stall */
        USBD_HandleEP0_Stall();
        break;

      case REQ_SetInterface:
        if ((uint8_t)DEVICE_STATE_Configured == USB_DeviceState)
 80258c4:	4b58      	ldr	r3, [pc, #352]	; (8025a28 <USBD_Handle_DeviceRequest+0x294>)
 80258c6:	781a      	ldrb	r2, [r3, #0]
 80258c8:	2a04      	cmp	r2, #4
 80258ca:	d195      	bne.n	80257f8 <USBD_Handle_DeviceRequest+0x64>
        {
          tmp_value = (uint32_t)USB_ControlRequest.wValue;
 80258cc:	8872      	ldrh	r2, [r6, #2]
          tmp_index = (uint32_t)USB_ControlRequest.wIndex;
 80258ce:	88b3      	ldrh	r3, [r6, #4]
          device.interface_settings[tmp_index] =	(uint8_t)tmp_value;
 80258d0:	fa14 f383 	uxtah	r3, r4, r3
 80258d4:	f883 2138 	strb.w	r2, [r3, #312]	; 0x138
          break;
 80258d8:	e76e      	b.n	80257b8 <USBD_Handle_DeviceRequest+0x24>
        }
        USBD_HandleEP0_Stall();
        break;

      case REQ_GetConfiguration:
        if (0U == (uint32_t)device.Driver->EndpointWrite(0U,&device.configuration,1U))
 80258da:	6823      	ldr	r3, [r4, #0]
 80258dc:	4953      	ldr	r1, [pc, #332]	; (8025a2c <USBD_Handle_DeviceRequest+0x298>)
 80258de:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80258e0:	2201      	movs	r2, #1
 80258e2:	2000      	movs	r0, #0
 80258e4:	4798      	blx	r3
        {
          XMC_ASSERT("USBD_Handle_DeviceRequest: EndpointWrite failed on get configuration request", 0);
        }
        break;
 80258e6:	e767      	b.n	80257b8 <USBD_Handle_DeviceRequest+0x24>

      case REQ_SetConfiguration:
        /* Regardless the state update the configuration to unconfigure
         * endpoints */
        device.configuration = (uint8_t)value;
        if (NULL != device.events->config_changed)
 80258e8:	f8d4 3140 	ldr.w	r3, [r4, #320]	; 0x140
        break;

      case REQ_SetConfiguration:
        /* Regardless the state update the configuration to unconfigure
         * endpoints */
        device.configuration = (uint8_t)value;
 80258ec:	f884 5139 	strb.w	r5, [r4, #313]	; 0x139
        if (NULL != device.events->config_changed)
 80258f0:	689b      	ldr	r3, [r3, #8]
 80258f2:	b103      	cbz	r3, 80258f6 <USBD_Handle_DeviceRequest+0x162>
        {
          device.events->config_changed();
 80258f4:	4798      	blx	r3
        }

        /* when config 0 is choosen, we are back in address state */
        if (0U == value)
 80258f6:	2d00      	cmp	r5, #0
 80258f8:	d054      	beq.n	80259a4 <USBD_Handle_DeviceRequest+0x210>
        {
          USB_DeviceState = (uint8_t)DEVICE_STATE_Addressed;
          break;
        }
        /* go ahead only with vailid config. (must be set in event) */
        if (1U == device.IsConfigured)
 80258fa:	f894 313e 	ldrb.w	r3, [r4, #318]	; 0x13e
 80258fe:	4d48      	ldr	r5, [pc, #288]	; (8025a20 <USBD_Handle_DeviceRequest+0x28c>)
 8025900:	07d9      	lsls	r1, r3, #31
 8025902:	f140 80a6 	bpl.w	8025a52 <USBD_Handle_DeviceRequest+0x2be>
        {
          USB_DeviceState = (uint8_t)DEVICE_STATE_Configured;
 8025906:	4b48      	ldr	r3, [pc, #288]	; (8025a28 <USBD_Handle_DeviceRequest+0x294>)
 8025908:	2204      	movs	r2, #4
 802590a:	701a      	strb	r2, [r3, #0]
 802590c:	e754      	b.n	80257b8 <USBD_Handle_DeviceRequest+0x24>
        }
        break;

      case REQ_SetFeature:
        /* we do not support test mode */
        if ((uint32_t)FEATURE_SEL_TestMode == value)
 802590e:	2d02      	cmp	r5, #2
 8025910:	f43f af75 	beq.w	80257fe <USBD_Handle_DeviceRequest+0x6a>
        {
          USBD_HandleEP0_Stall();
          break;
        }
        /* configured state */
        if ((uint8_t)DEVICE_STATE_Configured == USB_DeviceState)
 8025914:	4b44      	ldr	r3, [pc, #272]	; (8025a28 <USBD_Handle_DeviceRequest+0x294>)
 8025916:	781a      	ldrb	r2, [r3, #0]
 8025918:	2a04      	cmp	r2, #4
 802591a:	d067      	beq.n	80259ec <USBD_Handle_DeviceRequest+0x258>
              break;
          }
          break;
        }
        /* when addressed, only ep0 can be halted */
        if ((uint8_t)DEVICE_STATE_Addressed == USB_DeviceState)
 802591c:	781b      	ldrb	r3, [r3, #0]
 802591e:	2b03      	cmp	r3, #3
 8025920:	f47f af6d 	bne.w	80257fe <USBD_Handle_DeviceRequest+0x6a>
        {
          if (((uint32_t)FEATURE_SEL_EndpointHalt == value) &&
 8025924:	2d00      	cmp	r5, #0
 8025926:	f47f af6a 	bne.w	80257fe <USBD_Handle_DeviceRequest+0x6a>
              (REQREC_ENDPOINT == ((uint32_t)USB_ControlRequest.bmRequestType & REQ_RECIPIENT_MASK)) &&
 802592a:	7833      	ldrb	r3, [r6, #0]
 802592c:	4a3d      	ldr	r2, [pc, #244]	; (8025a24 <USBD_Handle_DeviceRequest+0x290>)
          break;
        }
        /* when addressed, only ep0 can be halted */
        if ((uint8_t)DEVICE_STATE_Addressed == USB_DeviceState)
        {
          if (((uint32_t)FEATURE_SEL_EndpointHalt == value) &&
 802592e:	f003 0303 	and.w	r3, r3, #3
 8025932:	2b02      	cmp	r3, #2
 8025934:	f47f af63 	bne.w	80257fe <USBD_Handle_DeviceRequest+0x6a>
              (REQREC_ENDPOINT == ((uint32_t)USB_ControlRequest.bmRequestType & REQ_RECIPIENT_MASK)) &&
              ((uint16_t)0 == ((uint16_t)USB_ControlRequest.wIndex & (uint16_t)USBD_BYTE_MASK)))
 8025938:	8893      	ldrh	r3, [r2, #4]
        }
        /* when addressed, only ep0 can be halted */
        if ((uint8_t)DEVICE_STATE_Addressed == USB_DeviceState)
        {
          if (((uint32_t)FEATURE_SEL_EndpointHalt == value) &&
              (REQREC_ENDPOINT == ((uint32_t)USB_ControlRequest.bmRequestType & REQ_RECIPIENT_MASK)) &&
 802593a:	f013 0fff 	tst.w	r3, #255	; 0xff
 802593e:	f47f af5e 	bne.w	80257fe <USBD_Handle_DeviceRequest+0x6a>
              ((uint16_t)0 == ((uint16_t)USB_ControlRequest.wIndex & (uint16_t)USBD_BYTE_MASK)))
          {
            device.Endpoints[0].IsHalted = 1U;
 8025942:	8923      	ldrh	r3, [r4, #8]
 8025944:	f043 0304 	orr.w	r3, r3, #4
 8025948:	8123      	strh	r3, [r4, #8]
            USBD_HandleEP0_Stall();
 802594a:	f7ff ff0f 	bl	802576c <USBD_HandleEP0_Stall>
            break;
 802594e:	e733      	b.n	80257b8 <USBD_Handle_DeviceRequest+0x24>
  {
    /* default request handling */
    switch (USB_ControlRequest.bRequest)
    {
      case REQ_ClearFeature:
        if ((uint8_t)REQREC_ENDPOINT == (USB_ControlRequest.bmRequestType & (uint8_t)REQ_RECIPIENT_MASK))
 8025950:	7833      	ldrb	r3, [r6, #0]
 8025952:	4a34      	ldr	r2, [pc, #208]	; (8025a24 <USBD_Handle_DeviceRequest+0x290>)
 8025954:	f003 0303 	and.w	r3, r3, #3
 8025958:	2b02      	cmp	r3, #2
 802595a:	d027      	beq.n	80259ac <USBD_Handle_DeviceRequest+0x218>
          {
            USBD_HandleEP0_Stall();
          }
          break;
        }
        if (REQREC_DEVICE == ((uint32_t)USB_ControlRequest.bmRequestType & REQ_RECIPIENT_MASK))
 802595c:	7813      	ldrb	r3, [r2, #0]
 802595e:	f013 0303 	ands.w	r3, r3, #3
 8025962:	f47f af4c 	bne.w	80257fe <USBD_Handle_DeviceRequest+0x6a>
        {
          device.remote_wakeup = 0U;
 8025966:	f894 213e 	ldrb.w	r2, [r4, #318]	; 0x13e
 802596a:	f363 0282 	bfi	r2, r3, #2, #1
 802596e:	f884 213e 	strb.w	r2, [r4, #318]	; 0x13e
          break;
 8025972:	e721      	b.n	80257b8 <USBD_Handle_DeviceRequest+0x24>
        break;

      case REQ_SetAddress:
        if (0U == value)
        {
          USB_DeviceState = (uint8_t)DEVICE_STATE_Default;
 8025974:	4b2c      	ldr	r3, [pc, #176]	; (8025a28 <USBD_Handle_DeviceRequest+0x294>)
        /* default stall */
        USBD_HandleEP0_Stall();
        break;

      case REQ_SetAddress:
        if (0U == value)
 8025976:	b995      	cbnz	r5, 802599e <USBD_Handle_DeviceRequest+0x20a>
        {
          USB_DeviceState = (uint8_t)DEVICE_STATE_Default;
 8025978:	2202      	movs	r2, #2
 802597a:	701a      	strb	r2, [r3, #0]
        }
        else
        {
          USB_DeviceState = (uint8_t)DEVICE_STATE_Addressed;
        }
        if (USBD_STATUS_SUCCESS == (USBD_STATUS_t)device.Driver->DeviceSetAddress((uint8_t)value,
 802597c:	6823      	ldr	r3, [r4, #0]
 802597e:	4e28      	ldr	r6, [pc, #160]	; (8025a20 <USBD_Handle_DeviceRequest+0x28c>)
 8025980:	699b      	ldr	r3, [r3, #24]
 8025982:	4628      	mov	r0, r5
 8025984:	2100      	movs	r1, #0
 8025986:	4798      	blx	r3
 8025988:	2800      	cmp	r0, #0
 802598a:	f47f af15 	bne.w	80257b8 <USBD_Handle_DeviceRequest+0x24>
                                   XMC_USBD_SET_ADDRESS_STAGE_SETUP))
        {
          if (NULL != device.events->set_address)
 802598e:	f8d6 3140 	ldr.w	r3, [r6, #320]	; 0x140
 8025992:	691b      	ldr	r3, [r3, #16]
 8025994:	2b00      	cmp	r3, #0
 8025996:	f43f af0f 	beq.w	80257b8 <USBD_Handle_DeviceRequest+0x24>
          {
            device.events->set_address();
 802599a:	4798      	blx	r3
 802599c:	e70c      	b.n	80257b8 <USBD_Handle_DeviceRequest+0x24>
        {
          USB_DeviceState = (uint8_t)DEVICE_STATE_Default;
        }
        else
        {
          USB_DeviceState = (uint8_t)DEVICE_STATE_Addressed;
 802599e:	2203      	movs	r2, #3
 80259a0:	701a      	strb	r2, [r3, #0]
 80259a2:	e7eb      	b.n	802597c <USBD_Handle_DeviceRequest+0x1e8>
        }

        /* when config 0 is choosen, we are back in address state */
        if (0U == value)
        {
          USB_DeviceState = (uint8_t)DEVICE_STATE_Addressed;
 80259a4:	4b20      	ldr	r3, [pc, #128]	; (8025a28 <USBD_Handle_DeviceRequest+0x294>)
 80259a6:	2203      	movs	r2, #3
 80259a8:	701a      	strb	r2, [r3, #0]
          break;
 80259aa:	e705      	b.n	80257b8 <USBD_Handle_DeviceRequest+0x24>
    {
      case REQ_ClearFeature:
        if ((uint8_t)REQREC_ENDPOINT == (USB_ControlRequest.bmRequestType & (uint8_t)REQ_RECIPIENT_MASK))
        {
          index = (uint32_t)USB_ControlRequest.wIndex & (uint32_t)ENDPOINT_EPNUM_MASK;
          if ((((uint8_t)DEVICE_STATE_Configured == USB_DeviceState) || ((uint16_t)0U == USB_ControlRequest.wIndex)) &&
 80259ac:	491e      	ldr	r1, [pc, #120]	; (8025a28 <USBD_Handle_DeviceRequest+0x294>)
    switch (USB_ControlRequest.bRequest)
    {
      case REQ_ClearFeature:
        if ((uint8_t)REQREC_ENDPOINT == (USB_ControlRequest.bmRequestType & (uint8_t)REQ_RECIPIENT_MASK))
        {
          index = (uint32_t)USB_ControlRequest.wIndex & (uint32_t)ENDPOINT_EPNUM_MASK;
 80259ae:	8893      	ldrh	r3, [r2, #4]
          if ((((uint8_t)DEVICE_STATE_Configured == USB_DeviceState) || ((uint16_t)0U == USB_ControlRequest.wIndex)) &&
 80259b0:	7809      	ldrb	r1, [r1, #0]
 80259b2:	2904      	cmp	r1, #4
    switch (USB_ControlRequest.bRequest)
    {
      case REQ_ClearFeature:
        if ((uint8_t)REQREC_ENDPOINT == (USB_ControlRequest.bmRequestType & (uint8_t)REQ_RECIPIENT_MASK))
        {
          index = (uint32_t)USB_ControlRequest.wIndex & (uint32_t)ENDPOINT_EPNUM_MASK;
 80259b4:	b29b      	uxth	r3, r3
          if ((((uint8_t)DEVICE_STATE_Configured == USB_DeviceState) || ((uint16_t)0U == USB_ControlRequest.wIndex)) &&
 80259b6:	d004      	beq.n	80259c2 <USBD_Handle_DeviceRequest+0x22e>
 80259b8:	8892      	ldrh	r2, [r2, #4]
 80259ba:	b292      	uxth	r2, r2
 80259bc:	2a00      	cmp	r2, #0
 80259be:	f47f af1e 	bne.w	80257fe <USBD_Handle_DeviceRequest+0x6a>
                  (1U == device.Endpoints[index].IsConfigured))
 80259c2:	222c      	movs	r2, #44	; 0x2c
    switch (USB_ControlRequest.bRequest)
    {
      case REQ_ClearFeature:
        if ((uint8_t)REQREC_ENDPOINT == (USB_ControlRequest.bmRequestType & (uint8_t)REQ_RECIPIENT_MASK))
        {
          index = (uint32_t)USB_ControlRequest.wIndex & (uint32_t)ENDPOINT_EPNUM_MASK;
 80259c4:	f003 030f 	and.w	r3, r3, #15
          if ((((uint8_t)DEVICE_STATE_Configured == USB_DeviceState) || ((uint16_t)0U == USB_ControlRequest.wIndex)) &&
                  (1U == device.Endpoints[index].IsConfigured))
 80259c8:	fb02 4303 	mla	r3, r2, r3, r4
 80259cc:	4914      	ldr	r1, [pc, #80]	; (8025a20 <USBD_Handle_DeviceRequest+0x28c>)
 80259ce:	7a1a      	ldrb	r2, [r3, #8]
    {
      case REQ_ClearFeature:
        if ((uint8_t)REQREC_ENDPOINT == (USB_ControlRequest.bmRequestType & (uint8_t)REQ_RECIPIENT_MASK))
        {
          index = (uint32_t)USB_ControlRequest.wIndex & (uint32_t)ENDPOINT_EPNUM_MASK;
          if ((((uint8_t)DEVICE_STATE_Configured == USB_DeviceState) || ((uint16_t)0U == USB_ControlRequest.wIndex)) &&
 80259d0:	07d5      	lsls	r5, r2, #31
 80259d2:	f57f af14 	bpl.w	80257fe <USBD_Handle_DeviceRequest+0x6a>
                  (1U == device.Endpoints[index].IsConfigured))
          {
            device.Endpoints[index].IsHalted = 0U;
 80259d6:	891a      	ldrh	r2, [r3, #8]
 80259d8:	f36f 0282 	bfc	r2, #2, #1
 80259dc:	811a      	strh	r2, [r3, #8]
            if (USBD_STATUS_SUCCESS != 
                                 (USBD_STATUS_t)device.Driver->EndpointStall((uint8_t)USB_ControlRequest.wIndex,false))
 80259de:	88b0      	ldrh	r0, [r6, #4]
 80259e0:	680b      	ldr	r3, [r1, #0]
 80259e2:	b2c0      	uxtb	r0, r0
 80259e4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80259e6:	2100      	movs	r1, #0
 80259e8:	4798      	blx	r3
          index = (uint32_t)USB_ControlRequest.wIndex & (uint32_t)ENDPOINT_EPNUM_MASK;
          if ((((uint8_t)DEVICE_STATE_Configured == USB_DeviceState) || ((uint16_t)0U == USB_ControlRequest.wIndex)) &&
                  (1U == device.Endpoints[index].IsConfigured))
          {
            device.Endpoints[index].IsHalted = 0U;
            if (USBD_STATUS_SUCCESS != 
 80259ea:	e6e5      	b.n	80257b8 <USBD_Handle_DeviceRequest+0x24>
          break;
        }
        /* configured state */
        if ((uint8_t)DEVICE_STATE_Configured == USB_DeviceState)
        {
          switch (value)
 80259ec:	2d00      	cmp	r5, #0
 80259ee:	d044      	beq.n	8025a7a <USBD_Handle_DeviceRequest+0x2e6>
 80259f0:	2d01      	cmp	r5, #1
 80259f2:	f47f aee1 	bne.w	80257b8 <USBD_Handle_DeviceRequest+0x24>
          {
            case FEATURE_SEL_DeviceRemoteWakeup:
              device.remote_wakeup = 1U;
 80259f6:	f894 313e 	ldrb.w	r3, [r4, #318]	; 0x13e
 80259fa:	f043 0304 	orr.w	r3, r3, #4
 80259fe:	f884 313e 	strb.w	r3, [r4, #318]	; 0x13e
              break;
 8025a02:	e6d9      	b.n	80257b8 <USBD_Handle_DeviceRequest+0x24>
            XMC_ASSERT("USBD_Handle_DeviceRequest: EndpointWrite failed on REQ_GetStatus", 0);
          }          
          break;
        }
        if ((REQREC_INTERFACE == ((uint32_t)USB_ControlRequest.bmRequestType & REQ_RECIPIENT_MASK)) &&
            ((uint8_t)DEVICE_STATE_Configured == USB_DeviceState))
 8025a04:	4b08      	ldr	r3, [pc, #32]	; (8025a28 <USBD_Handle_DeviceRequest+0x294>)
 8025a06:	781b      	ldrb	r3, [r3, #0]
          {
            XMC_ASSERT("USBD_Handle_DeviceRequest: EndpointWrite failed on REQ_GetStatus", 0);
          }          
          break;
        }
        if ((REQREC_INTERFACE == ((uint32_t)USB_ControlRequest.bmRequestType & REQ_RECIPIENT_MASK)) &&
 8025a08:	2b04      	cmp	r3, #4
 8025a0a:	f47f af14 	bne.w	8025836 <USBD_Handle_DeviceRequest+0xa2>
            ((uint8_t)DEVICE_STATE_Configured == USB_DeviceState))
        {
          status = 0U;
 8025a0e:	a902      	add	r1, sp, #8
          if (0U == (uint32_t)device.Driver->EndpointWrite(0U, (uint8_t*)&status, USBD_WORD_SIZE))
 8025a10:	6823      	ldr	r3, [r4, #0]
          break;
        }
        if ((REQREC_INTERFACE == ((uint32_t)USB_ControlRequest.bmRequestType & REQ_RECIPIENT_MASK)) &&
            ((uint8_t)DEVICE_STATE_Configured == USB_DeviceState))
        {
          status = 0U;
 8025a12:	2000      	movs	r0, #0
 8025a14:	f841 0d04 	str.w	r0, [r1, #-4]!
          if (0U == (uint32_t)device.Driver->EndpointWrite(0U, (uint8_t*)&status, USBD_WORD_SIZE))
 8025a18:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8025a1a:	2202      	movs	r2, #2
 8025a1c:	4798      	blx	r3
          {
            XMC_ASSERT("USBD_Handle_DeviceRequest: EndpointWrite failed on REQ_GetStatus- REQREC_INTERFACE", 0);
          }          
          break;
 8025a1e:	e6cb      	b.n	80257b8 <USBD_Handle_DeviceRequest+0x24>
 8025a20:	1fff05b0 	.word	0x1fff05b0
 8025a24:	1fff03a8 	.word	0x1fff03a8
 8025a28:	1fff03a5 	.word	0x1fff03a5
 8025a2c:	1fff06e9 	.word	0x1fff06e9
        break;

      case REQ_GetStatus:
        if (REQREC_DEVICE == ((uint32_t)USB_ControlRequest.bmRequestType & REQ_RECIPIENT_MASK))
        {
          status = (uint32_t)((uint8_t)(device.remote_wakeup << (uint8_t)1) | device.self_powered);					
 8025a30:	f894 313e 	ldrb.w	r3, [r4, #318]	; 0x13e
          if (0U == (uint32_t)device.Driver->EndpointWrite(0U, (uint8_t*)&status, USBD_WORD_SIZE))
 8025a34:	6822      	ldr	r2, [r4, #0]
        break;

      case REQ_GetStatus:
        if (REQREC_DEVICE == ((uint32_t)USB_ControlRequest.bmRequestType & REQ_RECIPIENT_MASK))
        {
          status = (uint32_t)((uint8_t)(device.remote_wakeup << (uint8_t)1) | device.self_powered);					
 8025a36:	f3c3 0580 	ubfx	r5, r3, #2, #1
 8025a3a:	006d      	lsls	r5, r5, #1
 8025a3c:	b2ed      	uxtb	r5, r5
 8025a3e:	a902      	add	r1, sp, #8
 8025a40:	f3c3 03c0 	ubfx	r3, r3, #3, #1
 8025a44:	432b      	orrs	r3, r5
 8025a46:	f841 3d04 	str.w	r3, [r1, #-4]!
          if (0U == (uint32_t)device.Driver->EndpointWrite(0U, (uint8_t*)&status, USBD_WORD_SIZE))
 8025a4a:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8025a4c:	2202      	movs	r2, #2
 8025a4e:	4798      	blx	r3
          {
            XMC_ASSERT("USBD_Handle_DeviceRequest: EndpointWrite failed on REQ_GetStatus", 0);
          }          
          break;
 8025a50:	e6b2      	b.n	80257b8 <USBD_Handle_DeviceRequest+0x24>
 */
static void USBD_HandleEP0_Stall(void)
{
  /* When we stall ep0 as protocol stall, we go back into idle state and
  * start a new read */
  if (USBD_STATUS_SUCCESS == (USBD_STATUS_t)device.Driver->EndpointStall(ENDPOINT_DIR_IN | 0U,1U))
 8025a52:	682b      	ldr	r3, [r5, #0]
 8025a54:	2080      	movs	r0, #128	; 0x80
 8025a56:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8025a58:	2101      	movs	r1, #1
 8025a5a:	4798      	blx	r3
 8025a5c:	2800      	cmp	r0, #0
 8025a5e:	f47f aeab 	bne.w	80257b8 <USBD_Handle_DeviceRequest+0x24>
 8025a62:	e6d4      	b.n	802580e <USBD_Handle_DeviceRequest+0x7a>

      case REQ_GetInterface:
        if ((uint8_t)DEVICE_STATE_Configured == USB_DeviceState)
        {          
          if (0U == (uint32_t)device.Driver->EndpointWrite(0U, 
             &device.interface_settings[USB_ControlRequest.wIndex], 1U))
 8025a64:	88b1      	ldrh	r1, [r6, #4]
        break;

      case REQ_GetInterface:
        if ((uint8_t)DEVICE_STATE_Configured == USB_DeviceState)
        {          
          if (0U == (uint32_t)device.Driver->EndpointWrite(0U, 
 8025a66:	6823      	ldr	r3, [r4, #0]
             &device.interface_settings[USB_ControlRequest.wIndex], 1U))
 8025a68:	b289      	uxth	r1, r1
 8025a6a:	f501 719c 	add.w	r1, r1, #312	; 0x138
        break;

      case REQ_GetInterface:
        if ((uint8_t)DEVICE_STATE_Configured == USB_DeviceState)
        {          
          if (0U == (uint32_t)device.Driver->EndpointWrite(0U, 
 8025a6e:	4421      	add	r1, r4
 8025a70:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8025a72:	2201      	movs	r2, #1
 8025a74:	2000      	movs	r0, #0
 8025a76:	4798      	blx	r3
             &device.interface_settings[USB_ControlRequest.wIndex], 1U))
          {
            XMC_ASSERT("USBD_Handle_DeviceRequest: EndpointWrite failed on REQ_GetInterface", 0);
          }
          break;
 8025a78:	e69e      	b.n	80257b8 <USBD_Handle_DeviceRequest+0x24>
          {
            case FEATURE_SEL_DeviceRemoteWakeup:
              device.remote_wakeup = 1U;
              break;
            case FEATURE_SEL_EndpointHalt:
              index = ((uint32_t)USB_ControlRequest.wIndex & (uint32_t)USBD_BYTE_MASK & 
 8025a7a:	88b3      	ldrh	r3, [r6, #4]
 8025a7c:	480a      	ldr	r0, [pc, #40]	; (8025aa8 <USBD_Handle_DeviceRequest+0x314>)
                      (uint32_t)XMC_USBD_ENDPOINT_NUMBER_MASK);
              if (0U == device.Endpoints[index].IsConfigured)
 8025a7e:	490b      	ldr	r1, [pc, #44]	; (8025aac <USBD_Handle_DeviceRequest+0x318>)
 8025a80:	222c      	movs	r2, #44	; 0x2c
          {
            case FEATURE_SEL_DeviceRemoteWakeup:
              device.remote_wakeup = 1U;
              break;
            case FEATURE_SEL_EndpointHalt:
              index = ((uint32_t)USB_ControlRequest.wIndex & (uint32_t)USBD_BYTE_MASK & 
 8025a82:	f003 030f 	and.w	r3, r3, #15
                      (uint32_t)XMC_USBD_ENDPOINT_NUMBER_MASK);
              if (0U == device.Endpoints[index].IsConfigured)
 8025a86:	fb02 4303 	mla	r3, r2, r3, r4
 8025a8a:	7a1a      	ldrb	r2, [r3, #8]
 8025a8c:	07d2      	lsls	r2, r2, #31
 8025a8e:	f57f af5c 	bpl.w	802594a <USBD_Handle_DeviceRequest+0x1b6>
              {
                USBD_HandleEP0_Stall();
              }
              else
              {
                device.Endpoints[index].IsHalted = 1U;
 8025a92:	891a      	ldrh	r2, [r3, #8]
 8025a94:	f042 0204 	orr.w	r2, r2, #4
 8025a98:	811a      	strh	r2, [r3, #8]
                if (USBD_STATUS_SUCCESS != 
                                  (USBD_STATUS_t)device.Driver->EndpointStall((uint8_t)USB_ControlRequest.wIndex,true))
 8025a9a:	680b      	ldr	r3, [r1, #0]
 8025a9c:	8880      	ldrh	r0, [r0, #4]
 8025a9e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8025aa0:	2101      	movs	r1, #1
 8025aa2:	b2c0      	uxtb	r0, r0
 8025aa4:	4798      	blx	r3
 8025aa6:	e687      	b.n	80257b8 <USBD_Handle_DeviceRequest+0x24>
 8025aa8:	1fff03a8 	.word	0x1fff03a8
 8025aac:	1fff05b0 	.word	0x1fff05b0

08025ab0 <USBD_SignalEndpointEvent_Handler>:
 * If the driver detects an event (See XMC_USBD_EP_EVENT_t) for a specified endpoint it calls this function.
 * Based on the event some further action is taken, e.g. process control request or update transfer information
 * and read data from the driver into the core buffer.
 */
static void USBD_SignalEndpointEvent_Handler(uint8_t ep_addr, XMC_USBD_EP_EVENT_t ep_event)
{
 8025ab0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  uint32_t temp_num;
  uint32_t temp_dir;

  ep =  &device.Endpoints[(ep_addr & ENDPOINT_EPNUM_MASK)];
  /* store CurrentEndpoint and direction for restore after handling */
  temp_num = (uint32_t)device.CurrentEndpoint;
 8025ab4:	4c72      	ldr	r4, [pc, #456]	; (8025c80 <USBD_SignalEndpointEvent_Handler+0x1d0>)
  USBD_Endpoint_t *ep;
  int32_t data_count;
  uint32_t temp_num;
  uint32_t temp_dir;

  ep =  &device.Endpoints[(ep_addr & ENDPOINT_EPNUM_MASK)];
 8025ab6:	f000 050f 	and.w	r5, r0, #15
  temp_dir = (uint32_t)device.CurrentDirection;
  /* select the given endpoint */
  device.CurrentEndpoint = ep_addr & ENDPOINT_EPNUM_MASK;
  device.CurrentDirection = ep_addr & (uint8_t)ENDPOINT_DIR_MASK;
  /* choose what to do based on the event */
  switch (ep_event)
 8025aba:	2901      	cmp	r1, #1
  /* store CurrentEndpoint and direction for restore after handling */
  temp_num = (uint32_t)device.CurrentEndpoint;
  temp_dir = (uint32_t)device.CurrentDirection;
  /* select the given endpoint */
  device.CurrentEndpoint = ep_addr & ENDPOINT_EPNUM_MASK;
  device.CurrentDirection = ep_addr & (uint8_t)ENDPOINT_DIR_MASK;
 8025abc:	f020 007f 	bic.w	r0, r0, #127	; 0x7f
  uint32_t temp_dir;

  ep =  &device.Endpoints[(ep_addr & ENDPOINT_EPNUM_MASK)];
  /* store CurrentEndpoint and direction for restore after handling */
  temp_num = (uint32_t)device.CurrentEndpoint;
  temp_dir = (uint32_t)device.CurrentDirection;
 8025ac0:	f894 713d 	ldrb.w	r7, [r4, #317]	; 0x13d
  uint32_t temp_num;
  uint32_t temp_dir;

  ep =  &device.Endpoints[(ep_addr & ENDPOINT_EPNUM_MASK)];
  /* store CurrentEndpoint and direction for restore after handling */
  temp_num = (uint32_t)device.CurrentEndpoint;
 8025ac4:	f894 813c 	ldrb.w	r8, [r4, #316]	; 0x13c
  temp_dir = (uint32_t)device.CurrentDirection;
  /* select the given endpoint */
  device.CurrentEndpoint = ep_addr & ENDPOINT_EPNUM_MASK;
  device.CurrentDirection = ep_addr & (uint8_t)ENDPOINT_DIR_MASK;
 8025ac8:	f884 013d 	strb.w	r0, [r4, #317]	; 0x13d
  USBD_Endpoint_t *ep;
  int32_t data_count;
  uint32_t temp_num;
  uint32_t temp_dir;

  ep =  &device.Endpoints[(ep_addr & ENDPOINT_EPNUM_MASK)];
 8025acc:	462e      	mov	r6, r5
  /* store CurrentEndpoint and direction for restore after handling */
  temp_num = (uint32_t)device.CurrentEndpoint;
  temp_dir = (uint32_t)device.CurrentDirection;
  /* select the given endpoint */
  device.CurrentEndpoint = ep_addr & ENDPOINT_EPNUM_MASK;
 8025ace:	f884 513c 	strb.w	r5, [r4, #316]	; 0x13c
  device.CurrentDirection = ep_addr & (uint8_t)ENDPOINT_DIR_MASK;
  /* choose what to do based on the event */
  switch (ep_event)
 8025ad2:	d067      	beq.n	8025ba4 <USBD_SignalEndpointEvent_Handler+0xf4>
 8025ad4:	d33a      	bcc.n	8025b4c <USBD_SignalEndpointEvent_Handler+0x9c>
 8025ad6:	2902      	cmp	r1, #2
 8025ad8:	d132      	bne.n	8025b40 <USBD_SignalEndpointEvent_Handler+0x90>
          break;
      }
      break;
    case XMC_USBD_EP_EVENT_IN:
      /* loop write transfers */
      if (ep->InDataLeft > 0U)
 8025ada:	232c      	movs	r3, #44	; 0x2c
 8025adc:	fb03 4305 	mla	r3, r3, r5, r4
 8025ae0:	f103 0920 	add.w	r9, r3, #32
 8025ae4:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8025ae6:	2a00      	cmp	r2, #0
 8025ae8:	f040 8091 	bne.w	8025c0e <USBD_SignalEndpointEvent_Handler+0x15e>
        data_count = device.Driver->EndpointWrite((uint8_t)ep->Address,ep->InDataBuffer,ep->InDataLeft);
        ep->InDataLeft -= (uint32_t)data_count;
        ep->InDataBuffer += (uint32_t)data_count;
        break;
      }
      else if (((uint32_t)ep->Number == 0U) && (ep->InBytesAvailable > 0U) &&
 8025aec:	7918      	ldrb	r0, [r3, #4]
 8025aee:	0702      	lsls	r2, r0, #28
 8025af0:	d114      	bne.n	8025b1c <USBD_SignalEndpointEvent_Handler+0x6c>
 8025af2:	69da      	ldr	r2, [r3, #28]
 8025af4:	b192      	cbz	r2, 8025b1c <USBD_SignalEndpointEvent_Handler+0x6c>
              (ep->InBytesAvailable != (uint32_t)USB_ControlRequest.wLength) &&
 8025af6:	4963      	ldr	r1, [pc, #396]	; (8025c84 <USBD_SignalEndpointEvent_Handler+0x1d4>)
 8025af8:	88c9      	ldrh	r1, [r1, #6]
 8025afa:	b289      	uxth	r1, r1
        data_count = device.Driver->EndpointWrite((uint8_t)ep->Address,ep->InDataBuffer,ep->InDataLeft);
        ep->InDataLeft -= (uint32_t)data_count;
        ep->InDataBuffer += (uint32_t)data_count;
        break;
      }
      else if (((uint32_t)ep->Number == 0U) && (ep->InBytesAvailable > 0U) &&
 8025afc:	428a      	cmp	r2, r1
 8025afe:	d00d      	beq.n	8025b1c <USBD_SignalEndpointEvent_Handler+0x6c>
              (ep->InBytesAvailable != (uint32_t)USB_ControlRequest.wLength) &&
              ((ep->InBytesAvailable % (uint32_t)ep->MaxPacketSize) == 0U))
 8025b00:	891b      	ldrh	r3, [r3, #8]
 8025b02:	f3c3 1386 	ubfx	r3, r3, #6, #7
 8025b06:	fbb2 f1f3 	udiv	r1, r2, r3
 8025b0a:	fb03 2111 	mls	r1, r3, r1, r2
        ep->InDataLeft -= (uint32_t)data_count;
        ep->InDataBuffer += (uint32_t)data_count;
        break;
      }
      else if (((uint32_t)ep->Number == 0U) && (ep->InBytesAvailable > 0U) &&
              (ep->InBytesAvailable != (uint32_t)USB_ControlRequest.wLength) &&
 8025b0e:	b929      	cbnz	r1, 8025b1c <USBD_SignalEndpointEvent_Handler+0x6c>
              ((ep->InBytesAvailable % (uint32_t)ep->MaxPacketSize) == 0U))
      {
        /* if the amount of data for endpoint 0 is exact the requested
         * amount, then no zlp has to be send */
        device.Driver->EndpointWrite((uint8_t)ep->Address,0,0U);
 8025b10:	6823      	ldr	r3, [r4, #0]
 8025b12:	460a      	mov	r2, r1
 8025b14:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8025b16:	4798      	blx	r3
 8025b18:	f894 513c 	ldrb.w	r5, [r4, #316]	; 0x13c
      }
      else
      {
      }
      ep->InBytesAvailable = 0U;
 8025b1c:	f8df 9160 	ldr.w	r9, [pc, #352]	; 8025c80 <USBD_SignalEndpointEvent_Handler+0x1d0>
 8025b20:	232c      	movs	r3, #44	; 0x2c
 8025b22:	fb03 4606 	mla	r6, r3, r6, r4
 8025b26:	2200      	movs	r2, #0
      ep->InInUse = (uint8_t)0;
 8025b28:	8933      	ldrh	r3, [r6, #8]
        device.Driver->EndpointWrite((uint8_t)ep->Address,0,0U);
      }
      else
      {
      }
      ep->InBytesAvailable = 0U;
 8025b2a:	61f2      	str	r2, [r6, #28]
      ep->InInUse = (uint8_t)0;
 8025b2c:	f362 1304 	bfi	r3, r2, #4, #1
 8025b30:	8133      	strh	r3, [r6, #8]
      switch (device.CurrentEndpoint)
 8025b32:	b92d      	cbnz	r5, 8025b40 <USBD_SignalEndpointEvent_Handler+0x90>
 * In USBD_EP0_STATE_IN_STATUS state it starts a new read of setup packets and switches
 * to USBD_EP0_STATE_IDLE.
 */
static void USBD_HandleEP0_IN()
{
  if (USBD_EP0_STATE_IN_DATA == device.ep0_state)
 8025b34:	f899 313b 	ldrb.w	r3, [r9, #315]	; 0x13b
 8025b38:	2b02      	cmp	r3, #2
 8025b3a:	d078      	beq.n	8025c2e <USBD_SignalEndpointEvent_Handler+0x17e>
  {
    /* Read zero length out data packet */
    device.Driver->EndpointReadStart((uint8_t)0,0U);
    device.ep0_state = USBD_EP0_STATE_OUT_STATUS;
  }
  else if (USBD_EP0_STATE_IN_STATUS == device.ep0_state)
 8025b3c:	2b03      	cmp	r3, #3
 8025b3e:	d04e      	beq.n	8025bde <USBD_SignalEndpointEvent_Handler+0x12e>
      }
      break;
    default:
      break;
  }
  device.CurrentEndpoint = (uint8_t)temp_num;
 8025b40:	f884 813c 	strb.w	r8, [r4, #316]	; 0x13c
  device.CurrentDirection = (uint8_t)temp_dir;
 8025b44:	f884 713d 	strb.w	r7, [r4, #317]	; 0x13d
 8025b48:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  device.CurrentDirection = ep_addr & (uint8_t)ENDPOINT_DIR_MASK;
  /* choose what to do based on the event */
  switch (ep_event)
  {
    case XMC_USBD_EP_EVENT_SETUP:
      ep->OutInUse = 0U;
 8025b4c:	232c      	movs	r3, #44	; 0x2c
 8025b4e:	fb03 4305 	mla	r3, r3, r5, r4
 8025b52:	891a      	ldrh	r2, [r3, #8]
 8025b54:	f36f 02c3 	bfc	r2, #3, #1
 8025b58:	811a      	strh	r2, [r3, #8]
      switch (device.CurrentEndpoint)
 8025b5a:	2d00      	cmp	r5, #0
 8025b5c:	d1f0      	bne.n	8025b40 <USBD_SignalEndpointEvent_Handler+0x90>
static void USBD_HandleEP0_SETUP()
{
  /* read setup packet from ep0 */
  uint32_t ret_val;

  ret_val = (uint32_t)device.Driver->EndpointRead((uint8_t)0,(void*)&USB_ControlRequest,
 8025b5e:	6823      	ldr	r3, [r4, #0]
 8025b60:	4e48      	ldr	r6, [pc, #288]	; (8025c84 <USBD_SignalEndpointEvent_Handler+0x1d4>)
 8025b62:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8025b64:	4631      	mov	r1, r6
 8025b66:	4628      	mov	r0, r5
 8025b68:	2208      	movs	r2, #8
 8025b6a:	4798      	blx	r3
            (uint32_t)USBD_EP0_SETUP_PKT_SIZE);
  device.IsSetupRecieved = (uint8_t)true;
 8025b6c:	f894 313e 	ldrb.w	r3, [r4, #318]	; 0x13e

  if ((uint32_t)USBD_EP0_SETUP_PKT_SIZE == ret_val)
 8025b70:	2808      	cmp	r0, #8
  /* read setup packet from ep0 */
  uint32_t ret_val;

  ret_val = (uint32_t)device.Driver->EndpointRead((uint8_t)0,(void*)&USB_ControlRequest,
            (uint32_t)USBD_EP0_SETUP_PKT_SIZE);
  device.IsSetupRecieved = (uint8_t)true;
 8025b72:	f043 0302 	orr.w	r3, r3, #2
 8025b76:	f884 313e 	strb.w	r3, [r4, #318]	; 0x13e

  if ((uint32_t)USBD_EP0_SETUP_PKT_SIZE == ret_val)
 8025b7a:	d1e1      	bne.n	8025b40 <USBD_SignalEndpointEvent_Handler+0x90>
  {
    /* if length is zero we have only a in_status phase */
    if (0U == (uint32_t)USB_ControlRequest.wLength)
 8025b7c:	f8b6 9006 	ldrh.w	r9, [r6, #6]
 8025b80:	fa1f f989 	uxth.w	r9, r9
 8025b84:	f1b9 0f00 	cmp.w	r9, #0
 8025b88:	d068      	beq.n	8025c5c <USBD_SignalEndpointEvent_Handler+0x1ac>
      USBD_Handle_DeviceRequest();
      device.Driver->EndpointWrite((uint8_t)0, (uint8_t*)0, (uint32_t)0);
    }
    else
    {
      if (USB_ControlRequest.bmRequestType & CONTROL_REQTYPE_DIRECTION)
 8025b8a:	7833      	ldrb	r3, [r6, #0]
 8025b8c:	0619      	lsls	r1, r3, #24
 8025b8e:	d471      	bmi.n	8025c74 <USBD_SignalEndpointEvent_Handler+0x1c4>
      }
      else
      {
        device.ep0_state = USBD_EP0_STATE_OUT_DATA;
        /* Do not process request here, first read data */
        device.Driver->EndpointReadStart((uint8_t)0, (uint32_t)USB_ControlRequest.wLength);
 8025b90:	88f1      	ldrh	r1, [r6, #6]
 8025b92:	6823      	ldr	r3, [r4, #0]
        device.ep0_state = USBD_EP0_STATE_IN_DATA;
        USBD_Handle_DeviceRequest();
      }
      else
      {
        device.ep0_state = USBD_EP0_STATE_OUT_DATA;
 8025b94:	2204      	movs	r2, #4
        /* Do not process request here, first read data */
        device.Driver->EndpointReadStart((uint8_t)0, (uint32_t)USB_ControlRequest.wLength);
 8025b96:	6a9b      	ldr	r3, [r3, #40]	; 0x28
        device.ep0_state = USBD_EP0_STATE_IN_DATA;
        USBD_Handle_DeviceRequest();
      }
      else
      {
        device.ep0_state = USBD_EP0_STATE_OUT_DATA;
 8025b98:	f884 213b 	strb.w	r2, [r4, #315]	; 0x13b
        /* Do not process request here, first read data */
        device.Driver->EndpointReadStart((uint8_t)0, (uint32_t)USB_ControlRequest.wLength);
 8025b9c:	b289      	uxth	r1, r1
 8025b9e:	4628      	mov	r0, r5
 8025ba0:	4798      	blx	r3
 8025ba2:	e7cd      	b.n	8025b40 <USBD_SignalEndpointEvent_Handler+0x90>
        default:
          break;
      }
      break;
    case XMC_USBD_EP_EVENT_OUT:
      ep->IsOutRecieved = 1U;
 8025ba4:	232c      	movs	r3, #44	; 0x2c
 8025ba6:	fb03 4305 	mla	r3, r3, r5, r4
 8025baa:	4699      	mov	r9, r3
 8025bac:	891a      	ldrh	r2, [r3, #8]
 8025bae:	f042 0220 	orr.w	r2, r2, #32
 8025bb2:	f829 2f08 	strh.w	r2, [r9, #8]!
      if (ep->OutBytesAvailable == 0U)
 8025bb6:	f8d9 2004 	ldr.w	r2, [r9, #4]
 8025bba:	b1da      	cbz	r2, 8025bf4 <USBD_SignalEndpointEvent_Handler+0x144>
      {
        ep->OutOffset = 0U; /* clear offset, new data is there */
        ep->OutBytesAvailable = (uint32_t)device.Driver->EndpointRead((uint8_t)ep->Address,
                                ep->OutBuffer,ep->OutBufferLength);
      }
      ep->OutInUse = (uint8_t)0;
 8025bbc:	232c      	movs	r3, #44	; 0x2c
 8025bbe:	fb03 4606 	mla	r6, r3, r6, r4
 8025bc2:	f8df 90bc 	ldr.w	r9, [pc, #188]	; 8025c80 <USBD_SignalEndpointEvent_Handler+0x1d0>
 8025bc6:	8933      	ldrh	r3, [r6, #8]
 8025bc8:	f36f 03c3 	bfc	r3, #3, #1
 8025bcc:	8133      	strh	r3, [r6, #8]
      switch (device.CurrentEndpoint)
 8025bce:	2d00      	cmp	r5, #0
 8025bd0:	d1b6      	bne.n	8025b40 <USBD_SignalEndpointEvent_Handler+0x90>
 * USBD_EP0_STATE_OUT_DATA state, it handles the received data and starts a write
 * transaction for \ref USBD_EP0_STATE_IN_STATUS.
 */
static void USBD_HandleEP0_OUT()
{
  if (USBD_EP0_STATE_OUT_DATA == device.ep0_state)
 8025bd2:	f899 313b 	ldrb.w	r3, [r9, #315]	; 0x13b
 8025bd6:	2b04      	cmp	r3, #4
 8025bd8:	d033      	beq.n	8025c42 <USBD_SignalEndpointEvent_Handler+0x192>
    USBD_Handle_DeviceRequest();
    /* Zero length packet for status stage */
    device.Driver->EndpointWrite((uint8_t)0,(uint8_t*)0,(uint32_t)0);
    device.ep0_state = USBD_EP0_STATE_IN_STATUS;
  }
  else if (USBD_EP0_STATE_OUT_STATUS == device.ep0_state)
 8025bda:	2b05      	cmp	r3, #5
 8025bdc:	d1b0      	bne.n	8025b40 <USBD_SignalEndpointEvent_Handler+0x90>
    device.ep0_state = USBD_EP0_STATE_OUT_STATUS;
  }
  else if (USBD_EP0_STATE_IN_STATUS == device.ep0_state)
  {
    /* Request new setup packet */
    device.Driver->EndpointReadStart((uint8_t)device.Endpoints[0].Address,(uint32_t)USBD_EP0_3SETUP_PKT_SIZE);
 8025bde:	f8d9 3000 	ldr.w	r3, [r9]
 8025be2:	f899 0004 	ldrb.w	r0, [r9, #4]
 8025be6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8025be8:	2118      	movs	r1, #24
 8025bea:	4798      	blx	r3
    device.ep0_state = USBD_EP0_STATE_IDLE;
 8025bec:	2301      	movs	r3, #1
 8025bee:	f889 313b 	strb.w	r3, [r9, #315]	; 0x13b
 8025bf2:	e7a5      	b.n	8025b40 <USBD_SignalEndpointEvent_Handler+0x90>
    case XMC_USBD_EP_EVENT_OUT:
      ep->IsOutRecieved = 1U;
      if (ep->OutBytesAvailable == 0U)
      {
        ep->OutOffset = 0U; /* clear offset, new data is there */
        ep->OutBytesAvailable = (uint32_t)device.Driver->EndpointRead((uint8_t)ep->Address,
 8025bf4:	6821      	ldr	r1, [r4, #0]
      break;
    case XMC_USBD_EP_EVENT_OUT:
      ep->IsOutRecieved = 1U;
      if (ep->OutBytesAvailable == 0U)
      {
        ep->OutOffset = 0U; /* clear offset, new data is there */
 8025bf6:	f8c9 2008 	str.w	r2, [r9, #8]
        ep->OutBytesAvailable = (uint32_t)device.Driver->EndpointRead((uint8_t)ep->Address,
 8025bfa:	6acd      	ldr	r5, [r1, #44]	; 0x2c
 8025bfc:	7918      	ldrb	r0, [r3, #4]
 8025bfe:	6959      	ldr	r1, [r3, #20]
 8025c00:	699a      	ldr	r2, [r3, #24]
 8025c02:	47a8      	blx	r5
 8025c04:	f894 513c 	ldrb.w	r5, [r4, #316]	; 0x13c
 8025c08:	f8c9 0004 	str.w	r0, [r9, #4]
 8025c0c:	e7d6      	b.n	8025bbc <USBD_SignalEndpointEvent_Handler+0x10c>
      break;
    case XMC_USBD_EP_EVENT_IN:
      /* loop write transfers */
      if (ep->InDataLeft > 0U)
      {
        data_count = device.Driver->EndpointWrite((uint8_t)ep->Address,ep->InDataBuffer,ep->InDataLeft);
 8025c0e:	6821      	ldr	r1, [r4, #0]
 8025c10:	7918      	ldrb	r0, [r3, #4]
 8025c12:	6b0e      	ldr	r6, [r1, #48]	; 0x30
 8025c14:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 8025c16:	f103 0528 	add.w	r5, r3, #40	; 0x28
 8025c1a:	47b0      	blx	r6
        ep->InDataLeft -= (uint32_t)data_count;
        ep->InDataBuffer += (uint32_t)data_count;
 8025c1c:	686a      	ldr	r2, [r5, #4]
    case XMC_USBD_EP_EVENT_IN:
      /* loop write transfers */
      if (ep->InDataLeft > 0U)
      {
        data_count = device.Driver->EndpointWrite((uint8_t)ep->Address,ep->InDataBuffer,ep->InDataLeft);
        ep->InDataLeft -= (uint32_t)data_count;
 8025c1e:	f8d9 3008 	ldr.w	r3, [r9, #8]
        ep->InDataBuffer += (uint32_t)data_count;
 8025c22:	4402      	add	r2, r0
    case XMC_USBD_EP_EVENT_IN:
      /* loop write transfers */
      if (ep->InDataLeft > 0U)
      {
        data_count = device.Driver->EndpointWrite((uint8_t)ep->Address,ep->InDataBuffer,ep->InDataLeft);
        ep->InDataLeft -= (uint32_t)data_count;
 8025c24:	1a1b      	subs	r3, r3, r0
        ep->InDataBuffer += (uint32_t)data_count;
 8025c26:	606a      	str	r2, [r5, #4]
    case XMC_USBD_EP_EVENT_IN:
      /* loop write transfers */
      if (ep->InDataLeft > 0U)
      {
        data_count = device.Driver->EndpointWrite((uint8_t)ep->Address,ep->InDataBuffer,ep->InDataLeft);
        ep->InDataLeft -= (uint32_t)data_count;
 8025c28:	f8c9 3008 	str.w	r3, [r9, #8]
        ep->InDataBuffer += (uint32_t)data_count;
        break;
 8025c2c:	e788      	b.n	8025b40 <USBD_SignalEndpointEvent_Handler+0x90>
static void USBD_HandleEP0_IN()
{
  if (USBD_EP0_STATE_IN_DATA == device.ep0_state)
  {
    /* Read zero length out data packet */
    device.Driver->EndpointReadStart((uint8_t)0,0U);
 8025c2e:	f8d9 3000 	ldr.w	r3, [r9]
 8025c32:	4628      	mov	r0, r5
 8025c34:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8025c36:	4629      	mov	r1, r5
 8025c38:	4798      	blx	r3
    device.ep0_state = USBD_EP0_STATE_OUT_STATUS;
 8025c3a:	2305      	movs	r3, #5
 8025c3c:	f889 313b 	strb.w	r3, [r9, #315]	; 0x13b
 8025c40:	e77e      	b.n	8025b40 <USBD_SignalEndpointEvent_Handler+0x90>
static void USBD_HandleEP0_OUT()
{
  if (USBD_EP0_STATE_OUT_DATA == device.ep0_state)
  {
    /* Now we have the data for handling the request */
    USBD_Handle_DeviceRequest();
 8025c42:	f7ff fda7 	bl	8025794 <USBD_Handle_DeviceRequest>
    /* Zero length packet for status stage */
    device.Driver->EndpointWrite((uint8_t)0,(uint8_t*)0,(uint32_t)0);
 8025c46:	f8d9 3000 	ldr.w	r3, [r9]
 8025c4a:	4628      	mov	r0, r5
 8025c4c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8025c4e:	4629      	mov	r1, r5
 8025c50:	462a      	mov	r2, r5
 8025c52:	4798      	blx	r3
    device.ep0_state = USBD_EP0_STATE_IN_STATUS;
 8025c54:	2303      	movs	r3, #3
 8025c56:	f889 313b 	strb.w	r3, [r9, #315]	; 0x13b
 8025c5a:	e771      	b.n	8025b40 <USBD_SignalEndpointEvent_Handler+0x90>
  if ((uint32_t)USBD_EP0_SETUP_PKT_SIZE == ret_val)
  {
    /* if length is zero we have only a in_status phase */
    if (0U == (uint32_t)USB_ControlRequest.wLength)
    {
      device.ep0_state = USBD_EP0_STATE_IN_STATUS;
 8025c5c:	2303      	movs	r3, #3
 8025c5e:	f884 313b 	strb.w	r3, [r4, #315]	; 0x13b
      USBD_Handle_DeviceRequest();
 8025c62:	f7ff fd97 	bl	8025794 <USBD_Handle_DeviceRequest>
      device.Driver->EndpointWrite((uint8_t)0, (uint8_t*)0, (uint32_t)0);
 8025c66:	6823      	ldr	r3, [r4, #0]
 8025c68:	4648      	mov	r0, r9
 8025c6a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8025c6c:	4649      	mov	r1, r9
 8025c6e:	464a      	mov	r2, r9
 8025c70:	4798      	blx	r3
 8025c72:	e765      	b.n	8025b40 <USBD_SignalEndpointEvent_Handler+0x90>
    }
    else
    {
      if (USB_ControlRequest.bmRequestType & CONTROL_REQTYPE_DIRECTION)
      {
        device.ep0_state = USBD_EP0_STATE_IN_DATA;
 8025c74:	2302      	movs	r3, #2
 8025c76:	f884 313b 	strb.w	r3, [r4, #315]	; 0x13b
        USBD_Handle_DeviceRequest();
 8025c7a:	f7ff fd8b 	bl	8025794 <USBD_Handle_DeviceRequest>
 8025c7e:	e75f      	b.n	8025b40 <USBD_SignalEndpointEvent_Handler+0x90>
 8025c80:	1fff05b0 	.word	0x1fff05b0
 8025c84:	1fff03a8 	.word	0x1fff03a8

08025c88 <USBD_Init>:
 * Intializes the USB driver core data structures and sets it into default
 * state. Afterwards it initializes the USB device controller driver and prepare
 *  it for connection via USBD_Connect.
 */
USBD_STATUS_t USBD_Init(USBD_t *handle)
{
 8025c88:	b570      	push	{r4, r5, r6, lr}
	/* Disable USB to resolve the disconnect issue on self powered devices.
	 * Later in the XMC_USBD_Init() it enables the USB.
	 */
	XMC_USBD_Disable();

	memset(&device,0x0,sizeof(USB_Device_t));
 8025c8a:	4c3b      	ldr	r4, [pc, #236]	; (8025d78 <USBD_Init+0xf0>)
 * Intializes the USB driver core data structures and sets it into default
 * state. Afterwards it initializes the USB device controller driver and prepare
 *  it for connection via USBD_Connect.
 */
USBD_STATUS_t USBD_Init(USBD_t *handle)
{
 8025c8c:	4605      	mov	r5, r0


	/* Disable USB to resolve the disconnect issue on self powered devices.
	 * Later in the XMC_USBD_Init() it enables the USB.
	 */
	XMC_USBD_Disable();
 8025c8e:	f7fd fb09 	bl	80232a4 <XMC_USBD_Disable>

	memset(&device,0x0,sizeof(USB_Device_t));
 8025c92:	2100      	movs	r1, #0
 8025c94:	f44f 72a2 	mov.w	r2, #324	; 0x144
 8025c98:	4620      	mov	r0, r4
 8025c9a:	f007 fc64 	bl	802d566 <memset>
	USB_DeviceState = (uint8_t)DEVICE_STATE_Unattached;
 8025c9e:	4b37      	ldr	r3, [pc, #220]	; (8025d7c <USBD_Init+0xf4>)
	device.Driver = &Driver_USBD0;
 8025ca0:	4837      	ldr	r0, [pc, #220]	; (8025d80 <USBD_Init+0xf8>)
 8025ca2:	6020      	str	r0, [r4, #0]
	device.Endpoints[0].InBuffer = endpoint0_in_buffer;
	device.Endpoints[0].InBufferLength = USBD_EP0_BUF_SIZE;
	device.Endpoints[0].OutBuffer = endpoint0_out_buffer;
	device.Endpoints[0].OutBufferLength = USBD_EP0_BUF_SIZE;
	device.Endpoints[0].Direction = (uint8_t)0;
	device.Endpoints[0].IsConfigured = (uint8_t)1;
 8025ca4:	2601      	movs	r6, #1
	 * Later in the XMC_USBD_Init() it enables the USB.
	 */
	XMC_USBD_Disable();

	memset(&device,0x0,sizeof(USB_Device_t));
	USB_DeviceState = (uint8_t)DEVICE_STATE_Unattached;
 8025ca6:	2000      	movs	r0, #0
 8025ca8:	7018      	strb	r0, [r3, #0]
	device.Endpoints[0].InBuffer = endpoint0_in_buffer;
	device.Endpoints[0].InBufferLength = USBD_EP0_BUF_SIZE;
	device.Endpoints[0].OutBuffer = endpoint0_out_buffer;
	device.Endpoints[0].OutBufferLength = USBD_EP0_BUF_SIZE;
	device.Endpoints[0].Direction = (uint8_t)0;
	device.Endpoints[0].IsConfigured = (uint8_t)1;
 8025caa:	7226      	strb	r6, [r4, #8]
	device.Endpoints[0].IsEnabled = (uint8_t)1;
 8025cac:	8923      	ldrh	r3, [r4, #8]
	USB_DeviceState = (uint8_t)DEVICE_STATE_Unattached;
	device.Driver = &Driver_USBD0;
	device.ep0_state = USBD_EP0_STATE_IDLE;
	device.Endpoints[0].InBuffer = endpoint0_in_buffer;
	device.Endpoints[0].InBufferLength = USBD_EP0_BUF_SIZE;
	device.Endpoints[0].OutBuffer = endpoint0_out_buffer;
 8025cae:	4a35      	ldr	r2, [pc, #212]	; (8025d84 <USBD_Init+0xfc>)
 8025cb0:	6162      	str	r2, [r4, #20]
	device.Endpoints[0].OutBufferLength = USBD_EP0_BUF_SIZE;
	device.Endpoints[0].Direction = (uint8_t)0;
	device.Endpoints[0].IsConfigured = (uint8_t)1;
	device.Endpoints[0].IsEnabled = (uint8_t)1;
 8025cb2:	f043 0302 	orr.w	r3, r3, #2
 8025cb6:	8123      	strh	r3, [r4, #8]
	device.Endpoints[0].MaxPacketSize = (uint8_t)USBD_EP0_MAX_PKT_SIZE;
 8025cb8:	8923      	ldrh	r3, [r4, #8]

	memset(&device,0x0,sizeof(USB_Device_t));
	USB_DeviceState = (uint8_t)DEVICE_STATE_Unattached;
	device.Driver = &Driver_USBD0;
	device.ep0_state = USBD_EP0_STATE_IDLE;
	device.Endpoints[0].InBuffer = endpoint0_in_buffer;
 8025cba:	4933      	ldr	r1, [pc, #204]	; (8025d88 <USBD_Init+0x100>)
 8025cbc:	6221      	str	r1, [r4, #32]
	device.Endpoints[0].OutBuffer = endpoint0_out_buffer;
	device.Endpoints[0].OutBufferLength = USBD_EP0_BUF_SIZE;
	device.Endpoints[0].Direction = (uint8_t)0;
	device.Endpoints[0].IsConfigured = (uint8_t)1;
	device.Endpoints[0].IsEnabled = (uint8_t)1;
	device.Endpoints[0].MaxPacketSize = (uint8_t)USBD_EP0_MAX_PKT_SIZE;
 8025cbe:	2240      	movs	r2, #64	; 0x40
 8025cc0:	f362 138c 	bfi	r3, r2, #6, #7
 8025cc4:	8123      	strh	r3, [r4, #8]

	if ((handle->event_cb->control_request == 0) ||
 8025cc6:	692b      	ldr	r3, [r5, #16]
 8025cc8:	68d9      	ldr	r1, [r3, #12]
	XMC_USBD_Disable();

	memset(&device,0x0,sizeof(USB_Device_t));
	USB_DeviceState = (uint8_t)DEVICE_STATE_Unattached;
	device.Driver = &Driver_USBD0;
	device.ep0_state = USBD_EP0_STATE_IDLE;
 8025cca:	f884 613b 	strb.w	r6, [r4, #315]	; 0x13b
	device.Endpoints[0].InBuffer = endpoint0_in_buffer;
	device.Endpoints[0].InBufferLength = USBD_EP0_BUF_SIZE;
 8025cce:	f44f 7280 	mov.w	r2, #256	; 0x100
	XMC_USBD_Disable();

	memset(&device,0x0,sizeof(USB_Device_t));
	USB_DeviceState = (uint8_t)DEVICE_STATE_Unattached;
	device.Driver = &Driver_USBD0;
	device.ep0_state = USBD_EP0_STATE_IDLE;
 8025cd2:	4630      	mov	r0, r6
	device.Endpoints[0].InBuffer = endpoint0_in_buffer;
	device.Endpoints[0].InBufferLength = USBD_EP0_BUF_SIZE;
 8025cd4:	6262      	str	r2, [r4, #36]	; 0x24
	device.Endpoints[0].OutBuffer = endpoint0_out_buffer;
	device.Endpoints[0].OutBufferLength = USBD_EP0_BUF_SIZE;
 8025cd6:	61a2      	str	r2, [r4, #24]
	device.Endpoints[0].Direction = (uint8_t)0;
	device.Endpoints[0].IsConfigured = (uint8_t)1;
	device.Endpoints[0].IsEnabled = (uint8_t)1;
	device.Endpoints[0].MaxPacketSize = (uint8_t)USBD_EP0_MAX_PKT_SIZE;

	if ((handle->event_cb->control_request == 0) ||
 8025cd8:	b321      	cbz	r1, 8025d24 <USBD_Init+0x9c>
 8025cda:	695a      	ldr	r2, [r3, #20]
 8025cdc:	b312      	cbz	r2, 8025d24 <USBD_Init+0x9c>
	    (handle->event_cb->get_descriptor == 0) ||
 8025cde:	689a      	ldr	r2, [r3, #8]
 8025ce0:	b302      	cbz	r2, 8025d24 <USBD_Init+0x9c>
	{
	  status = USBD_STATUS_FAILURE;
	}
	else
	{
	  device.events = handle->event_cb;
 8025ce2:	f8c4 3140 	str.w	r3, [r4, #320]	; 0x140

	  XMC_SCU_CLOCK_EnableClock(XMC_SCU_CLOCK_USB);
 8025ce6:	f7fb f9e5 	bl	80210b4 <XMC_SCU_CLOCK_EnableClock>

	  /* First initalize the device */
	  handle->usb_init.cb_xmc_device_event = USBD_SignalDeviceEventHandler;
	  handle->usb_init.cb_endpoint_event = USBD_SignalEndpointEvent_Handler;

	  status = (USBD_STATUS_t)device.Driver->Initialize(&handle->usb_init);
 8025cea:	6823      	ldr	r3, [r4, #0]
	  device.events = handle->event_cb;

	  XMC_SCU_CLOCK_EnableClock(XMC_SCU_CLOCK_USB);

	  /* First initalize the device */
	  handle->usb_init.cb_xmc_device_event = USBD_SignalDeviceEventHandler;
 8025cec:	4927      	ldr	r1, [pc, #156]	; (8025d8c <USBD_Init+0x104>)
	  handle->usb_init.cb_endpoint_event = USBD_SignalEndpointEvent_Handler;
 8025cee:	4a28      	ldr	r2, [pc, #160]	; (8025d90 <USBD_Init+0x108>)

	  status = (USBD_STATUS_t)device.Driver->Initialize(&handle->usb_init);
 8025cf0:	685b      	ldr	r3, [r3, #4]
	  device.events = handle->event_cb;

	  XMC_SCU_CLOCK_EnableClock(XMC_SCU_CLOCK_USB);

	  /* First initalize the device */
	  handle->usb_init.cb_xmc_device_event = USBD_SignalDeviceEventHandler;
 8025cf2:	6069      	str	r1, [r5, #4]
	  handle->usb_init.cb_endpoint_event = USBD_SignalEndpointEvent_Handler;
 8025cf4:	60aa      	str	r2, [r5, #8]

	  status = (USBD_STATUS_t)device.Driver->Initialize(&handle->usb_init);
 8025cf6:	4628      	mov	r0, r5
 8025cf8:	4798      	blx	r3
	  if (USBD_STATUS_SUCCESS == status)
 8025cfa:	4605      	mov	r5, r0
 8025cfc:	b1a8      	cbz	r0, 8025d2a <USBD_Init+0xa2>
	       (uint16_t)XMC_USBD_MAX_PACKET_SIZE);
	  }

	  if (USBD_STATUS_SUCCESS != status)
	  {
	  XMC_USBD_Disable();
 8025cfe:	f7fd fad1 	bl	80232a4 <XMC_USBD_Disable>
	  if (USBD_STATUS_SUCCESS == (USBD_STATUS_t)device.Driver->Uninitialize())
 8025d02:	6823      	ldr	r3, [r4, #0]
 8025d04:	689b      	ldr	r3, [r3, #8]
 8025d06:	4798      	blx	r3
 8025d08:	b950      	cbnz	r0, 8025d20 <USBD_Init+0x98>
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8025d0a:	4b22      	ldr	r3, [pc, #136]	; (8025d94 <USBD_Init+0x10c>)
 8025d0c:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8025d10:	f8c3 218c 	str.w	r2, [r3, #396]	; 0x18c
 */
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8025d14:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 8025d18:	f3bf 8f4f 	dsb	sy
           so that all instructions following the ISB are fetched from cache or memory,
           after the instruction has been completed.
 */
__attribute__((always_inline)) __STATIC_INLINE void __ISB(void)
{
  __ASM volatile ("isb 0xF":::"memory");
 8025d1c:	f3bf 8f6f 	isb	sy
	  }
	}


	return status;
}
 8025d20:	4628      	mov	r0, r5
 8025d22:	bd70      	pop	{r4, r5, r6, pc}

	if ((handle->event_cb->control_request == 0) ||
	    (handle->event_cb->get_descriptor == 0) ||
	    (handle->event_cb->config_changed == 0))
	{
	  status = USBD_STATUS_FAILURE;
 8025d24:	4605      	mov	r5, r0
	  }
	}


	return status;
}
 8025d26:	4628      	mov	r0, r5
 8025d28:	bd70      	pop	{r4, r5, r6, pc}
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8025d2a:	4b1b      	ldr	r3, [pc, #108]	; (8025d98 <USBD_Init+0x110>)
 8025d2c:	68db      	ldr	r3, [r3, #12]
 8025d2e:	f3c3 2302 	ubfx	r3, r3, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8025d32:	f1c3 0107 	rsb	r1, r3, #7
 8025d36:	2906      	cmp	r1, #6
 8025d38:	bf28      	it	cs
 8025d3a:	2106      	movcs	r1, #6
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8025d3c:	b1cb      	cbz	r3, 8025d72 <USBD_Init+0xea>
 8025d3e:	1e5a      	subs	r2, r3, #1

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8025d40:	2301      	movs	r3, #1
 8025d42:	408b      	lsls	r3, r1
 8025d44:	3b01      	subs	r3, #1
 8025d46:	4093      	lsls	r3, r2
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8025d48:	009b      	lsls	r3, r3, #2
 8025d4a:	4a12      	ldr	r2, [pc, #72]	; (8025d94 <USBD_Init+0x10c>)
 8025d4c:	b2db      	uxtb	r3, r3
 8025d4e:	f882 336b 	strb.w	r3, [r2, #875]	; 0x36b
	  {
	  /* Enable Interrupts in NVIC */
	  USB_EnableUSBInterrupt();

	  /* then configure endpoint 0 */
	  status = (USBD_STATUS_t)device.Driver->EndpointConfigure((uint8_t)0,XMC_USBD_ENDPOINT_TYPE_CONTROL,
 8025d52:	6823      	ldr	r3, [r4, #0]
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8025d54:	f44f 6100 	mov.w	r1, #2048	; 0x800
 8025d58:	2000      	movs	r0, #0
 8025d5a:	f8c2 118c 	str.w	r1, [r2, #396]	; 0x18c
 8025d5e:	69db      	ldr	r3, [r3, #28]
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8025d60:	60d1      	str	r1, [r2, #12]
 8025d62:	4601      	mov	r1, r0
 8025d64:	2240      	movs	r2, #64	; 0x40
 8025d66:	4798      	blx	r3
	       (uint16_t)XMC_USBD_MAX_PACKET_SIZE);
	  }

	  if (USBD_STATUS_SUCCESS != status)
 8025d68:	4605      	mov	r5, r0
 8025d6a:	2800      	cmp	r0, #0
 8025d6c:	d1c7      	bne.n	8025cfe <USBD_Init+0x76>
	  }
	}


	return status;
}
 8025d6e:	4628      	mov	r0, r5
 8025d70:	bd70      	pop	{r4, r5, r6, pc}
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8025d72:	461a      	mov	r2, r3
 8025d74:	e7e4      	b.n	8025d40 <USBD_Init+0xb8>
 8025d76:	bf00      	nop
 8025d78:	1fff05b0 	.word	0x1fff05b0
 8025d7c:	1fff03a5 	.word	0x1fff03a5
 8025d80:	0802f2a4 	.word	0x0802f2a4
 8025d84:	1fff04b0 	.word	0x1fff04b0
 8025d88:	1fff03b0 	.word	0x1fff03b0
 8025d8c:	08025469 	.word	0x08025469
 8025d90:	08025ab1 	.word	0x08025ab1
 8025d94:	e000e100 	.word	0xe000e100
 8025d98:	e000ed00 	.word	0xe000ed00

08025d9c <USBD_Connect>:
 * Tell the USB device controller driver to connect to the bus. Successful connection will be shown
 * through update of the device status ( USB_DeviceState) and a firing of the USB device connect event.
 */
USBD_STATUS_t USBD_Connect(void)
{
  return (USBD_STATUS_t)device.Driver->DeviceConnect();
 8025d9c:	4b01      	ldr	r3, [pc, #4]	; (8025da4 <USBD_Connect+0x8>)
 8025d9e:	681b      	ldr	r3, [r3, #0]
 8025da0:	68db      	ldr	r3, [r3, #12]
 8025da2:	4718      	bx	r3
 8025da4:	1fff05b0 	.word	0x1fff05b0

08025da8 <USBD_IsEnumDone>:
 * Check with the USB device controller driver if the enumeration is done.
 * Returns 1 on completion of enumeration.
 */
uint32_t USBD_IsEnumDone(void)
{
  return device.Driver->IsEnumDone();
 8025da8:	4b01      	ldr	r3, [pc, #4]	; (8025db0 <USBD_IsEnumDone+0x8>)
 8025daa:	681b      	ldr	r3, [r3, #0]
 8025dac:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8025dae:	4718      	bx	r3
 8025db0:	1fff05b0 	.word	0x1fff05b0

08025db4 <USBD_SetEndpointBuffer>:
  XMC_ASSERT("USBD_SetEndpointBuffer: invalid buffer", (buf != NULL));

  number = (uint32_t)addr & (uint32_t)ENDPOINT_EPNUM_MASK;
  XMC_ASSERT("USBD_SetEndpointBuffer: invalid ep address", (number < (uint8_t)USBD_MAX_NUM_EPS));

  if (addr & (uint8_t)ENDPOINT_DIR_MASK)
 8025db4:	f010 0f80 	tst.w	r0, #128	; 0x80
 *
 * The user has to ensure that an endpoint has a valid buffer for proper data transfer.
 *
 */
void USBD_SetEndpointBuffer(uint8_t addr, uint8_t *buf, uint16_t len)
{
 8025db8:	b410      	push	{r4}
  number = (uint32_t)addr & (uint32_t)ENDPOINT_EPNUM_MASK;
  XMC_ASSERT("USBD_SetEndpointBuffer: invalid ep address", (number < (uint8_t)USBD_MAX_NUM_EPS));

  if (addr & (uint8_t)ENDPOINT_DIR_MASK)
  {
    device.Endpoints[number].InBuffer = buf;
 8025dba:	4b0a      	ldr	r3, [pc, #40]	; (8025de4 <USBD_SetEndpointBuffer+0x30>)
void USBD_SetEndpointBuffer(uint8_t addr, uint8_t *buf, uint16_t len)
{
  uint32_t number;
  XMC_ASSERT("USBD_SetEndpointBuffer: invalid buffer", (buf != NULL));

  number = (uint32_t)addr & (uint32_t)ENDPOINT_EPNUM_MASK;
 8025dbc:	f000 040f 	and.w	r4, r0, #15
  XMC_ASSERT("USBD_SetEndpointBuffer: invalid ep address", (number < (uint8_t)USBD_MAX_NUM_EPS));

  if (addr & (uint8_t)ENDPOINT_DIR_MASK)
  {
    device.Endpoints[number].InBuffer = buf;
 8025dc0:	f04f 002c 	mov.w	r0, #44	; 0x2c
  XMC_ASSERT("USBD_SetEndpointBuffer: invalid buffer", (buf != NULL));

  number = (uint32_t)addr & (uint32_t)ENDPOINT_EPNUM_MASK;
  XMC_ASSERT("USBD_SetEndpointBuffer: invalid ep address", (number < (uint8_t)USBD_MAX_NUM_EPS));

  if (addr & (uint8_t)ENDPOINT_DIR_MASK)
 8025dc4:	d106      	bne.n	8025dd4 <USBD_SetEndpointBuffer+0x20>
    device.Endpoints[number].InBuffer = buf;
    device.Endpoints[number].InBufferLength = len;
  }
  else
  {
    device.Endpoints[number].OutBuffer = buf;
 8025dc6:	fb00 3304 	mla	r3, r0, r4, r3
    device.Endpoints[number].OutBufferLength = len;
  }

}
 8025dca:	f85d 4b04 	ldr.w	r4, [sp], #4
    device.Endpoints[number].InBuffer = buf;
    device.Endpoints[number].InBufferLength = len;
  }
  else
  {
    device.Endpoints[number].OutBuffer = buf;
 8025dce:	6159      	str	r1, [r3, #20]
    device.Endpoints[number].OutBufferLength = len;
 8025dd0:	619a      	str	r2, [r3, #24]
  }

}
 8025dd2:	4770      	bx	lr
  number = (uint32_t)addr & (uint32_t)ENDPOINT_EPNUM_MASK;
  XMC_ASSERT("USBD_SetEndpointBuffer: invalid ep address", (number < (uint8_t)USBD_MAX_NUM_EPS));

  if (addr & (uint8_t)ENDPOINT_DIR_MASK)
  {
    device.Endpoints[number].InBuffer = buf;
 8025dd4:	fb00 3404 	mla	r4, r0, r4, r3
 8025dd8:	6221      	str	r1, [r4, #32]
    device.Endpoints[number].InBufferLength = len;
 8025dda:	6262      	str	r2, [r4, #36]	; 0x24
  {
    device.Endpoints[number].OutBuffer = buf;
    device.Endpoints[number].OutBufferLength = len;
  }

}
 8025ddc:	f85d 4b04 	ldr.w	r4, [sp], #4
 8025de0:	4770      	bx	lr
 8025de2:	bf00      	nop
 8025de4:	1fff05b0 	.word	0x1fff05b0

08025de8 <USB0_0_IRQHandler>:
 * This function gets called, if a USB exception (interrupt) was thrown and
 * dispatches it to XMC_USBD_IRQHandler.
 */
void USB0_0_IRQHandler(void)
{
  XMC_USBD_IRQHandler(&(USBD_handle->usb_init));
 8025de8:	4b01      	ldr	r3, [pc, #4]	; (8025df0 <USB0_0_IRQHandler+0x8>)
 8025dea:	6818      	ldr	r0, [r3, #0]
 8025dec:	f7fc bdee 	b.w	80229cc <XMC_USBD_IRQHandler>
 8025df0:	1ffe9108 	.word	0x1ffe9108

08025df4 <TIMER_Init>:
/*
 * This function initializes a TIMER APP based on user configuration.
 *
 */
TIMER_STATUS_t TIMER_Init(TIMER_t* const handle_ptr)
{
 8025df4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  XMC_ASSERT("TIMER_Init:handle_ptr NULL" , (handle_ptr != NULL));

  status = TIMER_STATUS_SUCCESS;
  /* Check for APP instance is initialized or not */
  if (false == handle_ptr->initialized)
 8025df6:	f890 3026 	ldrb.w	r3, [r0, #38]	; 0x26
 8025dfa:	2b00      	cmp	r3, #0
 8025dfc:	d12f      	bne.n	8025e5e <TIMER_Init+0x6a>
  {
#ifdef TIMER_CCU4_USED
    if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
 8025dfe:	f890 6021 	ldrb.w	r6, [r0, #33]	; 0x21
 8025e02:	b116      	cbz	r6, 8025e0a <TIMER_Init+0x16>
{
  TIMER_STATUS_t status;

  XMC_ASSERT("TIMER_Init:handle_ptr NULL" , (handle_ptr != NULL));

  status = TIMER_STATUS_SUCCESS;
 8025e04:	461d      	mov	r5, r3
    }
#endif
  }

  return (status);
}
 8025e06:	4628      	mov	r0, r5
 8025e08:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8025e0a:	4604      	mov	r4, r0
 */
TIMER_STATUS_t TIMER_CCU4_lInit(TIMER_t* const handle_ptr)
{
  TIMER_STATUS_t status;
  /* Initialize the global registers */
  status = (TIMER_STATUS_t)GLOBAL_CCU4_Init(handle_ptr->global_ccu4_handler);
 8025e0c:	6900      	ldr	r0, [r0, #16]
 8025e0e:	f000 fc33 	bl	8026678 <GLOBAL_CCU4_Init>

  /* Enable the clock for selected timer */
  XMC_CCU4_EnableClock(handle_ptr->global_ccu4_handler->module_ptr, handle_ptr->ccu4_slice_number);
 8025e12:	6923      	ldr	r3, [r4, #16]
__STATIC_INLINE void XMC_CCU4_EnableClock(XMC_CCU4_MODULE_t *const module, const uint8_t slice_number)
{
  XMC_ASSERT("XMC_CCU4_EnableClock:Invalid Module Pointer", XMC_CCU4_IsValidModule(module));
  XMC_ASSERT("XMC_CCU4_EnableClock:Invalid Slice Number", (slice_number < 4U));

  module->GIDLC |= ((uint32_t) 1) << slice_number;
 8025e14:	f894 e018 	ldrb.w	lr, [r4, #24]
 8025e18:	689f      	ldr	r7, [r3, #8]
  /* Configure the timer with required settings */
  XMC_CCU4_SLICE_CompareInit(handle_ptr->ccu4_slice_ptr, handle_ptr->ccu4_slice_config_ptr);
 8025e1a:	69e1      	ldr	r1, [r4, #28]
 8025e1c:	68fa      	ldr	r2, [r7, #12]
 8025e1e:	2301      	movs	r3, #1
 8025e20:	fa03 f30e 	lsl.w	r3, r3, lr
 8025e24:	4313      	orrs	r3, r2
 */
TIMER_STATUS_t TIMER_CCU4_lInit(TIMER_t* const handle_ptr)
{
  TIMER_STATUS_t status;
  /* Initialize the global registers */
  status = (TIMER_STATUS_t)GLOBAL_CCU4_Init(handle_ptr->global_ccu4_handler);
 8025e26:	4605      	mov	r5, r0

  /* Enable the clock for selected timer */
  XMC_CCU4_EnableClock(handle_ptr->global_ccu4_handler->module_ptr, handle_ptr->ccu4_slice_number);
  /* Configure the timer with required settings */
  XMC_CCU4_SLICE_CompareInit(handle_ptr->ccu4_slice_ptr, handle_ptr->ccu4_slice_config_ptr);
 8025e28:	6960      	ldr	r0, [r4, #20]
 8025e2a:	60fb      	str	r3, [r7, #12]
 8025e2c:	f7fb fbc4 	bl	80215b8 <XMC_CCU4_SLICE_CompareInit>
  /* programs the timer period register according to time interval value */
  XMC_CCU4_SLICE_SetTimerPeriodMatch(handle_ptr->ccu4_slice_ptr, handle_ptr->period_value);
  /* programs the timer compare register for 50% duty cycle */
  XMC_CCU4_SLICE_SetTimerCompareMatch(handle_ptr->ccu4_slice_ptr, TIMER_CMP_100_DUTY);
  /* Transfers value from shadow timer registers to actual timer registers */
  XMC_CCU4_EnableShadowTransfer(handle_ptr->global_ccu4_handler->module_ptr, handle_ptr->shadow_mask);
 8025e30:	6923      	ldr	r3, [r4, #16]
 * This function configures timer period and compare values and triggers the shadow transfer operation
 */
void TIMER_CCU4_lShadowTransfer(TIMER_t* const handle_ptr)
{
  /* programs the timer period register according to time interval value */
  XMC_CCU4_SLICE_SetTimerPeriodMatch(handle_ptr->ccu4_slice_ptr, handle_ptr->period_value);
 8025e32:	6960      	ldr	r0, [r4, #20]
  /* programs the timer compare register for 50% duty cycle */
  XMC_CCU4_SLICE_SetTimerCompareMatch(handle_ptr->ccu4_slice_ptr, TIMER_CMP_100_DUTY);
  /* Transfers value from shadow timer registers to actual timer registers */
  XMC_CCU4_EnableShadowTransfer(handle_ptr->global_ccu4_handler->module_ptr, handle_ptr->shadow_mask);
 8025e34:	689a      	ldr	r2, [r3, #8]
  XMC_CCU4_SLICE_CompareInit(handle_ptr->ccu4_slice_ptr, handle_ptr->ccu4_slice_config_ptr);
  /* programs the timer period and compare register according to time interval value and do the shadow transfer */
  TIMER_CCU4_lShadowTransfer(handle_ptr);

#ifdef  TIMER_INTERRUPT
  if (true == handle_ptr->period_match_enable)
 8025e36:	f894 3025 	ldrb.w	r3, [r4, #37]	; 0x25
 *  XMC_CCU4_SLICE_GetTimerPeriodMatch().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_SetTimerPeriodMatch(XMC_CCU4_SLICE_t *const slice, const uint16_t period_val)
{
  XMC_ASSERT("XMC_CCU4_SLICE_SetTimerPeriodMatch:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->PRS = (uint32_t) period_val;
 8025e3a:	8c67      	ldrh	r7, [r4, #34]	; 0x22
  /* programs the timer period register according to time interval value */
  XMC_CCU4_SLICE_SetTimerPeriodMatch(handle_ptr->ccu4_slice_ptr, handle_ptr->period_value);
  /* programs the timer compare register for 50% duty cycle */
  XMC_CCU4_SLICE_SetTimerCompareMatch(handle_ptr->ccu4_slice_ptr, TIMER_CMP_100_DUTY);
  /* Transfers value from shadow timer registers to actual timer registers */
  XMC_CCU4_EnableShadowTransfer(handle_ptr->global_ccu4_handler->module_ptr, handle_ptr->shadow_mask);
 8025e3c:	68e1      	ldr	r1, [r4, #12]
 8025e3e:	6347      	str	r7, [r0, #52]	; 0x34
 *  XMC_CCU4_SLICE_GetTimerPeriodMatch().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_SetTimerCompareMatch(XMC_CCU4_SLICE_t *const slice, const uint16_t compare_val)
{
  XMC_ASSERT("XMC_CCU4_SLICE_SetTimerCompareMatch:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->CRS = (uint32_t) compare_val;
 8025e40:	63c6      	str	r6, [r0, #60]	; 0x3c
 *  None.
 */
__STATIC_INLINE void XMC_CCU4_EnableShadowTransfer(XMC_CCU4_MODULE_t *const module, const uint32_t shadow_transfer_msk)
{
  XMC_ASSERT("XMC_CCU4_EnableShadowTransfer:Invalid Slice Pointer", XMC_CCU4_IsValidModule(module));
  module->GCSS = (uint32_t)shadow_transfer_msk;  
 8025e42:	6111      	str	r1, [r2, #16]
  XMC_CCU4_SLICE_CompareInit(handle_ptr->ccu4_slice_ptr, handle_ptr->ccu4_slice_config_ptr);
  /* programs the timer period and compare register according to time interval value and do the shadow transfer */
  TIMER_CCU4_lShadowTransfer(handle_ptr);

#ifdef  TIMER_INTERRUPT
  if (true == handle_ptr->period_match_enable)
 8025e44:	b973      	cbnz	r3, 8025e64 <TIMER_Init+0x70>

  /* update the initialization flag as true for particular instance*/
  handle_ptr->initialized = true;

  /* Check whether the start of the timer is enabled during initialization or not */
  if (handle_ptr->start_control == true)
 8025e46:	f894 2024 	ldrb.w	r2, [r4, #36]	; 0x24
 *  XMC_CCU4_SLICE_StartTimer().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_ClearTimer(XMC_CCU4_SLICE_t *const slice)
{
  XMC_ASSERT("XMC_CCU4_SLICE_ClearTimer:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->TCCLR = (uint32_t) CCU4_CC4_TCCLR_TCC_Msk;
 8025e4a:	2102      	movs	r1, #2
#endif
  /* Clears the timer register */
  XMC_CCU4_SLICE_ClearTimer(handle_ptr->ccu4_slice_ptr);

  /* update the initialization flag as true for particular instance*/
  handle_ptr->initialized = true;
 8025e4c:	2301      	movs	r3, #1
 8025e4e:	6101      	str	r1, [r0, #16]
 8025e50:	f884 3026 	strb.w	r3, [r4, #38]	; 0x26

  /* Check whether the start of the timer is enabled during initialization or not */
  if (handle_ptr->start_control == true)
 8025e54:	2a00      	cmp	r2, #0
 8025e56:	d0d6      	beq.n	8025e06 <TIMER_Init+0x12>
 *  XMC_CCU4_SLICE_StopTimer().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_StartTimer(XMC_CCU4_SLICE_t *const slice)
{
  XMC_ASSERT("XMC_CCU4_SLICE_StartTimer:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->TCSET = CCU4_CC4_TCSET_TRBS_Msk;
 8025e58:	60c3      	str	r3, [r0, #12]
    }
#endif
  }

  return (status);
}
 8025e5a:	4628      	mov	r0, r5
 8025e5c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
{
  TIMER_STATUS_t status;

  XMC_ASSERT("TIMER_Init:handle_ptr NULL" , (handle_ptr != NULL));

  status = TIMER_STATUS_SUCCESS;
 8025e5e:	2500      	movs	r5, #0
    }
#endif
  }

  return (status);
}
 8025e60:	4628      	mov	r0, r5
 8025e62:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

#ifdef  TIMER_INTERRUPT
  if (true == handle_ptr->period_match_enable)
  {
    /* Binds a period match event to an NVIC node  */
    XMC_CCU4_SLICE_SetInterruptNode(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_PERIOD_MATCH,
 8025e64:	4631      	mov	r1, r6
 8025e66:	f894 2020 	ldrb.w	r2, [r4, #32]
 8025e6a:	f7fb fbc7 	bl	80215fc <XMC_CCU4_SLICE_SetInterruptNode>
                                    handle_ptr->ccu4_period_match_node);
    /* Enables a timer(period match) event  */
    XMC_CCU4_SLICE_EnableEvent(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_PERIOD_MATCH);
 8025e6e:	6960      	ldr	r0, [r4, #20]
__STATIC_INLINE void XMC_CCU4_SLICE_EnableEvent(XMC_CCU4_SLICE_t *const slice,
                                                const XMC_CCU4_SLICE_IRQ_ID_t event)
{
  XMC_ASSERT("XMC_CCU4_SLICE_EnableEvent:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_EnableEvent:Invalid SR event", XMC_CCU4_SLICE_CHECK_INTERRUPT(event));
  slice->INTE |= ((uint32_t) 1) << ((uint32_t) event);
 8025e70:	f8d0 30a4 	ldr.w	r3, [r0, #164]	; 0xa4
 8025e74:	f043 0301 	orr.w	r3, r3, #1
 8025e78:	f8c0 30a4 	str.w	r3, [r0, #164]	; 0xa4
 8025e7c:	e7e3      	b.n	8025e46 <TIMER_Init+0x52>
 8025e7e:	bf00      	nop

08025e80 <TIMER_Start>:
  TIMER_STATUS_t status;

  XMC_ASSERT("TIMER_Start:handle_ptr NULL" , (handle_ptr != NULL));

  /* Check for APP instance is initialized or not */
  if (true == handle_ptr->initialized)
 8025e80:	f890 3026 	ldrb.w	r3, [r0, #38]	; 0x26
 8025e84:	b14b      	cbz	r3, 8025e9a <TIMER_Start+0x1a>
  {
#ifdef TIMER_CCU4_USED
    if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
 8025e86:	f890 3021 	ldrb.w	r3, [r0, #33]	; 0x21
 8025e8a:	b923      	cbnz	r3, 8025e96 <TIMER_Start+0x16>
    {
      /* Start the timer manually */
      XMC_CCU4_SLICE_StartTimer(handle_ptr->ccu4_slice_ptr);
 8025e8c:	6942      	ldr	r2, [r0, #20]
 *  XMC_CCU4_SLICE_StopTimer().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_StartTimer(XMC_CCU4_SLICE_t *const slice)
{
  XMC_ASSERT("XMC_CCU4_SLICE_StartTimer:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->TCSET = CCU4_CC4_TCSET_TRBS_Msk;
 8025e8e:	2101      	movs	r1, #1
       {
      /* Start the timer manually */
      XMC_CCU8_SLICE_StartTimer(handle_ptr->ccu8_slice_ptr);
       }
#endif
    status = TIMER_STATUS_SUCCESS;
 8025e90:	4618      	mov	r0, r3
 8025e92:	60d1      	str	r1, [r2, #12]
 8025e94:	4770      	bx	lr
 8025e96:	2000      	movs	r0, #0
  {
    status = TIMER_STATUS_FAILURE;
  }

  return (status);
}
 8025e98:	4770      	bx	lr
#endif
    status = TIMER_STATUS_SUCCESS;
  }
  else
  {
    status = TIMER_STATUS_FAILURE;
 8025e9a:	2001      	movs	r0, #1
 8025e9c:	4770      	bx	lr
 8025e9e:	bf00      	nop

08025ea0 <TIMER_Stop>:
  XMC_ASSERT("TIMER_GetTimerStatus:handle_ptr NULL" , (handle_ptr != NULL));

  status = false;

#ifdef TIMER_CCU4_USED
  if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
 8025ea0:	f890 3021 	ldrb.w	r3, [r0, #33]	; 0x21
 8025ea4:	b10b      	cbz	r3, 8025eaa <TIMER_Stop+0xa>
#endif
    status = TIMER_STATUS_SUCCESS;
  }
  else
  {
    status = TIMER_STATUS_FAILURE;
 8025ea6:	2001      	movs	r0, #1
  }

  return (status);
}
 8025ea8:	4770      	bx	lr

#ifdef TIMER_CCU4_USED
  if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
  {
    /* Returns the current status of the timer */
    status = XMC_CCU4_SLICE_IsTimerRunning(handle_ptr->ccu4_slice_ptr);
 8025eaa:	6941      	ldr	r1, [r0, #20]
 *  XMC_CCU4_SLICE_StartTimer()<BR> XMC_CCU4_SLICE_StopTimer().
 */
__STATIC_INLINE bool XMC_CCU4_SLICE_IsTimerRunning(const XMC_CCU4_SLICE_t *const slice)
{
  XMC_ASSERT("XMC_CCU4_SLICE_GetTimerStatus:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  return (bool)(((slice->TCST) & CCU4_CC4_TCST_TRB_Msk) == CCU4_CC4_TCST_TRB_Msk);
 8025eac:	688a      	ldr	r2, [r1, #8]
  TIMER_STATUS_t status;

  XMC_ASSERT("TIMER_Stop:handle_ptr NULL" , (handle_ptr != NULL));

  /* Check whether timer is initialized and in running state */
  if ((TIMER_GetTimerStatus(handle_ptr)) && (true == handle_ptr->initialized))
 8025eae:	07d2      	lsls	r2, r2, #31
 8025eb0:	d5f9      	bpl.n	8025ea6 <TIMER_Stop+0x6>
 8025eb2:	f890 2026 	ldrb.w	r2, [r0, #38]	; 0x26
 8025eb6:	2a00      	cmp	r2, #0
 8025eb8:	d0f5      	beq.n	8025ea6 <TIMER_Stop+0x6>
 *  XMC_CCU4_SLICE_StartTimer().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_StopTimer(XMC_CCU4_SLICE_t *const slice)
{
  XMC_ASSERT("XMC_CCU4_SLICE_StopTimer:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->TCCLR = (uint32_t) CCU4_CC4_TCCLR_TRBC_Msk;
 8025eba:	2201      	movs	r2, #1
       {
      /* Stops the timer */
      XMC_CCU8_SLICE_StopTimer(handle_ptr->ccu8_slice_ptr);
       }
#endif
    status = TIMER_STATUS_SUCCESS;
 8025ebc:	4618      	mov	r0, r3
 8025ebe:	610a      	str	r2, [r1, #16]
 8025ec0:	4770      	bx	lr
 8025ec2:	bf00      	nop
 8025ec4:	0000      	movs	r0, r0
	...

08025ec8 <TIMER_SetTimeInterval>:
/*
 * This function changes the PWM period which in turn changes the time tick interval value by checking that
 * the given time tick value is within supported range.
 */
TIMER_STATUS_t TIMER_SetTimeInterval(TIMER_t  *const handle_ptr, uint32_t time_interval)
{
 8025ec8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  XMC_ASSERT("TIMER_GetTimerStatus:handle_ptr NULL" , (handle_ptr != NULL));

  status = false;

#ifdef TIMER_CCU4_USED
  if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
 8025eca:	f890 6021 	ldrb.w	r6, [r0, #33]	; 0x21
 8025ece:	2e00      	cmp	r6, #0
 8025ed0:	d04a      	beq.n	8025f68 <TIMER_SetTimeInterval+0xa0>
  status = TIMER_STATUS_FAILURE;

  if (false == TIMER_GetTimerStatus(handle_ptr))
  {
    /* check for time_interval range */
    if ((time_interval >= handle_ptr->timer_min_value_us) && (time_interval <= handle_ptr->timer_max_value_us))
 8025ed2:	6883      	ldr	r3, [r0, #8]
 8025ed4:	428b      	cmp	r3, r1
 8025ed6:	d84b      	bhi.n	8025f70 <TIMER_SetTimeInterval+0xa8>
 8025ed8:	6845      	ldr	r5, [r0, #4]
 8025eda:	42a9      	cmp	r1, r5
 8025edc:	d848      	bhi.n	8025f70 <TIMER_SetTimeInterval+0xa8>
    {
      /* Initialize the prescaler */
      lprescaler = 0U;
      while (time_interval > (handle_ptr->timer_max_value_us >> (TIMER_PRESCALER_MAX - lprescaler)))
 8025ede:	ebb1 3fd5 	cmp.w	r1, r5, lsr #15
 8025ee2:	d947      	bls.n	8025f74 <TIMER_SetTimeInterval+0xac>
 8025ee4:	2300      	movs	r3, #0
 8025ee6:	f1c3 020e 	rsb	r2, r3, #14
 8025eea:	fa25 f202 	lsr.w	r2, r5, r2
      {
        lprescaler++;
 8025eee:	1c5c      	adds	r4, r3, #1
    /* check for time_interval range */
    if ((time_interval >= handle_ptr->timer_min_value_us) && (time_interval <= handle_ptr->timer_max_value_us))
    {
      /* Initialize the prescaler */
      lprescaler = 0U;
      while (time_interval > (handle_ptr->timer_max_value_us >> (TIMER_PRESCALER_MAX - lprescaler)))
 8025ef0:	4291      	cmp	r1, r2
      {
        lprescaler++;
 8025ef2:	4623      	mov	r3, r4
    /* check for time_interval range */
    if ((time_interval >= handle_ptr->timer_min_value_us) && (time_interval <= handle_ptr->timer_max_value_us))
    {
      /* Initialize the prescaler */
      lprescaler = 0U;
      while (time_interval > (handle_ptr->timer_max_value_us >> (TIMER_PRESCALER_MAX - lprescaler)))
 8025ef4:	d8f7      	bhi.n	8025ee6 <TIMER_SetTimeInterval+0x1e>
      {
        lprescaler++;
      }
#ifdef TIMER_CCU4_USED
      if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
 8025ef6:	2e00      	cmp	r6, #0
 8025ef8:	d13a      	bne.n	8025f70 <TIMER_SetTimeInterval+0xa8>
      {
        lfrequency = handle_ptr->global_ccu4_handler->module_frequency;
 8025efa:	6903      	ldr	r3, [r0, #16]
        handle_ptr->ccu4_slice_config_ptr->prescaler_initval = lprescaler;
 8025efc:	69c7      	ldr	r7, [r0, #28]
        lprescaler++;
      }
#ifdef TIMER_CCU4_USED
      if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
      {
        lfrequency = handle_ptr->global_ccu4_handler->module_frequency;
 8025efe:	681a      	ldr	r2, [r3, #0]
        handle_ptr->ccu4_slice_config_ptr->prescaler_initval = lprescaler;
 8025f00:	f897 e004 	ldrb.w	lr, [r7, #4]
 8025f04:	f004 060f 	and.w	r6, r4, #15
        /* Calculate the period register for the required time_interval value */
        handle_ptr->period_value = (uint16_t)((((uint64_t)time_interval * lfrequency) >> \
 8025f08:	fba1 2302 	umull	r2, r3, r1, r2
 8025f0c:	f1c6 0120 	rsb	r1, r6, #32
 8025f10:	4605      	mov	r5, r0
 8025f12:	fa03 f101 	lsl.w	r1, r3, r1
 8025f16:	fa22 f006 	lsr.w	r0, r2, r6
 8025f1a:	f1a6 0220 	sub.w	r2, r6, #32
      }
#ifdef TIMER_CCU4_USED
      if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
      {
        lfrequency = handle_ptr->global_ccu4_handler->module_frequency;
        handle_ptr->ccu4_slice_config_ptr->prescaler_initval = lprescaler;
 8025f1e:	f364 0e03 	bfi	lr, r4, #0, #4
        /* Calculate the period register for the required time_interval value */
        handle_ptr->period_value = (uint16_t)((((uint64_t)time_interval * lfrequency) >> \
 8025f22:	4308      	orrs	r0, r1
 8025f24:	fa23 f202 	lsr.w	r2, r3, r2
                                               handle_ptr->ccu4_slice_config_ptr->prescaler_initval) / \
 8025f28:	fa23 f106 	lsr.w	r1, r3, r6
      }
#ifdef TIMER_CCU4_USED
      if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
      {
        lfrequency = handle_ptr->global_ccu4_handler->module_frequency;
        handle_ptr->ccu4_slice_config_ptr->prescaler_initval = lprescaler;
 8025f2c:	f887 e004 	strb.w	lr, [r7, #4]
        /* Calculate the period register for the required time_interval value */
        handle_ptr->period_value = (uint16_t)((((uint64_t)time_interval * lfrequency) >> \
                                               handle_ptr->ccu4_slice_config_ptr->prescaler_initval) / \
 8025f30:	4310      	orrs	r0, r2
 8025f32:	a313      	add	r3, pc, #76	; (adr r3, 8025f80 <TIMER_SetTimeInterval+0xb8>)
 8025f34:	e9d3 2300 	ldrd	r2, r3, [r3]
 8025f38:	f007 f828 	bl	802cf8c <__aeabi_uldivmod>
      if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
      {
        lfrequency = handle_ptr->global_ccu4_handler->module_frequency;
        handle_ptr->ccu4_slice_config_ptr->prescaler_initval = lprescaler;
        /* Calculate the period register for the required time_interval value */
        handle_ptr->period_value = (uint16_t)((((uint64_t)time_interval * lfrequency) >> \
 8025f3c:	b280      	uxth	r0, r0
                                               handle_ptr->ccu4_slice_config_ptr->prescaler_initval) / \
                                              TIMER_RESOLUTION_SEC_TO_MICRO);
        /* Actual timer period values is Period_reg_val+1U */
        if (handle_ptr->period_value > TIMER_PERIOD_MIN)
 8025f3e:	2801      	cmp	r0, #1
        {
          (handle_ptr->period_value)--;
 8025f40:	bf88      	it	hi
 8025f42:	f100 30ff 	addhi.w	r0, r0, #4294967295
      }
#ifdef TIMER_CCU4_USED
      if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
      {
        lfrequency = handle_ptr->global_ccu4_handler->module_frequency;
        handle_ptr->ccu4_slice_config_ptr->prescaler_initval = lprescaler;
 8025f46:	b2e4      	uxtb	r4, r4
                                               handle_ptr->ccu4_slice_config_ptr->prescaler_initval) / \
                                              TIMER_RESOLUTION_SEC_TO_MICRO);
        /* Actual timer period values is Period_reg_val+1U */
        if (handle_ptr->period_value > TIMER_PERIOD_MIN)
        {
          (handle_ptr->period_value)--;
 8025f48:	8468      	strh	r0, [r5, #34]	; 0x22
        }
        /* Update the prescaler */
        XMC_CCU4_SLICE_SetPrescaler(handle_ptr->ccu4_slice_ptr, handle_ptr->ccu4_slice_config_ptr->prescaler_initval);
 8025f4a:	f004 010f 	and.w	r1, r4, #15
 8025f4e:	6968      	ldr	r0, [r5, #20]
 8025f50:	f7fb fb4c 	bl	80215ec <XMC_CCU4_SLICE_SetPrescaler>
  /* programs the timer period register according to time interval value */
  XMC_CCU4_SLICE_SetTimerPeriodMatch(handle_ptr->ccu4_slice_ptr, handle_ptr->period_value);
  /* programs the timer compare register for 50% duty cycle */
  XMC_CCU4_SLICE_SetTimerCompareMatch(handle_ptr->ccu4_slice_ptr, TIMER_CMP_100_DUTY);
  /* Transfers value from shadow timer registers to actual timer registers */
  XMC_CCU4_EnableShadowTransfer(handle_ptr->global_ccu4_handler->module_ptr, handle_ptr->shadow_mask);
 8025f54:	692a      	ldr	r2, [r5, #16]
 * This function configures timer period and compare values and triggers the shadow transfer operation
 */
void TIMER_CCU4_lShadowTransfer(TIMER_t* const handle_ptr)
{
  /* programs the timer period register according to time interval value */
  XMC_CCU4_SLICE_SetTimerPeriodMatch(handle_ptr->ccu4_slice_ptr, handle_ptr->period_value);
 8025f56:	696b      	ldr	r3, [r5, #20]
 *  XMC_CCU4_SLICE_GetTimerPeriodMatch().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_SetTimerPeriodMatch(XMC_CCU4_SLICE_t *const slice, const uint16_t period_val)
{
  XMC_ASSERT("XMC_CCU4_SLICE_SetTimerPeriodMatch:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->PRS = (uint32_t) period_val;
 8025f58:	8c68      	ldrh	r0, [r5, #34]	; 0x22
  /* programs the timer compare register for 50% duty cycle */
  XMC_CCU4_SLICE_SetTimerCompareMatch(handle_ptr->ccu4_slice_ptr, TIMER_CMP_100_DUTY);
  /* Transfers value from shadow timer registers to actual timer registers */
  XMC_CCU4_EnableShadowTransfer(handle_ptr->global_ccu4_handler->module_ptr, handle_ptr->shadow_mask);
 8025f5a:	6892      	ldr	r2, [r2, #8]
 8025f5c:	68e9      	ldr	r1, [r5, #12]
 8025f5e:	6358      	str	r0, [r3, #52]	; 0x34
 *  XMC_CCU4_SLICE_GetTimerPeriodMatch().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_SetTimerCompareMatch(XMC_CCU4_SLICE_t *const slice, const uint16_t compare_val)
{
  XMC_ASSERT("XMC_CCU4_SLICE_SetTimerCompareMatch:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->CRS = (uint32_t) compare_val;
 8025f60:	2000      	movs	r0, #0
 8025f62:	63d8      	str	r0, [r3, #60]	; 0x3c
 *  None.
 */
__STATIC_INLINE void XMC_CCU4_EnableShadowTransfer(XMC_CCU4_MODULE_t *const module, const uint32_t shadow_transfer_msk)
{
  XMC_ASSERT("XMC_CCU4_EnableShadowTransfer:Invalid Slice Pointer", XMC_CCU4_IsValidModule(module));
  module->GCSS = (uint32_t)shadow_transfer_msk;  
 8025f64:	6111      	str	r1, [r2, #16]
 8025f66:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

#ifdef TIMER_CCU4_USED
  if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
  {
    /* Returns the current status of the timer */
    status = XMC_CCU4_SLICE_IsTimerRunning(handle_ptr->ccu4_slice_ptr);
 8025f68:	6943      	ldr	r3, [r0, #20]
 *  XMC_CCU4_SLICE_StartTimer()<BR> XMC_CCU4_SLICE_StopTimer().
 */
__STATIC_INLINE bool XMC_CCU4_SLICE_IsTimerRunning(const XMC_CCU4_SLICE_t *const slice)
{
  XMC_ASSERT("XMC_CCU4_SLICE_GetTimerStatus:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  return (bool)(((slice->TCST) & CCU4_CC4_TCST_TRB_Msk) == CCU4_CC4_TCST_TRB_Msk);
 8025f6a:	689b      	ldr	r3, [r3, #8]

  XMC_ASSERT("TIMER_SetTimeInterval:handle_ptr NULL" , (handle_ptr != NULL));

  status = TIMER_STATUS_FAILURE;

  if (false == TIMER_GetTimerStatus(handle_ptr))
 8025f6c:	07db      	lsls	r3, r3, #31
 8025f6e:	d5b0      	bpl.n	8025ed2 <TIMER_SetTimeInterval+0xa>
  uint32_t lfrequency;
  uint32_t lprescaler;

  XMC_ASSERT("TIMER_SetTimeInterval:handle_ptr NULL" , (handle_ptr != NULL));

  status = TIMER_STATUS_FAILURE;
 8025f70:	2001      	movs	r0, #1
      }
#endif
    }
  }
  return (status);
}
 8025f72:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    /* check for time_interval range */
    if ((time_interval >= handle_ptr->timer_min_value_us) && (time_interval <= handle_ptr->timer_max_value_us))
    {
      /* Initialize the prescaler */
      lprescaler = 0U;
      while (time_interval > (handle_ptr->timer_max_value_us >> (TIMER_PRESCALER_MAX - lprescaler)))
 8025f74:	2400      	movs	r4, #0
      {
        lprescaler++;
      }
#ifdef TIMER_CCU4_USED
      if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
 8025f76:	2e00      	cmp	r6, #0
 8025f78:	d0bf      	beq.n	8025efa <TIMER_SetTimeInterval+0x32>
 8025f7a:	e7f9      	b.n	8025f70 <TIMER_SetTimeInterval+0xa8>
 8025f7c:	f3af 8000 	nop.w
 8025f80:	05f5e100 	.word	0x05f5e100
 8025f84:	00000000 	.word	0x00000000

08025f88 <TIMER_GetInterruptStatus>:
{
  bool status;
  XMC_ASSERT("TIMER_GetInterruptStatus:handle_ptr NULL" , (handle_ptr != NULL));
  status = false;
#ifdef TIMER_CCU4_USED
  if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
 8025f88:	f890 3021 	ldrb.w	r3, [r0, #33]	; 0x21
 8025f8c:	b92b      	cbnz	r3, 8025f9a <TIMER_GetInterruptStatus+0x12>
  {
    /* Reads the interrupt status */
    status = XMC_CCU4_SLICE_GetEvent(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_PERIOD_MATCH);
 8025f8e:	6943      	ldr	r3, [r0, #20]
__STATIC_INLINE bool XMC_CCU4_SLICE_GetEvent(const XMC_CCU4_SLICE_t *const slice, const XMC_CCU4_SLICE_IRQ_ID_t event)
{
  XMC_ASSERT("XMC_CCU4_SLICE_GetEvent:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_GetEvent:Invalid SR event", XMC_CCU4_SLICE_CHECK_INTERRUPT(event));

  return(((uint32_t)(slice->INTS & ((uint32_t)1 << (uint32_t)event))) != 0U);
 8025f90:	f8d3 00a0 	ldr.w	r0, [r3, #160]	; 0xa0
 8025f94:	f000 0001 	and.w	r0, r0, #1
 8025f98:	4770      	bx	lr
 */
bool TIMER_GetInterruptStatus(TIMER_t * const handle_ptr)
{
  bool status;
  XMC_ASSERT("TIMER_GetInterruptStatus:handle_ptr NULL" , (handle_ptr != NULL));
  status = false;
 8025f9a:	2000      	movs	r0, #0
    /* Reads the interrupt status */
    status = XMC_CCU8_SLICE_GetEvent(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_IRQ_ID_PERIOD_MATCH);
  }
#endif
  return (status);
}
 8025f9c:	4770      	bx	lr
 8025f9e:	bf00      	nop

08025fa0 <TIMER_ClearEvent>:
void TIMER_ClearEvent(TIMER_t *const handle_ptr)
{
  XMC_ASSERT("TIME_CCU_AcknowledgeInterrupt:handle_ptr NULL" , (handle_ptr != NULL));

#ifdef TIMER_CCU4_USED
  if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
 8025fa0:	f890 3021 	ldrb.w	r3, [r0, #33]	; 0x21
 8025fa4:	b933      	cbnz	r3, 8025fb4 <TIMER_ClearEvent+0x14>
  {
    /* clears the timer event(period match interrupt) */
    XMC_CCU4_SLICE_ClearEvent(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_PERIOD_MATCH);
 8025fa6:	6942      	ldr	r2, [r0, #20]
 */
__STATIC_INLINE void XMC_CCU4_SLICE_ClearEvent(XMC_CCU4_SLICE_t *const slice, const XMC_CCU4_SLICE_IRQ_ID_t event)
{
  XMC_ASSERT("XMC_CCU4_SLICE_ClearEvent:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_ClearEvent:Invalid SR event", XMC_CCU4_SLICE_CHECK_INTERRUPT(event));
  slice->SWR |= ((uint32_t) 1) << ((uint32_t) event);
 8025fa8:	f8d2 30b0 	ldr.w	r3, [r2, #176]	; 0xb0
 8025fac:	f043 0301 	orr.w	r3, r3, #1
 8025fb0:	f8c2 30b0 	str.w	r3, [r2, #176]	; 0xb0
 8025fb4:	4770      	bx	lr
 8025fb6:	bf00      	nop

08025fb8 <TIMER_Clear>:
  TIMER_STATUS_t status;

  XMC_ASSERT("TIMER_Clear:handle_ptr NULL" , (handle_ptr != NULL));

  /* Check for APP instance is initialized or not */
  if (true == handle_ptr->initialized)
 8025fb8:	f890 3026 	ldrb.w	r3, [r0, #38]	; 0x26
 8025fbc:	b14b      	cbz	r3, 8025fd2 <TIMER_Clear+0x1a>
  {
#ifdef TIMER_CCU4_USED
    if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
 8025fbe:	f890 3021 	ldrb.w	r3, [r0, #33]	; 0x21
 8025fc2:	b923      	cbnz	r3, 8025fce <TIMER_Clear+0x16>
    {
      /* Clear the timer register */
      XMC_CCU4_SLICE_ClearTimer(handle_ptr->ccu4_slice_ptr);
 8025fc4:	6942      	ldr	r2, [r0, #20]
 *  XMC_CCU4_SLICE_StartTimer().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_ClearTimer(XMC_CCU4_SLICE_t *const slice)
{
  XMC_ASSERT("XMC_CCU4_SLICE_ClearTimer:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->TCCLR = (uint32_t) CCU4_CC4_TCCLR_TCC_Msk;
 8025fc6:	2102      	movs	r1, #2
    {
      /* Clear the timer register */
      XMC_CCU8_SLICE_ClearTimer(handle_ptr->ccu8_slice_ptr);
    }
#endif
    status = TIMER_STATUS_SUCCESS;
 8025fc8:	4618      	mov	r0, r3
 8025fca:	6111      	str	r1, [r2, #16]
 8025fcc:	4770      	bx	lr
 8025fce:	2000      	movs	r0, #0
  {
    status = TIMER_STATUS_FAILURE;
  }

  return (status);
}
 8025fd0:	4770      	bx	lr
#endif
    status = TIMER_STATUS_SUCCESS;
  }
  else
  {
    status = TIMER_STATUS_FAILURE;
 8025fd2:	2001      	movs	r0, #1
 8025fd4:	4770      	bx	lr
 8025fd6:	bf00      	nop

08025fd8 <PWM_CCU8_Init>:
  return version;
}

/* This function initializes the app */
PWM_CCU8_STATUS_t PWM_CCU8_Init(PWM_CCU8_t* handle_ptr)
{
 8025fd8:	b5f0      	push	{r4, r5, r6, r7, lr}

  status = PWM_CCU8_STATUS_FAILURE;
  status_ccu8_global = GLOBAL_CCU8_STATUS_FAILURE;
  XMC_ASSERT("PWM_CCU8_Init:handle_ptr is NULL", (handle_ptr != NULL));

  if (PWM_CCU8_STATE_UNINITIALIZED == handle_ptr->state)
 8025fda:	7f05      	ldrb	r5, [r0, #28]
  return version;
}

/* This function initializes the app */
PWM_CCU8_STATUS_t PWM_CCU8_Init(PWM_CCU8_t* handle_ptr)
{
 8025fdc:	b083      	sub	sp, #12

  status = PWM_CCU8_STATUS_FAILURE;
  status_ccu8_global = GLOBAL_CCU8_STATUS_FAILURE;
  XMC_ASSERT("PWM_CCU8_Init:handle_ptr is NULL", (handle_ptr != NULL));

  if (PWM_CCU8_STATE_UNINITIALIZED == handle_ptr->state)
 8025fde:	b115      	cbz	r5, 8025fe6 <PWM_CCU8_Init+0xe>
    }

  }
  else
  {
    status = PWM_CCU8_STATUS_ALREADY_INITIALIZED;
 8025fe0:	2002      	movs	r0, #2
    XMC_DEBUG("PWM_CCU8_Init:PWM_CCU8_STATUS_ALREADY_INITIALIZED");
  }

  return (status);
} /* end of PWM_CCU8_Init() api */
 8025fe2:	b003      	add	sp, #12
 8025fe4:	bdf0      	pop	{r4, r5, r6, r7, pc}
  XMC_ASSERT("PWM_CCU8_Init:handle_ptr is NULL", (handle_ptr != NULL));

  if (PWM_CCU8_STATE_UNINITIALIZED == handle_ptr->state)
  {
    /* Initialize consumed Apps */
    status_ccu8_global = GLOBAL_CCU8_Init(handle_ptr->config_ptr->global_ccu8_handle);
 8025fe6:	6803      	ldr	r3, [r0, #0]
 8025fe8:	4604      	mov	r4, r0
 8025fea:	f8d3 008c 	ldr.w	r0, [r3, #140]	; 0x8c
 8025fee:	f000 fb2f 	bl	8026650 <GLOBAL_CCU8_Init>

    /* Initialize CCU8x_CC8y slice */
    if (GLOBAL_CCU8_STATUS_SUCCESS == status_ccu8_global)
 8025ff2:	4606      	mov	r6, r0
 8025ff4:	b118      	cbz	r0, 8025ffe <PWM_CCU8_Init+0x26>
  PWM_CCU8_STATUS_t status;
  GLOBAL_CCU8_STATUS_t status_ccu8_global;
  uint32_t frequency_module;
  uint32_t prescalar;

  status = PWM_CCU8_STATUS_FAILURE;
 8025ff6:	2001      	movs	r0, #1
      }

    }
    else
    {
      handle_ptr->state = PWM_CCU8_STATE_UNINITIALIZED;
 8025ff8:	7725      	strb	r5, [r4, #28]
    status = PWM_CCU8_STATUS_ALREADY_INITIALIZED;
    XMC_DEBUG("PWM_CCU8_Init:PWM_CCU8_STATUS_ALREADY_INITIALIZED");
  }

  return (status);
} /* end of PWM_CCU8_Init() api */
 8025ffa:	b003      	add	sp, #12
 8025ffc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (GLOBAL_CCU8_STATUS_SUCCESS == status_ccu8_global)
    {
      XMC_DEBUG("PWM_CCU8_Init:Initilizing slice");

      /* Configure CCU8x_CC8y slice as timer */
      XMC_CCU8_SLICE_CompareInit(handle_ptr->ccu8_slice_ptr, handle_ptr->config_ptr->ccu8_cc8_slice_timer_ptr);
 8025ffe:	6823      	ldr	r3, [r4, #0]
 8026000:	68a0      	ldr	r0, [r4, #8]
 8026002:	6c99      	ldr	r1, [r3, #72]	; 0x48
 8026004:	f7fb fb42 	bl	802168c <XMC_CCU8_SLICE_CompareInit>
      /* Set period match value of the timer  */
      XMC_CCU8_SLICE_SetTimerPeriodMatch(handle_ptr->ccu8_slice_ptr, handle_ptr->config_ptr->period_value);
 8026008:	6823      	ldr	r3, [r4, #0]
 802600a:	68a0      	ldr	r0, [r4, #8]
 802600c:	8859      	ldrh	r1, [r3, #2]
 802600e:	f7fb fc49 	bl	80218a4 <XMC_CCU8_SLICE_SetTimerPeriodMatch>

      /* Set timer compare match value for channel 1 */
      XMC_CCU8_SLICE_SetTimerCompareMatch(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_COMPARE_CHANNEL_1,
 8026012:	6823      	ldr	r3, [r4, #0]
 8026014:	68a0      	ldr	r0, [r4, #8]
 8026016:	889a      	ldrh	r2, [r3, #4]
 8026018:	4631      	mov	r1, r6
 802601a:	f7fb fc45 	bl	80218a8 <XMC_CCU8_SLICE_SetTimerCompareMatch>
                                          (uint16_t) handle_ptr->config_ptr->compare1_value);
      /* Set timer compare match value for channel 2 */
      XMC_CCU8_SLICE_SetTimerCompareMatch(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_COMPARE_CHANNEL_2,
 802601e:	6823      	ldr	r3, [r4, #0]
 8026020:	68a0      	ldr	r0, [r4, #8]
 8026022:	88da      	ldrh	r2, [r3, #6]
 8026024:	2101      	movs	r1, #1
 8026026:	f7fb fc3f 	bl	80218a8 <XMC_CCU8_SLICE_SetTimerCompareMatch>
                                          (uint16_t) handle_ptr->config_ptr->compare2_value);

      if ((1U == handle_ptr->config_ptr->ccu8_cc8_slice_timer_ptr->mcm_ch1_enable) || (1U
 802602a:	6822      	ldr	r2, [r4, #0]
 802602c:	6c93      	ldr	r3, [r2, #72]	; 0x48
 802602e:	78db      	ldrb	r3, [r3, #3]
 8026030:	f013 0f06 	tst.w	r3, #6
 8026034:	f040 8166 	bne.w	8026304 <PWM_CCU8_Init+0x32c>
        XMC_CCU8_SetMultiChannelShadowTransferMode(handle_ptr->ccu8_module_ptr,
                                                   (uint32_t) handle_ptr->config_ptr->mcm_shadow_txfr_mode);
      }

#if (UC_SERIES != XMC45) /*STC register not available on XMC45xx devices */
      XMC_CCU8_SLICE_SetShadowTransferMode(handle_ptr->ccu8_slice_ptr, handle_ptr->config_ptr->shadow_transfer_mode);
 8026038:	68a0      	ldr	r0, [r4, #8]
__STATIC_INLINE void XMC_CCU8_SLICE_SetShadowTransferMode(XMC_CCU8_SLICE_t *const slice,
                                                          const XMC_CCU8_SLICE_SHADOW_TRANSFER_MODE_t shadow_transfer_mode)
{
  XMC_ASSERT("XMC_CCU8_SLICE_SetShadowTransferMode:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  slice->STC = ((slice->STC) & ~(uint32_t)((uint32_t)CCU8_CC8_STC_STM_Msk << (uint32_t)CCU8_CC8_STC_STM_Pos)) |
               ((shadow_transfer_mode << CCU8_CC8_STC_STM_Pos) & (uint32_t)CCU8_CC8_STC_STM_Msk);
 802603a:	f892 5044 	ldrb.w	r5, [r2, #68]	; 0x44
 */
__STATIC_INLINE void XMC_CCU8_SLICE_SetShadowTransferMode(XMC_CCU8_SLICE_t *const slice,
                                                          const XMC_CCU8_SLICE_SHADOW_TRANSFER_MODE_t shadow_transfer_mode)
{
  XMC_ASSERT("XMC_CCU8_SLICE_SetShadowTransferMode:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  slice->STC = ((slice->STC) & ~(uint32_t)((uint32_t)CCU8_CC8_STC_STM_Msk << (uint32_t)CCU8_CC8_STC_STM_Pos)) |
 802603e:	f8d0 30b4 	ldr.w	r3, [r0, #180]	; 0xb4

      /* Transfer value from shadow timer registers to actual timer registers */
      XMC_CCU8_EnableShadowTransfer(handle_ptr->ccu8_module_ptr, handle_ptr->shadow_txfr_msk);
      XMC_CCU8_EnableShadowTransfer(handle_ptr->ccu8_module_ptr, handle_ptr->dither_shadow_txfr_msk);

      XMC_CCU8_SLICE_DeadTimeInit(handle_ptr->ccu8_slice_ptr, handle_ptr->config_ptr->dt_config_ptr);
 8026042:	6c11      	ldr	r1, [r2, #64]	; 0x40
        XMC_CCU8_SLICE_EnableCascadedShadowTransfer(handle_ptr->ccu8_slice_ptr);
      }
#endif

      /* Transfer value from shadow timer registers to actual timer registers */
      XMC_CCU8_EnableShadowTransfer(handle_ptr->ccu8_module_ptr, handle_ptr->shadow_txfr_msk);
 8026044:	6866      	ldr	r6, [r4, #4]
 8026046:	f8d4 e010 	ldr.w	lr, [r4, #16]
      XMC_CCU8_EnableShadowTransfer(handle_ptr->ccu8_module_ptr, handle_ptr->dither_shadow_txfr_msk);
 802604a:	6967      	ldr	r7, [r4, #20]
               ((shadow_transfer_mode << CCU8_CC8_STC_STM_Pos) & (uint32_t)CCU8_CC8_STC_STM_Msk);
 802604c:	006d      	lsls	r5, r5, #1
 */
__STATIC_INLINE void XMC_CCU8_SLICE_SetShadowTransferMode(XMC_CCU8_SLICE_t *const slice,
                                                          const XMC_CCU8_SLICE_SHADOW_TRANSFER_MODE_t shadow_transfer_mode)
{
  XMC_ASSERT("XMC_CCU8_SLICE_SetShadowTransferMode:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  slice->STC = ((slice->STC) & ~(uint32_t)((uint32_t)CCU8_CC8_STC_STM_Msk << (uint32_t)CCU8_CC8_STC_STM_Pos)) |
 802604e:	f023 020c 	bic.w	r2, r3, #12
               ((shadow_transfer_mode << CCU8_CC8_STC_STM_Pos) & (uint32_t)CCU8_CC8_STC_STM_Msk);
 8026052:	f005 0306 	and.w	r3, r5, #6
 */
__STATIC_INLINE void XMC_CCU8_SLICE_SetShadowTransferMode(XMC_CCU8_SLICE_t *const slice,
                                                          const XMC_CCU8_SLICE_SHADOW_TRANSFER_MODE_t shadow_transfer_mode)
{
  XMC_ASSERT("XMC_CCU8_SLICE_SetShadowTransferMode:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  slice->STC = ((slice->STC) & ~(uint32_t)((uint32_t)CCU8_CC8_STC_STM_Msk << (uint32_t)CCU8_CC8_STC_STM_Pos)) |
 8026056:	4313      	orrs	r3, r2
 8026058:	f8c0 30b4 	str.w	r3, [r0, #180]	; 0xb4
 *  None.
 */
__STATIC_INLINE void XMC_CCU8_EnableShadowTransfer(XMC_CCU8_MODULE_t *const module, const uint32_t shadow_transfer_msk)
{
  XMC_ASSERT("XMC_CCU8_EnableShadowTransfer:Invalid module Pointer", XMC_CCU8_IsValidModule(module));
  module->GCSS = (uint32_t)shadow_transfer_msk;  
 802605c:	f8c6 e010 	str.w	lr, [r6, #16]
 8026060:	6137      	str	r7, [r6, #16]

      XMC_CCU8_SLICE_DeadTimeInit(handle_ptr->ccu8_slice_ptr, handle_ptr->config_ptr->dt_config_ptr);
 8026062:	f7fb fc43 	bl	80218ec <XMC_CCU8_SLICE_DeadTimeInit>
}

static void PWM_CCU8_lConfigure_Events(PWM_CCU8_t* handle_ptr)
{
  /* Configure slice to a external event 0 */
  XMC_CCU8_SLICE_ConfigureEvent(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_EVENT_0,
 8026066:	6823      	ldr	r3, [r4, #0]
 8026068:	68a0      	ldr	r0, [r4, #8]
 802606a:	69da      	ldr	r2, [r3, #28]
 802606c:	2101      	movs	r1, #1
 802606e:	f7fb fbdd 	bl	802182c <XMC_CCU8_SLICE_ConfigureEvent>
                                handle_ptr->config_ptr->event0_config_ptr);

  /* Configure slice to a external event 1 */
  XMC_CCU8_SLICE_ConfigureEvent(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_EVENT_1,
 8026072:	6823      	ldr	r3, [r4, #0]
 8026074:	68a0      	ldr	r0, [r4, #8]
 8026076:	6a1a      	ldr	r2, [r3, #32]
 8026078:	2102      	movs	r1, #2
 802607a:	f7fb fbd7 	bl	802182c <XMC_CCU8_SLICE_ConfigureEvent>
                                handle_ptr->config_ptr->event1_config_ptr);

  /* Configure slice to a external event 2 */
  XMC_CCU8_SLICE_ConfigureEvent(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_EVENT_2,
 802607e:	6823      	ldr	r3, [r4, #0]
 8026080:	68a0      	ldr	r0, [r4, #8]
 8026082:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8026084:	2103      	movs	r1, #3
 8026086:	f7fb fbd1 	bl	802182c <XMC_CCU8_SLICE_ConfigureEvent>
                                handle_ptr->config_ptr->event2_config_ptr);

  /* External signal controls start of the timer */
  if (XMC_CCU8_SLICE_EVENT_NONE != handle_ptr->config_ptr->ext_start_event)
 802608a:	6823      	ldr	r3, [r4, #0]
 802608c:	f893 1028 	ldrb.w	r1, [r3, #40]	; 0x28
 8026090:	2900      	cmp	r1, #0
 8026092:	f040 8130 	bne.w	80262f6 <PWM_CCU8_Init+0x31e>
    XMC_CCU8_SLICE_StartConfig(handle_ptr->ccu8_slice_ptr, handle_ptr->config_ptr->ext_start_event,
                               handle_ptr->config_ptr->ext_start_mode);
  }

  /* External signal can stop the timer */
  if (XMC_CCU8_SLICE_EVENT_NONE != handle_ptr->config_ptr->ext_stop_event)
 8026096:	f893 102a 	ldrb.w	r1, [r3, #42]	; 0x2a
 802609a:	2900      	cmp	r1, #0
 802609c:	f040 8124 	bne.w	80262e8 <PWM_CCU8_Init+0x310>
    XMC_CCU8_SLICE_StopConfig(handle_ptr->ccu8_slice_ptr, handle_ptr->config_ptr->ext_stop_event,
                              handle_ptr->config_ptr->ext_stop_mode);
  }

  /* External signal can change the timer counting direction */
  if (XMC_CCU8_SLICE_EVENT_NONE != handle_ptr->config_ptr->ext_count_dir_event)
 80260a0:	f893 102c 	ldrb.w	r1, [r3, #44]	; 0x2c
 80260a4:	2900      	cmp	r1, #0
 80260a6:	f040 811a 	bne.w	80262de <PWM_CCU8_Init+0x306>
  {
    XMC_CCU8_SLICE_DirectionConfig(handle_ptr->ccu8_slice_ptr, handle_ptr->config_ptr->ext_count_dir_event);
  }
  /* External signal can stop the timer and the timer value remains same */
  if (XMC_CCU8_SLICE_EVENT_NONE != handle_ptr->config_ptr->ext_gate_event)
 80260aa:	f893 102d 	ldrb.w	r1, [r3, #45]	; 0x2d
 80260ae:	2900      	cmp	r1, #0
 80260b0:	f040 8110 	bne.w	80262d4 <PWM_CCU8_Init+0x2fc>
  {
    XMC_CCU8_SLICE_GateConfig(handle_ptr->ccu8_slice_ptr, handle_ptr->config_ptr->ext_gate_event);
  }
  /* Timer increments on external signal */
  if (XMC_CCU8_SLICE_EVENT_NONE != handle_ptr->config_ptr->ext_count_event)
 80260b4:	f893 102e 	ldrb.w	r1, [r3, #46]	; 0x2e
 80260b8:	2900      	cmp	r1, #0
 80260ba:	f040 8106 	bne.w	80262ca <PWM_CCU8_Init+0x2f2>
  {
    XMC_CCU8_SLICE_CountConfig(handle_ptr->ccu8_slice_ptr, handle_ptr->config_ptr->ext_count_event);
  }
  /* Timer gets loaded with compare register value or period register value on external signal */
  if (XMC_CCU8_SLICE_EVENT_NONE != handle_ptr->config_ptr->ext_load_event)
 80260be:	f893 102f 	ldrb.w	r1, [r3, #47]	; 0x2f
 80260c2:	2900      	cmp	r1, #0
 80260c4:	f040 80f6 	bne.w	80262b4 <PWM_CCU8_Init+0x2dc>
  {
    XMC_CCU8_SLICE_LoadConfig(handle_ptr->ccu8_slice_ptr, handle_ptr->config_ptr->ext_load_event);
    XMC_CCU8_SLICE_LoadSelector(handle_ptr->ccu8_slice_ptr, handle_ptr->config_ptr->ext_load_selector);
  }
  /* External signal PWM signal (ST bit) output gets modulated by external signal */
  if (XMC_CCU8_SLICE_EVENT_NONE != handle_ptr->config_ptr->ext_mod_event)
 80260c8:	f893 1031 	ldrb.w	r1, [r3, #49]	; 0x31
 80260cc:	2900      	cmp	r1, #0
 80260ce:	f040 80e6 	bne.w	802629e <PWM_CCU8_Init+0x2c6>
                                    handle_ptr->config_ptr->ext_mod_mode, XMC_CCU8_SLICE_MODULATION_CHANNEL_1_AND_2,
                                    handle_ptr->config_ptr->ext_mod_sync);
  }

  /* PWM signal (ST bit) output gets modulated by external signal */
  if (XMC_CCU8_SLICE_EVENT_2 == handle_ptr->config_ptr->ext_trap_event)
 80260d2:	f893 2037 	ldrb.w	r2, [r3, #55]	; 0x37
  {
    XMC_CCU8_SLICE_TrapConfig(handle_ptr->ccu8_slice_ptr, handle_ptr->config_ptr->ext_trap_exit,
 80260d6:	68a0      	ldr	r0, [r4, #8]
                                    handle_ptr->config_ptr->ext_mod_mode, XMC_CCU8_SLICE_MODULATION_CHANNEL_1_AND_2,
                                    handle_ptr->config_ptr->ext_mod_sync);
  }

  /* PWM signal (ST bit) output gets modulated by external signal */
  if (XMC_CCU8_SLICE_EVENT_2 == handle_ptr->config_ptr->ext_trap_event)
 80260d8:	2a03      	cmp	r2, #3
 80260da:	f000 8119 	beq.w	8026310 <PWM_CCU8_Init+0x338>
          (uint32_t)(XMC_CCU8_SLICE_OUTPUT_0 | XMC_CCU8_SLICE_OUTPUT_1 | XMC_CCU8_SLICE_OUTPUT_2 | XMC_CCU8_SLICE_OUTPUT_3)
		  );
    }
  }

  if ((XMC_CCU8_SLICE_EVENT_NONE != handle_ptr->config_ptr->ext_override_edge_event) || (XMC_CCU8_SLICE_EVENT_NONE
 80260de:	8e9a      	ldrh	r2, [r3, #52]	; 0x34
 80260e0:	b142      	cbz	r2, 80260f4 <PWM_CCU8_Init+0x11c>
      != handle_ptr->config_ptr->ext_override_level_event))
  {
    XMC_CCU8_SLICE_ConfigureStatusBitOverrideEvent(handle_ptr->ccu8_slice_ptr,
 80260e2:	6a19      	ldr	r1, [r3, #32]
 80260e4:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80260e6:	f7fb fb73 	bl	80217d0 <XMC_CCU8_SLICE_ConfigureStatusBitOverrideEvent>
                                                   handle_ptr->config_ptr->event1_config_ptr,
                                                   handle_ptr->config_ptr->event2_config_ptr);
    XMC_CCU8_SLICE_StatusBitOverrideConfig(handle_ptr->ccu8_slice_ptr);
 80260ea:	68a0      	ldr	r0, [r4, #8]
 80260ec:	f7fb fb56 	bl	802179c <XMC_CCU8_SLICE_StatusBitOverrideConfig>
 80260f0:	6823      	ldr	r3, [r4, #0]
 80260f2:	68a0      	ldr	r0, [r4, #8]
static void PWM_CCU8_lInit_Interrupt(PWM_CCU8_t* handle_ptr)
{

  /* Enable events. Bind event to corresponding service request node. */

  XMC_CCU8_SLICE_SetInterruptNode(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_IRQ_ID_PERIOD_MATCH,
 80260f4:	7c5a      	ldrb	r2, [r3, #17]
 80260f6:	2100      	movs	r1, #0
 80260f8:	f7fb fbdc 	bl	80218b4 <XMC_CCU8_SLICE_SetInterruptNode>
                                  handle_ptr->config_ptr->sr_per_match);
  XMC_CCU8_SLICE_SetInterruptNode(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_IRQ_ID_COMPARE_MATCH_UP_CH_1,
 80260fc:	6823      	ldr	r3, [r4, #0]
 80260fe:	68a0      	ldr	r0, [r4, #8]
 8026100:	7c9a      	ldrb	r2, [r3, #18]
 8026102:	2102      	movs	r1, #2
 8026104:	f7fb fbd6 	bl	80218b4 <XMC_CCU8_SLICE_SetInterruptNode>
                                  handle_ptr->config_ptr->sr_cmp1_match_up);
  XMC_CCU8_SLICE_SetInterruptNode(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_IRQ_ID_COMPARE_MATCH_DOWN_CH_1,
 8026108:	6823      	ldr	r3, [r4, #0]
 802610a:	68a0      	ldr	r0, [r4, #8]
 802610c:	7cda      	ldrb	r2, [r3, #19]
 802610e:	2103      	movs	r1, #3
 8026110:	f7fb fbd0 	bl	80218b4 <XMC_CCU8_SLICE_SetInterruptNode>
                                  handle_ptr->config_ptr->sr_cmp1_match_down);
  XMC_CCU8_SLICE_SetInterruptNode(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_IRQ_ID_COMPARE_MATCH_UP_CH_2,
 8026114:	6823      	ldr	r3, [r4, #0]
 8026116:	68a0      	ldr	r0, [r4, #8]
 8026118:	7d1a      	ldrb	r2, [r3, #20]
 802611a:	2104      	movs	r1, #4
 802611c:	f7fb fbca 	bl	80218b4 <XMC_CCU8_SLICE_SetInterruptNode>
                                  handle_ptr->config_ptr->sr_cmp2_match_up);
  XMC_CCU8_SLICE_SetInterruptNode(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_IRQ_ID_COMPARE_MATCH_DOWN_CH_2,
 8026120:	6823      	ldr	r3, [r4, #0]
 8026122:	68a0      	ldr	r0, [r4, #8]
 8026124:	7d5a      	ldrb	r2, [r3, #21]
 8026126:	2105      	movs	r1, #5
 8026128:	f7fb fbc4 	bl	80218b4 <XMC_CCU8_SLICE_SetInterruptNode>
                                  handle_ptr->config_ptr->sr_cmp2_match_down);
  XMC_CCU8_SLICE_SetInterruptNode(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_IRQ_ID_ONE_MATCH,
 802612c:	6823      	ldr	r3, [r4, #0]
 802612e:	68a0      	ldr	r0, [r4, #8]
 8026130:	7d9a      	ldrb	r2, [r3, #22]
 8026132:	2101      	movs	r1, #1
 8026134:	f7fb fbbe 	bl	80218b4 <XMC_CCU8_SLICE_SetInterruptNode>
                                  handle_ptr->config_ptr->sr_one_match_down);
  XMC_CCU8_SLICE_SetInterruptNode(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_IRQ_ID_EVENT0,
 8026138:	6823      	ldr	r3, [r4, #0]
 802613a:	68a0      	ldr	r0, [r4, #8]
 802613c:	7dda      	ldrb	r2, [r3, #23]
 802613e:	2108      	movs	r1, #8
 8026140:	f7fb fbb8 	bl	80218b4 <XMC_CCU8_SLICE_SetInterruptNode>
                                  handle_ptr->config_ptr->sr_e0);
  XMC_CCU8_SLICE_SetInterruptNode(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_IRQ_ID_EVENT1,
 8026144:	6823      	ldr	r3, [r4, #0]
 8026146:	68a0      	ldr	r0, [r4, #8]
 8026148:	7e1a      	ldrb	r2, [r3, #24]
 802614a:	2109      	movs	r1, #9
 802614c:	f7fb fbb2 	bl	80218b4 <XMC_CCU8_SLICE_SetInterruptNode>
                                  handle_ptr->config_ptr->sr_e1);
  XMC_CCU8_SLICE_SetInterruptNode(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_IRQ_ID_EVENT2,
 8026150:	6823      	ldr	r3, [r4, #0]
 8026152:	68a0      	ldr	r0, [r4, #8]
 8026154:	7e5a      	ldrb	r2, [r3, #25]
 8026156:	210a      	movs	r1, #10
 8026158:	f7fb fbac 	bl	80218b4 <XMC_CCU8_SLICE_SetInterruptNode>
                                  handle_ptr->config_ptr->sr_e2);

  if ((bool) true == handle_ptr->config_ptr->int_per_match)
 802615c:	6823      	ldr	r3, [r4, #0]
 802615e:	7a1a      	ldrb	r2, [r3, #8]
 8026160:	b132      	cbz	r2, 8026170 <PWM_CCU8_Init+0x198>
  {
    XMC_DEBUG("PWM_CCU8_Init: Interrupt period match enable");
    XMC_CCU8_SLICE_EnableEvent(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_IRQ_ID_PERIOD_MATCH);
 8026162:	68a1      	ldr	r1, [r4, #8]
__STATIC_INLINE void XMC_CCU8_SLICE_EnableEvent(XMC_CCU8_SLICE_t *const slice, const XMC_CCU8_SLICE_IRQ_ID_t event)
{
  XMC_ASSERT("XMC_CCU8_SLICE_EnableEvent:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU8_SLICE_EnableEvent:Invalid SR event", XMC_CCU8_SLICE_CHECK_INTERRUPT(event));

  slice->INTE |= ((uint32_t) 1) << ((uint32_t) event);
 8026164:	f8d1 20a4 	ldr.w	r2, [r1, #164]	; 0xa4
 8026168:	f042 0201 	orr.w	r2, r2, #1
 802616c:	f8c1 20a4 	str.w	r2, [r1, #164]	; 0xa4
  }

  if ((bool) true == handle_ptr->config_ptr->int_cmp1_match_up)
 8026170:	7a5a      	ldrb	r2, [r3, #9]
 8026172:	b132      	cbz	r2, 8026182 <PWM_CCU8_Init+0x1aa>
  {
    XMC_DEBUG("PWM_CCU8_Init: Interrupt compare match ch1 up enable");
    XMC_CCU8_SLICE_EnableEvent(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_IRQ_ID_COMPARE_MATCH_UP_CH_1);
 8026174:	68a1      	ldr	r1, [r4, #8]
 8026176:	f8d1 20a4 	ldr.w	r2, [r1, #164]	; 0xa4
 802617a:	f042 0204 	orr.w	r2, r2, #4
 802617e:	f8c1 20a4 	str.w	r2, [r1, #164]	; 0xa4
  }

  if ((bool) true == handle_ptr->config_ptr->int_cmp1_match_down)
 8026182:	7a9a      	ldrb	r2, [r3, #10]
 8026184:	b132      	cbz	r2, 8026194 <PWM_CCU8_Init+0x1bc>
  {
    XMC_DEBUG("PWM_CCU8_Init: Interrupt compare match ch1 down enable");
    XMC_CCU8_SLICE_EnableEvent(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_IRQ_ID_COMPARE_MATCH_DOWN_CH_1);
 8026186:	68a1      	ldr	r1, [r4, #8]
 8026188:	f8d1 20a4 	ldr.w	r2, [r1, #164]	; 0xa4
 802618c:	f042 0208 	orr.w	r2, r2, #8
 8026190:	f8c1 20a4 	str.w	r2, [r1, #164]	; 0xa4
  }

  if ((bool) true == handle_ptr->config_ptr->int_cmp2_match_up)
 8026194:	7ada      	ldrb	r2, [r3, #11]
 8026196:	b132      	cbz	r2, 80261a6 <PWM_CCU8_Init+0x1ce>
  {
    XMC_DEBUG("PWM_CCU8_Init: Interrupt compare match ch2 up enable");
    XMC_CCU8_SLICE_EnableEvent(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_IRQ_ID_COMPARE_MATCH_UP_CH_2);
 8026198:	68a1      	ldr	r1, [r4, #8]
 802619a:	f8d1 20a4 	ldr.w	r2, [r1, #164]	; 0xa4
 802619e:	f042 0210 	orr.w	r2, r2, #16
 80261a2:	f8c1 20a4 	str.w	r2, [r1, #164]	; 0xa4
  }

  if ((bool) true == handle_ptr->config_ptr->int_cmp2_match_down)
 80261a6:	7b1a      	ldrb	r2, [r3, #12]
 80261a8:	b132      	cbz	r2, 80261b8 <PWM_CCU8_Init+0x1e0>
  {
    XMC_DEBUG("PWM_CCU8_Init: Interrupt compare match ch2 down enable");
    XMC_CCU8_SLICE_EnableEvent(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_IRQ_ID_COMPARE_MATCH_DOWN_CH_2);
 80261aa:	68a1      	ldr	r1, [r4, #8]
 80261ac:	f8d1 20a4 	ldr.w	r2, [r1, #164]	; 0xa4
 80261b0:	f042 0220 	orr.w	r2, r2, #32
 80261b4:	f8c1 20a4 	str.w	r2, [r1, #164]	; 0xa4
  }

  if ((bool) true == handle_ptr->config_ptr->int_one_match_down)
 80261b8:	7b5a      	ldrb	r2, [r3, #13]
 80261ba:	b132      	cbz	r2, 80261ca <PWM_CCU8_Init+0x1f2>
  {
    XMC_DEBUG("PWM_CCU8_Init: Interrupt one match enable");
    XMC_CCU8_SLICE_EnableEvent(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_IRQ_ID_ONE_MATCH);
 80261bc:	68a1      	ldr	r1, [r4, #8]
 80261be:	f8d1 20a4 	ldr.w	r2, [r1, #164]	; 0xa4
 80261c2:	f042 0202 	orr.w	r2, r2, #2
 80261c6:	f8c1 20a4 	str.w	r2, [r1, #164]	; 0xa4
  }

  if ((bool) true == handle_ptr->config_ptr->int_e0)
 80261ca:	7b9a      	ldrb	r2, [r3, #14]
 80261cc:	b132      	cbz	r2, 80261dc <PWM_CCU8_Init+0x204>
  {
    XMC_DEBUG("PWM_CCU8_Init: Interrupt event 0 enable");
    XMC_CCU8_SLICE_EnableEvent(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_IRQ_ID_EVENT0);
 80261ce:	68a1      	ldr	r1, [r4, #8]
 80261d0:	f8d1 20a4 	ldr.w	r2, [r1, #164]	; 0xa4
 80261d4:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 80261d8:	f8c1 20a4 	str.w	r2, [r1, #164]	; 0xa4
  }

  if ((bool) true == handle_ptr->config_ptr->int_e1)
 80261dc:	7bda      	ldrb	r2, [r3, #15]
 80261de:	b132      	cbz	r2, 80261ee <PWM_CCU8_Init+0x216>
  {
    XMC_DEBUG("PWM_CCU8_Init: Interrupt event 1 enable");
    XMC_CCU8_SLICE_EnableEvent(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_IRQ_ID_EVENT1);
 80261e0:	68a1      	ldr	r1, [r4, #8]
 80261e2:	f8d1 20a4 	ldr.w	r2, [r1, #164]	; 0xa4
 80261e6:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 80261ea:	f8c1 20a4 	str.w	r2, [r1, #164]	; 0xa4
  }

  if ((bool) true == handle_ptr->config_ptr->int_e2)
 80261ee:	7c1a      	ldrb	r2, [r3, #16]
 80261f0:	b132      	cbz	r2, 8026200 <PWM_CCU8_Init+0x228>
  {
    XMC_DEBUG("PWM_CCU8_Init: Interrupt event 2 enable");
    XMC_CCU8_SLICE_EnableEvent(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_IRQ_ID_EVENT2);
 80261f2:	68a1      	ldr	r1, [r4, #8]
 80261f4:	f8d1 20a4 	ldr.w	r2, [r1, #164]	; 0xa4
 80261f8:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 80261fc:	f8c1 20a4 	str.w	r2, [r1, #164]	; 0xa4
  }
}
static void PWM_CCU8_lInit_GPIO(PWM_CCU8_t* handle_ptr)
{
  if ((bool) true == handle_ptr->config_ptr->gpio_ch1_out0_enable)
 8026200:	f893 204c 	ldrb.w	r2, [r3, #76]	; 0x4c
 8026204:	2a00      	cmp	r2, #0
 8026206:	d142      	bne.n	802628e <PWM_CCU8_Init+0x2b6>
 8026208:	461d      	mov	r5, r3
  {
    XMC_GPIO_Init(handle_ptr->config_ptr->gpio_ch1_out0_ptr, handle_ptr->config_ptr->gpio_ch1_out0_pin,
                  handle_ptr->config_ptr->gpio_ch1_out0_config_ptr);
  }

  if ((bool) true == handle_ptr->config_ptr->gpio_ch1_out1_enable)
 802620a:	f895 305c 	ldrb.w	r3, [r5, #92]	; 0x5c
 802620e:	2b00      	cmp	r3, #0
 8026210:	d135      	bne.n	802627e <PWM_CCU8_Init+0x2a6>
  {
    XMC_GPIO_Init(handle_ptr->config_ptr->gpio_ch1_out1_ptr, handle_ptr->config_ptr->gpio_ch1_out1_pin,
                  handle_ptr->config_ptr->gpio_ch1_out1_config_ptr);
  }

  if ((bool) true == handle_ptr->config_ptr->gpio_ch2_out2_enable)
 8026212:	f895 306c 	ldrb.w	r3, [r5, #108]	; 0x6c
 8026216:	bb53      	cbnz	r3, 802626e <PWM_CCU8_Init+0x296>
  {
    XMC_GPIO_Init(handle_ptr->config_ptr->gpio_ch2_out2_ptr, handle_ptr->config_ptr->gpio_ch2_out2_pin,
                  handle_ptr->config_ptr->gpio_ch2_out2_config_ptr);
  }

  if ((bool) true == handle_ptr->config_ptr->gpio_ch2_out3_enable)
 8026218:	f895 307c 	ldrb.w	r3, [r5, #124]	; 0x7c
 802621c:	b143      	cbz	r3, 8026230 <PWM_CCU8_Init+0x258>
  {
    XMC_GPIO_Init(handle_ptr->config_ptr->gpio_ch2_out3_ptr, handle_ptr->config_ptr->gpio_ch2_out3_pin,
 802621e:	f8d5 0080 	ldr.w	r0, [r5, #128]	; 0x80
 8026222:	f895 1084 	ldrb.w	r1, [r5, #132]	; 0x84
 8026226:	f8d5 2088 	ldr.w	r2, [r5, #136]	; 0x88
 802622a:	f7fa fe89 	bl	8020f40 <XMC_GPIO_Init>
 802622e:	6825      	ldr	r5, [r4, #0]

      /*Initializes the GPIO*/
      PWM_CCU8_lInit_GPIO(handle_ptr);

      frequency_module = handle_ptr->config_ptr->global_ccu8_handle->module_frequency;
      prescalar = (uint32_t) handle_ptr->config_ptr->ccu8_cc8_slice_timer_ptr->prescaler_initval;
 8026230:	6caa      	ldr	r2, [r5, #72]	; 0x48
      PWM_CCU8_lInit_Interrupt(handle_ptr);

      /*Initializes the GPIO*/
      PWM_CCU8_lInit_GPIO(handle_ptr);

      frequency_module = handle_ptr->config_ptr->global_ccu8_handle->module_frequency;
 8026232:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
      prescalar = (uint32_t) handle_ptr->config_ptr->ccu8_cc8_slice_timer_ptr->prescaler_initval;
 8026236:	7b12      	ldrb	r2, [r2, #12]
      PWM_CCU8_lInit_Interrupt(handle_ptr);

      /*Initializes the GPIO*/
      PWM_CCU8_lInit_GPIO(handle_ptr);

      frequency_module = handle_ptr->config_ptr->global_ccu8_handle->module_frequency;
 8026238:	681b      	ldr	r3, [r3, #0]

      handle_ptr->state = PWM_CCU8_STATE_INITIALIZED;
      status = PWM_CCU8_STATUS_SUCCESS;

      /* Start the PWM generation if start at initialization is enabled */
      if ((bool) true == handle_ptr->config_ptr->start_control)
 802623a:	7828      	ldrb	r0, [r5, #0]
      /*Initializes the GPIO*/
      PWM_CCU8_lInit_GPIO(handle_ptr);

      frequency_module = handle_ptr->config_ptr->global_ccu8_handle->module_frequency;
      prescalar = (uint32_t) handle_ptr->config_ptr->ccu8_cc8_slice_timer_ptr->prescaler_initval;
      frequency_module = frequency_module / ((uint32_t) 1 << prescalar);
 802623c:	f002 020f 	and.w	r2, r2, #15
 8026240:	40d3      	lsrs	r3, r2
      handle_ptr->frequency_tclk = frequency_module;

      handle_ptr->state = PWM_CCU8_STATE_INITIALIZED;
 8026242:	2201      	movs	r2, #1
      PWM_CCU8_lInit_GPIO(handle_ptr);

      frequency_module = handle_ptr->config_ptr->global_ccu8_handle->module_frequency;
      prescalar = (uint32_t) handle_ptr->config_ptr->ccu8_cc8_slice_timer_ptr->prescaler_initval;
      frequency_module = frequency_module / ((uint32_t) 1 << prescalar);
      handle_ptr->frequency_tclk = frequency_module;
 8026244:	6223      	str	r3, [r4, #32]

      handle_ptr->state = PWM_CCU8_STATE_INITIALIZED;
 8026246:	7722      	strb	r2, [r4, #28]
      status = PWM_CCU8_STATUS_SUCCESS;

      /* Start the PWM generation if start at initialization is enabled */
      if ((bool) true == handle_ptr->config_ptr->start_control)
 8026248:	2800      	cmp	r0, #0
 802624a:	f43f aeca 	beq.w	8025fe2 <PWM_CCU8_Init+0xa>
  status = PWM_CCU8_STATUS_FAILURE;
  XMC_ASSERT("PWM_CCU8_Start:handle_ptr NULL", (handle_ptr != NULL));
  if ((PWM_CCU8_STATE_INITIALIZED == handle_ptr->state) || (PWM_CCU8_STATE_STOPPED == handle_ptr->state))
  {
    /* clear IDLE mode for the slice; Start timer */
    XMC_CCU8_EnableClock(handle_ptr->ccu8_module_ptr, handle_ptr->slice_number);
 802624e:	6861      	ldr	r1, [r4, #4]
__STATIC_INLINE void XMC_CCU8_EnableClock(XMC_CCU8_MODULE_t *const module, const uint8_t slice_number)
{
  XMC_ASSERT("XMC_CCU8_EnableClock:Invalid Module Pointer", XMC_CCU8_IsValidModule(module));
  XMC_ASSERT("XMC_CCU8_EnableClock:Invalid Slice Number", (slice_number < 4U));

  module->GIDLC |= ((uint32_t) 1 << slice_number);
 8026250:	7b66      	ldrb	r6, [r4, #13]
 8026252:	68cb      	ldr	r3, [r1, #12]

    if (XMC_CCU8_SLICE_EVENT_NONE == handle_ptr->config_ptr->ext_start_event)
 8026254:	f895 0028 	ldrb.w	r0, [r5, #40]	; 0x28
 8026258:	fa02 f506 	lsl.w	r5, r2, r6
 802625c:	432b      	orrs	r3, r5
 802625e:	60cb      	str	r3, [r1, #12]
 8026260:	b908      	cbnz	r0, 8026266 <PWM_CCU8_Init+0x28e>
    {
      XMC_CCU8_SLICE_StartTimer(handle_ptr->ccu8_slice_ptr);
 8026262:	68a3      	ldr	r3, [r4, #8]
 *  XMC_CCU8_SLICE_StopTimer().
 */
__STATIC_INLINE void XMC_CCU8_SLICE_StartTimer(XMC_CCU8_SLICE_t *const slice)
{
  XMC_ASSERT("XMC_CCU8_SLICE_StartTimer:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  slice->TCSET = CCU8_CC8_TCSET_TRBS_Msk;
 8026264:	60da      	str	r2, [r3, #12]
    }

    handle_ptr->state = PWM_CCU8_STATE_RUNNING;
 8026266:	2302      	movs	r3, #2
 8026268:	7723      	strb	r3, [r4, #28]
      status = PWM_CCU8_STATUS_SUCCESS;

      /* Start the PWM generation if start at initialization is enabled */
      if ((bool) true == handle_ptr->config_ptr->start_control)
      {
        status = PWM_CCU8_Start(handle_ptr);
 802626a:	2000      	movs	r0, #0
 802626c:	e6b9      	b.n	8025fe2 <PWM_CCU8_Init+0xa>
                  handle_ptr->config_ptr->gpio_ch1_out1_config_ptr);
  }

  if ((bool) true == handle_ptr->config_ptr->gpio_ch2_out2_enable)
  {
    XMC_GPIO_Init(handle_ptr->config_ptr->gpio_ch2_out2_ptr, handle_ptr->config_ptr->gpio_ch2_out2_pin,
 802626e:	6f28      	ldr	r0, [r5, #112]	; 0x70
 8026270:	f895 1074 	ldrb.w	r1, [r5, #116]	; 0x74
 8026274:	6faa      	ldr	r2, [r5, #120]	; 0x78
 8026276:	f7fa fe63 	bl	8020f40 <XMC_GPIO_Init>
 802627a:	6825      	ldr	r5, [r4, #0]
 802627c:	e7cc      	b.n	8026218 <PWM_CCU8_Init+0x240>
                  handle_ptr->config_ptr->gpio_ch1_out0_config_ptr);
  }

  if ((bool) true == handle_ptr->config_ptr->gpio_ch1_out1_enable)
  {
    XMC_GPIO_Init(handle_ptr->config_ptr->gpio_ch1_out1_ptr, handle_ptr->config_ptr->gpio_ch1_out1_pin,
 802627e:	6e28      	ldr	r0, [r5, #96]	; 0x60
 8026280:	f895 1064 	ldrb.w	r1, [r5, #100]	; 0x64
 8026284:	6eaa      	ldr	r2, [r5, #104]	; 0x68
 8026286:	f7fa fe5b 	bl	8020f40 <XMC_GPIO_Init>
 802628a:	6825      	ldr	r5, [r4, #0]
 802628c:	e7c1      	b.n	8026212 <PWM_CCU8_Init+0x23a>
}
static void PWM_CCU8_lInit_GPIO(PWM_CCU8_t* handle_ptr)
{
  if ((bool) true == handle_ptr->config_ptr->gpio_ch1_out0_enable)
  {
    XMC_GPIO_Init(handle_ptr->config_ptr->gpio_ch1_out0_ptr, handle_ptr->config_ptr->gpio_ch1_out0_pin,
 802628e:	6d18      	ldr	r0, [r3, #80]	; 0x50
 8026290:	f893 1054 	ldrb.w	r1, [r3, #84]	; 0x54
 8026294:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8026296:	f7fa fe53 	bl	8020f40 <XMC_GPIO_Init>
 802629a:	6825      	ldr	r5, [r4, #0]
 802629c:	e7b5      	b.n	802620a <PWM_CCU8_Init+0x232>
    XMC_CCU8_SLICE_LoadSelector(handle_ptr->ccu8_slice_ptr, handle_ptr->config_ptr->ext_load_selector);
  }
  /* External signal PWM signal (ST bit) output gets modulated by external signal */
  if (XMC_CCU8_SLICE_EVENT_NONE != handle_ptr->config_ptr->ext_mod_event)
  {
    XMC_CCU8_SLICE_ModulationConfig(handle_ptr->ccu8_slice_ptr, handle_ptr->config_ptr->ext_mod_event,
 802629e:	f893 2032 	ldrb.w	r2, [r3, #50]	; 0x32
 80262a2:	f893 3033 	ldrb.w	r3, [r3, #51]	; 0x33
 80262a6:	68a0      	ldr	r0, [r4, #8]
 80262a8:	9300      	str	r3, [sp, #0]
 80262aa:	2303      	movs	r3, #3
 80262ac:	f7fb fa40 	bl	8021730 <XMC_CCU8_SLICE_ModulationConfig>
 80262b0:	6823      	ldr	r3, [r4, #0]
 80262b2:	e70e      	b.n	80260d2 <PWM_CCU8_Init+0xfa>
    XMC_CCU8_SLICE_CountConfig(handle_ptr->ccu8_slice_ptr, handle_ptr->config_ptr->ext_count_event);
  }
  /* Timer gets loaded with compare register value or period register value on external signal */
  if (XMC_CCU8_SLICE_EVENT_NONE != handle_ptr->config_ptr->ext_load_event)
  {
    XMC_CCU8_SLICE_LoadConfig(handle_ptr->ccu8_slice_ptr, handle_ptr->config_ptr->ext_load_event);
 80262b4:	68a0      	ldr	r0, [r4, #8]
 80262b6:	f7fb fa2b 	bl	8021710 <XMC_CCU8_SLICE_LoadConfig>
    XMC_CCU8_SLICE_LoadSelector(handle_ptr->ccu8_slice_ptr, handle_ptr->config_ptr->ext_load_selector);
 80262ba:	6823      	ldr	r3, [r4, #0]
 80262bc:	68a0      	ldr	r0, [r4, #8]
 80262be:	f893 1030 	ldrb.w	r1, [r3, #48]	; 0x30
 80262c2:	f7fb fa2d 	bl	8021720 <XMC_CCU8_SLICE_LoadSelector>
 80262c6:	6823      	ldr	r3, [r4, #0]
 80262c8:	e6fe      	b.n	80260c8 <PWM_CCU8_Init+0xf0>
    XMC_CCU8_SLICE_GateConfig(handle_ptr->ccu8_slice_ptr, handle_ptr->config_ptr->ext_gate_event);
  }
  /* Timer increments on external signal */
  if (XMC_CCU8_SLICE_EVENT_NONE != handle_ptr->config_ptr->ext_count_event)
  {
    XMC_CCU8_SLICE_CountConfig(handle_ptr->ccu8_slice_ptr, handle_ptr->config_ptr->ext_count_event);
 80262ca:	68a0      	ldr	r0, [r4, #8]
 80262cc:	f7fb fa4e 	bl	802176c <XMC_CCU8_SLICE_CountConfig>
 80262d0:	6823      	ldr	r3, [r4, #0]
 80262d2:	e6f4      	b.n	80260be <PWM_CCU8_Init+0xe6>
    XMC_CCU8_SLICE_DirectionConfig(handle_ptr->ccu8_slice_ptr, handle_ptr->config_ptr->ext_count_dir_event);
  }
  /* External signal can stop the timer and the timer value remains same */
  if (XMC_CCU8_SLICE_EVENT_NONE != handle_ptr->config_ptr->ext_gate_event)
  {
    XMC_CCU8_SLICE_GateConfig(handle_ptr->ccu8_slice_ptr, handle_ptr->config_ptr->ext_gate_event);
 80262d4:	68a0      	ldr	r0, [r4, #8]
 80262d6:	f7fb fa51 	bl	802177c <XMC_CCU8_SLICE_GateConfig>
 80262da:	6823      	ldr	r3, [r4, #0]
 80262dc:	e6ea      	b.n	80260b4 <PWM_CCU8_Init+0xdc>
  }

  /* External signal can change the timer counting direction */
  if (XMC_CCU8_SLICE_EVENT_NONE != handle_ptr->config_ptr->ext_count_dir_event)
  {
    XMC_CCU8_SLICE_DirectionConfig(handle_ptr->ccu8_slice_ptr, handle_ptr->config_ptr->ext_count_dir_event);
 80262de:	68a0      	ldr	r0, [r4, #8]
 80262e0:	f7fb fa54 	bl	802178c <XMC_CCU8_SLICE_DirectionConfig>
 80262e4:	6823      	ldr	r3, [r4, #0]
 80262e6:	e6e0      	b.n	80260aa <PWM_CCU8_Init+0xd2>
  }

  /* External signal can stop the timer */
  if (XMC_CCU8_SLICE_EVENT_NONE != handle_ptr->config_ptr->ext_stop_event)
  {
    XMC_CCU8_SLICE_StopConfig(handle_ptr->ccu8_slice_ptr, handle_ptr->config_ptr->ext_stop_event,
 80262e8:	f893 202b 	ldrb.w	r2, [r3, #43]	; 0x2b
 80262ec:	68a0      	ldr	r0, [r4, #8]
 80262ee:	f7fb fa01 	bl	80216f4 <XMC_CCU8_SLICE_StopConfig>
 80262f2:	6823      	ldr	r3, [r4, #0]
 80262f4:	e6d4      	b.n	80260a0 <PWM_CCU8_Init+0xc8>
                                handle_ptr->config_ptr->event2_config_ptr);

  /* External signal controls start of the timer */
  if (XMC_CCU8_SLICE_EVENT_NONE != handle_ptr->config_ptr->ext_start_event)
  {
    XMC_CCU8_SLICE_StartConfig(handle_ptr->ccu8_slice_ptr, handle_ptr->config_ptr->ext_start_event,
 80262f6:	f893 2029 	ldrb.w	r2, [r3, #41]	; 0x29
 80262fa:	68a0      	ldr	r0, [r4, #8]
 80262fc:	f7fb f9ec 	bl	80216d8 <XMC_CCU8_SLICE_StartConfig>
 8026300:	6823      	ldr	r3, [r4, #0]
 8026302:	e6c8      	b.n	8026096 <PWM_CCU8_Init+0xbe>
                                          (uint16_t) handle_ptr->config_ptr->compare2_value);

      if ((1U == handle_ptr->config_ptr->ccu8_cc8_slice_timer_ptr->mcm_ch1_enable) || (1U
          == handle_ptr->config_ptr->ccu8_cc8_slice_timer_ptr->mcm_ch2_enable))
      {
        XMC_CCU8_SetMultiChannelShadowTransferMode(handle_ptr->ccu8_module_ptr,
 8026304:	6bd1      	ldr	r1, [r2, #60]	; 0x3c
 8026306:	6860      	ldr	r0, [r4, #4]
 8026308:	f7fb f9de 	bl	80216c8 <XMC_CCU8_SetMultiChannelShadowTransferMode>
 802630c:	6822      	ldr	r2, [r4, #0]
 802630e:	e693      	b.n	8026038 <PWM_CCU8_Init+0x60>
  }

  /* PWM signal (ST bit) output gets modulated by external signal */
  if (XMC_CCU8_SLICE_EVENT_2 == handle_ptr->config_ptr->ext_trap_event)
  {
    XMC_CCU8_SLICE_TrapConfig(handle_ptr->ccu8_slice_ptr, handle_ptr->config_ptr->ext_trap_exit,
 8026310:	f893 2038 	ldrb.w	r2, [r3, #56]	; 0x38
 8026314:	f893 1039 	ldrb.w	r1, [r3, #57]	; 0x39
 8026318:	f7fb fa46 	bl	80217a8 <XMC_CCU8_SLICE_TrapConfig>
                              handle_ptr->config_ptr->ext_trap_sync);
    if ((bool) true == handle_ptr->config_ptr->ext_trap_enable)
 802631c:	6823      	ldr	r3, [r4, #0]
    {
      XMC_CCU8_SLICE_EnableTrap(
 802631e:	68a0      	ldr	r0, [r4, #8]
  /* PWM signal (ST bit) output gets modulated by external signal */
  if (XMC_CCU8_SLICE_EVENT_2 == handle_ptr->config_ptr->ext_trap_event)
  {
    XMC_CCU8_SLICE_TrapConfig(handle_ptr->ccu8_slice_ptr, handle_ptr->config_ptr->ext_trap_exit,
                              handle_ptr->config_ptr->ext_trap_sync);
    if ((bool) true == handle_ptr->config_ptr->ext_trap_enable)
 8026320:	f893 2036 	ldrb.w	r2, [r3, #54]	; 0x36
 8026324:	2a00      	cmp	r2, #0
 8026326:	f43f aeda 	beq.w	80260de <PWM_CCU8_Init+0x106>
 *  XMC_CCU8_SLICE_SetInput().
 */
__STATIC_INLINE void XMC_CCU8_SLICE_EnableTrap(XMC_CCU8_SLICE_t *const slice, const uint32_t out_mask)
{
  XMC_ASSERT("XMC_CCU8_SLICE_EnableTrap:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  slice->TC |= (uint32_t)out_mask << CCU8_CC8_TC_TRAPE0_Pos;
 802632a:	6942      	ldr	r2, [r0, #20]
 802632c:	f442 12f0 	orr.w	r2, r2, #1966080	; 0x1e0000
 8026330:	6142      	str	r2, [r0, #20]
 8026332:	e6d4      	b.n	80260de <PWM_CCU8_Init+0x106>

08026334 <PWM_CCU8_Start>:
{
  PWM_CCU8_STATUS_t status;

  status = PWM_CCU8_STATUS_FAILURE;
  XMC_ASSERT("PWM_CCU8_Start:handle_ptr NULL", (handle_ptr != NULL));
  if ((PWM_CCU8_STATE_INITIALIZED == handle_ptr->state) || (PWM_CCU8_STATE_STOPPED == handle_ptr->state))
 8026334:	7f03      	ldrb	r3, [r0, #28]
 8026336:	f003 03fd 	and.w	r3, r3, #253	; 0xfd
 802633a:	2b01      	cmp	r3, #1
 802633c:	d001      	beq.n	8026342 <PWM_CCU8_Start+0xe>
/*Starts the CCU8_CC8 slice. This needs to be called even if external start is configured.*/
PWM_CCU8_STATUS_t PWM_CCU8_Start(PWM_CCU8_t* handle_ptr)
{
  PWM_CCU8_STATUS_t status;

  status = PWM_CCU8_STATUS_FAILURE;
 802633e:	2001      	movs	r0, #1
 8026340:	4770      	bx	lr

}
/**********************************************************************************************************/
/*Starts the CCU8_CC8 slice. This needs to be called even if external start is configured.*/
PWM_CCU8_STATUS_t PWM_CCU8_Start(PWM_CCU8_t* handle_ptr)
{
 8026342:	b430      	push	{r4, r5}
  status = PWM_CCU8_STATUS_FAILURE;
  XMC_ASSERT("PWM_CCU8_Start:handle_ptr NULL", (handle_ptr != NULL));
  if ((PWM_CCU8_STATE_INITIALIZED == handle_ptr->state) || (PWM_CCU8_STATE_STOPPED == handle_ptr->state))
  {
    /* clear IDLE mode for the slice; Start timer */
    XMC_CCU8_EnableClock(handle_ptr->ccu8_module_ptr, handle_ptr->slice_number);
 8026344:	6841      	ldr	r1, [r0, #4]
__STATIC_INLINE void XMC_CCU8_EnableClock(XMC_CCU8_MODULE_t *const module, const uint8_t slice_number)
{
  XMC_ASSERT("XMC_CCU8_EnableClock:Invalid Module Pointer", XMC_CCU8_IsValidModule(module));
  XMC_ASSERT("XMC_CCU8_EnableClock:Invalid Slice Number", (slice_number < 4U));

  module->GIDLC |= ((uint32_t) 1 << slice_number);
 8026346:	7b45      	ldrb	r5, [r0, #13]

    if (XMC_CCU8_SLICE_EVENT_NONE == handle_ptr->config_ptr->ext_start_event)
 8026348:	6804      	ldr	r4, [r0, #0]
 802634a:	68ca      	ldr	r2, [r1, #12]
 802634c:	f894 4028 	ldrb.w	r4, [r4, #40]	; 0x28
 8026350:	fa03 f505 	lsl.w	r5, r3, r5
 8026354:	432a      	orrs	r2, r5
 8026356:	60ca      	str	r2, [r1, #12]
 8026358:	b90c      	cbnz	r4, 802635e <PWM_CCU8_Start+0x2a>
    {
      XMC_CCU8_SLICE_StartTimer(handle_ptr->ccu8_slice_ptr);
 802635a:	6882      	ldr	r2, [r0, #8]
 *  XMC_CCU8_SLICE_StopTimer().
 */
__STATIC_INLINE void XMC_CCU8_SLICE_StartTimer(XMC_CCU8_SLICE_t *const slice)
{
  XMC_ASSERT("XMC_CCU8_SLICE_StartTimer:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  slice->TCSET = CCU8_CC8_TCSET_TRBS_Msk;
 802635c:	60d3      	str	r3, [r2, #12]
    }

    handle_ptr->state = PWM_CCU8_STATE_RUNNING;
 802635e:	2302      	movs	r3, #2
 8026360:	7703      	strb	r3, [r0, #28]
    status = PWM_CCU8_STATUS_SUCCESS;
    XMC_DEBUG("PWM_CCU8_Start:start PWM");
  }
  return (status);
} /* end of PWM_CCU8_Start() api */
 8026362:	bc30      	pop	{r4, r5}
    if (XMC_CCU8_SLICE_EVENT_NONE == handle_ptr->config_ptr->ext_start_event)
    {
      XMC_CCU8_SLICE_StartTimer(handle_ptr->ccu8_slice_ptr);
    }

    handle_ptr->state = PWM_CCU8_STATE_RUNNING;
 8026364:	2000      	movs	r0, #0
    status = PWM_CCU8_STATUS_SUCCESS;
    XMC_DEBUG("PWM_CCU8_Start:start PWM");
  }
  return (status);
} /* end of PWM_CCU8_Start() api */
 8026366:	4770      	bx	lr

08026368 <PWM_CCU8_Stop>:
{
  PWM_CCU8_STATUS_t status;

  status = PWM_CCU8_STATUS_FAILURE;
  XMC_ASSERT("PWM_CCU8_Stop:handle_ptr NULL", (handle_ptr != NULL));
  if (PWM_CCU8_STATE_UNINITIALIZED != handle_ptr->state)
 8026368:	7f02      	ldrb	r2, [r0, #28]
  return (status);
} /* end of PWM_CCU8_Start() api */
/**********************************************************************************************************/
/*Stops the CCU8_CC8 slice. */
PWM_CCU8_STATUS_t PWM_CCU8_Stop(PWM_CCU8_t* handle_ptr)
{
 802636a:	4603      	mov	r3, r0
  PWM_CCU8_STATUS_t status;

  status = PWM_CCU8_STATUS_FAILURE;
  XMC_ASSERT("PWM_CCU8_Stop:handle_ptr NULL", (handle_ptr != NULL));
  if (PWM_CCU8_STATE_UNINITIALIZED != handle_ptr->state)
 802636c:	b15a      	cbz	r2, 8026386 <PWM_CCU8_Stop+0x1e>
  {
    XMC_CCU8_SLICE_StopTimer(handle_ptr->ccu8_slice_ptr);
 802636e:	6882      	ldr	r2, [r0, #8]
  return (status);
} /* end of PWM_CCU8_Start() api */
/**********************************************************************************************************/
/*Stops the CCU8_CC8 slice. */
PWM_CCU8_STATUS_t PWM_CCU8_Stop(PWM_CCU8_t* handle_ptr)
{
 8026370:	b410      	push	{r4}
 *  XMC_CCU8_SLICE_StartTimer().
 */
__STATIC_INLINE void XMC_CCU8_SLICE_StopTimer(XMC_CCU8_SLICE_t *const slice)
{
  XMC_ASSERT("XMC_CCU8_SLICE_StopTimer:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  slice->TCCLR = (uint32_t) CCU8_CC8_TCCLR_TRBC_Msk;
 8026372:	2001      	movs	r0, #1
 *  XMC_CCU8_SLICE_StartTimer().
 */
__STATIC_INLINE void XMC_CCU8_SLICE_ClearTimer(XMC_CCU8_SLICE_t *const slice)
{
  XMC_ASSERT("XMC_CCU8_SLICE_ClearTimer:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  slice->TCCLR = (uint32_t) CCU8_CC8_TCCLR_TCC_Msk;
 8026374:	2402      	movs	r4, #2
  if (PWM_CCU8_STATE_UNINITIALIZED != handle_ptr->state)
  {
    XMC_CCU8_SLICE_StopTimer(handle_ptr->ccu8_slice_ptr);
    XMC_CCU8_SLICE_ClearTimer(handle_ptr->ccu8_slice_ptr);

    handle_ptr->state = PWM_CCU8_STATE_STOPPED;
 8026376:	2103      	movs	r1, #3
 *  XMC_CCU8_SLICE_StartTimer().
 */
__STATIC_INLINE void XMC_CCU8_SLICE_StopTimer(XMC_CCU8_SLICE_t *const slice)
{
  XMC_ASSERT("XMC_CCU8_SLICE_StopTimer:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  slice->TCCLR = (uint32_t) CCU8_CC8_TCCLR_TRBC_Msk;
 8026378:	6110      	str	r0, [r2, #16]
 *  XMC_CCU8_SLICE_StartTimer().
 */
__STATIC_INLINE void XMC_CCU8_SLICE_ClearTimer(XMC_CCU8_SLICE_t *const slice)
{
  XMC_ASSERT("XMC_CCU8_SLICE_ClearTimer:Invalid Slice Pointer", XMC_CCU8_IsValidSlice(slice));
  slice->TCCLR = (uint32_t) CCU8_CC8_TCCLR_TCC_Msk;
 802637a:	6114      	str	r4, [r2, #16]
    status = PWM_CCU8_STATUS_SUCCESS;
 802637c:	2000      	movs	r0, #0
  if (PWM_CCU8_STATE_UNINITIALIZED != handle_ptr->state)
  {
    XMC_CCU8_SLICE_StopTimer(handle_ptr->ccu8_slice_ptr);
    XMC_CCU8_SLICE_ClearTimer(handle_ptr->ccu8_slice_ptr);

    handle_ptr->state = PWM_CCU8_STATE_STOPPED;
 802637e:	7719      	strb	r1, [r3, #28]
    status = PWM_CCU8_STATUS_SUCCESS;
    XMC_DEBUG("PWM_CCU8_Stop:stop PWM");
  }
  return (status);

} /* end of PWM_CCU8_Stop() api */
 8026380:	f85d 4b04 	ldr.w	r4, [sp], #4
 8026384:	4770      	bx	lr
/*Stops the CCU8_CC8 slice. */
PWM_CCU8_STATUS_t PWM_CCU8_Stop(PWM_CCU8_t* handle_ptr)
{
  PWM_CCU8_STATUS_t status;

  status = PWM_CCU8_STATUS_FAILURE;
 8026386:	2001      	movs	r0, #1
 8026388:	4770      	bx	lr
 802638a:	bf00      	nop

0802638c <PWM_CCU8_SetFreqAndDutyCycleSymmetric>:
/**********************************************************************************************************/

/*Sets the frequency and duty cycle for CCU8_CC8 slice Symmetric Mode. */
PWM_CCU8_STATUS_t PWM_CCU8_SetFreqAndDutyCycleSymmetric(PWM_CCU8_t* handle_ptr, uint32_t pwm_freq_hz, uint32_t duty_ch1,
                                                        uint32_t duty_ch2)
{
 802638c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t compare_ch2;

  status = PWM_CCU8_STATUS_FAILURE;
  frequency_tclk = 0U;
  XMC_ASSERT("PWM_CCU8_SetFreqAndDutyCycleSymmetric:handle_ptr NULL", (handle_ptr != NULL));
  if (PWM_CCU8_STATE_UNINITIALIZED != handle_ptr->state)
 8026390:	7f04      	ldrb	r4, [r0, #28]
 8026392:	2c00      	cmp	r4, #0
 8026394:	d040      	beq.n	8026418 <PWM_CCU8_SetFreqAndDutyCycleSymmetric+0x8c>
  {
    if (0U == pwm_freq_hz)
 8026396:	2900      	cmp	r1, #0
 8026398:	d03e      	beq.n	8026418 <PWM_CCU8_SetFreqAndDutyCycleSymmetric+0x8c>
    {
      XMC_DEBUG("PWM_CCU8_SetFreqAndDutyCycleSymmetric:cannot set frequency 0Hz");
    }
    else if ((duty_ch1 > PWM_CCU8_SYM_DUTY_MAX) || (duty_ch2 > PWM_CCU8_SYM_DUTY_MAX))
 802639a:	f242 7410 	movw	r4, #10000	; 0x2710
 802639e:	42a2      	cmp	r2, r4
 80263a0:	d83a      	bhi.n	8026418 <PWM_CCU8_SetFreqAndDutyCycleSymmetric+0x8c>
 80263a2:	42a3      	cmp	r3, r4
 80263a4:	d838      	bhi.n	8026418 <PWM_CCU8_SetFreqAndDutyCycleSymmetric+0x8c>
    else
    {
      frequency_tclk = handle_ptr->frequency_tclk;
      period = frequency_tclk / pwm_freq_hz;

      if ((uint32_t) XMC_CCU8_SLICE_TIMER_COUNT_MODE_CA == handle_ptr->config_ptr->ccu8_cc8_slice_timer_ptr->timer_mode)
 80263a6:	6804      	ldr	r4, [r0, #0]
      XMC_DEBUG("PWM_CCU8_SetFreqAndDutyCycleSymmetric:duty > 100%");
    }
    else
    {
      frequency_tclk = handle_ptr->frequency_tclk;
      period = frequency_tclk / pwm_freq_hz;
 80263a8:	6a07      	ldr	r7, [r0, #32]

      if ((uint32_t) XMC_CCU8_SLICE_TIMER_COUNT_MODE_CA == handle_ptr->config_ptr->ccu8_cc8_slice_timer_ptr->timer_mode)
 80263aa:	6ca4      	ldr	r4, [r4, #72]	; 0x48
      XMC_DEBUG("PWM_CCU8_SetFreqAndDutyCycleSymmetric:duty > 100%");
    }
    else
    {
      frequency_tclk = handle_ptr->frequency_tclk;
      period = frequency_tclk / pwm_freq_hz;
 80263ac:	fbb7 f7f1 	udiv	r7, r7, r1

      if ((uint32_t) XMC_CCU8_SLICE_TIMER_COUNT_MODE_CA == handle_ptr->config_ptr->ccu8_cc8_slice_timer_ptr->timer_mode)
 80263b0:	7821      	ldrb	r1, [r4, #0]
 80263b2:	07c9      	lsls	r1, r1, #31
      {
        period = period >> 1U;/*divide by 2*/
 80263b4:	bf48      	it	mi
 80263b6:	087f      	lsrmi	r7, r7, #1
      }

      if ((period != 0U) && (period <= PWM_CCU8_MAX_TIMER_COUNT))
 80263b8:	1e79      	subs	r1, r7, #1
 80263ba:	f64f 74fe 	movw	r4, #65534	; 0xfffe
 80263be:	42a1      	cmp	r1, r4
 80263c0:	d82a      	bhi.n	8026418 <PWM_CCU8_SetFreqAndDutyCycleSymmetric+0x8c>
 80263c2:	4604      	mov	r4, r0
 80263c4:	4615      	mov	r5, r2
      {
        /*Calculate the current duty cycle in no-timer concatenation mode*/
        compare_ch1 = ((period * (PWM_CCU8_DUTY_FULL_SCALE - duty_ch1)) / PWM_CCU8_DUTY_FULL_SCALE);
        compare_ch2 = ((period * (PWM_CCU8_DUTY_FULL_SCALE - duty_ch2)) / PWM_CCU8_DUTY_FULL_SCALE);

        XMC_CCU8_SLICE_SetTimerPeriodMatch(handle_ptr->ccu8_slice_ptr, (uint16_t)(period - 1U));
 80263c6:	b289      	uxth	r1, r1
 80263c8:	6880      	ldr	r0, [r0, #8]
      }

      if ((period != 0U) && (period <= PWM_CCU8_MAX_TIMER_COUNT))
      {
        /*Calculate the current duty cycle in no-timer concatenation mode*/
        compare_ch1 = ((period * (PWM_CCU8_DUTY_FULL_SCALE - duty_ch1)) / PWM_CCU8_DUTY_FULL_SCALE);
 80263ca:	f8df 8054 	ldr.w	r8, [pc, #84]	; 8026420 <PWM_CCU8_SetFreqAndDutyCycleSymmetric+0x94>
 80263ce:	461e      	mov	r6, r3
        compare_ch2 = ((period * (PWM_CCU8_DUTY_FULL_SCALE - duty_ch2)) / PWM_CCU8_DUTY_FULL_SCALE);

        XMC_CCU8_SLICE_SetTimerPeriodMatch(handle_ptr->ccu8_slice_ptr, (uint16_t)(period - 1U));
 80263d0:	f7fb fa68 	bl	80218a4 <XMC_CCU8_SLICE_SetTimerPeriodMatch>
      }

      if ((period != 0U) && (period <= PWM_CCU8_MAX_TIMER_COUNT))
      {
        /*Calculate the current duty cycle in no-timer concatenation mode*/
        compare_ch1 = ((period * (PWM_CCU8_DUTY_FULL_SCALE - duty_ch1)) / PWM_CCU8_DUTY_FULL_SCALE);
 80263d4:	f5c5 531c 	rsb	r3, r5, #9984	; 0x2700
 80263d8:	3310      	adds	r3, #16
 80263da:	fb03 f307 	mul.w	r3, r3, r7
 80263de:	fba8 3203 	umull	r3, r2, r8, r3
        compare_ch2 = ((period * (PWM_CCU8_DUTY_FULL_SCALE - duty_ch2)) / PWM_CCU8_DUTY_FULL_SCALE);

        XMC_CCU8_SLICE_SetTimerPeriodMatch(handle_ptr->ccu8_slice_ptr, (uint16_t)(period - 1U));
        XMC_CCU8_SLICE_SetTimerCompareMatch(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_COMPARE_CHANNEL_1,
 80263e2:	68a0      	ldr	r0, [r4, #8]
 80263e4:	f3c2 324f 	ubfx	r2, r2, #13, #16
 80263e8:	2100      	movs	r1, #0
 80263ea:	f7fb fa5d 	bl	80218a8 <XMC_CCU8_SLICE_SetTimerCompareMatch>

      if ((period != 0U) && (period <= PWM_CCU8_MAX_TIMER_COUNT))
      {
        /*Calculate the current duty cycle in no-timer concatenation mode*/
        compare_ch1 = ((period * (PWM_CCU8_DUTY_FULL_SCALE - duty_ch1)) / PWM_CCU8_DUTY_FULL_SCALE);
        compare_ch2 = ((period * (PWM_CCU8_DUTY_FULL_SCALE - duty_ch2)) / PWM_CCU8_DUTY_FULL_SCALE);
 80263ee:	f5c6 511c 	rsb	r1, r6, #9984	; 0x2700
 80263f2:	3110      	adds	r1, #16
 80263f4:	fb01 f107 	mul.w	r1, r1, r7
 80263f8:	fba8 3201 	umull	r3, r2, r8, r1

        XMC_CCU8_SLICE_SetTimerPeriodMatch(handle_ptr->ccu8_slice_ptr, (uint16_t)(period - 1U));
        XMC_CCU8_SLICE_SetTimerCompareMatch(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_COMPARE_CHANNEL_1,
                                            (uint16_t) compare_ch1);
        XMC_CCU8_SLICE_SetTimerCompareMatch(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_COMPARE_CHANNEL_2,
 80263fc:	68a0      	ldr	r0, [r4, #8]
 80263fe:	f3c2 324f 	ubfx	r2, r2, #13, #16
 8026402:	2101      	movs	r1, #1
 8026404:	f7fb fa50 	bl	80218a8 <XMC_CCU8_SLICE_SetTimerCompareMatch>
                                            (uint16_t) compare_ch2);
        XMC_CCU8_EnableShadowTransfer(handle_ptr->ccu8_module_ptr, handle_ptr->shadow_txfr_msk);
 8026408:	6863      	ldr	r3, [r4, #4]
 802640a:	6922      	ldr	r2, [r4, #16]
 *  None.
 */
__STATIC_INLINE void XMC_CCU8_EnableShadowTransfer(XMC_CCU8_MODULE_t *const module, const uint32_t shadow_transfer_msk)
{
  XMC_ASSERT("XMC_CCU8_EnableShadowTransfer:Invalid module Pointer", XMC_CCU8_IsValidModule(module));
  module->GCSS = (uint32_t)shadow_transfer_msk;  
 802640c:	611a      	str	r2, [r3, #16]

        handle_ptr->sym_duty1 = duty_ch1;
        handle_ptr->sym_duty2 = duty_ch2;

        XMC_DEBUG("PWM_CCU8_SetFreqAndDutyCycleSymmetric:frequency set");
        status = PWM_CCU8_STATUS_SUCCESS;
 802640e:	2000      	movs	r0, #0
                                            (uint16_t) compare_ch1);
        XMC_CCU8_SLICE_SetTimerCompareMatch(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_COMPARE_CHANNEL_2,
                                            (uint16_t) compare_ch2);
        XMC_CCU8_EnableShadowTransfer(handle_ptr->ccu8_module_ptr, handle_ptr->shadow_txfr_msk);

        handle_ptr->sym_duty1 = duty_ch1;
 8026410:	6265      	str	r5, [r4, #36]	; 0x24
        handle_ptr->sym_duty2 = duty_ch2;
 8026412:	62a6      	str	r6, [r4, #40]	; 0x28
 8026414:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  uint32_t frequency_tclk;
  uint32_t period;
  uint32_t compare_ch1;
  uint32_t compare_ch2;

  status = PWM_CCU8_STATUS_FAILURE;
 8026418:	2001      	movs	r0, #1
      }
    }
  }
  return (status);

}/* end of PWM_CCU8_SetFreqAndDutyCycleSymmetric() api */
 802641a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802641e:	bf00      	nop
 8026420:	d1b71759 	.word	0xd1b71759

08026424 <PWM_CCU8_SetFreqAndDutyCycleAsymmetric>:
/**********************************************************************************************************/

/*Sets the frequency, (uint32_t)shift and (uint32_t)duty cycle for CCU8_CC8 slice Asymmetric Mode. */
PWM_CCU8_STATUS_t PWM_CCU8_SetFreqAndDutyCycleAsymmetric(PWM_CCU8_t* handle_ptr, uint32_t pwm_freq_hz, uint32_t shift,
                                                         uint32_t duty_cycle)
{
 8026424:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  uint32_t compare_ch2;

  status = PWM_CCU8_STATUS_FAILURE;
  frequency_tclk = 0U;
  XMC_ASSERT("PWM_CCU8_SetFreqAndDutyCycleAsymmetric:handle_ptr NULL", (handle_ptr != NULL));
  if (PWM_CCU8_STATE_UNINITIALIZED != handle_ptr->state)
 8026428:	7f04      	ldrb	r4, [r0, #28]
 802642a:	b304      	cbz	r4, 802646e <PWM_CCU8_SetFreqAndDutyCycleAsymmetric+0x4a>
  {
    if (0U == pwm_freq_hz)
 802642c:	b1f9      	cbz	r1, 802646e <PWM_CCU8_SetFreqAndDutyCycleAsymmetric+0x4a>
 802642e:	461f      	mov	r7, r3
    else
    {
      frequency_tclk = handle_ptr->frequency_tclk;
      period = frequency_tclk / pwm_freq_hz;

      if ((uint32_t) XMC_CCU8_SLICE_TIMER_COUNT_MODE_CA == handle_ptr->config_ptr->ccu8_cc8_slice_timer_ptr->timer_mode)
 8026430:	6803      	ldr	r3, [r0, #0]
 8026432:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8026434:	4616      	mov	r6, r2
 8026436:	4604      	mov	r4, r0
      XMC_DEBUG("PWM_CCU8_SetFreqAndDutyCycleAsymmetric:cannot set frequency 0Hz");
    }
    else
    {
      frequency_tclk = handle_ptr->frequency_tclk;
      period = frequency_tclk / pwm_freq_hz;
 8026438:	6a02      	ldr	r2, [r0, #32]

      if ((uint32_t) XMC_CCU8_SLICE_TIMER_COUNT_MODE_CA == handle_ptr->config_ptr->ccu8_cc8_slice_timer_ptr->timer_mode)
 802643a:	7818      	ldrb	r0, [r3, #0]
      XMC_DEBUG("PWM_CCU8_SetFreqAndDutyCycleAsymmetric:cannot set frequency 0Hz");
    }
    else
    {
      frequency_tclk = handle_ptr->frequency_tclk;
      period = frequency_tclk / pwm_freq_hz;
 802643c:	fbb2 f8f1 	udiv	r8, r2, r1

      if ((uint32_t) XMC_CCU8_SLICE_TIMER_COUNT_MODE_CA == handle_ptr->config_ptr->ccu8_cc8_slice_timer_ptr->timer_mode)
 8026440:	f010 0501 	ands.w	r5, r0, #1
 8026444:	d016      	beq.n	8026474 <PWM_CCU8_SetFreqAndDutyCycleAsymmetric+0x50>
      {
        if (((shift + duty_cycle) > PWM_CCU8_ASYM_CA_MAX) || ((shift + duty_cycle) < PWM_CCU8_ASYM_CA_MIN))
 8026446:	19f5      	adds	r5, r6, r7
 8026448:	f5a5 539c 	sub.w	r3, r5, #4992	; 0x1380
 802644c:	3b08      	subs	r3, #8
 802644e:	f241 3288 	movw	r2, #5000	; 0x1388
 8026452:	4293      	cmp	r3, r2
 8026454:	d80b      	bhi.n	802646e <PWM_CCU8_SetFreqAndDutyCycleAsymmetric+0x4a>
        {
          XMC_DEBUG("PWM_CCU8_SetDutyCycleAsymmetric:Cannot set center aligned mode 50% < (shift + duty_cycle) < 100%");
        }
        else if (shift >= PWM_CCU8_ASYM_CA_SHIFT_MAX)
 8026456:	f241 3387 	movw	r3, #4999	; 0x1387
 802645a:	429e      	cmp	r6, r3
 802645c:	d807      	bhi.n	802646e <PWM_CCU8_SetFreqAndDutyCycleAsymmetric+0x4a>
        {
          XMC_DEBUG("PWM_CCU8_SetDutyCycleAsymmetric:Cannot set center aligned mode shift > 50%");
        }
        else
        {
          period = period >> 1U;/*divide by 2*/
 802645e:	ea4f 0858 	mov.w	r8, r8, lsr #1

          if ((period != 0U) && (period <= PWM_CCU8_MAX_TIMER_COUNT))
 8026462:	f108 31ff 	add.w	r1, r8, #4294967295
 8026466:	f64f 73fe 	movw	r3, #65534	; 0xfffe
 802646a:	4299      	cmp	r1, r3
 802646c:	d92f      	bls.n	80264ce <PWM_CCU8_SetFreqAndDutyCycleAsymmetric+0xaa>
  uint32_t frequency_tclk;
  uint32_t period;
  uint32_t compare_ch1;
  uint32_t compare_ch2;

  status = PWM_CCU8_STATUS_FAILURE;
 802646e:	2001      	movs	r0, #1
        }
      }
    }
  }
  return (status);
}/* end of PWM_CCU8_SetFreqAndDutyCycleAsymmetric() api */
 8026470:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
          }
        }
      }
      else
      {
        if (period <= PWM_CCU8_MAX_TIMER_COUNT)
 8026474:	f5b8 3f80 	cmp.w	r8, #65536	; 0x10000
 8026478:	d2f9      	bcs.n	802646e <PWM_CCU8_SetFreqAndDutyCycleAsymmetric+0x4a>
        {
          if (((shift + duty_cycle) > PWM_CCU8_ASYM_EA_MAX))
 802647a:	eb06 0907 	add.w	r9, r6, r7
 802647e:	f242 7310 	movw	r3, #10000	; 0x2710
 8026482:	4599      	cmp	r9, r3
 8026484:	d8f3      	bhi.n	802646e <PWM_CCU8_SetFreqAndDutyCycleAsymmetric+0x4a>
          else
          {
            compare_ch1 = ((period * shift) / PWM_CCU8_DUTY_FULL_SCALE);
            compare_ch2 = ((period * (shift + duty_cycle)) / PWM_CCU8_DUTY_FULL_SCALE);

            XMC_CCU8_SLICE_SetTimerPeriodMatch(handle_ptr->ccu8_slice_ptr, (uint16_t)(period - 1U));
 8026486:	f108 31ff 	add.w	r1, r8, #4294967295
 802648a:	b289      	uxth	r1, r1
 802648c:	68a0      	ldr	r0, [r4, #8]
          {
            XMC_DEBUG("PWM_CCU8_SetDutyCycleAsymmetric:Cannot set edge aligned mode (shift + duty_cycle) > 100%");
          }
          else
          {
            compare_ch1 = ((period * shift) / PWM_CCU8_DUTY_FULL_SCALE);
 802648e:	f8df a074 	ldr.w	sl, [pc, #116]	; 8026504 <PWM_CCU8_SetFreqAndDutyCycleAsymmetric+0xe0>
            compare_ch2 = ((period * (shift + duty_cycle)) / PWM_CCU8_DUTY_FULL_SCALE);

            XMC_CCU8_SLICE_SetTimerPeriodMatch(handle_ptr->ccu8_slice_ptr, (uint16_t)(period - 1U));
 8026492:	f7fb fa07 	bl	80218a4 <XMC_CCU8_SLICE_SetTimerPeriodMatch>
          {
            XMC_DEBUG("PWM_CCU8_SetDutyCycleAsymmetric:Cannot set edge aligned mode (shift + duty_cycle) > 100%");
          }
          else
          {
            compare_ch1 = ((period * shift) / PWM_CCU8_DUTY_FULL_SCALE);
 8026496:	fb06 f208 	mul.w	r2, r6, r8
 802649a:	fbaa 3202 	umull	r3, r2, sl, r2
            compare_ch2 = ((period * (shift + duty_cycle)) / PWM_CCU8_DUTY_FULL_SCALE);

            XMC_CCU8_SLICE_SetTimerPeriodMatch(handle_ptr->ccu8_slice_ptr, (uint16_t)(period - 1U));
            XMC_CCU8_SLICE_SetTimerCompareMatch(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_COMPARE_CHANNEL_1,
 802649e:	f3c2 324f 	ubfx	r2, r2, #13, #16
 80264a2:	4629      	mov	r1, r5
 80264a4:	68a0      	ldr	r0, [r4, #8]
 80264a6:	f7fb f9ff 	bl	80218a8 <XMC_CCU8_SLICE_SetTimerCompareMatch>
            XMC_DEBUG("PWM_CCU8_SetDutyCycleAsymmetric:Cannot set edge aligned mode (shift + duty_cycle) > 100%");
          }
          else
          {
            compare_ch1 = ((period * shift) / PWM_CCU8_DUTY_FULL_SCALE);
            compare_ch2 = ((period * (shift + duty_cycle)) / PWM_CCU8_DUTY_FULL_SCALE);
 80264aa:	fb09 f108 	mul.w	r1, r9, r8
 80264ae:	fbaa 3201 	umull	r3, r2, sl, r1
                ((2U * period * (PWM_CCU8_DUTY_FULL_SCALE - (shift + duty_cycle))) / PWM_CCU8_DUTY_FULL_SCALE);

            XMC_CCU8_SLICE_SetTimerPeriodMatch(handle_ptr->ccu8_slice_ptr, (uint16_t)(period - 1U));
            XMC_CCU8_SLICE_SetTimerCompareMatch(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_COMPARE_CHANNEL_1,
                                                (uint16_t) compare_ch1);
            XMC_CCU8_SLICE_SetTimerCompareMatch(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_COMPARE_CHANNEL_2,
 80264b2:	68a0      	ldr	r0, [r4, #8]
 80264b4:	f3c2 324f 	ubfx	r2, r2, #13, #16
 80264b8:	2101      	movs	r1, #1
 80264ba:	f7fb f9f5 	bl	80218a8 <XMC_CCU8_SLICE_SetTimerCompareMatch>
                                                (uint16_t) compare_ch2);
            XMC_CCU8_EnableShadowTransfer(handle_ptr->ccu8_module_ptr, handle_ptr->shadow_txfr_msk);
 80264be:	6863      	ldr	r3, [r4, #4]
 80264c0:	6922      	ldr	r2, [r4, #16]
 80264c2:	611a      	str	r2, [r3, #16]

            handle_ptr->asym_duty = duty_cycle;
            handle_ptr->asym_shift = shift;

            XMC_DEBUG("PWM_CCU8_SetFreqAndDutyCycleAsymmetric:frequency and duty set center aligned mode");
            status = PWM_CCU8_STATUS_SUCCESS;
 80264c4:	2000      	movs	r0, #0
                                                (uint16_t) compare_ch1);
            XMC_CCU8_SLICE_SetTimerCompareMatch(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_COMPARE_CHANNEL_2,
                                                (uint16_t) compare_ch2);
            XMC_CCU8_EnableShadowTransfer(handle_ptr->ccu8_module_ptr, handle_ptr->shadow_txfr_msk);

            handle_ptr->asym_duty = duty_cycle;
 80264c6:	62e7      	str	r7, [r4, #44]	; 0x2c
            handle_ptr->asym_shift = shift;
 80264c8:	6326      	str	r6, [r4, #48]	; 0x30
 80264ca:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
          {
            compare_ch1 = ((2U * period * shift) / PWM_CCU8_DUTY_FULL_SCALE);
            compare_ch2 =
                ((2U * period * (PWM_CCU8_DUTY_FULL_SCALE - (shift + duty_cycle))) / PWM_CCU8_DUTY_FULL_SCALE);

            XMC_CCU8_SLICE_SetTimerPeriodMatch(handle_ptr->ccu8_slice_ptr, (uint16_t)(period - 1U));
 80264ce:	b289      	uxth	r1, r1
 80264d0:	68a0      	ldr	r0, [r4, #8]
        {
          period = period >> 1U;/*divide by 2*/

          if ((period != 0U) && (period <= PWM_CCU8_MAX_TIMER_COUNT))
          {
            compare_ch1 = ((2U * period * shift) / PWM_CCU8_DUTY_FULL_SCALE);
 80264d2:	f8df 9030 	ldr.w	r9, [pc, #48]	; 8026504 <PWM_CCU8_SetFreqAndDutyCycleAsymmetric+0xe0>
            compare_ch2 =
                ((2U * period * (PWM_CCU8_DUTY_FULL_SCALE - (shift + duty_cycle))) / PWM_CCU8_DUTY_FULL_SCALE);

            XMC_CCU8_SLICE_SetTimerPeriodMatch(handle_ptr->ccu8_slice_ptr, (uint16_t)(period - 1U));
 80264d6:	f7fb f9e5 	bl	80218a4 <XMC_CCU8_SLICE_SetTimerPeriodMatch>
 80264da:	0072      	lsls	r2, r6, #1
        {
          period = period >> 1U;/*divide by 2*/

          if ((period != 0U) && (period <= PWM_CCU8_MAX_TIMER_COUNT))
          {
            compare_ch1 = ((2U * period * shift) / PWM_CCU8_DUTY_FULL_SCALE);
 80264dc:	fb08 f202 	mul.w	r2, r8, r2
 80264e0:	fba9 3202 	umull	r3, r2, r9, r2
            compare_ch2 =
                ((2U * period * (PWM_CCU8_DUTY_FULL_SCALE - (shift + duty_cycle))) / PWM_CCU8_DUTY_FULL_SCALE);
 80264e4:	f5c5 551c 	rsb	r5, r5, #9984	; 0x2700

            XMC_CCU8_SLICE_SetTimerPeriodMatch(handle_ptr->ccu8_slice_ptr, (uint16_t)(period - 1U));
            XMC_CCU8_SLICE_SetTimerCompareMatch(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_COMPARE_CHANNEL_1,
 80264e8:	f3c2 324f 	ubfx	r2, r2, #13, #16
 80264ec:	68a0      	ldr	r0, [r4, #8]
 80264ee:	2100      	movs	r1, #0

          if ((period != 0U) && (period <= PWM_CCU8_MAX_TIMER_COUNT))
          {
            compare_ch1 = ((2U * period * shift) / PWM_CCU8_DUTY_FULL_SCALE);
            compare_ch2 =
                ((2U * period * (PWM_CCU8_DUTY_FULL_SCALE - (shift + duty_cycle))) / PWM_CCU8_DUTY_FULL_SCALE);
 80264f0:	3510      	adds	r5, #16

            XMC_CCU8_SLICE_SetTimerPeriodMatch(handle_ptr->ccu8_slice_ptr, (uint16_t)(period - 1U));
            XMC_CCU8_SLICE_SetTimerCompareMatch(handle_ptr->ccu8_slice_ptr, XMC_CCU8_SLICE_COMPARE_CHANNEL_1,
 80264f2:	f7fb f9d9 	bl	80218a8 <XMC_CCU8_SLICE_SetTimerCompareMatch>

          if ((period != 0U) && (period <= PWM_CCU8_MAX_TIMER_COUNT))
          {
            compare_ch1 = ((2U * period * shift) / PWM_CCU8_DUTY_FULL_SCALE);
            compare_ch2 =
                ((2U * period * (PWM_CCU8_DUTY_FULL_SCALE - (shift + duty_cycle))) / PWM_CCU8_DUTY_FULL_SCALE);
 80264f6:	fb05 f208 	mul.w	r2, r5, r8
 80264fa:	0052      	lsls	r2, r2, #1
          period = period >> 1U;/*divide by 2*/

          if ((period != 0U) && (period <= PWM_CCU8_MAX_TIMER_COUNT))
          {
            compare_ch1 = ((2U * period * shift) / PWM_CCU8_DUTY_FULL_SCALE);
            compare_ch2 =
 80264fc:	fba9 3202 	umull	r3, r2, r9, r2
 8026500:	e7d7      	b.n	80264b2 <PWM_CCU8_SetFreqAndDutyCycleAsymmetric+0x8e>
 8026502:	bf00      	nop
 8026504:	d1b71759 	.word	0xd1b71759

08026508 <INTERRUPT_Init>:
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8026508:	4b20      	ldr	r3, [pc, #128]	; (802658c <INTERRUPT_Init+0x84>)

/*
 * API to initialize the INTERRUPT APP
 */
INTERRUPT_STATUS_t INTERRUPT_Init(const INTERRUPT_t *const handler)
{
 802650a:	b4f0      	push	{r4, r5, r6, r7}
 802650c:	68db      	ldr	r3, [r3, #12]
  XMC_ASSERT("INTERRUPT_Init:HandlePtr NULL", (handler != NULL));
  
#if(UC_FAMILY == XMC4)

  NVIC_SetPriority(handler->node,
 802650e:	7804      	ldrb	r4, [r0, #0]
 8026510:	7841      	ldrb	r1, [r0, #1]
                   NVIC_EncodePriority(NVIC_GetPriorityGrouping(),
                                       handler->priority,
                                       handler->subpriority));
 8026512:	7887      	ldrb	r7, [r0, #2]
 8026514:	f3c3 2302 	ubfx	r3, r3, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8026518:	f1c3 0507 	rsb	r5, r3, #7
 802651c:	2d06      	cmp	r5, #6
 802651e:	bf28      	it	cs
 8026520:	2506      	movcs	r5, #6
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8026522:	b34b      	cbz	r3, 8026578 <INTERRUPT_Init+0x70>
 8026524:	1e5e      	subs	r6, r3, #1
 8026526:	2201      	movs	r2, #1
 8026528:	40b2      	lsls	r2, r6
 802652a:	3a01      	subs	r2, #1
 802652c:	ea02 0307 	and.w	r3, r2, r7

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8026530:	2201      	movs	r2, #1
 8026532:	40aa      	lsls	r2, r5
 8026534:	3a01      	subs	r2, #1
 8026536:	400a      	ands	r2, r1
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
 8026538:	b261      	sxtb	r1, r4

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 802653a:	40b2      	lsls	r2, r6
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
 802653c:	2900      	cmp	r1, #0
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
 802653e:	ea43 0302 	orr.w	r3, r3, r2
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
 8026542:	db1b      	blt.n	802657c <INTERRUPT_Init+0x74>
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8026544:	f101 4260 	add.w	r2, r1, #3758096384	; 0xe0000000
 8026548:	f502 4261 	add.w	r2, r2, #57600	; 0xe100
 802654c:	009b      	lsls	r3, r3, #2
 802654e:	b2db      	uxtb	r3, r3
 8026550:	f882 3300 	strb.w	r3, [r2, #768]	; 0x300
  if (handler->enable_at_init == true)
 8026554:	78c3      	ldrb	r3, [r0, #3]
 8026556:	b163      	cbz	r3, 8026572 <INTERRUPT_Init+0x6a>
 8026558:	7802      	ldrb	r2, [r0, #0]
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
 802655a:	b253      	sxtb	r3, r2
 802655c:	2b00      	cmp	r3, #0
 802655e:	db08      	blt.n	8026572 <INTERRUPT_Init+0x6a>
  {
    NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8026560:	f002 021f 	and.w	r2, r2, #31
 8026564:	095b      	lsrs	r3, r3, #5
 8026566:	2101      	movs	r1, #1
 8026568:	4809      	ldr	r0, [pc, #36]	; (8026590 <INTERRUPT_Init+0x88>)
 802656a:	fa01 f202 	lsl.w	r2, r1, r2
 802656e:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
    INTERRUPT_Enable(handler);
  }
#endif

  return (INTERRUPT_STATUS_SUCCESS);
}
 8026572:	2000      	movs	r0, #0
 8026574:	bcf0      	pop	{r4, r5, r6, r7}
 8026576:	4770      	bx	lr
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8026578:	461e      	mov	r6, r3
 802657a:	e7d9      	b.n	8026530 <INTERRUPT_Init+0x28>
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
  else
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 802657c:	4a05      	ldr	r2, [pc, #20]	; (8026594 <INTERRUPT_Init+0x8c>)
 802657e:	f004 040f 	and.w	r4, r4, #15
 8026582:	009b      	lsls	r3, r3, #2
 8026584:	4422      	add	r2, r4
 8026586:	b2db      	uxtb	r3, r3
 8026588:	7613      	strb	r3, [r2, #24]
 802658a:	e7e3      	b.n	8026554 <INTERRUPT_Init+0x4c>
 802658c:	e000ed00 	.word	0xe000ed00
 8026590:	e000e100 	.word	0xe000e100
 8026594:	e000ecfc 	.word	0xe000ecfc

08026598 <GLOBAL_DMA_Init>:
  return version;
}

/* GLOBAL_DMA initialization function */
GLOBAL_DMA_STATUS_t GLOBAL_DMA_Init(GLOBAL_DMA_t *const obj)
{
 8026598:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  XMC_ASSERT("DMA_GLOBAL_Init: NULL DMA_GLOBAL_t object", (obj != NULL));

  if (obj->initialized == false)
 802659a:	7a03      	ldrb	r3, [r0, #8]
 802659c:	b10b      	cbz	r3, 80265a2 <GLOBAL_DMA_Init+0xa>
    NVIC_EnableIRQ(obj->irq_node);
    obj->initialized = true;
  }

  return GLOBAL_DMA_STATUS_SUCCESS;
}
 802659e:	2000      	movs	r0, #0
 80265a0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80265a2:	4604      	mov	r4, r0
  XMC_ASSERT("DMA_GLOBAL_Init: NULL DMA_GLOBAL_t object", (obj != NULL));

  if (obj->initialized == false)
  {
    /* Enable DMA module */
    XMC_DMA_Init(obj->dma);
 80265a4:	6800      	ldr	r0, [r0, #0]
 80265a6:	f7fb f9a9 	bl	80218fc <XMC_DMA_Init>
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 80265aa:	4a20      	ldr	r2, [pc, #128]	; (802662c <GLOBAL_DMA_Init+0x94>)

    /* Enable DMA event handling */
    NVIC_SetPriority(obj->irq_node, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),
                                                        obj->config->priority,
 80265ac:	6863      	ldr	r3, [r4, #4]
 80265ae:	68d2      	ldr	r2, [r2, #12]
  {
    /* Enable DMA module */
    XMC_DMA_Init(obj->dma);

    /* Enable DMA event handling */
    NVIC_SetPriority(obj->irq_node, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),
 80265b0:	7819      	ldrb	r1, [r3, #0]
                                                        obj->config->priority,
                                                        obj->config->sub_priority));
 80265b2:	785f      	ldrb	r7, [r3, #1]
  {
    /* Enable DMA module */
    XMC_DMA_Init(obj->dma);

    /* Enable DMA event handling */
    NVIC_SetPriority(obj->irq_node, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),
 80265b4:	7a60      	ldrb	r0, [r4, #9]
 80265b6:	f3c2 2302 	ubfx	r3, r2, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 80265ba:	f1c3 0507 	rsb	r5, r3, #7
 80265be:	2d06      	cmp	r5, #6
 80265c0:	bf28      	it	cs
 80265c2:	2506      	movcs	r5, #6
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80265c4:	bb1b      	cbnz	r3, 802660e <GLOBAL_DMA_Init+0x76>
 80265c6:	461e      	mov	r6, r3

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 80265c8:	2201      	movs	r2, #1
 80265ca:	40aa      	lsls	r2, r5
 80265cc:	3a01      	subs	r2, #1
 80265ce:	400a      	ands	r2, r1
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
 80265d0:	b241      	sxtb	r1, r0

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 80265d2:	40b2      	lsls	r2, r6
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
 80265d4:	2900      	cmp	r1, #0
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
 80265d6:	ea43 0302 	orr.w	r3, r3, r2
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
 80265da:	db1f      	blt.n	802661c <GLOBAL_DMA_Init+0x84>
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80265dc:	f101 4260 	add.w	r2, r1, #3758096384	; 0xe0000000
 80265e0:	f502 4261 	add.w	r2, r2, #57600	; 0xe100
 80265e4:	009b      	lsls	r3, r3, #2
 80265e6:	b2db      	uxtb	r3, r3
 80265e8:	f882 3300 	strb.w	r3, [r2, #768]	; 0x300
                                                        obj->config->priority,
                                                        obj->config->sub_priority));
    NVIC_EnableIRQ(obj->irq_node);
 80265ec:	7a62      	ldrb	r2, [r4, #9]
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
 80265ee:	b253      	sxtb	r3, r2
 80265f0:	2b00      	cmp	r3, #0
 80265f2:	db08      	blt.n	8026606 <GLOBAL_DMA_Init+0x6e>
  {
    NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 80265f4:	f002 021f 	and.w	r2, r2, #31
 80265f8:	095b      	lsrs	r3, r3, #5
 80265fa:	2101      	movs	r1, #1
 80265fc:	480c      	ldr	r0, [pc, #48]	; (8026630 <GLOBAL_DMA_Init+0x98>)
 80265fe:	fa01 f202 	lsl.w	r2, r1, r2
 8026602:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
    obj->initialized = true;
 8026606:	2301      	movs	r3, #1
 8026608:	7223      	strb	r3, [r4, #8]
  }

  return GLOBAL_DMA_STATUS_SUCCESS;
}
 802660a:	2000      	movs	r0, #0
 802660c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 802660e:	1e5e      	subs	r6, r3, #1
 8026610:	2201      	movs	r2, #1
 8026612:	40b2      	lsls	r2, r6
 8026614:	3a01      	subs	r2, #1
 8026616:	ea02 0307 	and.w	r3, r2, r7
 802661a:	e7d5      	b.n	80265c8 <GLOBAL_DMA_Init+0x30>
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
  else
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 802661c:	4a05      	ldr	r2, [pc, #20]	; (8026634 <GLOBAL_DMA_Init+0x9c>)
 802661e:	f000 000f 	and.w	r0, r0, #15
 8026622:	009b      	lsls	r3, r3, #2
 8026624:	4402      	add	r2, r0
 8026626:	b2db      	uxtb	r3, r3
 8026628:	7613      	strb	r3, [r2, #24]
 802662a:	e7df      	b.n	80265ec <GLOBAL_DMA_Init+0x54>
 802662c:	e000ed00 	.word	0xe000ed00
 8026630:	e000e100 	.word	0xe000e100
 8026634:	e000ecfc 	.word	0xe000ecfc

08026638 <GPDMA0_0_IRQHandler>:
  .irq_node = (IRQn_Type)110U /* Allotted DMA IRQ node */
};

void GPDMA0_0_IRQHandler(void)
{
  XMC_DMA_IRQHandler(XMC_DMA0);
 8026638:	4801      	ldr	r0, [pc, #4]	; (8026640 <GPDMA0_0_IRQHandler+0x8>)
 802663a:	f7fb bb19 	b.w	8021c70 <XMC_DMA_IRQHandler>
 802663e:	bf00      	nop
 8026640:	50014000 	.word	0x50014000

08026644 <GPDMA1_0_IRQHandler>:
}

#ifdef XMC_DMA1
void GPDMA1_0_IRQHandler(void)
{
  XMC_DMA_IRQHandler(XMC_DMA1);
 8026644:	4801      	ldr	r0, [pc, #4]	; (802664c <GPDMA1_0_IRQHandler+0x8>)
 8026646:	f7fb bb13 	b.w	8021c70 <XMC_DMA_IRQHandler>
 802664a:	bf00      	nop
 802664c:	50018000 	.word	0x50018000

08026650 <GLOBAL_CCU8_Init>:
/* Initializes the slice with the generated configuration */
GLOBAL_CCU8_STATUS_t GLOBAL_CCU8_Init(GLOBAL_CCU8_t* handle)
{
  XMC_ASSERT("GLOBAL_CCU8_Init:NULL handler", (NULL != handle));

  if (false == handle->is_initialized)
 8026650:	7b43      	ldrb	r3, [r0, #13]
 8026652:	b10b      	cbz	r3, 8026658 <GLOBAL_CCU8_Init+0x8>
    /* Restricts multiple initializations */
    handle->is_initialized = true;
  }

  return (GLOBAL_CCU8_STATUS_SUCCESS);
}
 8026654:	2000      	movs	r0, #0
 8026656:	4770      	bx	lr
  return version;
}

/* Initializes the slice with the generated configuration */
GLOBAL_CCU8_STATUS_t GLOBAL_CCU8_Init(GLOBAL_CCU8_t* handle)
{
 8026658:	b510      	push	{r4, lr}
 802665a:	4604      	mov	r4, r0
  XMC_ASSERT("GLOBAL_CCU8_Init:NULL handler", (NULL != handle));

  if (false == handle->is_initialized)
  {
    /* Enable CCU8 module */
    XMC_CCU8_Init(handle->module_ptr,handle->mcs_action);
 802665c:	6880      	ldr	r0, [r0, #8]
 802665e:	7b21      	ldrb	r1, [r4, #12]
 8026660:	f7fa ffe8 	bl	8021634 <XMC_CCU8_Init>
    /* Start the prescaler */
    XMC_CCU8_StartPrescaler(handle->module_ptr);
 8026664:	68a2      	ldr	r2, [r4, #8]
 *  XMC_CCU8_StopPrescaler().
 */
__STATIC_INLINE void XMC_CCU8_StartPrescaler(XMC_CCU8_MODULE_t *const module)
{
  XMC_ASSERT("XMC_CCU8_StartPrescaler:Invalid Module Pointer", XMC_CCU8_IsValidModule(module));
  module->GIDLC |= (uint32_t) CCU8_GIDLC_SPRB_Msk;
 8026666:	68d3      	ldr	r3, [r2, #12]
    /* Restricts multiple initializations */
    handle->is_initialized = true;
 8026668:	2101      	movs	r1, #1
 802666a:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 802666e:	60d3      	str	r3, [r2, #12]
  }

  return (GLOBAL_CCU8_STATUS_SUCCESS);
}
 8026670:	2000      	movs	r0, #0
    /* Enable CCU8 module */
    XMC_CCU8_Init(handle->module_ptr,handle->mcs_action);
    /* Start the prescaler */
    XMC_CCU8_StartPrescaler(handle->module_ptr);
    /* Restricts multiple initializations */
    handle->is_initialized = true;
 8026672:	7361      	strb	r1, [r4, #13]
  }

  return (GLOBAL_CCU8_STATUS_SUCCESS);
}
 8026674:	bd10      	pop	{r4, pc}
 8026676:	bf00      	nop

08026678 <GLOBAL_CCU4_Init>:
/* Initializes the slice with the generated configuration */
GLOBAL_CCU4_STATUS_t GLOBAL_CCU4_Init(GLOBAL_CCU4_t* handle)
{
  XMC_ASSERT("GLOBAL_CCU4_Init:NULL handler", (NULL != handle));

  if (false == handle->is_initialized)
 8026678:	7b43      	ldrb	r3, [r0, #13]
 802667a:	b10b      	cbz	r3, 8026680 <GLOBAL_CCU4_Init+0x8>
    /* Restricts multiple initializations */
    handle->is_initialized = true;
  }

  return (GLOBAL_CCU4_STATUS_SUCCESS);
}
 802667c:	2000      	movs	r0, #0
 802667e:	4770      	bx	lr
  return version;
}

/* Initializes the slice with the generated configuration */
GLOBAL_CCU4_STATUS_t GLOBAL_CCU4_Init(GLOBAL_CCU4_t* handle)
{
 8026680:	b510      	push	{r4, lr}
 8026682:	4604      	mov	r4, r0
  XMC_ASSERT("GLOBAL_CCU4_Init:NULL handler", (NULL != handle));

  if (false == handle->is_initialized)
  {
    /* Enable CCU4 module */
    XMC_CCU4_Init(handle->module_ptr,handle->mcs_action);
 8026684:	6880      	ldr	r0, [r0, #8]
 8026686:	7b21      	ldrb	r1, [r4, #12]
 8026688:	f7fa ff52 	bl	8021530 <XMC_CCU4_Init>
    /* Start the prescaler */
    XMC_CCU4_StartPrescaler(handle->module_ptr);
 802668c:	68a2      	ldr	r2, [r4, #8]
 * XMC_CCU4_StopPrescaler().
 */
__STATIC_INLINE void XMC_CCU4_StartPrescaler(XMC_CCU4_MODULE_t *const module)
{
  XMC_ASSERT("XMC_CCU4_StartPrescaler:Invalid Module Pointer", XMC_CCU4_IsValidModule(module));
  module->GIDLC |= (uint32_t) CCU4_GIDLC_SPRB_Msk;
 802668e:	68d3      	ldr	r3, [r2, #12]
    /* Restricts multiple initializations */
    handle->is_initialized = true;
 8026690:	2101      	movs	r1, #1
 8026692:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8026696:	60d3      	str	r3, [r2, #12]
  }

  return (GLOBAL_CCU4_STATUS_SUCCESS);
}
 8026698:	2000      	movs	r0, #0
    /* Enable CCU4 module */
    XMC_CCU4_Init(handle->module_ptr,handle->mcs_action);
    /* Start the prescaler */
    XMC_CCU4_StartPrescaler(handle->module_ptr);
    /* Restricts multiple initializations */
    handle->is_initialized = true;
 802669a:	7361      	strb	r1, [r4, #13]
  }

  return (GLOBAL_CCU4_STATUS_SUCCESS);
}
 802669c:	bd10      	pop	{r4, pc}
 802669e:	bf00      	nop

080266a0 <GLOBAL_ADC_Init>:
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/**
 * This function initializes all instances of the ADC Global APP and low level app.
 */
GLOBAL_ADC_STATUS_t GLOBAL_ADC_Init(GLOBAL_ADC_t *const handle_ptr)
{
 80266a0:	4603      	mov	r3, r0
  XMC_ASSERT("GLOBAL_ADC_Init:Invalid handle_ptr", (handle_ptr != NULL))
#if (XMC_VADC_GROUP_AVAILABLE == 1U)
  uint32_t group_index;
#endif

  if (GLOBAL_ADC_UNINITIALIZED == handle_ptr->init_state)
 80266a2:	7e00      	ldrb	r0, [r0, #24]
 80266a4:	2802      	cmp	r0, #2
 80266a6:	d000      	beq.n	80266aa <GLOBAL_ADC_Init+0xa>
    	XMC_VADC_GLOBAL_StartupCalibration(handle_ptr->module_ptr);
    }
    handle_ptr->init_state = GLOBAL_ADC_SUCCESS;
  }
  return (handle_ptr->init_state);
}
 80266a8:	4770      	bx	lr
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/**
 * This function initializes all instances of the ADC Global APP and low level app.
 */
GLOBAL_ADC_STATUS_t GLOBAL_ADC_Init(GLOBAL_ADC_t *const handle_ptr)
{
 80266aa:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
#endif

  if (GLOBAL_ADC_UNINITIALIZED == handle_ptr->init_state)
  {  
    /* Initialize an instance of Global hardware */
    XMC_VADC_GLOBAL_Init(handle_ptr->module_ptr, handle_ptr->global_config_handle);
 80266ae:	6958      	ldr	r0, [r3, #20]
 80266b0:	6919      	ldr	r1, [r3, #16]
 80266b2:	461e      	mov	r6, r3
 80266b4:	f7fc fe88 	bl	80233c8 <XMC_VADC_GLOBAL_Init>
 80266b8:	4634      	mov	r4, r6
 80266ba:	2510      	movs	r5, #16

__STATIC_INLINE void XMC_VADC_GLOBAL_DisablePostCalibration(XMC_VADC_GLOBAL_t *const global_ptr, uint32_t group_number)
{
  XMC_ASSERT("XMC_VADC_GLOBAL_DisablePostCalibration:Wrong Module Pointer", (global_ptr == VADC))

  global_ptr->GLOBCFG |= (uint32_t)((uint32_t)1 << ((uint32_t)VADC_GLOBCFG_DPCAL0_Pos + group_number));
 80266bc:	f04f 0801 	mov.w	r8, #1

#if(XMC_VADC_SHS_AVAILABLE == 1U)
      XMC_VADC_GLOBAL_SHS_EnableAcceleratedMode(handle_ptr->global_shs_ptr, (XMC_VADC_GROUP_INDEX_t)group_index);
#endif

      handle_ptr->group_ptrs_array[group_index]->state = GLOBAL_ADC_SUCCESS;
 80266c0:	2700      	movs	r7, #0
    /* Initialize all the Groups */
#if (XMC_VADC_GROUP_AVAILABLE == 1U)
    for(group_index = (uint32_t)0; group_index < XMC_VADC_MAXIMUM_NUM_GROUPS; group_index++)
    {
      /*Initialize Group*/
      XMC_VADC_GROUP_Init(handle_ptr->group_ptrs_array[group_index]->group_handle,
 80266c2:	6823      	ldr	r3, [r4, #0]
 80266c4:	e893 0003 	ldmia.w	r3, {r0, r1}
 80266c8:	f7fc feca 	bl	8023460 <XMC_VADC_GROUP_Init>
    		            handle_ptr->group_ptrs_array[group_index]->group_config_handle);

      /* Switch on the converter of the Group[group_index]*/
      XMC_VADC_GROUP_SetPowerMode(handle_ptr->group_ptrs_array[group_index]->group_handle,
 80266cc:	6823      	ldr	r3, [r4, #0]
 80266ce:	2103      	movs	r1, #3
 80266d0:	6818      	ldr	r0, [r3, #0]
 80266d2:	f7fc ff63 	bl	802359c <XMC_VADC_GROUP_SetPowerMode>
                                  XMC_VADC_GROUP_POWERMODE_NORMAL);

      /* Disable the post calibration option for the respective group*/
      if ((bool)false == handle_ptr->group_ptrs_array[group_index]->post_calibration)
 80266d6:	f854 3b04 	ldr.w	r3, [r4], #4
 80266da:	7a1a      	ldrb	r2, [r3, #8]
 80266dc:	b93a      	cbnz	r2, 80266ee <GLOBAL_ADC_Init+0x4e>
      {
        XMC_VADC_GLOBAL_DisablePostCalibration(handle_ptr->module_ptr,group_index);
 80266de:	6971      	ldr	r1, [r6, #20]
 80266e0:	f8d1 2080 	ldr.w	r2, [r1, #128]	; 0x80
 80266e4:	fa08 f005 	lsl.w	r0, r8, r5
 80266e8:	4302      	orrs	r2, r0
 80266ea:	f8c1 2080 	str.w	r2, [r1, #128]	; 0x80
 80266ee:	3501      	adds	r5, #1
    /* Initialize an instance of Global hardware */
    XMC_VADC_GLOBAL_Init(handle_ptr->module_ptr, handle_ptr->global_config_handle);

    /* Initialize all the Groups */
#if (XMC_VADC_GROUP_AVAILABLE == 1U)
    for(group_index = (uint32_t)0; group_index < XMC_VADC_MAXIMUM_NUM_GROUPS; group_index++)
 80266f0:	2d14      	cmp	r5, #20

#if(XMC_VADC_SHS_AVAILABLE == 1U)
      XMC_VADC_GLOBAL_SHS_EnableAcceleratedMode(handle_ptr->global_shs_ptr, (XMC_VADC_GROUP_INDEX_t)group_index);
#endif

      handle_ptr->group_ptrs_array[group_index]->state = GLOBAL_ADC_SUCCESS;
 80266f2:	725f      	strb	r7, [r3, #9]
    /* Initialize an instance of Global hardware */
    XMC_VADC_GLOBAL_Init(handle_ptr->module_ptr, handle_ptr->global_config_handle);

    /* Initialize all the Groups */
#if (XMC_VADC_GROUP_AVAILABLE == 1U)
    for(group_index = (uint32_t)0; group_index < XMC_VADC_MAXIMUM_NUM_GROUPS; group_index++)
 80266f4:	d1e5      	bne.n	80266c2 <GLOBAL_ADC_Init+0x22>
#endif
#endif /* _XMC_VADC_GROUP_AVAILABLE_ */
#if(XMC_VADC_SHS_AVAILABLE == 1U)
    XMC_VADC_GLOBAL_SHS_SetAnalogReference(handle_ptr->global_shs_ptr, GLOBAL_ADC_AREF_VALUE);
#endif
    if((bool)true == handle_ptr->enable_startup_calibration)
 80266f6:	7e73      	ldrb	r3, [r6, #25]
 80266f8:	b91b      	cbnz	r3, 8026702 <GLOBAL_ADC_Init+0x62>
    {
    	XMC_VADC_GLOBAL_StartupCalibration(handle_ptr->module_ptr);
    }
    handle_ptr->init_state = GLOBAL_ADC_SUCCESS;
 80266fa:	2000      	movs	r0, #0
 80266fc:	7630      	strb	r0, [r6, #24]
  }
  return (handle_ptr->init_state);
}
 80266fe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
#if(XMC_VADC_SHS_AVAILABLE == 1U)
    XMC_VADC_GLOBAL_SHS_SetAnalogReference(handle_ptr->global_shs_ptr, GLOBAL_ADC_AREF_VALUE);
#endif
    if((bool)true == handle_ptr->enable_startup_calibration)
    {
    	XMC_VADC_GLOBAL_StartupCalibration(handle_ptr->module_ptr);
 8026702:	6970      	ldr	r0, [r6, #20]
 8026704:	f7fc fe8e 	bl	8023424 <XMC_VADC_GLOBAL_StartupCalibration>
 8026708:	e7f7      	b.n	80266fa <GLOBAL_ADC_Init+0x5a>
 802670a:	bf00      	nop

0802670c <DMA_CH_Init>:
  return version;
}

/* DMA_CH initialization function */
DMA_CH_STATUS_t DMA_CH_Init(DMA_CH_t *const obj)
{
 802670c:	b510      	push	{r4, lr}
 802670e:	4604      	mov	r4, r0
  DMA_CH_STATUS_t status;

  XMC_ASSERT("DMA_CH_Init: NULL DMA_CH_t object", (obj != NULL));

  /* This cannot possibly fail! */
  GLOBAL_DMA_Init(obj->dma_global);
 8026710:	6800      	ldr	r0, [r0, #0]
 8026712:	f7ff ff41 	bl	8026598 <GLOBAL_DMA_Init>

  if (XMC_DMA_CH_Init(obj->dma_global->dma, obj->ch_num, &obj->config->ch_config) == XMC_DMA_CH_STATUS_OK)
 8026716:	6823      	ldr	r3, [r4, #0]
 8026718:	7b21      	ldrb	r1, [r4, #12]
 802671a:	6818      	ldr	r0, [r3, #0]
 802671c:	6862      	ldr	r2, [r4, #4]
 802671e:	f7fb f919 	bl	8021954 <XMC_DMA_CH_Init>
 8026722:	b938      	cbnz	r0, 8026734 <DMA_CH_Init+0x28>
  {
	if(obj->config->events)
 8026724:	6863      	ldr	r3, [r4, #4]
 8026726:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8026728:	b932      	cbnz	r2, 8026738 <DMA_CH_Init+0x2c>
	{
		XMC_DMA_CH_EnableEvent(obj->dma_global->dma, obj->ch_num, obj->config->events);
		XMC_DMA_CH_SetEventHandler(obj->dma_global->dma, obj->ch_num, obj->config->callback);
	}
    obj->reload(obj);
 802672a:	4620      	mov	r0, r4
 802672c:	68a3      	ldr	r3, [r4, #8]
 802672e:	4798      	blx	r3
    status = DMA_CH_STATUS_SUCCESS;
 8026730:	2000      	movs	r0, #0
 8026732:	bd10      	pop	{r4, pc}
  }
  else
  {
    status = DMA_CH_STATUS_FAILURE;
 8026734:	2001      	movs	r0, #1
  }

  return status;
}
 8026736:	bd10      	pop	{r4, pc}

  if (XMC_DMA_CH_Init(obj->dma_global->dma, obj->ch_num, &obj->config->ch_config) == XMC_DMA_CH_STATUS_OK)
  {
	if(obj->config->events)
	{
		XMC_DMA_CH_EnableEvent(obj->dma_global->dma, obj->ch_num, obj->config->events);
 8026738:	6823      	ldr	r3, [r4, #0]
 802673a:	7b21      	ldrb	r1, [r4, #12]
 802673c:	6818      	ldr	r0, [r3, #0]
 802673e:	f7fb fa55 	bl	8021bec <XMC_DMA_CH_EnableEvent>
		XMC_DMA_CH_SetEventHandler(obj->dma_global->dma, obj->ch_num, obj->config->callback);
 8026742:	e894 000c 	ldmia.w	r4, {r2, r3}
 8026746:	7b21      	ldrb	r1, [r4, #12]
 8026748:	6810      	ldr	r0, [r2, #0]
 802674a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 802674c:	f7fb fa66 	bl	8021c1c <XMC_DMA_CH_SetEventHandler>
 8026750:	e7eb      	b.n	802672a <DMA_CH_Init+0x1e>
 8026752:	bf00      	nop

08026754 <DMA_CH_G0_reload>:

extern uint32_t* pDMA_dst_G0; /* Destination address symbol */

void DMA_CH_G0_reload(DMA_CH_t *obj)
{
  XMC_DMA_CH_SetBlockSize(obj->dma_global->dma, obj->ch_num, 256);
 8026754:	6802      	ldr	r2, [r0, #0]
 * see ::XMC_DMA_CH_Enable() for more information.
 *
 */
__STATIC_INLINE void XMC_DMA_CH_SetBlockSize(XMC_DMA_t *const dma, const uint8_t channel, uint32_t block_size)
{
  dma->CH[channel].CTLH = block_size;
 8026756:	7b03      	ldrb	r3, [r0, #12]
 8026758:	6811      	ldr	r1, [r2, #0]
  XMC_DMA_CH_SetSourceAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_src_G0);
 802675a:	4a0a      	ldr	r2, [pc, #40]	; (8026784 <DMA_CH_G0_reload+0x30>)
extern uint32_t* pDMA_src_G0; /* Source address symbol */

extern uint32_t* pDMA_dst_G0; /* Destination address symbol */

void DMA_CH_G0_reload(DMA_CH_t *obj)
{
 802675c:	b470      	push	{r4, r5, r6}
 802675e:	2458      	movs	r4, #88	; 0x58
 8026760:	fb04 1303 	mla	r3, r4, r3, r1
 8026764:	f44f 7680 	mov.w	r6, #256	; 0x100
 8026768:	61de      	str	r6, [r3, #28]
 * \par<b>Related API: </b><br>
 * ::XMC_DMA_CH_SetDestinationAddress() <br>
 */
__STATIC_INLINE void XMC_DMA_CH_SetSourceAddress(XMC_DMA_t *const dma, const uint8_t channel, uint32_t addr)
{
  dma->CH[channel].SAR = addr;
 802676a:	7b03      	ldrb	r3, [r0, #12]
  XMC_DMA_CH_SetBlockSize(obj->dma_global->dma, obj->ch_num, 256);
  XMC_DMA_CH_SetSourceAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_src_G0);
  XMC_DMA_CH_SetDestinationAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_dst_G0);
 802676c:	4d06      	ldr	r5, [pc, #24]	; (8026788 <DMA_CH_G0_reload+0x34>)
extern uint32_t* pDMA_dst_G0; /* Destination address symbol */

void DMA_CH_G0_reload(DMA_CH_t *obj)
{
  XMC_DMA_CH_SetBlockSize(obj->dma_global->dma, obj->ch_num, 256);
  XMC_DMA_CH_SetSourceAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_src_G0);
 802676e:	6812      	ldr	r2, [r2, #0]
  XMC_DMA_CH_SetDestinationAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_dst_G0);
 8026770:	682d      	ldr	r5, [r5, #0]
 8026772:	fb04 f303 	mul.w	r3, r4, r3
 8026776:	50ca      	str	r2, [r1, r3]
 * \par<b>Related API: </b><br>
 * ::XMC_DMA_CH_SetSourceAddress() <br>
 */
__STATIC_INLINE void XMC_DMA_CH_SetDestinationAddress(XMC_DMA_t *const dma, const uint8_t channel, uint32_t addr)
{
  dma->CH[channel].DAR = addr;
 8026778:	7b02      	ldrb	r2, [r0, #12]
 802677a:	fb04 1302 	mla	r3, r4, r2, r1
 802677e:	609d      	str	r5, [r3, #8]
}
 8026780:	bc70      	pop	{r4, r5, r6}
 8026782:	4770      	bx	lr
 8026784:	1ffedbf4 	.word	0x1ffedbf4
 8026788:	1ffedc04 	.word	0x1ffedc04

0802678c <DMA_CH_G1_reload>:

extern uint32_t* pDMA_dst_G1; /* Destination address symbol */

void DMA_CH_G1_reload(DMA_CH_t *obj)
{
  XMC_DMA_CH_SetBlockSize(obj->dma_global->dma, obj->ch_num, 256);
 802678c:	6802      	ldr	r2, [r0, #0]
 * see ::XMC_DMA_CH_Enable() for more information.
 *
 */
__STATIC_INLINE void XMC_DMA_CH_SetBlockSize(XMC_DMA_t *const dma, const uint8_t channel, uint32_t block_size)
{
  dma->CH[channel].CTLH = block_size;
 802678e:	7b03      	ldrb	r3, [r0, #12]
 8026790:	6811      	ldr	r1, [r2, #0]
  XMC_DMA_CH_SetSourceAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_src_G1);
 8026792:	4a0a      	ldr	r2, [pc, #40]	; (80267bc <DMA_CH_G1_reload+0x30>)
extern uint32_t* pDMA_src_G1; /* Source address symbol */

extern uint32_t* pDMA_dst_G1; /* Destination address symbol */

void DMA_CH_G1_reload(DMA_CH_t *obj)
{
 8026794:	b470      	push	{r4, r5, r6}
 8026796:	2458      	movs	r4, #88	; 0x58
 8026798:	fb04 1303 	mla	r3, r4, r3, r1
 802679c:	f44f 7680 	mov.w	r6, #256	; 0x100
 80267a0:	61de      	str	r6, [r3, #28]
 * \par<b>Related API: </b><br>
 * ::XMC_DMA_CH_SetDestinationAddress() <br>
 */
__STATIC_INLINE void XMC_DMA_CH_SetSourceAddress(XMC_DMA_t *const dma, const uint8_t channel, uint32_t addr)
{
  dma->CH[channel].SAR = addr;
 80267a2:	7b03      	ldrb	r3, [r0, #12]
  XMC_DMA_CH_SetBlockSize(obj->dma_global->dma, obj->ch_num, 256);
  XMC_DMA_CH_SetSourceAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_src_G1);
  XMC_DMA_CH_SetDestinationAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_dst_G1);
 80267a4:	4d06      	ldr	r5, [pc, #24]	; (80267c0 <DMA_CH_G1_reload+0x34>)
extern uint32_t* pDMA_dst_G1; /* Destination address symbol */

void DMA_CH_G1_reload(DMA_CH_t *obj)
{
  XMC_DMA_CH_SetBlockSize(obj->dma_global->dma, obj->ch_num, 256);
  XMC_DMA_CH_SetSourceAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_src_G1);
 80267a6:	6812      	ldr	r2, [r2, #0]
  XMC_DMA_CH_SetDestinationAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_dst_G1);
 80267a8:	682d      	ldr	r5, [r5, #0]
 80267aa:	fb04 f303 	mul.w	r3, r4, r3
 80267ae:	50ca      	str	r2, [r1, r3]
 * \par<b>Related API: </b><br>
 * ::XMC_DMA_CH_SetSourceAddress() <br>
 */
__STATIC_INLINE void XMC_DMA_CH_SetDestinationAddress(XMC_DMA_t *const dma, const uint8_t channel, uint32_t addr)
{
  dma->CH[channel].DAR = addr;
 80267b0:	7b02      	ldrb	r2, [r0, #12]
 80267b2:	fb04 1302 	mla	r3, r4, r2, r1
 80267b6:	609d      	str	r5, [r3, #8]
}
 80267b8:	bc70      	pop	{r4, r5, r6}
 80267ba:	4770      	bx	lr
 80267bc:	1ffedbf8 	.word	0x1ffedbf8
 80267c0:	1ffedc08 	.word	0x1ffedc08

080267c4 <DMA_CH_G3_reload>:

extern uint32_t* pDMA_dst_G3; /* Destination address symbol */

void DMA_CH_G3_reload(DMA_CH_t *obj)
{
  XMC_DMA_CH_SetBlockSize(obj->dma_global->dma, obj->ch_num, 256);
 80267c4:	6802      	ldr	r2, [r0, #0]
 * see ::XMC_DMA_CH_Enable() for more information.
 *
 */
__STATIC_INLINE void XMC_DMA_CH_SetBlockSize(XMC_DMA_t *const dma, const uint8_t channel, uint32_t block_size)
{
  dma->CH[channel].CTLH = block_size;
 80267c6:	7b03      	ldrb	r3, [r0, #12]
 80267c8:	6811      	ldr	r1, [r2, #0]
  XMC_DMA_CH_SetSourceAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_src_G3);
 80267ca:	4a0a      	ldr	r2, [pc, #40]	; (80267f4 <DMA_CH_G3_reload+0x30>)
extern uint32_t* pDMA_src_G3; /* Source address symbol */

extern uint32_t* pDMA_dst_G3; /* Destination address symbol */

void DMA_CH_G3_reload(DMA_CH_t *obj)
{
 80267cc:	b470      	push	{r4, r5, r6}
 80267ce:	2458      	movs	r4, #88	; 0x58
 80267d0:	fb04 1303 	mla	r3, r4, r3, r1
 80267d4:	f44f 7680 	mov.w	r6, #256	; 0x100
 80267d8:	61de      	str	r6, [r3, #28]
 * \par<b>Related API: </b><br>
 * ::XMC_DMA_CH_SetDestinationAddress() <br>
 */
__STATIC_INLINE void XMC_DMA_CH_SetSourceAddress(XMC_DMA_t *const dma, const uint8_t channel, uint32_t addr)
{
  dma->CH[channel].SAR = addr;
 80267da:	7b03      	ldrb	r3, [r0, #12]
  XMC_DMA_CH_SetBlockSize(obj->dma_global->dma, obj->ch_num, 256);
  XMC_DMA_CH_SetSourceAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_src_G3);
  XMC_DMA_CH_SetDestinationAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_dst_G3);
 80267dc:	4d06      	ldr	r5, [pc, #24]	; (80267f8 <DMA_CH_G3_reload+0x34>)
extern uint32_t* pDMA_dst_G3; /* Destination address symbol */

void DMA_CH_G3_reload(DMA_CH_t *obj)
{
  XMC_DMA_CH_SetBlockSize(obj->dma_global->dma, obj->ch_num, 256);
  XMC_DMA_CH_SetSourceAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_src_G3);
 80267de:	6812      	ldr	r2, [r2, #0]
  XMC_DMA_CH_SetDestinationAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_dst_G3);
 80267e0:	682d      	ldr	r5, [r5, #0]
 80267e2:	fb04 f303 	mul.w	r3, r4, r3
 80267e6:	50ca      	str	r2, [r1, r3]
 * \par<b>Related API: </b><br>
 * ::XMC_DMA_CH_SetSourceAddress() <br>
 */
__STATIC_INLINE void XMC_DMA_CH_SetDestinationAddress(XMC_DMA_t *const dma, const uint8_t channel, uint32_t addr)
{
  dma->CH[channel].DAR = addr;
 80267e8:	7b02      	ldrb	r2, [r0, #12]
 80267ea:	fb04 1302 	mla	r3, r4, r2, r1
 80267ee:	609d      	str	r5, [r3, #8]
}
 80267f0:	bc70      	pop	{r4, r5, r6}
 80267f2:	4770      	bx	lr
 80267f4:	1ffedc00 	.word	0x1ffedc00
 80267f8:	1ffeb498 	.word	0x1ffeb498

080267fc <DMA_CH_G2_reload>:

extern uint32_t* pDMA_dst_G2; /* Destination address symbol */

void DMA_CH_G2_reload(DMA_CH_t *obj)
{
  XMC_DMA_CH_SetBlockSize(obj->dma_global->dma, obj->ch_num, 256);
 80267fc:	6802      	ldr	r2, [r0, #0]
 * see ::XMC_DMA_CH_Enable() for more information.
 *
 */
__STATIC_INLINE void XMC_DMA_CH_SetBlockSize(XMC_DMA_t *const dma, const uint8_t channel, uint32_t block_size)
{
  dma->CH[channel].CTLH = block_size;
 80267fe:	7b03      	ldrb	r3, [r0, #12]
 8026800:	6811      	ldr	r1, [r2, #0]
  XMC_DMA_CH_SetSourceAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_src_G2);
 8026802:	4a0a      	ldr	r2, [pc, #40]	; (802682c <DMA_CH_G2_reload+0x30>)
extern uint32_t* pDMA_src_G2; /* Source address symbol */

extern uint32_t* pDMA_dst_G2; /* Destination address symbol */

void DMA_CH_G2_reload(DMA_CH_t *obj)
{
 8026804:	b470      	push	{r4, r5, r6}
 8026806:	2458      	movs	r4, #88	; 0x58
 8026808:	fb04 1303 	mla	r3, r4, r3, r1
 802680c:	f44f 7680 	mov.w	r6, #256	; 0x100
 8026810:	61de      	str	r6, [r3, #28]
 * \par<b>Related API: </b><br>
 * ::XMC_DMA_CH_SetDestinationAddress() <br>
 */
__STATIC_INLINE void XMC_DMA_CH_SetSourceAddress(XMC_DMA_t *const dma, const uint8_t channel, uint32_t addr)
{
  dma->CH[channel].SAR = addr;
 8026812:	7b03      	ldrb	r3, [r0, #12]
  XMC_DMA_CH_SetBlockSize(obj->dma_global->dma, obj->ch_num, 256);
  XMC_DMA_CH_SetSourceAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_src_G2);
  XMC_DMA_CH_SetDestinationAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_dst_G2);
 8026814:	4d06      	ldr	r5, [pc, #24]	; (8026830 <DMA_CH_G2_reload+0x34>)
extern uint32_t* pDMA_dst_G2; /* Destination address symbol */

void DMA_CH_G2_reload(DMA_CH_t *obj)
{
  XMC_DMA_CH_SetBlockSize(obj->dma_global->dma, obj->ch_num, 256);
  XMC_DMA_CH_SetSourceAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_src_G2);
 8026816:	6812      	ldr	r2, [r2, #0]
  XMC_DMA_CH_SetDestinationAddress(obj->dma_global->dma, obj->ch_num, (uint32_t)pDMA_dst_G2);
 8026818:	682d      	ldr	r5, [r5, #0]
 802681a:	fb04 f303 	mul.w	r3, r4, r3
 802681e:	50ca      	str	r2, [r1, r3]
 * \par<b>Related API: </b><br>
 * ::XMC_DMA_CH_SetSourceAddress() <br>
 */
__STATIC_INLINE void XMC_DMA_CH_SetDestinationAddress(XMC_DMA_t *const dma, const uint8_t channel, uint32_t addr)
{
  dma->CH[channel].DAR = addr;
 8026820:	7b02      	ldrb	r2, [r0, #12]
 8026822:	fb04 1302 	mla	r3, r4, r2, r1
 8026826:	609d      	str	r5, [r3, #8]
}
 8026828:	bc70      	pop	{r4, r5, r6}
 802682a:	4770      	bx	lr
 802682c:	1ffedbfc 	.word	0x1ffedbfc
 8026830:	1ffedbf0 	.word	0x1ffedbf0

08026834 <DIGITAL_IO_Init>:
* @param handler Pointer pointing to APP data structure.
* @return DIGITAL_IO_STATUS_t DIGITAL_IO APP status.
*/

DIGITAL_IO_STATUS_t DIGITAL_IO_Init(const DIGITAL_IO_t *const handler)
{
 8026834:	b510      	push	{r4, lr}
 8026836:	4604      	mov	r4, r0
  XMC_ASSERT("DIGITAL_IO_Init: handler null pointer", handler != NULL);

  /* Initializes input / output characteristics */
  XMC_GPIO_Init(handler->gpio_port, handler->gpio_pin, &handler->gpio_config);
 8026838:	1d02      	adds	r2, r0, #4
 802683a:	7c21      	ldrb	r1, [r4, #16]
 802683c:	6800      	ldr	r0, [r0, #0]
 802683e:	f7fa fb7f 	bl	8020f40 <XMC_GPIO_Init>

  /*Configure hardware port control*/
  XMC_GPIO_SetHardwareControl(handler->gpio_port, handler->gpio_pin, handler->hwctrl);
 8026842:	6820      	ldr	r0, [r4, #0]
 8026844:	7c21      	ldrb	r1, [r4, #16]
 8026846:	7c62      	ldrb	r2, [r4, #17]
 8026848:	f7fb fae2 	bl	8021e10 <XMC_GPIO_SetHardwareControl>

  return (DIGITAL_IO_STATUS_OK);
}
 802684c:	2000      	movs	r0, #0
 802684e:	bd10      	pop	{r4, pc}

08026850 <CRC_SW_Init>:
*/
CRC_SW_STATUS_t CRC_SW_Init(CRC_SW_t *const handle)
{
  CRC_SW_STATUS_t status;

  if (handle != NULL)
 8026850:	4603      	mov	r3, r0
 8026852:	b1a0      	cbz	r0, 802687e <CRC_SW_Init+0x2e>
/*
 * This function initializes CRC_SW handle.
 *
*/
CRC_SW_STATUS_t CRC_SW_Init(CRC_SW_t *const handle)
{
 8026854:	b470      	push	{r4, r5, r6}
  CRC_SW_STATUS_t status;

  if (handle != NULL)
  {
    /* calculate MSB mask, CRC Mask and shift from polynomial width */
    handle->msb_mask = (uint32_t)(CRC_SW_ONE << (handle->config->crc_width - CRC_SW_ONE));
 8026856:	6804      	ldr	r4, [r0, #0]
 8026858:	6821      	ldr	r1, [r4, #0]

    handle->crc_mask = (uint32_t)((handle->msb_mask - CRC_SW_ONE) | (handle->msb_mask));

    handle->crc_shift = CRC_SW_ZERO;

    handle->config->output_reflection &= handle->crc_mask;
 802685a:	7c62      	ldrb	r2, [r4, #17]

    handle->crc_runningval = handle->config->crc_initval;
 802685c:	68a6      	ldr	r6, [r4, #8]
  CRC_SW_STATUS_t status;

  if (handle != NULL)
  {
    /* calculate MSB mask, CRC Mask and shift from polynomial width */
    handle->msb_mask = (uint32_t)(CRC_SW_ONE << (handle->config->crc_width - CRC_SW_ONE));
 802685e:	1e48      	subs	r0, r1, #1
 8026860:	2101      	movs	r1, #1
 8026862:	4081      	lsls	r1, r0

    handle->crc_mask = (uint32_t)((handle->msb_mask - CRC_SW_ONE) | (handle->msb_mask));
 8026864:	1e4d      	subs	r5, r1, #1
 8026866:	430d      	orrs	r5, r1

    handle->crc_shift = CRC_SW_ZERO;

    handle->config->output_reflection &= handle->crc_mask;
 8026868:	402a      	ands	r2, r5
    /* calculate MSB mask, CRC Mask and shift from polynomial width */
    handle->msb_mask = (uint32_t)(CRC_SW_ONE << (handle->config->crc_width - CRC_SW_ONE));

    handle->crc_mask = (uint32_t)((handle->msb_mask - CRC_SW_ONE) | (handle->msb_mask));

    handle->crc_shift = CRC_SW_ZERO;
 802686a:	2000      	movs	r0, #0

    handle->config->output_reflection &= handle->crc_mask;
 802686c:	f002 0201 	and.w	r2, r2, #1
  if (handle != NULL)
  {
    /* calculate MSB mask, CRC Mask and shift from polynomial width */
    handle->msb_mask = (uint32_t)(CRC_SW_ONE << (handle->config->crc_width - CRC_SW_ONE));

    handle->crc_mask = (uint32_t)((handle->msb_mask - CRC_SW_ONE) | (handle->msb_mask));
 8026870:	60dd      	str	r5, [r3, #12]
  CRC_SW_STATUS_t status;

  if (handle != NULL)
  {
    /* calculate MSB mask, CRC Mask and shift from polynomial width */
    handle->msb_mask = (uint32_t)(CRC_SW_ONE << (handle->config->crc_width - CRC_SW_ONE));
 8026872:	6099      	str	r1, [r3, #8]

    handle->crc_mask = (uint32_t)((handle->msb_mask - CRC_SW_ONE) | (handle->msb_mask));

    handle->crc_shift = CRC_SW_ZERO;
 8026874:	6118      	str	r0, [r3, #16]

    handle->config->output_reflection &= handle->crc_mask;
 8026876:	7462      	strb	r2, [r4, #17]

    handle->crc_runningval = handle->config->crc_initval;
 8026878:	605e      	str	r6, [r3, #4]
  {
    status = CRC_SW_STATUS_FAILURE;
  }

  return (status);
}
 802687a:	bc70      	pop	{r4, r5, r6}
 802687c:	4770      	bx	lr

    status = CRC_SW_STATUS_SUCCESS;
  }
  else
  {
    status = CRC_SW_STATUS_FAILURE;
 802687e:	2001      	movs	r0, #1
 8026880:	4770      	bx	lr
 8026882:	bf00      	nop

08026884 <CRC_SW_CalculateCRC>:

/*
 * This function calculates CRC on a block of data.
 */
void CRC_SW_CalculateCRC(CRC_SW_t *const handle, void * bufferptr, uint32_t length)
{
 8026884:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  XMC_ASSERT("CalculateCRC: NULL Handle", handle != NULL);
  XMC_ASSERT("CalculateCRC: NULL Buffer", bufferptr != NULL);

  /* Load the initial CRC value as running value for CRC */
  handle->crc_runningval = handle->config->crc_initval;
 8026888:	6804      	ldr	r4, [r0, #0]
 802688a:	68a3      	ldr	r3, [r4, #8]
 802688c:	6043      	str	r3, [r0, #4]
  uint32_t buffer;
  uint8_t *temp;
  
  temp = (uint8_t *)bufferptr;

  while (length--)
 802688e:	2a00      	cmp	r2, #0
 8026890:	d038      	beq.n	8026904 <CRC_SW_CalculateCRC+0x80>
 8026892:	f8d0 e010 	ldr.w	lr, [r0, #16]
 8026896:	68c5      	ldr	r5, [r0, #12]
 8026898:	f894 c010 	ldrb.w	ip, [r4, #16]
 802689c:	6946      	ldr	r6, [r0, #20]
 802689e:	6987      	ldr	r7, [r0, #24]
 80268a0:	fa05 f50e 	lsl.w	r5, r5, lr
 80268a4:	f1bc 0f00 	cmp.w	ip, #0
 80268a8:	d11a      	bne.n	80268e0 <CRC_SW_CalculateCRC+0x5c>
                                 (handle->crc_runningval >> CRC_SW_EIGHT)) & (handle->crc_mask << handle->crc_shift);
    }
    else
    {
      /* load the lookup table value based on CRC width */
      tableindex = ((handle->crc_runningval >> ((handle->config->crc_width - CRC_SW_EIGHT) +
 80268aa:	6824      	ldr	r4, [r4, #0]
 80268ac:	eb0e 0c04 	add.w	ip, lr, r4
 80268b0:	f1ac 0c08 	sub.w	ip, ip, #8
 80268b4:	440a      	add	r2, r1
 80268b6:	f1ce 0e08 	rsb	lr, lr, #8
  
  temp = (uint8_t *)bufferptr;

  while (length--)
  {
    buffer = (uint32_t) *temp;
 80268ba:	f811 8b01 	ldrb.w	r8, [r1], #1
                                 (handle->crc_runningval >> CRC_SW_EIGHT)) & (handle->crc_mask << handle->crc_shift);
    }
    else
    {
      /* load the lookup table value based on CRC width */
      tableindex = ((handle->crc_runningval >> ((handle->config->crc_width - CRC_SW_EIGHT) +
 80268be:	fa23 f40c 	lsr.w	r4, r3, ip
                     handle->crc_shift)) ^ buffer) & (uint32_t)0xff;
 80268c2:	ea88 0404 	eor.w	r4, r8, r4
                                 (handle->crc_runningval >> CRC_SW_EIGHT)) & (handle->crc_mask << handle->crc_shift);
    }
    else
    {
      /* load the lookup table value based on CRC width */
      tableindex = ((handle->crc_runningval >> ((handle->config->crc_width - CRC_SW_EIGHT) +
 80268c6:	b2e4      	uxtb	r4, r4
                     handle->crc_shift)) ^ buffer) & (uint32_t)0xff;

      /* compute the CRC running value from the lookup table */
      handle->crc_runningval = (*(uint32_t *)((uint32_t)handle->crctable + (tableindex * handle->tableoffset)) ^ \
 80268c8:	fb07 f404 	mul.w	r4, r7, r4
                                 (handle->crc_runningval  << (CRC_SW_EIGHT - handle->crc_shift))) & \
 80268cc:	fa03 f30e 	lsl.w	r3, r3, lr
      /* load the lookup table value based on CRC width */
      tableindex = ((handle->crc_runningval >> ((handle->config->crc_width - CRC_SW_EIGHT) +
                     handle->crc_shift)) ^ buffer) & (uint32_t)0xff;

      /* compute the CRC running value from the lookup table */
      handle->crc_runningval = (*(uint32_t *)((uint32_t)handle->crctable + (tableindex * handle->tableoffset)) ^ \
 80268d0:	59a4      	ldr	r4, [r4, r6]
 80268d2:	4063      	eors	r3, r4
                                 (handle->crc_runningval  << (CRC_SW_EIGHT - handle->crc_shift))) & \
 80268d4:	402b      	ands	r3, r5
  uint32_t buffer;
  uint8_t *temp;
  
  temp = (uint8_t *)bufferptr;

  while (length--)
 80268d6:	4291      	cmp	r1, r2
 80268d8:	6043      	str	r3, [r0, #4]
 80268da:	d1ee      	bne.n	80268ba <CRC_SW_CalculateCRC+0x36>
 80268dc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80268e0:	440a      	add	r2, r1
  {
    buffer = (uint32_t) *temp;
 80268e2:	f811 cb01 	ldrb.w	ip, [r1], #1

    /* if input reflection is set */
    if (handle->config->input_reflection == true)
    {
      tableindex = ((handle->crc_runningval >> handle->crc_shift) ^ buffer) & (int32_t)0xff;
 80268e6:	fa23 f40e 	lsr.w	r4, r3, lr
 80268ea:	ea8c 0404 	eor.w	r4, ip, r4
 80268ee:	b2e4      	uxtb	r4, r4

      /* compute the CRC running value from the lookup table */
      handle->crc_runningval = (*(uint32_t*)((uint32_t)handle->crctable + (tableindex * handle->tableoffset))  ^ \
 80268f0:	fb07 f404 	mul.w	r4, r7, r4
  uint32_t buffer;
  uint8_t *temp;
  
  temp = (uint8_t *)bufferptr;

  while (length--)
 80268f4:	4291      	cmp	r1, r2
    if (handle->config->input_reflection == true)
    {
      tableindex = ((handle->crc_runningval >> handle->crc_shift) ^ buffer) & (int32_t)0xff;

      /* compute the CRC running value from the lookup table */
      handle->crc_runningval = (*(uint32_t*)((uint32_t)handle->crctable + (tableindex * handle->tableoffset))  ^ \
 80268f6:	59a4      	ldr	r4, [r4, r6]
 80268f8:	ea84 2313 	eor.w	r3, r4, r3, lsr #8
                                 (handle->crc_runningval >> CRC_SW_EIGHT)) & (handle->crc_mask << handle->crc_shift);
 80268fc:	ea03 0305 	and.w	r3, r3, r5
 8026900:	6043      	str	r3, [r0, #4]
  uint32_t buffer;
  uint8_t *temp;
  
  temp = (uint8_t *)bufferptr;

  while (length--)
 8026902:	d1ee      	bne.n	80268e2 <CRC_SW_CalculateCRC+0x5e>
 8026904:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08026908 <CRC_SW_GetCRCResult>:
/**
 * This function returns the CRC value for the already calculated CRC by doing
 * reflection(if selected) and inversion.
 **/
uint32_t CRC_SW_GetCRCResult(CRC_SW_t *const handle)
{
 8026908:	b4f0      	push	{r4, r5, r6, r7}
  uint32_t result;
  
  if (handle != NULL)
 802690a:	4606      	mov	r6, r0
 802690c:	b310      	cbz	r0, 8026954 <CRC_SW_GetCRCResult+0x4c>
  {
    handle->crc_runningval &= (handle->crc_mask << handle->crc_shift);
 802690e:	6902      	ldr	r2, [r0, #16]
 8026910:	68c7      	ldr	r7, [r0, #12]
    handle->crc_runningval >>= handle->crc_shift;

    /* Do not reflect the bytes if input reflection and output reflection are set to true. Otherwise reflect the bytes*/
    if (handle->config->input_reflection != handle->config->output_reflection)
 8026912:	c809      	ldmia	r0, {r0, r3}
{
  uint32_t result;
  
  if (handle != NULL)
  {
    handle->crc_runningval &= (handle->crc_mask << handle->crc_shift);
 8026914:	fa07 f102 	lsl.w	r1, r7, r2
 8026918:	400b      	ands	r3, r1
    handle->crc_runningval >>= handle->crc_shift;

    /* Do not reflect the bytes if input reflection and output reflection are set to true. Otherwise reflect the bytes*/
    if (handle->config->input_reflection != handle->config->output_reflection)
 802691a:	7c04      	ldrb	r4, [r0, #16]
 802691c:	7c41      	ldrb	r1, [r0, #17]
  uint32_t result;
  
  if (handle != NULL)
  {
    handle->crc_runningval &= (handle->crc_mask << handle->crc_shift);
    handle->crc_runningval >>= handle->crc_shift;
 802691e:	40d3      	lsrs	r3, r2

    /* Do not reflect the bytes if input reflection and output reflection are set to true. Otherwise reflect the bytes*/
    if (handle->config->input_reflection != handle->config->output_reflection)
 8026920:	428c      	cmp	r4, r1
  uint32_t result;
  
  if (handle != NULL)
  {
    handle->crc_runningval &= (handle->crc_mask << handle->crc_shift);
    handle->crc_runningval >>= handle->crc_shift;
 8026922:	6073      	str	r3, [r6, #4]

    /* Do not reflect the bytes if input reflection and output reflection are set to true. Otherwise reflect the bytes*/
    if (handle->config->input_reflection != handle->config->output_reflection)
 8026924:	d014      	beq.n	8026950 <CRC_SW_GetCRCResult+0x48>
    {
      handle->crc_runningval = CRC_SW_lReflect(handle->crc_runningval, handle->config->crc_width);
 8026926:	6805      	ldr	r5, [r0, #0]
  uint32_t count;
  uint32_t retval;

  retval = data & CRC_SW_ONE;
  
  for (count = CRC_SW_ONE; count < length ; count++)
 8026928:	2d01      	cmp	r5, #1
static uint32_t CRC_SW_lReflect(uint32_t data, uint32_t length)
{
  uint32_t count;
  uint32_t retval;

  retval = data & CRC_SW_ONE;
 802692a:	f003 0101 	and.w	r1, r3, #1
  
  for (count = CRC_SW_ONE; count < length ; count++)
 802692e:	d908      	bls.n	8026942 <CRC_SW_GetCRCResult+0x3a>
 8026930:	2201      	movs	r2, #1
  {
    data >>= CRC_SW_ONE;
 8026932:	085b      	lsrs	r3, r3, #1
  uint32_t count;
  uint32_t retval;

  retval = data & CRC_SW_ONE;
  
  for (count = CRC_SW_ONE; count < length ; count++)
 8026934:	3201      	adds	r2, #1
  {
    data >>= CRC_SW_ONE;
    retval = (retval << CRC_SW_ONE) | (data & CRC_SW_ONE);
 8026936:	f003 0401 	and.w	r4, r3, #1
  uint32_t count;
  uint32_t retval;

  retval = data & CRC_SW_ONE;
  
  for (count = CRC_SW_ONE; count < length ; count++)
 802693a:	42aa      	cmp	r2, r5
  {
    data >>= CRC_SW_ONE;
    retval = (retval << CRC_SW_ONE) | (data & CRC_SW_ONE);
 802693c:	ea44 0141 	orr.w	r1, r4, r1, lsl #1
  uint32_t count;
  uint32_t retval;

  retval = data & CRC_SW_ONE;
  
  for (count = CRC_SW_ONE; count < length ; count++)
 8026940:	d1f7      	bne.n	8026932 <CRC_SW_GetCRCResult+0x2a>
    if (handle->config->input_reflection != handle->config->output_reflection)
    {
      handle->crc_runningval = CRC_SW_lReflect(handle->crc_runningval, handle->config->crc_width);
    }

    handle->crc_runningval ^= handle->config->output_inversion;
 8026942:	68c0      	ldr	r0, [r0, #12]
 8026944:	4041      	eors	r1, r0
    handle->crc_runningval &= handle->crc_mask;
 8026946:	ea01 0007 	and.w	r0, r1, r7
 802694a:	6070      	str	r0, [r6, #4]
  else
  {
    result = CRC_SW_ZERO;
  }
  return (result);
}
 802694c:	bcf0      	pop	{r4, r5, r6, r7}
 802694e:	4770      	bx	lr
 8026950:	4619      	mov	r1, r3
 8026952:	e7f6      	b.n	8026942 <CRC_SW_GetCRCResult+0x3a>
 8026954:	bcf0      	pop	{r4, r5, r6, r7}
 8026956:	4770      	bx	lr

08026958 <SystemCoreSetup>:
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8026958:	4b18      	ldr	r3, [pc, #96]	; (80269bc <SystemCoreSetup+0x64>)
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
 802695a:	4a19      	ldr	r2, [pc, #100]	; (80269c0 <SystemCoreSetup+0x68>)
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 802695c:	68d8      	ldr	r0, [r3, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 802695e:	f64f 01ff 	movw	r1, #63743	; 0xf8ff
 8026962:	4001      	ands	r1, r0
  reg_value  =  (reg_value                                   |
 8026964:	430a      	orrs	r2, r1
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 8026966:	60da      	str	r2, [r3, #12]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__((always_inline)) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8026968:	b672      	cpsid	i
	
  /* relocate vector table */
  __disable_irq();

#if !defined(__TASKING__)
  SCB->VTOR = (uint32_t)(&__Vectors);
 802696a:	4a16      	ldr	r2, [pc, #88]	; (80269c4 <SystemCoreSetup+0x6c>)
 802696c:	609a      	str	r2, [r3, #8]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 802696e:	f3bf 8f4f 	dsb	sy
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__((always_inline)) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8026972:	b662      	cpsie	i

  __DSB();
  __enable_irq();
	
#if ((__FPU_PRESENT == 1) && (__FPU_USED == 1))
  SCB->CPACR |= ((3UL << 10*2) |                 /* set CP10 Full Access */
 8026974:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
				 (3UL << 11*2)  );               /* set CP11 Full Access */
#endif
  /* Set flash wait states */
  temp = FLASH0->FCON;
 8026978:	4813      	ldr	r0, [pc, #76]	; (80269c8 <SystemCoreSetup+0x70>)

  __DSB();
  __enable_irq();
	
#if ((__FPU_PRESENT == 1) && (__FPU_USED == 1))
  SCB->CPACR |= ((3UL << 10*2) |                 /* set CP10 Full Access */
 802697a:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
				 (3UL << 11*2)  );               /* set CP11 Full Access */
#endif
  /* Set flash wait states */
  temp = FLASH0->FCON;
 802697e:	f241 0114 	movw	r1, #4116	; 0x1014

  __DSB();
  __enable_irq();
	
#if ((__FPU_PRESENT == 1) && (__FPU_USED == 1))
  SCB->CPACR |= ((3UL << 10*2) |                 /* set CP10 Full Access */
 8026982:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
				 (3UL << 11*2)  );               /* set CP11 Full Access */
#endif
  /* Set flash wait states */
  temp = FLASH0->FCON;
 8026986:	5842      	ldr	r2, [r0, r1]
  temp &= ~FLASH_FCON_WSPFLASH_Msk;
 8026988:	f022 020f 	bic.w	r2, r2, #15
  temp |= PMU_FLASH_WS;
 802698c:	f042 0204 	orr.w	r2, r2, #4
  FLASH0->FCON = temp;
 8026990:	5042      	str	r2, [r0, r1]


  /* Disable divide by zero trap */
  SCB->CCR &= ~SCB_CCR_DIV_0_TRP_Msk; 
 8026992:	695a      	ldr	r2, [r3, #20]
 8026994:	f022 0210 	bic.w	r2, r2, #16
 8026998:	615a      	str	r2, [r3, #20]

  /* Disable unaligned memory access trap */
  SCB->CCR &= ~SCB_CCR_UNALIGN_TRP_Msk; 
 802699a:	695a      	ldr	r2, [r3, #20]
 802699c:	f022 0208 	bic.w	r2, r2, #8
 80269a0:	615a      	str	r2, [r3, #20]

  /* Disable memory management fault */
  SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;
 80269a2:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80269a4:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 80269a8:	625a      	str	r2, [r3, #36]	; 0x24

  /* Disable bus fault */
  SCB->SHCSR &= ~SCB_SHCSR_BUSFAULTENA_Msk;
 80269aa:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80269ac:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
 80269b0:	625a      	str	r2, [r3, #36]	; 0x24

  /* Disable usage fault */
  SCB->SHCSR &= ~SCB_SHCSR_USGFAULTENA_Msk;
 80269b2:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80269b4:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 80269b8:	625a      	str	r2, [r3, #36]	; 0x24
 80269ba:	4770      	bx	lr
 80269bc:	e000ed00 	.word	0xe000ed00
 80269c0:	05fa0100 	.word	0x05fa0100
 80269c4:	08000000 	.word	0x08000000
 80269c8:	58001000 	.word	0x58001000

080269cc <arm_bitreversal_32>:
	ENDP

#else

arm_bitreversal_32 PROC
	ADDS     r3,r1,#1
 80269cc:	1c4b      	adds	r3, r1, #1
	CMP      r3,#1
 80269ce:	2b01      	cmp	r3, #1
	IT       LS
 80269d0:	bf98      	it	ls
	BXLS     lr
 80269d2:	4770      	bxls	lr
	PUSH     {r4-r9}
 80269d4:	e92d 03f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9}
	ADDS     r1,r2,#2
 80269d8:	1c91      	adds	r1, r2, #2
	LSRS     r3,r3,#2
 80269da:	089b      	lsrs	r3, r3, #2

080269dc <arm_bitreversal_32_0>:
arm_bitreversal_32_0 LABEL       ;/* loop unrolled by 2 */
	LDRH     r8,[r1,#4]
 80269dc:	f8b1 8004 	ldrh.w	r8, [r1, #4]
	LDRH     r9,[r1,#2]
 80269e0:	f8b1 9002 	ldrh.w	r9, [r1, #2]
	LDRH     r2,[r1,#0]
 80269e4:	880a      	ldrh	r2, [r1, #0]
	LDRH     r12,[r1,#-2]
 80269e6:	f831 cc02 	ldrh.w	ip, [r1, #-2]
	ADD      r8,r0,r8
 80269ea:	4480      	add	r8, r0
	ADD      r9,r0,r9
 80269ec:	4481      	add	r9, r0
	ADD      r2,r0,r2
 80269ee:	4402      	add	r2, r0
	ADD      r12,r0,r12
 80269f0:	4484      	add	ip, r0
	LDR      r7,[r9,#0]
 80269f2:	f8d9 7000 	ldr.w	r7, [r9]
	LDR      r6,[r8,#0]
 80269f6:	f8d8 6000 	ldr.w	r6, [r8]
	LDR      r5,[r2,#0]
 80269fa:	6815      	ldr	r5, [r2, #0]
	LDR      r4,[r12,#0]
 80269fc:	f8dc 4000 	ldr.w	r4, [ip]
	STR      r6,[r9,#0]
 8026a00:	f8c9 6000 	str.w	r6, [r9]
	STR      r7,[r8,#0]
 8026a04:	f8c8 7000 	str.w	r7, [r8]
	STR      r5,[r12,#0]
 8026a08:	f8cc 5000 	str.w	r5, [ip]
	STR      r4,[r2,#0]
 8026a0c:	6014      	str	r4, [r2, #0]
	LDR      r7,[r9,#4]
 8026a0e:	f8d9 7004 	ldr.w	r7, [r9, #4]
	LDR      r6,[r8,#4]
 8026a12:	f8d8 6004 	ldr.w	r6, [r8, #4]
	LDR      r5,[r2,#4]
 8026a16:	6855      	ldr	r5, [r2, #4]
	LDR      r4,[r12,#4]
 8026a18:	f8dc 4004 	ldr.w	r4, [ip, #4]
	STR      r6,[r9,#4]
 8026a1c:	f8c9 6004 	str.w	r6, [r9, #4]
	STR      r7,[r8,#4]
 8026a20:	f8c8 7004 	str.w	r7, [r8, #4]
	STR      r5,[r12,#4]
 8026a24:	f8cc 5004 	str.w	r5, [ip, #4]
	STR      r4,[r2,#4]
 8026a28:	6054      	str	r4, [r2, #4]
	ADDS     r1,r1,#8
 8026a2a:	3108      	adds	r1, #8
	SUBS     r3,r3,#1
 8026a2c:	3b01      	subs	r3, #1
	BNE      arm_bitreversal_32_0
 8026a2e:	d1d5      	bne.n	80269dc <arm_bitreversal_32_0>
	POP      {r4-r9}
 8026a30:	e8bd 03f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9}
	BX       lr
 8026a34:	4770      	bx	lr

08026a36 <arm_bitreversal_16>:
	ENDP

arm_bitreversal_16 PROC
	ADDS     r3,r1,#1
 8026a36:	1c4b      	adds	r3, r1, #1
	CMP      r3,#1
 8026a38:	2b01      	cmp	r3, #1
	IT       LS
 8026a3a:	bf98      	it	ls
	BXLS     lr
 8026a3c:	4770      	bxls	lr
	PUSH     {r4-r9}
 8026a3e:	e92d 03f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9}
	ADDS     r1,r2,#2
 8026a42:	1c91      	adds	r1, r2, #2
	LSRS     r3,r3,#2
 8026a44:	089b      	lsrs	r3, r3, #2

08026a46 <arm_bitreversal_16_0>:
arm_bitreversal_16_0 LABEL       ;/* loop unrolled by 2 */
	LDRH     r8,[r1,#4]
 8026a46:	f8b1 8004 	ldrh.w	r8, [r1, #4]
	LDRH     r9,[r1,#2]
 8026a4a:	f8b1 9002 	ldrh.w	r9, [r1, #2]
	LDRH     r2,[r1,#0]
 8026a4e:	880a      	ldrh	r2, [r1, #0]
	LDRH     r12,[r1,#-2]
 8026a50:	f831 cc02 	ldrh.w	ip, [r1, #-2]
	ADD      r8,r0,r8,LSR #1
 8026a54:	eb00 0858 	add.w	r8, r0, r8, lsr #1
	ADD      r9,r0,r9,LSR #1
 8026a58:	eb00 0959 	add.w	r9, r0, r9, lsr #1
	ADD      r2,r0,r2,LSR #1
 8026a5c:	eb00 0252 	add.w	r2, r0, r2, lsr #1
	ADD      r12,r0,r12,LSR #1
 8026a60:	eb00 0c5c 	add.w	ip, r0, ip, lsr #1
	LDR      r7,[r9,#0]
 8026a64:	f8d9 7000 	ldr.w	r7, [r9]
	LDR      r6,[r8,#0]
 8026a68:	f8d8 6000 	ldr.w	r6, [r8]
	LDR      r5,[r2,#0]
 8026a6c:	6815      	ldr	r5, [r2, #0]
	LDR      r4,[r12,#0]
 8026a6e:	f8dc 4000 	ldr.w	r4, [ip]
	STR      r6,[r9,#0]
 8026a72:	f8c9 6000 	str.w	r6, [r9]
	STR      r7,[r8,#0]
 8026a76:	f8c8 7000 	str.w	r7, [r8]
	STR      r5,[r12,#0]
 8026a7a:	f8cc 5000 	str.w	r5, [ip]
	STR      r4,[r2,#0]
 8026a7e:	6014      	str	r4, [r2, #0]
	ADDS     r1,r1,#8
 8026a80:	3108      	adds	r1, #8
	SUBS     r3,r3,#1
 8026a82:	3b01      	subs	r3, #1
	BNE      arm_bitreversal_16_0
 8026a84:	d1df      	bne.n	8026a46 <arm_bitreversal_16_0>
	POP      {r4-r9}
 8026a86:	e8bd 03f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9}
	BX       lr
 8026a8a:	4770      	bx	lr

08026a8c <arm_cfft_radix8by2_f32>:
* \endcode
*
*/

void arm_cfft_radix8by2_f32( arm_cfft_instance_f32 * S, float32_t * p1)
{
 8026a8c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    uint32_t    L  = S->fftLen;
 8026a90:	f8b0 e000 	ldrh.w	lr, [r0]
    float32_t * pCol1, * pCol2, * pMid1, * pMid2;
    float32_t * p2 = p1 + L;
    const float32_t * tw = (float32_t *) S->pTwiddle;
 8026a94:	6842      	ldr	r2, [r0, #4]
* \endcode
*
*/

void arm_cfft_radix8by2_f32( arm_cfft_instance_f32 * S, float32_t * p1)
{
 8026a96:	4680      	mov	r8, r0
    uint32_t    L  = S->fftLen;
    float32_t * pCol1, * pCol2, * pMid1, * pMid2;
    float32_t * p2 = p1 + L;
 8026a98:	eb01 098e 	add.w	r9, r1, lr, lsl #2

    pCol1 = p1;
    pCol2 = p2;

    //    Define new length
    L >>= 1;
 8026a9c:	ea4f 005e 	mov.w	r0, lr, lsr #1
    //    Initialize mid pointers
    pMid1 = p1 + L;
    pMid2 = p2 + L;

    // do two dot Fourier transform
    for ( l = L >> 2; l > 0; l-- )
 8026aa0:	ea5f 0ede 	movs.w	lr, lr, lsr #3
* \endcode
*
*/

void arm_cfft_radix8by2_f32( arm_cfft_instance_f32 * S, float32_t * p1)
{
 8026aa4:	ed2d 8b08 	vpush	{d8-d11}
    pCol2 = p2;

    //    Define new length
    L >>= 1;
    //    Initialize mid pointers
    pMid1 = p1 + L;
 8026aa8:	ea4f 0380 	mov.w	r3, r0, lsl #2
    pMid2 = p2 + L;

    // do two dot Fourier transform
    for ( l = L >> 2; l > 0; l-- )
 8026aac:	f000 809f 	beq.w	8026bee <arm_cfft_radix8by2_f32+0x162>
 8026ab0:	3310      	adds	r3, #16
 8026ab2:	18ce      	adds	r6, r1, r3
 8026ab4:	f101 0510 	add.w	r5, r1, #16
 8026ab8:	444b      	add	r3, r9
 8026aba:	f102 0710 	add.w	r7, r2, #16
 8026abe:	f109 0410 	add.w	r4, r9, #16
        t1[0] = p1[0];
        t1[1] = p1[1];
        t1[2] = p1[2];
        t1[3] = p1[3];

        t2[0] = p2[0];
 8026ac2:	ed14 2a04 	vldr	s4, [r4, #-16]
        t2[1] = p2[1];
 8026ac6:	ed54 2a03 	vldr	s5, [r4, #-12]
        t3[0] = pMid1[0];
        t3[1] = pMid1[1];
        t3[2] = pMid1[2];
        t3[3] = pMid1[3];

        t4[0] = pMid2[0];
 8026aca:	ed13 5a04 	vldr	s10, [r3, #-16]
        t4[1] = pMid2[1];
 8026ace:	ed53 5a03 	vldr	s11, [r3, #-12]
        t1[2] = p1[2];
        t1[3] = p1[3];

        t2[0] = p2[0];
        t2[1] = p2[1];
        t2[2] = p2[2];
 8026ad2:	ed54 8a02 	vldr	s17, [r4, #-8]
        t2[3] = p2[3];

        t3[0] = pMid1[0];
 8026ad6:	ed16 3a04 	vldr	s6, [r6, #-16]
        t3[1] = pMid1[1];
 8026ada:	ed56 3a03 	vldr	s7, [r6, #-12]
        t3[2] = pMid1[2];
        t3[3] = pMid1[3];

        t4[0] = pMid2[0];
        t4[1] = pMid2[1];
        t4[2] = pMid2[2];
 8026ade:	ed13 7a02 	vldr	s14, [r3, #-8]
        t4[3] = pMid2[3];
 8026ae2:	ed53 7a01 	vldr	s15, [r3, #-4]
    pMid2 = p2 + L;

    // do two dot Fourier transform
    for ( l = L >> 2; l > 0; l-- )
    {
        t1[0] = p1[0];
 8026ae6:	ed55 4a04 	vldr	s9, [r5, #-16]
        t1[3] = p1[3];

        t2[0] = p2[0];
        t2[1] = p2[1];
        t2[2] = p2[2];
        t2[3] = p2[3];
 8026aea:	ed14 8a01 	vldr	s16, [r4, #-4]

        t3[0] = pMid1[0];
        t3[1] = pMid1[1];
        t3[2] = pMid1[2];
 8026aee:	ed16 0a02 	vldr	s0, [r6, #-8]
        t3[3] = pMid1[3];
 8026af2:	ed56 0a01 	vldr	s1, [r6, #-4]

    // do two dot Fourier transform
    for ( l = L >> 2; l > 0; l-- )
    {
        t1[0] = p1[0];
        t1[1] = p1[1];
 8026af6:	ed15 4a03 	vldr	s8, [r5, #-12]
        t1[2] = p1[2];
 8026afa:	ed55 6a02 	vldr	s13, [r5, #-8]
        t1[3] = p1[3];
 8026afe:	ed15 6a01 	vldr	s12, [r5, #-4]
        t4[0] = pMid2[0];
        t4[1] = pMid2[1];
        t4[2] = pMid2[2];
        t4[3] = pMid2[3];

        *p1++ = t1[0] + t2[0];
 8026b02:	ee74 ba82 	vadd.f32	s23, s9, s4
        *p1++ = t1[1] + t2[1];
 8026b06:	ee34 ba22 	vadd.f32	s22, s8, s5
        t2[0] = t1[0] - t2[0];
        t2[1] = t1[1] - t2[1];
        t2[2] = t1[2] - t2[2];
        t2[3] = t1[3] - t2[3];    // for col 2

        *pMid1++ = t3[0] + t4[0];
 8026b0a:	ee73 9a05 	vadd.f32	s19, s6, s10
        *pMid1++ = t3[1] + t4[1];
 8026b0e:	ee33 9aa5 	vadd.f32	s18, s7, s11
        *pMid1++ = t3[2] + t4[2];
 8026b12:	ee30 1a07 	vadd.f32	s2, s0, s14
        *pMid1++ = t3[3] + t4[3]; // col 1
 8026b16:	ee70 1aa7 	vadd.f32	s3, s1, s15
        t4[2] = pMid2[2];
        t4[3] = pMid2[3];

        *p1++ = t1[0] + t2[0];
        *p1++ = t1[1] + t2[1];
        *p1++ = t1[2] + t2[2];
 8026b1a:	ee76 aaa8 	vadd.f32	s21, s13, s17
        *p1++ = t1[3] + t2[3];    // col 1
 8026b1e:	ee36 aa08 	vadd.f32	s20, s12, s16
        t4[0] = pMid2[0];
        t4[1] = pMid2[1];
        t4[2] = pMid2[2];
        t4[3] = pMid2[3];

        *p1++ = t1[0] + t2[0];
 8026b22:	ed45 ba04 	vstr	s23, [r5, #-16]
        *p1++ = t1[1] + t2[1];
 8026b26:	ed05 ba03 	vstr	s22, [r5, #-12]
        *p1++ = t1[2] + t2[2];
 8026b2a:	ed45 aa02 	vstr	s21, [r5, #-8]
        *p1++ = t1[3] + t2[3];    // col 1
 8026b2e:	ed05 aa01 	vstr	s20, [r5, #-4]
        t2[2] = t1[2] - t2[2];
        t2[3] = t1[3] - t2[3];    // for col 2

        *pMid1++ = t3[0] + t4[0];
        *pMid1++ = t3[1] + t4[1];
        *pMid1++ = t3[2] + t4[2];
 8026b32:	ed06 1a02 	vstr	s2, [r6, #-8]
        *pMid1++ = t3[3] + t4[3]; // col 1
 8026b36:	ed46 1a01 	vstr	s3, [r6, #-4]
        t2[0] = t1[0] - t2[0];
        t2[1] = t1[1] - t2[1];
        t2[2] = t1[2] - t2[2];
        t2[3] = t1[3] - t2[3];    // for col 2

        *pMid1++ = t3[0] + t4[0];
 8026b3a:	ed46 9a04 	vstr	s19, [r6, #-16]
        *pMid1++ = t3[1] + t4[1];
 8026b3e:	ed06 9a03 	vstr	s18, [r6, #-12]
        *p1++ = t1[0] + t2[0];
        *p1++ = t1[1] + t2[1];
        *p1++ = t1[2] + t2[2];
        *p1++ = t1[3] + t2[3];    // col 1

        t2[0] = t1[0] - t2[0];
 8026b42:	ee74 4ac2 	vsub.f32	s9, s9, s4
        t2[1] = t1[1] - t2[1];
 8026b46:	ee34 4a62 	vsub.f32	s8, s8, s5
        *pMid1++ = t3[0] + t4[0];
        *pMid1++ = t3[1] + t4[1];
        *pMid1++ = t3[2] + t4[2];
        *pMid1++ = t3[3] + t4[3]; // col 1

        t4[0] = t4[0] - t3[0];
 8026b4a:	ee35 5a43 	vsub.f32	s10, s10, s6
        t4[1] = t4[1] - t3[1];
 8026b4e:	ee75 5ae3 	vsub.f32	s11, s11, s7
        t4[2] = t4[2] - t3[2];
        t4[3] = t4[3] - t3[3];    // for col 2

        twR = *tw++;
 8026b52:	ed17 3a04 	vldr	s6, [r7, #-16]
        twI = *tw++;
 8026b56:	ed57 3a03 	vldr	s7, [r7, #-12]
 8026b5a:	ee23 2a65 	vnmul.f32	s4, s6, s11

        // multiply by twiddle factors
        m0 = t2[0] * twR;
        m1 = t2[1] * twI;
 8026b5e:	ee64 1a23 	vmul.f32	s3, s8, s7
 8026b62:	ee23 1ae4 	vnmul.f32	s2, s7, s9
        // use vertical symmetry
        //  0.9988 - 0.0491i <==> -0.0491 - 0.9988i
        m0 = t4[0] * twI;
        m1 = t4[1] * twR;
        m2 = t4[1] * twI;
        m3 = t4[0] * twR;
 8026b66:	ee65 2a03 	vmul.f32	s5, s10, s6
        m3 = t2[0] * twI;

        // R  =  R  *  Tr - I * Ti
        *p2++ = m0 + m1;
        // I  =  I  *  Tr + R * Ti
        *p2++ = m2 - m3;
 8026b6a:	eea4 1a03 	vfma.f32	s2, s8, s6
    //    Initialize mid pointers
    pMid1 = p1 + L;
    pMid2 = p2 + L;

    // do two dot Fourier transform
    for ( l = L >> 2; l > 0; l-- )
 8026b6e:	f1be 0e01 	subs.w	lr, lr, #1
 8026b72:	f105 0510 	add.w	r5, r5, #16
        m1 = t2[1] * twI;
        m2 = t2[1] * twR;
        m3 = t2[0] * twI;

        // R  =  R  *  Tr - I * Ti
        *p2++ = m0 + m1;
 8026b76:	eee4 1a83 	vfma.f32	s3, s9, s6
 8026b7a:	f106 0610 	add.w	r6, r6, #16
 8026b7e:	f107 0710 	add.w	r7, r7, #16
        m0 = t4[0] * twI;
        m1 = t4[1] * twR;
        m2 = t4[1] * twI;
        m3 = t4[0] * twR;

        *pMid2++ = m0 - m1;
 8026b82:	eea5 2a23 	vfma.f32	s4, s10, s7
 8026b86:	f104 0410 	add.w	r4, r4, #16
 8026b8a:	f103 0310 	add.w	r3, r3, #16
        *pMid2++ = m2 + m3;
 8026b8e:	eee5 2aa3 	vfma.f32	s5, s11, s7
        m3 = t2[0] * twI;

        // R  =  R  *  Tr - I * Ti
        *p2++ = m0 + m1;
        // I  =  I  *  Tr + R * Ti
        *p2++ = m2 - m3;
 8026b92:	ed04 1a07 	vstr	s2, [r4, #-28]	; 0xffffffe4
        m1 = t2[1] * twI;
        m2 = t2[1] * twR;
        m3 = t2[0] * twI;

        // R  =  R  *  Tr - I * Ti
        *p2++ = m0 + m1;
 8026b96:	ed44 1a08 	vstr	s3, [r4, #-32]	; 0xffffffe0
        m0 = t4[0] * twI;
        m1 = t4[1] * twR;
        m2 = t4[1] * twI;
        m3 = t4[0] * twR;

        *pMid2++ = m0 - m1;
 8026b9a:	ed03 2a08 	vstr	s4, [r3, #-32]	; 0xffffffe0
        *pMid2++ = m2 + m3;
 8026b9e:	ed43 2a07 	vstr	s5, [r3, #-28]	; 0xffffffe4

        twR = *tw++;
        twI = *tw++;
 8026ba2:	ed57 5a05 	vldr	s11, [r7, #-20]	; 0xffffffec
        m3 = t4[0] * twR;

        *pMid2++ = m0 - m1;
        *pMid2++ = m2 + m3;

        twR = *tw++;
 8026ba6:	ed17 5a06 	vldr	s10, [r7, #-24]	; 0xffffffe8
        *p1++ = t1[2] + t2[2];
        *p1++ = t1[3] + t2[3];    // col 1

        t2[0] = t1[0] - t2[0];
        t2[1] = t1[1] - t2[1];
        t2[2] = t1[2] - t2[2];
 8026baa:	ee76 6ae8 	vsub.f32	s13, s13, s17
        t2[3] = t1[3] - t2[3];    // for col 2
 8026bae:	ee36 6a48 	vsub.f32	s12, s12, s16
        *pMid1++ = t3[2] + t4[2];
        *pMid1++ = t3[3] + t4[3]; // col 1

        t4[0] = t4[0] - t3[0];
        t4[1] = t4[1] - t3[1];
        t4[2] = t4[2] - t3[2];
 8026bb2:	ee37 7a40 	vsub.f32	s14, s14, s0
        t4[3] = t4[3] - t3[3];    // for col 2
 8026bb6:	ee77 7ae0 	vsub.f32	s15, s15, s1

        twR = *tw++;
        twI = *tw++;

        m0 = t2[2] * twR;
        m1 = t2[3] * twI;
 8026bba:	ee26 3a25 	vmul.f32	s6, s12, s11
 8026bbe:	ee65 3ae6 	vnmul.f32	s7, s11, s13
 8026bc2:	ee25 4a67 	vnmul.f32	s8, s10, s15
        *p2++ = m2 - m3;

        m0 = t4[2] * twI;
        m1 = t4[3] * twR;
        m2 = t4[3] * twI;
        m3 = t4[2] * twR;
 8026bc6:	ee67 4a05 	vmul.f32	s9, s14, s10
        m1 = t2[3] * twI;
        m2 = t2[3] * twR;
        m3 = t2[2] * twI;

        *p2++ = m0 + m1;
        *p2++ = m2 - m3;
 8026bca:	eee6 3a05 	vfma.f32	s7, s12, s10
        m0 = t2[2] * twR;
        m1 = t2[3] * twI;
        m2 = t2[3] * twR;
        m3 = t2[2] * twI;

        *p2++ = m0 + m1;
 8026bce:	eea6 3a85 	vfma.f32	s6, s13, s10
        m0 = t4[2] * twI;
        m1 = t4[3] * twR;
        m2 = t4[3] * twI;
        m3 = t4[2] * twR;

        *pMid2++ = m0 - m1;
 8026bd2:	eea7 4a25 	vfma.f32	s8, s14, s11
        *pMid2++ = m2 + m3;
 8026bd6:	eee7 4aa5 	vfma.f32	s9, s15, s11
        m0 = t2[2] * twR;
        m1 = t2[3] * twI;
        m2 = t2[3] * twR;
        m3 = t2[2] * twI;

        *p2++ = m0 + m1;
 8026bda:	ed04 3a06 	vstr	s6, [r4, #-24]	; 0xffffffe8
        *p2++ = m2 - m3;
 8026bde:	ed44 3a05 	vstr	s7, [r4, #-20]	; 0xffffffec
        m0 = t4[2] * twI;
        m1 = t4[3] * twR;
        m2 = t4[3] * twI;
        m3 = t4[2] * twR;

        *pMid2++ = m0 - m1;
 8026be2:	ed03 4a06 	vstr	s8, [r3, #-24]	; 0xffffffe8
        *pMid2++ = m2 + m3;
 8026be6:	ed43 4a05 	vstr	s9, [r3, #-20]	; 0xffffffec
    //    Initialize mid pointers
    pMid1 = p1 + L;
    pMid2 = p2 + L;

    // do two dot Fourier transform
    for ( l = L >> 2; l > 0; l-- )
 8026bea:	f47f af6a 	bne.w	8026ac2 <arm_cfft_radix8by2_f32+0x36>
        *pMid2++ = m0 - m1;
        *pMid2++ = m2 + m3;
    }

    // first col
    arm_radix8_butterfly_f32( pCol1, L, (float32_t *) S->pTwiddle, 2u);
 8026bee:	b284      	uxth	r4, r0
 8026bf0:	2302      	movs	r3, #2
 8026bf2:	4608      	mov	r0, r1
 8026bf4:	4621      	mov	r1, r4
 8026bf6:	f000 fac5 	bl	8027184 <arm_radix8_butterfly_f32>
    // second col
    arm_radix8_butterfly_f32( pCol2, L, (float32_t *) S->pTwiddle, 2u);
}
 8026bfa:	ecbd 8b08 	vpop	{d8-d11}
    }

    // first col
    arm_radix8_butterfly_f32( pCol1, L, (float32_t *) S->pTwiddle, 2u);
    // second col
    arm_radix8_butterfly_f32( pCol2, L, (float32_t *) S->pTwiddle, 2u);
 8026bfe:	4648      	mov	r0, r9
 8026c00:	4621      	mov	r1, r4
 8026c02:	f8d8 2004 	ldr.w	r2, [r8, #4]
 8026c06:	2302      	movs	r3, #2
}
 8026c08:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    }

    // first col
    arm_radix8_butterfly_f32( pCol1, L, (float32_t *) S->pTwiddle, 2u);
    // second col
    arm_radix8_butterfly_f32( pCol2, L, (float32_t *) S->pTwiddle, 2u);
 8026c0c:	f000 baba 	b.w	8027184 <arm_radix8_butterfly_f32>

08026c10 <arm_cfft_radix8by4_f32>:
}

void arm_cfft_radix8by4_f32( arm_cfft_instance_f32 * S, float32_t * p1)
{
 8026c10:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8026c14:	ed2d 8b0a 	vpush	{d8-d12}
    uint32_t    L  = S->fftLen >> 1;
 8026c18:	8804      	ldrh	r4, [r0, #0]
    pEnd1 = p2 - 1;     // points to imaginary values by default
    pEnd2 = p3 - 1;
    pEnd3 = p4 - 1;
    pEnd4 = pEnd3 + L;

    tw2 = tw3 = tw4 = (float32_t *) S->pTwiddle;
 8026c1a:	6843      	ldr	r3, [r0, #4]
    twMod2 = 2;
    twMod3 = 4;
    twMod4 = 6;

    // TOP
    p1ap3_0 = p1[0] + p3[0];
 8026c1c:	ed91 6a00 	vldr	s12, [r1]
    p1sp3_0 = p1[0] - p3[0];
    p1ap3_1 = p1[1] + p3[1];
 8026c20:	ed91 7a01 	vldr	s14, [r1, #4]
    // second col
    arm_radix8_butterfly_f32( pCol2, L, (float32_t *) S->pTwiddle, 2u);
}

void arm_cfft_radix8by4_f32( arm_cfft_instance_f32 * S, float32_t * p1)
{
 8026c24:	b08f      	sub	sp, #60	; 0x3c
    uint32_t    L  = S->fftLen >> 1;
 8026c26:	0864      	lsrs	r4, r4, #1
    pEnd1 = p2 - 1;     // points to imaginary values by default
    pEnd2 = p3 - 1;
    pEnd3 = p4 - 1;
    pEnd4 = pEnd3 + L;

    tw2 = tw3 = tw4 = (float32_t *) S->pTwiddle;
 8026c28:	9301      	str	r3, [sp, #4]
    twMod4 = 6;

    // TOP
    p1ap3_0 = p1[0] + p3[0];
    p1sp3_0 = p1[0] - p3[0];
    p1ap3_1 = p1[1] + p3[1];
 8026c2a:	460a      	mov	r2, r1
void arm_cfft_radix8by4_f32( arm_cfft_instance_f32 * S, float32_t * p1)
{
    uint32_t    L  = S->fftLen >> 1;
    float32_t * pCol1, *pCol2, *pCol3, *pCol4, *pEnd1, *pEnd2, *pEnd3, *pEnd4;
    const float32_t *tw2, *tw3, *tw4;
    float32_t * p2 = p1 + L;
 8026c2c:	00a3      	lsls	r3, r4, #2
 8026c2e:	441a      	add	r2, r3
 8026c30:	4615      	mov	r5, r2
 8026c32:	9208      	str	r2, [sp, #32]
    float32_t * p3 = p2 + L;
 8026c34:	441a      	add	r2, r3
    twMod2 = 2;
    twMod3 = 4;
    twMod4 = 6;

    // TOP
    p1ap3_0 = p1[0] + p3[0];
 8026c36:	edd2 6a00 	vldr	s13, [r2]
    p1ap3_1 = p1[1] + p3[1];
    p1sp3_1 = p1[1] - p3[1];

    // col 2
    t2[0] = p1sp3_0 + p2[1] - p4[1];
    t2[1] = p1sp3_1 - p2[0] + p4[0];
 8026c3a:	edd5 3a00 	vldr	s7, [r5]
    // second col
    arm_radix8_butterfly_f32( pCol2, L, (float32_t *) S->pTwiddle, 2u);
}

void arm_cfft_radix8by4_f32( arm_cfft_instance_f32 * S, float32_t * p1)
{
 8026c3e:	910c      	str	r1, [sp, #48]	; 0x30
 8026c40:	460e      	mov	r6, r1
    twMod2 = 2;
    twMod3 = 4;
    twMod4 = 6;

    // TOP
    p1ap3_0 = p1[0] + p3[0];
 8026c42:	ee76 5a26 	vadd.f32	s11, s12, s13
    p1sp3_0 = p1[0] - p3[0];
    p1ap3_1 = p1[1] + p3[1];
 8026c46:	4611      	mov	r1, r2
    // second col
    arm_radix8_butterfly_f32( pCol2, L, (float32_t *) S->pTwiddle, 2u);
}

void arm_cfft_radix8by4_f32( arm_cfft_instance_f32 * S, float32_t * p1)
{
 8026c48:	900b      	str	r0, [sp, #44]	; 0x2c
    uint32_t    L  = S->fftLen >> 1;
    float32_t * pCol1, *pCol2, *pCol3, *pCol4, *pEnd1, *pEnd2, *pEnd3, *pEnd4;
    const float32_t *tw2, *tw3, *tw4;
    float32_t * p2 = p1 + L;
    float32_t * p3 = p2 + L;
    float32_t * p4 = p3 + L;
 8026c4a:	4608      	mov	r0, r1
 8026c4c:	4419      	add	r1, r3
    p1ap3_1 = p1[1] + p3[1];
    p1sp3_1 = p1[1] - p3[1];

    // col 2
    t2[0] = p1sp3_0 + p2[1] - p4[1];
    t2[1] = p1sp3_1 - p2[0] + p4[0];
 8026c4e:	ed91 4a00 	vldr	s8, [r1]
    p1sp3_0 = p1[0] - p3[0];
    p1ap3_1 = p1[1] + p3[1];
    p1sp3_1 = p1[1] - p3[1];

    // col 2
    t2[0] = p1sp3_0 + p2[1] - p4[1];
 8026c52:	edd5 2a01 	vldr	s5, [r5, #4]
    twMod4 = 6;

    // TOP
    p1ap3_0 = p1[0] + p3[0];
    p1sp3_0 = p1[0] - p3[0];
    p1ap3_1 = p1[1] + p3[1];
 8026c56:	edd2 7a01 	vldr	s15, [r2, #4]
{
    uint32_t    L  = S->fftLen >> 1;
    float32_t * pCol1, *pCol2, *pCol3, *pCol4, *pEnd1, *pEnd2, *pEnd3, *pEnd4;
    const float32_t *tw2, *tw3, *tw4;
    float32_t * p2 = p1 + L;
    float32_t * p3 = p2 + L;
 8026c5a:	9209      	str	r2, [sp, #36]	; 0x24
    t3[1] = p1ap3_1 - p2[1] - p4[1];
    // col 4
    t4[0] = p1sp3_0 - p2[1] + p4[1];
    t4[1] = p1sp3_1 + p2[0] - p4[0];
    // col 1
    *p1++ = p1ap3_0 + p2[0] + p4[0];
 8026c5c:	ee75 4aa3 	vadd.f32	s9, s11, s7
    p1sp3_0 = p1[0] - p3[0];
    p1ap3_1 = p1[1] + p3[1];
    p1sp3_1 = p1[1] - p3[1];

    // col 2
    t2[0] = p1sp3_0 + p2[1] - p4[1];
 8026c60:	462a      	mov	r2, r5
    t3[1] = p1ap3_1 - p2[1] - p4[1];
    // col 4
    t4[0] = p1sp3_0 - p2[1] + p4[1];
    t4[1] = p1sp3_1 + p2[0] - p4[0];
    // col 1
    *p1++ = p1ap3_0 + p2[0] + p4[0];
 8026c62:	ee74 4a24 	vadd.f32	s9, s8, s9
 8026c66:	4635      	mov	r5, r6
 8026c68:	ee14 ea90 	vmov	lr, s9
    p1sp3_0 = p1[0] - p3[0];
    p1ap3_1 = p1[1] + p3[1];
    p1sp3_1 = p1[1] - p3[1];

    // col 2
    t2[0] = p1sp3_0 + p2[1] - p4[1];
 8026c6c:	ed91 5a01 	vldr	s10, [r1, #4]
    t3[1] = p1ap3_1 - p2[1] - p4[1];
    // col 4
    t4[0] = p1sp3_0 - p2[1] + p4[1];
    t4[1] = p1sp3_1 + p2[0] - p4[0];
    // col 1
    *p1++ = p1ap3_0 + p2[0] + p4[0];
 8026c70:	f845 eb08 	str.w	lr, [r5], #8
    twMod3 = 4;
    twMod4 = 6;

    // TOP
    p1ap3_0 = p1[0] + p3[0];
    p1sp3_0 = p1[0] - p3[0];
 8026c74:	ee76 6a66 	vsub.f32	s13, s12, s13
    // col 4
    t4[0] = p1sp3_0 - p2[1] + p4[1];
    t4[1] = p1sp3_1 + p2[0] - p4[0];
    // col 1
    *p1++ = p1ap3_0 + p2[0] + p4[0];
    *p1++ = p1ap3_1 + p2[1] + p4[1];
 8026c78:	edd2 4a01 	vldr	s9, [r2, #4]
    uint32_t    L  = S->fftLen >> 1;
    float32_t * pCol1, *pCol2, *pCol3, *pCol4, *pEnd1, *pEnd2, *pEnd3, *pEnd4;
    const float32_t *tw2, *tw3, *tw4;
    float32_t * p2 = p1 + L;
    float32_t * p3 = p2 + L;
    float32_t * p4 = p3 + L;
 8026c7c:	9100      	str	r1, [sp, #0]
    twMod4 = 6;

    // TOP
    p1ap3_0 = p1[0] + p3[0];
    p1sp3_0 = p1[0] - p3[0];
    p1ap3_1 = p1[1] + p3[1];
 8026c7e:	ee37 6a27 	vadd.f32	s12, s14, s15
    p1sp3_1 = p1[1] - p3[1];

    // col 2
    t2[0] = p1sp3_0 + p2[1] - p4[1];
 8026c82:	460f      	mov	r7, r1
    // col 4
    t4[0] = p1sp3_0 - p2[1] + p4[1];
    t4[1] = p1sp3_1 + p2[0] - p4[0];
    // col 1
    *p1++ = p1ap3_0 + p2[0] + p4[0];
    *p1++ = p1ap3_1 + p2[1] + p4[1];
 8026c84:	ed97 2a01 	vldr	s4, [r7, #4]
    t3[1] = p1ap3_1 - p2[1] - p4[1];
    // col 4
    t4[0] = p1sp3_0 - p2[1] + p4[1];
    t4[1] = p1sp3_1 + p2[0] - p4[0];
    // col 1
    *p1++ = p1ap3_0 + p2[0] + p4[0];
 8026c88:	9503      	str	r5, [sp, #12]

    // TOP
    p1ap3_0 = p1[0] + p3[0];
    p1sp3_0 = p1[0] - p3[0];
    p1ap3_1 = p1[1] + p3[1];
    p1sp3_1 = p1[1] - p3[1];
 8026c8a:	ee77 7a67 	vsub.f32	s15, s14, s15

    // col 2
    t2[0] = p1sp3_0 + p2[1] - p4[1];
 8026c8e:	ee32 3aa6 	vadd.f32	s6, s5, s13
    // col 4
    t4[0] = p1sp3_0 - p2[1] + p4[1];
    t4[1] = p1sp3_1 + p2[0] - p4[0];
    // col 1
    *p1++ = p1ap3_0 + p2[0] + p4[0];
    *p1++ = p1ap3_1 + p2[1] + p4[1];
 8026c92:	ee36 7a24 	vadd.f32	s14, s12, s9

    // col 2
    t2[0] = p1sp3_0 + p2[1] - p4[1];
    t2[1] = p1sp3_1 - p2[0] + p4[0];
    // col 3
    t3[0] = p1ap3_0 - p2[0] - p4[0];
 8026c96:	ee75 5ae3 	vsub.f32	s11, s11, s7
    p1ap3_1 = p1[1] + p3[1];
    p1sp3_1 = p1[1] - p3[1];

    // col 2
    t2[0] = p1sp3_0 + p2[1] - p4[1];
    t2[1] = p1sp3_1 - p2[0] + p4[0];
 8026c9a:	ee77 4ae3 	vsub.f32	s9, s15, s7
    // col 3
    t3[0] = p1ap3_0 - p2[0] - p4[0];
    t3[1] = p1ap3_1 - p2[1] - p4[1];
 8026c9e:	ee36 6a62 	vsub.f32	s12, s12, s5
    // col 4
    t4[0] = p1sp3_0 - p2[1] + p4[1];
    t4[1] = p1sp3_1 + p2[0] - p4[0];
 8026ca2:	ee77 7aa3 	vadd.f32	s15, s15, s7
    t2[1] = p1sp3_1 - p2[0] + p4[0];
    // col 3
    t3[0] = p1ap3_0 - p2[0] - p4[0];
    t3[1] = p1ap3_1 - p2[1] - p4[1];
    // col 4
    t4[0] = p1sp3_0 - p2[1] + p4[1];
 8026ca6:	ee76 6ae2 	vsub.f32	s13, s13, s5
    p1sp3_0 = p1[0] - p3[0];
    p1ap3_1 = p1[1] + p3[1];
    p1sp3_1 = p1[1] - p3[1];

    // col 2
    t2[0] = p1sp3_0 + p2[1] - p4[1];
 8026caa:	ee73 3a45 	vsub.f32	s7, s6, s10
    // col 4
    t4[0] = p1sp3_0 - p2[1] + p4[1];
    t4[1] = p1sp3_1 + p2[0] - p4[0];
    // col 1
    *p1++ = p1ap3_0 + p2[0] + p4[0];
    *p1++ = p1ap3_1 + p2[1] + p4[1];
 8026cae:	ee37 7a02 	vadd.f32	s14, s14, s4
 8026cb2:	4611      	mov	r1, r2
 8026cb4:	ed86 7a01 	vstr	s14, [r6, #4]
    pEnd3 = p4 - 1;
    pEnd4 = pEnd3 + L;

    tw2 = tw3 = tw4 = (float32_t *) S->pTwiddle;

    L >>= 1;
 8026cb8:	0862      	lsrs	r2, r4, #1
    // col 2
    t2[0] = p1sp3_0 + p2[1] - p4[1];
    t2[1] = p1sp3_1 - p2[0] + p4[0];
    // col 3
    t3[0] = p1ap3_0 - p2[0] - p4[0];
    t3[1] = p1ap3_1 - p2[1] - p4[1];
 8026cba:	ee36 6a45 	vsub.f32	s12, s12, s10
    *p3++ = t3[0];
    *p3++ = t3[1];
    *p4++ = t4[0];
    *p4++ = t4[1];

    tw2 += twMod2;
 8026cbe:	9c01      	ldr	r4, [sp, #4]
    pEnd3 = p4 - 1;
    pEnd4 = pEnd3 + L;

    tw2 = tw3 = tw4 = (float32_t *) S->pTwiddle;

    L >>= 1;
 8026cc0:	920a      	str	r2, [sp, #40]	; 0x28
    t2[1] = p1sp3_1 - p2[0] + p4[0];
    // col 3
    t3[0] = p1ap3_0 - p2[0] - p4[0];
    t3[1] = p1ap3_1 - p2[1] - p4[1];
    // col 4
    t4[0] = p1sp3_0 - p2[1] + p4[1];
 8026cc2:	ee75 6a26 	vadd.f32	s13, s10, s13
    // col 1
    *p1++ = p1ap3_0 + p2[0] + p4[0];
    *p1++ = p1ap3_1 + p2[1] + p4[1];

    // Twiddle factors are ones
    *p2++ = t2[0];
 8026cc6:	4688      	mov	r8, r1
    *p2++ = t2[1];
    *p3++ = t3[0];
    *p3++ = t3[1];
    *p4++ = t4[0];
 8026cc8:	46bc      	mov	ip, r7
    p1ap3_1 = p1[1] + p3[1];
    p1sp3_1 = p1[1] - p3[1];

    // col 2
    t2[0] = p1sp3_0 + p2[1] - p4[1];
    t2[1] = p1sp3_1 - p2[0] + p4[0];
 8026cca:	ee34 5a84 	vadd.f32	s10, s9, s8
    // col 4
    t4[0] = p1sp3_0 - p2[1] + p4[1];
    t4[1] = p1sp3_1 + p2[0] - p4[0];
    // col 1
    *p1++ = p1ap3_0 + p2[0] + p4[0];
    *p1++ = p1ap3_1 + p2[1] + p4[1];
 8026cce:	4635      	mov	r5, r6
    pCol2 = p2;
    pCol3 = p3;
    pCol4 = p4;
    pEnd1 = p2 - 1;     // points to imaginary values by default
    pEnd2 = p3 - 1;
    pEnd3 = p4 - 1;
 8026cd0:	1f3e      	subs	r6, r7, #4
    // col 1
    *p1++ = p1ap3_0 + p2[0] + p4[0];
    *p1++ = p1ap3_1 + p2[1] + p4[1];

    // Twiddle factors are ones
    *p2++ = t2[0];
 8026cd2:	ee13 7a90 	vmov	r7, s7
 8026cd6:	468e      	mov	lr, r1

    // col 2
    t2[0] = p1sp3_0 + p2[1] - p4[1];
    t2[1] = p1sp3_1 - p2[0] + p4[0];
    // col 3
    t3[0] = p1ap3_0 - p2[0] - p4[0];
 8026cd8:	ee75 5ac4 	vsub.f32	s11, s11, s8
    // col 1
    *p1++ = p1ap3_0 + p2[0] + p4[0];
    *p1++ = p1ap3_1 + p2[1] + p4[1];

    // Twiddle factors are ones
    *p2++ = t2[0];
 8026cdc:	f848 7b08 	str.w	r7, [r8], #8
    *p2++ = t2[1];
 8026ce0:	ed8e 5a01 	vstr	s10, [lr, #4]

    pCol1 = p1;         // points to real values by default
    pCol2 = p2;
    pCol3 = p3;
    pCol4 = p4;
    pEnd1 = p2 - 1;     // points to imaginary values by default
 8026ce4:	f1ae 0704 	sub.w	r7, lr, #4
    *p3++ = t3[0];
    *p3++ = t3[1];
    *p4++ = t4[0];
    *p4++ = t4[1];

    tw2 += twMod2;
 8026ce8:	f104 0e08 	add.w	lr, r4, #8
    *p1++ = p1ap3_1 + p2[1] + p4[1];

    // Twiddle factors are ones
    *p2++ = t2[0];
    *p2++ = t2[1];
    *p3++ = t3[0];
 8026cec:	4601      	mov	r1, r0
    *p3++ = t3[1];
    *p4++ = t4[0];
    *p4++ = t4[1];

    tw2 += twMod2;
 8026cee:	f8cd e010 	str.w	lr, [sp, #16]
    *p1++ = p1ap3_1 + p2[1] + p4[1];

    // Twiddle factors are ones
    *p2++ = t2[0];
    *p2++ = t2[1];
    *p3++ = t3[0];
 8026cf2:	ee15 ea90 	vmov	lr, s11
 8026cf6:	f841 eb08 	str.w	lr, [r1], #8
 8026cfa:	9106      	str	r1, [sp, #24]
    *p3++ = t3[1];
    *p4++ = t4[0];
    *p4++ = t4[1];

    tw2 += twMod2;
    tw3 += twMod3;
 8026cfc:	9901      	ldr	r1, [sp, #4]

    // Twiddle factors are ones
    *p2++ = t2[0];
    *p2++ = t2[1];
    *p3++ = t3[0];
    *p3++ = t3[1];
 8026cfe:	ed80 6a01 	vstr	s12, [r0, #4]
    *p4++ = t4[0];
    *p4++ = t4[1];

    tw2 += twMod2;
    tw3 += twMod3;
 8026d02:	f101 0e10 	add.w	lr, r1, #16
 8026d06:	f8cd e008 	str.w	lr, [sp, #8]
    tw4 += twMod4;
 8026d0a:	f101 0e18 	add.w	lr, r1, #24
 8026d0e:	f8cd e014 	str.w	lr, [sp, #20]
    // col 3
    t3[0] = p1ap3_0 - p2[0] - p4[0];
    t3[1] = p1ap3_1 - p2[1] - p4[1];
    // col 4
    t4[0] = p1sp3_0 - p2[1] + p4[1];
    t4[1] = p1sp3_1 + p2[0] - p4[0];
 8026d12:	ee77 7ac4 	vsub.f32	s15, s15, s8

    tw2 += twMod2;
    tw3 += twMod3;
    tw4 += twMod4;

    for (l = (L - 2) >> 1; l > 0; l-- )
 8026d16:	3a02      	subs	r2, #2
    // Twiddle factors are ones
    *p2++ = t2[0];
    *p2++ = t2[1];
    *p3++ = t3[0];
    *p3++ = t3[1];
    *p4++ = t4[0];
 8026d18:	ee16 ea90 	vmov	lr, s13
    *p4++ = t4[1];
 8026d1c:	9c00      	ldr	r4, [sp, #0]
    // Twiddle factors are ones
    *p2++ = t2[0];
    *p2++ = t2[1];
    *p3++ = t3[0];
    *p3++ = t3[1];
    *p4++ = t4[0];
 8026d1e:	f84c eb08 	str.w	lr, [ip], #8

    tw2 += twMod2;
    tw3 += twMod3;
    tw4 += twMod4;

    for (l = (L - 2) >> 1; l > 0; l-- )
 8026d22:	0852      	lsrs	r2, r2, #1
    *p2++ = t2[0];
    *p2++ = t2[1];
    *p3++ = t3[0];
    *p3++ = t3[1];
    *p4++ = t4[0];
    *p4++ = t4[1];
 8026d24:	edc4 7a01 	vstr	s15, [r4, #4]

    tw2 += twMod2;
    tw3 += twMod3;
    tw4 += twMod4;

    for (l = (L - 2) >> 1; l > 0; l-- )
 8026d28:	9207      	str	r2, [sp, #28]
 8026d2a:	f000 811b 	beq.w	8026f64 <arm_cfft_radix8by4_f32+0x354>
 8026d2e:	4604      	mov	r4, r0
 8026d30:	3b08      	subs	r3, #8
 8026d32:	f8dd a008 	ldr.w	sl, [sp, #8]
 8026d36:	f8cd c034 	str.w	ip, [sp, #52]	; 0x34
 8026d3a:	4693      	mov	fp, r2
 8026d3c:	f101 0920 	add.w	r9, r1, #32
 8026d40:	f1a0 020c 	sub.w	r2, r0, #12
 8026d44:	f101 0e30 	add.w	lr, r1, #48	; 0x30
 8026d48:	4433      	add	r3, r6
 8026d4a:	3510      	adds	r5, #16
 8026d4c:	3410      	adds	r4, #16
 8026d4e:	4660      	mov	r0, ip
 8026d50:	4641      	mov	r1, r8
    {
        // TOP
        p1ap3_0 = p1[0] + p3[0];
 8026d52:	ed14 7a02 	vldr	s14, [r4, #-8]
 8026d56:	ed55 3a02 	vldr	s7, [r5, #-8]
        p1sp3_0 = p1[0] - p3[0];
        p1ap3_1 = p1[1] + p3[1];
        p1sp3_1 = p1[1] - p3[1];
        // col 2
        t2[0] = p1sp3_0 + p2[1] - p4[1];
        t2[1] = p1sp3_1 - p2[0] + p4[0];
 8026d5a:	edd1 5a00 	vldr	s11, [r1]
 8026d5e:	ed90 6a00 	vldr	s12, [r0]
    for (l = (L - 2) >> 1; l > 0; l-- )
    {
        // TOP
        p1ap3_0 = p1[0] + p3[0];
        p1sp3_0 = p1[0] - p3[0];
        p1ap3_1 = p1[1] + p3[1];
 8026d62:	ed54 6a01 	vldr	s13, [r4, #-4]
 8026d66:	ed15 5a01 	vldr	s10, [r5, #-4]
        p1sp3_1 = p1[1] - p3[1];
        // col 2
        t2[0] = p1sp3_0 + p2[1] - p4[1];
 8026d6a:	edd0 4a01 	vldr	s9, [r0, #4]
 8026d6e:	ed91 4a01 	vldr	s8, [r1, #4]
    tw4 += twMod4;

    for (l = (L - 2) >> 1; l > 0; l-- )
    {
        // TOP
        p1ap3_0 = p1[0] + p3[0];
 8026d72:	ee33 0a87 	vadd.f32	s0, s7, s14
        p1sp3_0 = p1[0] - p3[0];
        p1ap3_1 = p1[1] + p3[1];
 8026d76:	ee35 8a26 	vadd.f32	s16, s10, s13
        t3[1] = p1ap3_1 - p2[1] - p4[1];
        // col 4
        t4[0] = p1sp3_0 - p2[1] + p4[1];
        t4[1] = p1sp3_1 + p2[0] - p4[0];
        // col 1 - top
        *p1++ = p1ap3_0 + p2[0] + p4[0];
 8026d7a:	ee70 7a25 	vadd.f32	s15, s0, s11

    for (l = (L - 2) >> 1; l > 0; l-- )
    {
        // TOP
        p1ap3_0 = p1[0] + p3[0];
        p1sp3_0 = p1[0] - p3[0];
 8026d7e:	ee73 3ac7 	vsub.f32	s7, s7, s14
        t3[1] = p1ap3_1 - p2[1] - p4[1];
        // col 4
        t4[0] = p1sp3_0 - p2[1] + p4[1];
        t4[1] = p1sp3_1 + p2[0] - p4[0];
        // col 1 - top
        *p1++ = p1ap3_0 + p2[0] + p4[0];
 8026d82:	ee76 7a27 	vadd.f32	s15, s12, s15
    {
        // TOP
        p1ap3_0 = p1[0] + p3[0];
        p1sp3_0 = p1[0] - p3[0];
        p1ap3_1 = p1[1] + p3[1];
        p1sp3_1 = p1[1] - p3[1];
 8026d86:	ee35 5a66 	vsub.f32	s10, s10, s13
        t3[1] = p1ap3_1 - p2[1] - p4[1];
        // col 4
        t4[0] = p1sp3_0 - p2[1] + p4[1];
        t4[1] = p1sp3_1 + p2[0] - p4[0];
        // col 1 - top
        *p1++ = p1ap3_0 + p2[0] + p4[0];
 8026d8a:	ed45 7a02 	vstr	s15, [r5, #-8]
        *p1++ = p1ap3_1 + p2[1] + p4[1];
 8026d8e:	edd1 7a01 	vldr	s15, [r1, #4]
 8026d92:	ed90 7a01 	vldr	s14, [r0, #4]
 8026d96:	ee78 7a27 	vadd.f32	s15, s16, s15
        p1sp3_0 = p1[0] - p3[0];
        p1ap3_1 = p1[1] + p3[1];
        p1sp3_1 = p1[1] - p3[1];
        // col 2
        t2[0] = p1sp3_0 + p2[1] - p4[1];
        t2[1] = p1sp3_1 - p2[0] + p4[0];
 8026d9a:	ee35 aa65 	vsub.f32	s20, s10, s11
        // col 4
        t4[0] = p1sp3_0 - p2[1] + p4[1];
        t4[1] = p1sp3_1 + p2[0] - p4[0];
        // col 1 - top
        *p1++ = p1ap3_0 + p2[0] + p4[0];
        *p1++ = p1ap3_1 + p2[1] + p4[1];
 8026d9e:	ee77 7a87 	vadd.f32	s15, s15, s14
        p1sp3_0 = p1[0] - p3[0];
        p1ap3_1 = p1[1] + p3[1];
        p1sp3_1 = p1[1] - p3[1];
        // col 2
        t2[0] = p1sp3_0 + p2[1] - p4[1];
        t2[1] = p1sp3_1 - p2[0] + p4[0];
 8026da2:	ee3a aa06 	vadd.f32	s20, s20, s12
        // col 4
        t4[0] = p1sp3_0 - p2[1] + p4[1];
        t4[1] = p1sp3_1 + p2[0] - p4[0];
        // col 1 - top
        *p1++ = p1ap3_0 + p2[0] + p4[0];
        *p1++ = p1ap3_1 + p2[1] + p4[1];
 8026da6:	ed45 7a01 	vstr	s15, [r5, #-4]

        // BOTTOM
        p1ap3_1 = pEnd1[-1] + pEnd3[-1];
        p1sp3_1 = pEnd1[-1] - pEnd3[-1];
        p1ap3_0 = pEnd1[0] + pEnd3[0];
 8026daa:	ed96 2a00 	vldr	s4, [r6]
 8026dae:	ed97 1a00 	vldr	s2, [r7]
        p1sp3_0 = pEnd1[0] - pEnd3[0];
        // col 2
        t2[2] = pEnd2[0]  - pEnd4[0] + p1sp3_1;
 8026db2:	edd2 7a02 	vldr	s15, [r2, #8]
 8026db6:	ed93 7a02 	vldr	s14, [r3, #8]
        t2[3] = pEnd1[0] - pEnd3[0] - pEnd2[-1] + pEnd4[-1];
 8026dba:	edd3 2a01 	vldr	s5, [r3, #4]
        // col 1 - top
        *p1++ = p1ap3_0 + p2[0] + p4[0];
        *p1++ = p1ap3_1 + p2[1] + p4[1];

        // BOTTOM
        p1ap3_1 = pEnd1[-1] + pEnd3[-1];
 8026dbe:	ed56 1a01 	vldr	s3, [r6, #-4]
        p1sp3_1 = pEnd1[-1] - pEnd3[-1];
        p1ap3_0 = pEnd1[0] + pEnd3[0];
        p1sp3_0 = pEnd1[0] - pEnd3[0];
        // col 2
        t2[2] = pEnd2[0]  - pEnd4[0] + p1sp3_1;
        t2[3] = pEnd1[0] - pEnd3[0] - pEnd2[-1] + pEnd4[-1];
 8026dc2:	ed92 3a01 	vldr	s6, [r2, #4]
        // col 1 - top
        *p1++ = p1ap3_0 + p2[0] + p4[0];
        *p1++ = p1ap3_1 + p2[1] + p4[1];

        // BOTTOM
        p1ap3_1 = pEnd1[-1] + pEnd3[-1];
 8026dc6:	ed57 9a01 	vldr	s19, [r7, #-4]
        p1sp3_1 = pEnd1[-1] - pEnd3[-1];
        p1ap3_0 = pEnd1[0] + pEnd3[0];
 8026dca:	ee71 6a02 	vadd.f32	s13, s2, s4
        // col 1 - top
        *p1++ = p1ap3_0 + p2[0] + p4[0];
        *p1++ = p1ap3_1 + p2[1] + p4[1];

        // BOTTOM
        p1ap3_1 = pEnd1[-1] + pEnd3[-1];
 8026dce:	ee79 0aa1 	vadd.f32	s1, s19, s3
        t3[3] = p1ap3_0 - pEnd2[0]  - pEnd4[0];
        // col 4
        t4[2] = pEnd2[0]  - pEnd4[0]  - p1sp3_1;
        t4[3] = pEnd4[-1] - pEnd2[-1] - p1sp3_0;
        // col 1 - Bottom
        *pEnd1-- = p1ap3_0 + pEnd2[0] + pEnd4[0];
 8026dd2:	ee76 8aa7 	vadd.f32	s17, s13, s15

        // BOTTOM
        p1ap3_1 = pEnd1[-1] + pEnd3[-1];
        p1sp3_1 = pEnd1[-1] - pEnd3[-1];
        p1ap3_0 = pEnd1[0] + pEnd3[0];
        p1sp3_0 = pEnd1[0] - pEnd3[0];
 8026dd6:	ee31 2a42 	vsub.f32	s4, s2, s4
        t3[3] = p1ap3_0 - pEnd2[0]  - pEnd4[0];
        // col 4
        t4[2] = pEnd2[0]  - pEnd4[0]  - p1sp3_1;
        t4[3] = pEnd4[-1] - pEnd2[-1] - p1sp3_0;
        // col 1 - Bottom
        *pEnd1-- = p1ap3_0 + pEnd2[0] + pEnd4[0];
 8026dda:	ee77 8a28 	vadd.f32	s17, s14, s17
        p1ap3_0 = p1[0] + p3[0];
        p1sp3_0 = p1[0] - p3[0];
        p1ap3_1 = p1[1] + p3[1];
        p1sp3_1 = p1[1] - p3[1];
        // col 2
        t2[0] = p1sp3_0 + p2[1] - p4[1];
 8026dde:	ee74 aa23 	vadd.f32	s21, s8, s7
        t3[3] = p1ap3_0 - pEnd2[0]  - pEnd4[0];
        // col 4
        t4[2] = pEnd2[0]  - pEnd4[0]  - p1sp3_1;
        t4[3] = pEnd4[-1] - pEnd2[-1] - p1sp3_0;
        // col 1 - Bottom
        *pEnd1-- = p1ap3_0 + pEnd2[0] + pEnd4[0];
 8026de2:	ee18 ca90 	vmov	ip, s17
 8026de6:	f847 c908 	str.w	ip, [r7], #-8
        *pEnd1-- = p1ap3_1 + pEnd2[-1] + pEnd4[-1];
 8026dea:	edd2 8a01 	vldr	s17, [r2, #4]
 8026dee:	ed93 9a01 	vldr	s18, [r3, #4]
 8026df2:	ee70 8aa8 	vadd.f32	s17, s1, s17
        p1ap3_1 = pEnd1[-1] + pEnd3[-1];
        p1sp3_1 = pEnd1[-1] - pEnd3[-1];
        p1ap3_0 = pEnd1[0] + pEnd3[0];
        p1sp3_0 = pEnd1[0] - pEnd3[0];
        // col 2
        t2[2] = pEnd2[0]  - pEnd4[0] + p1sp3_1;
 8026df6:	ee37 1ac7 	vsub.f32	s2, s15, s14
        // col 4
        t4[2] = pEnd2[0]  - pEnd4[0]  - p1sp3_1;
        t4[3] = pEnd4[-1] - pEnd2[-1] - p1sp3_0;
        // col 1 - Bottom
        *pEnd1-- = p1ap3_0 + pEnd2[0] + pEnd4[0];
        *pEnd1-- = p1ap3_1 + pEnd2[-1] + pEnd4[-1];
 8026dfa:	ee78 8a89 	vadd.f32	s17, s17, s18
        p1ap3_0 = p1[0] + p3[0];
        p1sp3_0 = p1[0] - p3[0];
        p1ap3_1 = p1[1] + p3[1];
        p1sp3_1 = p1[1] - p3[1];
        // col 2
        t2[0] = p1sp3_0 + p2[1] - p4[1];
 8026dfe:	ee7a aae4 	vsub.f32	s21, s21, s9
        // col 4
        t4[2] = pEnd2[0]  - pEnd4[0]  - p1sp3_1;
        t4[3] = pEnd4[-1] - pEnd2[-1] - p1sp3_0;
        // col 1 - Bottom
        *pEnd1-- = p1ap3_0 + pEnd2[0] + pEnd4[0];
        *pEnd1-- = p1ap3_1 + pEnd2[-1] + pEnd4[-1];
 8026e02:	edc7 8a01 	vstr	s17, [r7, #4]

        // COL 2
        // read twiddle factors
        twR = *tw2++;
        twI = *tw2++;
 8026e06:	ed5a 8a01 	vldr	s17, [sl, #-4]
        *p1++ = p1ap3_0 + p2[0] + p4[0];
        *p1++ = p1ap3_1 + p2[1] + p4[1];

        // BOTTOM
        p1ap3_1 = pEnd1[-1] + pEnd3[-1];
        p1sp3_1 = pEnd1[-1] - pEnd3[-1];
 8026e0a:	ee79 1ae1 	vsub.f32	s3, s19, s3
        //  let    Z1 = a + i(b),   Z2 = c + i(d)
        //   =>  Z1 * Z2  =  (a*c - b*d) + i(b*c + a*d)

        // Top
        m0 = t2[0] * twR;
        m1 = t2[1] * twI;
 8026e0e:	ee2a ca28 	vmul.f32	s24, s20, s17
        *pEnd1-- = p1ap3_0 + pEnd2[0] + pEnd4[0];
        *pEnd1-- = p1ap3_1 + pEnd2[-1] + pEnd4[-1];

        // COL 2
        // read twiddle factors
        twR = *tw2++;
 8026e12:	ed5a 9a02 	vldr	s19, [sl, #-8]
        p1sp3_1 = pEnd1[-1] - pEnd3[-1];
        p1ap3_0 = pEnd1[0] + pEnd3[0];
        p1sp3_0 = pEnd1[0] - pEnd3[0];
        // col 2
        t2[2] = pEnd2[0]  - pEnd4[0] + p1sp3_1;
        t2[3] = pEnd1[0] - pEnd3[0] - pEnd2[-1] + pEnd4[-1];
 8026e16:	ee32 9a43 	vsub.f32	s18, s4, s6
        m0 = t2[0] * twR;
        m1 = t2[1] * twI;
        m2 = t2[1] * twR;
        m3 = t2[0] * twI;

        *p2++ = m0 + m1;
 8026e1a:	eeaa caa9 	vfma.f32	s24, s21, s19

    tw2 += twMod2;
    tw3 += twMod3;
    tw4 += twMod4;

    for (l = (L - 2) >> 1; l > 0; l-- )
 8026e1e:	f1bb 0b01 	subs.w	fp, fp, #1
 8026e22:	f105 0508 	add.w	r5, r5, #8
        p1sp3_1 = pEnd1[-1] - pEnd3[-1];
        p1ap3_0 = pEnd1[0] + pEnd3[0];
        p1sp3_0 = pEnd1[0] - pEnd3[0];
        // col 2
        t2[2] = pEnd2[0]  - pEnd4[0] + p1sp3_1;
        t2[3] = pEnd1[0] - pEnd3[0] - pEnd2[-1] + pEnd4[-1];
 8026e26:	ee39 9a22 	vadd.f32	s18, s18, s5
        p1ap3_1 = pEnd1[-1] + pEnd3[-1];
        p1sp3_1 = pEnd1[-1] - pEnd3[-1];
        p1ap3_0 = pEnd1[0] + pEnd3[0];
        p1sp3_0 = pEnd1[0] - pEnd3[0];
        // col 2
        t2[2] = pEnd2[0]  - pEnd4[0] + p1sp3_1;
 8026e2a:	ee71 ca21 	vadd.f32	s25, s2, s3
 8026e2e:	ee68 baea 	vnmul.f32	s23, s17, s21
 8026e32:	ee29 baec 	vnmul.f32	s22, s19, s25
        // 0.9997 - 0.0245i  <==>  0.0245 - 0.9997i
        // Bottom
        m0 = t2[3] * twI;
        m1 = t2[2] * twR;
        m2 = t2[2] * twI;
        m3 = t2[3] * twR;
 8026e36:	ee69 aa29 	vmul.f32	s21, s18, s19

        *pEnd2-- = m0 - m1;
 8026e3a:	eea9 ba28 	vfma.f32	s22, s18, s17
 8026e3e:	f10a 0a08 	add.w	sl, sl, #8
 8026e42:	f1a2 0208 	sub.w	r2, r2, #8
        m1 = t2[1] * twI;
        m2 = t2[1] * twR;
        m3 = t2[0] * twI;

        *p2++ = m0 + m1;
        *p2++ = m2 - m3;
 8026e46:	eeea ba29 	vfma.f32	s23, s20, s19
 8026e4a:	f109 0910 	add.w	r9, r9, #16
 8026e4e:	f104 0408 	add.w	r4, r4, #8
        m0 = t2[0] * twR;
        m1 = t2[1] * twI;
        m2 = t2[1] * twR;
        m3 = t2[0] * twI;

        *p2++ = m0 + m1;
 8026e52:	ee1c ca10 	vmov	ip, s24
        m1 = t2[2] * twR;
        m2 = t2[2] * twI;
        m3 = t2[3] * twR;

        *pEnd2-- = m0 - m1;
        *pEnd2-- = m2 + m3;
 8026e56:	eeec aaa8 	vfma.f32	s21, s25, s17
        m0 = t2[0] * twR;
        m1 = t2[1] * twI;
        m2 = t2[1] * twR;
        m3 = t2[0] * twI;

        *p2++ = m0 + m1;
 8026e5a:	f841 cb08 	str.w	ip, [r1], #8
        p1sp3_0 = pEnd1[0] - pEnd3[0];
        // col 2
        t2[2] = pEnd2[0]  - pEnd4[0] + p1sp3_1;
        t2[3] = pEnd1[0] - pEnd3[0] - pEnd2[-1] + pEnd4[-1];
        // col 3
        t3[2] = p1ap3_1 - pEnd2[-1] - pEnd4[-1];
 8026e5e:	ee70 0ac3 	vsub.f32	s1, s1, s6
        m1 = t2[1] * twI;
        m2 = t2[1] * twR;
        m3 = t2[0] * twI;

        *p2++ = m0 + m1;
        *p2++ = m2 - m3;
 8026e62:	ed41 ba01 	vstr	s23, [r1, #-4]
        m0 = t2[3] * twI;
        m1 = t2[2] * twR;
        m2 = t2[2] * twI;
        m3 = t2[3] * twR;

        *pEnd2-- = m0 - m1;
 8026e66:	ed82 ba04 	vstr	s22, [r2, #16]
        *pEnd2-- = m2 + m3;
 8026e6a:	edc2 aa03 	vstr	s21, [r2, #12]
        // col 2
        t2[2] = pEnd2[0]  - pEnd4[0] + p1sp3_1;
        t2[3] = pEnd1[0] - pEnd3[0] - pEnd2[-1] + pEnd4[-1];
        // col 3
        t3[2] = p1ap3_1 - pEnd2[-1] - pEnd4[-1];
        t3[3] = p1ap3_0 - pEnd2[0]  - pEnd4[0];
 8026e6e:	ee76 6ae7 	vsub.f32	s13, s13, s15
        p1sp3_1 = p1[1] - p3[1];
        // col 2
        t2[0] = p1sp3_0 + p2[1] - p4[1];
        t2[1] = p1sp3_1 - p2[0] + p4[0];
        // col 3
        t3[0] = p1ap3_0 - p2[0] - p4[0];
 8026e72:	ee30 0a65 	vsub.f32	s0, s0, s11
        *pEnd2-- = m0 - m1;
        *pEnd2-- = m2 + m3;

        // COL 3
        twR = tw3[0];
        twI = tw3[1];
 8026e76:	ed59 7a07 	vldr	s15, [r9, #-28]	; 0xffffffe4

        *pEnd2-- = m0 - m1;
        *pEnd2-- = m2 + m3;

        // COL 3
        twR = tw3[0];
 8026e7a:	ed59 8a08 	vldr	s17, [r9, #-32]	; 0xffffffe0
        // col 2
        t2[0] = p1sp3_0 + p2[1] - p4[1];
        t2[1] = p1sp3_1 - p2[0] + p4[0];
        // col 3
        t3[0] = p1ap3_0 - p2[0] - p4[0];
        t3[1] = p1ap3_1 - p2[1] - p4[1];
 8026e7e:	ee38 8a44 	vsub.f32	s16, s16, s8
        p1sp3_0 = pEnd1[0] - pEnd3[0];
        // col 2
        t2[2] = pEnd2[0]  - pEnd4[0] + p1sp3_1;
        t2[3] = pEnd1[0] - pEnd3[0] - pEnd2[-1] + pEnd4[-1];
        // col 3
        t3[2] = p1ap3_1 - pEnd2[-1] - pEnd4[-1];
 8026e82:	ee70 0ae2 	vsub.f32	s1, s1, s5
        t3[3] = p1ap3_0 - pEnd2[0]  - pEnd4[0];
 8026e86:	ee36 7ac7 	vsub.f32	s14, s13, s14
        p1sp3_1 = p1[1] - p3[1];
        // col 2
        t2[0] = p1sp3_0 + p2[1] - p4[1];
        t2[1] = p1sp3_1 - p2[0] + p4[0];
        // col 3
        t3[0] = p1ap3_0 - p2[0] - p4[0];
 8026e8a:	ee30 0a46 	vsub.f32	s0, s0, s12
        t3[1] = p1ap3_1 - p2[1] - p4[1];
 8026e8e:	ee38 8a64 	vsub.f32	s16, s16, s9
 8026e92:	ee67 6ae0 	vnmul.f32	s13, s15, s1
        twR = tw3[0];
        twI = tw3[1];
        tw3 += twMod3;
        // Top
        m0 = t3[0] * twR;
        m1 = t3[1] * twI;
 8026e96:	ee68 9a27 	vmul.f32	s19, s16, s15
        m0 = -t3[3] * twR;
        m1 = t3[2] * twI;
        m2 = t3[2] * twR;
        m3 = t3[3] * twI;

        *pEnd3-- = m0 - m1;
 8026e9a:	eee7 6a68 	vfms.f32	s13, s14, s17
 8026e9e:	f10e 0e18 	add.w	lr, lr, #24
 8026ea2:	f1a3 0308 	sub.w	r3, r3, #8
 8026ea6:	ee27 9ac0 	vnmul.f32	s18, s15, s0
        m0 = t3[0] * twR;
        m1 = t3[1] * twI;
        m2 = t3[1] * twR;
        m3 = t3[0] * twI;

        *p3++ = m0 + m1;
 8026eaa:	eee0 9a28 	vfma.f32	s19, s0, s17
        // 0.9988 - 0.0491i  <==>  -0.9988 - 0.0491i
        // Bottom
        m0 = -t3[3] * twR;
        m1 = t3[2] * twI;
        m2 = t3[2] * twR;
        m3 = t3[3] * twI;
 8026eae:	ee67 7a27 	vmul.f32	s15, s14, s15
        m1 = t3[1] * twI;
        m2 = t3[1] * twR;
        m3 = t3[0] * twI;

        *p3++ = m0 + m1;
        *p3++ = m2 - m3;
 8026eb2:	eea8 9a28 	vfma.f32	s18, s16, s17
        m0 = -t3[3] * twR;
        m1 = t3[2] * twI;
        m2 = t3[2] * twR;
        m3 = t3[3] * twI;

        *pEnd3-- = m0 - m1;
 8026eb6:	ee16 ca90 	vmov	ip, s13
        *pEnd3-- = m3 - m2;
 8026eba:	eee0 7ae8 	vfms.f32	s15, s1, s17
        m0 = t3[0] * twR;
        m1 = t3[1] * twI;
        m2 = t3[1] * twR;
        m3 = t3[0] * twI;

        *p3++ = m0 + m1;
 8026ebe:	ed44 9a04 	vstr	s19, [r4, #-16]
        *p3++ = m2 - m3;
 8026ec2:	ed04 9a03 	vstr	s18, [r4, #-12]
        m0 = -t3[3] * twR;
        m1 = t3[2] * twI;
        m2 = t3[2] * twR;
        m3 = t3[3] * twI;

        *pEnd3-- = m0 - m1;
 8026ec6:	f846 c908 	str.w	ip, [r6], #-8
        // col 3
        t3[0] = p1ap3_0 - p2[0] - p4[0];
        t3[1] = p1ap3_1 - p2[1] - p4[1];
        // col 4
        t4[0] = p1sp3_0 - p2[1] + p4[1];
        t4[1] = p1sp3_1 + p2[0] - p4[0];
 8026eca:	ee75 5a25 	vadd.f32	s11, s10, s11
        m1 = t3[2] * twI;
        m2 = t3[2] * twR;
        m3 = t3[3] * twI;

        *pEnd3-- = m0 - m1;
        *pEnd3-- = m3 - m2;
 8026ece:	edc6 7a01 	vstr	s15, [r6, #4]

        // COL 4
        twR = tw4[0];
        twI = tw4[1];
 8026ed2:	ed5e 6a0b 	vldr	s13, [lr, #-44]	; 0xffffffd4
        // col 3
        t3[0] = p1ap3_0 - p2[0] - p4[0];
        t3[1] = p1ap3_1 - p2[1] - p4[1];
        // col 4
        t4[0] = p1sp3_0 - p2[1] + p4[1];
        t4[1] = p1sp3_1 + p2[0] - p4[0];
 8026ed6:	ee35 6ac6 	vsub.f32	s12, s11, s12
        t2[1] = p1sp3_1 - p2[0] + p4[0];
        // col 3
        t3[0] = p1ap3_0 - p2[0] - p4[0];
        t3[1] = p1ap3_1 - p2[1] - p4[1];
        // col 4
        t4[0] = p1sp3_0 - p2[1] + p4[1];
 8026eda:	ee33 4ac4 	vsub.f32	s8, s7, s8
        // col 3
        t3[2] = p1ap3_1 - pEnd2[-1] - pEnd4[-1];
        t3[3] = p1ap3_0 - pEnd2[0]  - pEnd4[0];
        // col 4
        t4[2] = pEnd2[0]  - pEnd4[0]  - p1sp3_1;
        t4[3] = pEnd4[-1] - pEnd2[-1] - p1sp3_0;
 8026ede:	ee72 7ac3 	vsub.f32	s15, s5, s6

        *pEnd3-- = m0 - m1;
        *pEnd3-- = m3 - m2;

        // COL 4
        twR = tw4[0];
 8026ee2:	ed5e 5a0c 	vldr	s11, [lr, #-48]	; 0xffffffd0
        t2[1] = p1sp3_1 - p2[0] + p4[0];
        // col 3
        t3[0] = p1ap3_0 - p2[0] - p4[0];
        t3[1] = p1ap3_1 - p2[1] - p4[1];
        // col 4
        t4[0] = p1sp3_0 - p2[1] + p4[1];
 8026ee6:	ee74 4a84 	vadd.f32	s9, s9, s8
        t2[3] = pEnd1[0] - pEnd3[0] - pEnd2[-1] + pEnd4[-1];
        // col 3
        t3[2] = p1ap3_1 - pEnd2[-1] - pEnd4[-1];
        t3[3] = p1ap3_0 - pEnd2[0]  - pEnd4[0];
        // col 4
        t4[2] = pEnd2[0]  - pEnd4[0]  - p1sp3_1;
 8026eea:	ee31 7a61 	vsub.f32	s14, s2, s3
        twR = tw4[0];
        twI = tw4[1];
        tw4 += twMod4;
        // Top
        m0 = t4[0] * twR;
        m1 = t4[1] * twI;
 8026eee:	ee66 3a26 	vmul.f32	s7, s12, s13
        // col 3
        t3[2] = p1ap3_1 - pEnd2[-1] - pEnd4[-1];
        t3[3] = p1ap3_0 - pEnd2[0]  - pEnd4[0];
        // col 4
        t4[2] = pEnd2[0]  - pEnd4[0]  - p1sp3_1;
        t4[3] = pEnd4[-1] - pEnd2[-1] - p1sp3_0;
 8026ef2:	ee77 7ac2 	vsub.f32	s15, s15, s4
 8026ef6:	ee26 4ae4 	vnmul.f32	s8, s13, s9
        m0 = t4[0] * twR;
        m1 = t4[1] * twI;
        m2 = t4[1] * twR;
        m3 = t4[0] * twI;

        *p4++ = m0 + m1;
 8026efa:	eee4 3aa5 	vfma.f32	s7, s9, s11
 8026efe:	ee65 4ac7 	vnmul.f32	s9, s11, s14
        // 0.9973 - 0.0736i  <==>  -0.0736 + 0.9973i
        // Bottom
        m0 = t4[3] * twI;
        m1 = t4[2] * twR;
        m2 = t4[2] * twI;
        m3 = t4[3] * twR;
 8026f02:	ee27 5aa5 	vmul.f32	s10, s15, s11
        m1 = t4[1] * twI;
        m2 = t4[1] * twR;
        m3 = t4[0] * twI;

        *p4++ = m0 + m1;
        *p4++ = m2 - m3;
 8026f06:	eea6 4a25 	vfma.f32	s8, s12, s11
        m0 = t4[3] * twI;
        m1 = t4[2] * twR;
        m2 = t4[2] * twI;
        m3 = t4[3] * twR;

        *pEnd4-- = m0 - m1;
 8026f0a:	eeb0 6a64 	vmov.f32	s12, s9
 8026f0e:	eea7 6aa6 	vfma.f32	s12, s15, s13
        *pEnd4-- = m2 + m3;
 8026f12:	eef0 7a45 	vmov.f32	s15, s10
        m0 = t4[0] * twR;
        m1 = t4[1] * twI;
        m2 = t4[1] * twR;
        m3 = t4[0] * twI;

        *p4++ = m0 + m1;
 8026f16:	ee13 ca90 	vmov	ip, s7
        m1 = t4[2] * twR;
        m2 = t4[2] * twI;
        m3 = t4[3] * twR;

        *pEnd4-- = m0 - m1;
        *pEnd4-- = m2 + m3;
 8026f1a:	eee7 7a26 	vfma.f32	s15, s14, s13
        m0 = t4[0] * twR;
        m1 = t4[1] * twI;
        m2 = t4[1] * twR;
        m3 = t4[0] * twI;

        *p4++ = m0 + m1;
 8026f1e:	f840 cb08 	str.w	ip, [r0], #8
        *p4++ = m2 - m3;
 8026f22:	ed00 4a01 	vstr	s8, [r0, #-4]
        m0 = t4[3] * twI;
        m1 = t4[2] * twR;
        m2 = t4[2] * twI;
        m3 = t4[3] * twR;

        *pEnd4-- = m0 - m1;
 8026f26:	ed83 6a04 	vstr	s12, [r3, #16]
        *pEnd4-- = m2 + m3;
 8026f2a:	edc3 7a03 	vstr	s15, [r3, #12]

    tw2 += twMod2;
    tw3 += twMod3;
    tw4 += twMod4;

    for (l = (L - 2) >> 1; l > 0; l-- )
 8026f2e:	f47f af10 	bne.w	8026d52 <arm_cfft_radix8by4_f32+0x142>
 8026f32:	9907      	ldr	r1, [sp, #28]
 8026f34:	9802      	ldr	r0, [sp, #8]
 8026f36:	f8dd c034 	ldr.w	ip, [sp, #52]	; 0x34
 8026f3a:	00cb      	lsls	r3, r1, #3
 8026f3c:	eb01 0241 	add.w	r2, r1, r1, lsl #1
 8026f40:	eb00 1101 	add.w	r1, r0, r1, lsl #4
 8026f44:	9102      	str	r1, [sp, #8]
 8026f46:	9903      	ldr	r1, [sp, #12]
 8026f48:	4419      	add	r1, r3
 8026f4a:	9103      	str	r1, [sp, #12]
 8026f4c:	9904      	ldr	r1, [sp, #16]
 8026f4e:	4419      	add	r1, r3
 8026f50:	9104      	str	r1, [sp, #16]
 8026f52:	9906      	ldr	r1, [sp, #24]
 8026f54:	4498      	add	r8, r3
 8026f56:	4419      	add	r1, r3
 8026f58:	449c      	add	ip, r3
 8026f5a:	9b05      	ldr	r3, [sp, #20]
 8026f5c:	9106      	str	r1, [sp, #24]
 8026f5e:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8026f62:	9305      	str	r3, [sp, #20]
    }

    //MIDDLE
    // Twiddle factors are
    //  1.0000  0.7071-0.7071i  -1.0000i  -0.7071-0.7071i
    p1ap3_0 = p1[0] + p3[0];
 8026f64:	9a03      	ldr	r2, [sp, #12]
 8026f66:	9e06      	ldr	r6, [sp, #24]
 8026f68:	ed92 3a00 	vldr	s6, [r2]
 8026f6c:	edd6 6a00 	vldr	s13, [r6]
    p1ap3_1 = p1[1] + p3[1];
    p1sp3_1 = p1[1] - p3[1];

    // col 2
    t2[0] = p1sp3_0 + p2[1] - p4[1];
    t2[1] = p1sp3_1 - p2[0] + p4[0];
 8026f70:	edd8 7a00 	vldr	s15, [r8]
 8026f74:	ed9c 4a00 	vldr	s8, [ip]
    //MIDDLE
    // Twiddle factors are
    //  1.0000  0.7071-0.7071i  -1.0000i  -0.7071-0.7071i
    p1ap3_0 = p1[0] + p3[0];
    p1sp3_0 = p1[0] - p3[0];
    p1ap3_1 = p1[1] + p3[1];
 8026f78:	ed96 7a01 	vldr	s14, [r6, #4]
 8026f7c:	edd2 3a01 	vldr	s7, [r2, #4]
    p1sp3_1 = p1[1] - p3[1];

    // col 2
    t2[0] = p1sp3_0 + p2[1] - p4[1];
 8026f80:	edd8 2a01 	vldr	s5, [r8, #4]
 8026f84:	eddc 4a01 	vldr	s9, [ip, #4]

    *p2++ = m0 + m1;
    *p2++ = m2 - m3;
    // COL 3
    twR = tw3[0];
    twI = tw3[1];
 8026f88:	9d02      	ldr	r5, [sp, #8]

    *p4++ = m0 + m1;
    *p4++ = m2 - m3;

    // first col
    arm_radix8_butterfly_f32( pCol1, L, (float32_t *) S->pTwiddle, 4u);
 8026f8a:	f8bd 4028 	ldrh.w	r4, [sp, #40]	; 0x28
 8026f8e:	980c      	ldr	r0, [sp, #48]	; 0x30
    }

    //MIDDLE
    // Twiddle factors are
    //  1.0000  0.7071-0.7071i  -1.0000i  -0.7071-0.7071i
    p1ap3_0 = p1[0] + p3[0];
 8026f90:	ee73 5a26 	vadd.f32	s11, s6, s13
    p1sp3_0 = p1[0] - p3[0];
    p1ap3_1 = p1[1] + p3[1];
 8026f94:	ee33 6a87 	vadd.f32	s12, s7, s14
    t3[1] = p1ap3_1 - p2[1] - p4[1];
    // col 4
    t4[0] = p1sp3_0 - p2[1] + p4[1];
    t4[1] = p1sp3_1 + p2[0] - p4[0];
    // col 1 - Top
    *p1++ = p1ap3_0 + p2[0] + p4[0];
 8026f98:	ee35 5aa7 	vadd.f32	s10, s11, s15

    //MIDDLE
    // Twiddle factors are
    //  1.0000  0.7071-0.7071i  -1.0000i  -0.7071-0.7071i
    p1ap3_0 = p1[0] + p3[0];
    p1sp3_0 = p1[0] - p3[0];
 8026f9c:	ee73 6a66 	vsub.f32	s13, s6, s13
    t3[1] = p1ap3_1 - p2[1] - p4[1];
    // col 4
    t4[0] = p1sp3_0 - p2[1] + p4[1];
    t4[1] = p1sp3_1 + p2[0] - p4[0];
    // col 1 - Top
    *p1++ = p1ap3_0 + p2[0] + p4[0];
 8026fa0:	ee34 5a05 	vadd.f32	s10, s8, s10
    // Twiddle factors are
    //  1.0000  0.7071-0.7071i  -1.0000i  -0.7071-0.7071i
    p1ap3_0 = p1[0] + p3[0];
    p1sp3_0 = p1[0] - p3[0];
    p1ap3_1 = p1[1] + p3[1];
    p1sp3_1 = p1[1] - p3[1];
 8026fa4:	ee33 7ac7 	vsub.f32	s14, s7, s14
    t3[1] = p1ap3_1 - p2[1] - p4[1];
    // col 4
    t4[0] = p1sp3_0 - p2[1] + p4[1];
    t4[1] = p1sp3_1 + p2[0] - p4[0];
    // col 1 - Top
    *p1++ = p1ap3_0 + p2[0] + p4[0];
 8026fa8:	ed82 5a00 	vstr	s10, [r2]
    *p1++ = p1ap3_1 + p2[1] + p4[1];
 8026fac:	ed98 5a01 	vldr	s10, [r8, #4]
 8026fb0:	ed9c 3a01 	vldr	s6, [ip, #4]
 8026fb4:	ee36 5a05 	vadd.f32	s10, s12, s10
    p1ap3_1 = p1[1] + p3[1];
    p1sp3_1 = p1[1] - p3[1];

    // col 2
    t2[0] = p1sp3_0 + p2[1] - p4[1];
    t2[1] = p1sp3_1 - p2[0] + p4[0];
 8026fb8:	ee77 3a67 	vsub.f32	s7, s14, s15
    // col 4
    t4[0] = p1sp3_0 - p2[1] + p4[1];
    t4[1] = p1sp3_1 + p2[0] - p4[0];
    // col 1 - Top
    *p1++ = p1ap3_0 + p2[0] + p4[0];
    *p1++ = p1ap3_1 + p2[1] + p4[1];
 8026fbc:	ee35 5a03 	vadd.f32	s10, s10, s6
    p1sp3_0 = p1[0] - p3[0];
    p1ap3_1 = p1[1] + p3[1];
    p1sp3_1 = p1[1] - p3[1];

    // col 2
    t2[0] = p1sp3_0 + p2[1] - p4[1];
 8026fc0:	ee32 3aa6 	vadd.f32	s6, s5, s13
    // col 4
    t4[0] = p1sp3_0 - p2[1] + p4[1];
    t4[1] = p1sp3_1 + p2[0] - p4[0];
    // col 1 - Top
    *p1++ = p1ap3_0 + p2[0] + p4[0];
    *p1++ = p1ap3_1 + p2[1] + p4[1];
 8026fc4:	ed82 5a01 	vstr	s10, [r2, #4]

    // COL 2
    twR = tw2[0];
    twI = tw2[1];
 8026fc8:	9a04      	ldr	r2, [sp, #16]
    p1ap3_1 = p1[1] + p3[1];
    p1sp3_1 = p1[1] - p3[1];

    // col 2
    t2[0] = p1sp3_0 + p2[1] - p4[1];
    t2[1] = p1sp3_1 - p2[0] + p4[0];
 8026fca:	ee73 3a84 	vadd.f32	s7, s7, s8
    *p1++ = p1ap3_0 + p2[0] + p4[0];
    *p1++ = p1ap3_1 + p2[1] + p4[1];

    // COL 2
    twR = tw2[0];
    twI = tw2[1];
 8026fce:	ed92 5a01 	vldr	s10, [r2, #4]
    // col 1 - Top
    *p1++ = p1ap3_0 + p2[0] + p4[0];
    *p1++ = p1ap3_1 + p2[1] + p4[1];

    // COL 2
    twR = tw2[0];
 8026fd2:	edd2 1a00 	vldr	s3, [r2]

    *p4++ = m0 + m1;
    *p4++ = m2 - m3;

    // first col
    arm_radix8_butterfly_f32( pCol1, L, (float32_t *) S->pTwiddle, 4u);
 8026fd6:	9a01      	ldr	r2, [sp, #4]
    p1sp3_0 = p1[0] - p3[0];
    p1ap3_1 = p1[1] + p3[1];
    p1sp3_1 = p1[1] - p3[1];

    // col 2
    t2[0] = p1sp3_0 + p2[1] - p4[1];
 8026fd8:	ee33 3a64 	vsub.f32	s6, s6, s9
    // COL 2
    twR = tw2[0];
    twI = tw2[1];

    m0 = t2[0] * twR;
    m1 = t2[1] * twI;
 8026fdc:	ee23 2a85 	vmul.f32	s4, s7, s10
 8026fe0:	ee25 5a43 	vnmul.f32	s10, s10, s6
    m2 = t2[1] * twR;
    m3 = t2[0] * twI;

    *p2++ = m0 + m1;
 8026fe4:	eea3 2a21 	vfma.f32	s4, s6, s3

    *p4++ = m0 + m1;
    *p4++ = m2 - m3;

    // first col
    arm_radix8_butterfly_f32( pCol1, L, (float32_t *) S->pTwiddle, 4u);
 8026fe8:	4621      	mov	r1, r4
 8026fea:	2304      	movs	r3, #4
    m1 = t2[1] * twI;
    m2 = t2[1] * twR;
    m3 = t2[0] * twI;

    *p2++ = m0 + m1;
    *p2++ = m2 - m3;
 8026fec:	eea3 5aa1 	vfma.f32	s10, s7, s3
    // col 2
    t2[0] = p1sp3_0 + p2[1] - p4[1];
    t2[1] = p1sp3_1 - p2[0] + p4[0];
    // col 3
    t3[0] = p1ap3_0 - p2[0] - p4[0];
    t3[1] = p1ap3_1 - p2[1] - p4[1];
 8026ff0:	ee36 6a62 	vsub.f32	s12, s12, s5

    // col 2
    t2[0] = p1sp3_0 + p2[1] - p4[1];
    t2[1] = p1sp3_1 - p2[0] + p4[0];
    // col 3
    t3[0] = p1ap3_0 - p2[0] - p4[0];
 8026ff4:	ee75 5ae7 	vsub.f32	s11, s11, s15
    m0 = t2[0] * twR;
    m1 = t2[1] * twI;
    m2 = t2[1] * twR;
    m3 = t2[0] * twI;

    *p2++ = m0 + m1;
 8026ff8:	ed88 2a00 	vstr	s4, [r8]
    *p2++ = m2 - m3;
 8026ffc:	ed88 5a01 	vstr	s10, [r8, #4]

    // col 2
    t2[0] = p1sp3_0 + p2[1] - p4[1];
    t2[1] = p1sp3_1 - p2[0] + p4[0];
    // col 3
    t3[0] = p1ap3_0 - p2[0] - p4[0];
 8027000:	ee75 5ac4 	vsub.f32	s11, s11, s8
    t3[1] = p1ap3_1 - p2[1] - p4[1];
 8027004:	ee36 6a64 	vsub.f32	s12, s12, s9

    *p2++ = m0 + m1;
    *p2++ = m2 - m3;
    // COL 3
    twR = tw3[0];
    twI = tw3[1];
 8027008:	ed95 5a01 	vldr	s10, [r5, #4]
    m3 = t2[0] * twI;

    *p2++ = m0 + m1;
    *p2++ = m2 - m3;
    // COL 3
    twR = tw3[0];
 802700c:	ed95 3a00 	vldr	s6, [r5]
    twI = tw3[1];

    m0 = t3[0] * twR;
    m1 = t3[1] * twI;
 8027010:	ee66 3a05 	vmul.f32	s7, s12, s10
 8027014:	ee25 5a65 	vnmul.f32	s10, s10, s11
    m2 = t3[1] * twR;
    m3 = t3[0] * twI;

    *p3++ = m0 + m1;
 8027018:	eee5 3a83 	vfma.f32	s7, s11, s6
 802701c:	4635      	mov	r5, r6
    *p3++ = m2 - m3;
 802701e:	eea6 5a03 	vfma.f32	s10, s12, s6
    m0 = t3[0] * twR;
    m1 = t3[1] * twI;
    m2 = t3[1] * twR;
    m3 = t3[0] * twI;

    *p3++ = m0 + m1;
 8027022:	edc5 3a00 	vstr	s7, [r5]
    t2[1] = p1sp3_1 - p2[0] + p4[0];
    // col 3
    t3[0] = p1ap3_0 - p2[0] - p4[0];
    t3[1] = p1ap3_1 - p2[1] - p4[1];
    // col 4
    t4[0] = p1sp3_0 - p2[1] + p4[1];
 8027026:	ee76 6ae2 	vsub.f32	s13, s13, s5
    m1 = t3[1] * twI;
    m2 = t3[1] * twR;
    m3 = t3[0] * twI;

    *p3++ = m0 + m1;
    *p3++ = m2 - m3;
 802702a:	ed86 5a01 	vstr	s10, [r6, #4]
    // col 3
    t3[0] = p1ap3_0 - p2[0] - p4[0];
    t3[1] = p1ap3_1 - p2[1] - p4[1];
    // col 4
    t4[0] = p1sp3_0 - p2[1] + p4[1];
    t4[1] = p1sp3_1 + p2[0] - p4[0];
 802702e:	ee37 7a27 	vadd.f32	s14, s14, s15

    *p3++ = m0 + m1;
    *p3++ = m2 - m3;
    // COL 4
    twR = tw4[0];
    twI = tw4[1];
 8027032:	9e05      	ldr	r6, [sp, #20]
    // col 3
    t3[0] = p1ap3_0 - p2[0] - p4[0];
    t3[1] = p1ap3_1 - p2[1] - p4[1];
    // col 4
    t4[0] = p1sp3_0 - p2[1] + p4[1];
    t4[1] = p1sp3_1 + p2[0] - p4[0];
 8027034:	ee77 7a44 	vsub.f32	s15, s14, s8
    t2[1] = p1sp3_1 - p2[0] + p4[0];
    // col 3
    t3[0] = p1ap3_0 - p2[0] - p4[0];
    t3[1] = p1ap3_1 - p2[1] - p4[1];
    // col 4
    t4[0] = p1sp3_0 - p2[1] + p4[1];
 8027038:	ee74 6aa6 	vadd.f32	s13, s9, s13

    *p3++ = m0 + m1;
    *p3++ = m2 - m3;
    // COL 4
    twR = tw4[0];
    twI = tw4[1];
 802703c:	ed96 7a01 	vldr	s14, [r6, #4]
    m3 = t3[0] * twI;

    *p3++ = m0 + m1;
    *p3++ = m2 - m3;
    // COL 4
    twR = tw4[0];
 8027040:	edd6 5a00 	vldr	s11, [r6]
    twI = tw4[1];

    m0 = t4[0] * twR;
    m1 = t4[1] * twI;
 8027044:	ee27 6a87 	vmul.f32	s12, s15, s14
 8027048:	ee27 7a66 	vnmul.f32	s14, s14, s13
    m2 = t4[1] * twR;
    m3 = t4[0] * twI;

    *p4++ = m0 + m1;
 802704c:	eea6 6aa5 	vfma.f32	s12, s13, s11
    *p4++ = m2 - m3;
 8027050:	eea7 7aa5 	vfma.f32	s14, s15, s11
    m0 = t4[0] * twR;
    m1 = t4[1] * twI;
    m2 = t4[1] * twR;
    m3 = t4[0] * twI;

    *p4++ = m0 + m1;
 8027054:	ed8c 6a00 	vstr	s12, [ip]
    *p4++ = m2 - m3;
 8027058:	ed8c 7a01 	vstr	s14, [ip, #4]

    // first col
    arm_radix8_butterfly_f32( pCol1, L, (float32_t *) S->pTwiddle, 4u);
 802705c:	f000 f892 	bl	8027184 <arm_radix8_butterfly_f32>
    // second col
    arm_radix8_butterfly_f32( pCol2, L, (float32_t *) S->pTwiddle, 4u);
 8027060:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 8027062:	9808      	ldr	r0, [sp, #32]
 8027064:	686a      	ldr	r2, [r5, #4]
 8027066:	4621      	mov	r1, r4
 8027068:	2304      	movs	r3, #4
 802706a:	f000 f88b 	bl	8027184 <arm_radix8_butterfly_f32>
    // third col
    arm_radix8_butterfly_f32( pCol3, L, (float32_t *) S->pTwiddle, 4u);
 802706e:	9809      	ldr	r0, [sp, #36]	; 0x24
 8027070:	686a      	ldr	r2, [r5, #4]
 8027072:	4621      	mov	r1, r4
 8027074:	2304      	movs	r3, #4
 8027076:	f000 f885 	bl	8027184 <arm_radix8_butterfly_f32>
    // fourth col
    arm_radix8_butterfly_f32( pCol4, L, (float32_t *) S->pTwiddle, 4u);
 802707a:	9800      	ldr	r0, [sp, #0]
 802707c:	686a      	ldr	r2, [r5, #4]
 802707e:	4621      	mov	r1, r4
 8027080:	2304      	movs	r3, #4
}
 8027082:	b00f      	add	sp, #60	; 0x3c
 8027084:	ecbd 8b0a 	vpop	{d8-d12}
 8027088:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    // second col
    arm_radix8_butterfly_f32( pCol2, L, (float32_t *) S->pTwiddle, 4u);
    // third col
    arm_radix8_butterfly_f32( pCol3, L, (float32_t *) S->pTwiddle, 4u);
    // fourth col
    arm_radix8_butterfly_f32( pCol4, L, (float32_t *) S->pTwiddle, 4u);
 802708c:	f000 b87a 	b.w	8027184 <arm_radix8_butterfly_f32>

08027090 <arm_cfft_f32>:
    uint8_t bitReverseFlag)
{
    uint32_t  L = S->fftLen, l;
    float32_t invL, * pSrc;

    if (ifftFlag == 1u)
 8027090:	2a01      	cmp	r2, #1
void arm_cfft_f32(
    const arm_cfft_instance_f32 * S,
    float32_t * p1,
    uint8_t ifftFlag,
    uint8_t bitReverseFlag)
{
 8027092:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8027096:	4606      	mov	r6, r0
 8027098:	4617      	mov	r7, r2
 802709a:	460c      	mov	r4, r1
 802709c:	4698      	mov	r8, r3
    uint32_t  L = S->fftLen, l;
 802709e:	8805      	ldrh	r5, [r0, #0]
    float32_t invL, * pSrc;

    if (ifftFlag == 1u)
 80270a0:	d054      	beq.n	802714c <arm_cfft_f32+0xbc>
            *pSrc = -*pSrc;
            pSrc += 2;
        }
    }

    switch (L)
 80270a2:	f5b5 7f80 	cmp.w	r5, #256	; 0x100
 80270a6:	d04c      	beq.n	8027142 <arm_cfft_f32+0xb2>
 80270a8:	d916      	bls.n	80270d8 <arm_cfft_f32+0x48>
 80270aa:	f5b5 6f80 	cmp.w	r5, #1024	; 0x400
 80270ae:	d01a      	beq.n	80270e6 <arm_cfft_f32+0x56>
 80270b0:	d95c      	bls.n	802716c <arm_cfft_f32+0xdc>
 80270b2:	f5b5 6f00 	cmp.w	r5, #2048	; 0x800
 80270b6:	d044      	beq.n	8027142 <arm_cfft_f32+0xb2>
 80270b8:	f5b5 5f80 	cmp.w	r5, #4096	; 0x1000
 80270bc:	d105      	bne.n	80270ca <arm_cfft_f32+0x3a>
        arm_cfft_radix8by4_f32  ( (arm_cfft_instance_f32 *) S, p1);
        break;
    case 64:
    case 512:
    case 4096:
        arm_radix8_butterfly_f32( p1, L, (float32_t *) S->pTwiddle, 1);
 80270be:	4620      	mov	r0, r4
 80270c0:	4629      	mov	r1, r5
 80270c2:	6872      	ldr	r2, [r6, #4]
 80270c4:	2301      	movs	r3, #1
 80270c6:	f000 f85d 	bl	8027184 <arm_radix8_butterfly_f32>
        break;
    }

    if ( bitReverseFlag )
 80270ca:	f1b8 0f00 	cmp.w	r8, #0
 80270ce:	d111      	bne.n	80270f4 <arm_cfft_f32+0x64>
        arm_bitreversal_32((uint32_t*)p1,S->bitRevLength,S->pBitRevTable);

    if (ifftFlag == 1u)
 80270d0:	2f01      	cmp	r7, #1
 80270d2:	d016      	beq.n	8027102 <arm_cfft_f32+0x72>
 80270d4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            *pSrc = -*pSrc;
            pSrc += 2;
        }
    }

    switch (L)
 80270d8:	2d20      	cmp	r5, #32
 80270da:	d032      	beq.n	8027142 <arm_cfft_f32+0xb2>
 80270dc:	d94a      	bls.n	8027174 <arm_cfft_f32+0xe4>
 80270de:	2d40      	cmp	r5, #64	; 0x40
 80270e0:	d0ed      	beq.n	80270be <arm_cfft_f32+0x2e>
 80270e2:	2d80      	cmp	r5, #128	; 0x80
 80270e4:	d1f1      	bne.n	80270ca <arm_cfft_f32+0x3a>
    {
    case 16:
    case 128:
    case 1024:
        arm_cfft_radix8by2_f32  ( (arm_cfft_instance_f32 *) S, p1);
 80270e6:	4630      	mov	r0, r6
 80270e8:	4621      	mov	r1, r4
 80270ea:	f7ff fccf 	bl	8026a8c <arm_cfft_radix8by2_f32>
    case 4096:
        arm_radix8_butterfly_f32( p1, L, (float32_t *) S->pTwiddle, 1);
        break;
    }

    if ( bitReverseFlag )
 80270ee:	f1b8 0f00 	cmp.w	r8, #0
 80270f2:	d0ed      	beq.n	80270d0 <arm_cfft_f32+0x40>
        arm_bitreversal_32((uint32_t*)p1,S->bitRevLength,S->pBitRevTable);
 80270f4:	4620      	mov	r0, r4
 80270f6:	89b1      	ldrh	r1, [r6, #12]
 80270f8:	68b2      	ldr	r2, [r6, #8]
 80270fa:	f7ff fc67 	bl	80269cc <arm_bitreversal_32>

    if (ifftFlag == 1u)
 80270fe:	2f01      	cmp	r7, #1
 8027100:	d1e8      	bne.n	80270d4 <arm_cfft_f32+0x44>
    {
        invL = 1.0f/(float32_t)L;
 8027102:	ee07 5a90 	vmov	s15, r5
 8027106:	eef8 6a67 	vcvt.f32.u32	s13, s15
 802710a:	eef7 7a00 	vmov.f32	s15, #112	; 0x70
 802710e:	eec7 6aa6 	vdiv.f32	s13, s15, s13
        /*  Conjugate and scale output data */
        pSrc = p1;
        for(l=0; l<L; l++)
 8027112:	2d00      	cmp	r5, #0
 8027114:	d0de      	beq.n	80270d4 <arm_cfft_f32+0x44>
 8027116:	f104 0108 	add.w	r1, r4, #8
 802711a:	2300      	movs	r3, #0
 802711c:	3301      	adds	r3, #1
 802711e:	429d      	cmp	r5, r3
 8027120:	f101 0108 	add.w	r1, r1, #8
        {
            *pSrc++ *=   invL ;
 8027124:	ed11 7a04 	vldr	s14, [r1, #-16]
            *pSrc  = -(*pSrc) * invL;
 8027128:	ed51 7a03 	vldr	s15, [r1, #-12]
        invL = 1.0f/(float32_t)L;
        /*  Conjugate and scale output data */
        pSrc = p1;
        for(l=0; l<L; l++)
        {
            *pSrc++ *=   invL ;
 802712c:	ee27 7a26 	vmul.f32	s14, s14, s13
            *pSrc  = -(*pSrc) * invL;
 8027130:	ee67 7ae6 	vnmul.f32	s15, s15, s13
        invL = 1.0f/(float32_t)L;
        /*  Conjugate and scale output data */
        pSrc = p1;
        for(l=0; l<L; l++)
        {
            *pSrc++ *=   invL ;
 8027134:	ed01 7a04 	vstr	s14, [r1, #-16]
            *pSrc  = -(*pSrc) * invL;
 8027138:	ed41 7a03 	vstr	s15, [r1, #-12]
    if (ifftFlag == 1u)
    {
        invL = 1.0f/(float32_t)L;
        /*  Conjugate and scale output data */
        pSrc = p1;
        for(l=0; l<L; l++)
 802713c:	d1ee      	bne.n	802711c <arm_cfft_f32+0x8c>
 802713e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        arm_cfft_radix8by2_f32  ( (arm_cfft_instance_f32 *) S, p1);
        break;
    case 32:
    case 256:
    case 2048:
        arm_cfft_radix8by4_f32  ( (arm_cfft_instance_f32 *) S, p1);
 8027142:	4630      	mov	r0, r6
 8027144:	4621      	mov	r1, r4
 8027146:	f7ff fd63 	bl	8026c10 <arm_cfft_radix8by4_f32>
        break;
 802714a:	e7be      	b.n	80270ca <arm_cfft_f32+0x3a>

    if (ifftFlag == 1u)
    {
        /*  Conjugate input data  */
        pSrc = p1 + 1;
        for(l=0; l<L; l++)
 802714c:	b1ad      	cbz	r5, 802717a <arm_cfft_f32+0xea>
 802714e:	f101 030c 	add.w	r3, r1, #12
 8027152:	2200      	movs	r2, #0
        {
            *pSrc = -*pSrc;
 8027154:	ed53 7a02 	vldr	s15, [r3, #-8]

    if (ifftFlag == 1u)
    {
        /*  Conjugate input data  */
        pSrc = p1 + 1;
        for(l=0; l<L; l++)
 8027158:	3201      	adds	r2, #1
        {
            *pSrc = -*pSrc;
 802715a:	eef1 7a67 	vneg.f32	s15, s15

    if (ifftFlag == 1u)
    {
        /*  Conjugate input data  */
        pSrc = p1 + 1;
        for(l=0; l<L; l++)
 802715e:	4295      	cmp	r5, r2
        {
            *pSrc = -*pSrc;
 8027160:	ed43 7a02 	vstr	s15, [r3, #-8]
 8027164:	f103 0308 	add.w	r3, r3, #8

    if (ifftFlag == 1u)
    {
        /*  Conjugate input data  */
        pSrc = p1 + 1;
        for(l=0; l<L; l++)
 8027168:	d1f4      	bne.n	8027154 <arm_cfft_f32+0xc4>
 802716a:	e79a      	b.n	80270a2 <arm_cfft_f32+0x12>
            *pSrc = -*pSrc;
            pSrc += 2;
        }
    }

    switch (L)
 802716c:	f5b5 7f00 	cmp.w	r5, #512	; 0x200
 8027170:	d0a5      	beq.n	80270be <arm_cfft_f32+0x2e>
 8027172:	e7aa      	b.n	80270ca <arm_cfft_f32+0x3a>
 8027174:	2d10      	cmp	r5, #16
 8027176:	d0b6      	beq.n	80270e6 <arm_cfft_f32+0x56>
 8027178:	e7a7      	b.n	80270ca <arm_cfft_f32+0x3a>
 802717a:	f5b5 7f80 	cmp.w	r5, #256	; 0x100
 802717e:	d894      	bhi.n	80270aa <arm_cfft_f32+0x1a>
 8027180:	e7aa      	b.n	80270d8 <arm_cfft_f32+0x48>
 8027182:	bf00      	nop

08027184 <arm_radix8_butterfly_f32>:
void arm_radix8_butterfly_f32(
float32_t * pSrc,
uint16_t fftLen,
const float32_t * pCoef,
uint16_t twidCoefModifier)
{
 8027184:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8027188:	ed2d 8b10 	vpush	{d8-d15}
 802718c:	b09d      	sub	sp, #116	; 0x74
 802718e:	461c      	mov	r4, r3
         pSrc[2 * i7 + 1] = t2 + r3;
         r1 = (r6 - r8) * C81;
         r6 = (r6 + r8) * C81;
         r2 = (s6 - s8) * C81;
         s6 = (s6 + s8) * C81;
         t1 = r5 - r1;
 8027190:	eddf aac9 	vldr	s21, [pc, #804]	; 80274b8 <arm_radix8_butterfly_f32+0x334>
void arm_radix8_butterfly_f32(
float32_t * pSrc,
uint16_t fftLen,
const float32_t * pCoef,
uint16_t twidCoefModifier)
{
 8027194:	921a      	str	r2, [sp, #104]	; 0x68
 8027196:	1d03      	adds	r3, r0, #4
 8027198:	4682      	mov	sl, r0
 802719a:	4689      	mov	r9, r1
   float32_t p1, p2, p3, p4;
   float32_t co2, co3, co4, co5, co6, co7, co8;
   float32_t si2, si3, si4, si5, si6, si7, si8;
   const float32_t C81 = 0.70710678118f;

   n2 = fftLen;
 802719c:	468b      	mov	fp, r1
 802719e:	931b      	str	r3, [sp, #108]	; 0x6c
 80271a0:	9400      	str	r4, [sp, #0]
 80271a2:	469e      	mov	lr, r3

   do
   {
      n1 = n2;
      n2 = n2 >> 3;
 80271a4:	ea4f 03db 	mov.w	r3, fp, lsr #3
 80271a8:	005a      	lsls	r2, r3, #1
 80271aa:	18d6      	adds	r6, r2, r3
 80271ac:	18f5      	adds	r5, r6, r3
 80271ae:	9204      	str	r2, [sp, #16]
 80271b0:	195a      	adds	r2, r3, r5
 80271b2:	18d0      	adds	r0, r2, r3
 80271b4:	00df      	lsls	r7, r3, #3
 80271b6:	1819      	adds	r1, r3, r0
 80271b8:	463c      	mov	r4, r7
 80271ba:	9702      	str	r7, [sp, #8]
 80271bc:	4457      	add	r7, sl
 80271be:	930c      	str	r3, [sp, #48]	; 0x30
 80271c0:	eb0a 02c2 	add.w	r2, sl, r2, lsl #3
 80271c4:	011b      	lsls	r3, r3, #4
 80271c6:	eb0a 01c1 	add.w	r1, sl, r1, lsl #3
 80271ca:	eb07 0c04 	add.w	ip, r7, r4
      i1 = 0;
 80271ce:	9c00      	ldr	r4, [sp, #0]
 80271d0:	9303      	str	r3, [sp, #12]
 80271d2:	eb0a 06c6 	add.w	r6, sl, r6, lsl #3
 80271d6:	eb0a 05c5 	add.w	r5, sl, r5, lsl #3
 80271da:	3204      	adds	r2, #4
 80271dc:	3104      	adds	r1, #4
 80271de:	eb0a 00c0 	add.w	r0, sl, r0, lsl #3
 80271e2:	ea4f 03cb 	mov.w	r3, fp, lsl #3
 80271e6:	f04f 0800 	mov.w	r8, #0
         i4 = i3 + n2;
         i5 = i4 + n2;
         i6 = i5 + n2;
         i7 = i6 + n2;
         i8 = i7 + n2;
         r1 = pSrc[2 * i1] + pSrc[2 * i5];
 80271ea:	ed5e 1a01 	vldr	s3, [lr, #-4]
         r5 = pSrc[2 * i1] - pSrc[2 * i5];
         r2 = pSrc[2 * i2] + pSrc[2 * i6];
         r6 = pSrc[2 * i2] - pSrc[2 * i6];
         r3 = pSrc[2 * i3] + pSrc[2 * i7];
 80271ee:	ed90 2a00 	vldr	s4, [r0]
         i6 = i5 + n2;
         i7 = i6 + n2;
         i8 = i7 + n2;
         r1 = pSrc[2 * i1] + pSrc[2 * i5];
         r5 = pSrc[2 * i1] - pSrc[2 * i5];
         r2 = pSrc[2 * i2] + pSrc[2 * i6];
 80271f2:	ed97 4a00 	vldr	s8, [r7]
 80271f6:	ed52 6a01 	vldr	s13, [r2, #-4]
         r6 = pSrc[2 * i2] - pSrc[2 * i6];
         r3 = pSrc[2 * i3] + pSrc[2 * i7];
         r7 = pSrc[2 * i3] - pSrc[2 * i7];
         r4 = pSrc[2 * i4] + pSrc[2 * i8];
 80271fa:	ed96 3a00 	vldr	s6, [r6]
 80271fe:	ed51 0a01 	vldr	s1, [r1, #-4]
         i4 = i3 + n2;
         i5 = i4 + n2;
         i6 = i5 + n2;
         i7 = i6 + n2;
         i8 = i7 + n2;
         r1 = pSrc[2 * i1] + pSrc[2 * i5];
 8027202:	edd5 2a00 	vldr	s5, [r5]
         r5 = pSrc[2 * i1] - pSrc[2 * i5];
         r2 = pSrc[2 * i2] + pSrc[2 * i6];
         r6 = pSrc[2 * i2] - pSrc[2 * i6];
         r3 = pSrc[2 * i3] + pSrc[2 * i7];
 8027206:	ed9c 1a00 	vldr	s2, [ip]
         i4 = i3 + n2;
         i5 = i4 + n2;
         i6 = i5 + n2;
         i7 = i6 + n2;
         i8 = i7 + n2;
         r1 = pSrc[2 * i1] + pSrc[2 * i5];
 802720a:	ee31 0aa2 	vadd.f32	s0, s3, s5
         r5 = pSrc[2 * i1] - pSrc[2 * i5];
         r2 = pSrc[2 * i2] + pSrc[2 * i6];
         r6 = pSrc[2 * i2] - pSrc[2 * i6];
         r3 = pSrc[2 * i3] + pSrc[2 * i7];
 802720e:	ee71 9a02 	vadd.f32	s19, s2, s4
         i6 = i5 + n2;
         i7 = i6 + n2;
         i8 = i7 + n2;
         r1 = pSrc[2 * i1] + pSrc[2 * i5];
         r5 = pSrc[2 * i1] - pSrc[2 * i5];
         r2 = pSrc[2 * i2] + pSrc[2 * i6];
 8027212:	ee34 6a26 	vadd.f32	s12, s8, s13
         r6 = pSrc[2 * i2] - pSrc[2 * i6];
         r3 = pSrc[2 * i3] + pSrc[2 * i7];
         r7 = pSrc[2 * i3] - pSrc[2 * i7];
         r4 = pSrc[2 * i4] + pSrc[2 * i8];
 8027216:	ee33 9a20 	vadd.f32	s18, s6, s1
         r8 = pSrc[2 * i4] - pSrc[2 * i8];
         t1 = r1 - r3;
         r1 = r1 + r3;
 802721a:	ee30 7a29 	vadd.f32	s14, s0, s19
         r3 = r2 - r4;
         r2 = r2 + r4;
 802721e:	ee76 7a09 	vadd.f32	s15, s12, s18
         i7 = i6 + n2;
         i8 = i7 + n2;
         r1 = pSrc[2 * i1] + pSrc[2 * i5];
         r5 = pSrc[2 * i1] - pSrc[2 * i5];
         r2 = pSrc[2 * i2] + pSrc[2 * i6];
         r6 = pSrc[2 * i2] - pSrc[2 * i6];
 8027222:	ee74 3a66 	vsub.f32	s7, s8, s13
         r8 = pSrc[2 * i4] - pSrc[2 * i8];
         t1 = r1 - r3;
         r1 = r1 + r3;
         r3 = r2 - r4;
         r2 = r2 + r4;
         pSrc[2 * i1] = r1 + r2;
 8027226:	ee77 6a27 	vadd.f32	s13, s14, s15
         pSrc[2 * i5] = r1 - r2;
 802722a:	ee37 7a67 	vsub.f32	s14, s14, s15
         r8 = pSrc[2 * i4] - pSrc[2 * i8];
         t1 = r1 - r3;
         r1 = r1 + r3;
         r3 = r2 - r4;
         r2 = r2 + r4;
         pSrc[2 * i1] = r1 + r2;
 802722e:	ed4e 6a01 	vstr	s13, [lr, #-4]
         pSrc[2 * i5] = r1 - r2;
 8027232:	ed85 7a00 	vstr	s14, [r5]
         r1 = pSrc[2 * i1 + 1] + pSrc[2 * i5 + 1];
         s5 = pSrc[2 * i1 + 1] - pSrc[2 * i5 + 1];
         r2 = pSrc[2 * i2 + 1] + pSrc[2 * i6 + 1];
 8027236:	edd7 5a01 	vldr	s11, [r7, #4]
 802723a:	edd2 6a00 	vldr	s13, [r2]
         s6 = pSrc[2 * i2 + 1] - pSrc[2 * i6 + 1];
         s3 = pSrc[2 * i3 + 1] + pSrc[2 * i7 + 1];
         s7 = pSrc[2 * i3 + 1] - pSrc[2 * i7 + 1];
         r4 = pSrc[2 * i4 + 1] + pSrc[2 * i8 + 1];
 802723e:	edd6 4a01 	vldr	s9, [r6, #4]
 8027242:	ed91 ba00 	vldr	s22, [r1]
         r1 = r1 + r3;
         r3 = r2 - r4;
         r2 = r2 + r4;
         pSrc[2 * i1] = r1 + r2;
         pSrc[2 * i5] = r1 - r2;
         r1 = pSrc[2 * i1 + 1] + pSrc[2 * i5 + 1];
 8027246:	edd5 8a01 	vldr	s17, [r5, #4]
 802724a:	ed9e 7a00 	vldr	s14, [lr]
         s5 = pSrc[2 * i1 + 1] - pSrc[2 * i5 + 1];
         r2 = pSrc[2 * i2 + 1] + pSrc[2 * i6 + 1];
         s6 = pSrc[2 * i2 + 1] - pSrc[2 * i6 + 1];
         s3 = pSrc[2 * i3 + 1] + pSrc[2 * i7 + 1];
 802724e:	edd0 7a01 	vldr	s15, [r0, #4]
 8027252:	ed9c 5a01 	vldr	s10, [ip, #4]
         r2 = pSrc[2 * i2] + pSrc[2 * i6];
         r6 = pSrc[2 * i2] - pSrc[2 * i6];
         r3 = pSrc[2 * i3] + pSrc[2 * i7];
         r7 = pSrc[2 * i3] - pSrc[2 * i7];
         r4 = pSrc[2 * i4] + pSrc[2 * i8];
         r8 = pSrc[2 * i4] - pSrc[2 * i8];
 8027256:	ee33 4a60 	vsub.f32	s8, s6, s1
         pSrc[2 * i1] = r1 + r2;
         pSrc[2 * i5] = r1 - r2;
         r1 = pSrc[2 * i1 + 1] + pSrc[2 * i5 + 1];
         s5 = pSrc[2 * i1 + 1] - pSrc[2 * i5 + 1];
         r2 = pSrc[2 * i2 + 1] + pSrc[2 * i6 + 1];
         s6 = pSrc[2 * i2 + 1] - pSrc[2 * i6 + 1];
 802725a:	ee35 3ae6 	vsub.f32	s6, s11, s13
         s3 = pSrc[2 * i3 + 1] + pSrc[2 * i7 + 1];
         s7 = pSrc[2 * i3 + 1] - pSrc[2 * i7 + 1];
         r4 = pSrc[2 * i4 + 1] + pSrc[2 * i8 + 1];
         s8 = pSrc[2 * i4 + 1] - pSrc[2 * i8 + 1];
 802725e:	ee74 0acb 	vsub.f32	s1, s9, s22
         r1 = pSrc[2 * i1] + pSrc[2 * i5];
         r5 = pSrc[2 * i1] - pSrc[2 * i5];
         r2 = pSrc[2 * i2] + pSrc[2 * i6];
         r6 = pSrc[2 * i2] - pSrc[2 * i6];
         r3 = pSrc[2 * i3] + pSrc[2 * i7];
         r7 = pSrc[2 * i3] - pSrc[2 * i7];
 8027262:	ee31 1a42 	vsub.f32	s2, s2, s4
         r1 = pSrc[2 * i1 + 1] + pSrc[2 * i5 + 1];
         s5 = pSrc[2 * i1 + 1] - pSrc[2 * i5 + 1];
         r2 = pSrc[2 * i2 + 1] + pSrc[2 * i6 + 1];
         s6 = pSrc[2 * i2 + 1] - pSrc[2 * i6 + 1];
         s3 = pSrc[2 * i3 + 1] + pSrc[2 * i7 + 1];
         s7 = pSrc[2 * i3 + 1] - pSrc[2 * i7 + 1];
 8027266:	ee35 8a67 	vsub.f32	s16, s10, s15
         r3 = r2 - r4;
         r2 = r2 + r4;
         pSrc[2 * i1] = r1 + r2;
         pSrc[2 * i5] = r1 - r2;
         r1 = pSrc[2 * i1 + 1] + pSrc[2 * i5 + 1];
         s5 = pSrc[2 * i1 + 1] - pSrc[2 * i5 + 1];
 802726a:	ee37 2a68 	vsub.f32	s4, s14, s17
         i5 = i4 + n2;
         i6 = i5 + n2;
         i7 = i6 + n2;
         i8 = i7 + n2;
         r1 = pSrc[2 * i1] + pSrc[2 * i5];
         r5 = pSrc[2 * i1] - pSrc[2 * i5];
 802726e:	ee71 2ae2 	vsub.f32	s5, s3, s5
         pSrc[2 * i3 + 1] = t2 - r3;
         pSrc[2 * i7 + 1] = t2 + r3;
         r1 = (r6 - r8) * C81;
         r6 = (r6 + r8) * C81;
         r2 = (s6 - s8) * C81;
         s6 = (s6 + s8) * C81;
 8027272:	ee73 1a20 	vadd.f32	s3, s6, s1
         pSrc[2 * i7]     = t1 - s3;
         pSrc[2 * i3 + 1] = t2 - r3;
         pSrc[2 * i7 + 1] = t2 + r3;
         r1 = (r6 - r8) * C81;
         r6 = (r6 + r8) * C81;
         r2 = (s6 - s8) * C81;
 8027276:	ee33 3a60 	vsub.f32	s6, s6, s1
         pSrc[2 * i5 + 1] = r1 - r2;
         pSrc[2 * i3]     = t1 + s3;
         pSrc[2 * i7]     = t1 - s3;
         pSrc[2 * i3 + 1] = t2 - r3;
         pSrc[2 * i7 + 1] = t2 + r3;
         r1 = (r6 - r8) * C81;
 802727a:	ee33 aac4 	vsub.f32	s20, s7, s8
         r2 = r2 + r4;
         pSrc[2 * i1] = r1 + r2;
         pSrc[2 * i5] = r1 - r2;
         r1 = pSrc[2 * i1 + 1] + pSrc[2 * i5 + 1];
         s5 = pSrc[2 * i1 + 1] - pSrc[2 * i5 + 1];
         r2 = pSrc[2 * i2 + 1] + pSrc[2 * i6 + 1];
 802727e:	ee75 0aa6 	vadd.f32	s1, s11, s13
         pSrc[2 * i3]     = t1 + s3;
         pSrc[2 * i7]     = t1 - s3;
         pSrc[2 * i3 + 1] = t2 - r3;
         pSrc[2 * i7 + 1] = t2 + r3;
         r1 = (r6 - r8) * C81;
         r6 = (r6 + r8) * C81;
 8027282:	ee33 4a84 	vadd.f32	s8, s7, s8
         r1 = r1 + r3;
         r3 = r2 - r4;
         r2 = r2 + r4;
         pSrc[2 * i1] = r1 + r2;
         pSrc[2 * i5] = r1 - r2;
         r1 = pSrc[2 * i1 + 1] + pSrc[2 * i5 + 1];
 8027286:	ee37 7a28 	vadd.f32	s14, s14, s17
         s5 = pSrc[2 * i1 + 1] - pSrc[2 * i5 + 1];
         r2 = pSrc[2 * i2 + 1] + pSrc[2 * i6 + 1];
         s6 = pSrc[2 * i2 + 1] - pSrc[2 * i6 + 1];
         s3 = pSrc[2 * i3 + 1] + pSrc[2 * i7 + 1];
         s7 = pSrc[2 * i3 + 1] - pSrc[2 * i7 + 1];
         r4 = pSrc[2 * i4 + 1] + pSrc[2 * i8 + 1];
 802728a:	ee74 5a8b 	vadd.f32	s11, s9, s22
         r8 = r7 - r6;
         r7 = r7 + r6;
         t2 = s5 - r2;
         s5 = s5 + r2;
         s8 = s7 - s6;
         s7 = s7 + s6;
 802728e:	eef0 8a48 	vmov.f32	s17, s16
         t1 = r5 - r1;
         r5 = r5 + r1;
         r8 = r7 - r6;
         r7 = r7 + r6;
         t2 = s5 - r2;
         s5 = s5 + r2;
 8027292:	eef0 3a42 	vmov.f32	s7, s4
         s6 = (s6 + s8) * C81;
         t1 = r5 - r1;
         r5 = r5 + r1;
         r8 = r7 - r6;
         r7 = r7 + r6;
         t2 = s5 - r2;
 8027296:	eef0 4a42 	vmov.f32	s9, s4
         s5 = s5 + r2;
         s8 = s7 - s6;
         s7 = s7 + s6;
 802729a:	eee1 8aaa 	vfma.f32	s17, s3, s21
         pSrc[2 * i2 + 1] = s5 - r7;
         pSrc[2 * i8 + 1] = s5 + r7;
         pSrc[2 * i6 + 1] = t2 - r8;
         pSrc[2 * i4 + 1] = t2 + r8;

         i1 += n1;
 802729e:	44d8      	add	r8, fp
      } while (i1 < fftLen);
 80272a0:	45c1      	cmp	r9, r8
         r5 = r5 + r1;
         r8 = r7 - r6;
         r7 = r7 + r6;
         t2 = s5 - r2;
         s5 = s5 + r2;
         s8 = s7 - s6;
 80272a2:	eea1 8aea 	vfms.f32	s16, s3, s21
         t1 = r5 - r1;
         r5 = r5 + r1;
         r8 = r7 - r6;
         r7 = r7 + r6;
         t2 = s5 - r2;
         s5 = s5 + r2;
 80272a6:	eee3 3a2a 	vfma.f32	s7, s6, s21
         s6 = (s6 + s8) * C81;
         t1 = r5 - r1;
         r5 = r5 + r1;
         r8 = r7 - r6;
         r7 = r7 + r6;
         t2 = s5 - r2;
 80272aa:	eee3 4a6a 	vfms.f32	s9, s6, s21
         r1 = (r6 - r8) * C81;
         r6 = (r6 + r8) * C81;
         r2 = (s6 - s8) * C81;
         s6 = (s6 + s8) * C81;
         t1 = r5 - r1;
         r5 = r5 + r1;
 80272ae:	eef0 1a62 	vmov.f32	s3, s5
         r8 = r7 - r6;
         r7 = r7 + r6;
 80272b2:	eeb0 2a41 	vmov.f32	s4, s2
         r6 = (r6 + r8) * C81;
         r2 = (s6 - s8) * C81;
         s6 = (s6 + s8) * C81;
         t1 = r5 - r1;
         r5 = r5 + r1;
         r8 = r7 - r6;
 80272b6:	eeb0 3a41 	vmov.f32	s6, s2
         pSrc[2 * i5] = r1 - r2;
         r1 = pSrc[2 * i1 + 1] + pSrc[2 * i5 + 1];
         s5 = pSrc[2 * i1 + 1] - pSrc[2 * i5 + 1];
         r2 = pSrc[2 * i2 + 1] + pSrc[2 * i6 + 1];
         s6 = pSrc[2 * i2 + 1] - pSrc[2 * i6 + 1];
         s3 = pSrc[2 * i3 + 1] + pSrc[2 * i7 + 1];
 80272ba:	ee35 5a27 	vadd.f32	s10, s10, s15
         r2 = (s6 - s8) * C81;
         s6 = (s6 + s8) * C81;
         t1 = r5 - r1;
         r5 = r5 + r1;
         r8 = r7 - r6;
         r7 = r7 + r6;
 80272be:	eea4 2a2a 	vfma.f32	s4, s8, s21
         r6 = (r6 + r8) * C81;
         r2 = (s6 - s8) * C81;
         s6 = (s6 + s8) * C81;
         t1 = r5 - r1;
         r5 = r5 + r1;
         r8 = r7 - r6;
 80272c2:	eea4 3a6a 	vfms.f32	s6, s8, s21
         r1 = (r6 - r8) * C81;
         r6 = (r6 + r8) * C81;
         r2 = (s6 - s8) * C81;
         s6 = (s6 + s8) * C81;
         t1 = r5 - r1;
         r5 = r5 + r1;
 80272c6:	eeea 1a2a 	vfma.f32	s3, s20, s21
         pSrc[2 * i7 + 1] = t2 + r3;
         r1 = (r6 - r8) * C81;
         r6 = (r6 + r8) * C81;
         r2 = (s6 - s8) * C81;
         s6 = (s6 + s8) * C81;
         t1 = r5 - r1;
 80272ca:	eeea 2a6a 	vfms.f32	s5, s20, s21
         r4 = pSrc[2 * i4 + 1] + pSrc[2 * i8 + 1];
         s8 = pSrc[2 * i4 + 1] - pSrc[2 * i8 + 1];
         t2 = r1 - s3;
         r1 = r1 + s3;
         s3 = r2 - r4;
         r2 = r2 + r4;
 80272ce:	ee30 1aa5 	vadd.f32	s2, s1, s11
         s3 = pSrc[2 * i3 + 1] + pSrc[2 * i7 + 1];
         s7 = pSrc[2 * i3 + 1] - pSrc[2 * i7 + 1];
         r4 = pSrc[2 * i4 + 1] + pSrc[2 * i8 + 1];
         s8 = pSrc[2 * i4 + 1] - pSrc[2 * i8 + 1];
         t2 = r1 - s3;
         r1 = r1 + s3;
 80272d2:	ee37 4a05 	vadd.f32	s8, s14, s10
         s6 = pSrc[2 * i2 + 1] - pSrc[2 * i6 + 1];
         s3 = pSrc[2 * i3 + 1] + pSrc[2 * i7 + 1];
         s7 = pSrc[2 * i3 + 1] - pSrc[2 * i7 + 1];
         r4 = pSrc[2 * i4 + 1] + pSrc[2 * i8 + 1];
         s8 = pSrc[2 * i4 + 1] - pSrc[2 * i8 + 1];
         t2 = r1 - s3;
 80272d6:	ee77 7a45 	vsub.f32	s15, s14, s10
         r6 = pSrc[2 * i2] - pSrc[2 * i6];
         r3 = pSrc[2 * i3] + pSrc[2 * i7];
         r7 = pSrc[2 * i3] - pSrc[2 * i7];
         r4 = pSrc[2 * i4] + pSrc[2 * i8];
         r8 = pSrc[2 * i4] - pSrc[2 * i8];
         t1 = r1 - r3;
 80272da:	ee70 6a69 	vsub.f32	s13, s0, s19
         r1 = r1 + r3;
         r3 = r2 - r4;
 80272de:	ee36 6a49 	vsub.f32	s12, s12, s18
         s7 = pSrc[2 * i3 + 1] - pSrc[2 * i7 + 1];
         r4 = pSrc[2 * i4 + 1] + pSrc[2 * i8 + 1];
         s8 = pSrc[2 * i4 + 1] - pSrc[2 * i8 + 1];
         t2 = r1 - s3;
         r1 = r1 + s3;
         s3 = r2 - r4;
 80272e2:	ee70 5ae5 	vsub.f32	s11, s1, s11
         r2 = r2 + r4;
         pSrc[2 * i1 + 1] = r1 + r2;
 80272e6:	ee34 0a01 	vadd.f32	s0, s8, s2
         pSrc[2 * i5 + 1] = r1 - r2;
         pSrc[2 * i3]     = t1 + s3;
 80272ea:	ee76 0aa5 	vadd.f32	s1, s13, s11
         t2 = r1 - s3;
         r1 = r1 + s3;
         s3 = r2 - r4;
         r2 = r2 + r4;
         pSrc[2 * i1 + 1] = r1 + r2;
         pSrc[2 * i5 + 1] = r1 - r2;
 80272ee:	ee34 4a41 	vsub.f32	s8, s8, s2
         pSrc[2 * i3]     = t1 + s3;
         pSrc[2 * i7]     = t1 - s3;
 80272f2:	ee76 6ae5 	vsub.f32	s13, s13, s11
         pSrc[2 * i3 + 1] = t2 - r3;
 80272f6:	ee37 1ac6 	vsub.f32	s2, s15, s12
         r7 = r7 + r6;
         t2 = s5 - r2;
         s5 = s5 + r2;
         s8 = s7 - s6;
         s7 = s7 + s6;
         pSrc[2 * i2]     = r5 + s7;
 80272fa:	ee31 5aa8 	vadd.f32	s10, s3, s17
         pSrc[2 * i1 + 1] = r1 + r2;
         pSrc[2 * i5 + 1] = r1 - r2;
         pSrc[2 * i3]     = t1 + s3;
         pSrc[2 * i7]     = t1 - s3;
         pSrc[2 * i3 + 1] = t2 - r3;
         pSrc[2 * i7 + 1] = t2 + r3;
 80272fe:	ee77 7a86 	vadd.f32	s15, s15, s12
         s5 = s5 + r2;
         s8 = s7 - s6;
         s7 = s7 + s6;
         pSrc[2 * i2]     = r5 + s7;
         pSrc[2 * i8]     = r5 - s7;
         pSrc[2 * i6]     = t1 + s8;
 8027302:	ee72 5a88 	vadd.f32	s11, s5, s16
         pSrc[2 * i4]     = t1 - s8;
         pSrc[2 * i2 + 1] = s5 - r7;
 8027306:	ee33 6ac2 	vsub.f32	s12, s7, s4
         pSrc[2 * i8 + 1] = s5 + r7;
         pSrc[2 * i6 + 1] = t2 - r8;
 802730a:	ee34 7ac3 	vsub.f32	s14, s9, s6
         t2 = s5 - r2;
         s5 = s5 + r2;
         s8 = s7 - s6;
         s7 = s7 + s6;
         pSrc[2 * i2]     = r5 + s7;
         pSrc[2 * i8]     = r5 - s7;
 802730e:	ee71 1ae8 	vsub.f32	s3, s3, s17
         pSrc[2 * i6]     = t1 + s8;
         pSrc[2 * i4]     = t1 - s8;
 8027312:	ee72 2ac8 	vsub.f32	s5, s5, s16
         pSrc[2 * i2 + 1] = s5 - r7;
         pSrc[2 * i8 + 1] = s5 + r7;
 8027316:	ee73 3a82 	vadd.f32	s7, s7, s4
         pSrc[2 * i6 + 1] = t2 - r8;
         pSrc[2 * i4 + 1] = t2 + r8;
 802731a:	ee74 4a83 	vadd.f32	s9, s9, s6
         s8 = pSrc[2 * i4 + 1] - pSrc[2 * i8 + 1];
         t2 = r1 - s3;
         r1 = r1 + s3;
         s3 = r2 - r4;
         r2 = r2 + r4;
         pSrc[2 * i1 + 1] = r1 + r2;
 802731e:	ed8e 0a00 	vstr	s0, [lr]
         pSrc[2 * i5 + 1] = r1 - r2;
 8027322:	ed85 4a01 	vstr	s8, [r5, #4]
 8027326:	449e      	add	lr, r3
         pSrc[2 * i3]     = t1 + s3;
 8027328:	edcc 0a00 	vstr	s1, [ip]
 802732c:	441d      	add	r5, r3
         pSrc[2 * i7]     = t1 - s3;
 802732e:	edc0 6a00 	vstr	s13, [r0]
         pSrc[2 * i3 + 1] = t2 - r3;
 8027332:	ed8c 1a01 	vstr	s2, [ip, #4]
         pSrc[2 * i7 + 1] = t2 + r3;
 8027336:	edc0 7a01 	vstr	s15, [r0, #4]
 802733a:	449c      	add	ip, r3
         r7 = r7 + r6;
         t2 = s5 - r2;
         s5 = s5 + r2;
         s8 = s7 - s6;
         s7 = s7 + s6;
         pSrc[2 * i2]     = r5 + s7;
 802733c:	ed87 5a00 	vstr	s10, [r7]
 8027340:	4418      	add	r0, r3
         pSrc[2 * i8]     = r5 - s7;
 8027342:	ed41 1a01 	vstr	s3, [r1, #-4]
         pSrc[2 * i6]     = t1 + s8;
 8027346:	ed42 5a01 	vstr	s11, [r2, #-4]
         pSrc[2 * i4]     = t1 - s8;
 802734a:	edc6 2a00 	vstr	s5, [r6]
         pSrc[2 * i2 + 1] = s5 - r7;
 802734e:	ed87 6a01 	vstr	s12, [r7, #4]
         pSrc[2 * i8 + 1] = s5 + r7;
 8027352:	edc1 3a00 	vstr	s7, [r1]
 8027356:	441f      	add	r7, r3
         pSrc[2 * i6 + 1] = t2 - r8;
 8027358:	ed82 7a00 	vstr	s14, [r2]
 802735c:	4419      	add	r1, r3
         pSrc[2 * i4 + 1] = t2 + r8;
 802735e:	edc6 4a01 	vstr	s9, [r6, #4]
 8027362:	441a      	add	r2, r3
 8027364:	441e      	add	r6, r3

         i1 += n1;
      } while (i1 < fftLen);
 8027366:	f63f af40 	bhi.w	80271ea <arm_radix8_butterfly_f32+0x66>

      if (n2 < 8)
 802736a:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 802736c:	9301      	str	r3, [sp, #4]
 802736e:	2a07      	cmp	r2, #7
 8027370:	4623      	mov	r3, r4
 8027372:	f240 81ca 	bls.w	802770a <arm_radix8_butterfly_f32+0x586>
 8027376:	eb04 0e44 	add.w	lr, r4, r4, lsl #1
 802737a:	eb0e 0703 	add.w	r7, lr, r3
 802737e:	18fd      	adds	r5, r7, r3
 8027380:	18e8      	adds	r0, r5, r3
 8027382:	9c04      	ldr	r4, [sp, #16]
 8027384:	9300      	str	r3, [sp, #0]
 8027386:	eb00 0c03 	add.w	ip, r0, r3
 802738a:	00c0      	lsls	r0, r0, #3
 802738c:	9010      	str	r0, [sp, #64]	; 0x40
 802738e:	9800      	ldr	r0, [sp, #0]
 8027390:	18a1      	adds	r1, r4, r2
 8027392:	1c66      	adds	r6, r4, #1
 8027394:	ea4f 04ce 	mov.w	r4, lr, lsl #3
 8027398:	940f      	str	r4, [sp, #60]	; 0x3c
 802739a:	00c4      	lsls	r4, r0, #3
 802739c:	940d      	str	r4, [sp, #52]	; 0x34
 802739e:	9c02      	ldr	r4, [sp, #8]
 80273a0:	3408      	adds	r4, #8
 80273a2:	9417      	str	r4, [sp, #92]	; 0x5c
 80273a4:	9c03      	ldr	r4, [sp, #12]
 80273a6:	3408      	adds	r4, #8
 80273a8:	00ed      	lsls	r5, r5, #3
 80273aa:	9416      	str	r4, [sp, #88]	; 0x58
 80273ac:	9c1a      	ldr	r4, [sp, #104]	; 0x68
 80273ae:	9513      	str	r5, [sp, #76]	; 0x4c
 80273b0:	462b      	mov	r3, r5
 80273b2:	ea4f 05cc 	mov.w	r5, ip, lsl #3
 80273b6:	9512      	str	r5, [sp, #72]	; 0x48
 80273b8:	1965      	adds	r5, r4, r5
 80273ba:	9507      	str	r5, [sp, #28]
 80273bc:	9d10      	ldr	r5, [sp, #64]	; 0x40
 80273be:	eb06 0682 	add.w	r6, r6, r2, lsl #2
 80273c2:	4416      	add	r6, r2
 80273c4:	1965      	adds	r5, r4, r5
 80273c6:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 80273ca:	0100      	lsls	r0, r0, #4
 80273cc:	00d2      	lsls	r2, r2, #3
 80273ce:	9508      	str	r5, [sp, #32]
 80273d0:	18e5      	adds	r5, r4, r3
 80273d2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80273d4:	900e      	str	r0, [sp, #56]	; 0x38
 80273d6:	320c      	adds	r2, #12
 80273d8:	eb0a 06c6 	add.w	r6, sl, r6, lsl #3
 80273dc:	980c      	ldr	r0, [sp, #48]	; 0x30
 80273de:	9214      	str	r2, [sp, #80]	; 0x50
 80273e0:	18e2      	adds	r2, r4, r3
 80273e2:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80273e4:	9509      	str	r5, [sp, #36]	; 0x24
 80273e6:	00ff      	lsls	r7, r7, #3
 80273e8:	1d35      	adds	r5, r6, #4
 80273ea:	9e0f      	ldr	r6, [sp, #60]	; 0x3c
 80273ec:	950a      	str	r5, [sp, #40]	; 0x28
 80273ee:	18e3      	adds	r3, r4, r3
 80273f0:	19e5      	adds	r5, r4, r7
 80273f2:	0140      	lsls	r0, r0, #5
 80273f4:	ea4f 0ec1 	mov.w	lr, r1, lsl #3
 80273f8:	9506      	str	r5, [sp, #24]
 80273fa:	0109      	lsls	r1, r1, #4
 80273fc:	19a5      	adds	r5, r4, r6
 80273fe:	9305      	str	r3, [sp, #20]
 8027400:	f100 0308 	add.w	r3, r0, #8
 8027404:	9504      	str	r5, [sp, #16]
 8027406:	310c      	adds	r1, #12
 8027408:	f10e 0508 	add.w	r5, lr, #8
 802740c:	9318      	str	r3, [sp, #96]	; 0x60
 802740e:	9b01      	ldr	r3, [sp, #4]
 8027410:	9203      	str	r2, [sp, #12]
 8027412:	9711      	str	r7, [sp, #68]	; 0x44
 8027414:	9519      	str	r5, [sp, #100]	; 0x64
 8027416:	9115      	str	r1, [sp, #84]	; 0x54
 8027418:	2200      	movs	r2, #0
 802741a:	f04f 0801 	mov.w	r8, #1
 802741e:	f102 0108 	add.w	r1, r2, #8
 8027422:	460f      	mov	r7, r1
 8027424:	910b      	str	r1, [sp, #44]	; 0x2c
 8027426:	9918      	ldr	r1, [sp, #96]	; 0x60
 8027428:	188e      	adds	r6, r1, r2
 802742a:	9917      	ldr	r1, [sp, #92]	; 0x5c
 802742c:	188d      	adds	r5, r1, r2
 802742e:	9916      	ldr	r1, [sp, #88]	; 0x58
 8027430:	188c      	adds	r4, r1, r2
 8027432:	9919      	ldr	r1, [sp, #100]	; 0x64
 8027434:	1888      	adds	r0, r1, r2
 8027436:	9914      	ldr	r1, [sp, #80]	; 0x50
 8027438:	eb01 0c02 	add.w	ip, r1, r2
 802743c:	9915      	ldr	r1, [sp, #84]	; 0x54
 802743e:	440a      	add	r2, r1
         ia4 = ia3 + id;
         ia5 = ia4 + id;
         ia6 = ia5 + id;
         ia7 = ia6 + id;

         co2 = pCoef[2 * ia1];
 8027440:	9903      	ldr	r1, [sp, #12]
 8027442:	ed91 fa00 	vldr	s30, [r1]
         co3 = pCoef[2 * ia2];
 8027446:	9905      	ldr	r1, [sp, #20]
 8027448:	edd1 ea00 	vldr	s29, [r1]
         co4 = pCoef[2 * ia3];
 802744c:	9904      	ldr	r1, [sp, #16]
 802744e:	ed91 ea00 	vldr	s28, [r1]
         co5 = pCoef[2 * ia4];
 8027452:	9906      	ldr	r1, [sp, #24]
 8027454:	edd1 da00 	vldr	s27, [r1]
         co6 = pCoef[2 * ia5];
 8027458:	9909      	ldr	r1, [sp, #36]	; 0x24
 802745a:	ed91 da00 	vldr	s26, [r1]
         co7 = pCoef[2 * ia6];
 802745e:	9908      	ldr	r1, [sp, #32]
 8027460:	edd1 ca00 	vldr	s25, [r1]
         co8 = pCoef[2 * ia7];
 8027464:	9907      	ldr	r1, [sp, #28]
 8027466:	ed91 ca00 	vldr	s24, [r1]
         si2 = pCoef[2 * ia1 + 1];
 802746a:	9903      	ldr	r1, [sp, #12]
 802746c:	edd1 ba01 	vldr	s23, [r1, #4]
         si3 = pCoef[2 * ia2 + 1];
 8027470:	9905      	ldr	r1, [sp, #20]
 8027472:	ed91 ba01 	vldr	s22, [r1, #4]
         si4 = pCoef[2 * ia3 + 1];
 8027476:	9904      	ldr	r1, [sp, #16]
 8027478:	ed91 aa01 	vldr	s20, [r1, #4]
         si5 = pCoef[2 * ia4 + 1];
 802747c:	9906      	ldr	r1, [sp, #24]
 802747e:	edd1 9a01 	vldr	s19, [r1, #4]
         si6 = pCoef[2 * ia5 + 1];
 8027482:	9909      	ldr	r1, [sp, #36]	; 0x24
 8027484:	edd1 7a01 	vldr	s15, [r1, #4]
         si7 = pCoef[2 * ia6 + 1];
 8027488:	9908      	ldr	r1, [sp, #32]
         co8 = pCoef[2 * ia7];
         si2 = pCoef[2 * ia1 + 1];
         si3 = pCoef[2 * ia2 + 1];
         si4 = pCoef[2 * ia3 + 1];
         si5 = pCoef[2 * ia4 + 1];
         si6 = pCoef[2 * ia5 + 1];
 802748a:	edcd 7a00 	vstr	s15, [sp]
         si7 = pCoef[2 * ia6 + 1];
 802748e:	edd1 7a01 	vldr	s15, [r1, #4]
         si8 = pCoef[2 * ia7 + 1];
 8027492:	9907      	ldr	r1, [sp, #28]
         si2 = pCoef[2 * ia1 + 1];
         si3 = pCoef[2 * ia2 + 1];
         si4 = pCoef[2 * ia3 + 1];
         si5 = pCoef[2 * ia4 + 1];
         si6 = pCoef[2 * ia5 + 1];
         si7 = pCoef[2 * ia6 + 1];
 8027494:	edcd 7a01 	vstr	s15, [sp, #4]
         si8 = pCoef[2 * ia7 + 1];
 8027498:	edd1 7a01 	vldr	s15, [r1, #4]
 802749c:	eb0a 0e07 	add.w	lr, sl, r7
 80274a0:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 80274a2:	edcd 7a02 	vstr	s15, [sp, #8]
 80274a6:	eb0c 010a 	add.w	r1, ip, sl
 80274aa:	4456      	add	r6, sl
 80274ac:	4455      	add	r5, sl
 80274ae:	4454      	add	r4, sl
 80274b0:	4450      	add	r0, sl
 80274b2:	4452      	add	r2, sl

         i1 = j;
 80274b4:	46c4      	mov	ip, r8
 80274b6:	e001      	b.n	80274bc <arm_radix8_butterfly_f32+0x338>
 80274b8:	3f3504f3 	.word	0x3f3504f3
            i4 = i3 + n2;
            i5 = i4 + n2;
            i6 = i5 + n2;
            i7 = i6 + n2;
            i8 = i7 + n2;
            r1 = pSrc[2 * i1] + pSrc[2 * i5];
 80274bc:	edde fa00 	vldr	s31, [lr]
            r5 = pSrc[2 * i1] - pSrc[2 * i5];
            r2 = pSrc[2 * i2] + pSrc[2 * i6];
            r6 = pSrc[2 * i2] - pSrc[2 * i6];
            r3 = pSrc[2 * i3] + pSrc[2 * i7];
 80274c0:	ed52 2a01 	vldr	s5, [r2, #-4]
            i6 = i5 + n2;
            i7 = i6 + n2;
            i8 = i7 + n2;
            r1 = pSrc[2 * i1] + pSrc[2 * i5];
            r5 = pSrc[2 * i1] - pSrc[2 * i5];
            r2 = pSrc[2 * i2] + pSrc[2 * i6];
 80274c4:	ed11 6a01 	vldr	s12, [r1, #-4]
            r6 = pSrc[2 * i2] - pSrc[2 * i6];
            r3 = pSrc[2 * i3] + pSrc[2 * i7];
            r7 = pSrc[2 * i3] - pSrc[2 * i7];
            r4 = pSrc[2 * i4] + pSrc[2 * i8];
 80274c8:	edd0 5a00 	vldr	s11, [r0]
 80274cc:	ed57 6a01 	vldr	s13, [r7, #-4]
            i4 = i3 + n2;
            i5 = i4 + n2;
            i6 = i5 + n2;
            i7 = i6 + n2;
            i8 = i7 + n2;
            r1 = pSrc[2 * i1] + pSrc[2 * i5];
 80274d0:	ed96 7a00 	vldr	s14, [r6]
            r5 = pSrc[2 * i1] - pSrc[2 * i5];
            r2 = pSrc[2 * i2] + pSrc[2 * i6];
            r6 = pSrc[2 * i2] - pSrc[2 * i6];
            r3 = pSrc[2 * i3] + pSrc[2 * i7];
 80274d4:	edd4 7a00 	vldr	s15, [r4]
            i6 = i5 + n2;
            i7 = i6 + n2;
            i8 = i7 + n2;
            r1 = pSrc[2 * i1] + pSrc[2 * i5];
            r5 = pSrc[2 * i1] - pSrc[2 * i5];
            r2 = pSrc[2 * i2] + pSrc[2 * i6];
 80274d8:	ed95 2a00 	vldr	s4, [r5]
            r1 = r1 + r3;
            r3 = r2 - r4;
            r2 = r2 + r4;
            pSrc[2 * i1] = r1 + r2;
            r2 = r1 - r2;
            s1 = pSrc[2 * i1 + 1] + pSrc[2 * i5 + 1];
 80274dc:	ed9e 8a01 	vldr	s16, [lr, #4]
            i4 = i3 + n2;
            i5 = i4 + n2;
            i6 = i5 + n2;
            i7 = i6 + n2;
            i8 = i7 + n2;
            r1 = pSrc[2 * i1] + pSrc[2 * i5];
 80274e0:	ee7f 0a87 	vadd.f32	s1, s31, s14
            r5 = pSrc[2 * i1] - pSrc[2 * i5];
            r2 = pSrc[2 * i2] + pSrc[2 * i6];
 80274e4:	ee32 1a06 	vadd.f32	s2, s4, s12
            r6 = pSrc[2 * i2] - pSrc[2 * i6];
            r3 = pSrc[2 * i3] + pSrc[2 * i7];
 80274e8:	ee37 4aa2 	vadd.f32	s8, s15, s5
            r7 = pSrc[2 * i3] - pSrc[2 * i7];
            r4 = pSrc[2 * i4] + pSrc[2 * i8];
 80274ec:	ee75 4aa6 	vadd.f32	s9, s11, s13
            r8 = pSrc[2 * i4] - pSrc[2 * i8];
            t1 = r1 - r3;
            r1 = r1 + r3;
 80274f0:	ee70 1a84 	vadd.f32	s3, s1, s8
            r3 = r2 - r4;
            r2 = r2 + r4;
 80274f4:	ee31 5a24 	vadd.f32	s10, s2, s9
            i7 = i6 + n2;
            i8 = i7 + n2;
            r1 = pSrc[2 * i1] + pSrc[2 * i5];
            r5 = pSrc[2 * i1] - pSrc[2 * i5];
            r2 = pSrc[2 * i2] + pSrc[2 * i6];
            r6 = pSrc[2 * i2] - pSrc[2 * i6];
 80274f8:	ee32 2a46 	vsub.f32	s4, s4, s12
            r8 = pSrc[2 * i4] - pSrc[2 * i8];
            t1 = r1 - r3;
            r1 = r1 + r3;
            r3 = r2 - r4;
            r2 = r2 + r4;
            pSrc[2 * i1] = r1 + r2;
 80274fc:	ee31 6a85 	vadd.f32	s12, s3, s10
            r2 = pSrc[2 * i2] + pSrc[2 * i6];
            r6 = pSrc[2 * i2] - pSrc[2 * i6];
            r3 = pSrc[2 * i3] + pSrc[2 * i7];
            r7 = pSrc[2 * i3] - pSrc[2 * i7];
            r4 = pSrc[2 * i4] + pSrc[2 * i8];
            r8 = pSrc[2 * i4] - pSrc[2 * i8];
 8027500:	ee75 5ae6 	vsub.f32	s11, s11, s13
            t1 = r1 - r3;
            r1 = r1 + r3;
            r3 = r2 - r4;
            r2 = r2 + r4;
            pSrc[2 * i1] = r1 + r2;
 8027504:	ed8e 6a00 	vstr	s12, [lr]
            s5 = pSrc[2 * i1 + 1] - pSrc[2 * i5 + 1];
            s2 = pSrc[2 * i2 + 1] + pSrc[2 * i6 + 1];
            s6 = pSrc[2 * i2 + 1] - pSrc[2 * i6 + 1];
            s3 = pSrc[2 * i3 + 1] + pSrc[2 * i7 + 1];
            s7 = pSrc[2 * i3 + 1] - pSrc[2 * i7 + 1];
            s4 = pSrc[2 * i4 + 1] + pSrc[2 * i8 + 1];
 8027508:	edd0 8a01 	vldr	s17, [r0, #4]
            r2 = r2 + r4;
            pSrc[2 * i1] = r1 + r2;
            r2 = r1 - r2;
            s1 = pSrc[2 * i1 + 1] + pSrc[2 * i5 + 1];
            s5 = pSrc[2 * i1 + 1] - pSrc[2 * i5 + 1];
            s2 = pSrc[2 * i2 + 1] + pSrc[2 * i6 + 1];
 802750c:	ed95 9a01 	vldr	s18, [r5, #4]
 8027510:	ed91 3a00 	vldr	s6, [r1]
            s6 = pSrc[2 * i2 + 1] - pSrc[2 * i6 + 1];
            s3 = pSrc[2 * i3 + 1] + pSrc[2 * i7 + 1];
            s7 = pSrc[2 * i3 + 1] - pSrc[2 * i7 + 1];
            s4 = pSrc[2 * i4 + 1] + pSrc[2 * i8 + 1];
 8027514:	ed97 6a00 	vldr	s12, [r7]
            r2 = r1 - r2;
            s1 = pSrc[2 * i1 + 1] + pSrc[2 * i5 + 1];
            s5 = pSrc[2 * i1 + 1] - pSrc[2 * i5 + 1];
            s2 = pSrc[2 * i2 + 1] + pSrc[2 * i6 + 1];
            s6 = pSrc[2 * i2 + 1] - pSrc[2 * i6 + 1];
            s3 = pSrc[2 * i3 + 1] + pSrc[2 * i7 + 1];
 8027518:	ed94 0a01 	vldr	s0, [r4, #4]
 802751c:	edd2 6a00 	vldr	s13, [r2]
            r1 = r1 + r3;
            r3 = r2 - r4;
            r2 = r2 + r4;
            pSrc[2 * i1] = r1 + r2;
            r2 = r1 - r2;
            s1 = pSrc[2 * i1 + 1] + pSrc[2 * i5 + 1];
 8027520:	edd6 3a01 	vldr	s7, [r6, #4]
            i5 = i4 + n2;
            i6 = i5 + n2;
            i7 = i6 + n2;
            i8 = i7 + n2;
            r1 = pSrc[2 * i1] + pSrc[2 * i5];
            r5 = pSrc[2 * i1] - pSrc[2 * i5];
 8027524:	ee3f 7ac7 	vsub.f32	s14, s31, s14
            r2 = pSrc[2 * i2] + pSrc[2 * i6];
            r6 = pSrc[2 * i2] - pSrc[2 * i6];
            r3 = pSrc[2 * i3] + pSrc[2 * i7];
            r7 = pSrc[2 * i3] - pSrc[2 * i7];
 8027528:	ee77 7ae2 	vsub.f32	s15, s15, s5
            s2 = pSrc[2 * i2 + 1] + pSrc[2 * i6 + 1];
            s6 = pSrc[2 * i2 + 1] - pSrc[2 * i6 + 1];
            s3 = pSrc[2 * i3 + 1] + pSrc[2 * i7 + 1];
            s7 = pSrc[2 * i3 + 1] - pSrc[2 * i7 + 1];
            s4 = pSrc[2 * i4 + 1] + pSrc[2 * i8 + 1];
            s8 = pSrc[2 * i4 + 1] - pSrc[2 * i8 + 1];
 802752c:	ee78 fac6 	vsub.f32	s31, s17, s12
            pSrc[2 * i1] = r1 + r2;
            r2 = r1 - r2;
            s1 = pSrc[2 * i1 + 1] + pSrc[2 * i5 + 1];
            s5 = pSrc[2 * i1 + 1] - pSrc[2 * i5 + 1];
            s2 = pSrc[2 * i2 + 1] + pSrc[2 * i6 + 1];
            s6 = pSrc[2 * i2 + 1] - pSrc[2 * i6 + 1];
 8027530:	ee79 2a43 	vsub.f32	s5, s18, s6
            r2 = r2 + r4;
            pSrc[2 * i1] = r1 + r2;
            r2 = r1 - r2;
            s1 = pSrc[2 * i1 + 1] + pSrc[2 * i5 + 1];
            s5 = pSrc[2 * i1 + 1] - pSrc[2 * i5 + 1];
            s2 = pSrc[2 * i2 + 1] + pSrc[2 * i6 + 1];
 8027534:	ee39 3a03 	vadd.f32	s6, s18, s6
            s6 = pSrc[2 * i2 + 1] - pSrc[2 * i6 + 1];
            s3 = pSrc[2 * i3 + 1] + pSrc[2 * i7 + 1];
            s7 = pSrc[2 * i3 + 1] - pSrc[2 * i7 + 1];
 8027538:	ee30 9a66 	vsub.f32	s18, s0, s13
            s4 = pSrc[2 * i4 + 1] + pSrc[2 * i8 + 1];
 802753c:	ee38 6a86 	vadd.f32	s12, s17, s12
            r2 = r1 - r2;
            s1 = pSrc[2 * i1 + 1] + pSrc[2 * i5 + 1];
            s5 = pSrc[2 * i1 + 1] - pSrc[2 * i5 + 1];
            s2 = pSrc[2 * i2 + 1] + pSrc[2 * i6 + 1];
            s6 = pSrc[2 * i2 + 1] - pSrc[2 * i6 + 1];
            s3 = pSrc[2 * i3 + 1] + pSrc[2 * i7 + 1];
 8027540:	ee70 6a26 	vadd.f32	s13, s0, s13
            r3 = r2 - r4;
            r2 = r2 + r4;
            pSrc[2 * i1] = r1 + r2;
            r2 = r1 - r2;
            s1 = pSrc[2 * i1 + 1] + pSrc[2 * i5 + 1];
            s5 = pSrc[2 * i1 + 1] - pSrc[2 * i5 + 1];
 8027544:	ee78 8a63 	vsub.f32	s17, s16, s7
            p4 = si7 * t1;
            pSrc[2 * i7]     = p1 + p2;
            pSrc[2 * i7 + 1] = p3 - p4;
            r1 = (r6 - r8) * C81;
            r6 = (r6 + r8) * C81;
            s1 = (s6 - s8) * C81;
 8027548:	ee32 0aef 	vsub.f32	s0, s5, s31
            s6 = (s6 + s8) * C81;
 802754c:	ee72 2aaf 	vadd.f32	s5, s5, s31
            r1 = r1 + r3;
            r3 = r2 - r4;
            r2 = r2 + r4;
            pSrc[2 * i1] = r1 + r2;
            r2 = r1 - r2;
            s1 = pSrc[2 * i1 + 1] + pSrc[2 * i5 + 1];
 8027550:	ee78 3a23 	vadd.f32	s7, s16, s7
            r6 = pSrc[2 * i2] - pSrc[2 * i6];
            r3 = pSrc[2 * i3] + pSrc[2 * i7];
            r7 = pSrc[2 * i3] - pSrc[2 * i7];
            r4 = pSrc[2 * i4] + pSrc[2 * i8];
            r8 = pSrc[2 * i4] - pSrc[2 * i8];
            t1 = r1 - r3;
 8027554:	ee30 4ac4 	vsub.f32	s8, s1, s8
            p3 = co7 * t2;
            p4 = si7 * t1;
            pSrc[2 * i7]     = p1 + p2;
            pSrc[2 * i7 + 1] = p3 - p4;
            r1 = (r6 - r8) * C81;
            r6 = (r6 + r8) * C81;
 8027558:	ee32 8a25 	vadd.f32	s16, s4, s11
            r8 = r7 - r6;
            r7 = r7 + r6;
            t2 = s5 - s1;
            s5 = s5 + s1;
            s8 = s7 - s6;
            s7 = s7 + s6;
 802755c:	eef0 0a49 	vmov.f32	s1, s18
            p2 = si7 * t2;
            p3 = co7 * t2;
            p4 = si7 * t1;
            pSrc[2 * i7]     = p1 + p2;
            pSrc[2 * i7 + 1] = p3 - p4;
            r1 = (r6 - r8) * C81;
 8027560:	ee72 5a65 	vsub.f32	s11, s4, s11
            r8 = r7 - r6;
            r7 = r7 + r6;
            t2 = s5 - s1;
            s5 = s5 + s1;
            s8 = s7 - s6;
            s7 = s7 + s6;
 8027564:	eee2 0aaa 	vfma.f32	s1, s5, s21
            p3 = co4 * t2;
            p4 = si4 * t1;
            pSrc[2 * i4]     = p1 + p2;
            pSrc[2 * i4 + 1] = p3 - p4;

            i1 += n1;
 8027568:	44dc      	add	ip, fp
         } while (i1 < fftLen);
 802756a:	45e1      	cmp	r9, ip
            r5 = r5 + r1;
            r8 = r7 - r6;
            r7 = r7 + r6;
            t2 = s5 - s1;
            s5 = s5 + s1;
            s8 = s7 - s6;
 802756c:	eea2 9aea 	vfms.f32	s18, s5, s21
            t1 = r5 - r1;
            r5 = r5 + r1;
            r8 = r7 - r6;
            r7 = r7 + r6;
            t2 = s5 - s1;
            s5 = s5 + s1;
 8027570:	eeb0 2a68 	vmov.f32	s4, s17
            r1 = (r6 - r8) * C81;
            r6 = (r6 + r8) * C81;
            s1 = (s6 - s8) * C81;
            s6 = (s6 + s8) * C81;
            t1 = r5 - r1;
            r5 = r5 + r1;
 8027574:	eef0 2a47 	vmov.f32	s5, s14
 8027578:	eee5 2aaa 	vfma.f32	s5, s11, s21
            pSrc[2 * i7 + 1] = p3 - p4;
            r1 = (r6 - r8) * C81;
            r6 = (r6 + r8) * C81;
            s1 = (s6 - s8) * C81;
            s6 = (s6 + s8) * C81;
            t1 = r5 - r1;
 802757c:	eea5 7aea 	vfms.f32	s14, s11, s21
            r5 = r5 + r1;
            r8 = r7 - r6;
            r7 = r7 + r6;
            t2 = s5 - s1;
            s5 = s5 + s1;
 8027580:	eea0 2a2a 	vfma.f32	s4, s0, s21
            s4 = pSrc[2 * i4 + 1] + pSrc[2 * i8 + 1];
            s8 = pSrc[2 * i4 + 1] - pSrc[2 * i8 + 1];
            t2 = s1 - s3;
            s1 = s1 + s3;
            s3 = s2 - s4;
            s2 = s2 + s4;
 8027584:	ee73 5a06 	vadd.f32	s11, s6, s12
            s6 = (s6 + s8) * C81;
            t1 = r5 - r1;
            r5 = r5 + r1;
            r8 = r7 - r6;
            r7 = r7 + r6;
            t2 = s5 - s1;
 8027588:	eee0 8a6a 	vfms.f32	s17, s0, s21
            s1 = (s6 - s8) * C81;
            s6 = (s6 + s8) * C81;
            t1 = r5 - r1;
            r5 = r5 + r1;
            r8 = r7 - r6;
            r7 = r7 + r6;
 802758c:	eef0 fa67 	vmov.f32	s31, s15
            s3 = pSrc[2 * i3 + 1] + pSrc[2 * i7 + 1];
            s7 = pSrc[2 * i3 + 1] - pSrc[2 * i7 + 1];
            s4 = pSrc[2 * i4 + 1] + pSrc[2 * i8 + 1];
            s8 = pSrc[2 * i4 + 1] - pSrc[2 * i8 + 1];
            t2 = s1 - s3;
            s1 = s1 + s3;
 8027590:	ee33 0aa6 	vadd.f32	s0, s7, s13
            r6 = (r6 + r8) * C81;
            s1 = (s6 - s8) * C81;
            s6 = (s6 + s8) * C81;
            t1 = r5 - r1;
            r5 = r5 + r1;
            r8 = r7 - r6;
 8027594:	eee8 7a6a 	vfms.f32	s15, s16, s21
            r7 = pSrc[2 * i3] - pSrc[2 * i7];
            r4 = pSrc[2 * i4] + pSrc[2 * i8];
            r8 = pSrc[2 * i4] - pSrc[2 * i8];
            t1 = r1 - r3;
            r1 = r1 + r3;
            r3 = r2 - r4;
 8027598:	ee71 4a64 	vsub.f32	s9, s2, s9
            r2 = r2 + r4;
            pSrc[2 * i1] = r1 + r2;
            r2 = r1 - r2;
 802759c:	ee31 5ac5 	vsub.f32	s10, s3, s10
            s1 = (s6 - s8) * C81;
            s6 = (s6 + s8) * C81;
            t1 = r5 - r1;
            r5 = r5 + r1;
            r8 = r7 - r6;
            r7 = r7 + r6;
 80275a0:	eee8 fa2a 	vfma.f32	s31, s16, s21
            s7 = pSrc[2 * i3 + 1] - pSrc[2 * i7 + 1];
            s4 = pSrc[2 * i4 + 1] + pSrc[2 * i8 + 1];
            s8 = pSrc[2 * i4 + 1] - pSrc[2 * i8 + 1];
            t2 = s1 - s3;
            s1 = s1 + s3;
            s3 = s2 - s4;
 80275a4:	ee33 3a46 	vsub.f32	s6, s6, s12
            s2 = s2 + s4;
            r1 = t1 + s3;
            t1 = t1 - s3;
            pSrc[2 * i1 + 1] = s1 + s2;
            s2 = s1 - s2;
 80275a8:	ee30 8a65 	vsub.f32	s16, s0, s11
            s6 = pSrc[2 * i2 + 1] - pSrc[2 * i6 + 1];
            s3 = pSrc[2 * i3 + 1] + pSrc[2 * i7 + 1];
            s7 = pSrc[2 * i3 + 1] - pSrc[2 * i7 + 1];
            s4 = pSrc[2 * i4 + 1] + pSrc[2 * i8 + 1];
            s8 = pSrc[2 * i4 + 1] - pSrc[2 * i8 + 1];
            t2 = s1 - s3;
 80275ac:	ee73 3ae6 	vsub.f32	s7, s7, s13
            s1 = s1 + s3;
            s3 = s2 - s4;
            s2 = s2 + s4;
            r1 = t1 + s3;
 80275b0:	ee34 6a03 	vadd.f32	s12, s8, s6
            r7 = r7 + r6;
            t2 = s5 - s1;
            s5 = s5 + s1;
            s8 = s7 - s6;
            s7 = s7 + s6;
            r1 = r5 + s7;
 80275b4:	ee72 6aa0 	vadd.f32	s13, s5, s1
            t2 = s1 - s3;
            s1 = s1 + s3;
            s3 = s2 - s4;
            s2 = s2 + s4;
            r1 = t1 + s3;
            t1 = t1 - s3;
 80275b8:	ee34 4a43 	vsub.f32	s8, s8, s6
            t2 = s5 - s1;
            s5 = s5 + s1;
            s8 = s7 - s6;
            s7 = s7 + s6;
            r1 = r5 + s7;
            r5 = r5 - s7;
 80275bc:	ee72 0ae0 	vsub.f32	s1, s5, s1
            s2 = s2 + s4;
            r1 = t1 + s3;
            t1 = t1 - s3;
            pSrc[2 * i1 + 1] = s1 + s2;
            s2 = s1 - s2;
            s1 = t2 - r3;
 80275c0:	ee33 3ae4 	vsub.f32	s6, s7, s9
 80275c4:	ee65 2a69 	vnmul.f32	s5, s10, s19
            t2 = t2 + r3;
 80275c8:	ee73 3aa4 	vadd.f32	s7, s7, s9
            s5 = s5 + s1;
            s8 = s7 - s6;
            s7 = s7 + s6;
            r1 = r5 + s7;
            r5 = r5 - s7;
            r6 = t1 + s8;
 80275cc:	ee77 4a09 	vadd.f32	s9, s14, s18
            t1 = t1 - s8;
 80275d0:	ee37 9a49 	vsub.f32	s18, s14, s18
            s1 = s5 - r7;
            s5 = s5 + r7;
            s6 = t2 - r8;
 80275d4:	ee38 7ae7 	vsub.f32	s14, s17, s15
            t2 = t2 + r8;
 80275d8:	ee78 8aa7 	vadd.f32	s17, s17, s15
            pSrc[2 * i1 + 1] = s1 + s2;
            s2 = s1 - s2;
            s1 = t2 - r3;
            t2 = t2 + r3;
            p1 = co5 * r2;
            p2 = si5 * s2;
 80275dc:	ee69 7a88 	vmul.f32	s15, s19, s16
            p3 = co5 * s2;
            p4 = si5 * r2;
            pSrc[2 * i5]     = p1 + p2;
            pSrc[2 * i5 + 1] = p3 - p4;
 80275e0:	eeed 2a88 	vfma.f32	s5, s27, s16
            t2 = t2 + r3;
            p1 = co5 * r2;
            p2 = si5 * s2;
            p3 = co5 * s2;
            p4 = si5 * r2;
            pSrc[2 * i5]     = p1 + p2;
 80275e4:	eeed 7a85 	vfma.f32	s15, s27, s10
            p3 = co3 * s1;
            p4 = si3 * r1;
            pSrc[2 * i3]     = p1 + p2;
            pSrc[2 * i3 + 1] = p3 - p4;
            p1 = co7 * t1;
            p2 = si7 * t2;
 80275e8:	ed9d 8a01 	vldr	s16, [sp, #4]
 80275ec:	ee26 5a4b 	vnmul.f32	s10, s12, s22
            p3 = co5 * s2;
            p4 = si5 * r2;
            pSrc[2 * i5]     = p1 + p2;
            pSrc[2 * i5 + 1] = p3 - p4;
            p1 = co3 * r1;
            p2 = si3 * s1;
 80275f0:	ee2b 1a03 	vmul.f32	s2, s22, s6
            s7 = s7 + s6;
            r1 = r5 + s7;
            r5 = r5 - s7;
            r6 = t1 + s8;
            t1 = t1 - s8;
            s1 = s5 - r7;
 80275f4:	ee72 1a6f 	vsub.f32	s3, s4, s31
            p1 = co3 * r1;
            p2 = si3 * s1;
            p3 = co3 * s1;
            p4 = si3 * r1;
            pSrc[2 * i3]     = p1 + p2;
            pSrc[2 * i3 + 1] = p3 - p4;
 80275f8:	eeae 5a83 	vfma.f32	s10, s29, s6
            pSrc[2 * i5 + 1] = p3 - p4;
            p1 = co3 * r1;
            p2 = si3 * s1;
            p3 = co3 * s1;
            p4 = si3 * r1;
            pSrc[2 * i3]     = p1 + p2;
 80275fc:	eeae 1a86 	vfma.f32	s2, s29, s12
            pSrc[2 * i3 + 1] = p3 - p4;
            p1 = co7 * t1;
            p2 = si7 * t2;
 8027600:	ee28 3a23 	vmul.f32	s6, s16, s7
 8027604:	ee24 6a48 	vnmul.f32	s12, s8, s16
            r1 = r5 + s7;
            r5 = r5 - s7;
            r6 = t1 + s8;
            t1 = t1 - s8;
            s1 = s5 - r7;
            s5 = s5 + r7;
 8027608:	ee32 2a2f 	vadd.f32	s4, s4, s31
            p3 = co2 * s1;
            p4 = si2 * r1;
            pSrc[2 * i2]     = p1 + p2;
            pSrc[2 * i2 + 1] = p3 - p4;
            p1 = co8 * r5;
            p2 = si8 * s5;
 802760c:	ed9d 8a02 	vldr	s16, [sp, #8]
            pSrc[2 * i3 + 1] = p3 - p4;
            p1 = co7 * t1;
            p2 = si7 * t2;
            p3 = co7 * t2;
            p4 = si7 * t1;
            pSrc[2 * i7]     = p1 + p2;
 8027610:	eeac 3a84 	vfma.f32	s6, s25, s8
            pSrc[2 * i7 + 1] = p3 - p4;
 8027614:	eeac 6aa3 	vfma.f32	s12, s25, s7
            s1 = s5 - r7;
            s5 = s5 + r7;
            s6 = t2 - r8;
            t2 = t2 + r8;
            p1 = co2 * r1;
            p2 = si2 * s1;
 8027618:	ee2b 4aa1 	vmul.f32	s8, s23, s3
 802761c:	ee66 3aeb 	vnmul.f32	s7, s13, s23
            p3 = co2 * s1;
            p4 = si2 * r1;
            pSrc[2 * i2]     = p1 + p2;
 8027620:	eeaf 4a26 	vfma.f32	s8, s30, s13
            pSrc[2 * i2 + 1] = p3 - p4;
 8027624:	eeef 3a21 	vfma.f32	s7, s30, s3
            p1 = co8 * r5;
            p2 = si8 * s5;
 8027628:	ee68 6a02 	vmul.f32	s13, s16, s4
 802762c:	ee60 1ac8 	vnmul.f32	s3, s1, s16
 8027630:	ed9d 8a00 	vldr	s16, [sp]
            p3 = co8 * s5;
            p4 = si8 * r5;
            pSrc[2 * i8]     = p1 + p2;
 8027634:	eeec 6a20 	vfma.f32	s13, s24, s1
            pSrc[2 * i8 + 1] = p3 - p4;
 8027638:	eeec 1a02 	vfma.f32	s3, s24, s4
 802763c:	ee64 0ac8 	vnmul.f32	s1, s9, s16
            p1 = co6 * r6;
            p2 = si6 * s6;
 8027640:	ee28 2a07 	vmul.f32	s4, s16, s14
            p3 = co6 * s6;
            p4 = si6 * r6;
            pSrc[2 * i6]     = p1 + p2;
            pSrc[2 * i6 + 1] = p3 - p4;
 8027644:	eeed 0a07 	vfma.f32	s1, s26, s14
            pSrc[2 * i8 + 1] = p3 - p4;
            p1 = co6 * r6;
            p2 = si6 * s6;
            p3 = co6 * s6;
            p4 = si6 * r6;
            pSrc[2 * i6]     = p1 + p2;
 8027648:	eead 2a24 	vfma.f32	s4, s26, s9
            pSrc[2 * i6 + 1] = p3 - p4;
            p1 = co4 * t1;
            p2 = si4 * t2;
 802764c:	ee2a 7a28 	vmul.f32	s14, s20, s17
 8027650:	ee69 4a4a 	vnmul.f32	s9, s18, s20
            p3 = co4 * t2;
            p4 = si4 * t1;
            pSrc[2 * i4]     = p1 + p2;
 8027654:	eeae 7a09 	vfma.f32	s14, s28, s18
            pSrc[2 * i4 + 1] = p3 - p4;
 8027658:	eeee 4a28 	vfma.f32	s9, s28, s17
            s1 = s1 + s3;
            s3 = s2 - s4;
            s2 = s2 + s4;
            r1 = t1 + s3;
            t1 = t1 - s3;
            pSrc[2 * i1 + 1] = s1 + s2;
 802765c:	ee70 5a25 	vadd.f32	s11, s0, s11
 8027660:	edce 5a01 	vstr	s11, [lr, #4]
            t2 = t2 + r3;
            p1 = co5 * r2;
            p2 = si5 * s2;
            p3 = co5 * s2;
            p4 = si5 * r2;
            pSrc[2 * i5]     = p1 + p2;
 8027664:	edc6 7a00 	vstr	s15, [r6]
            pSrc[2 * i5 + 1] = p3 - p4;
 8027668:	edc6 2a01 	vstr	s5, [r6, #4]
 802766c:	449e      	add	lr, r3
            p1 = co3 * r1;
            p2 = si3 * s1;
            p3 = co3 * s1;
            p4 = si3 * r1;
            pSrc[2 * i3]     = p1 + p2;
 802766e:	ed84 1a00 	vstr	s2, [r4]
            pSrc[2 * i3 + 1] = p3 - p4;
 8027672:	ed84 5a01 	vstr	s10, [r4, #4]
 8027676:	441e      	add	r6, r3
            p1 = co7 * t1;
            p2 = si7 * t2;
            p3 = co7 * t2;
            p4 = si7 * t1;
            pSrc[2 * i7]     = p1 + p2;
 8027678:	ed02 3a01 	vstr	s6, [r2, #-4]
            pSrc[2 * i7 + 1] = p3 - p4;
 802767c:	ed82 6a00 	vstr	s12, [r2]
 8027680:	441c      	add	r4, r3
            t2 = t2 + r8;
            p1 = co2 * r1;
            p2 = si2 * s1;
            p3 = co2 * s1;
            p4 = si2 * r1;
            pSrc[2 * i2]     = p1 + p2;
 8027682:	ed85 4a00 	vstr	s8, [r5]
            pSrc[2 * i2 + 1] = p3 - p4;
 8027686:	edc5 3a01 	vstr	s7, [r5, #4]
 802768a:	441a      	add	r2, r3
            p1 = co8 * r5;
            p2 = si8 * s5;
            p3 = co8 * s5;
            p4 = si8 * r5;
            pSrc[2 * i8]     = p1 + p2;
 802768c:	ed47 6a01 	vstr	s13, [r7, #-4]
            pSrc[2 * i8 + 1] = p3 - p4;
 8027690:	edc7 1a00 	vstr	s3, [r7]
 8027694:	441d      	add	r5, r3
            p1 = co6 * r6;
            p2 = si6 * s6;
            p3 = co6 * s6;
            p4 = si6 * r6;
            pSrc[2 * i6]     = p1 + p2;
 8027696:	ed01 2a01 	vstr	s4, [r1, #-4]
            pSrc[2 * i6 + 1] = p3 - p4;
 802769a:	edc1 0a00 	vstr	s1, [r1]
 802769e:	441f      	add	r7, r3
            p1 = co4 * t1;
            p2 = si4 * t2;
            p3 = co4 * t2;
            p4 = si4 * t1;
            pSrc[2 * i4]     = p1 + p2;
 80276a0:	ed80 7a00 	vstr	s14, [r0]
 80276a4:	4419      	add	r1, r3
            pSrc[2 * i4 + 1] = p3 - p4;
 80276a6:	edc0 4a01 	vstr	s9, [r0, #4]
 80276aa:	4418      	add	r0, r3

            i1 += n1;
         } while (i1 < fftLen);
 80276ac:	f63f af06 	bhi.w	80274bc <arm_radix8_butterfly_f32+0x338>
 80276b0:	9a03      	ldr	r2, [sp, #12]
 80276b2:	990d      	ldr	r1, [sp, #52]	; 0x34
 80276b4:	440a      	add	r2, r1
 80276b6:	9203      	str	r2, [sp, #12]
 80276b8:	990e      	ldr	r1, [sp, #56]	; 0x38
 80276ba:	9a05      	ldr	r2, [sp, #20]
 80276bc:	440a      	add	r2, r1
 80276be:	9205      	str	r2, [sp, #20]
 80276c0:	990f      	ldr	r1, [sp, #60]	; 0x3c
 80276c2:	9a04      	ldr	r2, [sp, #16]
 80276c4:	440a      	add	r2, r1
 80276c6:	9204      	str	r2, [sp, #16]
 80276c8:	9911      	ldr	r1, [sp, #68]	; 0x44
 80276ca:	9a06      	ldr	r2, [sp, #24]
 80276cc:	440a      	add	r2, r1
 80276ce:	9206      	str	r2, [sp, #24]
 80276d0:	9913      	ldr	r1, [sp, #76]	; 0x4c
 80276d2:	9a09      	ldr	r2, [sp, #36]	; 0x24
 80276d4:	440a      	add	r2, r1
 80276d6:	9209      	str	r2, [sp, #36]	; 0x24
 80276d8:	9910      	ldr	r1, [sp, #64]	; 0x40
 80276da:	9a08      	ldr	r2, [sp, #32]
 80276dc:	440a      	add	r2, r1
 80276de:	9208      	str	r2, [sp, #32]
 80276e0:	9912      	ldr	r1, [sp, #72]	; 0x48
 80276e2:	9a07      	ldr	r2, [sp, #28]
 80276e4:	440a      	add	r2, r1
 80276e6:	9207      	str	r2, [sp, #28]

         j++;
      } while (j < n2);
 80276e8:	990c      	ldr	r1, [sp, #48]	; 0x30
 80276ea:	9a0a      	ldr	r2, [sp, #40]	; 0x28
            pSrc[2 * i4 + 1] = p3 - p4;

            i1 += n1;
         } while (i1 < fftLen);

         j++;
 80276ec:	f108 0801 	add.w	r8, r8, #1
 80276f0:	3208      	adds	r2, #8
      } while (j < n2);
 80276f2:	4588      	cmp	r8, r1
 80276f4:	920a      	str	r2, [sp, #40]	; 0x28
 80276f6:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 80276f8:	f47f ae91 	bne.w	802741e <arm_radix8_butterfly_f32+0x29a>

      twidCoefModifier <<= 3;
 80276fc:	f8bd 3034 	ldrh.w	r3, [sp, #52]	; 0x34
 8027700:	9300      	str	r3, [sp, #0]
 8027702:	46c3      	mov	fp, r8
 8027704:	f8dd e06c 	ldr.w	lr, [sp, #108]	; 0x6c
 8027708:	e54c      	b.n	80271a4 <arm_radix8_butterfly_f32+0x20>
   } while (n2 > 7);
}
 802770a:	b01d      	add	sp, #116	; 0x74
 802770c:	ecbd 8b10 	vpop	{d8-d15}
 8027710:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08027714 <arm_max_f32>:
void arm_max_f32(
  float32_t * pSrc,
  uint32_t blockSize,
  float32_t * pResult,
  uint32_t * pIndex)
{
 8027714:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  outIndex = 0u;
  /* Load first input value that act as reference value for comparision */
  out = *pSrc++;

  /* Loop unrolling */
  blkCnt = (blockSize - 1u) >> 2u;
 8027718:	1e4f      	subs	r7, r1, #1

  while (blkCnt > 0u)
 802771a:	ea5f 0897 	movs.w	r8, r7, lsr #2
  /* Initialise the count value. */
  count = 0u;
  /* Initialise the index value to zero. */
  outIndex = 0u;
  /* Load first input value that act as reference value for comparision */
  out = *pSrc++;
 802771e:	f100 0e04 	add.w	lr, r0, #4
 8027722:	edd0 7a00 	vldr	s15, [r0]

  /* Loop unrolling */
  blkCnt = (blockSize - 1u) >> 2u;

  while (blkCnt > 0u)
 8027726:	d058      	beq.n	80277da <arm_max_f32+0xc6>
 8027728:	3014      	adds	r0, #20
 802772a:	46c4      	mov	ip, r8
 802772c:	2604      	movs	r6, #4
 802772e:	2400      	movs	r4, #0
  {
    /* Initialize maxVal to the next consecutive values one by one */
    maxVal1 = *pSrc++;
 8027730:	ed10 6a04 	vldr	s12, [r0, #-16]
    maxVal2 = *pSrc++;
 8027734:	ed50 6a03 	vldr	s13, [r0, #-12]
      out = maxVal2;
      outIndex = count + 2u;
    }

    /* Initialize maxVal to the next consecutive values one by one */
    maxVal1 = *pSrc++;
 8027738:	ed10 7a02 	vldr	s14, [r0, #-8]
    maxVal2 = *pSrc++;
 802773c:	ed50 5a01 	vldr	s11, [r0, #-4]
 8027740:	eeb4 6ae7 	vcmpe.f32	s12, s15
 8027744:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8027748:	bfc8      	it	gt
 802774a:	eef0 7a46 	vmovgt.f32	s15, s12
    /* compare for the maximum value */
    if (out < maxVal1)
    {
      /* Update the maximum value and its index */
      out = maxVal1;
      outIndex = count + 1u;
 802774e:	f1a6 0503 	sub.w	r5, r6, #3
 8027752:	eef4 7ae6 	vcmpe.f32	s15, s13
 8027756:	bfc8      	it	gt
 8027758:	462c      	movgt	r4, r5
 802775a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802775e:	bf48      	it	mi
 8027760:	eef0 7a66 	vmovmi.f32	s15, s13
    /* compare for the maximum value */
    if (out < maxVal2)
    {
      /* Update the maximum value and its index */
      out = maxVal2;
      outIndex = count + 2u;
 8027764:	f1a6 0502 	sub.w	r5, r6, #2
 8027768:	eef4 7ac7 	vcmpe.f32	s15, s14
 802776c:	bf48      	it	mi
 802776e:	462c      	movmi	r4, r5
 8027770:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8027774:	bf48      	it	mi
 8027776:	eef0 7a47 	vmovmi.f32	s15, s14
    /* compare for the maximum value */
    if (out < maxVal1)
    {
      /* Update the maximum value and its index */
      out = maxVal1;
      outIndex = count + 3u;
 802777a:	f106 35ff 	add.w	r5, r6, #4294967295
 802777e:	eef4 7ae5 	vcmpe.f32	s15, s11
 8027782:	bf48      	it	mi
 8027784:	462c      	movmi	r4, r5
 8027786:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802778a:	bf48      	it	mi
 802778c:	4634      	movmi	r4, r6
 802778e:	bf48      	it	mi
 8027790:	eef0 7a65 	vmovmi.f32	s15, s11
  out = *pSrc++;

  /* Loop unrolling */
  blkCnt = (blockSize - 1u) >> 2u;

  while (blkCnt > 0u)
 8027794:	f1bc 0c01 	subs.w	ip, ip, #1
 8027798:	f106 0604 	add.w	r6, r6, #4
 802779c:	f100 0010 	add.w	r0, r0, #16
 80277a0:	d1c6      	bne.n	8027730 <arm_max_f32+0x1c>
 80277a2:	eb0e 1e08 	add.w	lr, lr, r8, lsl #4

  blkCnt = (blockSize - 1u);

#endif /* #if defined (ARM_MATH_DSP) */

  while (blkCnt > 0u)
 80277a6:	f017 0003 	ands.w	r0, r7, #3
 80277aa:	d018      	beq.n	80277de <arm_max_f32+0xca>
 80277ac:	1a08      	subs	r0, r1, r0
  {
    /* Initialize maxVal to the next consecutive values one by one */
    maxVal1 = *pSrc++;
 80277ae:	ecbe 7a01 	vldmia	lr!, {s14}
 80277b2:	eeb4 7ae7 	vcmpe.f32	s14, s15
 80277b6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80277ba:	bfc8      	it	gt
 80277bc:	4604      	movgt	r4, r0
 80277be:	f100 0001 	add.w	r0, r0, #1
 80277c2:	bfd8      	it	le
 80277c4:	eeb0 7a67 	vmovle.f32	s14, s15

  blkCnt = (blockSize - 1u);

#endif /* #if defined (ARM_MATH_DSP) */

  while (blkCnt > 0u)
 80277c8:	4288      	cmp	r0, r1
 80277ca:	eef0 7a47 	vmov.f32	s15, s14
 80277ce:	d1ee      	bne.n	80277ae <arm_max_f32+0x9a>
    /* Decrement the loop counter */
    blkCnt--;
  }

  /* Store the maximum value and it's index into destination pointers */
  *pResult = out;
 80277d0:	ed82 7a00 	vstr	s14, [r2]
  *pIndex = outIndex;
 80277d4:	601c      	str	r4, [r3, #0]
 80277d6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  uint32_t blkCnt, outIndex, count;              /* loop counter */

  /* Initialise the count value. */
  count = 0u;
  /* Initialise the index value to zero. */
  outIndex = 0u;
 80277da:	4644      	mov	r4, r8
 80277dc:	e7e3      	b.n	80277a6 <arm_max_f32+0x92>

  blkCnt = (blockSize - 1u);

#endif /* #if defined (ARM_MATH_DSP) */

  while (blkCnt > 0u)
 80277de:	eeb0 7a67 	vmov.f32	s14, s15
 80277e2:	e7f5      	b.n	80277d0 <arm_max_f32+0xbc>

080277e4 <arm_mean_f32>:

void arm_mean_f32(
  float32_t * pSrc,
  uint32_t blockSize,
  float32_t * pResult)
{
 80277e4:	b430      	push	{r4, r5}
  /*loop Unrolling */
  blkCnt = blockSize >> 2u;

  /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.
   ** a second loop below computes the remaining 1 to 3 samples. */
  while (blkCnt > 0u)
 80277e6:	088d      	lsrs	r5, r1, #2
 80277e8:	eddf 7a17 	vldr	s15, [pc, #92]	; 8027848 <arm_mean_f32+0x64>
 80277ec:	d018      	beq.n	8027820 <arm_mean_f32+0x3c>
 80277ee:	f100 0310 	add.w	r3, r0, #16
 80277f2:	462c      	mov	r4, r5
    in1 = *pSrc++;
    in2 = *pSrc++;
    in3 = *pSrc++;
    in4 = *pSrc++;

    sum += in1;
 80277f4:	ed13 7a04 	vldr	s14, [r3, #-16]
    sum += in2;
 80277f8:	ed53 5a03 	vldr	s11, [r3, #-12]
    sum += in3;
 80277fc:	ed13 6a02 	vldr	s12, [r3, #-8]
    sum += in4;
 8027800:	ed53 6a01 	vldr	s13, [r3, #-4]
    in1 = *pSrc++;
    in2 = *pSrc++;
    in3 = *pSrc++;
    in4 = *pSrc++;

    sum += in1;
 8027804:	ee37 7a87 	vadd.f32	s14, s15, s14
  /*loop Unrolling */
  blkCnt = blockSize >> 2u;

  /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.
   ** a second loop below computes the remaining 1 to 3 samples. */
  while (blkCnt > 0u)
 8027808:	3c01      	subs	r4, #1
    in2 = *pSrc++;
    in3 = *pSrc++;
    in4 = *pSrc++;

    sum += in1;
    sum += in2;
 802780a:	ee77 7a25 	vadd.f32	s15, s14, s11
 802780e:	f103 0310 	add.w	r3, r3, #16
    sum += in3;
 8027812:	ee77 7a86 	vadd.f32	s15, s15, s12
    sum += in4;
 8027816:	ee77 7aa6 	vadd.f32	s15, s15, s13
  /*loop Unrolling */
  blkCnt = blockSize >> 2u;

  /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.
   ** a second loop below computes the remaining 1 to 3 samples. */
  while (blkCnt > 0u)
 802781a:	d1eb      	bne.n	80277f4 <arm_mean_f32+0x10>
 802781c:	eb00 1005 	add.w	r0, r0, r5, lsl #4
  /* Loop over blockSize number of values */
  blkCnt = blockSize;

#endif /* #if defined (ARM_MATH_DSP) */

  while (blkCnt > 0u)
 8027820:	f011 0303 	ands.w	r3, r1, #3
 8027824:	d005      	beq.n	8027832 <arm_mean_f32+0x4e>
  {
    /* C = (A[0] + A[1] + A[2] + ... + A[blockSize-1]) */
    sum += *pSrc++;
 8027826:	ecb0 7a01 	vldmia	r0!, {s14}
  /* Loop over blockSize number of values */
  blkCnt = blockSize;

#endif /* #if defined (ARM_MATH_DSP) */

  while (blkCnt > 0u)
 802782a:	3b01      	subs	r3, #1
  {
    /* C = (A[0] + A[1] + A[2] + ... + A[blockSize-1]) */
    sum += *pSrc++;
 802782c:	ee77 7a87 	vadd.f32	s15, s15, s14
  /* Loop over blockSize number of values */
  blkCnt = blockSize;

#endif /* #if defined (ARM_MATH_DSP) */

  while (blkCnt > 0u)
 8027830:	d1f9      	bne.n	8027826 <arm_mean_f32+0x42>
    blkCnt--;
  }

  /* C = (A[0] + A[1] + A[2] + ... + A[blockSize-1]) / blockSize  */
  /* Store the result to the destination */
  *pResult = sum / (float32_t) blockSize;
 8027832:	ee07 1a10 	vmov	s14, r1
 8027836:	eeb8 7a47 	vcvt.f32.u32	s14, s14
}
 802783a:	bc30      	pop	{r4, r5}
    blkCnt--;
  }

  /* C = (A[0] + A[1] + A[2] + ... + A[blockSize-1]) / blockSize  */
  /* Store the result to the destination */
  *pResult = sum / (float32_t) blockSize;
 802783c:	eec7 7a87 	vdiv.f32	s15, s15, s14
 8027840:	edc2 7a00 	vstr	s15, [r2]
}
 8027844:	4770      	bx	lr
 8027846:	bf00      	nop
 8027848:	00000000 	.word	0x00000000

0802784c <arm_cos_f32>:
  int32_t n;
  float32_t findex;

  /* input x is in radians */
  /* Scale the input to [0 1] range from [0 2*PI] , divide input by 2*pi, add 0.25 (pi/2) to read sine table */
  in = x * 0.159154943092f + 0.25f;
 802784c:	ed9f 7a1c 	vldr	s14, [pc, #112]	; 80278c0 <arm_cos_f32+0x74>
 8027850:	ee06 0a90 	vmov	s13, r0
 8027854:	eef5 7a00 	vmov.f32	s15, #80	; 0x50
 8027858:	eee6 7a87 	vfma.f32	s15, s13, s14

  /* Calculation of floor value of input */
  n = (int32_t) in;

  /* Make negative values towards -infinity */
  if (in < 0.0f)
 802785c:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8027860:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  /* input x is in radians */
  /* Scale the input to [0 1] range from [0 2*PI] , divide input by 2*pi, add 0.25 (pi/2) to read sine table */
  in = x * 0.159154943092f + 0.25f;

  /* Calculation of floor value of input */
  n = (int32_t) in;
 8027864:	eebd 7ae7 	vcvt.s32.f32	s14, s15

  /* Make negative values towards -infinity */
  if (in < 0.0f)
 8027868:	d504      	bpl.n	8027874 <arm_cos_f32+0x28>
  {
    n--;
 802786a:	ee17 3a10 	vmov	r3, s14
 802786e:	3b01      	subs	r3, #1
 8027870:	ee07 3a10 	vmov	s14, r3
  }

  /* Map input value to [0 1] */
  in = in - (float32_t) n;
 8027874:	eeb8 7ac7 	vcvt.f32.s32	s14, s14

  /* Calculation of index of the table */
  findex = (float32_t) FAST_MATH_TABLE_SIZE * in;
 8027878:	eddf 6a12 	vldr	s13, [pc, #72]	; 80278c4 <arm_cos_f32+0x78>
  /* fractional value calculation */
  fract = findex - (float32_t) index;

  /* Read two nearest values of input value from the cos table */
  a = sinTable_f32[index];
  b = sinTable_f32[index+1];
 802787c:	4a12      	ldr	r2, [pc, #72]	; (80278c8 <arm_cos_f32+0x7c>)
  {
    n--;
  }

  /* Map input value to [0 1] */
  in = in - (float32_t) n;
 802787e:	ee77 7ac7 	vsub.f32	s15, s15, s14
  /* Read two nearest values of input value from the cos table */
  a = sinTable_f32[index];
  b = sinTable_f32[index+1];

  /* Linear interpolation process */
  cosVal = (1.0f-fract)*a + fract*b;
 8027882:	eeb7 7a00 	vmov.f32	s14, #112	; 0x70

  /* Map input value to [0 1] */
  in = in - (float32_t) n;

  /* Calculation of index of the table */
  findex = (float32_t) FAST_MATH_TABLE_SIZE * in;
 8027886:	ee67 7aa6 	vmul.f32	s15, s15, s13
  index = ((uint16_t)findex) & 0x1ff;
 802788a:	eefc 6ae7 	vcvt.u32.f32	s13, s15
 802788e:	ee16 3a90 	vmov	r3, s13
 8027892:	f3c3 0308 	ubfx	r3, r3, #0, #9

  /* fractional value calculation */
  fract = findex - (float32_t) index;
 8027896:	ee06 3a90 	vmov	s13, r3
 802789a:	eef8 6a66 	vcvt.f32.u32	s13, s13

  /* Read two nearest values of input value from the cos table */
  a = sinTable_f32[index];
  b = sinTable_f32[index+1];
 802789e:	eb02 0183 	add.w	r1, r2, r3, lsl #2
  /* Calculation of index of the table */
  findex = (float32_t) FAST_MATH_TABLE_SIZE * in;
  index = ((uint16_t)findex) & 0x1ff;

  /* fractional value calculation */
  fract = findex - (float32_t) index;
 80278a2:	ee77 7ae6 	vsub.f32	s15, s15, s13
  /* Read two nearest values of input value from the cos table */
  a = sinTable_f32[index];
  b = sinTable_f32[index+1];

  /* Linear interpolation process */
  cosVal = (1.0f-fract)*a + fract*b;
 80278a6:	edd1 6a01 	vldr	s13, [r1, #4]
 80278aa:	ee37 7a67 	vsub.f32	s14, s14, s15
 80278ae:	ee67 7aa6 	vmul.f32	s15, s15, s13
 80278b2:	edd1 6a00 	vldr	s13, [r1]

  /* Return the output value */
  return (cosVal);
}
 80278b6:	eee7 7a26 	vfma.f32	s15, s14, s13
 80278ba:	ee17 0a90 	vmov	r0, s15
 80278be:	4770      	bx	lr
 80278c0:	3e22f983 	.word	0x3e22f983
 80278c4:	44000000 	.word	0x44000000
 80278c8:	08030384 	.word	0x08030384

080278cc <arm_cmplx_mag_f32>:

void arm_cmplx_mag_f32(
  float32_t * pSrc,
  float32_t * pDst,
  uint32_t numSamples)
{
 80278cc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  /*loop Unrolling */
  blkCnt = numSamples >> 2u;

  /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.
   ** a second loop below computes the remaining 1 to 3 samples. */
  while (blkCnt > 0u)
 80278d0:	ea5f 0992 	movs.w	r9, r2, lsr #2

void arm_cmplx_mag_f32(
  float32_t * pSrc,
  float32_t * pDst,
  uint32_t numSamples)
{
 80278d4:	b083      	sub	sp, #12
 80278d6:	4606      	mov	r6, r0
  /*loop Unrolling */
  blkCnt = numSamples >> 2u;

  /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.
   ** a second loop below computes the remaining 1 to 3 samples. */
  while (blkCnt > 0u)
 80278d8:	d078      	beq.n	80279cc <arm_cmplx_mag_f32+0x100>
   */
  CMSIS_INLINE __STATIC_INLINE arm_status arm_sqrt_f32(
  float32_t in,
  float32_t * pOut)
  {
    if (in >= 0.0f)
 80278da:	f04f 0800 	mov.w	r8, #0
 80278de:	f100 0420 	add.w	r4, r0, #32
 80278e2:	f101 0510 	add.w	r5, r1, #16
 80278e6:	464f      	mov	r7, r9
 80278e8:	e054      	b.n	8027994 <arm_cmplx_mag_f32+0xc8>
#if   (__FPU_USED == 1) && defined ( __CC_ARM   )
      *pOut = __sqrtf(in);
#elif (__FPU_USED == 1) && (defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050))
      *pOut = __builtin_sqrtf(in);
#elif (__FPU_USED == 1) && defined(__GNUC__)
      *pOut = __builtin_sqrtf(in);
 80278ea:	eeb1 7ae7 	vsqrt.f32	s14, s15
 80278ee:	eeb4 7a47 	vcmp.f32	s14, s14
 80278f2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80278f6:	f040 809a 	bne.w	8027a2e <arm_cmplx_mag_f32+0x162>
 80278fa:	ed05 7a04 	vstr	s14, [r5, #-16]
    imagIn = *pSrc++;
    /* store the result in the destination buffer. */
    arm_sqrt_f32((realIn * realIn) + (imagIn * imagIn), pDst++);

    realIn = *pSrc++;
    imagIn = *pSrc++;
 80278fe:	ed54 7a05 	vldr	s15, [r4, #-20]	; 0xffffffec
    realIn = *pSrc++;
    imagIn = *pSrc++;
    /* store the result in the destination buffer. */
    arm_sqrt_f32((realIn * realIn) + (imagIn * imagIn), pDst++);

    realIn = *pSrc++;
 8027902:	ed14 7a06 	vldr	s14, [r4, #-24]	; 0xffffffe8
    imagIn = *pSrc++;
    arm_sqrt_f32((realIn * realIn) + (imagIn * imagIn), pDst++);
 8027906:	ee67 7aa7 	vmul.f32	s15, s15, s15
 802790a:	eee7 7a07 	vfma.f32	s15, s14, s14
   */
  CMSIS_INLINE __STATIC_INLINE arm_status arm_sqrt_f32(
  float32_t in,
  float32_t * pOut)
  {
    if (in >= 0.0f)
 802790e:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8027912:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8027916:	f2c0 8087 	blt.w	8027a28 <arm_cmplx_mag_f32+0x15c>
#if   (__FPU_USED == 1) && defined ( __CC_ARM   )
      *pOut = __sqrtf(in);
#elif (__FPU_USED == 1) && (defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050))
      *pOut = __builtin_sqrtf(in);
#elif (__FPU_USED == 1) && defined(__GNUC__)
      *pOut = __builtin_sqrtf(in);
 802791a:	eeb1 7ae7 	vsqrt.f32	s14, s15
 802791e:	eeb4 7a47 	vcmp.f32	s14, s14
 8027922:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8027926:	f040 80ac 	bne.w	8027a82 <arm_cmplx_mag_f32+0x1b6>
 802792a:	ed05 7a03 	vstr	s14, [r5, #-12]

    realIn = *pSrc++;
    imagIn = *pSrc++;
 802792e:	ed54 7a03 	vldr	s15, [r4, #-12]

    realIn = *pSrc++;
    imagIn = *pSrc++;
    arm_sqrt_f32((realIn * realIn) + (imagIn * imagIn), pDst++);

    realIn = *pSrc++;
 8027932:	ed14 7a04 	vldr	s14, [r4, #-16]
    imagIn = *pSrc++;
    arm_sqrt_f32((realIn * realIn) + (imagIn * imagIn), pDst++);
 8027936:	ee67 7aa7 	vmul.f32	s15, s15, s15
 802793a:	eee7 7a07 	vfma.f32	s15, s14, s14
   */
  CMSIS_INLINE __STATIC_INLINE arm_status arm_sqrt_f32(
  float32_t in,
  float32_t * pOut)
  {
    if (in >= 0.0f)
 802793e:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8027942:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8027946:	db6c      	blt.n	8027a22 <arm_cmplx_mag_f32+0x156>
#if   (__FPU_USED == 1) && defined ( __CC_ARM   )
      *pOut = __sqrtf(in);
#elif (__FPU_USED == 1) && (defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050))
      *pOut = __builtin_sqrtf(in);
#elif (__FPU_USED == 1) && defined(__GNUC__)
      *pOut = __builtin_sqrtf(in);
 8027948:	eeb1 7ae7 	vsqrt.f32	s14, s15
 802794c:	eeb4 7a47 	vcmp.f32	s14, s14
 8027950:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8027954:	f040 808a 	bne.w	8027a6c <arm_cmplx_mag_f32+0x1a0>
 8027958:	ed05 7a02 	vstr	s14, [r5, #-8]

    realIn = *pSrc++;
    imagIn = *pSrc++;
 802795c:	ed54 7a01 	vldr	s15, [r4, #-4]

    realIn = *pSrc++;
    imagIn = *pSrc++;
    arm_sqrt_f32((realIn * realIn) + (imagIn * imagIn), pDst++);

    realIn = *pSrc++;
 8027960:	ed14 7a02 	vldr	s14, [r4, #-8]
    imagIn = *pSrc++;
    arm_sqrt_f32((realIn * realIn) + (imagIn * imagIn), pDst++);
 8027964:	ee67 7aa7 	vmul.f32	s15, s15, s15
 8027968:	eee7 7a07 	vfma.f32	s15, s14, s14
   */
  CMSIS_INLINE __STATIC_INLINE arm_status arm_sqrt_f32(
  float32_t in,
  float32_t * pOut)
  {
    if (in >= 0.0f)
 802796c:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8027970:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8027974:	db1e      	blt.n	80279b4 <arm_cmplx_mag_f32+0xe8>
#if   (__FPU_USED == 1) && defined ( __CC_ARM   )
      *pOut = __sqrtf(in);
#elif (__FPU_USED == 1) && (defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050))
      *pOut = __builtin_sqrtf(in);
#elif (__FPU_USED == 1) && defined(__GNUC__)
      *pOut = __builtin_sqrtf(in);
 8027976:	eeb1 7ae7 	vsqrt.f32	s14, s15
 802797a:	eeb4 7a47 	vcmp.f32	s14, s14
 802797e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8027982:	d168      	bne.n	8027a56 <arm_cmplx_mag_f32+0x18a>
  /*loop Unrolling */
  blkCnt = numSamples >> 2u;

  /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.
   ** a second loop below computes the remaining 1 to 3 samples. */
  while (blkCnt > 0u)
 8027984:	3f01      	subs	r7, #1
 8027986:	ed05 7a01 	vstr	s14, [r5, #-4]
 802798a:	f104 0420 	add.w	r4, r4, #32
 802798e:	f105 0510 	add.w	r5, r5, #16
 8027992:	d017      	beq.n	80279c4 <arm_cmplx_mag_f32+0xf8>
  {

    /* C[0] = sqrt(A[0] * A[0] + A[1] * A[1]) */
    realIn = *pSrc++;
    imagIn = *pSrc++;
 8027994:	ed54 7a07 	vldr	s15, [r4, #-28]	; 0xffffffe4
   ** a second loop below computes the remaining 1 to 3 samples. */
  while (blkCnt > 0u)
  {

    /* C[0] = sqrt(A[0] * A[0] + A[1] * A[1]) */
    realIn = *pSrc++;
 8027998:	ed14 7a08 	vldr	s14, [r4, #-32]	; 0xffffffe0
    imagIn = *pSrc++;
    /* store the result in the destination buffer. */
    arm_sqrt_f32((realIn * realIn) + (imagIn * imagIn), pDst++);
 802799c:	ee67 7aa7 	vmul.f32	s15, s15, s15
 80279a0:	eee7 7a07 	vfma.f32	s15, s14, s14
   */
  CMSIS_INLINE __STATIC_INLINE arm_status arm_sqrt_f32(
  float32_t in,
  float32_t * pOut)
  {
    if (in >= 0.0f)
 80279a4:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 80279a8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80279ac:	da9d      	bge.n	80278ea <arm_cmplx_mag_f32+0x1e>

      return (ARM_MATH_SUCCESS);
    }
    else
    {
      *pOut = 0.0f;
 80279ae:	f845 8c10 	str.w	r8, [r5, #-16]
 80279b2:	e7a4      	b.n	80278fe <arm_cmplx_mag_f32+0x32>
  /*loop Unrolling */
  blkCnt = numSamples >> 2u;

  /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.
   ** a second loop below computes the remaining 1 to 3 samples. */
  while (blkCnt > 0u)
 80279b4:	3f01      	subs	r7, #1
 80279b6:	f845 8c04 	str.w	r8, [r5, #-4]
 80279ba:	f104 0420 	add.w	r4, r4, #32
 80279be:	f105 0510 	add.w	r5, r5, #16
 80279c2:	d1e7      	bne.n	8027994 <arm_cmplx_mag_f32+0xc8>
 80279c4:	eb06 1649 	add.w	r6, r6, r9, lsl #5
 80279c8:	eb01 1109 	add.w	r1, r1, r9, lsl #4

  /* If the numSamples is not a multiple of 4, compute any remaining output samples here.
   ** No loop unrolling is used. */
  blkCnt = numSamples % 0x4u;

  while (blkCnt > 0u)
 80279cc:	f012 0503 	ands.w	r5, r2, #3
 80279d0:	d024      	beq.n	8027a1c <arm_cmplx_mag_f32+0x150>
   */
  CMSIS_INLINE __STATIC_INLINE arm_status arm_sqrt_f32(
  float32_t in,
  float32_t * pOut)
  {
    if (in >= 0.0f)
 80279d2:	2700      	movs	r7, #0
 80279d4:	f106 0408 	add.w	r4, r6, #8
 80279d8:	e00c      	b.n	80279f4 <arm_cmplx_mag_f32+0x128>
#if   (__FPU_USED == 1) && defined ( __CC_ARM   )
      *pOut = __sqrtf(in);
#elif (__FPU_USED == 1) && (defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050))
      *pOut = __builtin_sqrtf(in);
#elif (__FPU_USED == 1) && defined(__GNUC__)
      *pOut = __builtin_sqrtf(in);
 80279da:	eeb1 7ae7 	vsqrt.f32	s14, s15
 80279de:	eeb4 7a47 	vcmp.f32	s14, s14
 80279e2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80279e6:	d12d      	bne.n	8027a44 <arm_cmplx_mag_f32+0x178>
 80279e8:	3d01      	subs	r5, #1
 80279ea:	ed01 7a01 	vstr	s14, [r1, #-4]
 80279ee:	f104 0408 	add.w	r4, r4, #8
 80279f2:	d013      	beq.n	8027a1c <arm_cmplx_mag_f32+0x150>
  {
    /* C[0] = sqrt(A[0] * A[0] + A[1] * A[1]) */
    realIn = *pSrc++;
    imagIn = *pSrc++;
 80279f4:	ed54 7a01 	vldr	s15, [r4, #-4]
  blkCnt = numSamples % 0x4u;

  while (blkCnt > 0u)
  {
    /* C[0] = sqrt(A[0] * A[0] + A[1] * A[1]) */
    realIn = *pSrc++;
 80279f8:	ed14 7a02 	vldr	s14, [r4, #-8]
    imagIn = *pSrc++;
    /* store the result in the destination buffer. */
    arm_sqrt_f32((realIn * realIn) + (imagIn * imagIn), pDst++);
 80279fc:	ee67 7aa7 	vmul.f32	s15, s15, s15
 8027a00:	3104      	adds	r1, #4
 8027a02:	eee7 7a07 	vfma.f32	s15, s14, s14
   */
  CMSIS_INLINE __STATIC_INLINE arm_status arm_sqrt_f32(
  float32_t in,
  float32_t * pOut)
  {
    if (in >= 0.0f)
 8027a06:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8027a0a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8027a0e:	dae4      	bge.n	80279da <arm_cmplx_mag_f32+0x10e>

  /* If the numSamples is not a multiple of 4, compute any remaining output samples here.
   ** No loop unrolling is used. */
  blkCnt = numSamples % 0x4u;

  while (blkCnt > 0u)
 8027a10:	3d01      	subs	r5, #1

      return (ARM_MATH_SUCCESS);
    }
    else
    {
      *pOut = 0.0f;
 8027a12:	f841 7c04 	str.w	r7, [r1, #-4]
 8027a16:	f104 0408 	add.w	r4, r4, #8
 8027a1a:	d1eb      	bne.n	80279f4 <arm_cmplx_mag_f32+0x128>
    numSamples--;
  }

#endif /* #if defined (ARM_MATH_DSP) */

}
 8027a1c:	b003      	add	sp, #12
 8027a1e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8027a22:	f845 8c08 	str.w	r8, [r5, #-8]
 8027a26:	e799      	b.n	802795c <arm_cmplx_mag_f32+0x90>
 8027a28:	f845 8c0c 	str.w	r8, [r5, #-12]
 8027a2c:	e77f      	b.n	802792e <arm_cmplx_mag_f32+0x62>
#if   (__FPU_USED == 1) && defined ( __CC_ARM   )
      *pOut = __sqrtf(in);
#elif (__FPU_USED == 1) && (defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050))
      *pOut = __builtin_sqrtf(in);
#elif (__FPU_USED == 1) && defined(__GNUC__)
      *pOut = __builtin_sqrtf(in);
 8027a2e:	ee17 0a90 	vmov	r0, s15
 8027a32:	e88d 0006 	stmia.w	sp, {r1, r2}
 8027a36:	f003 fa87 	bl	802af48 <sqrtf>
 8027a3a:	e89d 0006 	ldmia.w	sp, {r1, r2}
 8027a3e:	ee07 0a10 	vmov	s14, r0
 8027a42:	e75a      	b.n	80278fa <arm_cmplx_mag_f32+0x2e>
 8027a44:	ee17 0a90 	vmov	r0, s15
 8027a48:	9100      	str	r1, [sp, #0]
 8027a4a:	f003 fa7d 	bl	802af48 <sqrtf>
 8027a4e:	9900      	ldr	r1, [sp, #0]
 8027a50:	ee07 0a10 	vmov	s14, r0
 8027a54:	e7c8      	b.n	80279e8 <arm_cmplx_mag_f32+0x11c>
 8027a56:	ee17 0a90 	vmov	r0, s15
 8027a5a:	e88d 0006 	stmia.w	sp, {r1, r2}
 8027a5e:	f003 fa73 	bl	802af48 <sqrtf>
 8027a62:	e89d 0006 	ldmia.w	sp, {r1, r2}
 8027a66:	ee07 0a10 	vmov	s14, r0
 8027a6a:	e78b      	b.n	8027984 <arm_cmplx_mag_f32+0xb8>
 8027a6c:	ee17 0a90 	vmov	r0, s15
 8027a70:	e88d 0006 	stmia.w	sp, {r1, r2}
 8027a74:	f003 fa68 	bl	802af48 <sqrtf>
 8027a78:	e89d 0006 	ldmia.w	sp, {r1, r2}
 8027a7c:	ee07 0a10 	vmov	s14, r0
 8027a80:	e76a      	b.n	8027958 <arm_cmplx_mag_f32+0x8c>
 8027a82:	ee17 0a90 	vmov	r0, s15
 8027a86:	e88d 0006 	stmia.w	sp, {r1, r2}
 8027a8a:	f003 fa5d 	bl	802af48 <sqrtf>
 8027a8e:	e89d 0006 	ldmia.w	sp, {r1, r2}
 8027a92:	ee07 0a10 	vmov	s14, r0
 8027a96:	e748      	b.n	802792a <arm_cmplx_mag_f32+0x5e>

08027a98 <CLOCK_XMC4_Init>:
{
  CLOCK_XMC4_STATUS_t status = CLOCK_XMC4_STATUS_SUCCESS;

  XMC_ASSERT("CLOCK_XMC4 APP handle function pointer uninitialized", (handle != NULL));

  handle->init_status = true;
 8027a98:	2301      	movs	r3, #1
 8027a9a:	7003      	strb	r3, [r0, #0]

  return (status);
}
 8027a9c:	2000      	movs	r0, #0
 8027a9e:	4770      	bx	lr

08027aa0 <OSCHP_GetFrequency>:
#ifdef CLOCK_XMC4_OSCHP_ENABLED
/*  API to retrieve high precision external oscillator frequency */
uint32_t OSCHP_GetFrequency(void)
{
  return (CLOCK_XMC4_OSCHP_FREQUENCY);
}
 8027aa0:	4800      	ldr	r0, [pc, #0]	; (8027aa4 <OSCHP_GetFrequency+0x4>)
 8027aa2:	4770      	bx	lr
 8027aa4:	00b71b00 	.word	0x00b71b00

08027aa8 <SystemCoreClockSetup>:
* @note   -
* @param  None
* @retval None
*/
void SystemCoreClockSetup(void)
{
 8027aa8:	b530      	push	{r4, r5, lr}
  /* Local data structure for initializing the clock functional block */
  const XMC_SCU_CLOCK_CONFIG_t CLOCK_XMC4_0_CONFIG =
 8027aaa:	4d11      	ldr	r5, [pc, #68]	; (8027af0 <SystemCoreClockSetup+0x48>)
 8027aac:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
* @note   -
* @param  None
* @retval None
*/
void SystemCoreClockSetup(void)
{
 8027aae:	b087      	sub	sp, #28
  /* Local data structure for initializing the clock functional block */
  const XMC_SCU_CLOCK_CONFIG_t CLOCK_XMC4_0_CONFIG =
 8027ab0:	ac01      	add	r4, sp, #4
 8027ab2:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8027ab4:	682b      	ldr	r3, [r5, #0]
 8027ab6:	6023      	str	r3, [r4, #0]
#endif
    /* Peripheral Clock Divider Value */
    .fperipheral_clkdiv = 1U
  };
  /* Initialize the SCU clock */
  XMC_SCU_CLOCK_Init(&CLOCK_XMC4_0_CONFIG);
 8027ab8:	a801      	add	r0, sp, #4
 8027aba:	f7f9 fc35 	bl	8021328 <XMC_SCU_CLOCK_Init>
  /* RTC source clock */
  XMC_SCU_HIB_SetRtcClockSource(XMC_SCU_HIB_RTCCLKSRC_OSI);
 8027abe:	2000      	movs	r0, #0
 8027ac0:	f7f9 faca 	bl	8021058 <XMC_SCU_HIB_SetRtcClockSource>
  
#ifdef CLOCK_XMC4_USBCLK_ENABLED  
  /* USB/SDMMC source clock */
  XMC_SCU_CLOCK_SetUsbClockSource(XMC_SCU_CLOCK_USBCLKSRC_USBPLL);
 8027ac4:	2000      	movs	r0, #0
 8027ac6:	f7f9 fab3 	bl	8021030 <XMC_SCU_CLOCK_SetUsbClockSource>
  /* USB/SDMMC divider setting */
  XMC_SCU_CLOCK_SetUsbClockDivider(4U);
 8027aca:	2004      	movs	r0, #4
 8027acc:	f7f9 fad4 	bl	8021078 <XMC_SCU_CLOCK_SetUsbClockDivider>
#endif
  /* Start USB PLL */
  XMC_SCU_CLOCK_StartUsbPll(1U, 32U);
 8027ad0:	2120      	movs	r1, #32
 8027ad2:	2001      	movs	r0, #1
 8027ad4:	f7f9 fb1c 	bl	8021110 <XMC_SCU_CLOCK_StartUsbPll>

#ifdef CLOCK_XMC4_WDTCLK_ENABLED    
  /* WDT source clock */
  XMC_SCU_CLOCK_SetWdtClockSource(XMC_SCU_CLOCK_WDTCLKSRC_PLL);
 8027ad8:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 8027adc:	f7f9 fab2 	bl	8021044 <XMC_SCU_CLOCK_SetWdtClockSource>
  /* WDT divider setting */
  XMC_SCU_CLOCK_SetWdtClockDivider(1U);
 8027ae0:	2001      	movs	r0, #1
 8027ae2:	f7f9 fadd 	bl	80210a0 <XMC_SCU_CLOCK_SetWdtClockDivider>
#endif

#ifdef CLOCK_XMC4_EBUCLK_ENABLED 
  /* EBU divider setting */
  XMC_SCU_CLOCK_SetEbuClockDivider(1U);
 8027ae6:	2001      	movs	r0, #1
 8027ae8:	f7f9 fad0 	bl	802108c <XMC_SCU_CLOCK_SetEbuClockDivider>
#endif

}
 8027aec:	b007      	add	sp, #28
 8027aee:	bd30      	pop	{r4, r5, pc}
 8027af0:	080316e8 	.word	0x080316e8

08027af4 <ADC_MEASUREMENT_ADV_Init>:
#ifdef ADC_MEASUREMENT_ADV_SHS_GAIN_NON_DEFAULT
  uint8_t channel_number;
#endif
  bool arbitration_status = (bool)false;

  if (ADC_MEASUREMENT_ADV_STATUS_UNINITIALIZED == *handle_ptr->init_state)
 8027af4:	6903      	ldr	r3, [r0, #16]
 8027af6:	781b      	ldrb	r3, [r3, #0]
 8027af8:	2b02      	cmp	r3, #2
 8027afa:	d001      	beq.n	8027b00 <ADC_MEASUREMENT_ADV_Init+0xc>
#endif

    *handle_ptr->init_state = status;
  }
  return (*handle_ptr->init_state);
}
 8027afc:	4618      	mov	r0, r3
 8027afe:	4770      	bx	lr
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Initialization routine to call ADC LLD API's */
ADC_MEASUREMENT_ADV_STATUS_t ADC_MEASUREMENT_ADV_Init(const ADC_MEASUREMENT_ADV_t *const handle_ptr)
{
 8027b00:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8027b04:	4605      	mov	r5, r0
  /* To check if the arbiter is already enabled. Before checking this ensure that clock and reset states are correct */
#if defined(CLOCK_GATING_SUPPORTED) && defined(ADC_MEASUREMENT_ADV_CHECK_CLOCK_GATING)
  clock_reset_check = !XMC_SCU_CLOCK_IsPeripheralClockGated(XMC_SCU_PERIPHERAL_CLOCK_VADC);
#endif
#ifdef PERIPHERAL_RESET_SUPPORTED
  clock_reset_check |= !XMC_SCU_RESET_IsPeripheralResetAsserted(XMC_SCU_PERIPHERAL_RESET_VADC);
 8027b06:	2001      	movs	r0, #1
 8027b08:	f7f9 fa76 	bl	8020ff8 <XMC_SCU_RESET_IsPeripheralResetAsserted>
#endif
  if(clock_reset_check != (bool)false)
 8027b0c:	2800      	cmp	r0, #0
 8027b0e:	f040 80c8 	bne.w	8027ca2 <ADC_MEASUREMENT_ADV_Init+0x1ae>
  {
#ifdef ADC_MEASUREMENT_ADV_SCAN_USED
  #ifdef ADC_MEASUREMENT_ADV_QUEUE_USED
    if ( ADC_MEASUREMENT_ADV_REQUEST_SOURCE_LOCAL_SCAN >= handle_ptr->req_src)
 8027b12:	7d2b      	ldrb	r3, [r5, #20]
  #endif
      {
        arbitration_status = XMC_VADC_GROUP_ScanIsArbitrationSlotEnabled(group_ptrs[handle_ptr->group_index]);
 8027b14:	4e94      	ldr	r6, [pc, #592]	; (8027d68 <ADC_MEASUREMENT_ADV_Init+0x274>)
#endif
  if(clock_reset_check != (bool)false)
  {
#ifdef ADC_MEASUREMENT_ADV_SCAN_USED
  #ifdef ADC_MEASUREMENT_ADV_QUEUE_USED
    if ( ADC_MEASUREMENT_ADV_REQUEST_SOURCE_LOCAL_SCAN >= handle_ptr->req_src)
 8027b16:	2b01      	cmp	r3, #1
  #endif
      {
        arbitration_status = XMC_VADC_GROUP_ScanIsArbitrationSlotEnabled(group_ptrs[handle_ptr->group_index]);
 8027b18:	7dab      	ldrb	r3, [r5, #22]
 8027b1a:	f856 4023 	ldr.w	r4, [r6, r3, lsl #2]
 */
__STATIC_INLINE bool XMC_VADC_GROUP_ScanIsArbitrationSlotEnabled(XMC_VADC_GROUP_t *const group_ptr)
{
  XMC_ASSERT("XMC_VADC_GROUP_ScanIsArbitrationSlotEnabled:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))

  return ((group_ptr->ARBPR & (uint32_t)VADC_G_ARBPR_ASEN1_Msk) >> VADC_G_ARBPR_ASEN1_Pos);
 8027b1e:	f8d4 3084 	ldr.w	r3, [r4, #132]	; 0x84
#endif
  if(clock_reset_check != (bool)false)
  {
#ifdef ADC_MEASUREMENT_ADV_SCAN_USED
  #ifdef ADC_MEASUREMENT_ADV_QUEUE_USED
    if ( ADC_MEASUREMENT_ADV_REQUEST_SOURCE_LOCAL_SCAN >= handle_ptr->req_src)
 8027b22:	f240 81fb 	bls.w	8027f1c <ADC_MEASUREMENT_ADV_Init+0x428>
 */
__STATIC_INLINE bool XMC_VADC_GROUP_QueueIsArbitrationSlotEnabled(XMC_VADC_GROUP_t *const group_ptr)
{
  XMC_ASSERT("XMC_VADC_GROUP_QueueIsArbitrationSlotEnabled:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))

  return ((group_ptr->ARBPR & (uint32_t)VADC_G_ARBPR_ASEN0_Msk) >> VADC_G_ARBPR_ASEN0_Pos);
 8027b26:	f3c3 6900 	ubfx	r9, r3, #24, #1
                                                           uint8_t group_index)
{
  ADC_MEASUREMENT_ADV_STATUS_t status;

  /*Initialization of APP 'GLOBAL_ADC'*/
  status = (ADC_MEASUREMENT_ADV_STATUS_t) GLOBAL_ADC_Init(ADC_MEASUREMENT_ADV_GLOBAL_HANDLE);
 8027b2a:	4890      	ldr	r0, [pc, #576]	; (8027d6c <ADC_MEASUREMENT_ADV_Init+0x278>)
#ifdef ADC_MEASUREMENT_ADV_LOCAL_QUEUE_USED
  #ifdef ADC_MEASUREMENT_ADV_ADC_QUEUE_USED
      if ( ADC_MEASUREMENT_ADV_REQUEST_SOURCE_QUEUE != handle_ptr->req_src)
  #endif
      {
        status = ADC_MEASUREMENT_ADV_lQueueInit(handle_ptr->local_queue_handle,handle_ptr->group_index);
 8027b2c:	68ef      	ldr	r7, [r5, #12]
                                                           uint8_t group_index)
{
  ADC_MEASUREMENT_ADV_STATUS_t status;

  /*Initialization of APP 'GLOBAL_ADC'*/
  status = (ADC_MEASUREMENT_ADV_STATUS_t) GLOBAL_ADC_Init(ADC_MEASUREMENT_ADV_GLOBAL_HANDLE);
 8027b2e:	f7fe fdb7 	bl	80266a0 <GLOBAL_ADC_Init>

  /*Class Configuration*/
  XMC_VADC_GROUP_InputClassInit(group_ptrs[group_index],handle_ptr->iclass_config_handle,
 8027b32:	7ebb      	ldrb	r3, [r7, #26]
 8027b34:	6939      	ldr	r1, [r7, #16]
 8027b36:	2200      	movs	r2, #0
                                                           uint8_t group_index)
{
  ADC_MEASUREMENT_ADV_STATUS_t status;

  /*Initialization of APP 'GLOBAL_ADC'*/
  status = (ADC_MEASUREMENT_ADV_STATUS_t) GLOBAL_ADC_Init(ADC_MEASUREMENT_ADV_GLOBAL_HANDLE);
 8027b38:	4680      	mov	r8, r0

  /*Class Configuration*/
  XMC_VADC_GROUP_InputClassInit(group_ptrs[group_index],handle_ptr->iclass_config_handle,
 8027b3a:	4620      	mov	r0, r4
 8027b3c:	f7fb fd08 	bl	8023550 <XMC_VADC_GROUP_InputClassInit>
                                XMC_VADC_GROUP_CONV_STD,handle_ptr->iclass_num);

  /* Initialize the Queue hardware */
  XMC_VADC_GROUP_QueueInit(group_ptrs[group_index],handle_ptr->queue_config_handle);
 8027b40:	4620      	mov	r0, r4
 8027b42:	6979      	ldr	r1, [r7, #20]
 8027b44:	f7fb fdc0 	bl	80236c8 <XMC_VADC_GROUP_QueueInit>
{
  XMC_ASSERT("XMC_VADC_GROUP_QueueSetGatingMode:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  XMC_ASSERT("XMC_VADC_GROUP_QueueSetGatingMode:Wrong mode selected", (mode_sel <= XMC_VADC_GATEMODE_ACTIVELOW))

  /* Clear the existing gate configuration */
  group_ptr->QMR0 &= (uint32_t)(~((uint32_t) VADC_G_QMR0_ENGT_Msk));
 8027b48:	f8d4 2104 	ldr.w	r2, [r4, #260]	; 0x104

  /* Configure the gating mode for queue*/
  XMC_VADC_GROUP_QueueSetGatingMode(group_ptrs[group_index], handle_ptr->gating_mode);
 8027b4c:	7e38      	ldrb	r0, [r7, #24]

  /*Interrupt Configuration*/
  if ((bool)true == handle_ptr->rs_intr_handle.interrupt_enable)
 8027b4e:	7b39      	ldrb	r1, [r7, #12]
 8027b50:	f022 0203 	bic.w	r2, r2, #3
 8027b54:	f8c4 2104 	str.w	r2, [r4, #260]	; 0x104
  /* Set the new gating mode */
  group_ptr->QMR0 |= (uint32_t)((uint32_t)mode_sel << VADC_G_QMR0_ENGT_Pos);
 8027b58:	f8d4 3104 	ldr.w	r3, [r4, #260]	; 0x104
 8027b5c:	4303      	orrs	r3, r0
 8027b5e:	f8c4 3104 	str.w	r3, [r4, #260]	; 0x104
 8027b62:	b389      	cbz	r1, 8027bc8 <ADC_MEASUREMENT_ADV_Init+0xd4>
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8027b64:	4b82      	ldr	r3, [pc, #520]	; (8027d70 <ADC_MEASUREMENT_ADV_Init+0x27c>)
  {
#if (UC_FAMILY == XMC1)
    NVIC_SetPriority((IRQn_Type)handle_ptr->rs_intr_handle.node_id, handle_ptr->rs_intr_handle.priority);
#else
    NVIC_SetPriority((IRQn_Type)handle_ptr->rs_intr_handle.node_id,
 8027b66:	f8d7 e000 	ldr.w	lr, [r7]
 8027b6a:	68db      	ldr	r3, [r3, #12]
 8027b6c:	6878      	ldr	r0, [r7, #4]
 8027b6e:	f8d7 c008 	ldr.w	ip, [r7, #8]
 8027b72:	f3c3 2302 	ubfx	r3, r3, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8027b76:	f1c3 0a07 	rsb	sl, r3, #7
 8027b7a:	f1ba 0f06 	cmp.w	sl, #6
 8027b7e:	bf28      	it	cs
 8027b80:	f04f 0a06 	movcs.w	sl, #6
 8027b84:	fa5f f18e 	uxtb.w	r1, lr
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8027b88:	2b00      	cmp	r3, #0
 8027b8a:	f040 818d 	bne.w	8027ea8 <ADC_MEASUREMENT_ADV_Init+0x3b4>
 8027b8e:	461a      	mov	r2, r3

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8027b90:	f04f 0c01 	mov.w	ip, #1
 8027b94:	fa0c fc0a 	lsl.w	ip, ip, sl
 8027b98:	f10c 3cff 	add.w	ip, ip, #4294967295
 8027b9c:	ea0c 0000 	and.w	r0, ip, r0
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
 8027ba0:	b249      	sxtb	r1, r1

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8027ba2:	fa00 f202 	lsl.w	r2, r0, r2
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
 8027ba6:	2900      	cmp	r1, #0
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
 8027ba8:	ea43 0302 	orr.w	r3, r3, r2
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
 8027bac:	f2c0 81ae 	blt.w	8027f0c <ADC_MEASUREMENT_ADV_Init+0x418>
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8027bb0:	f101 4260 	add.w	r2, r1, #3758096384	; 0xe0000000
 8027bb4:	f502 4261 	add.w	r2, r2, #57600	; 0xe100
 8027bb8:	009b      	lsls	r3, r3, #2
 8027bba:	b2db      	uxtb	r3, r3
 8027bbc:	f882 3300 	strb.w	r3, [r2, #768]	; 0x300
    XMC_SCU_SetInterruptControl(handle_ptr->rs_intr_handle.node_id,
                                ((handle_ptr->rs_intr_handle.node_id << 8) | handle_ptr->rs_intr_handle.irqctrl));
#endif

    /* Connect RS Events to NVIC nodes */
    XMC_VADC_GROUP_QueueSetReqSrcEventInterruptNode(group_ptrs[group_index], (XMC_VADC_SR_t)handle_ptr->srv_req_node);
 8027bc0:	4620      	mov	r0, r4
 8027bc2:	7e79      	ldrb	r1, [r7, #25]
 8027bc4:	f7fb fdc4 	bl	8023750 <XMC_VADC_GROUP_QueueSetReqSrcEventInterruptNode>

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
__STATIC_INLINE void ADC_MEASUREMENT_ADV_lDisableArbitration(const ADC_MEASUREMENT_ADV_t *const handle_ptr,
                                                             bool arbitration_status)
{
  if(arbitration_status == (bool)false)
 8027bc8:	f1b9 0f00 	cmp.w	r9, #0
 8027bcc:	d10d      	bne.n	8027bea <ADC_MEASUREMENT_ADV_Init+0xf6>
  {
#ifdef ADC_MEASUREMENT_ADV_SCAN_USED
  #ifdef ADC_MEASUREMENT_ADV_QUEUE_USED
      if ( ADC_MEASUREMENT_ADV_REQUEST_SOURCE_LOCAL_SCAN >= handle_ptr->req_src)
 8027bce:	7d2b      	ldrb	r3, [r5, #20]
 8027bd0:	2b01      	cmp	r3, #1
  #endif
      {
        XMC_VADC_GROUP_ScanDisableArbitrationSlot(group_ptrs[handle_ptr->group_index]);
 8027bd2:	7dab      	ldrb	r3, [r5, #22]
 8027bd4:	f856 2023 	ldr.w	r2, [r6, r3, lsl #2]
 *  XMC_VADC_GROUP_ScanEnableArbitrationSlot()<BR>
 */
__STATIC_INLINE void XMC_VADC_GROUP_ScanDisableArbitrationSlot(XMC_VADC_GROUP_t *const group_ptr)
{
  XMC_ASSERT("XMC_VADC_GROUP_ScanDisableArbitrationSlot:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  group_ptr->ARBPR &= ~((uint32_t)VADC_G_ARBPR_ASEN1_Msk);
 8027bd8:	f8d2 3084 	ldr.w	r3, [r2, #132]	; 0x84
 8027bdc:	bf94      	ite	ls
 8027bde:	f023 7300 	bicls.w	r3, r3, #33554432	; 0x2000000
 *  XMC_VADC_GROUP_QueueEnableArbitrationSlot()<BR>
 */
__STATIC_INLINE void XMC_VADC_GROUP_QueueDisableArbitrationSlot(XMC_VADC_GROUP_t *const group_ptr)
{
  XMC_ASSERT("XMC_VADC_GROUP_QueueDisableArbitrationSlot:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr));
  group_ptr->ARBPR &= ~((uint32_t)VADC_G_ARBPR_ASEN0_Msk);
 8027be2:	f023 7380 	bichi.w	r3, r3, #16777216	; 0x1000000
 8027be6:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
   /* Disable the Arbitration if no other instance has enabled it*/
   ADC_MEASUREMENT_ADV_lDisableArbitration(handle_ptr,arbitration_status);

#ifdef ADC_MEASUREMENT_ADV_SYNC_USED
  #ifdef ADC_MEASUREMENT_ADV_SYNC_NOT_ALL_USED
    if ((uint32_t)0 != handle_ptr->sync_slaves)
 8027bea:	7d6b      	ldrb	r3, [r5, #21]
 8027bec:	2b00      	cmp	r3, #0
 8027bee:	f040 80c1 	bne.w	8027d74 <ADC_MEASUREMENT_ADV_Init+0x280>
#endif

    /* Initialize the SR lines for the Channel event and the Result event, if required*/
#ifdef ADC_MEASUREMENT_ADV_MUX_USED
  #ifdef ADC_MEASUREMENT_ADV_MUX_NOT_ALL_USED
    if (handle_ptr->event_config != NULL)
 8027bf2:	68ab      	ldr	r3, [r5, #8]
 8027bf4:	b103      	cbz	r3, 8027bf8 <ADC_MEASUREMENT_ADV_Init+0x104>
  #endif
    {
      (handle_ptr->event_config)();
 8027bf6:	4798      	blx	r3
    }
#endif

    total_number_of_channels = (uint8_t)handle_ptr->total_number_of_channels;
 8027bf8:	7e2b      	ldrb	r3, [r5, #24]
    for (ch_num = (uint8_t)0; ch_num < (uint8_t)total_number_of_channels; ch_num++)
 8027bfa:	b1fb      	cbz	r3, 8027c3c <ADC_MEASUREMENT_ADV_Init+0x148>
 8027bfc:	1e5f      	subs	r7, r3, #1
 8027bfe:	b2ff      	uxtb	r7, r7
 8027c00:	3701      	adds	r7, #1
 8027c02:	00bf      	lsls	r7, r7, #2
 8027c04:	f04f 0900 	mov.w	r9, #0
    {
      indexed = handle_ptr->channel_array[ch_num];
 8027c08:	682b      	ldr	r3, [r5, #0]
 8027c0a:	f853 4009 	ldr.w	r4, [r3, r9]

      /* Initialize for configured channels*/
      XMC_VADC_GROUP_ChannelInit(group_ptrs[indexed->group_index],(uint32_t)indexed->ch_num, indexed->ch_handle);
 8027c0e:	7a23      	ldrb	r3, [r4, #8]
 8027c10:	7a61      	ldrb	r1, [r4, #9]
 8027c12:	f856 0023 	ldr.w	r0, [r6, r3, lsl #2]
 8027c16:	6822      	ldr	r2, [r4, #0]
 8027c18:	f7fb fda2 	bl	8023760 <XMC_VADC_GROUP_ChannelInit>
      XMC_VADC_GROUP_ResultInit(group_ptrs[indexed->group_index], (uint32_t)indexed->result_fifo_tail_number,
                                indexed->res_handle[ADC_MEASUREMENT_ADV_TAIL_RESULT_REG_CONFIG]);
  }
#endif
      /* Initialize for configured result registers For FIFO Head configuration*/
      XMC_VADC_GROUP_ResultInit(group_ptrs[indexed->group_index], (uint32_t)indexed->ch_handle->result_reg_number,
 8027c1c:	6823      	ldr	r3, [r4, #0]
 8027c1e:	7a22      	ldrb	r2, [r4, #8]
 8027c20:	789b      	ldrb	r3, [r3, #2]
__STATIC_INLINE void XMC_VADC_GROUP_ResultInit(XMC_VADC_GROUP_t *const group_ptr,
                                               const uint32_t res_reg_num,
                                               const XMC_VADC_RESULT_CONFIG_t *config)
{
  XMC_ASSERT("XMC_VADC_GROUP_ResultInit:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  group_ptr->RCR[res_reg_num] = config->g_rcr;
 8027c22:	6861      	ldr	r1, [r4, #4]
 8027c24:	f856 2022 	ldr.w	r2, [r6, r2, lsl #2]
 8027c28:	6809      	ldr	r1, [r1, #0]
 8027c2a:	f003 030f 	and.w	r3, r3, #15
 8027c2e:	33a0      	adds	r3, #160	; 0xa0
 8027c30:	f109 0904 	add.w	r9, r9, #4
      (handle_ptr->event_config)();
    }
#endif

    total_number_of_channels = (uint8_t)handle_ptr->total_number_of_channels;
    for (ch_num = (uint8_t)0; ch_num < (uint8_t)total_number_of_channels; ch_num++)
 8027c34:	45b9      	cmp	r9, r7
 8027c36:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
 8027c3a:	d1e5      	bne.n	8027c08 <ADC_MEASUREMENT_ADV_Init+0x114>
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Enables the NVIC(if needed) when scan/queue request source is consumed internally in the APP. */
void ADC_MEASUREMENT_ADC_lNvicEnable(const ADC_MEASUREMENT_ADV_t *const handle_ptr)
{
#ifdef ADC_MEASUREMENT_ADV_LOCAL_SCAN_USED
    if (((bool)true == handle_ptr->local_scan_handle->rs_intr_handle.interrupt_enable) &&
 8027c3c:	68ea      	ldr	r2, [r5, #12]
 8027c3e:	7b13      	ldrb	r3, [r2, #12]
 8027c40:	b36b      	cbz	r3, 8027c9e <ADC_MEASUREMENT_ADV_Init+0x1aa>
        (ADC_MEASUREMENT_ADV_REQUEST_SOURCE_LOCAL_SCAN == handle_ptr->req_src))
 8027c42:	7d2b      	ldrb	r3, [r5, #20]
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Enables the NVIC(if needed) when scan/queue request source is consumed internally in the APP. */
void ADC_MEASUREMENT_ADC_lNvicEnable(const ADC_MEASUREMENT_ADV_t *const handle_ptr)
{
#ifdef ADC_MEASUREMENT_ADV_LOCAL_SCAN_USED
    if (((bool)true == handle_ptr->local_scan_handle->rs_intr_handle.interrupt_enable) &&
 8027c44:	2b01      	cmp	r3, #1
 8027c46:	f000 8145 	beq.w	8027ed4 <ADC_MEASUREMENT_ADV_Init+0x3e0>
    {
      NVIC_EnableIRQ((IRQn_Type)handle_ptr->local_scan_handle->rs_intr_handle.node_id);
    }
#endif
#ifdef ADC_MEASUREMENT_ADV_LOCAL_QUEUE_USED
    if (((bool)true == handle_ptr->local_queue_handle->rs_intr_handle.interrupt_enable) &&
 8027c4a:	2b03      	cmp	r3, #3
 8027c4c:	f000 8133 	beq.w	8027eb6 <ADC_MEASUREMENT_ADV_Init+0x3c2>
{
  XMC_ASSERT("ADC_MEASUREMENT_ADV_InsertChannels:Invalid handle_ptr", (handle_ptr != NULL))

#ifdef ADC_MEASUREMENT_ADV_SCAN_USED
  #ifdef ADC_MEASUREMENT_ADV_QUEUE_USED
    if ( ADC_MEASUREMENT_ADV_REQUEST_SOURCE_LOCAL_SCAN >= handle_ptr->req_src)
 8027c50:	2b01      	cmp	r3, #1
 8027c52:	f240 814b 	bls.w	8027eec <ADC_MEASUREMENT_ADV_Init+0x3f8>
/* Local function to insert the queue entries into the hardware.*/
__STATIC_INLINE void ADC_MEASUREMENT_ADV_lQueueInsertEntries(const ADC_MEASUREMENT_ADV_t *const handle_ptr)
{
  uint32_t entry_index;

  XMC_VADC_GROUP_t *queue_group_ptr = group_ptrs[handle_ptr->group_index];
 8027c56:	7daa      	ldrb	r2, [r5, #22]
  const XMC_VADC_QUEUE_ENTRY_t **const entries_array = handle_ptr->local_queue_entries;

  for(entry_index = 0; entry_index < handle_ptr->total_number_of_entries; entry_index++)
 8027c58:	7deb      	ldrb	r3, [r5, #23]
/* Local function to insert the queue entries into the hardware.*/
__STATIC_INLINE void ADC_MEASUREMENT_ADV_lQueueInsertEntries(const ADC_MEASUREMENT_ADV_t *const handle_ptr)
{
  uint32_t entry_index;

  XMC_VADC_GROUP_t *queue_group_ptr = group_ptrs[handle_ptr->group_index];
 8027c5a:	f856 0022 	ldr.w	r0, [r6, r2, lsl #2]
  const XMC_VADC_QUEUE_ENTRY_t **const entries_array = handle_ptr->local_queue_entries;
 8027c5e:	686a      	ldr	r2, [r5, #4]

  for(entry_index = 0; entry_index < handle_ptr->total_number_of_entries; entry_index++)
 8027c60:	b18b      	cbz	r3, 8027c86 <ADC_MEASUREMENT_ADV_Init+0x192>
 8027c62:	3a04      	subs	r2, #4
 8027c64:	2300      	movs	r3, #0
 8027c66:	f852 1f04 	ldr.w	r1, [r2, #4]!
 8027c6a:	6809      	ldr	r1, [r1, #0]
__STATIC_INLINE void XMC_VADC_GROUP_QueueInsertChannel(XMC_VADC_GROUP_t *const group_ptr,
                                                       const XMC_VADC_QUEUE_ENTRY_t entry)
{
  XMC_ASSERT("XMC_VADC_GROUP_QueueInsertChannel:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  /* Insert the channel physically and get the length of the queue*/
  group_ptr->QINR0 = entry.qinr0;
 8027c6c:	f8c0 1110 	str.w	r1, [r0, #272]	; 0x110
 8027c70:	7de9      	ldrb	r1, [r5, #23]
 8027c72:	3301      	adds	r3, #1
 8027c74:	428b      	cmp	r3, r1
 8027c76:	d3f6      	bcc.n	8027c66 <ADC_MEASUREMENT_ADV_Init+0x172>
/* Enables the arbiter of the selected request source*/
void ADC_MEASUREMENT_ADV_StartADC(const ADC_MEASUREMENT_ADV_t *const handle_ptr)
{
#ifdef ADC_MEASUREMENT_ADV_SCAN_USED
  #ifdef ADC_MEASUREMENT_ADV_QUEUE_USED
    if ( ADC_MEASUREMENT_ADV_REQUEST_SOURCE_LOCAL_SCAN >= handle_ptr->req_src)
 8027c78:	7d2b      	ldrb	r3, [r5, #20]
 8027c7a:	2b01      	cmp	r3, #1
 8027c7c:	f240 813c 	bls.w	8027ef8 <ADC_MEASUREMENT_ADV_Init+0x404>
 8027c80:	7dab      	ldrb	r3, [r5, #22]
 8027c82:	f856 0023 	ldr.w	r0, [r6, r3, lsl #2]
 *  XMC_VADC_GROUP_QueueDisableArbitrationSlot()<BR>
 */
__STATIC_INLINE void XMC_VADC_GROUP_QueueEnableArbitrationSlot(XMC_VADC_GROUP_t *const group_ptr)
{
  XMC_ASSERT("XMC_VADC_GROUP_QueueEnableArbitrationSlot:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr));
  group_ptr->ARBPR |= (uint32_t)((uint32_t)1 << VADC_G_ARBPR_ASEN0_Pos);
 8027c86:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
 8027c8a:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8027c8e:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
    {
      ADC_MEASUREMENT_ADV_StartADC(handle_ptr);
    }
#endif

    *handle_ptr->init_state = status;
 8027c92:	692a      	ldr	r2, [r5, #16]
  }
  return (*handle_ptr->init_state);
}
 8027c94:	4640      	mov	r0, r8
    {
      ADC_MEASUREMENT_ADV_StartADC(handle_ptr);
    }
#endif

    *handle_ptr->init_state = status;
 8027c96:	f882 8000 	strb.w	r8, [r2]
  }
  return (*handle_ptr->init_state);
}
 8027c9a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8027c9e:	7d2b      	ldrb	r3, [r5, #20]
 8027ca0:	e7d6      	b.n	8027c50 <ADC_MEASUREMENT_ADV_Init+0x15c>
{
  ADC_MEASUREMENT_ADV_STATUS_t status;

#ifdef ADC_MEASUREMENT_ADV_SCAN_USED
  #ifdef ADC_MEASUREMENT_ADV_QUEUE_USED
    if ( ADC_MEASUREMENT_ADV_REQUEST_SOURCE_LOCAL_SCAN >= handle_ptr->req_src)
 8027ca2:	7d2b      	ldrb	r3, [r5, #20]
 8027ca4:	4e30      	ldr	r6, [pc, #192]	; (8027d68 <ADC_MEASUREMENT_ADV_Init+0x274>)
 8027ca6:	7daa      	ldrb	r2, [r5, #22]
 8027ca8:	2b01      	cmp	r3, #1
 8027caa:	f856 4022 	ldr.w	r4, [r6, r2, lsl #2]
  bool arbitration_status;

#if !defined(CLOCK_GATING_SUPPORTED) || !defined(ADC_MEASUREMENT_ADV_CHECK_CLOCK_GATING)
  clock_reset_check = (bool)false;
#endif
  arbitration_status = (bool)false;
 8027cae:	f04f 0900 	mov.w	r9, #0
{
  ADC_MEASUREMENT_ADV_STATUS_t status;

#ifdef ADC_MEASUREMENT_ADV_SCAN_USED
  #ifdef ADC_MEASUREMENT_ADV_QUEUE_USED
    if ( ADC_MEASUREMENT_ADV_REQUEST_SOURCE_LOCAL_SCAN >= handle_ptr->req_src)
 8027cb2:	f63f af3a 	bhi.w	8027b2a <ADC_MEASUREMENT_ADV_Init+0x36>
                                                           uint8_t group_index)
{
  ADC_MEASUREMENT_ADV_STATUS_t status;

  /*Initialization of APP 'ADCGroup'*/
  status = (ADC_MEASUREMENT_ADV_STATUS_t) GLOBAL_ADC_Init(ADC_MEASUREMENT_ADV_GLOBAL_HANDLE);
 8027cb6:	482d      	ldr	r0, [pc, #180]	; (8027d6c <ADC_MEASUREMENT_ADV_Init+0x278>)
#ifdef ADC_MEASUREMENT_ADV_LOCAL_SCAN_USED
  #ifdef ADC_MEASUREMENT_ADV_ADC_SCAN_USED
      if ( ADC_MEASUREMENT_ADV_REQUEST_SOURCE_SCAN != handle_ptr->req_src)
  #endif
      {
        status = ADC_MEASUREMENT_ADV_lScanInit(handle_ptr->local_scan_handle,handle_ptr->group_index);
 8027cb8:	68ef      	ldr	r7, [r5, #12]
                                                           uint8_t group_index)
{
  ADC_MEASUREMENT_ADV_STATUS_t status;

  /*Initialization of APP 'ADCGroup'*/
  status = (ADC_MEASUREMENT_ADV_STATUS_t) GLOBAL_ADC_Init(ADC_MEASUREMENT_ADV_GLOBAL_HANDLE);
 8027cba:	f7fe fcf1 	bl	80266a0 <GLOBAL_ADC_Init>

  XMC_VADC_GROUP_InputClassInit(group_ptrs[group_index], handle_ptr->iclass_config_handle,
 8027cbe:	f897 3020 	ldrb.w	r3, [r7, #32]
 8027cc2:	6939      	ldr	r1, [r7, #16]
 8027cc4:	2200      	movs	r2, #0
                                                           uint8_t group_index)
{
  ADC_MEASUREMENT_ADV_STATUS_t status;

  /*Initialization of APP 'ADCGroup'*/
  status = (ADC_MEASUREMENT_ADV_STATUS_t) GLOBAL_ADC_Init(ADC_MEASUREMENT_ADV_GLOBAL_HANDLE);
 8027cc6:	4680      	mov	r8, r0

  XMC_VADC_GROUP_InputClassInit(group_ptrs[group_index], handle_ptr->iclass_config_handle,
 8027cc8:	4620      	mov	r0, r4
 8027cca:	f7fb fc41 	bl	8023550 <XMC_VADC_GROUP_InputClassInit>
                                XMC_VADC_GROUP_CONV_STD, (uint32_t)handle_ptr->iclass_num);


  /*Initialization of scan request source*/
  XMC_VADC_GROUP_ScanInit(group_ptrs[group_index], handle_ptr->scan_config_handle);
 8027cce:	4620      	mov	r0, r4
 8027cd0:	6979      	ldr	r1, [r7, #20]
 8027cd2:	f7fb fcab 	bl	802362c <XMC_VADC_GROUP_ScanInit>
{
  XMC_ASSERT("XMC_VADC_GROUP_ScanSetGatingMode:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  XMC_ASSERT("XMC_VADC_GROUP_ScanSetGatingMode:Wrong mode selected", (mode_sel <= XMC_VADC_GATEMODE_ACTIVELOW))

  /* Clear the existing gate configuration */
  group_ptr->ASMR &= (uint32_t) (~((uint32_t)VADC_G_ASMR_ENGT_Msk));
 8027cd6:	f8d4 2124 	ldr.w	r2, [r4, #292]	; 0x124

  /* Configure the gating mode for Scan*/
  XMC_VADC_GROUP_ScanSetGatingMode(group_ptrs[group_index], handle_ptr->gating_mode);
 8027cda:	7e38      	ldrb	r0, [r7, #24]

  /*Interrupt Configuration*/
  if ((bool)true == handle_ptr->rs_intr_handle.interrupt_enable)
 8027cdc:	7b39      	ldrb	r1, [r7, #12]
 8027cde:	f022 0203 	bic.w	r2, r2, #3
 8027ce2:	f8c4 2124 	str.w	r2, [r4, #292]	; 0x124
  /* Set the new gating mode */
  group_ptr->ASMR |= (uint32_t)((uint32_t)mode_sel << VADC_G_ASMR_ENGT_Pos);
 8027ce6:	f8d4 3124 	ldr.w	r3, [r4, #292]	; 0x124
 8027cea:	4303      	orrs	r3, r0
 8027cec:	f8c4 3124 	str.w	r3, [r4, #292]	; 0x124
 8027cf0:	2900      	cmp	r1, #0
 8027cf2:	f43f af69 	beq.w	8027bc8 <ADC_MEASUREMENT_ADV_Init+0xd4>
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8027cf6:	4b1e      	ldr	r3, [pc, #120]	; (8027d70 <ADC_MEASUREMENT_ADV_Init+0x27c>)
  {
#if (UC_FAMILY == XMC1)
    NVIC_SetPriority((IRQn_Type)handle_ptr->rs_intr_handle.node_id, handle_ptr->rs_intr_handle.priority);
#else
    NVIC_SetPriority((IRQn_Type)handle_ptr->rs_intr_handle.node_id,
 8027cf8:	f8d7 e000 	ldr.w	lr, [r7]
 8027cfc:	68db      	ldr	r3, [r3, #12]
 8027cfe:	6878      	ldr	r0, [r7, #4]
 8027d00:	f8d7 c008 	ldr.w	ip, [r7, #8]
 8027d04:	f3c3 2302 	ubfx	r3, r3, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8027d08:	f1c3 0a07 	rsb	sl, r3, #7
 8027d0c:	f1ba 0f06 	cmp.w	sl, #6
 8027d10:	bf28      	it	cs
 8027d12:	f04f 0a06 	movcs.w	sl, #6
 8027d16:	fa5f f18e 	uxtb.w	r1, lr
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8027d1a:	2b00      	cmp	r3, #0
 8027d1c:	f000 8101 	beq.w	8027f22 <ADC_MEASUREMENT_ADV_Init+0x42e>
 8027d20:	1e5a      	subs	r2, r3, #1
 8027d22:	2301      	movs	r3, #1
 8027d24:	4093      	lsls	r3, r2
 8027d26:	3b01      	subs	r3, #1
 8027d28:	ea03 030c 	and.w	r3, r3, ip

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8027d2c:	f04f 0c01 	mov.w	ip, #1
 8027d30:	fa0c fc0a 	lsl.w	ip, ip, sl
 8027d34:	f10c 3cff 	add.w	ip, ip, #4294967295
 8027d38:	ea0c 0000 	and.w	r0, ip, r0
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
 8027d3c:	b249      	sxtb	r1, r1

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8027d3e:	fa00 f202 	lsl.w	r2, r0, r2
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
 8027d42:	2900      	cmp	r1, #0
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
 8027d44:	ea43 0302 	orr.w	r3, r3, r2
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
 8027d48:	f2c0 811c 	blt.w	8027f84 <ADC_MEASUREMENT_ADV_Init+0x490>
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8027d4c:	f101 4260 	add.w	r2, r1, #3758096384	; 0xe0000000
 8027d50:	f502 4261 	add.w	r2, r2, #57600	; 0xe100
 8027d54:	009b      	lsls	r3, r3, #2
 8027d56:	b2db      	uxtb	r3, r3
 8027d58:	f882 3300 	strb.w	r3, [r2, #768]	; 0x300
    XMC_SCU_SetInterruptControl(handle_ptr->rs_intr_handle.node_id,
                                ((handle_ptr->rs_intr_handle.node_id << 8) | handle_ptr->rs_intr_handle.irqctrl));
#endif

    /* Connect RS Events to NVIC nodes */
    XMC_VADC_GROUP_ScanSetReqSrcEventInterruptNode(group_ptrs[group_index], handle_ptr->srv_req_node);
 8027d5c:	4620      	mov	r0, r4
 8027d5e:	7e79      	ldrb	r1, [r7, #25]
 8027d60:	f7fb fca8 	bl	80236b4 <XMC_VADC_GROUP_ScanSetReqSrcEventInterruptNode>
 8027d64:	e730      	b.n	8027bc8 <ADC_MEASUREMENT_ADV_Init+0xd4>
 8027d66:	bf00      	nop
 8027d68:	080316fc 	.word	0x080316fc
 8027d6c:	1ffe9354 	.word	0x1ffe9354
 8027d70:	e000ed00 	.word	0xe000ed00
__STATIC_INLINE void ADC_MEASUREMENT_ADV_lSyncInit(const ADC_MEASUREMENT_ADV_t *const handle_ptr)
{
  uint8_t sync_group;

  /* shift to get the 4 bit position needed to or it with the slave groups */
  sync_group = handle_ptr->sync_slaves | ( 1 << handle_ptr->group_index);
 8027d74:	7daa      	ldrb	r2, [r5, #22]
 8027d76:	2701      	movs	r7, #1
 8027d78:	4097      	lsls	r7, r2
 8027d7a:	433b      	orrs	r3, r7
  ADC_MEASUREMENT_ADV_lSyncSequencer(handle_ptr, sync_group, ADC_MEASUREMENT_ADV_SYNC_SEQ_POWER_DOWN);
 8027d7c:	b2df      	uxtb	r7, r3
 8027d7e:	2403      	movs	r4, #3
                                        ADC_MEASUREMENT_ADV_SYNC_SEQ_t sequence)
{
  int8_t group_index;
  for( group_index = XMC_VADC_MAXIMUM_NUM_GROUPS - (int32_t)1; group_index >= (int32_t)0  ; group_index--)
  {
    if ( (bool)false != (bool)((sync_group >> group_index) & 0x1 ))
 8027d80:	fa27 f304 	lsr.w	r3, r7, r4
 8027d84:	f013 0f01 	tst.w	r3, #1
    {
      switch( sequence)
      {
        case ADC_MEASUREMENT_ADV_SYNC_SEQ_POWER_DOWN:
             XMC_VADC_GROUP_SetPowerMode(group_ptrs[group_index],XMC_VADC_GROUP_POWERMODE_OFF);
 8027d88:	f04f 0100 	mov.w	r1, #0
                                        ADC_MEASUREMENT_ADV_SYNC_SEQ_t sequence)
{
  int8_t group_index;
  for( group_index = XMC_VADC_MAXIMUM_NUM_GROUPS - (int32_t)1; group_index >= (int32_t)0  ; group_index--)
  {
    if ( (bool)false != (bool)((sync_group >> group_index) & 0x1 ))
 8027d8c:	d003      	beq.n	8027d96 <ADC_MEASUREMENT_ADV_Init+0x2a2>
    {
      switch( sequence)
      {
        case ADC_MEASUREMENT_ADV_SYNC_SEQ_POWER_DOWN:
             XMC_VADC_GROUP_SetPowerMode(group_ptrs[group_index],XMC_VADC_GROUP_POWERMODE_OFF);
 8027d8e:	f856 0024 	ldr.w	r0, [r6, r4, lsl #2]
 8027d92:	f7fb fc03 	bl	802359c <XMC_VADC_GROUP_SetPowerMode>
void ADC_MEASUREMENT_ADV_lSyncSequencer(const ADC_MEASUREMENT_ADV_t *const handle_ptr,
                                        uint32_t sync_group,
                                        ADC_MEASUREMENT_ADV_SYNC_SEQ_t sequence)
{
  int8_t group_index;
  for( group_index = XMC_VADC_MAXIMUM_NUM_GROUPS - (int32_t)1; group_index >= (int32_t)0  ; group_index--)
 8027d96:	f114 34ff 	adds.w	r4, r4, #4294967295
 8027d9a:	d2f1      	bcs.n	8027d80 <ADC_MEASUREMENT_ADV_Init+0x28c>

  /* shift to get the 4 bit position needed to or it with the slave groups */
  sync_group = handle_ptr->sync_slaves | ( 1 << handle_ptr->group_index);
  ADC_MEASUREMENT_ADV_lSyncSequencer(handle_ptr, sync_group, ADC_MEASUREMENT_ADV_SYNC_SEQ_POWER_DOWN);

  sync_group = handle_ptr->sync_slaves;
 8027d9c:	7d6f      	ldrb	r7, [r5, #21]
  ADC_MEASUREMENT_ADV_lSyncSequencer(handle_ptr, sync_group, ADC_MEASUREMENT_ADV_SYNC_SEQ_STSEL_CONFIG);
 8027d9e:	2403      	movs	r4, #3
                                        ADC_MEASUREMENT_ADV_SYNC_SEQ_t sequence)
{
  int8_t group_index;
  for( group_index = XMC_VADC_MAXIMUM_NUM_GROUPS - (int32_t)1; group_index >= (int32_t)0  ; group_index--)
  {
    if ( (bool)false != (bool)((sync_group >> group_index) & 0x1 ))
 8027da0:	fa27 f304 	lsr.w	r3, r7, r4
 8027da4:	07d8      	lsls	r0, r3, #31
      {
        case ADC_MEASUREMENT_ADV_SYNC_SEQ_POWER_DOWN:
             XMC_VADC_GROUP_SetPowerMode(group_ptrs[group_index],XMC_VADC_GROUP_POWERMODE_OFF);
             break;
        case ADC_MEASUREMENT_ADV_SYNC_SEQ_STSEL_CONFIG:
             XMC_VADC_GROUP_SetSyncSlave(group_ptrs[group_index], handle_ptr->group_index, group_index);
 8027da6:	4622      	mov	r2, r4
                                        ADC_MEASUREMENT_ADV_SYNC_SEQ_t sequence)
{
  int8_t group_index;
  for( group_index = XMC_VADC_MAXIMUM_NUM_GROUPS - (int32_t)1; group_index >= (int32_t)0  ; group_index--)
  {
    if ( (bool)false != (bool)((sync_group >> group_index) & 0x1 ))
 8027da8:	d50a      	bpl.n	8027dc0 <ADC_MEASUREMENT_ADV_Init+0x2cc>
      {
        case ADC_MEASUREMENT_ADV_SYNC_SEQ_POWER_DOWN:
             XMC_VADC_GROUP_SetPowerMode(group_ptrs[group_index],XMC_VADC_GROUP_POWERMODE_OFF);
             break;
        case ADC_MEASUREMENT_ADV_SYNC_SEQ_STSEL_CONFIG:
             XMC_VADC_GROUP_SetSyncSlave(group_ptrs[group_index], handle_ptr->group_index, group_index);
 8027daa:	f856 0024 	ldr.w	r0, [r6, r4, lsl #2]
 8027dae:	7da9      	ldrb	r1, [r5, #22]
 8027db0:	f7fb fbfc 	bl	80235ac <XMC_VADC_GROUP_SetSyncSlave>
             XMC_VADC_GROUP_CheckSlaveReadiness(group_ptrs[handle_ptr->group_index],group_index);
 8027db4:	7dab      	ldrb	r3, [r5, #22]
 8027db6:	4621      	mov	r1, r4
 8027db8:	f856 0023 	ldr.w	r0, [r6, r3, lsl #2]
 8027dbc:	f7fb fc0a 	bl	80235d4 <XMC_VADC_GROUP_CheckSlaveReadiness>
void ADC_MEASUREMENT_ADV_lSyncSequencer(const ADC_MEASUREMENT_ADV_t *const handle_ptr,
                                        uint32_t sync_group,
                                        ADC_MEASUREMENT_ADV_SYNC_SEQ_t sequence)
{
  int8_t group_index;
  for( group_index = XMC_VADC_MAXIMUM_NUM_GROUPS - (int32_t)1; group_index >= (int32_t)0  ; group_index--)
 8027dc0:	f114 34ff 	adds.w	r4, r4, #4294967295
 8027dc4:	d2ec      	bcs.n	8027da0 <ADC_MEASUREMENT_ADV_Init+0x2ac>
  {
    if ( (bool)false != (bool)((sync_group >> group_index) & 0x1 ))
 8027dc6:	0739      	lsls	r1, r7, #28
 8027dc8:	d510      	bpl.n	8027dec <ADC_MEASUREMENT_ADV_Init+0x2f8>
/* Helper function to configure the eval bits in the slave*/
void ADC_MEASUREMENT_ADV_lSyncEvalConfig(uint32_t master_group, uint32_t slave_selected,
                                         uint32_t sync_group)
{
  int8_t group_index;
  sync_group |= (1U << master_group);
 8027dca:	7dab      	ldrb	r3, [r5, #22]
 8027dcc:	2401      	movs	r4, #1
 8027dce:	409c      	lsls	r4, r3
 8027dd0:	433c      	orrs	r4, r7
  sync_group &= ~(1U << slave_selected);
  for( group_index = XMC_VADC_MAXIMUM_NUM_GROUPS - (int32_t)1; group_index >= (int32_t)0  ; group_index--)
  {
    if ( (bool)false != (bool)((sync_group >> group_index) & 0x1 ))
 8027dd2:	0762      	lsls	r2, r4, #29
 8027dd4:	f100 80b8 	bmi.w	8027f48 <ADC_MEASUREMENT_ADV_Init+0x454>
 8027dd8:	07a3      	lsls	r3, r4, #30
 8027dda:	f100 80af 	bmi.w	8027f3c <ADC_MEASUREMENT_ADV_Init+0x448>
 8027dde:	07e0      	lsls	r0, r4, #31
 8027de0:	d504      	bpl.n	8027dec <ADC_MEASUREMENT_ADV_Init+0x2f8>
    {
      XMC_VADC_GROUP_SetSyncSlaveReadySignal(group_ptrs[slave_selected], slave_selected, group_index);
 8027de2:	486c      	ldr	r0, [pc, #432]	; (8027f94 <ADC_MEASUREMENT_ADV_Init+0x4a0>)
 8027de4:	2103      	movs	r1, #3
 8027de6:	2200      	movs	r2, #0
 8027de8:	f7fb fc14 	bl	8023614 <XMC_VADC_GROUP_SetSyncSlaveReadySignal>
                                        ADC_MEASUREMENT_ADV_SYNC_SEQ_t sequence)
{
  int8_t group_index;
  for( group_index = XMC_VADC_MAXIMUM_NUM_GROUPS - (int32_t)1; group_index >= (int32_t)0  ; group_index--)
  {
    if ( (bool)false != (bool)((sync_group >> group_index) & 0x1 ))
 8027dec:	0779      	lsls	r1, r7, #29
 8027dee:	d510      	bpl.n	8027e12 <ADC_MEASUREMENT_ADV_Init+0x31e>
/* Helper function to configure the eval bits in the slave*/
void ADC_MEASUREMENT_ADV_lSyncEvalConfig(uint32_t master_group, uint32_t slave_selected,
                                         uint32_t sync_group)
{
  int8_t group_index;
  sync_group |= (1U << master_group);
 8027df0:	7dab      	ldrb	r3, [r5, #22]
 8027df2:	2401      	movs	r4, #1
 8027df4:	409c      	lsls	r4, r3
 8027df6:	433c      	orrs	r4, r7
  sync_group &= ~(1U << slave_selected);
  for( group_index = XMC_VADC_MAXIMUM_NUM_GROUPS - (int32_t)1; group_index >= (int32_t)0  ; group_index--)
  {
    if ( (bool)false != (bool)((sync_group >> group_index) & 0x1 ))
 8027df8:	0722      	lsls	r2, r4, #28
 8027dfa:	f100 80bd 	bmi.w	8027f78 <ADC_MEASUREMENT_ADV_Init+0x484>
 8027dfe:	07a3      	lsls	r3, r4, #30
 8027e00:	f100 80b4 	bmi.w	8027f6c <ADC_MEASUREMENT_ADV_Init+0x478>
 8027e04:	07e0      	lsls	r0, r4, #31
 8027e06:	d504      	bpl.n	8027e12 <ADC_MEASUREMENT_ADV_Init+0x31e>
    {
      XMC_VADC_GROUP_SetSyncSlaveReadySignal(group_ptrs[slave_selected], slave_selected, group_index);
 8027e08:	4863      	ldr	r0, [pc, #396]	; (8027f98 <ADC_MEASUREMENT_ADV_Init+0x4a4>)
 8027e0a:	2102      	movs	r1, #2
 8027e0c:	2200      	movs	r2, #0
 8027e0e:	f7fb fc01 	bl	8023614 <XMC_VADC_GROUP_SetSyncSlaveReadySignal>
                                        ADC_MEASUREMENT_ADV_SYNC_SEQ_t sequence)
{
  int8_t group_index;
  for( group_index = XMC_VADC_MAXIMUM_NUM_GROUPS - (int32_t)1; group_index >= (int32_t)0  ; group_index--)
  {
    if ( (bool)false != (bool)((sync_group >> group_index) & 0x1 ))
 8027e12:	07b9      	lsls	r1, r7, #30
 8027e14:	d510      	bpl.n	8027e38 <ADC_MEASUREMENT_ADV_Init+0x344>
/* Helper function to configure the eval bits in the slave*/
void ADC_MEASUREMENT_ADV_lSyncEvalConfig(uint32_t master_group, uint32_t slave_selected,
                                         uint32_t sync_group)
{
  int8_t group_index;
  sync_group |= (1U << master_group);
 8027e16:	7dab      	ldrb	r3, [r5, #22]
 8027e18:	2101      	movs	r1, #1
 8027e1a:	fa01 f403 	lsl.w	r4, r1, r3
 8027e1e:	433c      	orrs	r4, r7
  sync_group &= ~(1U << slave_selected);
  for( group_index = XMC_VADC_MAXIMUM_NUM_GROUPS - (int32_t)1; group_index >= (int32_t)0  ; group_index--)
  {
    if ( (bool)false != (bool)((sync_group >> group_index) & 0x1 ))
 8027e20:	0722      	lsls	r2, r4, #28
 8027e22:	f100 8086 	bmi.w	8027f32 <ADC_MEASUREMENT_ADV_Init+0x43e>
 8027e26:	0763      	lsls	r3, r4, #29
 8027e28:	d47d      	bmi.n	8027f26 <ADC_MEASUREMENT_ADV_Init+0x432>
 8027e2a:	07e4      	lsls	r4, r4, #31
 8027e2c:	d504      	bpl.n	8027e38 <ADC_MEASUREMENT_ADV_Init+0x344>
    {
      XMC_VADC_GROUP_SetSyncSlaveReadySignal(group_ptrs[slave_selected], slave_selected, group_index);
 8027e2e:	485b      	ldr	r0, [pc, #364]	; (8027f9c <ADC_MEASUREMENT_ADV_Init+0x4a8>)
 8027e30:	2101      	movs	r1, #1
 8027e32:	2200      	movs	r2, #0
 8027e34:	f7fb fbee 	bl	8023614 <XMC_VADC_GROUP_SetSyncSlaveReadySignal>
                                        ADC_MEASUREMENT_ADV_SYNC_SEQ_t sequence)
{
  int8_t group_index;
  for( group_index = XMC_VADC_MAXIMUM_NUM_GROUPS - (int32_t)1; group_index >= (int32_t)0  ; group_index--)
  {
    if ( (bool)false != (bool)((sync_group >> group_index) & 0x1 ))
 8027e38:	07f8      	lsls	r0, r7, #31
 8027e3a:	d510      	bpl.n	8027e5e <ADC_MEASUREMENT_ADV_Init+0x36a>
/* Helper function to configure the eval bits in the slave*/
void ADC_MEASUREMENT_ADV_lSyncEvalConfig(uint32_t master_group, uint32_t slave_selected,
                                         uint32_t sync_group)
{
  int8_t group_index;
  sync_group |= (1U << master_group);
 8027e3c:	7daa      	ldrb	r2, [r5, #22]
 8027e3e:	2301      	movs	r3, #1
 8027e40:	4093      	lsls	r3, r2
 8027e42:	431f      	orrs	r7, r3
  sync_group &= ~(1U << slave_selected);
  for( group_index = XMC_VADC_MAXIMUM_NUM_GROUPS - (int32_t)1; group_index >= (int32_t)0  ; group_index--)
  {
    if ( (bool)false != (bool)((sync_group >> group_index) & 0x1 ))
 8027e44:	0739      	lsls	r1, r7, #28
 8027e46:	f100 808b 	bmi.w	8027f60 <ADC_MEASUREMENT_ADV_Init+0x46c>
 8027e4a:	077a      	lsls	r2, r7, #29
 8027e4c:	f100 8082 	bmi.w	8027f54 <ADC_MEASUREMENT_ADV_Init+0x460>
 8027e50:	07bb      	lsls	r3, r7, #30
 8027e52:	d504      	bpl.n	8027e5e <ADC_MEASUREMENT_ADV_Init+0x36a>
    {
      XMC_VADC_GROUP_SetSyncSlaveReadySignal(group_ptrs[slave_selected], slave_selected, group_index);
 8027e54:	4852      	ldr	r0, [pc, #328]	; (8027fa0 <ADC_MEASUREMENT_ADV_Init+0x4ac>)
 8027e56:	2100      	movs	r1, #0
 8027e58:	2201      	movs	r2, #1
 8027e5a:	f7fb fbdb 	bl	8023614 <XMC_VADC_GROUP_SetSyncSlaveReadySignal>
  sync_group = handle_ptr->sync_slaves;
  ADC_MEASUREMENT_ADV_lSyncSequencer(handle_ptr, sync_group, ADC_MEASUREMENT_ADV_SYNC_SEQ_STSEL_CONFIG);
  ADC_MEASUREMENT_ADV_lSyncSequencer(handle_ptr, sync_group, ADC_MEASUREMENT_ADV_SYNC_SEQ_EVAL_CONFIG);

  /* Configure the iclass settings needed for the sync slaves*/
  if( (bool) false != handle_ptr->configure_globiclass1)
 8027e5e:	7eab      	ldrb	r3, [r5, #26]
 8027e60:	b1b3      	cbz	r3, 8027e90 <ADC_MEASUREMENT_ADV_Init+0x39c>
{
  XMC_VADC_CHANNEL_CONV_t req_iclass;

#ifdef ADC_MEASUREMENT_ADV_SCAN_USED
  #ifdef ADC_MEASUREMENT_ADV_QUEUE_USED
    if ( ADC_MEASUREMENT_ADV_REQUEST_SOURCE_LOCAL_SCAN >= handle_ptr->req_src)
 8027e62:	7d2b      	ldrb	r3, [r5, #20]
  XMC_VADC_GLOBAL_CLASS_t conv_class_global;

  XMC_ASSERT("ADC_MEASUREMENT_ADV_SetIclass:Invalid handle_ptr", (handle_ptr != NULL))

  req_iclass = ADC_MEASUREMENT_ADV_lGetIclass(handle_ptr);
  conv_class = XMC_VADC_GROUP_GetInputClass(group_ptrs[handle_ptr->group_index], req_iclass);
 8027e64:	7daa      	ldrb	r2, [r5, #22]
{
  XMC_VADC_CHANNEL_CONV_t req_iclass;

#ifdef ADC_MEASUREMENT_ADV_SCAN_USED
  #ifdef ADC_MEASUREMENT_ADV_QUEUE_USED
    if ( ADC_MEASUREMENT_ADV_REQUEST_SOURCE_LOCAL_SCAN >= handle_ptr->req_src)
 8027e66:	2b01      	cmp	r3, #1
#ifdef ADC_MEASUREMENT_ADV_LOCAL_SCAN_USED
  #ifdef ADC_MEASUREMENT_ADV_ADC_SCAN_USED
      if ( ADC_MEASUREMENT_ADV_REQUEST_SOURCE_SCAN != handle_ptr->req_src)
  #endif
      {
        req_iclass = (XMC_VADC_CHANNEL_CONV_t)handle_ptr->local_scan_handle->iclass_num;
 8027e68:	68eb      	ldr	r3, [r5, #12]
  XMC_VADC_GLOBAL_CLASS_t conv_class_global;

  XMC_ASSERT("ADC_MEASUREMENT_ADV_SetIclass:Invalid handle_ptr", (handle_ptr != NULL))

  req_iclass = ADC_MEASUREMENT_ADV_lGetIclass(handle_ptr);
  conv_class = XMC_VADC_GROUP_GetInputClass(group_ptrs[handle_ptr->group_index], req_iclass);
 8027e6a:	f856 2022 	ldr.w	r2, [r6, r2, lsl #2]
#ifdef ADC_MEASUREMENT_ADV_LOCAL_SCAN_USED
  #ifdef ADC_MEASUREMENT_ADV_ADC_SCAN_USED
      if ( ADC_MEASUREMENT_ADV_REQUEST_SOURCE_SCAN != handle_ptr->req_src)
  #endif
      {
        req_iclass = (XMC_VADC_CHANNEL_CONV_t)handle_ptr->local_scan_handle->iclass_num;
 8027e6e:	bf94      	ite	ls
 8027e70:	f893 3020 	ldrbls.w	r3, [r3, #32]
#ifdef ADC_MEASUREMENT_ADV_LOCAL_QUEUE_USED
  #ifdef ADC_MEASUREMENT_ADV_ADC_QUEUE_USED
      if ( ADC_MEASUREMENT_ADV_REQUEST_SOURCE_QUEUE != handle_ptr->req_src)
  #endif
      {
        req_iclass = (XMC_VADC_CHANNEL_CONV_t)handle_ptr->local_queue_handle->iclass_num;
 8027e74:	7e9b      	ldrbhi	r3, [r3, #26]
  XMC_ASSERT("XMC_VADC_GROUP_GetInputClass:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  XMC_ASSERT("XMC_VADC_GROUP_GetInputClass:Wrong conv_class selected", 
             (XMC_VADC_CHANNEL_CONV_GROUP_CLASS0 == conv_class) || (XMC_VADC_CHANNEL_CONV_GROUP_CLASS1 == conv_class))

  input_value.g_iclass0 = (uint32_t) 0xFFFFFFFF;
  if ((XMC_VADC_CHANNEL_CONV_GROUP_CLASS0 == conv_class) || (XMC_VADC_CHANNEL_CONV_GROUP_CLASS1 == conv_class))
 8027e76:	2b01      	cmp	r3, #1
  {
    input_value.g_iclass0 = group_ptr->ICLASS[(uint32_t)conv_class];
 8027e78:	bf96      	itet	ls
 8027e7a:	3328      	addls	r3, #40	; 0x28
  XMC_VADC_GROUP_CLASS_t input_value;
  XMC_ASSERT("XMC_VADC_GROUP_GetInputClass:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  XMC_ASSERT("XMC_VADC_GROUP_GetInputClass:Wrong conv_class selected", 
             (XMC_VADC_CHANNEL_CONV_GROUP_CLASS0 == conv_class) || (XMC_VADC_CHANNEL_CONV_GROUP_CLASS1 == conv_class))

  input_value.g_iclass0 = (uint32_t) 0xFFFFFFFF;
 8027e7c:	f04f 31ff 	movhi.w	r1, #4294967295
  if ((XMC_VADC_CHANNEL_CONV_GROUP_CLASS0 == conv_class) || (XMC_VADC_CHANNEL_CONV_GROUP_CLASS1 == conv_class))
  {
    input_value.g_iclass0 = group_ptr->ICLASS[(uint32_t)conv_class];
 8027e80:	f852 1023 	ldrls.w	r1, [r2, r3, lsl #2]
  XMC_ASSERT("ADC_MEASUREMENT_ADV_SetIclass:Invalid handle_ptr", (handle_ptr != NULL))

  req_iclass = ADC_MEASUREMENT_ADV_lGetIclass(handle_ptr);
  conv_class = XMC_VADC_GROUP_GetInputClass(group_ptrs[handle_ptr->group_index], req_iclass);
  conv_class_global.globiclass = conv_class.g_iclass0;
  XMC_VADC_GLOBAL_InputClassInit(ADC_MEASUREMENT_ADV_GLOBAL_PTR, conv_class_global,
 8027e84:	f04f 2040 	mov.w	r0, #1073758208	; 0x40004000
 8027e88:	2200      	movs	r2, #0
 8027e8a:	2301      	movs	r3, #1
 8027e8c:	f7fb faba 	bl	8023404 <XMC_VADC_GLOBAL_InputClassInit>
  if( (bool) false != handle_ptr->configure_globiclass1)
  {
    ADC_MEASUREMENT_ADV_SetIclass(handle_ptr);
  }

  XMC_VADC_GROUP_SetSyncMaster(group_ptrs[handle_ptr->group_index]);
 8027e90:	7dab      	ldrb	r3, [r5, #22]
 8027e92:	f856 0023 	ldr.w	r0, [r6, r3, lsl #2]
 8027e96:	f7fb fb95 	bl	80235c4 <XMC_VADC_GROUP_SetSyncMaster>

  XMC_VADC_GROUP_SetPowerMode(group_ptrs[handle_ptr->group_index],XMC_VADC_GROUP_POWERMODE_NORMAL);
 8027e9a:	7dab      	ldrb	r3, [r5, #22]
 8027e9c:	2103      	movs	r1, #3
 8027e9e:	f856 0023 	ldr.w	r0, [r6, r3, lsl #2]
 8027ea2:	f7fb fb7b 	bl	802359c <XMC_VADC_GROUP_SetPowerMode>
 8027ea6:	e6a4      	b.n	8027bf2 <ADC_MEASUREMENT_ADV_Init+0xfe>
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8027ea8:	1e5a      	subs	r2, r3, #1
 8027eaa:	2301      	movs	r3, #1
 8027eac:	4093      	lsls	r3, r2
 8027eae:	3b01      	subs	r3, #1
 8027eb0:	ea03 030c 	and.w	r3, r3, ip
 8027eb4:	e66c      	b.n	8027b90 <ADC_MEASUREMENT_ADV_Init+0x9c>
#endif
#ifdef ADC_MEASUREMENT_ADV_LOCAL_QUEUE_USED
    if (((bool)true == handle_ptr->local_queue_handle->rs_intr_handle.interrupt_enable) &&
        (ADC_MEASUREMENT_ADV_REQUEST_SOURCE_LOCAL_QUEUE == handle_ptr->req_src))
    {
      NVIC_EnableIRQ((IRQn_Type)handle_ptr->local_queue_handle->rs_intr_handle.node_id);
 8027eb6:	6812      	ldr	r2, [r2, #0]
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
 8027eb8:	b253      	sxtb	r3, r2
 8027eba:	2b00      	cmp	r3, #0
 8027ebc:	f6ff aecb 	blt.w	8027c56 <ADC_MEASUREMENT_ADV_Init+0x162>
  {
    NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8027ec0:	f002 021f 	and.w	r2, r2, #31
 8027ec4:	095b      	lsrs	r3, r3, #5
 8027ec6:	2101      	movs	r1, #1
 8027ec8:	4836      	ldr	r0, [pc, #216]	; (8027fa4 <ADC_MEASUREMENT_ADV_Init+0x4b0>)
 8027eca:	fa01 f202 	lsl.w	r2, r1, r2
 8027ece:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
 8027ed2:	e6c0      	b.n	8027c56 <ADC_MEASUREMENT_ADV_Init+0x162>
{
#ifdef ADC_MEASUREMENT_ADV_LOCAL_SCAN_USED
    if (((bool)true == handle_ptr->local_scan_handle->rs_intr_handle.interrupt_enable) &&
        (ADC_MEASUREMENT_ADV_REQUEST_SOURCE_LOCAL_SCAN == handle_ptr->req_src))
    {
      NVIC_EnableIRQ((IRQn_Type)handle_ptr->local_scan_handle->rs_intr_handle.node_id);
 8027ed4:	6810      	ldr	r0, [r2, #0]
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
 8027ed6:	b241      	sxtb	r1, r0
 8027ed8:	2900      	cmp	r1, #0
 8027eda:	db07      	blt.n	8027eec <ADC_MEASUREMENT_ADV_Init+0x3f8>
  {
    NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8027edc:	4a31      	ldr	r2, [pc, #196]	; (8027fa4 <ADC_MEASUREMENT_ADV_Init+0x4b0>)
 8027ede:	f000 001f 	and.w	r0, r0, #31
 8027ee2:	0949      	lsrs	r1, r1, #5
 8027ee4:	4083      	lsls	r3, r0
 8027ee6:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
 8027eea:	68ea      	ldr	r2, [r5, #12]
#ifdef ADC_MEASUREMENT_ADV_LOCAL_SCAN_USED
  #ifdef ADC_MEASUREMENT_ADV_ADC_SCAN_USED
      if ( ADC_MEASUREMENT_ADV_REQUEST_SOURCE_SCAN != handle_ptr->req_src)
  #endif
      {
        XMC_VADC_GROUP_ScanAddMultipleChannels(group_ptrs[handle_ptr->group_index], handle_ptr->local_scan_handle->insert_mask);
 8027eec:	7dab      	ldrb	r3, [r5, #22]
 8027eee:	69d2      	ldr	r2, [r2, #28]
 8027ef0:	f856 3023 	ldr.w	r3, [r6, r3, lsl #2]
 *  XMC_VADC_GROUP_ScanAddChannelToSequence()<BR>
 */
__STATIC_INLINE void XMC_VADC_GROUP_ScanAddMultipleChannels(XMC_VADC_GROUP_t *const group_ptr, const uint32_t ch_mask)
{
  XMC_ASSERT("XMC_VADC_GROUP_ScanAddMultipleChannels:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  group_ptr->ASSEL = ch_mask;
 8027ef4:	f8c3 2128 	str.w	r2, [r3, #296]	; 0x128
#ifdef ADC_MEASUREMENT_ADV_SCAN_USED
  #ifdef ADC_MEASUREMENT_ADV_QUEUE_USED
    if ( ADC_MEASUREMENT_ADV_REQUEST_SOURCE_LOCAL_SCAN >= handle_ptr->req_src)
  #endif
      {
        XMC_VADC_GROUP_ScanEnableArbitrationSlot(group_ptrs[handle_ptr->group_index]);
 8027ef8:	7dab      	ldrb	r3, [r5, #22]
 8027efa:	f856 2023 	ldr.w	r2, [r6, r3, lsl #2]
 *  XMC_VADC_GROUP_ScanDisableArbitrationSlot()<BR>
 */
__STATIC_INLINE void XMC_VADC_GROUP_ScanEnableArbitrationSlot(XMC_VADC_GROUP_t *const group_ptr)
{
  XMC_ASSERT("XMC_VADC_GROUP_ScanEnableArbitrationSlot:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))
  group_ptr->ARBPR |= (uint32_t)VADC_G_ARBPR_ASEN1_Msk;
 8027efe:	f8d2 3084 	ldr.w	r3, [r2, #132]	; 0x84
 8027f02:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 8027f06:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
 8027f0a:	e6c2      	b.n	8027c92 <ADC_MEASUREMENT_ADV_Init+0x19e>
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
  else
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8027f0c:	4a26      	ldr	r2, [pc, #152]	; (8027fa8 <ADC_MEASUREMENT_ADV_Init+0x4b4>)
 8027f0e:	f00e 0e0f 	and.w	lr, lr, #15
 8027f12:	009b      	lsls	r3, r3, #2
 8027f14:	4472      	add	r2, lr
 8027f16:	b2db      	uxtb	r3, r3
 8027f18:	7613      	strb	r3, [r2, #24]
 8027f1a:	e651      	b.n	8027bc0 <ADC_MEASUREMENT_ADV_Init+0xcc>
 */
__STATIC_INLINE bool XMC_VADC_GROUP_ScanIsArbitrationSlotEnabled(XMC_VADC_GROUP_t *const group_ptr)
{
  XMC_ASSERT("XMC_VADC_GROUP_ScanIsArbitrationSlotEnabled:Wrong Group Pointer", XMC_VADC_CHECK_GROUP_PTR(group_ptr))

  return ((group_ptr->ARBPR & (uint32_t)VADC_G_ARBPR_ASEN1_Msk) >> VADC_G_ARBPR_ASEN1_Pos);
 8027f1c:	f3c3 6940 	ubfx	r9, r3, #25, #1
 8027f20:	e6c9      	b.n	8027cb6 <ADC_MEASUREMENT_ADV_Init+0x1c2>
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8027f22:	461a      	mov	r2, r3
 8027f24:	e702      	b.n	8027d2c <ADC_MEASUREMENT_ADV_Init+0x238>
  sync_group &= ~(1U << slave_selected);
  for( group_index = XMC_VADC_MAXIMUM_NUM_GROUPS - (int32_t)1; group_index >= (int32_t)0  ; group_index--)
  {
    if ( (bool)false != (bool)((sync_group >> group_index) & 0x1 ))
    {
      XMC_VADC_GROUP_SetSyncSlaveReadySignal(group_ptrs[slave_selected], slave_selected, group_index);
 8027f26:	481d      	ldr	r0, [pc, #116]	; (8027f9c <ADC_MEASUREMENT_ADV_Init+0x4a8>)
 8027f28:	2101      	movs	r1, #1
 8027f2a:	2202      	movs	r2, #2
 8027f2c:	f7fb fb72 	bl	8023614 <XMC_VADC_GROUP_SetSyncSlaveReadySignal>
 8027f30:	e77b      	b.n	8027e2a <ADC_MEASUREMENT_ADV_Init+0x336>
 8027f32:	481a      	ldr	r0, [pc, #104]	; (8027f9c <ADC_MEASUREMENT_ADV_Init+0x4a8>)
 8027f34:	2203      	movs	r2, #3
 8027f36:	f7fb fb6d 	bl	8023614 <XMC_VADC_GROUP_SetSyncSlaveReadySignal>
 8027f3a:	e774      	b.n	8027e26 <ADC_MEASUREMENT_ADV_Init+0x332>
 8027f3c:	4815      	ldr	r0, [pc, #84]	; (8027f94 <ADC_MEASUREMENT_ADV_Init+0x4a0>)
 8027f3e:	2103      	movs	r1, #3
 8027f40:	2201      	movs	r2, #1
 8027f42:	f7fb fb67 	bl	8023614 <XMC_VADC_GROUP_SetSyncSlaveReadySignal>
 8027f46:	e74a      	b.n	8027dde <ADC_MEASUREMENT_ADV_Init+0x2ea>
 8027f48:	4812      	ldr	r0, [pc, #72]	; (8027f94 <ADC_MEASUREMENT_ADV_Init+0x4a0>)
 8027f4a:	2103      	movs	r1, #3
 8027f4c:	2202      	movs	r2, #2
 8027f4e:	f7fb fb61 	bl	8023614 <XMC_VADC_GROUP_SetSyncSlaveReadySignal>
 8027f52:	e741      	b.n	8027dd8 <ADC_MEASUREMENT_ADV_Init+0x2e4>
 8027f54:	4812      	ldr	r0, [pc, #72]	; (8027fa0 <ADC_MEASUREMENT_ADV_Init+0x4ac>)
 8027f56:	2100      	movs	r1, #0
 8027f58:	2202      	movs	r2, #2
 8027f5a:	f7fb fb5b 	bl	8023614 <XMC_VADC_GROUP_SetSyncSlaveReadySignal>
 8027f5e:	e777      	b.n	8027e50 <ADC_MEASUREMENT_ADV_Init+0x35c>
 8027f60:	480f      	ldr	r0, [pc, #60]	; (8027fa0 <ADC_MEASUREMENT_ADV_Init+0x4ac>)
 8027f62:	2100      	movs	r1, #0
 8027f64:	2203      	movs	r2, #3
 8027f66:	f7fb fb55 	bl	8023614 <XMC_VADC_GROUP_SetSyncSlaveReadySignal>
 8027f6a:	e76e      	b.n	8027e4a <ADC_MEASUREMENT_ADV_Init+0x356>
 8027f6c:	480a      	ldr	r0, [pc, #40]	; (8027f98 <ADC_MEASUREMENT_ADV_Init+0x4a4>)
 8027f6e:	2102      	movs	r1, #2
 8027f70:	2201      	movs	r2, #1
 8027f72:	f7fb fb4f 	bl	8023614 <XMC_VADC_GROUP_SetSyncSlaveReadySignal>
 8027f76:	e745      	b.n	8027e04 <ADC_MEASUREMENT_ADV_Init+0x310>
 8027f78:	4807      	ldr	r0, [pc, #28]	; (8027f98 <ADC_MEASUREMENT_ADV_Init+0x4a4>)
 8027f7a:	2102      	movs	r1, #2
 8027f7c:	2203      	movs	r2, #3
 8027f7e:	f7fb fb49 	bl	8023614 <XMC_VADC_GROUP_SetSyncSlaveReadySignal>
 8027f82:	e73c      	b.n	8027dfe <ADC_MEASUREMENT_ADV_Init+0x30a>
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
  else
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8027f84:	4a08      	ldr	r2, [pc, #32]	; (8027fa8 <ADC_MEASUREMENT_ADV_Init+0x4b4>)
 8027f86:	f00e 0e0f 	and.w	lr, lr, #15
 8027f8a:	009b      	lsls	r3, r3, #2
 8027f8c:	4472      	add	r2, lr
 8027f8e:	b2db      	uxtb	r3, r3
 8027f90:	7613      	strb	r3, [r2, #24]
 8027f92:	e6e3      	b.n	8027d5c <ADC_MEASUREMENT_ADV_Init+0x268>
 8027f94:	40005000 	.word	0x40005000
 8027f98:	40004c00 	.word	0x40004c00
 8027f9c:	40004800 	.word	0x40004800
 8027fa0:	40004400 	.word	0x40004400
 8027fa4:	e000e100 	.word	0xe000e100
 8027fa8:	e000ecfc 	.word	0xe000ecfc

08027fac <ADC_MEASUREMENT_ADV_G0_event_config>:
 */
static void ADC_MEASUREMENT_ADV_G0_event_config(void)
{

	/* Result Event Node Mux Configuration for CH_G0 (Group-0 channel-0 Result_Register-15)*/
	XMC_VADC_GROUP_SetResultInterruptNode(VADC_G0, 15U, XMC_VADC_SR_SHARED_SR0);
 8027fac:	4802      	ldr	r0, [pc, #8]	; (8027fb8 <ADC_MEASUREMENT_ADV_G0_event_config+0xc>)
 8027fae:	210f      	movs	r1, #15
 8027fb0:	2204      	movs	r2, #4
 8027fb2:	f7fb bc13 	b.w	80237dc <XMC_VADC_GROUP_SetResultInterruptNode>
 8027fb6:	bf00      	nop
 8027fb8:	40004400 	.word	0x40004400

08027fbc <ADC_MEASUREMENT_ADV_G1_event_config>:
 */
static void ADC_MEASUREMENT_ADV_G1_event_config(void)
{

	/* Result Event Node Mux Configuration for CH_G1 (Group-1 channel-3 Result_Register-3)*/
	XMC_VADC_GROUP_SetResultInterruptNode(VADC_G1, 3U, XMC_VADC_SR_SHARED_SR1);
 8027fbc:	4802      	ldr	r0, [pc, #8]	; (8027fc8 <ADC_MEASUREMENT_ADV_G1_event_config+0xc>)
 8027fbe:	2103      	movs	r1, #3
 8027fc0:	2205      	movs	r2, #5
 8027fc2:	f7fb bc0b 	b.w	80237dc <XMC_VADC_GROUP_SetResultInterruptNode>
 8027fc6:	bf00      	nop
 8027fc8:	40004800 	.word	0x40004800

08027fcc <ADC_MEASUREMENT_ADV_G2_event_config>:
 */
static void ADC_MEASUREMENT_ADV_G2_event_config(void)
{

	/* Result Event Node Mux Configuration for CH_G2 (Group-2 channel-3 Result_Register-0)*/
	XMC_VADC_GROUP_SetResultInterruptNode(VADC_G2, 0U, XMC_VADC_SR_SHARED_SR3);
 8027fcc:	4802      	ldr	r0, [pc, #8]	; (8027fd8 <ADC_MEASUREMENT_ADV_G2_event_config+0xc>)
 8027fce:	2100      	movs	r1, #0
 8027fd0:	2207      	movs	r2, #7
 8027fd2:	f7fb bc03 	b.w	80237dc <XMC_VADC_GROUP_SetResultInterruptNode>
 8027fd6:	bf00      	nop
 8027fd8:	40004c00 	.word	0x40004c00

08027fdc <ADC_MEASUREMENT_ADV_G3_event_config>:
 */
static void ADC_MEASUREMENT_ADV_G3_event_config(void)
{

	/* Result Event Node Mux Configuration for CH_G3 (Group-3 channel-1 Result_Register-4)*/
	XMC_VADC_GROUP_SetResultInterruptNode(VADC_G3, 4U, XMC_VADC_SR_GROUP_SR2);
 8027fdc:	4802      	ldr	r0, [pc, #8]	; (8027fe8 <ADC_MEASUREMENT_ADV_G3_event_config+0xc>)
 8027fde:	2104      	movs	r1, #4
 8027fe0:	2202      	movs	r2, #2
 8027fe2:	f7fb bbfb 	b.w	80237dc <XMC_VADC_GROUP_SetResultInterruptNode>
 8027fe6:	bf00      	nop
 8027fe8:	40005000 	.word	0x40005000

08027fec <DAVE_Init>:
 * @param[in]  None
 *
 * @return  DAVE_STATUS_t <BR>
 ******************************************************************************/
DAVE_STATUS_t DAVE_Init(void)
{
 8027fec:	b508      	push	{r3, lr}
  DAVE_STATUS_t init_status;
  
  init_status = DAVE_STATUS_SUCCESS;
     /** @Initialization of APPs Init Functions */
     init_status = (DAVE_STATUS_t)CLOCK_XMC4_Init(&CLOCK_XMC4_0);
 8027fee:	486a      	ldr	r0, [pc, #424]	; (8028198 <DAVE_Init+0x1ac>)
 8027ff0:	f7ff fd52 	bl	8027a98 <CLOCK_XMC4_Init>

  if (init_status == DAVE_STATUS_SUCCESS)
 8027ff4:	b100      	cbz	r0, 8027ff8 <DAVE_Init+0xc>
  {
	 /**  Initialization of TIMER APP instance TIMER_ERROR_TOGGLE */
	 init_status = (DAVE_STATUS_t)TIMER_Init(&TIMER_ERROR_TOGGLE); 
   }  
  return init_status;
} /**  End of function DAVE_Init */
 8027ff6:	bd08      	pop	{r3, pc}
     init_status = (DAVE_STATUS_t)CLOCK_XMC4_Init(&CLOCK_XMC4_0);

  if (init_status == DAVE_STATUS_SUCCESS)
  {
	 /**  Initialization of ADC_MEASUREMENT_ADV APP instance ADC_MEASUREMENT_ADV_G0 */
	 init_status = (DAVE_STATUS_t)ADC_MEASUREMENT_ADV_Init(&ADC_MEASUREMENT_ADV_G0); 
 8027ff8:	4868      	ldr	r0, [pc, #416]	; (802819c <DAVE_Init+0x1b0>)
 8027ffa:	f7ff fd7b 	bl	8027af4 <ADC_MEASUREMENT_ADV_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8027ffe:	2800      	cmp	r0, #0
 8028000:	d1f9      	bne.n	8027ff6 <DAVE_Init+0xa>
  {
	 /**  Initialization of INTERRUPT APP instance INTERRUPT_FRAME */
	 init_status = (DAVE_STATUS_t)INTERRUPT_Init(&INTERRUPT_FRAME); 
 8028002:	4867      	ldr	r0, [pc, #412]	; (80281a0 <DAVE_Init+0x1b4>)
 8028004:	f7fe fa80 	bl	8026508 <INTERRUPT_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8028008:	2800      	cmp	r0, #0
 802800a:	d1f4      	bne.n	8027ff6 <DAVE_Init+0xa>
  {
	 /**  Initialization of TIMER APP instance TIMER_FRAME_TRIG */
	 init_status = (DAVE_STATUS_t)TIMER_Init(&TIMER_FRAME_TRIG); 
 802800c:	4865      	ldr	r0, [pc, #404]	; (80281a4 <DAVE_Init+0x1b8>)
 802800e:	f7fd fef1 	bl	8025df4 <TIMER_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8028012:	2800      	cmp	r0, #0
 8028014:	d1ef      	bne.n	8027ff6 <DAVE_Init+0xa>
  {
	 /**  Initialization of USBD_VCOM APP instance USBD_VCOM_0 */
	 init_status = (DAVE_STATUS_t)USBD_VCOM_Init(&USBD_VCOM_0); 
 8028016:	4864      	ldr	r0, [pc, #400]	; (80281a8 <DAVE_Init+0x1bc>)
 8028018:	f7fc ff66 	bl	8024ee8 <USBD_VCOM_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802801c:	2800      	cmp	r0, #0
 802801e:	d1ea      	bne.n	8027ff6 <DAVE_Init+0xa>
  {
	 /**  Initialization of GLOBAL_CCU8 APP instance GLOBAL_CCU8_0 */
	 init_status = (DAVE_STATUS_t)GLOBAL_CCU8_Init(&GLOBAL_CCU8_0); 
 8028020:	4862      	ldr	r0, [pc, #392]	; (80281ac <DAVE_Init+0x1c0>)
 8028022:	f7fe fb15 	bl	8026650 <GLOBAL_CCU8_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8028026:	2800      	cmp	r0, #0
 8028028:	d1e5      	bne.n	8027ff6 <DAVE_Init+0xa>
  {
	 /**  Initialization of ADC_MEASUREMENT_ADV APP instance ADC_MEASUREMENT_ADV_G1 */
	 init_status = (DAVE_STATUS_t)ADC_MEASUREMENT_ADV_Init(&ADC_MEASUREMENT_ADV_G1); 
 802802a:	4861      	ldr	r0, [pc, #388]	; (80281b0 <DAVE_Init+0x1c4>)
 802802c:	f7ff fd62 	bl	8027af4 <ADC_MEASUREMENT_ADV_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8028030:	2800      	cmp	r0, #0
 8028032:	d1e0      	bne.n	8027ff6 <DAVE_Init+0xa>
  {
	 /**  Initialization of DMA_CH APP instance DMA_CH_G0 */
	 init_status = (DAVE_STATUS_t)DMA_CH_Init(&DMA_CH_G0); 
 8028034:	485f      	ldr	r0, [pc, #380]	; (80281b4 <DAVE_Init+0x1c8>)
 8028036:	f7fe fb69 	bl	802670c <DMA_CH_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802803a:	2800      	cmp	r0, #0
 802803c:	d1db      	bne.n	8027ff6 <DAVE_Init+0xa>
  {
	 /**  Initialization of DMA_CH APP instance DMA_CH_G1 */
	 init_status = (DAVE_STATUS_t)DMA_CH_Init(&DMA_CH_G1); 
 802803e:	485e      	ldr	r0, [pc, #376]	; (80281b8 <DAVE_Init+0x1cc>)
 8028040:	f7fe fb64 	bl	802670c <DMA_CH_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8028044:	2800      	cmp	r0, #0
 8028046:	d1d6      	bne.n	8027ff6 <DAVE_Init+0xa>
  {
	 /**  Initialization of ADC_MEASUREMENT_ADV APP instance ADC_MEASUREMENT_SCAN */
	 init_status = (DAVE_STATUS_t)ADC_MEASUREMENT_ADV_Init(&ADC_MEASUREMENT_SCAN); 
 8028048:	485c      	ldr	r0, [pc, #368]	; (80281bc <DAVE_Init+0x1d0>)
 802804a:	f7ff fd53 	bl	8027af4 <ADC_MEASUREMENT_ADV_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802804e:	2800      	cmp	r0, #0
 8028050:	d1d1      	bne.n	8027ff6 <DAVE_Init+0xa>
  {
	 /**  Initialization of DIGITAL_IO APP instance DIGITAL_IO_BGT_VCC_PTAT */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_BGT_VCC_PTAT); 
 8028052:	485b      	ldr	r0, [pc, #364]	; (80281c0 <DAVE_Init+0x1d4>)
 8028054:	f7fe fbee 	bl	8026834 <DIGITAL_IO_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8028058:	2800      	cmp	r0, #0
 802805a:	d1cc      	bne.n	8027ff6 <DAVE_Init+0xa>
  {
	 /**  Initialization of PWM_CCU8 APP instance PWM_CCU8_BGT_VCC */
	 init_status = (DAVE_STATUS_t)PWM_CCU8_Init(&PWM_CCU8_BGT_VCC); 
 802805c:	4859      	ldr	r0, [pc, #356]	; (80281c4 <DAVE_Init+0x1d8>)
 802805e:	f7fd ffbb 	bl	8025fd8 <PWM_CCU8_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8028062:	2800      	cmp	r0, #0
 8028064:	d1c7      	bne.n	8027ff6 <DAVE_Init+0xa>
  {
	 /**  Initialization of PWM_CCU8 APP instance PWM_CCU8_BGT_TX_ON */
	 init_status = (DAVE_STATUS_t)PWM_CCU8_Init(&PWM_CCU8_BGT_TX_ON); 
 8028066:	4858      	ldr	r0, [pc, #352]	; (80281c8 <DAVE_Init+0x1dc>)
 8028068:	f7fd ffb6 	bl	8025fd8 <PWM_CCU8_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802806c:	2800      	cmp	r0, #0
 802806e:	d1c2      	bne.n	8027ff6 <DAVE_Init+0xa>
  {
	 /**  Initialization of PWM_CCU8 APP instance PWM_CCU8_SAMPLE_HOLD */
	 init_status = (DAVE_STATUS_t)PWM_CCU8_Init(&PWM_CCU8_SAMPLE_HOLD); 
 8028070:	4856      	ldr	r0, [pc, #344]	; (80281cc <DAVE_Init+0x1e0>)
 8028072:	f7fd ffb1 	bl	8025fd8 <PWM_CCU8_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8028076:	2800      	cmp	r0, #0
 8028078:	d1bd      	bne.n	8027ff6 <DAVE_Init+0xa>
  {
	 /**  Initialization of PWM_CCU8 APP instance PWM_CCU8_ADC_SAMPLE */
	 init_status = (DAVE_STATUS_t)PWM_CCU8_Init(&PWM_CCU8_ADC_SAMPLE); 
 802807a:	4855      	ldr	r0, [pc, #340]	; (80281d0 <DAVE_Init+0x1e4>)
 802807c:	f7fd ffac 	bl	8025fd8 <PWM_CCU8_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8028080:	2800      	cmp	r0, #0
 8028082:	d1b8      	bne.n	8027ff6 <DAVE_Init+0xa>
  {
	 /**  Initialization of DIGITAL_IO APP instance DIGITAL_IO_RED_LED */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_RED_LED); 
 8028084:	4853      	ldr	r0, [pc, #332]	; (80281d4 <DAVE_Init+0x1e8>)
 8028086:	f7fe fbd5 	bl	8026834 <DIGITAL_IO_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802808a:	2800      	cmp	r0, #0
 802808c:	d1b3      	bne.n	8027ff6 <DAVE_Init+0xa>
  {
	 /**  Initialization of DIGITAL_IO APP instance DIGITAL_IO_BLUE_LED */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_BLUE_LED); 
 802808e:	4852      	ldr	r0, [pc, #328]	; (80281d8 <DAVE_Init+0x1ec>)
 8028090:	f7fe fbd0 	bl	8026834 <DIGITAL_IO_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8028094:	2800      	cmp	r0, #0
 8028096:	d1ae      	bne.n	8027ff6 <DAVE_Init+0xa>
  {
	 /**  Initialization of DIGITAL_IO APP instance DIGITAL_IO_GREEN_LED */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_GREEN_LED); 
 8028098:	4850      	ldr	r0, [pc, #320]	; (80281dc <DAVE_Init+0x1f0>)
 802809a:	f7fe fbcb 	bl	8026834 <DIGITAL_IO_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802809e:	2800      	cmp	r0, #0
 80280a0:	d1a9      	bne.n	8027ff6 <DAVE_Init+0xa>
  {
	 /**  Initialization of TIMER APP instance TIMER_PTAT_DELAY */
	 init_status = (DAVE_STATUS_t)TIMER_Init(&TIMER_PTAT_DELAY); 
 80280a2:	484f      	ldr	r0, [pc, #316]	; (80281e0 <DAVE_Init+0x1f4>)
 80280a4:	f7fd fea6 	bl	8025df4 <TIMER_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 80280a8:	2800      	cmp	r0, #0
 80280aa:	d1a4      	bne.n	8027ff6 <DAVE_Init+0xa>
  {
	 /**  Initialization of INTERRUPT APP instance INTERRUPT_PTAT_TIMER */
	 init_status = (DAVE_STATUS_t)INTERRUPT_Init(&INTERRUPT_PTAT_TIMER); 
 80280ac:	484d      	ldr	r0, [pc, #308]	; (80281e4 <DAVE_Init+0x1f8>)
 80280ae:	f7fe fa2b 	bl	8026508 <INTERRUPT_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 80280b2:	2800      	cmp	r0, #0
 80280b4:	d19f      	bne.n	8027ff6 <DAVE_Init+0xa>
  {
	 /**  Initialization of ADC_MEASUREMENT_ADV APP instance ADC_MEASUREMENT_ADV_G2 */
	 init_status = (DAVE_STATUS_t)ADC_MEASUREMENT_ADV_Init(&ADC_MEASUREMENT_ADV_G2); 
 80280b6:	484c      	ldr	r0, [pc, #304]	; (80281e8 <DAVE_Init+0x1fc>)
 80280b8:	f7ff fd1c 	bl	8027af4 <ADC_MEASUREMENT_ADV_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 80280bc:	2800      	cmp	r0, #0
 80280be:	d19a      	bne.n	8027ff6 <DAVE_Init+0xa>
  {
	 /**  Initialization of ADC_MEASUREMENT_ADV APP instance ADC_MEASUREMENT_ADV_G3 */
	 init_status = (DAVE_STATUS_t)ADC_MEASUREMENT_ADV_Init(&ADC_MEASUREMENT_ADV_G3); 
 80280c0:	484a      	ldr	r0, [pc, #296]	; (80281ec <DAVE_Init+0x200>)
 80280c2:	f7ff fd17 	bl	8027af4 <ADC_MEASUREMENT_ADV_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 80280c6:	2800      	cmp	r0, #0
 80280c8:	d195      	bne.n	8027ff6 <DAVE_Init+0xa>
  {
	 /**  Initialization of DMA_CH APP instance DMA_CH_G3 */
	 init_status = (DAVE_STATUS_t)DMA_CH_Init(&DMA_CH_G3); 
 80280ca:	4849      	ldr	r0, [pc, #292]	; (80281f0 <DAVE_Init+0x204>)
 80280cc:	f7fe fb1e 	bl	802670c <DMA_CH_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 80280d0:	2800      	cmp	r0, #0
 80280d2:	d190      	bne.n	8027ff6 <DAVE_Init+0xa>
  {
	 /**  Initialization of DMA_CH APP instance DMA_CH_G2 */
	 init_status = (DAVE_STATUS_t)DMA_CH_Init(&DMA_CH_G2); 
 80280d4:	4847      	ldr	r0, [pc, #284]	; (80281f4 <DAVE_Init+0x208>)
 80280d6:	f7fe fb19 	bl	802670c <DMA_CH_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 80280da:	2800      	cmp	r0, #0
 80280dc:	d18b      	bne.n	8027ff6 <DAVE_Init+0xa>
  {
	 /**  Initialization of I2C_MASTER APP instance I2C_MASTER_EEPROM */
	 init_status = (DAVE_STATUS_t)I2C_MASTER_Init(&I2C_MASTER_EEPROM); 
 80280de:	4846      	ldr	r0, [pc, #280]	; (80281f8 <DAVE_Init+0x20c>)
 80280e0:	f000 fe7c 	bl	8028ddc <I2C_MASTER_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 80280e4:	2800      	cmp	r0, #0
 80280e6:	d186      	bne.n	8027ff6 <DAVE_Init+0xa>
  {
	 /**  Initialization of TIMER APP instance EEPROM_TIMER_DELAY */
	 init_status = (DAVE_STATUS_t)TIMER_Init(&EEPROM_TIMER_DELAY); 
 80280e8:	4844      	ldr	r0, [pc, #272]	; (80281fc <DAVE_Init+0x210>)
 80280ea:	f7fd fe83 	bl	8025df4 <TIMER_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 80280ee:	2800      	cmp	r0, #0
 80280f0:	d181      	bne.n	8027ff6 <DAVE_Init+0xa>
  {
	 /**  Initialization of DIGITAL_IO APP instance DIGITAL_IO_ARD_D4 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_ARD_D4); 
 80280f2:	4843      	ldr	r0, [pc, #268]	; (8028200 <DAVE_Init+0x214>)
 80280f4:	f7fe fb9e 	bl	8026834 <DIGITAL_IO_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 80280f8:	2800      	cmp	r0, #0
 80280fa:	f47f af7c 	bne.w	8027ff6 <DAVE_Init+0xa>
  {
	 /**  Initialization of DIGITAL_IO APP instance DIGITAL_IO_ARD_D7 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_ARD_D7); 
 80280fe:	4841      	ldr	r0, [pc, #260]	; (8028204 <DAVE_Init+0x218>)
 8028100:	f7fe fb98 	bl	8026834 <DIGITAL_IO_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8028104:	2800      	cmp	r0, #0
 8028106:	f47f af76 	bne.w	8027ff6 <DAVE_Init+0xa>
  {
	 /**  Initialization of DIGITAL_IO APP instance DIGITAL_IO_ARD_D6 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_ARD_D6); 
 802810a:	483f      	ldr	r0, [pc, #252]	; (8028208 <DAVE_Init+0x21c>)
 802810c:	f7fe fb92 	bl	8026834 <DIGITAL_IO_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8028110:	2800      	cmp	r0, #0
 8028112:	f47f af70 	bne.w	8027ff6 <DAVE_Init+0xa>
  {
	 /**  Initialization of CRC_SW APP instance CRC_SW_EEPROM */
	 init_status = (DAVE_STATUS_t)CRC_SW_Init(&CRC_SW_EEPROM); 
 8028116:	483d      	ldr	r0, [pc, #244]	; (802820c <DAVE_Init+0x220>)
 8028118:	f7fe fb9a 	bl	8026850 <CRC_SW_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802811c:	2800      	cmp	r0, #0
 802811e:	f47f af6a 	bne.w	8027ff6 <DAVE_Init+0xa>
  {
	 /**  Initialization of DIGITAL_IO APP instance DIGITAL_IO_V_PTAT_SH_EN */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_V_PTAT_SH_EN); 
 8028122:	483b      	ldr	r0, [pc, #236]	; (8028210 <DAVE_Init+0x224>)
 8028124:	f7fe fb86 	bl	8026834 <DIGITAL_IO_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8028128:	2800      	cmp	r0, #0
 802812a:	f47f af64 	bne.w	8027ff6 <DAVE_Init+0xa>
  {
	 /**  Initialization of TIMER APP instance TIMER_PTAT_S_H_DELAY */
	 init_status = (DAVE_STATUS_t)TIMER_Init(&TIMER_PTAT_S_H_DELAY); 
 802812e:	4839      	ldr	r0, [pc, #228]	; (8028214 <DAVE_Init+0x228>)
 8028130:	f7fd fe60 	bl	8025df4 <TIMER_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8028134:	2800      	cmp	r0, #0
 8028136:	f47f af5e 	bne.w	8027ff6 <DAVE_Init+0xa>
  {
	 /**  Initialization of INTERRUPT APP instance INTERRUPT_PTAT_S_H_DELAY */
	 init_status = (DAVE_STATUS_t)INTERRUPT_Init(&INTERRUPT_PTAT_S_H_DELAY); 
 802813a:	4837      	ldr	r0, [pc, #220]	; (8028218 <DAVE_Init+0x22c>)
 802813c:	f7fe f9e4 	bl	8026508 <INTERRUPT_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8028140:	2800      	cmp	r0, #0
 8028142:	f47f af58 	bne.w	8027ff6 <DAVE_Init+0xa>
  {
	 /**  Initialization of INTERRUPT APP instance INTERRUPT_BGT_VCC_ON */
	 init_status = (DAVE_STATUS_t)INTERRUPT_Init(&INTERRUPT_BGT_VCC_ON); 
 8028146:	4835      	ldr	r0, [pc, #212]	; (802821c <DAVE_Init+0x230>)
 8028148:	f7fe f9de 	bl	8026508 <INTERRUPT_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802814c:	2800      	cmp	r0, #0
 802814e:	f47f af52 	bne.w	8027ff6 <DAVE_Init+0xa>
  {
	 /**  Initialization of DIGITAL_IO APP instance DIGITAL_IO_BB1_EN */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_BB1_EN); 
 8028152:	4833      	ldr	r0, [pc, #204]	; (8028220 <DAVE_Init+0x234>)
 8028154:	f7fe fb6e 	bl	8026834 <DIGITAL_IO_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8028158:	2800      	cmp	r0, #0
 802815a:	f47f af4c 	bne.w	8027ff6 <DAVE_Init+0xa>
  {
	 /**  Initialization of DIGITAL_IO APP instance DIGITAL_IO_BB2_EN */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&DIGITAL_IO_BB2_EN); 
 802815e:	4831      	ldr	r0, [pc, #196]	; (8028224 <DAVE_Init+0x238>)
 8028160:	f7fe fb68 	bl	8026834 <DIGITAL_IO_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8028164:	2800      	cmp	r0, #0
 8028166:	f47f af46 	bne.w	8027ff6 <DAVE_Init+0xa>
  {
	 /**  Initialization of INTERRUPT APP instance INTERRUPT_BB_PRE_TRIGGER */
	 init_status = (DAVE_STATUS_t)INTERRUPT_Init(&INTERRUPT_BB_PRE_TRIGGER); 
 802816a:	482f      	ldr	r0, [pc, #188]	; (8028228 <DAVE_Init+0x23c>)
 802816c:	f7fe f9cc 	bl	8026508 <INTERRUPT_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8028170:	2800      	cmp	r0, #0
 8028172:	f47f af40 	bne.w	8027ff6 <DAVE_Init+0xa>
  {
	 /**  Initialization of TIMER APP instance TIMER_BB_PRE_TRIGGER */
	 init_status = (DAVE_STATUS_t)TIMER_Init(&TIMER_BB_PRE_TRIGGER); 
 8028176:	482d      	ldr	r0, [pc, #180]	; (802822c <DAVE_Init+0x240>)
 8028178:	f7fd fe3c 	bl	8025df4 <TIMER_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 802817c:	2800      	cmp	r0, #0
 802817e:	f47f af3a 	bne.w	8027ff6 <DAVE_Init+0xa>
  {
	 /**  Initialization of INTERRUPT APP instance INTERRUPT_ERROR_TOGGLE */
	 init_status = (DAVE_STATUS_t)INTERRUPT_Init(&INTERRUPT_ERROR_TOGGLE); 
 8028182:	482b      	ldr	r0, [pc, #172]	; (8028230 <DAVE_Init+0x244>)
 8028184:	f7fe f9c0 	bl	8026508 <INTERRUPT_Init>
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8028188:	2800      	cmp	r0, #0
 802818a:	f47f af34 	bne.w	8027ff6 <DAVE_Init+0xa>
  {
	 /**  Initialization of TIMER APP instance TIMER_ERROR_TOGGLE */
	 init_status = (DAVE_STATUS_t)TIMER_Init(&TIMER_ERROR_TOGGLE); 
 802818e:	4829      	ldr	r0, [pc, #164]	; (8028234 <DAVE_Init+0x248>)
   }  
  return init_status;
} /**  End of function DAVE_Init */
 8028190:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	 init_status = (DAVE_STATUS_t)INTERRUPT_Init(&INTERRUPT_ERROR_TOGGLE); 
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
  {
	 /**  Initialization of TIMER APP instance TIMER_ERROR_TOGGLE */
	 init_status = (DAVE_STATUS_t)TIMER_Init(&TIMER_ERROR_TOGGLE); 
 8028194:	f7fd be2e 	b.w	8025df4 <TIMER_Init>
 8028198:	1ffeb464 	.word	0x1ffeb464
 802819c:	080318a4 	.word	0x080318a4
 80281a0:	0802f7d0 	.word	0x0802f7d0
 80281a4:	1ffe9200 	.word	0x1ffe9200
 80281a8:	1ffeb420 	.word	0x1ffeb420
 80281ac:	1ffe9308 	.word	0x1ffe9308
 80281b0:	080318c0 	.word	0x080318c0
 80281b4:	1ffe93c0 	.word	0x1ffe93c0
 80281b8:	1ffe93d0 	.word	0x1ffe93d0
 80281bc:	080317a4 	.word	0x080317a4
 80281c0:	0802f86c 	.word	0x0802f86c
 80281c4:	1ffe9228 	.word	0x1ffe9228
 80281c8:	1ffe925c 	.word	0x1ffe925c
 80281cc:	1ffe9290 	.word	0x1ffe9290
 80281d0:	1ffe92c4 	.word	0x1ffe92c4
 80281d4:	0802f8d0 	.word	0x0802f8d0
 80281d8:	0802f8e4 	.word	0x0802f8e4
 80281dc:	0802f8bc 	.word	0x0802f8bc
 80281e0:	1ffe9120 	.word	0x1ffe9120
 80281e4:	0802f7cc 	.word	0x0802f7cc
 80281e8:	080318dc 	.word	0x080318dc
 80281ec:	080318f8 	.word	0x080318f8
 80281f0:	1ffe93f0 	.word	0x1ffe93f0
 80281f4:	1ffe93e0 	.word	0x1ffe93e0
 80281f8:	1ffe95f0 	.word	0x1ffe95f0
 80281fc:	1ffe9188 	.word	0x1ffe9188
 8028200:	0802f880 	.word	0x0802f880
 8028204:	0802f8a8 	.word	0x0802f8a8
 8028208:	0802f894 	.word	0x0802f894
 802820c:	1ffe9484 	.word	0x1ffe9484
 8028210:	0802f8f8 	.word	0x0802f8f8
 8028214:	1ffe91b0 	.word	0x1ffe91b0
 8028218:	0802f7d4 	.word	0x0802f7d4
 802821c:	0802f7d8 	.word	0x0802f7d8
 8028220:	0802f844 	.word	0x0802f844
 8028224:	0802f858 	.word	0x0802f858
 8028228:	0802f7c8 	.word	0x0802f7c8
 802822c:	1ffe9158 	.word	0x1ffe9158
 8028230:	0802f7c4 	.word	0x0802f7c4
 8028234:	1ffe91d8 	.word	0x1ffe91d8

08028238 <fft_window_gen>:
==============================================================================
 */

/*-------------------------- fft_init() ------------------------------------*/
uint8_t fft_window_gen(FFT_Window_Struct_t *fft_window)
{
 8028238:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802823c:	ed2d 8b08 	vpush	{d8-d11}
  if ((fft_window->fft_window_buffer == NULL) ||
 8028240:	f8d0 a00c 	ldr.w	sl, [r0, #12]
==============================================================================
 */

/*-------------------------- fft_init() ------------------------------------*/
uint8_t fft_window_gen(FFT_Window_Struct_t *fft_window)
{
 8028244:	b087      	sub	sp, #28
  if ((fft_window->fft_window_buffer == NULL) ||
 8028246:	f1ba 0f00 	cmp.w	sl, #0
 802824a:	d01b      	beq.n	8028284 <fft_window_gen+0x4c>
	   (fft_window->fft_window_length == 0) ||
 802824c:	f8d0 9004 	ldr.w	r9, [r0, #4]
 */

/*-------------------------- fft_init() ------------------------------------*/
uint8_t fft_window_gen(FFT_Window_Struct_t *fft_window)
{
  if ((fft_window->fft_window_buffer == NULL) ||
 8028250:	f109 34ff 	add.w	r4, r9, #4294967295
 8028254:	2cff      	cmp	r4, #255	; 0xff
 8028256:	d815      	bhi.n	8028284 <fft_window_gen+0x4c>
	   (fft_window->fft_window_length > MAX_FFT_WIN_LEN))
  {
    return 0;
  }

  switch (fft_window->fft_size)
 8028258:	8843      	ldrh	r3, [r0, #2]
 802825a:	2b40      	cmp	r3, #64	; 0x40
 802825c:	d020      	beq.n	80282a0 <fft_window_gen+0x68>
 802825e:	d817      	bhi.n	8028290 <fft_window_gen+0x58>
 8028260:	2b10      	cmp	r3, #16
 8028262:	d020      	beq.n	80282a6 <fft_window_gen+0x6e>
 8028264:	2b20      	cmp	r3, #32
 8028266:	d10d      	bne.n	8028284 <fft_window_gen+0x4c>
  case FFT_SIZE_16:
	  fft_window->fft_time_twiddle_table = &arm_cfft_sR_f32_len16;		/* as FFT_SIZE = 16 points */
	  break;

  case FFT_SIZE_32:
	  fft_window->fft_time_twiddle_table = &arm_cfft_sR_f32_len32;		/* as FFT_SIZE = 32 points */
 8028268:	4bb1      	ldr	r3, [pc, #708]	; (8028530 <fft_window_gen+0x2f8>)
 802826a:	6103      	str	r3, [r0, #16]
  if ((window_buffer == NULL) || (window_size == 0) || (window_size > MAX_FFT_WIN_LEN))
  {
    return 0;
  }

  switch (window_type)
 802826c:	7803      	ldrb	r3, [r0, #0]
  default:
	  return 0;
	  break;
  }

  return(fft_window_init(fft_window->fft_window_type,fft_window->fft_window_length,
 802826e:	edd0 7a02 	vldr	s15, [r0, #8]
  if ((window_buffer == NULL) || (window_size == 0) || (window_size > MAX_FFT_WIN_LEN))
  {
    return 0;
  }

  switch (window_type)
 8028272:	3b01      	subs	r3, #1
 8028274:	2b03      	cmp	r3, #3
 8028276:	d805      	bhi.n	8028284 <fft_window_gen+0x4c>
 8028278:	e8df f013 	tbh	[pc, r3, lsl #1]
 802827c:	00e7011d 	.word	0x00e7011d
 8028280:	001b0172 	.word	0x001b0172
  case FFT_WINDOW_CHEBYSHEV:
	  return fft_window_init_chebyshev(window_size, window_buffer, at_dB);
	  break;

  default:
	  return 0;
 8028284:	2000      	movs	r0, #0
	  break;
  }

  return(fft_window_init(fft_window->fft_window_type,fft_window->fft_window_length,
		 fft_window->fft_chebyshev_at_dB, fft_window->fft_window_buffer));
}
 8028286:	b007      	add	sp, #28
 8028288:	ecbd 8b08 	vpop	{d8-d11}
 802828c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	   (fft_window->fft_window_length > MAX_FFT_WIN_LEN))
  {
    return 0;
  }

  switch (fft_window->fft_size)
 8028290:	2b80      	cmp	r3, #128	; 0x80
 8028292:	d00b      	beq.n	80282ac <fft_window_gen+0x74>
 8028294:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8028298:	d1f4      	bne.n	8028284 <fft_window_gen+0x4c>
  case FFT_SIZE_128:
	  fft_window->fft_time_twiddle_table  = &arm_cfft_sR_f32_len128;	/* as FFT_SIZE = 128 points */
	  break;

  case FFT_SIZE_256:
	  fft_window->fft_time_twiddle_table  = &arm_cfft_sR_f32_len256;	/* as FFT_SIZE = 256 points */
 802829a:	4ba6      	ldr	r3, [pc, #664]	; (8028534 <fft_window_gen+0x2fc>)
 802829c:	6103      	str	r3, [r0, #16]
	  break;
 802829e:	e7e5      	b.n	802826c <fft_window_gen+0x34>
  case FFT_SIZE_32:
	  fft_window->fft_time_twiddle_table = &arm_cfft_sR_f32_len32;		/* as FFT_SIZE = 32 points */
	  break;

  case FFT_SIZE_64:
	  fft_window->fft_time_twiddle_table  = &arm_cfft_sR_f32_len64;		/* as FFT_SIZE = 64 points */
 80282a0:	4ba5      	ldr	r3, [pc, #660]	; (8028538 <fft_window_gen+0x300>)
 80282a2:	6103      	str	r3, [r0, #16]
	  break;
 80282a4:	e7e2      	b.n	802826c <fft_window_gen+0x34>
  }

  switch (fft_window->fft_size)
  {
  case FFT_SIZE_16:
	  fft_window->fft_time_twiddle_table = &arm_cfft_sR_f32_len16;		/* as FFT_SIZE = 16 points */
 80282a6:	4ba5      	ldr	r3, [pc, #660]	; (802853c <fft_window_gen+0x304>)
 80282a8:	6103      	str	r3, [r0, #16]
	  break;
 80282aa:	e7df      	b.n	802826c <fft_window_gen+0x34>
  case FFT_SIZE_64:
	  fft_window->fft_time_twiddle_table  = &arm_cfft_sR_f32_len64;		/* as FFT_SIZE = 64 points */
	  break;

  case FFT_SIZE_128:
	  fft_window->fft_time_twiddle_table  = &arm_cfft_sR_f32_len128;	/* as FFT_SIZE = 128 points */
 80282ac:	4ba4      	ldr	r3, [pc, #656]	; (8028540 <fft_window_gen+0x308>)
 80282ae:	6103      	str	r3, [r0, #16]
	  break;
 80282b0:	e7dc      	b.n	802826c <fft_window_gen+0x34>
}

/*-------------------- fft_window_init_chebyshev() -----------------------*/
static uint8_t fft_window_init_chebyshev(uint32_t window_size, float *window_buffer, float at_dB)
{
  if (window_size == 1)
 80282b2:	f1b9 0f01 	cmp.w	r9, #1
 80282b6:	f000 81dc 	beq.w	8028672 <fft_window_gen+0x43a>
  {
	window_buffer[0] = 1;
  }
  else
  {
    float pssbnd_ripple = powf(10.0f, at_dB / 20.0f);
 80282ba:	eeb3 7a04 	vmov.f32	s14, #52	; 0x34
 80282be:	eec7 7a87 	vdiv.f32	s15, s15, s14
 80282c2:	48a0      	ldr	r0, [pc, #640]	; (8028544 <fft_window_gen+0x30c>)
    {
      win_even = win_even + 0.5f;
    }

    float max_val = 0;
    for (uint32_t j = 0; j < (window_size / 2 + 1); ++j)
 80282c4:	ed9f baa0 	vldr	s22, [pc, #640]	; 8028548 <fft_window_gen+0x310>
  {
	window_buffer[0] = 1;
  }
  else
  {
    float pssbnd_ripple = powf(10.0f, at_dB / 20.0f);
 80282c8:	ee17 1a90 	vmov	r1, s15
 80282cc:	f002 fca8 	bl	802ac20 <powf>
    float alpha = coshf((1.0f / (float)(window_size - 1)) * acoshf(pssbnd_ripple));
 80282d0:	ee07 4a90 	vmov	s15, r4
 80282d4:	eeb8 aae7 	vcvt.f32.s32	s20, s15
  {
	window_buffer[0] = 1;
  }
  else
  {
    float pssbnd_ripple = powf(10.0f, at_dB / 20.0f);
 80282d8:	ee0b 0a90 	vmov	s23, r0
    float alpha = coshf((1.0f / (float)(window_size - 1)) * acoshf(pssbnd_ripple));
 80282dc:	f002 fbf0 	bl	802aac0 <acoshf>
 80282e0:	eef7 7a00 	vmov.f32	s15, #112	; 0x70
 80282e4:	eec7 7a8a 	vdiv.f32	s15, s15, s20
    float win_even = (float)((window_size - 1) / 2);
 80282e8:	0864      	lsrs	r4, r4, #1
	window_buffer[0] = 1;
  }
  else
  {
    float pssbnd_ripple = powf(10.0f, at_dB / 20.0f);
    float alpha = coshf((1.0f / (float)(window_size - 1)) * acoshf(pssbnd_ripple));
 80282ea:	ee07 0a10 	vmov	s14, r0
 80282ee:	ee67 7a87 	vmul.f32	s15, s15, s14
    for (uint32_t j = 0; j < (window_size / 2 + 1); ++j)
    {
      float n = j - win_even;
      float sum = 0;

      for (uint32_t i = 1; i <= win_even; ++i)
 80282f2:	eef7 9a00 	vmov.f32	s19, #112	; 0x70
	window_buffer[0] = 1;
  }
  else
  {
    float pssbnd_ripple = powf(10.0f, at_dB / 20.0f);
    float alpha = coshf((1.0f / (float)(window_size - 1)) * acoshf(pssbnd_ripple));
 80282f6:	ee17 0a90 	vmov	r0, s15
 80282fa:	f002 fc39 	bl	802ab70 <coshf>
    float win_even = (float)((window_size - 1) / 2);
 80282fe:	ee07 4a90 	vmov	s15, r4
    {
      win_even = win_even + 0.5f;
    }

    float max_val = 0;
    for (uint32_t j = 0; j < (window_size / 2 + 1); ++j)
 8028302:	ea4f 0359 	mov.w	r3, r9, lsr #1
  {
    float pssbnd_ripple = powf(10.0f, at_dB / 20.0f);
    float alpha = coshf((1.0f / (float)(window_size - 1)) * acoshf(pssbnd_ripple));
    float win_even = (float)((window_size - 1) / 2);

    if (window_size % 2 == 0)
 8028306:	f019 0f01 	tst.w	r9, #1
 802830a:	ea4f 0289 	mov.w	r2, r9, lsl #2
  }
  else
  {
    float pssbnd_ripple = powf(10.0f, at_dB / 20.0f);
    float alpha = coshf((1.0f / (float)(window_size - 1)) * acoshf(pssbnd_ripple));
    float win_even = (float)((window_size - 1) / 2);
 802830e:	eeb8 8ae7 	vcvt.f32.s32	s16, s15
    {
      win_even = win_even + 0.5f;
    }

    float max_val = 0;
    for (uint32_t j = 0; j < (window_size / 2 + 1); ++j)
 8028312:	f103 0301 	add.w	r3, r3, #1
    float alpha = coshf((1.0f / (float)(window_size - 1)) * acoshf(pssbnd_ripple));
    float win_even = (float)((window_size - 1) / 2);

    if (window_size % 2 == 0)
    {
      win_even = win_even + 0.5f;
 8028316:	bf08      	it	eq
 8028318:	eef6 7a00 	vmoveq.f32	s15, #96	; 0x60
    }

    float max_val = 0;
    for (uint32_t j = 0; j < (window_size / 2 + 1); ++j)
 802831c:	9302      	str	r3, [sp, #8]
 802831e:	eb0a 0302 	add.w	r3, sl, r2
 8028322:	9300      	str	r3, [sp, #0]
	window_buffer[0] = 1;
  }
  else
  {
    float pssbnd_ripple = powf(10.0f, at_dB / 20.0f);
    float alpha = coshf((1.0f / (float)(window_size - 1)) * acoshf(pssbnd_ripple));
 8028324:	ee0a 0a90 	vmov	s21, r0
    {
      win_even = win_even + 0.5f;
    }

    float max_val = 0;
    for (uint32_t j = 0; j < (window_size / 2 + 1); ++j)
 8028328:	f04f 0300 	mov.w	r3, #0
    float alpha = coshf((1.0f / (float)(window_size - 1)) * acoshf(pssbnd_ripple));
    float win_even = (float)((window_size - 1) / 2);

    if (window_size % 2 == 0)
    {
      win_even = win_even + 0.5f;
 802832c:	bf08      	it	eq
 802832e:	ee38 8a27 	vaddeq.f32	s16, s16, s15
    for (uint32_t j = 0; j < (window_size / 2 + 1); ++j)
    {
      float n = j - win_even;
      float sum = 0;

      for (uint32_t i = 1; i <= win_even; ++i)
 8028332:	f8cd 900c 	str.w	r9, [sp, #12]
 8028336:	9204      	str	r2, [sp, #16]
 8028338:	f8cd a014 	str.w	sl, [sp, #20]
 802833c:	4699      	mov	r9, r3
 802833e:	f8cd a004 	str.w	sl, [sp, #4]
    }

    float max_val = 0;
    for (uint32_t j = 0; j < (window_size / 2 + 1); ++j)
    {
      float n = j - win_even;
 8028342:	ee07 9a90 	vmov	s15, r9
      float sum = 0;

      for (uint32_t i = 1; i <= win_even; ++i)
 8028346:	eeb4 8ae9 	vcmpe.f32	s16, s19
    }

    float max_val = 0;
    for (uint32_t j = 0; j < (window_size / 2 + 1); ++j)
    {
      float n = j - win_even;
 802834a:	eeb8 9ae7 	vcvt.f32.s32	s18, s15
      float sum = 0;

      for (uint32_t i = 1; i <= win_even; ++i)
 802834e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    }

    float max_val = 0;
    for (uint32_t j = 0; j < (window_size / 2 + 1); ++j)
    {
      float n = j - win_even;
 8028352:	ee39 9a48 	vsub.f32	s18, s18, s16
      float sum = 0;

      for (uint32_t i = 1; i <= win_even; ++i)
 8028356:	f2c0 8192 	blt.w	802867e <fft_window_gen+0x446>
 802835a:	9c03      	ldr	r4, [sp, #12]
 802835c:	eddf 8a7a 	vldr	s17, [pc, #488]	; 8028548 <fft_window_gen+0x310>
 8028360:	4620      	mov	r0, r4
 8028362:	f004 fa93 	bl	802c88c <__aeabi_ui2d>
 8028366:	ee79 7a09 	vadd.f32	s15, s18, s18
 802836a:	4682      	mov	sl, r0
 802836c:	ee17 5a90 	vmov	r5, s15
 8028370:	ee07 4a90 	vmov	s15, r4
 8028374:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8028378:	468b      	mov	fp, r1
 802837a:	ee17 8a90 	vmov	r8, s15
 802837e:	2401      	movs	r4, #1
 8028380:	e037      	b.n	80283f2 <fft_window_gen+0x1ba>
  {
    ret = arm_cos_f32( size * acosf(poly_order));
  }
  else
  {
   	  ret = coshf( size * acoshf(poly_order)); 
 8028382:	f002 fb9d 	bl	802aac0 <acoshf>
 8028386:	ee07 0a90 	vmov	s15, r0
 802838a:	ee6a 7a27 	vmul.f32	s15, s20, s15
 802838e:	ee17 0a90 	vmov	r0, s15
 8028392:	f002 fbed 	bl	802ab70 <coshf>
 8028396:	ee09 0a10 	vmov	s18, r0

      for (uint32_t i = 1; i <= win_even; ++i)
      {
       	float poly_order = alpha * arm_cos_f32( (M_PI * i) / window_size);
       	float res = cheby_poly( window_size - 1, poly_order);
        sum += res * arm_cos_f32( 2.0f * n * M_PI * i / (float)window_size );
 802839a:	4628      	mov	r0, r5
 802839c:	f004 fa98 	bl	802c8d0 <__aeabi_f2d>
 80283a0:	a35f      	add	r3, pc, #380	; (adr r3, 8028520 <fft_window_gen+0x2e8>)
 80283a2:	e9d3 2300 	ldrd	r2, r3, [r3]
 80283a6:	f004 fae7 	bl	802c978 <__aeabi_dmul>
 80283aa:	4602      	mov	r2, r0
 80283ac:	460b      	mov	r3, r1
 80283ae:	4630      	mov	r0, r6
 80283b0:	4639      	mov	r1, r7
 80283b2:	f004 fae1 	bl	802c978 <__aeabi_dmul>
 80283b6:	4606      	mov	r6, r0
 80283b8:	4640      	mov	r0, r8
 80283ba:	460f      	mov	r7, r1
 80283bc:	f004 fa88 	bl	802c8d0 <__aeabi_f2d>
 80283c0:	4602      	mov	r2, r0
 80283c2:	460b      	mov	r3, r1
 80283c4:	4630      	mov	r0, r6
 80283c6:	4639      	mov	r1, r7
 80283c8:	f004 fc00 	bl	802cbcc <__aeabi_ddiv>
 80283cc:	f004 fd8e 	bl	802ceec <__aeabi_d2f>
    for (uint32_t j = 0; j < (window_size / 2 + 1); ++j)
    {
      float n = j - win_even;
      float sum = 0;

      for (uint32_t i = 1; i <= win_even; ++i)
 80283d0:	3401      	adds	r4, #1
      {
       	float poly_order = alpha * arm_cos_f32( (M_PI * i) / window_size);
       	float res = cheby_poly( window_size - 1, poly_order);
        sum += res * arm_cos_f32( 2.0f * n * M_PI * i / (float)window_size );
 80283d2:	f7ff fa3b 	bl	802784c <arm_cos_f32>
    for (uint32_t j = 0; j < (window_size / 2 + 1); ++j)
    {
      float n = j - win_even;
      float sum = 0;

      for (uint32_t i = 1; i <= win_even; ++i)
 80283d6:	ee07 4a90 	vmov	s15, r4
 80283da:	eef8 7a67 	vcvt.f32.u32	s15, s15
      {
       	float poly_order = alpha * arm_cos_f32( (M_PI * i) / window_size);
       	float res = cheby_poly( window_size - 1, poly_order);
        sum += res * arm_cos_f32( 2.0f * n * M_PI * i / (float)window_size );
 80283de:	ee07 0a10 	vmov	s14, r0
    for (uint32_t j = 0; j < (window_size / 2 + 1); ++j)
    {
      float n = j - win_even;
      float sum = 0;

      for (uint32_t i = 1; i <= win_even; ++i)
 80283e2:	eeb4 8ae7 	vcmpe.f32	s16, s15
 80283e6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
      {
       	float poly_order = alpha * arm_cos_f32( (M_PI * i) / window_size);
       	float res = cheby_poly( window_size - 1, poly_order);
        sum += res * arm_cos_f32( 2.0f * n * M_PI * i / (float)window_size );
 80283ea:	eee7 8a09 	vfma.f32	s17, s14, s18
    for (uint32_t j = 0; j < (window_size / 2 + 1); ++j)
    {
      float n = j - win_even;
      float sum = 0;

      for (uint32_t i = 1; i <= win_even; ++i)
 80283ee:	f2c0 8116 	blt.w	802861e <fft_window_gen+0x3e6>
      {
       	float poly_order = alpha * arm_cos_f32( (M_PI * i) / window_size);
 80283f2:	4620      	mov	r0, r4
 80283f4:	f004 fa4a 	bl	802c88c <__aeabi_ui2d>
 80283f8:	a349      	add	r3, pc, #292	; (adr r3, 8028520 <fft_window_gen+0x2e8>)
 80283fa:	e9d3 2300 	ldrd	r2, r3, [r3]
 80283fe:	4606      	mov	r6, r0
 8028400:	460f      	mov	r7, r1
 8028402:	f004 fab9 	bl	802c978 <__aeabi_dmul>
 8028406:	4652      	mov	r2, sl
 8028408:	465b      	mov	r3, fp
 802840a:	f004 fbdf 	bl	802cbcc <__aeabi_ddiv>
 802840e:	f004 fd6d 	bl	802ceec <__aeabi_d2f>
 8028412:	f7ff fa1b 	bl	802784c <arm_cos_f32>
 8028416:	ee07 0a90 	vmov	s15, r0
 802841a:	ee6a 7aa7 	vmul.f32	s15, s21, s15
/*----------------------------- cheby_poly() -----------------------------*/
static float cheby_poly(const uint32_t size, const float poly_order)
{
  float ret = 0;

  if (fabsf(poly_order) <= 1)
 802841e:	eeb0 7ae7 	vabs.f32	s14, s15
 8028422:	eeb4 7ae9 	vcmpe.f32	s14, s19
 8028426:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  {
    ret = arm_cos_f32( size * acosf(poly_order));
  }
  else
  {
   	  ret = coshf( size * acoshf(poly_order)); 
 802842a:	ee17 0a90 	vmov	r0, s15
/*----------------------------- cheby_poly() -----------------------------*/
static float cheby_poly(const uint32_t size, const float poly_order)
{
  float ret = 0;

  if (fabsf(poly_order) <= 1)
 802842e:	d8a8      	bhi.n	8028382 <fft_window_gen+0x14a>
  {
    ret = arm_cos_f32( size * acosf(poly_order));
 8028430:	f002 faf4 	bl	802aa1c <acosf>
 8028434:	ee07 0a90 	vmov	s15, r0
 8028438:	ee6a 7a27 	vmul.f32	s15, s20, s15
 802843c:	ee17 0a90 	vmov	r0, s15
 8028440:	f7ff fa04 	bl	802784c <arm_cos_f32>
 8028444:	ee09 0a10 	vmov	s18, r0
 8028448:	e7a7      	b.n	802839a <fft_window_gen+0x162>
}

/*----------------------- fft_window_init_hanning() ----------------------*/
static uint8_t fft_window_init_hanning(uint32_t window_size, float *window_buffer)
{
  if (window_size == 1)
 802844a:	f1b9 0f01 	cmp.w	r9, #1
 802844e:	f000 8110 	beq.w	8028672 <fft_window_gen+0x43a>
 8028452:	ee07 4a90 	vmov	s15, r4
 8028456:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 802845a:	4655      	mov	r5, sl
 802845c:	ee17 0a90 	vmov	r0, s15
 8028460:	f004 fa36 	bl	802c8d0 <__aeabi_f2d>
 8028464:	2400      	movs	r4, #0
 8028466:	4606      	mov	r6, r0
 8028468:	460f      	mov	r7, r1
  }
  else
  {
    for (uint32_t i = 0; i < window_size; ++i)
    {
      window_buffer[i] = 0.5f * (1.0f - arm_cos_f32(2 * M_PI * (float)i / (float)(window_size - 1)));
 802846a:	eef7 8a00 	vmov.f32	s17, #112	; 0x70
 802846e:	eeb6 8a00 	vmov.f32	s16, #96	; 0x60
 8028472:	ee07 4a90 	vmov	s15, r4
 8028476:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  {
	window_buffer[0] = 1;
  }
  else
  {
    for (uint32_t i = 0; i < window_size; ++i)
 802847a:	3401      	adds	r4, #1
    {
      window_buffer[i] = 0.5f * (1.0f - arm_cos_f32(2 * M_PI * (float)i / (float)(window_size - 1)));
 802847c:	ee17 0a90 	vmov	r0, s15
 8028480:	f004 fa26 	bl	802c8d0 <__aeabi_f2d>
 8028484:	a328      	add	r3, pc, #160	; (adr r3, 8028528 <fft_window_gen+0x2f0>)
 8028486:	e9d3 2300 	ldrd	r2, r3, [r3]
 802848a:	f004 fa75 	bl	802c978 <__aeabi_dmul>
 802848e:	4632      	mov	r2, r6
 8028490:	463b      	mov	r3, r7
 8028492:	f004 fb9b 	bl	802cbcc <__aeabi_ddiv>
 8028496:	f004 fd29 	bl	802ceec <__aeabi_d2f>
 802849a:	f7ff f9d7 	bl	802784c <arm_cos_f32>
 802849e:	ee07 0a90 	vmov	s15, r0
 80284a2:	ee78 7ae7 	vsub.f32	s15, s17, s15
  {
	window_buffer[0] = 1;
  }
  else
  {
    for (uint32_t i = 0; i < window_size; ++i)
 80284a6:	454c      	cmp	r4, r9
    {
      window_buffer[i] = 0.5f * (1.0f - arm_cos_f32(2 * M_PI * (float)i / (float)(window_size - 1)));
 80284a8:	ee67 7a88 	vmul.f32	s15, s15, s16
 80284ac:	ece5 7a01 	vstmia	r5!, {s15}
  {
	window_buffer[0] = 1;
  }
  else
  {
    for (uint32_t i = 0; i < window_size; ++i)
 80284b0:	d1df      	bne.n	8028472 <fft_window_gen+0x23a>
  }

  switch (window_type)
  {
  case FFT_WINDOW_HAMM:
	  return fft_window_init_hamming(window_size, window_buffer);
 80284b2:	2001      	movs	r0, #1
 80284b4:	e6e7      	b.n	8028286 <fft_window_gen+0x4e>
 */

/*--------------------- fft_window_init_hamming() ------------------------*/
static uint8_t fft_window_init_hamming(uint32_t window_size, float *window_buffer)
{
  if (window_size == 1)
 80284b6:	f1b9 0f01 	cmp.w	r9, #1
 80284ba:	f000 80da 	beq.w	8028672 <fft_window_gen+0x43a>
 80284be:	ee07 4a90 	vmov	s15, r4
 80284c2:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  }
  else
  {
    for (uint32_t i = 0; i < window_size; ++i)
    {
      window_buffer[i] = 0.54f - 0.46f * arm_cos_f32(2.0f * M_PI * (float)i / (float)(window_size - 1));
 80284c6:	eddf 8a21 	vldr	s17, [pc, #132]	; 802854c <fft_window_gen+0x314>
 80284ca:	ed9f 8a21 	vldr	s16, [pc, #132]	; 8028550 <fft_window_gen+0x318>
 80284ce:	ee17 0a90 	vmov	r0, s15
 80284d2:	f004 f9fd 	bl	802c8d0 <__aeabi_f2d>
 80284d6:	4655      	mov	r5, sl
 80284d8:	4606      	mov	r6, r0
 80284da:	460f      	mov	r7, r1
 */

/*--------------------- fft_window_init_hamming() ------------------------*/
static uint8_t fft_window_init_hamming(uint32_t window_size, float *window_buffer)
{
  if (window_size == 1)
 80284dc:	2400      	movs	r4, #0
  }
  else
  {
    for (uint32_t i = 0; i < window_size; ++i)
    {
      window_buffer[i] = 0.54f - 0.46f * arm_cos_f32(2.0f * M_PI * (float)i / (float)(window_size - 1));
 80284de:	ee07 4a90 	vmov	s15, r4
 80284e2:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  {
	window_buffer[0] = 1;
  }
  else
  {
    for (uint32_t i = 0; i < window_size; ++i)
 80284e6:	3401      	adds	r4, #1
    {
      window_buffer[i] = 0.54f - 0.46f * arm_cos_f32(2.0f * M_PI * (float)i / (float)(window_size - 1));
 80284e8:	ee17 0a90 	vmov	r0, s15
 80284ec:	f004 f9f0 	bl	802c8d0 <__aeabi_f2d>
 80284f0:	a30d      	add	r3, pc, #52	; (adr r3, 8028528 <fft_window_gen+0x2f0>)
 80284f2:	e9d3 2300 	ldrd	r2, r3, [r3]
 80284f6:	f004 fa3f 	bl	802c978 <__aeabi_dmul>
 80284fa:	4632      	mov	r2, r6
 80284fc:	463b      	mov	r3, r7
 80284fe:	f004 fb65 	bl	802cbcc <__aeabi_ddiv>
 8028502:	f004 fcf3 	bl	802ceec <__aeabi_d2f>
 8028506:	f7ff f9a1 	bl	802784c <arm_cos_f32>
 802850a:	ee07 0a10 	vmov	s14, r0
 802850e:	eef0 7a48 	vmov.f32	s15, s16
 8028512:	eee7 7a68 	vfms.f32	s15, s14, s17
  {
	window_buffer[0] = 1;
  }
  else
  {
    for (uint32_t i = 0; i < window_size; ++i)
 8028516:	454c      	cmp	r4, r9
    {
      window_buffer[i] = 0.54f - 0.46f * arm_cos_f32(2.0f * M_PI * (float)i / (float)(window_size - 1));
 8028518:	ece5 7a01 	vstmia	r5!, {s15}
  {
	window_buffer[0] = 1;
  }
  else
  {
    for (uint32_t i = 0; i < window_size; ++i)
 802851c:	d1df      	bne.n	80284de <fft_window_gen+0x2a6>
 802851e:	e7c8      	b.n	80284b2 <fft_window_gen+0x27a>
 8028520:	54442d18 	.word	0x54442d18
 8028524:	400921fb 	.word	0x400921fb
 8028528:	54442d18 	.word	0x54442d18
 802852c:	401921fb 	.word	0x401921fb
 8028530:	080316d8 	.word	0x080316d8
 8028534:	080316c8 	.word	0x080316c8
 8028538:	08031698 	.word	0x08031698
 802853c:	080316b8 	.word	0x080316b8
 8028540:	080316a8 	.word	0x080316a8
 8028544:	41200000 	.word	0x41200000
 8028548:	00000000 	.word	0x00000000
 802854c:	3eeb851f 	.word	0x3eeb851f
 8028550:	3f0a3d71 	.word	0x3f0a3d71
 8028554:	3efa0126 	.word	0x3efa0126
 8028558:	3eb7ae14 	.word	0x3eb7ae14
 802855c:	3e10abb4 	.word	0x3e10abb4
}

/*----------------- fft_window_init_blackmanharris() ---------------------*/
static uint8_t fft_window_init_blackmanharris(uint32_t window_size, float *window_buffer)
{
  if (window_size == 1)
 8028560:	f1b9 0f01 	cmp.w	r9, #1
 8028564:	f000 8085 	beq.w	8028672 <fft_window_gen+0x43a>
 8028568:	4620      	mov	r0, r4
 802856a:	f004 f98f 	bl	802c88c <__aeabi_ui2d>
    const float a3 = 0.01168f;

   for (uint32_t i = 0; i < window_size; ++i)
   {
	 window_buffer[i] = a0
                        - (a1 * arm_cos_f32( (2.0f * M_PI * (float)i) / (window_size - 1) ))
 802856e:	ed5f 9a07 	vldr	s19, [pc, #-28]	; 8028554 <fft_window_gen+0x31c>
 8028572:	ed1f 9a07 	vldr	s18, [pc, #-28]	; 8028558 <fft_window_gen+0x320>
                        + (a2 * arm_cos_f32( (4.0f * M_PI * (float)i) / (window_size - 1) ))
 8028576:	ed5f 8a07 	vldr	s17, [pc, #-28]	; 802855c <fft_window_gen+0x324>
 802857a:	4604      	mov	r4, r0
 802857c:	460d      	mov	r5, r1
}

/*----------------- fft_window_init_blackmanharris() ---------------------*/
static uint8_t fft_window_init_blackmanharris(uint32_t window_size, float *window_buffer)
{
  if (window_size == 1)
 802857e:	f04f 0800 	mov.w	r8, #0
    const float a3 = 0.01168f;

   for (uint32_t i = 0; i < window_size; ++i)
   {
	 window_buffer[i] = a0
                        - (a1 * arm_cos_f32( (2.0f * M_PI * (float)i) / (window_size - 1) ))
 8028582:	ee07 8a90 	vmov	s15, r8
 8028586:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    const float a0 = 0.35875f;
    const float a1 = 0.48829f;
    const float a2 = 0.14128f;
    const float a3 = 0.01168f;

   for (uint32_t i = 0; i < window_size; ++i)
 802858a:	f108 0801 	add.w	r8, r8, #1
   {
	 window_buffer[i] = a0
                        - (a1 * arm_cos_f32( (2.0f * M_PI * (float)i) / (window_size - 1) ))
 802858e:	ee17 0a90 	vmov	r0, s15
 8028592:	f004 f99d 	bl	802c8d0 <__aeabi_f2d>
 8028596:	a33e      	add	r3, pc, #248	; (adr r3, 8028690 <fft_window_gen+0x458>)
 8028598:	e9d3 2300 	ldrd	r2, r3, [r3]
 802859c:	4606      	mov	r6, r0
 802859e:	460f      	mov	r7, r1
 80285a0:	f004 f9ea 	bl	802c978 <__aeabi_dmul>
 80285a4:	4622      	mov	r2, r4
 80285a6:	462b      	mov	r3, r5
 80285a8:	f004 fb10 	bl	802cbcc <__aeabi_ddiv>
 80285ac:	f004 fc9e 	bl	802ceec <__aeabi_d2f>
 80285b0:	f7ff f94c 	bl	802784c <arm_cos_f32>
                        + (a2 * arm_cos_f32( (4.0f * M_PI * (float)i) / (window_size - 1) ))
 80285b4:	a338      	add	r3, pc, #224	; (adr r3, 8028698 <fft_window_gen+0x460>)
 80285b6:	e9d3 2300 	ldrd	r2, r3, [r3]
    const float a3 = 0.01168f;

   for (uint32_t i = 0; i < window_size; ++i)
   {
	 window_buffer[i] = a0
                        - (a1 * arm_cos_f32( (2.0f * M_PI * (float)i) / (window_size - 1) ))
 80285ba:	ee08 0a10 	vmov	s16, r0
                        + (a2 * arm_cos_f32( (4.0f * M_PI * (float)i) / (window_size - 1) ))
 80285be:	4639      	mov	r1, r7
 80285c0:	4630      	mov	r0, r6
 80285c2:	f004 f9d9 	bl	802c978 <__aeabi_dmul>
 80285c6:	4622      	mov	r2, r4
 80285c8:	462b      	mov	r3, r5
 80285ca:	f004 faff 	bl	802cbcc <__aeabi_ddiv>
 80285ce:	f004 fc8d 	bl	802ceec <__aeabi_d2f>
 80285d2:	f7ff f93b 	bl	802784c <arm_cos_f32>
    const float a3 = 0.01168f;

   for (uint32_t i = 0; i < window_size; ++i)
   {
	 window_buffer[i] = a0
                        - (a1 * arm_cos_f32( (2.0f * M_PI * (float)i) / (window_size - 1) ))
 80285d6:	eef0 7a49 	vmov.f32	s15, s18
 80285da:	eee8 7a69 	vfms.f32	s15, s16, s19
                        + (a2 * arm_cos_f32( (4.0f * M_PI * (float)i) / (window_size - 1) ))
                        - (a3 * arm_cos_f32( (6.0f * M_PI * (float)i) / (window_size - 1) ));
 80285de:	a330      	add	r3, pc, #192	; (adr r3, 80286a0 <fft_window_gen+0x468>)
 80285e0:	e9d3 2300 	ldrd	r2, r3, [r3]
    const float a3 = 0.01168f;

   for (uint32_t i = 0; i < window_size; ++i)
   {
	 window_buffer[i] = a0
                        - (a1 * arm_cos_f32( (2.0f * M_PI * (float)i) / (window_size - 1) ))
 80285e4:	eeb0 8a67 	vmov.f32	s16, s15
                        + (a2 * arm_cos_f32( (4.0f * M_PI * (float)i) / (window_size - 1) ))
 80285e8:	ee07 0a90 	vmov	s15, r0
                        - (a3 * arm_cos_f32( (6.0f * M_PI * (float)i) / (window_size - 1) ));
 80285ec:	4639      	mov	r1, r7
 80285ee:	4630      	mov	r0, r6

   for (uint32_t i = 0; i < window_size; ++i)
   {
	 window_buffer[i] = a0
                        - (a1 * arm_cos_f32( (2.0f * M_PI * (float)i) / (window_size - 1) ))
                        + (a2 * arm_cos_f32( (4.0f * M_PI * (float)i) / (window_size - 1) ))
 80285f0:	eea7 8aa8 	vfma.f32	s16, s15, s17
                        - (a3 * arm_cos_f32( (6.0f * M_PI * (float)i) / (window_size - 1) ));
 80285f4:	f004 f9c0 	bl	802c978 <__aeabi_dmul>
 80285f8:	4622      	mov	r2, r4
 80285fa:	462b      	mov	r3, r5
 80285fc:	f004 fae6 	bl	802cbcc <__aeabi_ddiv>
 8028600:	f004 fc74 	bl	802ceec <__aeabi_d2f>
 8028604:	f7ff f922 	bl	802784c <arm_cos_f32>
 8028608:	eddf 7a1f 	vldr	s15, [pc, #124]	; 8028688 <fft_window_gen+0x450>
 802860c:	ee07 0a10 	vmov	s14, r0
 8028610:	eea7 8a67 	vfms.f32	s16, s14, s15
    const float a0 = 0.35875f;
    const float a1 = 0.48829f;
    const float a2 = 0.14128f;
    const float a3 = 0.01168f;

   for (uint32_t i = 0; i < window_size; ++i)
 8028614:	45c8      	cmp	r8, r9
   {
	 window_buffer[i] = a0
 8028616:	ecaa 8a01 	vstmia	sl!, {s16}
    const float a0 = 0.35875f;
    const float a1 = 0.48829f;
    const float a2 = 0.14128f;
    const float a3 = 0.01168f;

   for (uint32_t i = 0; i < window_size; ++i)
 802861a:	d1b2      	bne.n	8028582 <fft_window_gen+0x34a>
 802861c:	e749      	b.n	80284b2 <fft_window_gen+0x27a>
 802861e:	ee78 8aa8 	vadd.f32	s17, s17, s17
       	float poly_order = alpha * arm_cos_f32( (M_PI * i) / window_size);
       	float res = cheby_poly( window_size - 1, poly_order);
        sum += res * arm_cos_f32( 2.0f * n * M_PI * i / (float)window_size );
      }

      window_buffer[j] = pssbnd_ripple + 2 * sum;
 8028622:	9a01      	ldr	r2, [sp, #4]
      window_buffer[window_size - j - 1] = window_buffer[j];
 8028624:	9b00      	ldr	r3, [sp, #0]
       	float poly_order = alpha * arm_cos_f32( (M_PI * i) / window_size);
       	float res = cheby_poly( window_size - 1, poly_order);
        sum += res * arm_cos_f32( 2.0f * n * M_PI * i / (float)window_size );
      }

      window_buffer[j] = pssbnd_ripple + 2 * sum;
 8028626:	ee7b 8aa8 	vadd.f32	s17, s23, s17
    {
      win_even = win_even + 0.5f;
    }

    float max_val = 0;
    for (uint32_t j = 0; j < (window_size / 2 + 1); ++j)
 802862a:	f109 0901 	add.w	r9, r9, #1
       	float poly_order = alpha * arm_cos_f32( (M_PI * i) / window_size);
       	float res = cheby_poly( window_size - 1, poly_order);
        sum += res * arm_cos_f32( 2.0f * n * M_PI * i / (float)window_size );
      }

      window_buffer[j] = pssbnd_ripple + 2 * sum;
 802862e:	edc2 8a00 	vstr	s17, [r2]
      window_buffer[window_size - j - 1] = window_buffer[j];
 8028632:	ed63 8a01 	vstmdb	r3!, {s17}
 8028636:	9300      	str	r3, [sp, #0]

      if (window_buffer[j] > max_val)
 8028638:	4613      	mov	r3, r2
 802863a:	ecf3 7a01 	vldmia	r3!, {s15}
      {
        max_val = window_buffer[j];
 802863e:	eeb4 ba67 	vcmp.f32	s22, s15
      }

      window_buffer[j] = pssbnd_ripple + 2 * sum;
      window_buffer[window_size - j - 1] = window_buffer[j];

      if (window_buffer[j] > max_val)
 8028642:	9301      	str	r3, [sp, #4]
    {
      win_even = win_even + 0.5f;
    }

    float max_val = 0;
    for (uint32_t j = 0; j < (window_size / 2 + 1); ++j)
 8028644:	9b02      	ldr	r3, [sp, #8]
      window_buffer[j] = pssbnd_ripple + 2 * sum;
      window_buffer[window_size - j - 1] = window_buffer[j];

      if (window_buffer[j] > max_val)
      {
        max_val = window_buffer[j];
 8028646:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802864a:	bf48      	it	mi
 802864c:	eeb0 ba67 	vmovmi.f32	s22, s15
    {
      win_even = win_even + 0.5f;
    }

    float max_val = 0;
    for (uint32_t j = 0; j < (window_size / 2 + 1); ++j)
 8028650:	4599      	cmp	r9, r3
 8028652:	f47f ae76 	bne.w	8028342 <fft_window_gen+0x10a>
 8028656:	f8dd a014 	ldr.w	sl, [sp, #20]
 802865a:	9a04      	ldr	r2, [sp, #16]
 802865c:	4653      	mov	r3, sl
 802865e:	4452      	add	r2, sl
      }
    }

    for (uint32_t j = 0; j < window_size; ++j)
    {
      window_buffer[j] /= max_val;
 8028660:	edd3 7a00 	vldr	s15, [r3]
 8028664:	eec7 7a8b 	vdiv.f32	s15, s15, s22
 8028668:	ece3 7a01 	vstmia	r3!, {s15}
      {
        max_val = window_buffer[j];
      }
    }

    for (uint32_t j = 0; j < window_size; ++j)
 802866c:	4293      	cmp	r3, r2
 802866e:	d1f7      	bne.n	8028660 <fft_window_gen+0x428>
 8028670:	e71f      	b.n	80284b2 <fft_window_gen+0x27a>
/*-------------------- fft_window_init_chebyshev() -----------------------*/
static uint8_t fft_window_init_chebyshev(uint32_t window_size, float *window_buffer, float at_dB)
{
  if (window_size == 1)
  {
	window_buffer[0] = 1;
 8028672:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
  case FFT_WINDOW_BLACKMANHARRIS:
	  return fft_window_init_blackmanharris(window_size, window_buffer);
	  break;

  case FFT_WINDOW_CHEBYSHEV:
	  return fft_window_init_chebyshev(window_size, window_buffer, at_dB);
 8028676:	4648      	mov	r0, r9
/*-------------------- fft_window_init_chebyshev() -----------------------*/
static uint8_t fft_window_init_chebyshev(uint32_t window_size, float *window_buffer, float at_dB)
{
  if (window_size == 1)
  {
	window_buffer[0] = 1;
 8028678:	f8ca 3000 	str.w	r3, [sl]
 802867c:	e603      	b.n	8028286 <fft_window_gen+0x4e>
    for (uint32_t j = 0; j < (window_size / 2 + 1); ++j)
    {
      float n = j - win_even;
      float sum = 0;

      for (uint32_t i = 1; i <= win_even; ++i)
 802867e:	eddf 8a03 	vldr	s17, [pc, #12]	; 802868c <fft_window_gen+0x454>
 8028682:	e7ce      	b.n	8028622 <fft_window_gen+0x3ea>
 8028684:	f3af 8000 	nop.w
 8028688:	3c3f5d79 	.word	0x3c3f5d79
 802868c:	00000000 	.word	0x00000000
 8028690:	54442d18 	.word	0x54442d18
 8028694:	401921fb 	.word	0x401921fb
 8028698:	54442d18 	.word	0x54442d18
 802869c:	402921fb 	.word	0x402921fb
 80286a0:	7f3321d2 	.word	0x7f3321d2
 80286a4:	4032d97c 	.word	0x4032d97c

080286a8 <compute_fft_signal>:

/*-------------------------- compute_fft_signal() --------------------------*/
void compute_fft_signal(FFT_Window_Struct_t fft_window, float* i_data, float* q_data, uint16_t Nd,
		                uint16_t Nf, float if_scale, FFT_Input_t fft_type,
						float* p_i_mean, float* p_q_mean, float* complex_fft_signal)
{
 80286a8:	b084      	sub	sp, #16
 80286aa:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80286ae:	ed2d 8b02 	vpush	{d8}
 80286b2:	b087      	sub	sp, #28
 80286b4:	ac12      	add	r4, sp, #72	; 0x48
 80286b6:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
 80286ba:	9e1f      	ldr	r6, [sp, #124]	; 0x7c
	float i_mean = 0.0f;
	float q_mean = 0.0f;
	uint32_t idx;
	float *fft_window_buffer = fft_window.fft_window_buffer;
 80286bc:	f8dd b054 	ldr.w	fp, [sp, #84]	; 0x54

/*-------------------------- compute_fft_signal() --------------------------*/
void compute_fft_signal(FFT_Window_Struct_t fft_window, float* i_data, float* q_data, uint16_t Nd,
		                uint16_t Nf, float if_scale, FFT_Input_t fft_type,
						float* p_i_mean, float* p_q_mean, float* complex_fft_signal)
{
 80286c0:	f8bd 4064 	ldrh.w	r4, [sp, #100]	; 0x64
 80286c4:	f8bd 7068 	ldrh.w	r7, [sp, #104]	; 0x68
 80286c8:	ed9d 8a1b 	vldr	s16, [sp, #108]	; 0x6c
 80286cc:	f89d 3070 	ldrb.w	r3, [sp, #112]	; 0x70
	float i_mean = 0.0f;
 80286d0:	2500      	movs	r5, #0
 80286d2:	9504      	str	r5, [sp, #16]
	float q_mean = 0.0f;
 80286d4:	9505      	str	r5, [sp, #20]
	uint32_t idx;
	float *fft_window_buffer = fft_window.fft_window_buffer;

	if (!complex_fft_signal)
 80286d6:	2e00      	cmp	r6, #0
 80286d8:	d054      	beq.n	8028784 <compute_fft_signal+0xdc>
		return;

	if (!fft_window_buffer)
 80286da:	f1bb 0f00 	cmp.w	fp, #0
 80286de:	d051      	beq.n	8028784 <compute_fft_signal+0xdc>
		return;

	if (fft_type == FFT_INPUT_REAL_I)
 80286e0:	2b01      	cmp	r3, #1
 80286e2:	f000 8098 	beq.w	8028816 <compute_fft_signal+0x16e>
		{
			complex_fft_signal[2 * idx + 0] = 2.0 * (float)(i_data[idx] - i_mean) * if_scale * fft_window_buffer[idx];	// additional scaling by 2 for real input FFT
			complex_fft_signal[2 * idx + 1] = 0;
		}
	}
	else if (fft_type == FFT_INPUT_REAL_Q)
 80286e6:	2b02      	cmp	r3, #2
	{
		/* Find the mean in q_data */
		arm_mean_f32(q_data, Nd, &q_mean);
 80286e8:	9818      	ldr	r0, [sp, #96]	; 0x60
 80286ea:	4621      	mov	r1, r4
 80286ec:	aa05      	add	r2, sp, #20
		{
			complex_fft_signal[2 * idx + 0] = 2.0 * (float)(i_data[idx] - i_mean) * if_scale * fft_window_buffer[idx];	// additional scaling by 2 for real input FFT
			complex_fft_signal[2 * idx + 1] = 0;
		}
	}
	else if (fft_type == FFT_INPUT_REAL_Q)
 80286ee:	d050      	beq.n	8028792 <compute_fft_signal+0xea>
		}
	}
	else
	{
		/* Find the mean in q_data */
		arm_mean_f32(q_data, Nd, &q_mean);
 80286f0:	f7ff f878 	bl	80277e4 <arm_mean_f32>

		/* Find the mean in i_data */
		arm_mean_f32(i_data, Nd, &i_mean);
 80286f4:	9817      	ldr	r0, [sp, #92]	; 0x5c
 80286f6:	4621      	mov	r1, r4
 80286f8:	aa04      	add	r2, sp, #16
 80286fa:	f7ff f873 	bl	80277e4 <arm_mean_f32>

		/* Interleaved (re = I & im = Q) samples as {re[0], im[0], re[1], im[1], ...} */
		for (idx = 0; idx < Nd; idx++)
 80286fe:	b32c      	cbz	r4, 802874c <compute_fft_signal+0xa4>
 8028700:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 8028702:	ed9d 6a04 	vldr	s12, [sp, #16]
 8028706:	eddd 6a05 	vldr	s13, [sp, #20]
 802870a:	9918      	ldr	r1, [sp, #96]	; 0x60
 802870c:	eb02 0584 	add.w	r5, r2, r4, lsl #2
 8028710:	4633      	mov	r3, r6
		{
			complex_fft_signal[2 * idx + 0] = (float)(i_data[idx] - i_mean) * if_scale * fft_window_buffer[idx];
 8028712:	ecf2 7a01 	vldmia	r2!, {s15}
 8028716:	ee77 7ac6 	vsub.f32	s15, s15, s12
 802871a:	4658      	mov	r0, fp
 802871c:	ee27 7a88 	vmul.f32	s14, s15, s16
 8028720:	ecfb 7a01 	vldmia	fp!, {s15}
 8028724:	ee67 7a27 	vmul.f32	s15, s14, s15

		/* Find the mean in i_data */
		arm_mean_f32(i_data, Nd, &i_mean);

		/* Interleaved (re = I & im = Q) samples as {re[0], im[0], re[1], im[1], ...} */
		for (idx = 0; idx < Nd; idx++)
 8028728:	42aa      	cmp	r2, r5
		{
			complex_fft_signal[2 * idx + 0] = (float)(i_data[idx] - i_mean) * if_scale * fft_window_buffer[idx];
 802872a:	edc3 7a00 	vstr	s15, [r3]
			complex_fft_signal[2 * idx + 1] = (float)(q_data[idx] - q_mean) * if_scale * fft_window_buffer[idx];
 802872e:	ecf1 7a01 	vldmia	r1!, {s15}
 8028732:	ed90 7a00 	vldr	s14, [r0]
 8028736:	ee77 7ae6 	vsub.f32	s15, s15, s13
 802873a:	f103 0308 	add.w	r3, r3, #8
 802873e:	ee67 7a88 	vmul.f32	s15, s15, s16
 8028742:	ee67 7a87 	vmul.f32	s15, s15, s14
 8028746:	ed43 7a01 	vstr	s15, [r3, #-4]

		/* Find the mean in i_data */
		arm_mean_f32(i_data, Nd, &i_mean);

		/* Interleaved (re = I & im = Q) samples as {re[0], im[0], re[1], im[1], ...} */
		for (idx = 0; idx < Nd; idx++)
 802874a:	d1e2      	bne.n	8028712 <compute_fft_signal+0x6a>
			complex_fft_signal[2 * idx + 1] = (float)(q_data[idx] - q_mean) * if_scale * fft_window_buffer[idx];
		}
	}

	/* Zero Padding */
	for (uint16_t idx = Nd; idx < Nf; idx++)
 802874c:	42bc      	cmp	r4, r7
	{
		complex_fft_signal[2 * idx + 0] = 0;
 802874e:	bf38      	it	cc
 8028750:	2200      	movcc	r2, #0
			complex_fft_signal[2 * idx + 1] = (float)(q_data[idx] - q_mean) * if_scale * fft_window_buffer[idx];
		}
	}

	/* Zero Padding */
	for (uint16_t idx = Nd; idx < Nf; idx++)
 8028752:	d207      	bcs.n	8028764 <compute_fft_signal+0xbc>
 8028754:	1c61      	adds	r1, r4, #1
	{
		complex_fft_signal[2 * idx + 0] = 0;
 8028756:	eb06 03c4 	add.w	r3, r6, r4, lsl #3
			complex_fft_signal[2 * idx + 1] = (float)(q_data[idx] - q_mean) * if_scale * fft_window_buffer[idx];
		}
	}

	/* Zero Padding */
	for (uint16_t idx = Nd; idx < Nf; idx++)
 802875a:	b28c      	uxth	r4, r1
 802875c:	42bc      	cmp	r4, r7
	{
		complex_fft_signal[2 * idx + 0] = 0;
 802875e:	601a      	str	r2, [r3, #0]
		complex_fft_signal[2 * idx + 1] = 0;
 8028760:	605a      	str	r2, [r3, #4]
			complex_fft_signal[2 * idx + 1] = (float)(q_data[idx] - q_mean) * if_scale * fft_window_buffer[idx];
		}
	}

	/* Zero Padding */
	for (uint16_t idx = Nd; idx < Nf; idx++)
 8028762:	d1f7      	bne.n	8028754 <compute_fft_signal+0xac>
		complex_fft_signal[2 * idx + 0] = 0;
		complex_fft_signal[2 * idx + 1] = 0;
	}

	/* copy mean values into output pointers */
	if ( p_i_mean )
 8028764:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 8028766:	b113      	cbz	r3, 802876e <compute_fft_signal+0xc6>
 8028768:	461a      	mov	r2, r3
		*p_i_mean = i_mean;
 802876a:	9b04      	ldr	r3, [sp, #16]
 802876c:	6013      	str	r3, [r2, #0]

	if ( p_q_mean )
 802876e:	9b1e      	ldr	r3, [sp, #120]	; 0x78
 8028770:	b113      	cbz	r3, 8028778 <compute_fft_signal+0xd0>
 8028772:	461a      	mov	r2, r3
		*p_q_mean = q_mean;
 8028774:	9b05      	ldr	r3, [sp, #20]
 8028776:	6013      	str	r3, [r2, #0]

	/* Processing the floating-point complex FFT. */
	arm_cfft_f32(fft_window.fft_time_twiddle_table, complex_fft_signal, 0, 1);
 8028778:	4631      	mov	r1, r6
 802877a:	9816      	ldr	r0, [sp, #88]	; 0x58
 802877c:	2200      	movs	r2, #0
 802877e:	2301      	movs	r3, #1
 8028780:	f7fe fc86 	bl	8027090 <arm_cfft_f32>
}
 8028784:	b007      	add	sp, #28
 8028786:	ecbd 8b02 	vpop	{d8}
 802878a:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802878e:	b004      	add	sp, #16
 8028790:	4770      	bx	lr
		}
	}
	else if (fft_type == FFT_INPUT_REAL_Q)
	{
		/* Find the mean in q_data */
		arm_mean_f32(q_data, Nd, &q_mean);
 8028792:	f7ff f827 	bl	80277e4 <arm_mean_f32>

		/* Interleaved (re = Q & im = 0) samples as {re[0], im[0], re[1], im[1], ...} */
		for (idx = 0; idx < Nd; idx++)
 8028796:	2c00      	cmp	r4, #0
 8028798:	d0d8      	beq.n	802874c <compute_fft_signal+0xa4>
 802879a:	ee18 0a10 	vmov	r0, s16
 802879e:	f004 f897 	bl	802c8d0 <__aeabi_f2d>
		{
			complex_fft_signal[2 * idx + 0] = 2.0 * (float)(q_data[idx] - q_mean) * if_scale * fft_window_buffer[idx];	// additional scaling by 2 for real input FFT
			complex_fft_signal[2 * idx + 1] = 0;
 80287a2:	ee08 5a10 	vmov	s16, r5
 80287a6:	9d18      	ldr	r5, [sp, #96]	; 0x60
 80287a8:	eddd 8a05 	vldr	s17, [sp, #20]
 80287ac:	9703      	str	r7, [sp, #12]
 80287ae:	eb05 0384 	add.w	r3, r5, r4, lsl #2
 80287b2:	46b2      	mov	sl, r6
 80287b4:	961f      	str	r6, [sp, #124]	; 0x7c
 80287b6:	9301      	str	r3, [sp, #4]
 80287b8:	9402      	str	r4, [sp, #8]
 80287ba:	4606      	mov	r6, r0
 80287bc:	460f      	mov	r7, r1
		arm_mean_f32(q_data, Nd, &q_mean);

		/* Interleaved (re = Q & im = 0) samples as {re[0], im[0], re[1], im[1], ...} */
		for (idx = 0; idx < Nd; idx++)
		{
			complex_fft_signal[2 * idx + 0] = 2.0 * (float)(q_data[idx] - q_mean) * if_scale * fft_window_buffer[idx];	// additional scaling by 2 for real input FFT
 80287be:	ecf5 7a01 	vldmia	r5!, {s15}
 80287c2:	f85b 4b04 	ldr.w	r4, [fp], #4
 80287c6:	ee77 7ae8 	vsub.f32	s15, s15, s17
 80287ca:	f10a 0a08 	add.w	sl, sl, #8
 80287ce:	ee17 0a90 	vmov	r0, s15
 80287d2:	f004 f87d 	bl	802c8d0 <__aeabi_f2d>
 80287d6:	4602      	mov	r2, r0
 80287d8:	460b      	mov	r3, r1
 80287da:	f003 ff1b 	bl	802c614 <__adddf3>
 80287de:	4632      	mov	r2, r6
 80287e0:	463b      	mov	r3, r7
 80287e2:	f004 f8c9 	bl	802c978 <__aeabi_dmul>
 80287e6:	4680      	mov	r8, r0
 80287e8:	4620      	mov	r0, r4
 80287ea:	4689      	mov	r9, r1
 80287ec:	f004 f870 	bl	802c8d0 <__aeabi_f2d>
 80287f0:	460b      	mov	r3, r1
 80287f2:	4602      	mov	r2, r0
 80287f4:	4649      	mov	r1, r9
 80287f6:	4640      	mov	r0, r8
 80287f8:	f004 f8be 	bl	802c978 <__aeabi_dmul>
 80287fc:	f004 fb76 	bl	802ceec <__aeabi_d2f>
	{
		/* Find the mean in q_data */
		arm_mean_f32(q_data, Nd, &q_mean);

		/* Interleaved (re = Q & im = 0) samples as {re[0], im[0], re[1], im[1], ...} */
		for (idx = 0; idx < Nd; idx++)
 8028800:	9b01      	ldr	r3, [sp, #4]
		{
			complex_fft_signal[2 * idx + 0] = 2.0 * (float)(q_data[idx] - q_mean) * if_scale * fft_window_buffer[idx];	// additional scaling by 2 for real input FFT
			complex_fft_signal[2 * idx + 1] = 0;
 8028802:	ed0a 8a01 	vstr	s16, [sl, #-4]
	{
		/* Find the mean in q_data */
		arm_mean_f32(q_data, Nd, &q_mean);

		/* Interleaved (re = Q & im = 0) samples as {re[0], im[0], re[1], im[1], ...} */
		for (idx = 0; idx < Nd; idx++)
 8028806:	429d      	cmp	r5, r3
		{
			complex_fft_signal[2 * idx + 0] = 2.0 * (float)(q_data[idx] - q_mean) * if_scale * fft_window_buffer[idx];	// additional scaling by 2 for real input FFT
 8028808:	f84a 0c08 	str.w	r0, [sl, #-8]
	{
		/* Find the mean in q_data */
		arm_mean_f32(q_data, Nd, &q_mean);

		/* Interleaved (re = Q & im = 0) samples as {re[0], im[0], re[1], im[1], ...} */
		for (idx = 0; idx < Nd; idx++)
 802880c:	d1d7      	bne.n	80287be <compute_fft_signal+0x116>
 802880e:	9c02      	ldr	r4, [sp, #8]
 8028810:	9f03      	ldr	r7, [sp, #12]
 8028812:	9e1f      	ldr	r6, [sp, #124]	; 0x7c
 8028814:	e79a      	b.n	802874c <compute_fft_signal+0xa4>
		return;

	if (fft_type == FFT_INPUT_REAL_I)
	{
		/* Find the mean in i_data */
		arm_mean_f32(i_data, Nd, &i_mean);
 8028816:	9817      	ldr	r0, [sp, #92]	; 0x5c
 8028818:	4621      	mov	r1, r4
 802881a:	aa04      	add	r2, sp, #16
 802881c:	f7fe ffe2 	bl	80277e4 <arm_mean_f32>

		/* Interleaved (re = I & im = 0) samples as {re[0], im[0], re[1], im[1], ...} */
		for (idx = 0; idx < Nd; idx++)
 8028820:	2c00      	cmp	r4, #0
 8028822:	d093      	beq.n	802874c <compute_fft_signal+0xa4>
 8028824:	ee18 0a10 	vmov	r0, s16
 8028828:	f004 f852 	bl	802c8d0 <__aeabi_f2d>
		{
			complex_fft_signal[2 * idx + 0] = 2.0 * (float)(i_data[idx] - i_mean) * if_scale * fft_window_buffer[idx];	// additional scaling by 2 for real input FFT
			complex_fft_signal[2 * idx + 1] = 0;
 802882c:	ee08 5a10 	vmov	s16, r5
 8028830:	9d17      	ldr	r5, [sp, #92]	; 0x5c
 8028832:	eddd 8a04 	vldr	s17, [sp, #16]
 8028836:	9703      	str	r7, [sp, #12]
 8028838:	eb05 0384 	add.w	r3, r5, r4, lsl #2
 802883c:	46b2      	mov	sl, r6
 802883e:	961f      	str	r6, [sp, #124]	; 0x7c
 8028840:	9301      	str	r3, [sp, #4]
 8028842:	9402      	str	r4, [sp, #8]
 8028844:	4606      	mov	r6, r0
 8028846:	460f      	mov	r7, r1
		arm_mean_f32(i_data, Nd, &i_mean);

		/* Interleaved (re = I & im = 0) samples as {re[0], im[0], re[1], im[1], ...} */
		for (idx = 0; idx < Nd; idx++)
		{
			complex_fft_signal[2 * idx + 0] = 2.0 * (float)(i_data[idx] - i_mean) * if_scale * fft_window_buffer[idx];	// additional scaling by 2 for real input FFT
 8028848:	ecf5 7a01 	vldmia	r5!, {s15}
 802884c:	f85b 4b04 	ldr.w	r4, [fp], #4
 8028850:	ee77 7ae8 	vsub.f32	s15, s15, s17
 8028854:	f10a 0a08 	add.w	sl, sl, #8
 8028858:	ee17 0a90 	vmov	r0, s15
 802885c:	f004 f838 	bl	802c8d0 <__aeabi_f2d>
 8028860:	4602      	mov	r2, r0
 8028862:	460b      	mov	r3, r1
 8028864:	f003 fed6 	bl	802c614 <__adddf3>
 8028868:	4632      	mov	r2, r6
 802886a:	463b      	mov	r3, r7
 802886c:	f004 f884 	bl	802c978 <__aeabi_dmul>
 8028870:	4680      	mov	r8, r0
 8028872:	4620      	mov	r0, r4
 8028874:	4689      	mov	r9, r1
 8028876:	f004 f82b 	bl	802c8d0 <__aeabi_f2d>
 802887a:	460b      	mov	r3, r1
 802887c:	4602      	mov	r2, r0
 802887e:	4649      	mov	r1, r9
 8028880:	4640      	mov	r0, r8
 8028882:	f004 f879 	bl	802c978 <__aeabi_dmul>
 8028886:	f004 fb31 	bl	802ceec <__aeabi_d2f>
	{
		/* Find the mean in i_data */
		arm_mean_f32(i_data, Nd, &i_mean);

		/* Interleaved (re = I & im = 0) samples as {re[0], im[0], re[1], im[1], ...} */
		for (idx = 0; idx < Nd; idx++)
 802888a:	9b01      	ldr	r3, [sp, #4]
		{
			complex_fft_signal[2 * idx + 0] = 2.0 * (float)(i_data[idx] - i_mean) * if_scale * fft_window_buffer[idx];	// additional scaling by 2 for real input FFT
			complex_fft_signal[2 * idx + 1] = 0;
 802888c:	ed0a 8a01 	vstr	s16, [sl, #-4]
	{
		/* Find the mean in i_data */
		arm_mean_f32(i_data, Nd, &i_mean);

		/* Interleaved (re = I & im = 0) samples as {re[0], im[0], re[1], im[1], ...} */
		for (idx = 0; idx < Nd; idx++)
 8028890:	429d      	cmp	r5, r3
		{
			complex_fft_signal[2 * idx + 0] = 2.0 * (float)(i_data[idx] - i_mean) * if_scale * fft_window_buffer[idx];	// additional scaling by 2 for real input FFT
 8028892:	f84a 0c08 	str.w	r0, [sl, #-8]
	{
		/* Find the mean in i_data */
		arm_mean_f32(i_data, Nd, &i_mean);

		/* Interleaved (re = I & im = 0) samples as {re[0], im[0], re[1], im[1], ...} */
		for (idx = 0; idx < Nd; idx++)
 8028896:	d1d7      	bne.n	8028848 <compute_fft_signal+0x1a0>
 8028898:	e7b9      	b.n	802880e <compute_fft_signal+0x166>
 802889a:	bf00      	nop

0802889c <compute_fft_spectrum>:
	arm_cfft_f32(fft_window.fft_time_twiddle_table, complex_fft_signal, 0, 1);
}

/*-------------------------- compute_fft_spectrum() ------------------------*/
void compute_fft_spectrum(float* fft_input_signal, uint32_t Nf, float* fft_output_spectrum)
{
 802889c:	460b      	mov	r3, r1
	/* Convert to real magnitude data */
	arm_cmplx_mag_f32(fft_input_signal, fft_output_spectrum, Nf);
 802889e:	4611      	mov	r1, r2
 80288a0:	461a      	mov	r2, r3
 80288a2:	f7ff b813 	b.w	80278cc <arm_cmplx_mag_f32>
 80288a6:	bf00      	nop

080288a8 <bsp_eeprom_24cw128x_write_data>:

/* Function to write data into EEPROM in case of write operation in multi-page, within more then one page */
/* ==> For many write operations we have to wait at least 5ms between each operation
       This is needed only for write operation, there is no need to have this delay for the read operation */
EEPROM_STATUS_t bsp_eeprom_24cw128x_write_data(const uint16_t mem_address, uint8_t *tx_data, uint32_t tx_size)
{
 80288a8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  uint32_t tmp_tx_size = tx_size;
  uint16_t tmp_mem_address = mem_address;

  /* Check for valid start address and valid data size */
  if ((tmp_mem_address >= EEPROM_24CW128X_START_MEM_ADDR) &&
	 ((tmp_mem_address + tmp_tx_size) <= EEPROM_24CW128X_MAX_SIZE) &&
 80288ac:	1883      	adds	r3, r0, r2
  uint32_t written_data = 0;
  uint32_t tmp_tx_size = tx_size;
  uint16_t tmp_mem_address = mem_address;

  /* Check for valid start address and valid data size */
  if ((tmp_mem_address >= EEPROM_24CW128X_START_MEM_ADDR) &&
 80288ae:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000

/* Function to write data into EEPROM in case of write operation in multi-page, within more then one page */
/* ==> For many write operations we have to wait at least 5ms between each operation
       This is needed only for write operation, there is no need to have this delay for the read operation */
EEPROM_STATUS_t bsp_eeprom_24cw128x_write_data(const uint16_t mem_address, uint8_t *tx_data, uint32_t tx_size)
{
 80288b2:	b084      	sub	sp, #16
 80288b4:	4605      	mov	r5, r0
 80288b6:	4614      	mov	r4, r2
  uint32_t written_data = 0;
  uint32_t tmp_tx_size = tx_size;
  uint16_t tmp_mem_address = mem_address;

  /* Check for valid start address and valid data size */
  if ((tmp_mem_address >= EEPROM_24CW128X_START_MEM_ADDR) &&
 80288b8:	d81c      	bhi.n	80288f4 <bsp_eeprom_24cw128x_write_data+0x4c>
	 ((tmp_mem_address + tmp_tx_size) <= EEPROM_24CW128X_MAX_SIZE) &&
 80288ba:	b1da      	cbz	r2, 80288f4 <bsp_eeprom_24cw128x_write_data+0x4c>
  {
	/* The start write address is located in page : */
	nb_of_start_page = (tmp_mem_address / EEPROM_24CW128X_PAGE_SIZE) + 1;

	/* The last write address is located in page : */
	nb_of_end_page = ((tmp_mem_address + tmp_tx_size - 1) / EEPROM_24CW128X_PAGE_SIZE) + 1;
 80288bc:	3b01      	subs	r3, #1
 80288be:	095b      	lsrs	r3, r3, #5
  if ((tmp_mem_address >= EEPROM_24CW128X_START_MEM_ADDR) &&
	 ((tmp_mem_address + tmp_tx_size) <= EEPROM_24CW128X_MAX_SIZE) &&
	 (tmp_tx_size > 0))
  {
	/* The start write address is located in page : */
	nb_of_start_page = (tmp_mem_address / EEPROM_24CW128X_PAGE_SIZE) + 1;
 80288c0:	0947      	lsrs	r7, r0, #5

	/* The last write address is located in page : */
	nb_of_end_page = ((tmp_mem_address + tmp_tx_size - 1) / EEPROM_24CW128X_PAGE_SIZE) + 1;
 80288c2:	3301      	adds	r3, #1
  if ((tmp_mem_address >= EEPROM_24CW128X_START_MEM_ADDR) &&
	 ((tmp_mem_address + tmp_tx_size) <= EEPROM_24CW128X_MAX_SIZE) &&
	 (tmp_tx_size > 0))
  {
	/* The start write address is located in page : */
	nb_of_start_page = (tmp_mem_address / EEPROM_24CW128X_PAGE_SIZE) + 1;
 80288c4:	3701      	adds	r7, #1

	/* The last write address is located in page : */
	nb_of_end_page = ((tmp_mem_address + tmp_tx_size - 1) / EEPROM_24CW128X_PAGE_SIZE) + 1;

	/* Write operation in multi-page */
	if ((nb_of_end_page - nb_of_start_page) > 0)
 80288c6:	42bb      	cmp	r3, r7
 80288c8:	4689      	mov	r9, r1
 80288ca:	f000 80e6 	beq.w	8028a9a <bsp_eeprom_24cw128x_write_data+0x1f2>
	{
	  /* Write the first part of data */
	  written_data = (nb_of_start_page * EEPROM_24CW128X_PAGE_SIZE) - tmp_mem_address;

	  /* Write the first chunk of data */
	  if (written_data > 0)
 80288ce:	ebd0 1747 	rsbs	r7, r0, r7, lsl #5
 80288d2:	d113      	bne.n	80288fc <bsp_eeprom_24cw128x_write_data+0x54>
/* Function to write data into EEPROM in case of write operation in multi-page, within more then one page */
/* ==> For many write operations we have to wait at least 5ms between each operation
       This is needed only for write operation, there is no need to have this delay for the read operation */
EEPROM_STATUS_t bsp_eeprom_24cw128x_write_data(const uint16_t mem_address, uint8_t *tx_data, uint32_t tx_size)
{
  I2C_MASTER_STATUS_t status = I2C_MASTER_STATUS_FAILURE;
 80288d4:	2601      	movs	r6, #1
		  /* EEPROM start write address */
          mem_add[0] = (tmp_mem_address & 0x3F00) >> 8;
          mem_add[1] = tmp_mem_address & 0x00FF;

          /* Send memory address */
          status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, mem_add, 2, false);
 80288d6:	f8df 8238 	ldr.w	r8, [pc, #568]	; 8028b10 <bsp_eeprom_24cw128x_write_data+0x268>
	  }

	  /* Loop for the number of pages to be written */
	  do
	  {
		if (tmp_tx_size >= EEPROM_24CW128X_PAGE_SIZE) /* Write one page data */
 80288da:	2c1f      	cmp	r4, #31
 80288dc:	d852      	bhi.n	8028984 <bsp_eeprom_24cw128x_write_data+0xdc>

			/* Wait for the EEPROM internal write cycle, minimum for 5ms */
			bsp_time_delay(6, BSP_TIMER_DELAY_MILLISECOND);
		  }
		}
		else if ((tmp_tx_size > 0) && (tmp_tx_size < EEPROM_24CW128X_PAGE_SIZE)) /* Write the last chunk of data */
 80288de:	1e63      	subs	r3, r4, #1
 80288e0:	2b1e      	cmp	r3, #30
 80288e2:	f240 8097 	bls.w	8028a14 <bsp_eeprom_24cw128x_write_data+0x16c>
  {
    return EEPROM_STATUS_SUCCESS;
  }
  else
  {
    return EEPROM_STATUS_WRITE_ERROR;
 80288e6:	2e00      	cmp	r6, #0
 80288e8:	bf0c      	ite	eq
 80288ea:	2001      	moveq	r0, #1
 80288ec:	2004      	movne	r0, #4
  }
}
 80288ee:	b004      	add	sp, #16
 80288f0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  {
    return EEPROM_STATUS_SUCCESS;
  }
  else
  {
    return EEPROM_STATUS_WRITE_ERROR;
 80288f4:	2004      	movs	r0, #4
  }
}
 80288f6:	b004      	add	sp, #16
 80288f8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	    /* EEPROM start write address */
        mem_add[0] = (tmp_mem_address & 0x3F00) >> 8;
        mem_add[1] = tmp_mem_address & 0x00FF;

        /* Send memory address */
        status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, mem_add, 2, false);
 80288fc:	f8df a210 	ldr.w	sl, [pc, #528]	; 8028b10 <bsp_eeprom_24cw128x_write_data+0x268>
	  /* Write the first chunk of data */
	  if (written_data > 0)
	  {
	    /* EEPROM start write address */
        mem_add[0] = (tmp_mem_address & 0x3F00) >> 8;
        mem_add[1] = tmp_mem_address & 0x00FF;
 8028900:	f88d 000d 	strb.w	r0, [sp, #13]

        /* Send memory address */
        status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, mem_add, 2, false);
 8028904:	2202      	movs	r2, #2
 8028906:	2300      	movs	r3, #0
 8028908:	e88d 000c 	stmia.w	sp, {r2, r3}

	  /* Write the first chunk of data */
	  if (written_data > 0)
	  {
	    /* EEPROM start write address */
        mem_add[0] = (tmp_mem_address & 0x3F00) >> 8;
 802890c:	f3c5 2605 	ubfx	r6, r5, #8, #6
        mem_add[1] = tmp_mem_address & 0x00FF;

        /* Send memory address */
        status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, mem_add, 2, false);
 8028910:	22a0      	movs	r2, #160	; 0xa0
 8028912:	4650      	mov	r0, sl
 8028914:	2101      	movs	r1, #1
 8028916:	ab03      	add	r3, sp, #12

	  /* Write the first chunk of data */
	  if (written_data > 0)
	  {
	    /* EEPROM start write address */
        mem_add[0] = (tmp_mem_address & 0x3F00) >> 8;
 8028918:	f88d 600c 	strb.w	r6, [sp, #12]
        mem_add[1] = tmp_mem_address & 0x00FF;

        /* Send memory address */
        status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, mem_add, 2, false);
 802891c:	f000 fa68 	bl	8028df0 <I2C_MASTER_Transmit>
 8028920:	f8da 2008 	ldr.w	r2, [sl, #8]
 8028924:	4606      	mov	r6, r0
 *
 */
__STATIC_INLINE bool I2C_MASTER_IsTxBusy(I2C_MASTER_t * const handle)
{
  XMC_ASSERT("I2C_MASTER_IsTxBusy: invalid handle", (handle != NULL))	
  return handle->runtime->tx_busy;
 8028926:	f892 3026 	ldrb.w	r3, [r2, #38]	; 0x26
        while(I2C_MASTER_IsTxBusy(&I2C_MASTER_EEPROM));
 802892a:	2b00      	cmp	r3, #0
 802892c:	d1fb      	bne.n	8028926 <bsp_eeprom_24cw128x_write_data+0x7e>

        if (status == I2C_MASTER_STATUS_SUCCESS)
 802892e:	2e00      	cmp	r6, #0
 8028930:	d1d1      	bne.n	80288d6 <bsp_eeprom_24cw128x_write_data+0x2e>
	    {
          /* Start sending data */
          status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, false, EEPROM_24CW128X_I2C_ADDRESS, tx_data, written_data, true);
 8028932:	2301      	movs	r3, #1
 8028934:	4631      	mov	r1, r6
 8028936:	9301      	str	r3, [sp, #4]
 8028938:	22a0      	movs	r2, #160	; 0xa0
 802893a:	9700      	str	r7, [sp, #0]
 802893c:	4874      	ldr	r0, [pc, #464]	; (8028b10 <bsp_eeprom_24cw128x_write_data+0x268>)
 802893e:	464b      	mov	r3, r9
 8028940:	f000 fa56 	bl	8028df0 <I2C_MASTER_Transmit>
 8028944:	f8da 2008 	ldr.w	r2, [sl, #8]
 8028948:	4606      	mov	r6, r0
 802894a:	f892 3026 	ldrb.w	r3, [r2, #38]	; 0x26
          while(I2C_MASTER_IsTxBusy(&I2C_MASTER_EEPROM));
 802894e:	2b00      	cmp	r3, #0
 8028950:	d1fb      	bne.n	802894a <bsp_eeprom_24cw128x_write_data+0xa2>
/* Function used to generate a time in units of microseconds or milliseconds */
void bsp_time_delay(uint32_t delay_value, BSP_TIMER_DELAY_t time_unit)
{
  uint32_t delay_cnt;

  TIMER_ClearEvent(&EEPROM_TIMER_DELAY);
 8028952:	4870      	ldr	r0, [pc, #448]	; (8028b14 <bsp_eeprom_24cw128x_write_data+0x26c>)
 8028954:	f7fd fb24 	bl	8025fa0 <TIMER_ClearEvent>
  {
	/* Time in units of microseconds */
    delay_cnt = delay_value;
  }

  TIMER_SetTimeInterval(&EEPROM_TIMER_DELAY, delay_cnt);
 8028958:	486e      	ldr	r0, [pc, #440]	; (8028b14 <bsp_eeprom_24cw128x_write_data+0x26c>)
 802895a:	496f      	ldr	r1, [pc, #444]	; (8028b18 <bsp_eeprom_24cw128x_write_data+0x270>)
          status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, false, EEPROM_24CW128X_I2C_ADDRESS, tx_data, written_data, true);
          while(I2C_MASTER_IsTxBusy(&I2C_MASTER_EEPROM));

		  /* Remaining data */
		  tmp_tx_size = tmp_tx_size - written_data;
		  tmp_mem_address = tmp_mem_address + written_data;
 802895c:	443d      	add	r5, r7
  {
	/* Time in units of microseconds */
    delay_cnt = delay_value;
  }

  TIMER_SetTimeInterval(&EEPROM_TIMER_DELAY, delay_cnt);
 802895e:	f7fd fab3 	bl	8025ec8 <TIMER_SetTimeInterval>

  TIMER_Start(&EEPROM_TIMER_DELAY);
 8028962:	486c      	ldr	r0, [pc, #432]	; (8028b14 <bsp_eeprom_24cw128x_write_data+0x26c>)
          status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, false, EEPROM_24CW128X_I2C_ADDRESS, tx_data, written_data, true);
          while(I2C_MASTER_IsTxBusy(&I2C_MASTER_EEPROM));

		  /* Remaining data */
		  tmp_tx_size = tmp_tx_size - written_data;
		  tmp_mem_address = tmp_mem_address + written_data;
 8028964:	b2ad      	uxth	r5, r5
          /* Start sending data */
          status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, false, EEPROM_24CW128X_I2C_ADDRESS, tx_data, written_data, true);
          while(I2C_MASTER_IsTxBusy(&I2C_MASTER_EEPROM));

		  /* Remaining data */
		  tmp_tx_size = tmp_tx_size - written_data;
 8028966:	1be4      	subs	r4, r4, r7
    delay_cnt = delay_value;
  }

  TIMER_SetTimeInterval(&EEPROM_TIMER_DELAY, delay_cnt);

  TIMER_Start(&EEPROM_TIMER_DELAY);
 8028968:	f7fd fa8a 	bl	8025e80 <TIMER_Start>

  while(!TIMER_GetInterruptStatus(&EEPROM_TIMER_DELAY));
 802896c:	4869      	ldr	r0, [pc, #420]	; (8028b14 <bsp_eeprom_24cw128x_write_data+0x26c>)
 802896e:	f7fd fb0b 	bl	8025f88 <TIMER_GetInterruptStatus>
 8028972:	2800      	cmp	r0, #0
 8028974:	d0fa      	beq.n	802896c <bsp_eeprom_24cw128x_write_data+0xc4>

  TIMER_Stop(&EEPROM_TIMER_DELAY);
 8028976:	4867      	ldr	r0, [pc, #412]	; (8028b14 <bsp_eeprom_24cw128x_write_data+0x26c>)
 8028978:	f7fd fa92 	bl	8025ea0 <TIMER_Stop>

  TIMER_Clear(&EEPROM_TIMER_DELAY);
 802897c:	4865      	ldr	r0, [pc, #404]	; (8028b14 <bsp_eeprom_24cw128x_write_data+0x26c>)
 802897e:	f7fd fb1b 	bl	8025fb8 <TIMER_Clear>
 8028982:	e7a8      	b.n	80288d6 <bsp_eeprom_24cw128x_write_data+0x2e>
		  /* EEPROM start write address */
          mem_add[0] = (tmp_mem_address & 0x3F00) >> 8;
          mem_add[1] = tmp_mem_address & 0x00FF;

          /* Send memory address */
          status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, mem_add, 2, false);
 8028984:	2202      	movs	r2, #2
 8028986:	2300      	movs	r3, #0
 8028988:	e88d 000c 	stmia.w	sp, {r2, r3}
	  do
	  {
		if (tmp_tx_size >= EEPROM_24CW128X_PAGE_SIZE) /* Write one page data */
		{
		  /* EEPROM start write address */
          mem_add[0] = (tmp_mem_address & 0x3F00) >> 8;
 802898c:	f3c5 2605 	ubfx	r6, r5, #8, #6
          mem_add[1] = tmp_mem_address & 0x00FF;

          /* Send memory address */
          status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, mem_add, 2, false);
 8028990:	22a0      	movs	r2, #160	; 0xa0
 8028992:	485f      	ldr	r0, [pc, #380]	; (8028b10 <bsp_eeprom_24cw128x_write_data+0x268>)
	  do
	  {
		if (tmp_tx_size >= EEPROM_24CW128X_PAGE_SIZE) /* Write one page data */
		{
		  /* EEPROM start write address */
          mem_add[0] = (tmp_mem_address & 0x3F00) >> 8;
 8028994:	f88d 600c 	strb.w	r6, [sp, #12]
          mem_add[1] = tmp_mem_address & 0x00FF;

          /* Send memory address */
          status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, mem_add, 2, false);
 8028998:	2101      	movs	r1, #1
 802899a:	ab03      	add	r3, sp, #12
	  {
		if (tmp_tx_size >= EEPROM_24CW128X_PAGE_SIZE) /* Write one page data */
		{
		  /* EEPROM start write address */
          mem_add[0] = (tmp_mem_address & 0x3F00) >> 8;
          mem_add[1] = tmp_mem_address & 0x00FF;
 802899c:	f88d 500d 	strb.w	r5, [sp, #13]

          /* Send memory address */
          status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, mem_add, 2, false);
 80289a0:	f000 fa26 	bl	8028df0 <I2C_MASTER_Transmit>
 80289a4:	f8d8 2008 	ldr.w	r2, [r8, #8]
 80289a8:	4606      	mov	r6, r0
 80289aa:	f892 3026 	ldrb.w	r3, [r2, #38]	; 0x26
          while(I2C_MASTER_IsTxBusy(&I2C_MASTER_EEPROM));
 80289ae:	2b00      	cmp	r3, #0
 80289b0:	d1fb      	bne.n	80289aa <bsp_eeprom_24cw128x_write_data+0x102>

          if (status == I2C_MASTER_STATUS_SUCCESS)
 80289b2:	2e00      	cmp	r6, #0
 80289b4:	d191      	bne.n	80288da <bsp_eeprom_24cw128x_write_data+0x32>
	      {
            /* Start sending data */
            status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, false, EEPROM_24CW128X_I2C_ADDRESS, (tx_data + written_data), EEPROM_24CW128X_PAGE_SIZE, true);
 80289b6:	2220      	movs	r2, #32
 80289b8:	2301      	movs	r3, #1
 80289ba:	e88d 000c 	stmia.w	sp, {r2, r3}
 80289be:	4631      	mov	r1, r6
 80289c0:	22a0      	movs	r2, #160	; 0xa0
 80289c2:	4853      	ldr	r0, [pc, #332]	; (8028b10 <bsp_eeprom_24cw128x_write_data+0x268>)
 80289c4:	eb09 0307 	add.w	r3, r9, r7
 80289c8:	f000 fa12 	bl	8028df0 <I2C_MASTER_Transmit>
 80289cc:	f8d8 2008 	ldr.w	r2, [r8, #8]
 80289d0:	4606      	mov	r6, r0
 80289d2:	f892 3026 	ldrb.w	r3, [r2, #38]	; 0x26
            while(I2C_MASTER_IsTxBusy(&I2C_MASTER_EEPROM));
 80289d6:	2b00      	cmp	r3, #0
 80289d8:	d1fb      	bne.n	80289d2 <bsp_eeprom_24cw128x_write_data+0x12a>
/* Function used to generate a time in units of microseconds or milliseconds */
void bsp_time_delay(uint32_t delay_value, BSP_TIMER_DELAY_t time_unit)
{
  uint32_t delay_cnt;

  TIMER_ClearEvent(&EEPROM_TIMER_DELAY);
 80289da:	484e      	ldr	r0, [pc, #312]	; (8028b14 <bsp_eeprom_24cw128x_write_data+0x26c>)
 80289dc:	f7fd fae0 	bl	8025fa0 <TIMER_ClearEvent>
  {
	/* Time in units of microseconds */
    delay_cnt = delay_value;
  }

  TIMER_SetTimeInterval(&EEPROM_TIMER_DELAY, delay_cnt);
 80289e0:	484c      	ldr	r0, [pc, #304]	; (8028b14 <bsp_eeprom_24cw128x_write_data+0x26c>)
 80289e2:	494d      	ldr	r1, [pc, #308]	; (8028b18 <bsp_eeprom_24cw128x_write_data+0x270>)
            /* Start sending data */
            status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, false, EEPROM_24CW128X_I2C_ADDRESS, (tx_data + written_data), EEPROM_24CW128X_PAGE_SIZE, true);
            while(I2C_MASTER_IsTxBusy(&I2C_MASTER_EEPROM));

		    /* Remaining data */
            tmp_mem_address = tmp_mem_address + EEPROM_24CW128X_PAGE_SIZE;
 80289e4:	3520      	adds	r5, #32
  {
	/* Time in units of microseconds */
    delay_cnt = delay_value;
  }

  TIMER_SetTimeInterval(&EEPROM_TIMER_DELAY, delay_cnt);
 80289e6:	f7fd fa6f 	bl	8025ec8 <TIMER_SetTimeInterval>

  TIMER_Start(&EEPROM_TIMER_DELAY);
 80289ea:	484a      	ldr	r0, [pc, #296]	; (8028b14 <bsp_eeprom_24cw128x_write_data+0x26c>)
            /* Start sending data */
            status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, false, EEPROM_24CW128X_I2C_ADDRESS, (tx_data + written_data), EEPROM_24CW128X_PAGE_SIZE, true);
            while(I2C_MASTER_IsTxBusy(&I2C_MASTER_EEPROM));

		    /* Remaining data */
            tmp_mem_address = tmp_mem_address + EEPROM_24CW128X_PAGE_SIZE;
 80289ec:	b2ad      	uxth	r5, r5
		    tmp_tx_size = tmp_tx_size - EEPROM_24CW128X_PAGE_SIZE;
 80289ee:	3c20      	subs	r4, #32
			written_data = written_data + EEPROM_24CW128X_PAGE_SIZE;
 80289f0:	3720      	adds	r7, #32
    delay_cnt = delay_value;
  }

  TIMER_SetTimeInterval(&EEPROM_TIMER_DELAY, delay_cnt);

  TIMER_Start(&EEPROM_TIMER_DELAY);
 80289f2:	f7fd fa45 	bl	8025e80 <TIMER_Start>

  while(!TIMER_GetInterruptStatus(&EEPROM_TIMER_DELAY));
 80289f6:	4847      	ldr	r0, [pc, #284]	; (8028b14 <bsp_eeprom_24cw128x_write_data+0x26c>)
 80289f8:	f7fd fac6 	bl	8025f88 <TIMER_GetInterruptStatus>
 80289fc:	2800      	cmp	r0, #0
 80289fe:	d0fa      	beq.n	80289f6 <bsp_eeprom_24cw128x_write_data+0x14e>

  TIMER_Stop(&EEPROM_TIMER_DELAY);
 8028a00:	4844      	ldr	r0, [pc, #272]	; (8028b14 <bsp_eeprom_24cw128x_write_data+0x26c>)
 8028a02:	f7fd fa4d 	bl	8025ea0 <TIMER_Stop>

  TIMER_Clear(&EEPROM_TIMER_DELAY);
 8028a06:	4843      	ldr	r0, [pc, #268]	; (8028b14 <bsp_eeprom_24cw128x_write_data+0x26c>)
 8028a08:	f7fd fad6 	bl	8025fb8 <TIMER_Clear>

			/* Wait for the EEPROM internal write cycle, minimum for 5ms */
		    bsp_time_delay(6, BSP_TIMER_DELAY_MILLISECOND);
		  }
		}
	  }while(tmp_tx_size > 0);
 8028a0c:	2c00      	cmp	r4, #0
 8028a0e:	f47f af64 	bne.w	80288da <bsp_eeprom_24cw128x_write_data+0x32>
 8028a12:	e768      	b.n	80288e6 <bsp_eeprom_24cw128x_write_data+0x3e>
		  /* EEPROM start write address */
          mem_add[0] = (tmp_mem_address & 0x3F00) >> 8;
          mem_add[1] = tmp_mem_address & 0x00FF;

          /* Send memory address */
          status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, mem_add, 2, false);
 8028a14:	f8df a0f8 	ldr.w	sl, [pc, #248]	; 8028b10 <bsp_eeprom_24cw128x_write_data+0x268>
		}
		else if ((tmp_tx_size > 0) && (tmp_tx_size < EEPROM_24CW128X_PAGE_SIZE)) /* Write the last chunk of data */
		{
		  /* EEPROM start write address */
          mem_add[0] = (tmp_mem_address & 0x3F00) >> 8;
          mem_add[1] = tmp_mem_address & 0x00FF;
 8028a18:	f88d 500d 	strb.w	r5, [sp, #13]

          /* Send memory address */
          status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, mem_add, 2, false);
 8028a1c:	2202      	movs	r2, #2
 8028a1e:	2300      	movs	r3, #0
 8028a20:	e88d 000c 	stmia.w	sp, {r2, r3}
		  }
		}
		else if ((tmp_tx_size > 0) && (tmp_tx_size < EEPROM_24CW128X_PAGE_SIZE)) /* Write the last chunk of data */
		{
		  /* EEPROM start write address */
          mem_add[0] = (tmp_mem_address & 0x3F00) >> 8;
 8028a24:	f3c5 2605 	ubfx	r6, r5, #8, #6
          mem_add[1] = tmp_mem_address & 0x00FF;

          /* Send memory address */
          status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, mem_add, 2, false);
 8028a28:	22a0      	movs	r2, #160	; 0xa0
 8028a2a:	4650      	mov	r0, sl
 8028a2c:	2101      	movs	r1, #1
 8028a2e:	ab03      	add	r3, sp, #12
		  }
		}
		else if ((tmp_tx_size > 0) && (tmp_tx_size < EEPROM_24CW128X_PAGE_SIZE)) /* Write the last chunk of data */
		{
		  /* EEPROM start write address */
          mem_add[0] = (tmp_mem_address & 0x3F00) >> 8;
 8028a30:	f88d 600c 	strb.w	r6, [sp, #12]
          mem_add[1] = tmp_mem_address & 0x00FF;

          /* Send memory address */
          status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, mem_add, 2, false);
 8028a34:	f000 f9dc 	bl	8028df0 <I2C_MASTER_Transmit>
 8028a38:	f8d8 2008 	ldr.w	r2, [r8, #8]
 8028a3c:	4606      	mov	r6, r0
 8028a3e:	f892 3026 	ldrb.w	r3, [r2, #38]	; 0x26
          while(I2C_MASTER_IsTxBusy(&I2C_MASTER_EEPROM));
 8028a42:	2b00      	cmp	r3, #0
 8028a44:	d1fb      	bne.n	8028a3e <bsp_eeprom_24cw128x_write_data+0x196>

          if (status == I2C_MASTER_STATUS_SUCCESS)
 8028a46:	2e00      	cmp	r6, #0
 8028a48:	f47f af47 	bne.w	80288da <bsp_eeprom_24cw128x_write_data+0x32>
	      {
            /* Start sending data */
            status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, false, EEPROM_24CW128X_I2C_ADDRESS, (void *)(tx_data + written_data), tmp_tx_size, true);
 8028a4c:	2201      	movs	r2, #1
 8028a4e:	4631      	mov	r1, r6
 8028a50:	9201      	str	r2, [sp, #4]
 8028a52:	9400      	str	r4, [sp, #0]
 8028a54:	22a0      	movs	r2, #160	; 0xa0
 8028a56:	eb09 0307 	add.w	r3, r9, r7
 8028a5a:	482d      	ldr	r0, [pc, #180]	; (8028b10 <bsp_eeprom_24cw128x_write_data+0x268>)
 8028a5c:	f000 f9c8 	bl	8028df0 <I2C_MASTER_Transmit>
 8028a60:	f8da 2008 	ldr.w	r2, [sl, #8]
 8028a64:	4606      	mov	r6, r0
 8028a66:	f892 3026 	ldrb.w	r3, [r2, #38]	; 0x26
            while(I2C_MASTER_IsTxBusy(&I2C_MASTER_EEPROM));
 8028a6a:	2b00      	cmp	r3, #0
 8028a6c:	d1fb      	bne.n	8028a66 <bsp_eeprom_24cw128x_write_data+0x1be>
/* Function used to generate a time in units of microseconds or milliseconds */
void bsp_time_delay(uint32_t delay_value, BSP_TIMER_DELAY_t time_unit)
{
  uint32_t delay_cnt;

  TIMER_ClearEvent(&EEPROM_TIMER_DELAY);
 8028a6e:	4829      	ldr	r0, [pc, #164]	; (8028b14 <bsp_eeprom_24cw128x_write_data+0x26c>)
 8028a70:	f7fd fa96 	bl	8025fa0 <TIMER_ClearEvent>
  {
	/* Time in units of microseconds */
    delay_cnt = delay_value;
  }

  TIMER_SetTimeInterval(&EEPROM_TIMER_DELAY, delay_cnt);
 8028a74:	4827      	ldr	r0, [pc, #156]	; (8028b14 <bsp_eeprom_24cw128x_write_data+0x26c>)
 8028a76:	4928      	ldr	r1, [pc, #160]	; (8028b18 <bsp_eeprom_24cw128x_write_data+0x270>)
 8028a78:	f7fd fa26 	bl	8025ec8 <TIMER_SetTimeInterval>

  TIMER_Start(&EEPROM_TIMER_DELAY);
 8028a7c:	4825      	ldr	r0, [pc, #148]	; (8028b14 <bsp_eeprom_24cw128x_write_data+0x26c>)
 8028a7e:	f7fd f9ff 	bl	8025e80 <TIMER_Start>

  while(!TIMER_GetInterruptStatus(&EEPROM_TIMER_DELAY));
 8028a82:	4824      	ldr	r0, [pc, #144]	; (8028b14 <bsp_eeprom_24cw128x_write_data+0x26c>)
 8028a84:	f7fd fa80 	bl	8025f88 <TIMER_GetInterruptStatus>
 8028a88:	2800      	cmp	r0, #0
 8028a8a:	d0fa      	beq.n	8028a82 <bsp_eeprom_24cw128x_write_data+0x1da>

  TIMER_Stop(&EEPROM_TIMER_DELAY);
 8028a8c:	4821      	ldr	r0, [pc, #132]	; (8028b14 <bsp_eeprom_24cw128x_write_data+0x26c>)
 8028a8e:	f7fd fa07 	bl	8025ea0 <TIMER_Stop>

  TIMER_Clear(&EEPROM_TIMER_DELAY);
 8028a92:	4820      	ldr	r0, [pc, #128]	; (8028b14 <bsp_eeprom_24cw128x_write_data+0x26c>)
 8028a94:	f7fd fa90 	bl	8025fb8 <TIMER_Clear>
 8028a98:	e725      	b.n	80288e6 <bsp_eeprom_24cw128x_write_data+0x3e>
	  /* EEPROM start write address */
      mem_add[0] = (mem_address & 0x3F00) >> 8;
      mem_add[1] = mem_address & 0x00FF;

      /* Send memory address */
      status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, mem_add, 2, false);
 8028a9a:	f8df a074 	ldr.w	sl, [pc, #116]	; 8028b10 <bsp_eeprom_24cw128x_write_data+0x268>
	}
	else /* Write operation within the same page */
	{
	  /* EEPROM start write address */
      mem_add[0] = (mem_address & 0x3F00) >> 8;
      mem_add[1] = mem_address & 0x00FF;
 8028a9e:	f88d 000d 	strb.w	r0, [sp, #13]

      /* Send memory address */
      status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, mem_add, 2, false);
 8028aa2:	2202      	movs	r2, #2
 8028aa4:	2300      	movs	r3, #0
 8028aa6:	e88d 000c 	stmia.w	sp, {r2, r3}
	  }while(tmp_tx_size > 0);
	}
	else /* Write operation within the same page */
	{
	  /* EEPROM start write address */
      mem_add[0] = (mem_address & 0x3F00) >> 8;
 8028aaa:	f3c0 2505 	ubfx	r5, r0, #8, #6
      mem_add[1] = mem_address & 0x00FF;

      /* Send memory address */
      status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, mem_add, 2, false);
 8028aae:	22a0      	movs	r2, #160	; 0xa0
 8028ab0:	4650      	mov	r0, sl
 8028ab2:	2101      	movs	r1, #1
 8028ab4:	ab03      	add	r3, sp, #12
	  }while(tmp_tx_size > 0);
	}
	else /* Write operation within the same page */
	{
	  /* EEPROM start write address */
      mem_add[0] = (mem_address & 0x3F00) >> 8;
 8028ab6:	f88d 500c 	strb.w	r5, [sp, #12]
      mem_add[1] = mem_address & 0x00FF;

      /* Send memory address */
      status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, mem_add, 2, false);
 8028aba:	f000 f999 	bl	8028df0 <I2C_MASTER_Transmit>
 8028abe:	f8da 2008 	ldr.w	r2, [sl, #8]
 8028ac2:	4606      	mov	r6, r0
 8028ac4:	f892 3026 	ldrb.w	r3, [r2, #38]	; 0x26
      while(I2C_MASTER_IsTxBusy(&I2C_MASTER_EEPROM));
 8028ac8:	2b00      	cmp	r3, #0
 8028aca:	d1fb      	bne.n	8028ac4 <bsp_eeprom_24cw128x_write_data+0x21c>

      if (status == I2C_MASTER_STATUS_SUCCESS)
 8028acc:	b17e      	cbz	r6, 8028aee <bsp_eeprom_24cw128x_write_data+0x246>
/* Function used to generate a time in units of microseconds or milliseconds */
void bsp_time_delay(uint32_t delay_value, BSP_TIMER_DELAY_t time_unit)
{
  uint32_t delay_cnt;

  TIMER_ClearEvent(&EEPROM_TIMER_DELAY);
 8028ace:	4811      	ldr	r0, [pc, #68]	; (8028b14 <bsp_eeprom_24cw128x_write_data+0x26c>)
 8028ad0:	f7fd fa66 	bl	8025fa0 <TIMER_ClearEvent>
  {
	/* Time in units of microseconds */
    delay_cnt = delay_value;
  }

  TIMER_SetTimeInterval(&EEPROM_TIMER_DELAY, delay_cnt);
 8028ad4:	480f      	ldr	r0, [pc, #60]	; (8028b14 <bsp_eeprom_24cw128x_write_data+0x26c>)
 8028ad6:	4910      	ldr	r1, [pc, #64]	; (8028b18 <bsp_eeprom_24cw128x_write_data+0x270>)
 8028ad8:	f7fd f9f6 	bl	8025ec8 <TIMER_SetTimeInterval>

  TIMER_Start(&EEPROM_TIMER_DELAY);
 8028adc:	480d      	ldr	r0, [pc, #52]	; (8028b14 <bsp_eeprom_24cw128x_write_data+0x26c>)
 8028ade:	f7fd f9cf 	bl	8025e80 <TIMER_Start>

  while(!TIMER_GetInterruptStatus(&EEPROM_TIMER_DELAY));
 8028ae2:	480c      	ldr	r0, [pc, #48]	; (8028b14 <bsp_eeprom_24cw128x_write_data+0x26c>)
 8028ae4:	f7fd fa50 	bl	8025f88 <TIMER_GetInterruptStatus>
 8028ae8:	2800      	cmp	r0, #0
 8028aea:	d0fa      	beq.n	8028ae2 <bsp_eeprom_24cw128x_write_data+0x23a>
 8028aec:	e7ce      	b.n	8028a8c <bsp_eeprom_24cw128x_write_data+0x1e4>
      while(I2C_MASTER_IsTxBusy(&I2C_MASTER_EEPROM));

      if (status == I2C_MASTER_STATUS_SUCCESS)
	  {
        /* Start sending data */
        status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, false, EEPROM_24CW128X_I2C_ADDRESS, (void*) tx_data, tx_size, true);
 8028aee:	2201      	movs	r2, #1
 8028af0:	4631      	mov	r1, r6
 8028af2:	9201      	str	r2, [sp, #4]
 8028af4:	9400      	str	r4, [sp, #0]
 8028af6:	22a0      	movs	r2, #160	; 0xa0
 8028af8:	464b      	mov	r3, r9
 8028afa:	4805      	ldr	r0, [pc, #20]	; (8028b10 <bsp_eeprom_24cw128x_write_data+0x268>)
 8028afc:	f000 f978 	bl	8028df0 <I2C_MASTER_Transmit>
 8028b00:	f8da 2008 	ldr.w	r2, [sl, #8]
 8028b04:	4606      	mov	r6, r0
 8028b06:	f892 3026 	ldrb.w	r3, [r2, #38]	; 0x26
        while(I2C_MASTER_IsTxBusy(&I2C_MASTER_EEPROM));
 8028b0a:	2b00      	cmp	r3, #0
 8028b0c:	d1fb      	bne.n	8028b06 <bsp_eeprom_24cw128x_write_data+0x25e>
 8028b0e:	e7de      	b.n	8028ace <bsp_eeprom_24cw128x_write_data+0x226>
 8028b10:	1ffe95f0 	.word	0x1ffe95f0
 8028b14:	1ffe9188 	.word	0x1ffe9188
 8028b18:	000927c0 	.word	0x000927c0

08028b1c <bsp_eeprom_24cw128x_read_data>:

//============================================================================

/* Function to read data from EEPROM in case of read operation in multi-page, within more then one page */
EEPROM_STATUS_t bsp_eeprom_24cw128x_read_data(const uint16_t mem_address, uint8_t *rx_data, uint32_t rx_size)
{
 8028b1c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  uint32_t tmp_rx_size = rx_size;
  uint16_t tmp_mem_address = mem_address;

  /* Check for valid start address and valid data size */
  if ((tmp_mem_address >= EEPROM_24CW128X_START_MEM_ADDR) &&
	 ((tmp_mem_address + tmp_rx_size) <= EEPROM_24CW128X_MAX_SIZE) &&
 8028b20:	1883      	adds	r3, r0, r2
  uint32_t read_data = 0;
  uint32_t tmp_rx_size = rx_size;
  uint16_t tmp_mem_address = mem_address;

  /* Check for valid start address and valid data size */
  if ((tmp_mem_address >= EEPROM_24CW128X_START_MEM_ADDR) &&
 8028b22:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000

//============================================================================

/* Function to read data from EEPROM in case of read operation in multi-page, within more then one page */
EEPROM_STATUS_t bsp_eeprom_24cw128x_read_data(const uint16_t mem_address, uint8_t *rx_data, uint32_t rx_size)
{
 8028b26:	b086      	sub	sp, #24
 8028b28:	4681      	mov	r9, r0
 8028b2a:	4614      	mov	r4, r2
  uint32_t read_data = 0;
  uint32_t tmp_rx_size = rx_size;
  uint16_t tmp_mem_address = mem_address;

  /* Check for valid start address and valid data size */
  if ((tmp_mem_address >= EEPROM_24CW128X_START_MEM_ADDR) &&
 8028b2c:	d819      	bhi.n	8028b62 <bsp_eeprom_24cw128x_read_data+0x46>
	 ((tmp_mem_address + tmp_rx_size) <= EEPROM_24CW128X_MAX_SIZE) &&
 8028b2e:	b1c2      	cbz	r2, 8028b62 <bsp_eeprom_24cw128x_read_data+0x46>
  {
	/* The start read address is located in page : */
	nb_of_start_page = (tmp_mem_address / EEPROM_24CW128X_PAGE_SIZE) + 1;

	/* The last read address is located in page : */
	nb_of_end_page = ((tmp_mem_address + tmp_rx_size - 1) / EEPROM_24CW128X_PAGE_SIZE) + 1;
 8028b30:	3b01      	subs	r3, #1
 8028b32:	095b      	lsrs	r3, r3, #5
  if ((tmp_mem_address >= EEPROM_24CW128X_START_MEM_ADDR) &&
	 ((tmp_mem_address + tmp_rx_size) <= EEPROM_24CW128X_MAX_SIZE) &&
	 (tmp_rx_size > 0))
  {
	/* The start read address is located in page : */
	nb_of_start_page = (tmp_mem_address / EEPROM_24CW128X_PAGE_SIZE) + 1;
 8028b34:	0945      	lsrs	r5, r0, #5

	/* The last read address is located in page : */
	nb_of_end_page = ((tmp_mem_address + tmp_rx_size - 1) / EEPROM_24CW128X_PAGE_SIZE) + 1;
 8028b36:	3301      	adds	r3, #1
  if ((tmp_mem_address >= EEPROM_24CW128X_START_MEM_ADDR) &&
	 ((tmp_mem_address + tmp_rx_size) <= EEPROM_24CW128X_MAX_SIZE) &&
	 (tmp_rx_size > 0))
  {
	/* The start read address is located in page : */
	nb_of_start_page = (tmp_mem_address / EEPROM_24CW128X_PAGE_SIZE) + 1;
 8028b38:	3501      	adds	r5, #1

	/* The last read address is located in page : */
	nb_of_end_page = ((tmp_mem_address + tmp_rx_size - 1) / EEPROM_24CW128X_PAGE_SIZE) + 1;

	/* Read operation from multi-pages */
	if ((nb_of_end_page - nb_of_start_page) > 0)
 8028b3a:	42ab      	cmp	r3, r5
 8028b3c:	4688      	mov	r8, r1
 8028b3e:	f000 809b 	beq.w	8028c78 <bsp_eeprom_24cw128x_read_data+0x15c>
	{
	  /* Read the first part of data */
		read_data = (nb_of_start_page * EEPROM_24CW128X_PAGE_SIZE) - tmp_mem_address;

	  /* Write the first chunk of data */
	  if (read_data > 0)
 8028b42:	ebd0 1545 	rsbs	r5, r0, r5, lsl #5
 8028b46:	d139      	bne.n	8028bbc <bsp_eeprom_24cw128x_read_data+0xa0>
//============================================================================

/* Function to read data from EEPROM in case of read operation in multi-page, within more then one page */
EEPROM_STATUS_t bsp_eeprom_24cw128x_read_data(const uint16_t mem_address, uint8_t *rx_data, uint32_t rx_size)
{
  I2C_MASTER_STATUS_t status = I2C_MASTER_STATUS_FAILURE;
 8028b48:	2001      	movs	r0, #1
		  /* EEPROM start read address */
          mem_add[0] = (tmp_mem_address & 0x3F00) >> 8;
          mem_add[1] = tmp_mem_address & 0x00FF;

          /* Send memory address */
          status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, mem_add, 2, false);
 8028b4a:	4e61      	ldr	r6, [pc, #388]	; (8028cd0 <bsp_eeprom_24cw128x_read_data+0x1b4>)
 8028b4c:	2702      	movs	r7, #2
	  }

	  /* Loop for the number of pages to be read */
	  do
	  {
		if (tmp_rx_size >= EEPROM_24CW128X_PAGE_SIZE) /* read one page data */
 8028b4e:	2c1f      	cmp	r4, #31
 8028b50:	d862      	bhi.n	8028c18 <bsp_eeprom_24cw128x_read_data+0xfc>
            tmp_mem_address = tmp_mem_address + EEPROM_24CW128X_PAGE_SIZE;
			tmp_rx_size = tmp_rx_size - EEPROM_24CW128X_PAGE_SIZE;
			read_data = read_data + EEPROM_24CW128X_PAGE_SIZE;
		  }
		}
		else if ((tmp_rx_size > 0) && (tmp_rx_size < EEPROM_24CW128X_PAGE_SIZE)) /* read the last chunk of data */
 8028b52:	1e63      	subs	r3, r4, #1
 8028b54:	2b1e      	cmp	r3, #30
 8028b56:	d908      	bls.n	8028b6a <bsp_eeprom_24cw128x_read_data+0x4e>
        while(I2C_MASTER_IsRxBusy(&I2C_MASTER_EEPROM));
      }
	}
  }

  if (status == I2C_MASTER_STATUS_SUCCESS)
 8028b58:	b918      	cbnz	r0, 8028b62 <bsp_eeprom_24cw128x_read_data+0x46>
  {
    return EEPROM_STATUS_SUCCESS;
 8028b5a:	2001      	movs	r0, #1
  }
  else
  {
    return EEPROM_STATUS_READ_ERROR;
  }
}
 8028b5c:	b006      	add	sp, #24
 8028b5e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  {
    return EEPROM_STATUS_SUCCESS;
  }
  else
  {
    return EEPROM_STATUS_READ_ERROR;
 8028b62:	2003      	movs	r0, #3
  }
}
 8028b64:	b006      	add	sp, #24
 8028b66:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		  /* EEPROM start read address */
          mem_add[0] = (tmp_mem_address & 0x3F00) >> 8;
          mem_add[1] = tmp_mem_address & 0x00FF;

          /* Send memory address */
          status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, mem_add, 2, false);
 8028b6a:	f8df a164 	ldr.w	sl, [pc, #356]	; 8028cd0 <bsp_eeprom_24cw128x_read_data+0x1b4>
 8028b6e:	9700      	str	r7, [sp, #0]
 8028b70:	2300      	movs	r3, #0
 8028b72:	9301      	str	r3, [sp, #4]
		  }
		}
		else if ((tmp_rx_size > 0) && (tmp_rx_size < EEPROM_24CW128X_PAGE_SIZE)) /* read the last chunk of data */
		{
		  /* EEPROM start read address */
          mem_add[0] = (tmp_mem_address & 0x3F00) >> 8;
 8028b74:	f3c9 2e05 	ubfx	lr, r9, #8, #6
          mem_add[1] = tmp_mem_address & 0x00FF;

          /* Send memory address */
          status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, mem_add, 2, false);
 8028b78:	22a0      	movs	r2, #160	; 0xa0
 8028b7a:	4650      	mov	r0, sl
 8028b7c:	2101      	movs	r1, #1
 8028b7e:	ab05      	add	r3, sp, #20
		}
		else if ((tmp_rx_size > 0) && (tmp_rx_size < EEPROM_24CW128X_PAGE_SIZE)) /* read the last chunk of data */
		{
		  /* EEPROM start read address */
          mem_add[0] = (tmp_mem_address & 0x3F00) >> 8;
          mem_add[1] = tmp_mem_address & 0x00FF;
 8028b80:	f88d 9015 	strb.w	r9, [sp, #21]
		  }
		}
		else if ((tmp_rx_size > 0) && (tmp_rx_size < EEPROM_24CW128X_PAGE_SIZE)) /* read the last chunk of data */
		{
		  /* EEPROM start read address */
          mem_add[0] = (tmp_mem_address & 0x3F00) >> 8;
 8028b84:	f88d e014 	strb.w	lr, [sp, #20]
          mem_add[1] = tmp_mem_address & 0x00FF;

          /* Send memory address */
          status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, mem_add, 2, false);
 8028b88:	f000 f932 	bl	8028df0 <I2C_MASTER_Transmit>
 8028b8c:	68b2      	ldr	r2, [r6, #8]
 8028b8e:	f892 3026 	ldrb.w	r3, [r2, #38]	; 0x26
          while(I2C_MASTER_IsTxBusy(&I2C_MASTER_EEPROM));
 8028b92:	2b00      	cmp	r3, #0
 8028b94:	d1fb      	bne.n	8028b8e <bsp_eeprom_24cw128x_read_data+0x72>

          if (status == I2C_MASTER_STATUS_SUCCESS)
 8028b96:	2800      	cmp	r0, #0
 8028b98:	d1d9      	bne.n	8028b4e <bsp_eeprom_24cw128x_read_data+0x32>
	      {
            /* Start reading data */
            status = I2C_MASTER_Receive(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, (rx_data + read_data), tmp_rx_size, true, true);
 8028b9a:	2101      	movs	r1, #1
 8028b9c:	22a0      	movs	r2, #160	; 0xa0
 8028b9e:	9400      	str	r4, [sp, #0]
 8028ba0:	eb08 0305 	add.w	r3, r8, r5
 8028ba4:	9101      	str	r1, [sp, #4]
 8028ba6:	9102      	str	r1, [sp, #8]
 8028ba8:	4849      	ldr	r0, [pc, #292]	; (8028cd0 <bsp_eeprom_24cw128x_read_data+0x1b4>)
 8028baa:	f000 fa27 	bl	8028ffc <I2C_MASTER_Receive>
 8028bae:	f8da 2008 	ldr.w	r2, [sl, #8]
 *
 */
__STATIC_INLINE bool I2C_MASTER_IsRxBusy(I2C_MASTER_t * const handle)
{
  XMC_ASSERT("I2C_MASTER_IsRxBusy: invalid handle", (handle != NULL))	
  return handle->runtime->rx_busy;
 8028bb2:	f892 3027 	ldrb.w	r3, [r2, #39]	; 0x27
            while(I2C_MASTER_IsRxBusy(&I2C_MASTER_EEPROM));
 8028bb6:	2b00      	cmp	r3, #0
 8028bb8:	d1fb      	bne.n	8028bb2 <bsp_eeprom_24cw128x_read_data+0x96>
 8028bba:	e7cd      	b.n	8028b58 <bsp_eeprom_24cw128x_read_data+0x3c>
	    /* EEPROM start read address */
        mem_add[0] = (tmp_mem_address & 0x3F00) >> 8;
        mem_add[1] = tmp_mem_address & 0x00FF;

        /* Send memory address */
        status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, mem_add, 2, false);
 8028bbc:	f8df a110 	ldr.w	sl, [pc, #272]	; 8028cd0 <bsp_eeprom_24cw128x_read_data+0x1b4>
	  /* Write the first chunk of data */
	  if (read_data > 0)
	  {
	    /* EEPROM start read address */
        mem_add[0] = (tmp_mem_address & 0x3F00) >> 8;
        mem_add[1] = tmp_mem_address & 0x00FF;
 8028bc0:	f88d 0015 	strb.w	r0, [sp, #21]

        /* Send memory address */
        status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, mem_add, 2, false);
 8028bc4:	2202      	movs	r2, #2
 8028bc6:	2300      	movs	r3, #0
 8028bc8:	e88d 000c 	stmia.w	sp, {r2, r3}
 8028bcc:	4650      	mov	r0, sl
 8028bce:	22a0      	movs	r2, #160	; 0xa0

	  /* Write the first chunk of data */
	  if (read_data > 0)
	  {
	    /* EEPROM start read address */
        mem_add[0] = (tmp_mem_address & 0x3F00) >> 8;
 8028bd0:	f3c9 2605 	ubfx	r6, r9, #8, #6
        mem_add[1] = tmp_mem_address & 0x00FF;

        /* Send memory address */
        status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, mem_add, 2, false);
 8028bd4:	2101      	movs	r1, #1
 8028bd6:	ab05      	add	r3, sp, #20

	  /* Write the first chunk of data */
	  if (read_data > 0)
	  {
	    /* EEPROM start read address */
        mem_add[0] = (tmp_mem_address & 0x3F00) >> 8;
 8028bd8:	f88d 6014 	strb.w	r6, [sp, #20]
        mem_add[1] = tmp_mem_address & 0x00FF;

        /* Send memory address */
        status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, mem_add, 2, false);
 8028bdc:	f000 f908 	bl	8028df0 <I2C_MASTER_Transmit>
 8028be0:	f8da 2008 	ldr.w	r2, [sl, #8]
 *
 */
__STATIC_INLINE bool I2C_MASTER_IsTxBusy(I2C_MASTER_t * const handle)
{
  XMC_ASSERT("I2C_MASTER_IsTxBusy: invalid handle", (handle != NULL))	
  return handle->runtime->tx_busy;
 8028be4:	f892 3026 	ldrb.w	r3, [r2, #38]	; 0x26
        while(I2C_MASTER_IsTxBusy(&I2C_MASTER_EEPROM));
 8028be8:	2b00      	cmp	r3, #0
 8028bea:	d1fb      	bne.n	8028be4 <bsp_eeprom_24cw128x_read_data+0xc8>

        if (status == I2C_MASTER_STATUS_SUCCESS)
 8028bec:	2800      	cmp	r0, #0
 8028bee:	d1ac      	bne.n	8028b4a <bsp_eeprom_24cw128x_read_data+0x2e>
	    {
          /* Start reading data */
          status = I2C_MASTER_Receive(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, rx_data, read_data, true, true);
 8028bf0:	2101      	movs	r1, #1
 8028bf2:	22a0      	movs	r2, #160	; 0xa0
 8028bf4:	9500      	str	r5, [sp, #0]
 8028bf6:	9101      	str	r1, [sp, #4]
 8028bf8:	9102      	str	r1, [sp, #8]
 8028bfa:	4835      	ldr	r0, [pc, #212]	; (8028cd0 <bsp_eeprom_24cw128x_read_data+0x1b4>)
 8028bfc:	4643      	mov	r3, r8
 8028bfe:	f000 f9fd 	bl	8028ffc <I2C_MASTER_Receive>
 8028c02:	f8da 2008 	ldr.w	r2, [sl, #8]
 *
 */
__STATIC_INLINE bool I2C_MASTER_IsRxBusy(I2C_MASTER_t * const handle)
{
  XMC_ASSERT("I2C_MASTER_IsRxBusy: invalid handle", (handle != NULL))	
  return handle->runtime->rx_busy;
 8028c06:	f892 3027 	ldrb.w	r3, [r2, #39]	; 0x27
          while(I2C_MASTER_IsRxBusy(&I2C_MASTER_EEPROM));
 8028c0a:	2b00      	cmp	r3, #0
 8028c0c:	d1fb      	bne.n	8028c06 <bsp_eeprom_24cw128x_read_data+0xea>

		  /* Remaining data */
          tmp_rx_size = tmp_rx_size - read_data;
          tmp_mem_address = tmp_mem_address + read_data;
 8028c0e:	44a9      	add	r9, r5
 8028c10:	fa1f f989 	uxth.w	r9, r9
          /* Start reading data */
          status = I2C_MASTER_Receive(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, rx_data, read_data, true, true);
          while(I2C_MASTER_IsRxBusy(&I2C_MASTER_EEPROM));

		  /* Remaining data */
          tmp_rx_size = tmp_rx_size - read_data;
 8028c14:	1b64      	subs	r4, r4, r5
 8028c16:	e798      	b.n	8028b4a <bsp_eeprom_24cw128x_read_data+0x2e>
		  /* EEPROM start read address */
          mem_add[0] = (tmp_mem_address & 0x3F00) >> 8;
          mem_add[1] = tmp_mem_address & 0x00FF;

          /* Send memory address */
          status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, mem_add, 2, false);
 8028c18:	2300      	movs	r3, #0
 8028c1a:	9301      	str	r3, [sp, #4]
	  do
	  {
		if (tmp_rx_size >= EEPROM_24CW128X_PAGE_SIZE) /* read one page data */
		{
		  /* EEPROM start read address */
          mem_add[0] = (tmp_mem_address & 0x3F00) >> 8;
 8028c1c:	f3c9 2e05 	ubfx	lr, r9, #8, #6
          mem_add[1] = tmp_mem_address & 0x00FF;

          /* Send memory address */
          status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, mem_add, 2, false);
 8028c20:	22a0      	movs	r2, #160	; 0xa0
 8028c22:	9700      	str	r7, [sp, #0]
 8028c24:	482a      	ldr	r0, [pc, #168]	; (8028cd0 <bsp_eeprom_24cw128x_read_data+0x1b4>)
	  {
		if (tmp_rx_size >= EEPROM_24CW128X_PAGE_SIZE) /* read one page data */
		{
		  /* EEPROM start read address */
          mem_add[0] = (tmp_mem_address & 0x3F00) >> 8;
          mem_add[1] = tmp_mem_address & 0x00FF;
 8028c26:	f88d 9015 	strb.w	r9, [sp, #21]

          /* Send memory address */
          status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, mem_add, 2, false);
 8028c2a:	2101      	movs	r1, #1
 8028c2c:	ab05      	add	r3, sp, #20
	  do
	  {
		if (tmp_rx_size >= EEPROM_24CW128X_PAGE_SIZE) /* read one page data */
		{
		  /* EEPROM start read address */
          mem_add[0] = (tmp_mem_address & 0x3F00) >> 8;
 8028c2e:	f88d e014 	strb.w	lr, [sp, #20]
          mem_add[1] = tmp_mem_address & 0x00FF;

          /* Send memory address */
          status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, mem_add, 2, false);
 8028c32:	f000 f8dd 	bl	8028df0 <I2C_MASTER_Transmit>
 8028c36:	68b2      	ldr	r2, [r6, #8]
 *
 */
__STATIC_INLINE bool I2C_MASTER_IsTxBusy(I2C_MASTER_t * const handle)
{
  XMC_ASSERT("I2C_MASTER_IsTxBusy: invalid handle", (handle != NULL))	
  return handle->runtime->tx_busy;
 8028c38:	f892 3026 	ldrb.w	r3, [r2, #38]	; 0x26
          while(I2C_MASTER_IsTxBusy(&I2C_MASTER_EEPROM));
 8028c3c:	2b00      	cmp	r3, #0
 8028c3e:	d1fb      	bne.n	8028c38 <bsp_eeprom_24cw128x_read_data+0x11c>

          if (status == I2C_MASTER_STATUS_SUCCESS)
 8028c40:	2800      	cmp	r0, #0
 8028c42:	d184      	bne.n	8028b4e <bsp_eeprom_24cw128x_read_data+0x32>
	      {
            /* Start reading data */
            status = I2C_MASTER_Receive(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, (rx_data + read_data), EEPROM_24CW128X_PAGE_SIZE, true, true);
 8028c44:	2101      	movs	r1, #1
 8028c46:	2320      	movs	r3, #32
 8028c48:	9300      	str	r3, [sp, #0]
 8028c4a:	22a0      	movs	r2, #160	; 0xa0
 8028c4c:	9101      	str	r1, [sp, #4]
 8028c4e:	9102      	str	r1, [sp, #8]
 8028c50:	481f      	ldr	r0, [pc, #124]	; (8028cd0 <bsp_eeprom_24cw128x_read_data+0x1b4>)
 8028c52:	eb08 0305 	add.w	r3, r8, r5
 8028c56:	f000 f9d1 	bl	8028ffc <I2C_MASTER_Receive>
 8028c5a:	68b2      	ldr	r2, [r6, #8]
 *
 */
__STATIC_INLINE bool I2C_MASTER_IsRxBusy(I2C_MASTER_t * const handle)
{
  XMC_ASSERT("I2C_MASTER_IsRxBusy: invalid handle", (handle != NULL))	
  return handle->runtime->rx_busy;
 8028c5c:	f892 3027 	ldrb.w	r3, [r2, #39]	; 0x27
            while(I2C_MASTER_IsRxBusy(&I2C_MASTER_EEPROM));
 8028c60:	2b00      	cmp	r3, #0
 8028c62:	d1fb      	bne.n	8028c5c <bsp_eeprom_24cw128x_read_data+0x140>

		    /* Remaining data */
            tmp_mem_address = tmp_mem_address + EEPROM_24CW128X_PAGE_SIZE;
 8028c64:	f109 0920 	add.w	r9, r9, #32

		    /* No remaining data */
            tmp_rx_size = 0;
		  }
		}
	  }while(tmp_rx_size > 0);
 8028c68:	3c20      	subs	r4, #32
            /* Start reading data */
            status = I2C_MASTER_Receive(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, (rx_data + read_data), EEPROM_24CW128X_PAGE_SIZE, true, true);
            while(I2C_MASTER_IsRxBusy(&I2C_MASTER_EEPROM));

		    /* Remaining data */
            tmp_mem_address = tmp_mem_address + EEPROM_24CW128X_PAGE_SIZE;
 8028c6a:	fa1f f989 	uxth.w	r9, r9
			tmp_rx_size = tmp_rx_size - EEPROM_24CW128X_PAGE_SIZE;
			read_data = read_data + EEPROM_24CW128X_PAGE_SIZE;
 8028c6e:	f105 0520 	add.w	r5, r5, #32

		    /* No remaining data */
            tmp_rx_size = 0;
		  }
		}
	  }while(tmp_rx_size > 0);
 8028c72:	f47f af6c 	bne.w	8028b4e <bsp_eeprom_24cw128x_read_data+0x32>
 8028c76:	e76f      	b.n	8028b58 <bsp_eeprom_24cw128x_read_data+0x3c>
	  /* EEPROM start write address */
      mem_add[0] = (mem_address & 0x3F00) >> 8;
      mem_add[1] = mem_address & 0x00FF;

      /* Send memory address */
      status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, mem_add, 2, false);
 8028c78:	f8df a054 	ldr.w	sl, [pc, #84]	; 8028cd0 <bsp_eeprom_24cw128x_read_data+0x1b4>
	}
	else /* Read operation within the same page */
	{
	  /* EEPROM start write address */
      mem_add[0] = (mem_address & 0x3F00) >> 8;
      mem_add[1] = mem_address & 0x00FF;
 8028c7c:	f88d 0015 	strb.w	r0, [sp, #21]

      /* Send memory address */
      status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, mem_add, 2, false);
 8028c80:	2202      	movs	r2, #2
 8028c82:	2300      	movs	r3, #0
 8028c84:	e88d 000c 	stmia.w	sp, {r2, r3}
	  }while(tmp_rx_size > 0);
	}
	else /* Read operation within the same page */
	{
	  /* EEPROM start write address */
      mem_add[0] = (mem_address & 0x3F00) >> 8;
 8028c88:	f3c0 2905 	ubfx	r9, r0, #8, #6
      mem_add[1] = mem_address & 0x00FF;

      /* Send memory address */
      status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, mem_add, 2, false);
 8028c8c:	22a0      	movs	r2, #160	; 0xa0
 8028c8e:	4650      	mov	r0, sl
 8028c90:	2101      	movs	r1, #1
 8028c92:	ab05      	add	r3, sp, #20
	  }while(tmp_rx_size > 0);
	}
	else /* Read operation within the same page */
	{
	  /* EEPROM start write address */
      mem_add[0] = (mem_address & 0x3F00) >> 8;
 8028c94:	f88d 9014 	strb.w	r9, [sp, #20]
      mem_add[1] = mem_address & 0x00FF;

      /* Send memory address */
      status = I2C_MASTER_Transmit(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, mem_add, 2, false);
 8028c98:	f000 f8aa 	bl	8028df0 <I2C_MASTER_Transmit>
 8028c9c:	f8da 2008 	ldr.w	r2, [sl, #8]
 *
 */
__STATIC_INLINE bool I2C_MASTER_IsTxBusy(I2C_MASTER_t * const handle)
{
  XMC_ASSERT("I2C_MASTER_IsTxBusy: invalid handle", (handle != NULL))	
  return handle->runtime->tx_busy;
 8028ca0:	f892 3026 	ldrb.w	r3, [r2, #38]	; 0x26
      while(I2C_MASTER_IsTxBusy(&I2C_MASTER_EEPROM));
 8028ca4:	2b00      	cmp	r3, #0
 8028ca6:	d1fb      	bne.n	8028ca0 <bsp_eeprom_24cw128x_read_data+0x184>

      if (status == I2C_MASTER_STATUS_SUCCESS)
 8028ca8:	2800      	cmp	r0, #0
 8028caa:	f47f af5a 	bne.w	8028b62 <bsp_eeprom_24cw128x_read_data+0x46>
	  {
        /* Start reading data */
        status = I2C_MASTER_Receive(&I2C_MASTER_EEPROM, true, EEPROM_24CW128X_I2C_ADDRESS, rx_data, rx_size, true, true);
 8028cae:	2101      	movs	r1, #1
 8028cb0:	22a0      	movs	r2, #160	; 0xa0
 8028cb2:	9400      	str	r4, [sp, #0]
 8028cb4:	4643      	mov	r3, r8
 8028cb6:	9101      	str	r1, [sp, #4]
 8028cb8:	9102      	str	r1, [sp, #8]
 8028cba:	4805      	ldr	r0, [pc, #20]	; (8028cd0 <bsp_eeprom_24cw128x_read_data+0x1b4>)
 8028cbc:	f000 f99e 	bl	8028ffc <I2C_MASTER_Receive>
 8028cc0:	f8da 2008 	ldr.w	r2, [sl, #8]
 *
 */
__STATIC_INLINE bool I2C_MASTER_IsRxBusy(I2C_MASTER_t * const handle)
{
  XMC_ASSERT("I2C_MASTER_IsRxBusy: invalid handle", (handle != NULL))	
  return handle->runtime->rx_busy;
 8028cc4:	f892 3027 	ldrb.w	r3, [r2, #39]	; 0x27
        while(I2C_MASTER_IsRxBusy(&I2C_MASTER_EEPROM));
 8028cc8:	2b00      	cmp	r3, #0
 8028cca:	d1fb      	bne.n	8028cc4 <bsp_eeprom_24cw128x_read_data+0x1a8>
 8028ccc:	e744      	b.n	8028b58 <bsp_eeprom_24cw128x_read_data+0x3c>
 8028cce:	bf00      	nop
 8028cd0:	1ffe95f0 	.word	0x1ffe95f0

08028cd4 <bsp_time_delay>:

//============================================================================

/* Function used to generate a time in units of microseconds or milliseconds */
void bsp_time_delay(uint32_t delay_value, BSP_TIMER_DELAY_t time_unit)
{
 8028cd4:	b538      	push	{r3, r4, r5, lr}
 8028cd6:	4604      	mov	r4, r0
 8028cd8:	460d      	mov	r5, r1
  uint32_t delay_cnt;

  TIMER_ClearEvent(&EEPROM_TIMER_DELAY);
 8028cda:	480e      	ldr	r0, [pc, #56]	; (8028d14 <bsp_time_delay+0x40>)
 8028cdc:	f7fd f960 	bl	8025fa0 <TIMER_ClearEvent>

  if (time_unit == BSP_TIMER_DELAY_MILLISECOND)
 8028ce0:	2d01      	cmp	r5, #1
  {
	/* Time in units of milliseconds */
	delay_cnt = (1000U * 100U) * delay_value;
 8028ce2:	bf08      	it	eq
 8028ce4:	4b0c      	ldreq	r3, [pc, #48]	; (8028d18 <bsp_time_delay+0x44>)
  {
	/* Time in units of microseconds */
    delay_cnt = delay_value;
  }

  TIMER_SetTimeInterval(&EEPROM_TIMER_DELAY, delay_cnt);
 8028ce6:	480b      	ldr	r0, [pc, #44]	; (8028d14 <bsp_time_delay+0x40>)
  TIMER_ClearEvent(&EEPROM_TIMER_DELAY);

  if (time_unit == BSP_TIMER_DELAY_MILLISECOND)
  {
	/* Time in units of milliseconds */
	delay_cnt = (1000U * 100U) * delay_value;
 8028ce8:	bf08      	it	eq
 8028cea:	435c      	muleq	r4, r3
  {
	/* Time in units of microseconds */
    delay_cnt = delay_value;
  }

  TIMER_SetTimeInterval(&EEPROM_TIMER_DELAY, delay_cnt);
 8028cec:	4621      	mov	r1, r4
 8028cee:	f7fd f8eb 	bl	8025ec8 <TIMER_SetTimeInterval>

  TIMER_Start(&EEPROM_TIMER_DELAY);
 8028cf2:	4808      	ldr	r0, [pc, #32]	; (8028d14 <bsp_time_delay+0x40>)
 8028cf4:	f7fd f8c4 	bl	8025e80 <TIMER_Start>

  while(!TIMER_GetInterruptStatus(&EEPROM_TIMER_DELAY));
 8028cf8:	4806      	ldr	r0, [pc, #24]	; (8028d14 <bsp_time_delay+0x40>)
 8028cfa:	f7fd f945 	bl	8025f88 <TIMER_GetInterruptStatus>
 8028cfe:	2800      	cmp	r0, #0
 8028d00:	d0fa      	beq.n	8028cf8 <bsp_time_delay+0x24>

  TIMER_Stop(&EEPROM_TIMER_DELAY);
 8028d02:	4804      	ldr	r0, [pc, #16]	; (8028d14 <bsp_time_delay+0x40>)
 8028d04:	f7fd f8cc 	bl	8025ea0 <TIMER_Stop>

  TIMER_Clear(&EEPROM_TIMER_DELAY);
 8028d08:	4802      	ldr	r0, [pc, #8]	; (8028d14 <bsp_time_delay+0x40>)
}
 8028d0a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}

  while(!TIMER_GetInterruptStatus(&EEPROM_TIMER_DELAY));

  TIMER_Stop(&EEPROM_TIMER_DELAY);

  TIMER_Clear(&EEPROM_TIMER_DELAY);
 8028d0e:	f7fd b953 	b.w	8025fb8 <TIMER_Clear>
 8028d12:	bf00      	nop
 8028d14:	1ffe9188 	.word	0x1ffe9188
 8028d18:	000186a0 	.word	0x000186a0

08028d1c <bsp_led_green_on>:
#if !defined(BUILD_FOR_ARDUINO)

//============================================================================

void bsp_led_green_on(void)
{
 8028d1c:	4b03      	ldr	r3, [pc, #12]	; (8028d2c <bsp_led_green_on+0x10>)

__STATIC_INLINE void XMC_GPIO_SetOutputLow(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputLow: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = 0x10000U << pin;
 8028d1e:	7c19      	ldrb	r1, [r3, #16]
 8028d20:	681a      	ldr	r2, [r3, #0]
 8028d22:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8028d26:	408b      	lsls	r3, r1
 8028d28:	6053      	str	r3, [r2, #4]
 8028d2a:	4770      	bx	lr
 8028d2c:	0802f8bc 	.word	0x0802f8bc

08028d30 <bsp_led_green_off>:
}

//============================================================================

void bsp_led_green_off(void)
{
 8028d30:	4b03      	ldr	r3, [pc, #12]	; (8028d40 <bsp_led_green_off+0x10>)

__STATIC_INLINE void XMC_GPIO_SetOutputHigh(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputHigh: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = (uint32_t)0x1U << pin;
 8028d32:	7c19      	ldrb	r1, [r3, #16]
 8028d34:	681a      	ldr	r2, [r3, #0]
 8028d36:	2301      	movs	r3, #1
 8028d38:	408b      	lsls	r3, r1
 8028d3a:	6053      	str	r3, [r2, #4]
 8028d3c:	4770      	bx	lr
 8028d3e:	bf00      	nop
 8028d40:	0802f8bc 	.word	0x0802f8bc

08028d44 <bsp_led_blue_on>:
  DIGITAL_IO_ToggleOutput(&DIGITAL_IO_GREEN_LED);
}
//============================================================================

void bsp_led_blue_on(void)
{
 8028d44:	4b03      	ldr	r3, [pc, #12]	; (8028d54 <bsp_led_blue_on+0x10>)

__STATIC_INLINE void XMC_GPIO_SetOutputLow(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputLow: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = 0x10000U << pin;
 8028d46:	7c19      	ldrb	r1, [r3, #16]
 8028d48:	681a      	ldr	r2, [r3, #0]
 8028d4a:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8028d4e:	408b      	lsls	r3, r1
 8028d50:	6053      	str	r3, [r2, #4]
 8028d52:	4770      	bx	lr
 8028d54:	0802f8e4 	.word	0x0802f8e4

08028d58 <bsp_led_blue_off>:
}

//============================================================================

void bsp_led_blue_off(void)
{
 8028d58:	4b03      	ldr	r3, [pc, #12]	; (8028d68 <bsp_led_blue_off+0x10>)

__STATIC_INLINE void XMC_GPIO_SetOutputHigh(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputHigh: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = (uint32_t)0x1U << pin;
 8028d5a:	7c19      	ldrb	r1, [r3, #16]
 8028d5c:	681a      	ldr	r2, [r3, #0]
 8028d5e:	2301      	movs	r3, #1
 8028d60:	408b      	lsls	r3, r1
 8028d62:	6053      	str	r3, [r2, #4]
 8028d64:	4770      	bx	lr
 8028d66:	bf00      	nop
 8028d68:	0802f8e4 	.word	0x0802f8e4

08028d6c <bsp_led_red_on>:
}

//============================================================================

void bsp_led_red_on(void)
{
 8028d6c:	4b03      	ldr	r3, [pc, #12]	; (8028d7c <bsp_led_red_on+0x10>)

__STATIC_INLINE void XMC_GPIO_SetOutputLow(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputLow: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = 0x10000U << pin;
 8028d6e:	7c19      	ldrb	r1, [r3, #16]
 8028d70:	681a      	ldr	r2, [r3, #0]
 8028d72:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8028d76:	408b      	lsls	r3, r1
 8028d78:	6053      	str	r3, [r2, #4]
 8028d7a:	4770      	bx	lr
 8028d7c:	0802f8d0 	.word	0x0802f8d0

08028d80 <bsp_led_red_off>:
}

//============================================================================

void bsp_led_red_off(void)
{
 8028d80:	4b03      	ldr	r3, [pc, #12]	; (8028d90 <bsp_led_red_off+0x10>)

__STATIC_INLINE void XMC_GPIO_SetOutputHigh(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputHigh: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = (uint32_t)0x1U << pin;
 8028d82:	7c19      	ldrb	r1, [r3, #16]
 8028d84:	681a      	ldr	r2, [r3, #0]
 8028d86:	2301      	movs	r3, #1
 8028d88:	408b      	lsls	r3, r1
 8028d8a:	6053      	str	r3, [r2, #4]
 8028d8c:	4770      	bx	lr
 8028d8e:	bf00      	nop
 8028d90:	0802f8d0 	.word	0x0802f8d0

08028d94 <bsp_led_red_toggle>:
}

//============================================================================

void bsp_led_red_toggle(void)
{
 8028d94:	4b03      	ldr	r3, [pc, #12]	; (8028da4 <bsp_led_red_toggle+0x10>)

__STATIC_INLINE void XMC_GPIO_ToggleOutput(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_ToggleOutput: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = 0x10001U << pin;
 8028d96:	7c19      	ldrb	r1, [r3, #16]
 8028d98:	681a      	ldr	r2, [r3, #0]
 8028d9a:	f04f 1301 	mov.w	r3, #65537	; 0x10001
 8028d9e:	408b      	lsls	r3, r1
 8028da0:	6053      	str	r3, [r2, #4]
 8028da2:	4770      	bx	lr
 8028da4:	0802f8d0 	.word	0x0802f8d0

08028da8 <com_init>:
   6. EXPORTED FUNCTIONS
==============================================================================
 */
   
   void com_init(void)
   {
 8028da8:	4770      	bx	lr
 8028daa:	bf00      	nop

08028dac <com_send_data>:

//============================================================================

void com_send_data(const void* pData, uint16_t uNumBytes)
{
  USBD_VCOM_SendData(pData,uNumBytes);
 8028dac:	f7fc b8fe 	b.w	8024fac <USBD_VCOM_SendData>

08028db0 <com_get_data>:
}

//============================================================================

uint16_t com_get_data(void* pData, uint16_t uNumBytes)
{
 8028db0:	b538      	push	{r3, r4, r5, lr}
 8028db2:	460c      	mov	r4, r1
 8028db4:	4605      	mov	r5, r0
  uint16_t bytes = 0;
  
  bytes = USBD_VCOM_BytesReceived();
 8028db6:	f7fc f937 	bl	8025028 <USBD_VCOM_BytesReceived>
  
  bytes = (bytes > uNumBytes) ? uNumBytes : bytes;
 8028dba:	42a0      	cmp	r0, r4
 8028dbc:	bf28      	it	cs
 8028dbe:	4620      	movcs	r0, r4
 8028dc0:	b284      	uxth	r4, r0
  
  if (bytes)
 8028dc2:	b11c      	cbz	r4, 8028dcc <com_get_data+0x1c>
  {
    USBD_VCOM_ReceiveData((int8_t*)pData, bytes);
 8028dc4:	4628      	mov	r0, r5
 8028dc6:	4621      	mov	r1, r4
 8028dc8:	f7fc f90a 	bl	8024fe0 <USBD_VCOM_ReceiveData>
  }
  
  return (bytes);
}
 8028dcc:	4620      	mov	r0, r4
 8028dce:	bd38      	pop	{r3, r4, r5, pc}

08028dd0 <com_flush>:

//============================================================================

void com_flush(void)
{
  CDC_Device_USBTask(&USBD_VCOM_cdc_interface);	/* Do nothing as USBD VCOM already flushes the data that is sent */
 8028dd0:	4801      	ldr	r0, [pc, #4]	; (8028dd8 <com_flush+0x8>)
 8028dd2:	f7fb bf33 	b.w	8024c3c <CDC_Device_USBTask>
 8028dd6:	bf00      	nop
 8028dd8:	1fff0384 	.word	0x1fff0384

08028ddc <I2C_MASTER_Init>:
/* Function to initialize the USIC Channel with GUI configured values.*/
I2C_MASTER_STATUS_t I2C_MASTER_Init(const I2C_MASTER_t *const handle)
{
  I2C_MASTER_STATUS_t status;

  if (handle != NULL)
 8028ddc:	b128      	cbz	r0, 8028dea <I2C_MASTER_Init+0xe>
  return (version);
}

/* Function to initialize the USIC Channel with GUI configured values.*/
I2C_MASTER_STATUS_t I2C_MASTER_Init(const I2C_MASTER_t *const handle)
{
 8028dde:	b508      	push	{r3, lr}
  I2C_MASTER_STATUS_t status;

  if (handle != NULL)
  {
    /*Initialize the multiplexers required for I2C_MASTER configuration*/
    handle->config->fptr_i2c_config();
 8028de0:	6843      	ldr	r3, [r0, #4]
 8028de2:	685b      	ldr	r3, [r3, #4]
 8028de4:	4798      	blx	r3

    status = I2C_MASTER_STATUS_SUCCESS;
 8028de6:	2000      	movs	r0, #0
 8028de8:	bd08      	pop	{r3, pc}
  }
  else
  {
    status = I2C_MASTER_STATUS_FAILURE;
 8028dea:	2001      	movs	r0, #1
 8028dec:	4770      	bx	lr
 8028dee:	bf00      	nop

08028df0 <I2C_MASTER_Transmit>:
}

/* Function to transmit the data to slave device */
I2C_MASTER_STATUS_t I2C_MASTER_Transmit(I2C_MASTER_t *handle, bool send_start, const uint32_t address,
                                        uint8_t *data, const uint32_t size, bool send_stop)
{
 8028df0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8028df4:	4605      	mov	r5, r0
  I2C_MASTER_STATUS_t status;

  status = I2C_MASTER_STATUS_BUSY;

  if (handle->config->transmit_mode == I2C_MASTER_TRANSFER_MODE_INTERRUPT)
 8028df6:	6840      	ldr	r0, [r0, #4]
}

/* Function to transmit the data to slave device */
I2C_MASTER_STATUS_t I2C_MASTER_Transmit(I2C_MASTER_t *handle, bool send_start, const uint32_t address,
                                        uint8_t *data, const uint32_t size, bool send_stop)
{
 8028df8:	9f08      	ldr	r7, [sp, #32]
  I2C_MASTER_STATUS_t status;

  status = I2C_MASTER_STATUS_BUSY;

  if (handle->config->transmit_mode == I2C_MASTER_TRANSFER_MODE_INTERRUPT)
 8028dfa:	f890 4024 	ldrb.w	r4, [r0, #36]	; 0x24
}

/* Function to transmit the data to slave device */
I2C_MASTER_STATUS_t I2C_MASTER_Transmit(I2C_MASTER_t *handle, bool send_start, const uint32_t address,
                                        uint8_t *data, const uint32_t size, bool send_stop)
{
 8028dfe:	f89d 8024 	ldrb.w	r8, [sp, #36]	; 0x24
  I2C_MASTER_STATUS_t status;

  status = I2C_MASTER_STATUS_BUSY;

  if (handle->config->transmit_mode == I2C_MASTER_TRANSFER_MODE_INTERRUPT)
 8028e02:	2c01      	cmp	r4, #1
 8028e04:	d802      	bhi.n	8028e0c <I2C_MASTER_Transmit+0x1c>
I2C_MASTER_STATUS_t I2C_MASTER_Transmit(I2C_MASTER_t *handle, bool send_start, const uint32_t address,
                                        uint8_t *data, const uint32_t size, bool send_stop)
{
  I2C_MASTER_STATUS_t status;

  status = I2C_MASTER_STATUS_BUSY;
 8028e06:	2002      	movs	r0, #2
 8028e08:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8028e0c:	4699      	mov	r9, r3

  status = I2C_MASTER_STATUS_BUSY;

  buffer_index = 0U;

  if ((((send_start == false) && (handle->runtime->bus_acquired == false)) || (data == NULL) || (size == 0U)))
 8028e0e:	b921      	cbnz	r1, 8028e1a <I2C_MASTER_Transmit+0x2a>
 8028e10:	68ab      	ldr	r3, [r5, #8]
 8028e12:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8028e16:	2b00      	cmp	r3, #0
 8028e18:	d04c      	beq.n	8028eb4 <I2C_MASTER_Transmit+0xc4>
 8028e1a:	f1b9 0f00 	cmp.w	r9, #0
 8028e1e:	d049      	beq.n	8028eb4 <I2C_MASTER_Transmit+0xc4>
 8028e20:	2f00      	cmp	r7, #0
 8028e22:	d047      	beq.n	8028eb4 <I2C_MASTER_Transmit+0xc4>
  {
    status = I2C_MASTER_STATUS_FAILURE;
  }
  else
  {
    if (send_start == true)
 8028e24:	2900      	cmp	r1, #0
 8028e26:	d04a      	beq.n	8028ebe <I2C_MASTER_Transmit+0xce>
    {
      if (handle->runtime->bus_acquired == false)
 8028e28:	68a9      	ldr	r1, [r5, #8]
 8028e2a:	f891 3028 	ldrb.w	r3, [r1, #40]	; 0x28
 8028e2e:	f003 04ff 	and.w	r4, r3, #255	; 0xff
 8028e32:	2b00      	cmp	r3, #0
 8028e34:	f000 8089 	beq.w	8028f4a <I2C_MASTER_Transmit+0x15a>
 8028e38:	4602      	mov	r2, r0
 8028e3a:	6828      	ldr	r0, [r5, #0]
        }

        I2C_MASTER_ClearFlag(handle, (uint32_t)XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED);
      }
    }
    if (handle->config->txFIFO_size == XMC_USIC_CH_FIFO_DISABLED)
 8028e3c:	f892 3026 	ldrb.w	r3, [r2, #38]	; 0x26
 8028e40:	2b00      	cmp	r3, #0
 8028e42:	d042      	beq.n	8028eca <I2C_MASTER_Transmit+0xda>
    else
    {
      while (buffer_index < size)
      {
        /* Fill the transmit FIFO */
        while (I2C_MASTER_IsTXFIFOFull(handle) == false)
 8028e44:	2400      	movs	r4, #0
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_TXFIFO_IsEmpty(), XMC_USIC_CH_TXFIFO_Flush() \n\n\n
 */
__STATIC_INLINE bool XMC_USIC_CH_TXFIFO_IsFull(XMC_USIC_CH_t *const channel)
{
  return (bool)(channel->TRBSR & USIC_CH_TRBSR_TFULL_Msk);
 8028e46:	f8d0 3114 	ldr.w	r3, [r0, #276]	; 0x114
 8028e4a:	04da      	lsls	r2, r3, #19
 8028e4c:	d411      	bmi.n	8028e72 <I2C_MASTER_Transmit+0x82>
        {
          /* transmit each byte till index reaches to the last byte */
          if (buffer_index < size)
 8028e4e:	42a7      	cmp	r7, r4
 8028e50:	d933      	bls.n	8028eba <I2C_MASTER_Transmit+0xca>
 8028e52:	eb09 0604 	add.w	r6, r9, r4
 8028e56:	e001      	b.n	8028e5c <I2C_MASTER_Transmit+0x6c>
 8028e58:	42a7      	cmp	r7, r4
 8028e5a:	d92e      	bls.n	8028eba <I2C_MASTER_Transmit+0xca>
 * @endcode
 */
__STATIC_INLINE void I2C_MASTER_TransmitByte(I2C_MASTER_t * const handle, uint8_t byte)
{
  XMC_ASSERT("I2C_MASTER_TransmitByte: invalid handle", (handle != NULL))
  XMC_I2C_CH_MasterTransmit(handle->channel, byte);
 8028e5c:	f816 1b01 	ldrb.w	r1, [r6], #1
 8028e60:	f7f9 f86a 	bl	8021f38 <XMC_I2C_CH_MasterTransmit>
 8028e64:	6828      	ldr	r0, [r5, #0]
 8028e66:	f8d0 3114 	ldr.w	r3, [r0, #276]	; 0x114
    else
    {
      while (buffer_index < size)
      {
        /* Fill the transmit FIFO */
        while (I2C_MASTER_IsTXFIFOFull(handle) == false)
 8028e6a:	04d9      	lsls	r1, r3, #19
          /* transmit each byte till index reaches to the last byte */
          if (buffer_index < size)
          {
            /* load the FIFO, byte by byte till either FIFO is full or all data is loaded*/
            I2C_MASTER_TransmitByte(handle, data[buffer_index]);
            buffer_index++;
 8028e6c:	f104 0401 	add.w	r4, r4, #1
    else
    {
      while (buffer_index < size)
      {
        /* Fill the transmit FIFO */
        while (I2C_MASTER_IsTXFIFOFull(handle) == false)
 8028e70:	d5f2      	bpl.n	8028e58 <I2C_MASTER_Transmit+0x68>
        buffer_index++;
      }
    }
    else
    {
      while (buffer_index < size)
 8028e72:	42a7      	cmp	r7, r4
      {
        /* Fill the transmit FIFO */
        while (I2C_MASTER_IsTXFIFOFull(handle) == false)
 8028e74:	4602      	mov	r2, r0
        buffer_index++;
      }
    }
    else
    {
      while (buffer_index < size)
 8028e76:	d8e6      	bhi.n	8028e46 <I2C_MASTER_Transmit+0x56>
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_TXFIFO_Flush(), XMC_USIC_CH_TXFIFO_PutData() \n\n\n
 */
__STATIC_INLINE bool XMC_USIC_CH_TXFIFO_IsEmpty(XMC_USIC_CH_t *const channel)
{
  return (bool)(channel->TRBSR & USIC_CH_TRBSR_TEMPTY_Msk);
 8028e78:	f8d0 3114 	ldr.w	r3, [r0, #276]	; 0x114
            break;
          }
        }
      }
      /*make sure data is transmitted from FIFO*/
      while (!XMC_USIC_CH_TXFIFO_IsEmpty(handle->channel)){}
 8028e7c:	051b      	lsls	r3, r3, #20
 8028e7e:	d5fb      	bpl.n	8028e78 <I2C_MASTER_Transmit+0x88>
    }

    if (send_stop == true)
 8028e80:	f1b8 0f00 	cmp.w	r8, #0
 8028e84:	f040 8094 	bne.w	8028fb0 <I2C_MASTER_Transmit+0x1c0>
    {
      handle->runtime->bus_acquired = false;
      I2C_MASTER_SendStop(handle);
    }

    status = I2C_MASTER_STATUS_SUCCESS;
 8028e88:	4640      	mov	r0, r8
 8028e8a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
                            (uint32_t)XMC_I2C_CH_STATUS_FLAG_ARBITRATION_LOST |
                            (uint32_t)XMC_I2C_CH_STATUS_FLAG_ERROR |
                            (uint32_t)XMC_I2C_CH_STATUS_FLAG_WRONG_TDF_CODE_FOUND))
          {
   	        /* Check for NACK event */
    	    if (psr_status & (uint32_t)XMC_I2C_CH_STATUS_FLAG_NACK_RECEIVED)
 8028e8e:	0690      	lsls	r0, r2, #26
 8028e90:	d503      	bpl.n	8028e9a <I2C_MASTER_Transmit+0xaa>
 8028e92:	6cd9      	ldr	r1, [r3, #76]	; 0x4c
 8028e94:	f041 0120 	orr.w	r1, r1, #32
 8028e98:	64d9      	str	r1, [r3, #76]	; 0x4c
    	    {
    	      I2C_MASTER_ClearFlag(handle,(uint32_t)XMC_I2C_CH_STATUS_FLAG_NACK_RECEIVED);
    	    }

    	    /* Check for arbitration lost */
    	    if (psr_status & (uint32_t)XMC_I2C_CH_STATUS_FLAG_ARBITRATION_LOST)
 8028e9a:	0651      	lsls	r1, r2, #25
 8028e9c:	d503      	bpl.n	8028ea6 <I2C_MASTER_Transmit+0xb6>
 8028e9e:	6cd9      	ldr	r1, [r3, #76]	; 0x4c
 8028ea0:	f041 0140 	orr.w	r1, r1, #64	; 0x40
 8028ea4:	64d9      	str	r1, [r3, #76]	; 0x4c
    	    {
    	      I2C_MASTER_ClearFlag(handle,(uint32_t)XMC_I2C_CH_STATUS_FLAG_ARBITRATION_LOST);
    	    }

    	    /* Check for error detected */
    	    if (psr_status & ((uint32_t)XMC_I2C_CH_STATUS_FLAG_ERROR | (uint32_t)XMC_I2C_CH_STATUS_FLAG_WRONG_TDF_CODE_FOUND))
 8028ea6:	f412 7f81 	tst.w	r2, #258	; 0x102
 8028eaa:	d003      	beq.n	8028eb4 <I2C_MASTER_Transmit+0xc4>
 8028eac:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8028eae:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8028eb2:	64da      	str	r2, [r3, #76]	; 0x4c
    	    {
    	      I2C_MASTER_ClearFlag(handle,(uint32_t)XMC_I2C_CH_STATUS_FLAG_ERROR);
    	    }

            status = I2C_MASTER_STATUS_FAILURE;
            return (status);
 8028eb4:	2001      	movs	r0, #1
 8028eb6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      {
        /* Fill the transmit FIFO */
        while (I2C_MASTER_IsTXFIFOFull(handle) == false)
        {
          /* transmit each byte till index reaches to the last byte */
          if (buffer_index < size)
 8028eba:	4602      	mov	r2, r0
 8028ebc:	e7dc      	b.n	8028e78 <I2C_MASTER_Transmit+0x88>
        }

        I2C_MASTER_ClearFlag(handle, (uint32_t)XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED);
      }
    }
    if (handle->config->txFIFO_size == XMC_USIC_CH_FIFO_DISABLED)
 8028ebe:	f890 3026 	ldrb.w	r3, [r0, #38]	; 0x26
 8028ec2:	2b00      	cmp	r3, #0
 8028ec4:	d03f      	beq.n	8028f46 <I2C_MASTER_Transmit+0x156>
 8028ec6:	6828      	ldr	r0, [r5, #0]
 8028ec8:	e7bc      	b.n	8028e44 <I2C_MASTER_Transmit+0x54>
 8028eca:	4602      	mov	r2, r0
 8028ecc:	4e48      	ldr	r6, [pc, #288]	; (8028ff0 <I2C_MASTER_Transmit+0x200>)
      while (buffer_index < size)
      {
        I2C_MASTER_TransmitByte(handle, data[buffer_index]);

        /* Wait for ACK or timeout */
        I2C_Timeout = 0X2FFFFF;
 8028ece:	4c49      	ldr	r4, [pc, #292]	; (8028ff4 <I2C_MASTER_Transmit+0x204>)
 8028ed0:	444f      	add	r7, r9
 8028ed2:	46b2      	mov	sl, r6
 8028ed4:	4610      	mov	r0, r2
 8028ed6:	f819 1b01 	ldrb.w	r1, [r9], #1
 8028eda:	f7f9 f82d 	bl	8021f38 <XMC_I2C_CH_MasterTransmit>
/* Function to get flag status of the requested parameter */
uint32_t I2C_MASTER_GetFlagStatus(const I2C_MASTER_t *handle, uint32_t flagtype)
{
  uint32_t status;

  status = XMC_I2C_CH_GetStatusFlag(handle->channel);
 8028ede:	682a      	ldr	r2, [r5, #0]
      while (buffer_index < size)
      {
        I2C_MASTER_TransmitByte(handle, data[buffer_index]);

        /* Wait for ACK or timeout */
        I2C_Timeout = 0X2FFFFF;
 8028ee0:	6034      	str	r4, [r6, #0]
 * \par<b>Related APIs:</b><br>
 * XMC_I2C_CH_ClearStatusFlag()\n\n
 */
__STATIC_INLINE uint32_t XMC_I2C_CH_GetStatusFlag(XMC_USIC_CH_t *const channel)
{
  return (channel->PSR_IICMode);
 8028ee2:	6c93      	ldr	r3, [r2, #72]	; 0x48
        psr_status = 0;
        while ((I2C_MASTER_GetFlagStatus(handle, (uint32_t)XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED) == 0U) && (I2C_Timeout > 0))
 8028ee4:	059b      	lsls	r3, r3, #22
 8028ee6:	d50a      	bpl.n	8028efe <I2C_MASTER_Transmit+0x10e>
 8028ee8:	e00d      	b.n	8028f06 <I2C_MASTER_Transmit+0x116>
 8028eea:	6c93      	ldr	r3, [r2, #72]	; 0x48
        {
          /* Get flag status */
          psr_status = XMC_I2C_CH_GetStatusFlag(handle->channel);

          /* Check if an error flag is set */
          if (psr_status & ((uint32_t)XMC_I2C_CH_STATUS_FLAG_NACK_RECEIVED |
 8028eec:	f413 7fb1 	tst.w	r3, #354	; 0x162
 8028ef0:	d113      	bne.n	8028f1a <I2C_MASTER_Transmit+0x12a>

            status = I2C_MASTER_STATUS_FAILURE;
            return (status);
          }

          I2C_Timeout--;
 8028ef2:	6833      	ldr	r3, [r6, #0]
 8028ef4:	3b01      	subs	r3, #1
 8028ef6:	6033      	str	r3, [r6, #0]
 8028ef8:	6c93      	ldr	r3, [r2, #72]	; 0x48
        I2C_MASTER_TransmitByte(handle, data[buffer_index]);

        /* Wait for ACK or timeout */
        I2C_Timeout = 0X2FFFFF;
        psr_status = 0;
        while ((I2C_MASTER_GetFlagStatus(handle, (uint32_t)XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED) == 0U) && (I2C_Timeout > 0))
 8028efa:	0598      	lsls	r0, r3, #22
 8028efc:	d403      	bmi.n	8028f06 <I2C_MASTER_Transmit+0x116>
 8028efe:	f8da 3000 	ldr.w	r3, [sl]
 8028f02:	2b00      	cmp	r3, #0
 8028f04:	d1f1      	bne.n	8028eea <I2C_MASTER_Transmit+0xfa>

          I2C_Timeout--;
        }

        /* Undefined error, return Timeout */
        if (I2C_Timeout == 0)
 8028f06:	6833      	ldr	r3, [r6, #0]
 8028f08:	2b00      	cmp	r3, #0
 8028f0a:	d04e      	beq.n	8028faa <I2C_MASTER_Transmit+0x1ba>
 * \par<b>Related APIs:</b><br>
 * XMC_I2C_CH_GetStatusFlag()\n\n
 */
__STATIC_INLINE void XMC_I2C_CH_ClearStatusFlag(XMC_USIC_CH_t *const channel, uint32_t flag)
{
  channel->PSCR |= flag;
 8028f0c:	6cd3      	ldr	r3, [r2, #76]	; 0x4c
      }
    }
    if (handle->config->txFIFO_size == XMC_USIC_CH_FIFO_DISABLED)
    {
      /* send data, byte by byte */
      while (buffer_index < size)
 8028f0e:	45b9      	cmp	r9, r7
 8028f10:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8028f14:	64d3      	str	r3, [r2, #76]	; 0x4c
 8028f16:	d1dd      	bne.n	8028ed4 <I2C_MASTER_Transmit+0xe4>
 8028f18:	e7b2      	b.n	8028e80 <I2C_MASTER_Transmit+0x90>
                            (uint32_t)XMC_I2C_CH_STATUS_FLAG_ARBITRATION_LOST |
                            (uint32_t)XMC_I2C_CH_STATUS_FLAG_ERROR |
                            (uint32_t)XMC_I2C_CH_STATUS_FLAG_WRONG_TDF_CODE_FOUND))
          {
	        /* Check for NACK event */
	        if (psr_status & (uint32_t)XMC_I2C_CH_STATUS_FLAG_NACK_RECEIVED)
 8028f1a:	069d      	lsls	r5, r3, #26
 8028f1c:	d503      	bpl.n	8028f26 <I2C_MASTER_Transmit+0x136>
 8028f1e:	6cd1      	ldr	r1, [r2, #76]	; 0x4c
 8028f20:	f041 0120 	orr.w	r1, r1, #32
 8028f24:	64d1      	str	r1, [r2, #76]	; 0x4c
	        {
	          I2C_MASTER_ClearFlag(handle,(uint32_t)XMC_I2C_CH_STATUS_FLAG_NACK_RECEIVED);
	        }

	        /* Check for arbitration lost */
	        if (psr_status & (uint32_t)XMC_I2C_CH_STATUS_FLAG_ARBITRATION_LOST)
 8028f26:	065c      	lsls	r4, r3, #25
 8028f28:	d503      	bpl.n	8028f32 <I2C_MASTER_Transmit+0x142>
 8028f2a:	6cd1      	ldr	r1, [r2, #76]	; 0x4c
 8028f2c:	f041 0140 	orr.w	r1, r1, #64	; 0x40
 8028f30:	64d1      	str	r1, [r2, #76]	; 0x4c
	        {
	          I2C_MASTER_ClearFlag(handle,(uint32_t)XMC_I2C_CH_STATUS_FLAG_ARBITRATION_LOST);
	        }

	        /* Check for error detected */
	        if (psr_status & ((uint32_t)XMC_I2C_CH_STATUS_FLAG_ERROR | (uint32_t)XMC_I2C_CH_STATUS_FLAG_WRONG_TDF_CODE_FOUND))
 8028f32:	f413 7f81 	tst.w	r3, #258	; 0x102
 8028f36:	d0bd      	beq.n	8028eb4 <I2C_MASTER_Transmit+0xc4>
 8028f38:	6cd3      	ldr	r3, [r2, #76]	; 0x4c
 8028f3a:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8028f3e:	64d3      	str	r3, [r2, #76]	; 0x4c
	        {
	          I2C_MASTER_ClearFlag(handle,(uint32_t)XMC_I2C_CH_STATUS_FLAG_ERROR);
	        }

            status = I2C_MASTER_STATUS_FAILURE;
            return (status);
 8028f40:	2001      	movs	r0, #1
 8028f42:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8028f46:	682a      	ldr	r2, [r5, #0]
 8028f48:	e7c0      	b.n	8028ecc <I2C_MASTER_Transmit+0xdc>
    (I2C_MASTER_DIRECT_TX_ENABLED == 1) || (I2C_MASTER_DIRECT_RX_ENABLED == 1))
/* Function to issue Send Start/Repeated Start command */
static void I2C_MASTER_lSendStart_Or_RepeatedStart(I2C_MASTER_t * handle,const uint32_t address,
                                               const XMC_I2C_CH_CMD_t cmd)
{
  if (handle->runtime->bus_acquired == true)
 8028f4a:	f891 3028 	ldrb.w	r3, [r1, #40]	; 0x28
 8028f4e:	f003 06ff 	and.w	r6, r3, #255	; 0xff
 8028f52:	2b00      	cmp	r3, #0
 8028f54:	d13b      	bne.n	8028fce <I2C_MASTER_Transmit+0x1de>
 8028f56:	6828      	ldr	r0, [r5, #0]
  {
  I2C_MASTER_SendRepeatedStart(handle, (uint16_t)address, cmd);
  }
  else
  {
    handle->runtime->bus_acquired = true;
 8028f58:	2301      	movs	r3, #1
 8028f5a:	f881 3028 	strb.w	r3, [r1, #40]	; 0x28
 8028f5e:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 8028f60:	f043 0304 	orr.w	r3, r3, #4
__STATIC_INLINE void I2C_MASTER_SendStart(I2C_MASTER_t * const handle, const uint32_t address,
		                                  const XMC_I2C_CH_CMD_t cmd)
{
  XMC_ASSERT("I2C_MASTER_SendStart: invalid handle", (handle != NULL))
  XMC_I2C_CH_ClearStatusFlag(handle->channel, XMC_I2C_CH_STATUS_FLAG_START_CONDITION_RECEIVED);
  XMC_I2C_CH_MasterStart(handle->channel, (uint16_t)address, cmd);
 8028f64:	b291      	uxth	r1, r2
 8028f66:	64c3      	str	r3, [r0, #76]	; 0x4c
 8028f68:	4632      	mov	r2, r6
 8028f6a:	f7f8 ff9f 	bl	8021eac <XMC_I2C_CH_MasterStart>
      if (handle->runtime->bus_acquired == false)
      {
        I2C_MASTER_lSendStart_Or_RepeatedStart(handle, slave_address, XMC_I2C_CH_CMD_WRITE);

        /* Wait for ACK or timeout */
        I2C_Timeout = 0X1FFFFF;
 8028f6e:	4e20      	ldr	r6, [pc, #128]	; (8028ff0 <I2C_MASTER_Transmit+0x200>)
 8028f70:	4a21      	ldr	r2, [pc, #132]	; (8028ff8 <I2C_MASTER_Transmit+0x208>)
/* Function to get flag status of the requested parameter */
uint32_t I2C_MASTER_GetFlagStatus(const I2C_MASTER_t *handle, uint32_t flagtype)
{
  uint32_t status;

  status = XMC_I2C_CH_GetStatusFlag(handle->channel);
 8028f72:	682b      	ldr	r3, [r5, #0]
      if (handle->runtime->bus_acquired == false)
      {
        I2C_MASTER_lSendStart_Or_RepeatedStart(handle, slave_address, XMC_I2C_CH_CMD_WRITE);

        /* Wait for ACK or timeout */
        I2C_Timeout = 0X1FFFFF;
 8028f74:	6032      	str	r2, [r6, #0]
 * \par<b>Related APIs:</b><br>
 * XMC_I2C_CH_ClearStatusFlag()\n\n
 */
__STATIC_INLINE uint32_t XMC_I2C_CH_GetStatusFlag(XMC_USIC_CH_t *const channel)
{
  return (channel->PSR_IICMode);
 8028f76:	6c9a      	ldr	r2, [r3, #72]	; 0x48
        while ((I2C_MASTER_GetFlagStatus(handle, (uint32_t)XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED) == 0U) && (I2C_Timeout > 0))
 8028f78:	0594      	lsls	r4, r2, #22
 8028f7a:	d414      	bmi.n	8028fa6 <I2C_MASTER_Transmit+0x1b6>
 8028f7c:	6832      	ldr	r2, [r6, #0]
 8028f7e:	b192      	cbz	r2, 8028fa6 <I2C_MASTER_Transmit+0x1b6>
 8028f80:	6c9a      	ldr	r2, [r3, #72]	; 0x48
        {
          /* Get flag status */
          psr_status = XMC_I2C_CH_GetStatusFlag(handle->channel);

          /* Check if an error flag is set */
          if (psr_status & ((uint32_t)XMC_I2C_CH_STATUS_FLAG_NACK_RECEIVED |
 8028f82:	f412 7fb1 	tst.w	r2, #354	; 0x162
 8028f86:	d182      	bne.n	8028e8e <I2C_MASTER_Transmit+0x9e>

            status = I2C_MASTER_STATUS_FAILURE;
            return (status);
          }

          I2C_Timeout--;
 8028f88:	4631      	mov	r1, r6
 8028f8a:	e006      	b.n	8028f9a <I2C_MASTER_Transmit+0x1aa>
      {
        I2C_MASTER_lSendStart_Or_RepeatedStart(handle, slave_address, XMC_I2C_CH_CMD_WRITE);

        /* Wait for ACK or timeout */
        I2C_Timeout = 0X1FFFFF;
        while ((I2C_MASTER_GetFlagStatus(handle, (uint32_t)XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED) == 0U) && (I2C_Timeout > 0))
 8028f8c:	680a      	ldr	r2, [r1, #0]
 8028f8e:	b152      	cbz	r2, 8028fa6 <I2C_MASTER_Transmit+0x1b6>
 8028f90:	6c9a      	ldr	r2, [r3, #72]	; 0x48
        {
          /* Get flag status */
          psr_status = XMC_I2C_CH_GetStatusFlag(handle->channel);

          /* Check if an error flag is set */
          if (psr_status & ((uint32_t)XMC_I2C_CH_STATUS_FLAG_NACK_RECEIVED |
 8028f92:	f412 7fb1 	tst.w	r2, #354	; 0x162
 8028f96:	f47f af7a 	bne.w	8028e8e <I2C_MASTER_Transmit+0x9e>

            status = I2C_MASTER_STATUS_FAILURE;
            return (status);
          }

          I2C_Timeout--;
 8028f9a:	6832      	ldr	r2, [r6, #0]
 8028f9c:	3a01      	subs	r2, #1
 8028f9e:	6032      	str	r2, [r6, #0]
 8028fa0:	6c9a      	ldr	r2, [r3, #72]	; 0x48
      {
        I2C_MASTER_lSendStart_Or_RepeatedStart(handle, slave_address, XMC_I2C_CH_CMD_WRITE);

        /* Wait for ACK or timeout */
        I2C_Timeout = 0X1FFFFF;
        while ((I2C_MASTER_GetFlagStatus(handle, (uint32_t)XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED) == 0U) && (I2C_Timeout > 0))
 8028fa2:	0592      	lsls	r2, r2, #22
 8028fa4:	d5f2      	bpl.n	8028f8c <I2C_MASTER_Transmit+0x19c>

          I2C_Timeout--;
        }

        /* Undefined error, return Timeout */
        if (I2C_Timeout == 0)
 8028fa6:	6832      	ldr	r2, [r6, #0]
 8028fa8:	b9da      	cbnz	r2, 8028fe2 <I2C_MASTER_Transmit+0x1f2>
        {
          status = I2C_MASTER_STATUS_TIMEOUT;
          return (status);
 8028faa:	2004      	movs	r0, #4
 8028fac:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      while (!XMC_USIC_CH_TXFIFO_IsEmpty(handle->channel)){}
    }

    if (send_stop == true)
    {
      handle->runtime->bus_acquired = false;
 8028fb0:	68ab      	ldr	r3, [r5, #8]
 8028fb2:	f04f 0800 	mov.w	r8, #0
 8028fb6:	f883 8028 	strb.w	r8, [r3, #40]	; 0x28
 * \par<b>Related APIs:</b><br>
 * XMC_I2C_CH_GetStatusFlag()\n\n
 */
__STATIC_INLINE void XMC_I2C_CH_ClearStatusFlag(XMC_USIC_CH_t *const channel, uint32_t flag)
{
  channel->PSCR |= flag;
 8028fba:	6cd3      	ldr	r3, [r2, #76]	; 0x4c
 8028fbc:	f043 0310 	orr.w	r3, r3, #16
*/
__STATIC_INLINE void I2C_MASTER_SendStop(I2C_MASTER_t * const handle)
{
  XMC_ASSERT("I2C_MASTER_SendStop: invalid handle", (handle != NULL))
  XMC_I2C_CH_ClearStatusFlag(handle->channel, XMC_I2C_CH_STATUS_FLAG_STOP_CONDITION_RECEIVED);
  XMC_I2C_CH_MasterStop(handle->channel);
 8028fc0:	4610      	mov	r0, r2
 8028fc2:	64d3      	str	r3, [r2, #76]	; 0x4c
 8028fc4:	f7f8 ffa2 	bl	8021f0c <XMC_I2C_CH_MasterStop>
      I2C_MASTER_SendStop(handle);
    }

    status = I2C_MASTER_STATUS_SUCCESS;
 8028fc8:	4640      	mov	r0, r8
 8028fca:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8028fce:	6828      	ldr	r0, [r5, #0]
 8028fd0:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 8028fd2:	f043 0308 	orr.w	r3, r3, #8
__STATIC_INLINE void I2C_MASTER_SendRepeatedStart(I2C_MASTER_t * const handle, const uint32_t address,
		                                          const XMC_I2C_CH_CMD_t cmd)
{
  XMC_ASSERT("I2C_MASTER_SendRepeatedStart: invalid handle", (handle != NULL))
  XMC_I2C_CH_ClearStatusFlag(handle->channel, XMC_I2C_CH_STATUS_FLAG_REPEATED_START_CONDITION_RECEIVED);
  XMC_I2C_CH_MasterRepeatedStart(handle->channel, (uint16_t)address, cmd);
 8028fd6:	b291      	uxth	r1, r2
 8028fd8:	64c3      	str	r3, [r0, #76]	; 0x4c
 8028fda:	4622      	mov	r2, r4
 8028fdc:	f7f8 ff7e 	bl	8021edc <XMC_I2C_CH_MasterRepeatedStart>
 8028fe0:	e7c5      	b.n	8028f6e <I2C_MASTER_Transmit+0x17e>
 8028fe2:	6cd9      	ldr	r1, [r3, #76]	; 0x4c
 8028fe4:	686a      	ldr	r2, [r5, #4]
 8028fe6:	f441 7100 	orr.w	r1, r1, #512	; 0x200
 8028fea:	64d9      	str	r1, [r3, #76]	; 0x4c
 8028fec:	4618      	mov	r0, r3
 8028fee:	e725      	b.n	8028e3c <I2C_MASTER_Transmit+0x4c>
 8028ff0:	1ffeb468 	.word	0x1ffeb468
 8028ff4:	002fffff 	.word	0x002fffff
 8028ff8:	001fffff 	.word	0x001fffff

08028ffc <I2C_MASTER_Receive>:
 *
 *
 **********************************************************************************************************************/
I2C_MASTER_STATUS_t I2C_MASTER_Receive(I2C_MASTER_t *handle, bool send_start, const uint32_t address, uint8_t * data,
                                   const uint32_t count, bool send_stop, bool send_nack)
{
 8028ffc:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8029000:	4604      	mov	r4, r0
  I2C_MASTER_STATUS_t status;

  status = I2C_MASTER_STATUS_BUSY;

  if (handle->config->receive_mode == I2C_MASTER_TRANSFER_MODE_INTERRUPT)
 8029002:	6840      	ldr	r0, [r0, #4]
 *
 *
 **********************************************************************************************************************/
I2C_MASTER_STATUS_t I2C_MASTER_Receive(I2C_MASTER_t *handle, bool send_start, const uint32_t address, uint8_t * data,
                                   const uint32_t count, bool send_stop, bool send_nack)
{
 8029004:	9d0a      	ldr	r5, [sp, #40]	; 0x28
  I2C_MASTER_STATUS_t status;

  status = I2C_MASTER_STATUS_BUSY;

  if (handle->config->receive_mode == I2C_MASTER_TRANSFER_MODE_INTERRUPT)
 8029006:	f890 e025 	ldrb.w	lr, [r0, #37]	; 0x25
 *
 *
 **********************************************************************************************************************/
I2C_MASTER_STATUS_t I2C_MASTER_Receive(I2C_MASTER_t *handle, bool send_start, const uint32_t address, uint8_t * data,
                                   const uint32_t count, bool send_stop, bool send_nack)
{
 802900a:	f89d 602c 	ldrb.w	r6, [sp, #44]	; 0x2c
 802900e:	f89d 8030 	ldrb.w	r8, [sp, #48]	; 0x30
  I2C_MASTER_STATUS_t status;

  status = I2C_MASTER_STATUS_BUSY;

  if (handle->config->receive_mode == I2C_MASTER_TRANSFER_MODE_INTERRUPT)
 8029012:	f1be 0f01 	cmp.w	lr, #1
 8029016:	d802      	bhi.n	802901e <I2C_MASTER_Receive+0x22>
I2C_MASTER_STATUS_t I2C_MASTER_Receive(I2C_MASTER_t *handle, bool send_start, const uint32_t address, uint8_t * data,
                                   const uint32_t count, bool send_stop, bool send_nack)
{
  I2C_MASTER_STATUS_t status;

  status = I2C_MASTER_STATUS_BUSY;
 8029018:	2002      	movs	r0, #2
 802901a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802901e:	461f      	mov	r7, r3
  I2C_MASTER_STATUS_t status;
  uint32_t buffer_index;
  uint32_t temp_index;

  status = I2C_MASTER_STATUS_BUSY;
  if ((((send_start == false) && (handle->runtime->bus_acquired == false)) || (data == NULL) || (count == 0U)))
 8029020:	b919      	cbnz	r1, 802902a <I2C_MASTER_Receive+0x2e>
 8029022:	68a3      	ldr	r3, [r4, #8]
 8029024:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8029028:	b383      	cbz	r3, 802908c <I2C_MASTER_Receive+0x90>
 802902a:	b37f      	cbz	r7, 802908c <I2C_MASTER_Receive+0x90>
 802902c:	b375      	cbz	r5, 802908c <I2C_MASTER_Receive+0x90>
  }
  else
  {
  buffer_index = 0U;
  temp_index = 0U;
    if (send_start == true)
 802902e:	2900      	cmp	r1, #0
 8029030:	d143      	bne.n	80290ba <I2C_MASTER_Receive+0xbe>
      /* wait for ACK */
    }
    I2C_MASTER_ClearFlag(handle, (uint32_t)XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED);
  }

  if (handle->config->txFIFO_size == XMC_USIC_CH_FIFO_DISABLED)
 8029032:	f890 3026 	ldrb.w	r3, [r0, #38]	; 0x26
 8029036:	2b00      	cmp	r3, #0
 8029038:	f000 808a 	beq.w	8029150 <I2C_MASTER_Receive+0x154>
 802903c:	6822      	ldr	r2, [r4, #0]
 * @endcode
*/
__STATIC_INLINE void I2C_MASTER_ReceiveNACK(I2C_MASTER_t * const handle)
{
  XMC_ASSERT("I2C_MASTER_ReceiveNACK: invalid handle", (handle != NULL))
  XMC_I2C_CH_MasterReceiveNack(handle->channel);
 802903e:	f04f 0900 	mov.w	r9, #0
 8029042:	46ca      	mov	sl, r9
 8029044:	f1b8 0f00 	cmp.w	r8, #0
 8029048:	d007      	beq.n	802905a <I2C_MASTER_Receive+0x5e>
 802904a:	e027      	b.n	802909c <I2C_MASTER_Receive+0xa0>
    while (temp_index < count)
    {
      while (I2C_MASTER_IsTXFIFOFull(handle) == false)
    {
      /* transmit each byte till index reaches to the last byte */
      if (temp_index < count)
 802904c:	4555      	cmp	r5, sl
 802904e:	d979      	bls.n	8029144 <I2C_MASTER_Receive+0x148>
 * @endcode
*/
__STATIC_INLINE void I2C_MASTER_ReceiveACK(I2C_MASTER_t * const handle)
{
  XMC_ASSERT("I2C_MASTER_ReceiveACK: invalid handle", (handle != NULL))
  XMC_I2C_CH_MasterReceiveAck(handle->channel);
 8029050:	f7f8 ff84 	bl	8021f5c <XMC_I2C_CH_MasterReceiveAck>
 8029054:	6822      	ldr	r2, [r4, #0]
      {
        /* load the FIFO, byte by byte till either FIFO is full or all data is loaded*/
        if (((temp_index + 1U) == count) && (send_nack == true))
 8029056:	f10a 0a01 	add.w	sl, sl, #1
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_TXFIFO_IsEmpty(), XMC_USIC_CH_TXFIFO_Flush() \n\n\n
 */
__STATIC_INLINE bool XMC_USIC_CH_TXFIFO_IsFull(XMC_USIC_CH_t *const channel)
{
  return (bool)(channel->TRBSR & USIC_CH_TRBSR_TFULL_Msk);
 802905a:	f8d2 3114 	ldr.w	r3, [r2, #276]	; 0x114
  else
  {
    temp_index = buffer_index;
    while (temp_index < count)
    {
      while (I2C_MASTER_IsTXFIFOFull(handle) == false)
 802905e:	f413 5f80 	tst.w	r3, #4096	; 0x1000
 8029062:	4610      	mov	r0, r2
 8029064:	d0f2      	beq.n	802904c <I2C_MASTER_Receive+0x50>
      {
        break;
      }
    } /* end of while (I2C_MASTER_IsTXFIFOFull(handle) == false) */

    while (buffer_index < temp_index)
 8029066:	45ca      	cmp	sl, r9
 8029068:	d968      	bls.n	802913c <I2C_MASTER_Receive+0x140>
 802906a:	eb07 0b09 	add.w	fp, r7, r9
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_RXFIFO_Flush(), XMC_USIC_CH_RXFIFO_PutData() \n\n\n
 */
__STATIC_INLINE bool XMC_USIC_CH_RXFIFO_IsEmpty(XMC_USIC_CH_t *const channel)
{
  return (bool)(channel->TRBSR & USIC_CH_TRBSR_REMPTY_Msk);
 802906e:	f8d2 3114 	ldr.w	r3, [r2, #276]	; 0x114
    {
      /* wait for data to come in RX fifo */
      while (I2C_MASTER_IsRXFIFOEmpty(handle)){}
 8029072:	071b      	lsls	r3, r3, #28
 8029074:	d4fb      	bmi.n	802906e <I2C_MASTER_Receive+0x72>
 */
/* Wrapper to the LLD API for reading back the value of the RBUF or OUTR register */
__STATIC_INLINE uint8_t I2C_MASTER_GetReceivedByte(I2C_MASTER_t * const handle)
{
  XMC_ASSERT("I2C_MASTER_GetReceivedByte: invalid handle", (handle != NULL))
  return (uint8_t)XMC_I2C_CH_GetReceivedData(handle->channel);
 8029076:	4610      	mov	r0, r2
 8029078:	f7f8 ff9c 	bl	8021fb4 <XMC_I2C_CH_GetReceivedData>
      data[buffer_index++] = I2C_MASTER_GetReceivedByte(handle);
 802907c:	f109 0901 	add.w	r9, r9, #1
      {
        break;
      }
    } /* end of while (I2C_MASTER_IsTXFIFOFull(handle) == false) */

    while (buffer_index < temp_index)
 8029080:	45d1      	cmp	r9, sl
    {
      /* wait for data to come in RX fifo */
      while (I2C_MASTER_IsRXFIFOEmpty(handle)){}
      data[buffer_index++] = I2C_MASTER_GetReceivedByte(handle);
 8029082:	f80b 0b01 	strb.w	r0, [fp], #1
      {
        break;
      }
    } /* end of while (I2C_MASTER_IsTXFIFOFull(handle) == false) */

    while (buffer_index < temp_index)
 8029086:	d259      	bcs.n	802913c <I2C_MASTER_Receive+0x140>
 8029088:	6822      	ldr	r2, [r4, #0]
 802908a:	e7f0      	b.n	802906e <I2C_MASTER_Receive+0x72>
  uint32_t temp_index;

  status = I2C_MASTER_STATUS_BUSY;
  if ((((send_start == false) && (handle->runtime->bus_acquired == false)) || (data == NULL) || (count == 0U)))
  {
    status = I2C_MASTER_STATUS_FAILURE;
 802908c:	2001      	movs	r0, #1
 802908e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 * @endcode
*/
__STATIC_INLINE void I2C_MASTER_ReceiveNACK(I2C_MASTER_t * const handle)
{
  XMC_ASSERT("I2C_MASTER_ReceiveNACK: invalid handle", (handle != NULL))
  XMC_I2C_CH_MasterReceiveNack(handle->channel);
 8029092:	4610      	mov	r0, r2
 8029094:	f7f8 ff78 	bl	8021f88 <XMC_I2C_CH_MasterReceiveNack>
 8029098:	46aa      	mov	sl, r5
 802909a:	6822      	ldr	r2, [r4, #0]
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_TXFIFO_IsEmpty(), XMC_USIC_CH_TXFIFO_Flush() \n\n\n
 */
__STATIC_INLINE bool XMC_USIC_CH_TXFIFO_IsFull(XMC_USIC_CH_t *const channel)
{
  return (bool)(channel->TRBSR & USIC_CH_TRBSR_TFULL_Msk);
 802909c:	f8d2 3114 	ldr.w	r3, [r2, #276]	; 0x114
  else
  {
    temp_index = buffer_index;
    while (temp_index < count)
    {
      while (I2C_MASTER_IsTXFIFOFull(handle) == false)
 80290a0:	f413 5f80 	tst.w	r3, #4096	; 0x1000
 * @endcode
*/
__STATIC_INLINE void I2C_MASTER_ReceiveACK(I2C_MASTER_t * const handle)
{
  XMC_ASSERT("I2C_MASTER_ReceiveACK: invalid handle", (handle != NULL))
  XMC_I2C_CH_MasterReceiveAck(handle->channel);
 80290a4:	4610      	mov	r0, r2
 80290a6:	d1de      	bne.n	8029066 <I2C_MASTER_Receive+0x6a>
    {
      /* transmit each byte till index reaches to the last byte */
      if (temp_index < count)
 80290a8:	4555      	cmp	r5, sl
 80290aa:	d94b      	bls.n	8029144 <I2C_MASTER_Receive+0x148>
      {
        /* load the FIFO, byte by byte till either FIFO is full or all data is loaded*/
        if (((temp_index + 1U) == count) && (send_nack == true))
 80290ac:	f10a 0a01 	add.w	sl, sl, #1
 80290b0:	4555      	cmp	r5, sl
 80290b2:	d0ee      	beq.n	8029092 <I2C_MASTER_Receive+0x96>
 80290b4:	f7f8 ff52 	bl	8021f5c <XMC_I2C_CH_MasterReceiveAck>
 80290b8:	e7ef      	b.n	802909a <I2C_MASTER_Receive+0x9e>
    (I2C_MASTER_DIRECT_TX_ENABLED == 1) || (I2C_MASTER_DIRECT_RX_ENABLED == 1))
/* Function to issue Send Start/Repeated Start command */
static void I2C_MASTER_lSendStart_Or_RepeatedStart(I2C_MASTER_t * handle,const uint32_t address,
                                               const XMC_I2C_CH_CMD_t cmd)
{
  if (handle->runtime->bus_acquired == true)
 80290ba:	68a3      	ldr	r3, [r4, #8]
 80290bc:	f893 1028 	ldrb.w	r1, [r3, #40]	; 0x28
 80290c0:	2900      	cmp	r1, #0
 80290c2:	d155      	bne.n	8029170 <I2C_MASTER_Receive+0x174>
 80290c4:	6820      	ldr	r0, [r4, #0]
  {
  I2C_MASTER_SendRepeatedStart(handle, (uint16_t)address, cmd);
  }
  else
  {
    handle->runtime->bus_acquired = true;
 80290c6:	f04f 0e01 	mov.w	lr, #1
 80290ca:	f883 e028 	strb.w	lr, [r3, #40]	; 0x28
 80290ce:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 80290d0:	f043 0304 	orr.w	r3, r3, #4
__STATIC_INLINE void I2C_MASTER_SendStart(I2C_MASTER_t * const handle, const uint32_t address,
		                                  const XMC_I2C_CH_CMD_t cmd)
{
  XMC_ASSERT("I2C_MASTER_SendStart: invalid handle", (handle != NULL))
  XMC_I2C_CH_ClearStatusFlag(handle->channel, XMC_I2C_CH_STATUS_FLAG_START_CONDITION_RECEIVED);
  XMC_I2C_CH_MasterStart(handle->channel, (uint16_t)address, cmd);
 80290d4:	b291      	uxth	r1, r2
 80290d6:	64c3      	str	r3, [r0, #76]	; 0x4c
 80290d8:	4672      	mov	r2, lr
 80290da:	f7f8 fee7 	bl	8021eac <XMC_I2C_CH_MasterStart>
 80290de:	6822      	ldr	r2, [r4, #0]
 * \par<b>Related APIs:</b><br>
 * XMC_I2C_CH_ClearStatusFlag()\n\n
 */
__STATIC_INLINE uint32_t XMC_I2C_CH_GetStatusFlag(XMC_USIC_CH_t *const channel)
{
  return (channel->PSR_IICMode);
 80290e0:	6c93      	ldr	r3, [r2, #72]	; 0x48
  buffer_index = 0U;
  temp_index = 0U;
    if (send_start == true)
    {
      I2C_MASTER_lSendStart_Or_RepeatedStart(handle, slave_address, XMC_I2C_CH_CMD_READ);
      while (I2C_MASTER_GetFlagStatus(handle, (uint32_t)XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED) == 0U)
 80290e2:	0598      	lsls	r0, r3, #22
 80290e4:	d5fc      	bpl.n	80290e0 <I2C_MASTER_Receive+0xe4>
      /* wait for ACK */
    }
    I2C_MASTER_ClearFlag(handle, (uint32_t)XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED);
  }

  if (handle->config->txFIFO_size == XMC_USIC_CH_FIFO_DISABLED)
 80290e6:	6861      	ldr	r1, [r4, #4]
 * \par<b>Related APIs:</b><br>
 * XMC_I2C_CH_GetStatusFlag()\n\n
 */
__STATIC_INLINE void XMC_I2C_CH_ClearStatusFlag(XMC_USIC_CH_t *const channel, uint32_t flag)
{
  channel->PSCR |= flag;
 80290e8:	6cd3      	ldr	r3, [r2, #76]	; 0x4c
 80290ea:	f891 1026 	ldrb.w	r1, [r1, #38]	; 0x26
 80290ee:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 80290f2:	64d3      	str	r3, [r2, #76]	; 0x4c
 80290f4:	2900      	cmp	r1, #0
 80290f6:	d1a2      	bne.n	802903e <I2C_MASTER_Receive+0x42>
 80290f8:	4610      	mov	r0, r2
 80290fa:	3f01      	subs	r7, #1
 80290fc:	f04f 0900 	mov.w	r9, #0
  {
    while (buffer_index < count)
    {
      if (((buffer_index + 1U) == count) && (send_nack == true))
 8029100:	f109 0901 	add.w	r9, r9, #1
 8029104:	454d      	cmp	r5, r9
 8029106:	d03d      	beq.n	8029184 <I2C_MASTER_Receive+0x188>
 * @endcode
*/
__STATIC_INLINE void I2C_MASTER_ReceiveACK(I2C_MASTER_t * const handle)
{
  XMC_ASSERT("I2C_MASTER_ReceiveACK: invalid handle", (handle != NULL))
  XMC_I2C_CH_MasterReceiveAck(handle->channel);
 8029108:	f7f8 ff28 	bl	8021f5c <XMC_I2C_CH_MasterReceiveAck>
 802910c:	6820      	ldr	r0, [r4, #0]
 802910e:	e002      	b.n	8029116 <I2C_MASTER_Receive+0x11a>
 * \par<b>Related APIs:</b><br>
 * XMC_I2C_CH_ClearStatusFlag()\n\n
 */
__STATIC_INLINE uint32_t XMC_I2C_CH_GetStatusFlag(XMC_USIC_CH_t *const channel)
{
  return (channel->PSR_IICMode);
 8029110:	6c83      	ldr	r3, [r0, #72]	; 0x48
    else
    {
      I2C_MASTER_ReceiveACK(handle);
    }

      while ((I2C_MASTER_GetFlagStatus(handle, (uint32_t)XMC_I2C_CH_STATUS_FLAG_ALTERNATIVE_RECEIVE_INDICATION) == 0U) &&
 8029112:	045a      	lsls	r2, r3, #17
 8029114:	d402      	bmi.n	802911c <I2C_MASTER_Receive+0x120>
 8029116:	6c83      	ldr	r3, [r0, #72]	; 0x48
 8029118:	0419      	lsls	r1, r3, #16
 802911a:	d5f9      	bpl.n	8029110 <I2C_MASTER_Receive+0x114>
 * \par<b>Related APIs:</b><br>
 * XMC_I2C_CH_GetStatusFlag()\n\n
 */
__STATIC_INLINE void XMC_I2C_CH_ClearStatusFlag(XMC_USIC_CH_t *const channel, uint32_t flag)
{
  channel->PSCR |= flag;
 802911c:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 802911e:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8029122:	64c3      	str	r3, [r0, #76]	; 0x4c
 8029124:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 8029126:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 802912a:	64c3      	str	r3, [r0, #76]	; 0x4c
 */
/* Wrapper to the LLD API for reading back the value of the RBUF or OUTR register */
__STATIC_INLINE uint8_t I2C_MASTER_GetReceivedByte(I2C_MASTER_t * const handle)
{
  XMC_ASSERT("I2C_MASTER_GetReceivedByte: invalid handle", (handle != NULL))
  return (uint8_t)XMC_I2C_CH_GetReceivedData(handle->channel);
 802912c:	f7f8 ff42 	bl	8021fb4 <XMC_I2C_CH_GetReceivedData>
    I2C_MASTER_ClearFlag(handle, (uint32_t)XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED);
  }

  if (handle->config->txFIFO_size == XMC_USIC_CH_FIFO_DISABLED)
  {
    while (buffer_index < count)
 8029130:	45a9      	cmp	r9, r5
    }

    I2C_MASTER_ClearFlag(handle, (uint32_t)XMC_I2C_CH_STATUS_FLAG_ALTERNATIVE_RECEIVE_INDICATION);
    I2C_MASTER_ClearFlag(handle, (uint32_t)XMC_I2C_CH_STATUS_FLAG_RECEIVE_INDICATION);

    data[buffer_index++] = I2C_MASTER_GetReceivedByte(handle);
 8029132:	f807 0f01 	strb.w	r0, [r7, #1]!
    I2C_MASTER_ClearFlag(handle, (uint32_t)XMC_I2C_CH_STATUS_FLAG_ACK_RECEIVED);
  }

  if (handle->config->txFIFO_size == XMC_USIC_CH_FIFO_DISABLED)
  {
    while (buffer_index < count)
 8029136:	d007      	beq.n	8029148 <I2C_MASTER_Receive+0x14c>
 8029138:	6820      	ldr	r0, [r4, #0]
 802913a:	e7e1      	b.n	8029100 <I2C_MASTER_Receive+0x104>
    }
  } /* end of if (handle->config->txFIFO_size == XMC_USIC_CH_FIFO_DISABLED) */
  else
  {
    temp_index = buffer_index;
    while (temp_index < count)
 802913c:	4555      	cmp	r5, sl
 802913e:	d903      	bls.n	8029148 <I2C_MASTER_Receive+0x14c>
 8029140:	6822      	ldr	r2, [r4, #0]
 8029142:	e77f      	b.n	8029044 <I2C_MASTER_Receive+0x48>
      {
        break;
      }
    } /* end of while (I2C_MASTER_IsTXFIFOFull(handle) == false) */

    while (buffer_index < temp_index)
 8029144:	45ca      	cmp	sl, r9
 8029146:	d890      	bhi.n	802906a <I2C_MASTER_Receive+0x6e>
      data[buffer_index++] = I2C_MASTER_GetReceivedByte(handle);
    }
    } /* end of while (temp_index < count) */
  } /* end of else */

    if (send_stop == true)
 8029148:	b926      	cbnz	r6, 8029154 <I2C_MASTER_Receive+0x158>
    {
      handle->runtime->bus_acquired = false;
      I2C_MASTER_SendStop(handle);
    }

    status = I2C_MASTER_STATUS_SUCCESS;
 802914a:	4630      	mov	r0, r6
 802914c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8029150:	6820      	ldr	r0, [r4, #0]
 8029152:	e7d2      	b.n	80290fa <I2C_MASTER_Receive+0xfe>
    } /* end of while (temp_index < count) */
  } /* end of else */

    if (send_stop == true)
    {
      handle->runtime->bus_acquired = false;
 8029154:	68a3      	ldr	r3, [r4, #8]
 8029156:	6820      	ldr	r0, [r4, #0]
 8029158:	2600      	movs	r6, #0
 802915a:	f883 6028 	strb.w	r6, [r3, #40]	; 0x28
 802915e:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 8029160:	f043 0310 	orr.w	r3, r3, #16
 8029164:	64c3      	str	r3, [r0, #76]	; 0x4c
*/
__STATIC_INLINE void I2C_MASTER_SendStop(I2C_MASTER_t * const handle)
{
  XMC_ASSERT("I2C_MASTER_SendStop: invalid handle", (handle != NULL))
  XMC_I2C_CH_ClearStatusFlag(handle->channel, XMC_I2C_CH_STATUS_FLAG_STOP_CONDITION_RECEIVED);
  XMC_I2C_CH_MasterStop(handle->channel);
 8029166:	f7f8 fed1 	bl	8021f0c <XMC_I2C_CH_MasterStop>
      I2C_MASTER_SendStop(handle);
    }

    status = I2C_MASTER_STATUS_SUCCESS;
 802916a:	4630      	mov	r0, r6
 802916c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8029170:	6820      	ldr	r0, [r4, #0]
 8029172:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 8029174:	f043 0308 	orr.w	r3, r3, #8
__STATIC_INLINE void I2C_MASTER_SendRepeatedStart(I2C_MASTER_t * const handle, const uint32_t address,
		                                          const XMC_I2C_CH_CMD_t cmd)
{
  XMC_ASSERT("I2C_MASTER_SendRepeatedStart: invalid handle", (handle != NULL))
  XMC_I2C_CH_ClearStatusFlag(handle->channel, XMC_I2C_CH_STATUS_FLAG_REPEATED_START_CONDITION_RECEIVED);
  XMC_I2C_CH_MasterRepeatedStart(handle->channel, (uint16_t)address, cmd);
 8029178:	b291      	uxth	r1, r2
 802917a:	64c3      	str	r3, [r0, #76]	; 0x4c
 802917c:	2201      	movs	r2, #1
 802917e:	f7f8 fead 	bl	8021edc <XMC_I2C_CH_MasterRepeatedStart>
 8029182:	e7ac      	b.n	80290de <I2C_MASTER_Receive+0xe2>

  if (handle->config->txFIFO_size == XMC_USIC_CH_FIFO_DISABLED)
  {
    while (buffer_index < count)
    {
      if (((buffer_index + 1U) == count) && (send_nack == true))
 8029184:	f1b8 0f00 	cmp.w	r8, #0
 8029188:	d0be      	beq.n	8029108 <I2C_MASTER_Receive+0x10c>
 * @endcode
*/
__STATIC_INLINE void I2C_MASTER_ReceiveNACK(I2C_MASTER_t * const handle)
{
  XMC_ASSERT("I2C_MASTER_ReceiveNACK: invalid handle", (handle != NULL))
  XMC_I2C_CH_MasterReceiveNack(handle->channel);
 802918a:	f7f8 fefd 	bl	8021f88 <XMC_I2C_CH_MasterReceiveNack>
 802918e:	e7bd      	b.n	802910c <I2C_MASTER_Receive+0x110>

08029190 <I2C_MASTER_EEPROM_disable_io>:
  .baudrate = (uint32_t)(400000U),
  .address  = 0
};

static void I2C_MASTER_EEPROM_disable_io(void)
{
 8029190:	b510      	push	{r4, lr}
  XMC_GPIO_SetMode((XMC_GPIO_PORT_t *)PORT2_BASE, (uint8_t)5, XMC_GPIO_MODE_INPUT_TRISTATE);
 8029192:	4c06      	ldr	r4, [pc, #24]	; (80291ac <I2C_MASTER_EEPROM_disable_io+0x1c>)
 8029194:	2105      	movs	r1, #5
 8029196:	4620      	mov	r0, r4
 8029198:	2200      	movs	r2, #0
 802919a:	f7f8 fe25 	bl	8021de8 <XMC_GPIO_SetMode>
  XMC_GPIO_SetMode((XMC_GPIO_PORT_t *)PORT2_BASE, (uint8_t)4, XMC_GPIO_MODE_INPUT_TRISTATE);
 802919e:	4620      	mov	r0, r4
 80291a0:	2104      	movs	r1, #4
 80291a2:	2200      	movs	r2, #0
}
 80291a4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
};

static void I2C_MASTER_EEPROM_disable_io(void)
{
  XMC_GPIO_SetMode((XMC_GPIO_PORT_t *)PORT2_BASE, (uint8_t)5, XMC_GPIO_MODE_INPUT_TRISTATE);
  XMC_GPIO_SetMode((XMC_GPIO_PORT_t *)PORT2_BASE, (uint8_t)4, XMC_GPIO_MODE_INPUT_TRISTATE);
 80291a8:	f7f8 be1e 	b.w	8021de8 <XMC_GPIO_SetMode>
 80291ac:	48028200 	.word	0x48028200

080291b0 <I2C_MASTER_EEPROM_enable_io>:
}

static void I2C_MASTER_EEPROM_enable_io(void)
{
 80291b0:	b510      	push	{r4, lr}
  XMC_GPIO_SetMode((XMC_GPIO_PORT_t *)PORT2_BASE, (uint8_t)5, I2C_MASTER_EEPROM_sda_pin_config.mode);
 80291b2:	4c06      	ldr	r4, [pc, #24]	; (80291cc <I2C_MASTER_EEPROM_enable_io+0x1c>)
 80291b4:	2105      	movs	r1, #5
 80291b6:	4620      	mov	r0, r4
 80291b8:	22d0      	movs	r2, #208	; 0xd0
 80291ba:	f7f8 fe15 	bl	8021de8 <XMC_GPIO_SetMode>
  XMC_GPIO_SetMode((XMC_GPIO_PORT_t *)PORT2_BASE, (uint8_t)4, I2C_MASTER_EEPROM_scl_pin_config.mode);
 80291be:	4620      	mov	r0, r4
 80291c0:	2104      	movs	r1, #4
 80291c2:	22d0      	movs	r2, #208	; 0xd0
}
 80291c4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
}

static void I2C_MASTER_EEPROM_enable_io(void)
{
  XMC_GPIO_SetMode((XMC_GPIO_PORT_t *)PORT2_BASE, (uint8_t)5, I2C_MASTER_EEPROM_sda_pin_config.mode);
  XMC_GPIO_SetMode((XMC_GPIO_PORT_t *)PORT2_BASE, (uint8_t)4, I2C_MASTER_EEPROM_scl_pin_config.mode);
 80291c8:	f7f8 be0e 	b.w	8021de8 <XMC_GPIO_SetMode>
 80291cc:	48028200 	.word	0x48028200

080291d0 <I2C_MASTER_EEPROM_init>:
  .config = &I2C_MASTER_EEPROM_config,
  .runtime = &I2C_MASTER_EEPROM_runtime,
};

void I2C_MASTER_EEPROM_init(void)
{
 80291d0:	b538      	push	{r3, r4, r5, lr}
 
  XMC_I2C_CH_Init(XMC_I2C0_CH1, &I2C_MASTER_EEPROM_channel_config);
 80291d2:	4c19      	ldr	r4, [pc, #100]	; (8029238 <I2C_MASTER_EEPROM_init+0x68>)
 80291d4:	4919      	ldr	r1, [pc, #100]	; (802923c <I2C_MASTER_EEPROM_init+0x6c>)
  XMC_USIC_CH_EnableInputDigitalFilter(XMC_I2C0_CH1, XMC_USIC_CH_INPUT_DX1);
  XMC_USIC_CH_EnableInputSync(XMC_I2C0_CH1, XMC_USIC_CH_INPUT_DX1);
    
  XMC_I2C_CH_Start(XMC_I2C0_CH1);

  XMC_GPIO_Init((XMC_GPIO_PORT_t *)PORT2_BASE, (uint8_t)5, &I2C_MASTER_EEPROM_sda_pin_config);
 80291d6:	4d1a      	ldr	r5, [pc, #104]	; (8029240 <I2C_MASTER_EEPROM_init+0x70>)
};

void I2C_MASTER_EEPROM_init(void)
{
 
  XMC_I2C_CH_Init(XMC_I2C0_CH1, &I2C_MASTER_EEPROM_channel_config);
 80291d8:	4620      	mov	r0, r4
 80291da:	f7f8 fe29 	bl	8021e30 <XMC_I2C_CH_Init>
 * XMC_USIC_CH_EnableInputInversion(), XMC_USIC_CH_EnableInputDigitalFilter(), XMC_USIC_CH_EnableInputSync(),
 * XMC_USIC_CH_SetInputSamplingFreq()\n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_SetInputSource(XMC_USIC_CH_t *const channel, const XMC_USIC_CH_INPUT_t input, const uint8_t source)
{
  channel->DXCR[input] = (uint32_t)((channel->DXCR[input] & (uint32_t)(~USIC_CH_DXCR_DSEL_Msk)) |
 80291de:	69e3      	ldr	r3, [r4, #28]
  XMC_USIC_CH_EnableInputDigitalFilter(XMC_I2C0_CH1, XMC_USIC_CH_INPUT_DX1);
  XMC_USIC_CH_EnableInputSync(XMC_I2C0_CH1, XMC_USIC_CH_INPUT_DX1);
    
  XMC_I2C_CH_Start(XMC_I2C0_CH1);

  XMC_GPIO_Init((XMC_GPIO_PORT_t *)PORT2_BASE, (uint8_t)5, &I2C_MASTER_EEPROM_sda_pin_config);
 80291e0:	4a18      	ldr	r2, [pc, #96]	; (8029244 <I2C_MASTER_EEPROM_init+0x74>)
 80291e2:	f023 0307 	bic.w	r3, r3, #7
 80291e6:	f043 0301 	orr.w	r3, r3, #1
 80291ea:	61e3      	str	r3, [r4, #28]
 80291ec:	6a23      	ldr	r3, [r4, #32]
 80291ee:	f023 0307 	bic.w	r3, r3, #7
 80291f2:	6223      	str	r3, [r4, #32]
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_DisableInputDigitalFilter()\n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_EnableInputDigitalFilter(XMC_USIC_CH_t *const channel, const XMC_USIC_CH_INPUT_t input)
{
  channel->DXCR[input] |= (uint32_t)USIC_CH_DXCR_DFEN_Msk;
 80291f4:	69e3      	ldr	r3, [r4, #28]
 80291f6:	f043 0320 	orr.w	r3, r3, #32
 80291fa:	61e3      	str	r3, [r4, #28]
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_DisableInputSync(), XMC_USIC_CH_EnableInputDigitalFilter()\n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_EnableInputSync(XMC_USIC_CH_t *const channel, const XMC_USIC_CH_INPUT_t input)
{
  channel->DXCR[input] |=(uint32_t)USIC_CH_DXCR_DSEN_Msk;
 80291fc:	69e3      	ldr	r3, [r4, #28]
 80291fe:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8029202:	61e3      	str	r3, [r4, #28]
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_DisableInputDigitalFilter()\n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_EnableInputDigitalFilter(XMC_USIC_CH_t *const channel, const XMC_USIC_CH_INPUT_t input)
{
  channel->DXCR[input] |= (uint32_t)USIC_CH_DXCR_DFEN_Msk;
 8029204:	6a23      	ldr	r3, [r4, #32]
 8029206:	f043 0320 	orr.w	r3, r3, #32
 802920a:	6223      	str	r3, [r4, #32]
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_DisableInputSync(), XMC_USIC_CH_EnableInputDigitalFilter()\n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_EnableInputSync(XMC_USIC_CH_t *const channel, const XMC_USIC_CH_INPUT_t input)
{
  channel->DXCR[input] |=(uint32_t)USIC_CH_DXCR_DSEN_Msk;
 802920c:	6a23      	ldr	r3, [r4, #32]
 802920e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8029212:	6223      	str	r3, [r4, #32]
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_Enable(), XMC_USIC_CH_Enable() \n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_SetMode(XMC_USIC_CH_t *const channel, const XMC_USIC_CH_OPERATING_MODE_t mode)
{
  channel->CCR = (uint32_t)(channel->CCR & (~(USIC_CH_CCR_MODE_Msk))) | (uint32_t)mode;
 8029214:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8029216:	f023 030f 	bic.w	r3, r3, #15
 802921a:	f043 0304 	orr.w	r3, r3, #4
 802921e:	4628      	mov	r0, r5
 8029220:	6423      	str	r3, [r4, #64]	; 0x40
 8029222:	2105      	movs	r1, #5
 8029224:	f7f7 fe8c 	bl	8020f40 <XMC_GPIO_Init>
  XMC_GPIO_Init((XMC_GPIO_PORT_t *)PORT2_BASE, (uint8_t)4, &I2C_MASTER_EEPROM_scl_pin_config);
 8029228:	4628      	mov	r0, r5
 802922a:	2104      	movs	r1, #4
 802922c:	4a06      	ldr	r2, [pc, #24]	; (8029248 <I2C_MASTER_EEPROM_init+0x78>)
}
 802922e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  XMC_USIC_CH_EnableInputSync(XMC_I2C0_CH1, XMC_USIC_CH_INPUT_DX1);
    
  XMC_I2C_CH_Start(XMC_I2C0_CH1);

  XMC_GPIO_Init((XMC_GPIO_PORT_t *)PORT2_BASE, (uint8_t)5, &I2C_MASTER_EEPROM_sda_pin_config);
  XMC_GPIO_Init((XMC_GPIO_PORT_t *)PORT2_BASE, (uint8_t)4, &I2C_MASTER_EEPROM_scl_pin_config);
 8029232:	f7f7 be85 	b.w	8020f40 <XMC_GPIO_Init>
 8029236:	bf00      	nop
 8029238:	40030200 	.word	0x40030200
 802923c:	080319bc 	.word	0x080319bc
 8029240:	48028200 	.word	0x48028200
 8029244:	08031978 	.word	0x08031978
 8029248:	08031984 	.word	0x08031984

0802924c <helper_switch_pwm_on.isra.10>:

//============================================================================

static void helper_switch_pwm_on(PWM_CCU8_t *handle_ptr)
{
	if ((bool)true == handle_ptr->config_ptr->gpio_ch1_out0_enable)
 802924c:	6803      	ldr	r3, [r0, #0]
 802924e:	f893 204c 	ldrb.w	r2, [r3, #76]	; 0x4c
	}
}

//============================================================================

static void helper_switch_pwm_on(PWM_CCU8_t *handle_ptr)
 8029252:	b510      	push	{r4, lr}
 8029254:	4604      	mov	r4, r0
{
	if ((bool)true == handle_ptr->config_ptr->gpio_ch1_out0_enable)
 8029256:	bb32      	cbnz	r2, 80292a6 <helper_switch_pwm_on.isra.10+0x5a>
	{
		XMC_GPIO_MODE_t new_mode = handle_ptr->config_ptr->gpio_ch1_out0_config_ptr->mode;
		XMC_GPIO_SetMode(handle_ptr->config_ptr->gpio_ch1_out0_ptr, handle_ptr->config_ptr->gpio_ch1_out0_pin, new_mode);
	}

	if ((bool)true == handle_ptr->config_ptr->gpio_ch1_out1_enable)
 8029258:	f893 205c 	ldrb.w	r2, [r3, #92]	; 0x5c
 802925c:	b9d2      	cbnz	r2, 8029294 <helper_switch_pwm_on.isra.10+0x48>
	{
		XMC_GPIO_MODE_t new_mode = handle_ptr->config_ptr->gpio_ch1_out1_config_ptr->mode;
		XMC_GPIO_SetMode(handle_ptr->config_ptr->gpio_ch1_out1_ptr, handle_ptr->config_ptr->gpio_ch1_out1_pin, new_mode);
	}

	if ((bool)true == handle_ptr->config_ptr->gpio_ch2_out2_enable)
 802925e:	f893 206c 	ldrb.w	r2, [r3, #108]	; 0x6c
 8029262:	b972      	cbnz	r2, 8029282 <helper_switch_pwm_on.isra.10+0x36>
	{
		XMC_GPIO_MODE_t new_mode = handle_ptr->config_ptr->gpio_ch2_out2_config_ptr->mode;
		XMC_GPIO_SetMode(handle_ptr->config_ptr->gpio_ch2_out2_ptr, handle_ptr->config_ptr->gpio_ch2_out2_pin, new_mode);
	}

	if ((bool)true == handle_ptr->config_ptr->gpio_ch2_out3_enable)
 8029264:	f893 207c 	ldrb.w	r2, [r3, #124]	; 0x7c
 8029268:	b902      	cbnz	r2, 802926c <helper_switch_pwm_on.isra.10+0x20>
 802926a:	bd10      	pop	{r4, pc}
	{
		XMC_GPIO_MODE_t new_mode = handle_ptr->config_ptr->gpio_ch2_out3_config_ptr->mode;
 802926c:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
		XMC_GPIO_SetMode(handle_ptr->config_ptr->gpio_ch2_out3_ptr, handle_ptr->config_ptr->gpio_ch2_out3_pin, new_mode);
 8029270:	f8d3 0080 	ldr.w	r0, [r3, #128]	; 0x80
 8029274:	7812      	ldrb	r2, [r2, #0]
 8029276:	f893 1084 	ldrb.w	r1, [r3, #132]	; 0x84
	}
}
 802927a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	}

	if ((bool)true == handle_ptr->config_ptr->gpio_ch2_out3_enable)
	{
		XMC_GPIO_MODE_t new_mode = handle_ptr->config_ptr->gpio_ch2_out3_config_ptr->mode;
		XMC_GPIO_SetMode(handle_ptr->config_ptr->gpio_ch2_out3_ptr, handle_ptr->config_ptr->gpio_ch2_out3_pin, new_mode);
 802927e:	f7f8 bdb3 	b.w	8021de8 <XMC_GPIO_SetMode>
		XMC_GPIO_SetMode(handle_ptr->config_ptr->gpio_ch1_out1_ptr, handle_ptr->config_ptr->gpio_ch1_out1_pin, new_mode);
	}

	if ((bool)true == handle_ptr->config_ptr->gpio_ch2_out2_enable)
	{
		XMC_GPIO_MODE_t new_mode = handle_ptr->config_ptr->gpio_ch2_out2_config_ptr->mode;
 8029282:	6f9a      	ldr	r2, [r3, #120]	; 0x78
		XMC_GPIO_SetMode(handle_ptr->config_ptr->gpio_ch2_out2_ptr, handle_ptr->config_ptr->gpio_ch2_out2_pin, new_mode);
 8029284:	6f18      	ldr	r0, [r3, #112]	; 0x70
 8029286:	f893 1074 	ldrb.w	r1, [r3, #116]	; 0x74
 802928a:	7812      	ldrb	r2, [r2, #0]
 802928c:	f7f8 fdac 	bl	8021de8 <XMC_GPIO_SetMode>
 8029290:	6823      	ldr	r3, [r4, #0]
 8029292:	e7e7      	b.n	8029264 <helper_switch_pwm_on.isra.10+0x18>
		XMC_GPIO_SetMode(handle_ptr->config_ptr->gpio_ch1_out0_ptr, handle_ptr->config_ptr->gpio_ch1_out0_pin, new_mode);
	}

	if ((bool)true == handle_ptr->config_ptr->gpio_ch1_out1_enable)
	{
		XMC_GPIO_MODE_t new_mode = handle_ptr->config_ptr->gpio_ch1_out1_config_ptr->mode;
 8029294:	6e9a      	ldr	r2, [r3, #104]	; 0x68
		XMC_GPIO_SetMode(handle_ptr->config_ptr->gpio_ch1_out1_ptr, handle_ptr->config_ptr->gpio_ch1_out1_pin, new_mode);
 8029296:	6e18      	ldr	r0, [r3, #96]	; 0x60
 8029298:	f893 1064 	ldrb.w	r1, [r3, #100]	; 0x64
 802929c:	7812      	ldrb	r2, [r2, #0]
 802929e:	f7f8 fda3 	bl	8021de8 <XMC_GPIO_SetMode>
 80292a2:	6823      	ldr	r3, [r4, #0]
 80292a4:	e7db      	b.n	802925e <helper_switch_pwm_on.isra.10+0x12>

static void helper_switch_pwm_on(PWM_CCU8_t *handle_ptr)
{
	if ((bool)true == handle_ptr->config_ptr->gpio_ch1_out0_enable)
	{
		XMC_GPIO_MODE_t new_mode = handle_ptr->config_ptr->gpio_ch1_out0_config_ptr->mode;
 80292a6:	6d9a      	ldr	r2, [r3, #88]	; 0x58
		XMC_GPIO_SetMode(handle_ptr->config_ptr->gpio_ch1_out0_ptr, handle_ptr->config_ptr->gpio_ch1_out0_pin, new_mode);
 80292a8:	6d18      	ldr	r0, [r3, #80]	; 0x50
 80292aa:	f893 1054 	ldrb.w	r1, [r3, #84]	; 0x54
 80292ae:	7812      	ldrb	r2, [r2, #0]
 80292b0:	f7f8 fd9a 	bl	8021de8 <XMC_GPIO_SetMode>
 80292b4:	6823      	ldr	r3, [r4, #0]
 80292b6:	e7cf      	b.n	8029258 <helper_switch_pwm_on.isra.10+0xc>

080292b8 <bsp_update>:
}

//============================================================================

uint8_t bsp_update(device_settings_t *p_dev)
{
 80292b8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint32_t duty_ch1_bgt_vcc;								  /* BGT VCC */
	uint32_t bgt_tx_on_duty, bgt_tx_on_shift, bgt_tx_on_freq; /* BGT TX ON */
	uint32_t hold_duty, hold_shift, sample_hold_freq;		  /* Sample and hold */
	uint32_t sample_duty, sample_adc_freq;					  /* ADC sampling */

	uint32_t doppler_sampling_freq_hz = p_dev->adc_sampling_freq_Hz;
 80292bc:	f8d0 b014 	ldr.w	fp, [r0, #20]
	uint32_t pulse_width_usec = p_dev->pulse_width_usec;
 80292c0:	6b05      	ldr	r5, [r0, #48]	; 0x30
	uint32_t sample_hold_on_time_nsec = p_dev->sample_hold_on_time_nsec;
 80292c2:	f8d0 8034 	ldr.w	r8, [r0, #52]	; 0x34

	if (doppler_sampling_freq_hz > BSP_MAX_DOPPLER_SAMPLING_FREQ_HZ || doppler_sampling_freq_hz < BSP_MIN_DOPPLER_SAMPLING_FREQ_HZ)
 80292c6:	f5ab 737a 	sub.w	r3, fp, #1000	; 0x3e8
 80292ca:	f5b3 6f7a 	cmp.w	r3, #4000	; 0xfa0
 80292ce:	f200 810e 	bhi.w	80294ee <bsp_update+0x236>
		return 1;

	if (pulse_width_usec > BSP_MAX_PULSE_WIDTH_USEC || pulse_width_usec < BSP_MIN_PULSE_WIDTH_USEC)
 80292d2:	1f2b      	subs	r3, r5, #4
 80292d4:	2b06      	cmp	r3, #6
 80292d6:	f200 810a 	bhi.w	80294ee <bsp_update+0x236>
		return 1;

	// !!! Maximum value must be (1000 * PULSE_WIDTH_USEC - SAMPLE_HOLD_ON_DELAY_TIME_NSEC) */
	if (sample_hold_on_time_nsec > (1000 * pulse_width_usec - SAMPLE_HOLD_ON_DELAY_TIME_NSEC))
 80292da:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80292de:	fb03 f305 	mul.w	r3, r3, r5
 80292e2:	f5a3 73f0 	sub.w	r3, r3, #480	; 0x1e0
 80292e6:	4598      	cmp	r8, r3
 80292e8:	f200 8101 	bhi.w	80294ee <bsp_update+0x236>
 80292ec:	4604      	mov	r4, r0
	/* Sample and hold's period in microsecond */
	sample_and_hold_periodic_time_usec = 1000000 / doppler_sampling_freq_hz;

	uint32_t min_int = bsp_calc_min_frame_interval_usec(p_dev);

	if (!pwm_bgt_enabled) // if false!
 80292ee:	489e      	ldr	r0, [pc, #632]	; (8029568 <bsp_update+0x2b0>)

//============================================================================

uint32_t bsp_calc_min_frame_interval_usec(device_settings_t *p_dev)
{
	uint32_t min_frame_interval_usec = p_dev->num_of_chirps_per_frame * (((p_dev->num_samples_per_chirp + p_dev->num_sample_skip_count) * 1000U * 1000U) / p_dev->adc_sampling_freq_Hz); // units in us
 80292f0:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 80292f2:	6a62      	ldr	r2, [r4, #36]	; 0x24
	// !!! Maximum value must be (1000 * PULSE_WIDTH_USEC - SAMPLE_HOLD_ON_DELAY_TIME_NSEC) */
	if (sample_hold_on_time_nsec > (1000 * pulse_width_usec - SAMPLE_HOLD_ON_DELAY_TIME_NSEC))
		return 1;

	/* Sample and hold's period in microsecond */
	sample_and_hold_periodic_time_usec = 1000000 / doppler_sampling_freq_hz;
 80292f4:	4b9d      	ldr	r3, [pc, #628]	; (802956c <bsp_update+0x2b4>)

//============================================================================

uint32_t bsp_calc_min_frame_interval_usec(device_settings_t *p_dev)
{
	uint32_t min_frame_interval_usec = p_dev->num_of_chirps_per_frame * (((p_dev->num_samples_per_chirp + p_dev->num_sample_skip_count) * 1000U * 1000U) / p_dev->adc_sampling_freq_Hz); // units in us
 80292f6:	69e7      	ldr	r7, [r4, #28]
	/* Sample and hold's period in microsecond */
	sample_and_hold_periodic_time_usec = 1000000 / doppler_sampling_freq_hz;

	uint32_t min_int = bsp_calc_min_frame_interval_usec(p_dev);

	if (!pwm_bgt_enabled) // if false!
 80292f8:	7800      	ldrb	r0, [r0, #0]
	// !!! Maximum value must be (1000 * PULSE_WIDTH_USEC - SAMPLE_HOLD_ON_DELAY_TIME_NSEC) */
	if (sample_hold_on_time_nsec > (1000 * pulse_width_usec - SAMPLE_HOLD_ON_DELAY_TIME_NSEC))
		return 1;

	/* Sample and hold's period in microsecond */
	sample_and_hold_periodic_time_usec = 1000000 / doppler_sampling_freq_hz;
 80292fa:	fbb3 f6fb 	udiv	r6, r3, fp

//============================================================================

uint32_t bsp_calc_min_frame_interval_usec(device_settings_t *p_dev)
{
	uint32_t min_frame_interval_usec = p_dev->num_of_chirps_per_frame * (((p_dev->num_samples_per_chirp + p_dev->num_sample_skip_count) * 1000U * 1000U) / p_dev->adc_sampling_freq_Hz); // units in us
 80292fe:	440a      	add	r2, r1
 8029300:	fb03 f302 	mul.w	r3, r3, r2
 8029304:	fbb3 f3fb 	udiv	r3, r3, fp
 8029308:	fb07 f703 	mul.w	r7, r7, r3
	/* Sample and hold's period in microsecond */
	sample_and_hold_periodic_time_usec = 1000000 / doppler_sampling_freq_hz;

	uint32_t min_int = bsp_calc_min_frame_interval_usec(p_dev);

	if (!pwm_bgt_enabled) // if false!
 802930c:	2800      	cmp	r0, #0
 802930e:	f000 814f 	beq.w	80295b0 <bsp_update+0x2f8>
 8029312:	4897      	ldr	r0, [pc, #604]	; (8029570 <bsp_update+0x2b8>)
 8029314:	f8df 9268 	ldr.w	r9, [pc, #616]	; 8029580 <bsp_update+0x2c8>
 8029318:	6801      	ldr	r1, [r0, #0]
 802931a:	f8d9 3000 	ldr.w	r3, [r9]

static void switch_passive_PWM_GPIO(PWM_CCU8_t *handle_ptr)
{
	XMC_GPIO_OUTPUT_LEVEL_t output_level;

	output_level = (handle_ptr->config_ptr->ccu8_cc8_slice_timer_ptr->passive_level_out0 == (uint32_t)XMC_CCU8_SLICE_OUTPUT_PASSIVE_LEVEL_LOW)
 802931e:	6c8a      	ldr	r2, [r1, #72]	; 0x48
__STATIC_INLINE void XMC_GPIO_SetOutputLevel(XMC_GPIO_PORT_t *const port, const uint8_t pin, const XMC_GPIO_OUTPUT_LEVEL_t level)
{
  XMC_ASSERT("XMC_GPIO_SetOutputLevel: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));
  XMC_ASSERT("XMC_GPIO_SetOutputLevel: Invalid output level", XMC_GPIO_CHECK_OUTPUT_LEVEL(level));
  
  port->OMR = (uint32_t)level << pin;
 8029320:	f891 e054 	ldrb.w	lr, [r1, #84]	; 0x54
 8029324:	f892 c004 	ldrb.w	ip, [r2, #4]
 8029328:	6c9a      	ldr	r2, [r3, #72]	; 0x48
					   ? XMC_GPIO_OUTPUT_LEVEL_LOW
					   : XMC_GPIO_OUTPUT_LEVEL_HIGH;
	XMC_GPIO_SetOutputLevel(handle_ptr->config_ptr->gpio_ch1_out0_ptr, handle_ptr->config_ptr->gpio_ch1_out0_pin, output_level);
 802932a:	6d09      	ldr	r1, [r1, #80]	; 0x50

static void switch_passive_PWM_GPIO(PWM_CCU8_t *handle_ptr)
{
	XMC_GPIO_OUTPUT_LEVEL_t output_level;

	output_level = (handle_ptr->config_ptr->ccu8_cc8_slice_timer_ptr->passive_level_out0 == (uint32_t)XMC_CCU8_SLICE_OUTPUT_PASSIVE_LEVEL_LOW)
 802932c:	f892 a004 	ldrb.w	sl, [r2, #4]
					   ? XMC_GPIO_OUTPUT_LEVEL_LOW
					   : XMC_GPIO_OUTPUT_LEVEL_HIGH;
	XMC_GPIO_SetOutputLevel(handle_ptr->config_ptr->gpio_ch1_out0_ptr, handle_ptr->config_ptr->gpio_ch1_out0_pin, output_level);
 8029330:	6d1a      	ldr	r2, [r3, #80]	; 0x50

static void switch_passive_PWM_GPIO(PWM_CCU8_t *handle_ptr)
{
	XMC_GPIO_OUTPUT_LEVEL_t output_level;

	output_level = (handle_ptr->config_ptr->ccu8_cc8_slice_timer_ptr->passive_level_out0 == (uint32_t)XMC_CCU8_SLICE_OUTPUT_PASSIVE_LEVEL_LOW)
 8029332:	f01c 0f01 	tst.w	ip, #1
 8029336:	bf0c      	ite	eq
 8029338:	f44f 3c80 	moveq.w	ip, #65536	; 0x10000
 802933c:	f04f 0c01 	movne.w	ip, #1
 8029340:	fa0c fe0e 	lsl.w	lr, ip, lr
 8029344:	f8c1 e004 	str.w	lr, [r1, #4]
 8029348:	f893 1054 	ldrb.w	r1, [r3, #84]	; 0x54
 802934c:	f01a 0f01 	tst.w	sl, #1
 8029350:	bf0c      	ite	eq
 8029352:	f44f 3380 	moveq.w	r3, #65536	; 0x10000
 8029356:	2301      	movne	r3, #1
 8029358:	408b      	lsls	r3, r1
 802935a:	6053      	str	r3, [r2, #4]
	{
		/* turn on duty cycling of TX_ON and BGT_VCC, and assign "active" level */
		switch_passive_PWM_GPIO(&PWM_CCU8_BGT_TX_ON);
		switch_passive_PWM_GPIO(&PWM_CCU8_BGT_VCC);

		helper_switch_pwm_on(&PWM_CCU8_BGT_TX_ON);
 802935c:	f7ff ff76 	bl	802924c <helper_switch_pwm_on.isra.10>
		helper_switch_pwm_on(&PWM_CCU8_BGT_VCC);
 8029360:	4648      	mov	r0, r9
 8029362:	f7ff ff73 	bl	802924c <helper_switch_pwm_on.isra.10>
	}

	Radar_Data_Acq_Mode_t mode = radar_get_data_acq_mode();
 8029366:	f7f7 fc21 	bl	8020bac <radar_get_data_acq_mode>
	if (mode != RADAR_DATA_CONTINUOUS_MODE)
 802936a:	2802      	cmp	r0, #2
 802936c:	f000 80e9 	beq.w	8029542 <bsp_update+0x28a>
	{
		use_vptag_sh_duty_cycle = PTAT_S_H_SWITCHING;
		if (p_dev->frame_period_usec <= min_int + 2 * p_dev->ptat_delay_usec + BB_PRE_TRIGGER_ADVANCE_USEC - (p_dev->num_sample_skip_count * sample_and_hold_periodic_time_usec))
 8029370:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8029372:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8029374:	f8d4 e020 	ldr.w	lr, [r4, #32]
	}

	Radar_Data_Acq_Mode_t mode = radar_get_data_acq_mode();
	if (mode != RADAR_DATA_CONTINUOUS_MODE)
	{
		use_vptag_sh_duty_cycle = PTAT_S_H_SWITCHING;
 8029378:	f8df 922c 	ldr.w	r9, [pc, #556]	; 80295a8 <bsp_update+0x2f0>
		if (p_dev->frame_period_usec <= min_int + 2 * p_dev->ptat_delay_usec + BB_PRE_TRIGGER_ADVANCE_USEC - (p_dev->num_sample_skip_count * sample_and_hold_periodic_time_usec))
 802937c:	0050      	lsls	r0, r2, #1
 802937e:	f500 419c 	add.w	r1, r0, #19968	; 0x4e00
 8029382:	fb03 fc06 	mul.w	ip, r3, r6
 8029386:	3120      	adds	r1, #32
 8029388:	ebcc 0101 	rsb	r1, ip, r1
 802938c:	4439      	add	r1, r7
	}

	Radar_Data_Acq_Mode_t mode = radar_get_data_acq_mode();
	if (mode != RADAR_DATA_CONTINUOUS_MODE)
	{
		use_vptag_sh_duty_cycle = PTAT_S_H_SWITCHING;
 802938e:	2301      	movs	r3, #1
		if (p_dev->frame_period_usec <= min_int + 2 * p_dev->ptat_delay_usec + BB_PRE_TRIGGER_ADVANCE_USEC - (p_dev->num_sample_skip_count * sample_and_hold_periodic_time_usec))
 8029390:	458e      	cmp	lr, r1
	}

	Radar_Data_Acq_Mode_t mode = radar_get_data_acq_mode();
	if (mode != RADAR_DATA_CONTINUOUS_MODE)
	{
		use_vptag_sh_duty_cycle = PTAT_S_H_SWITCHING;
 8029392:	f8c9 3000 	str.w	r3, [r9]
		if (p_dev->frame_period_usec <= min_int + 2 * p_dev->ptat_delay_usec + BB_PRE_TRIGGER_ADVANCE_USEC - (p_dev->num_sample_skip_count * sample_and_hold_periodic_time_usec))
 8029396:	f240 80af 	bls.w	80294f8 <bsp_update+0x240>
 802939a:	f502 439c 	add.w	r3, r2, #19968	; 0x4e00
 802939e:	3320      	adds	r3, #32
		{
			bb_pre_trigger_advance_usec = 0;
		}
		else
		{
			bb_pre_trigger_advance_usec = BB_PRE_TRIGGER_ADVANCE_USEC - (p_dev->num_sample_skip_count * sample_and_hold_periodic_time_usec) + p_dev->ptat_delay_usec;
 80293a0:	f8df 9208 	ldr.w	r9, [pc, #520]	; 80295ac <bsp_update+0x2f4>
 80293a4:	ebcc 0303 	rsb	r3, ip, r3
 80293a8:	f8c9 3000 	str.w	r3, [r9]
	else
	{
		bb_pre_trigger_advance_usec = 0;
	}

	if (p_dev->frame_period_usec <= min_int + 2 * p_dev->ptat_delay_usec)
 80293ac:	4438      	add	r0, r7
 80293ae:	4570      	cmp	r0, lr
	{
		ptat_switching_status = 0;
 80293b0:	4b70      	ldr	r3, [pc, #448]	; (8029574 <bsp_update+0x2bc>)
	else
	{
		bb_pre_trigger_advance_usec = 0;
	}

	if (p_dev->frame_period_usec <= min_int + 2 * p_dev->ptat_delay_usec)
 80293b2:	f0c0 80ab 	bcc.w	802950c <bsp_update+0x254>
	{
		ptat_switching_status = 0;
 80293b6:	2200      	movs	r2, #0
 80293b8:	601a      	str	r2, [r3, #0]
 80293ba:	4b6f      	ldr	r3, [pc, #444]	; (8029578 <bsp_update+0x2c0>)
 80293bc:	4a6f      	ldr	r2, [pc, #444]	; (802957c <bsp_update+0x2c4>)

__STATIC_INLINE void XMC_GPIO_SetOutputHigh(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputHigh: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = (uint32_t)0x1U << pin;
 80293be:	7c1f      	ldrb	r7, [r3, #16]
 80293c0:	7c10      	ldrb	r0, [r2, #16]
 80293c2:	6819      	ldr	r1, [r3, #0]
 80293c4:	6812      	ldr	r2, [r2, #0]
 80293c6:	2301      	movs	r3, #1
 80293c8:	fa03 f000 	lsl.w	r0, r3, r0
 80293cc:	40bb      	lsls	r3, r7
 80293ce:	6050      	str	r0, [r2, #4]
 80293d0:	604b      	str	r3, [r1, #4]
		/* Enabled BBx_EN */
		enable_Baseband(true);
	}

	/* stop PWM timers for setting new parameters */
	PWM_CCU8_Stop(&PWM_CCU8_BGT_VCC);
 80293d2:	486b      	ldr	r0, [pc, #428]	; (8029580 <bsp_update+0x2c8>)
 80293d4:	f7fc ffc8 	bl	8026368 <PWM_CCU8_Stop>
	PWM_CCU8_Stop(&PWM_CCU8_BGT_TX_ON);
 80293d8:	4865      	ldr	r0, [pc, #404]	; (8029570 <bsp_update+0x2b8>)
 80293da:	f7fc ffc5 	bl	8026368 <PWM_CCU8_Stop>
	PWM_CCU8_Stop(&PWM_CCU8_SAMPLE_HOLD);
 80293de:	4869      	ldr	r0, [pc, #420]	; (8029584 <bsp_update+0x2cc>)
 80293e0:	f7fc ffc2 	bl	8026368 <PWM_CCU8_Stop>
	PWM_CCU8_Stop(&PWM_CCU8_ADC_SAMPLE);
 80293e4:	4868      	ldr	r0, [pc, #416]	; (8029588 <bsp_update+0x2d0>)
 80293e6:	f7fc ffbf 	bl	8026368 <PWM_CCU8_Stop>

TIMER_STATUS_t bsp_timer_stop_clear(TIMER_t *const handle_timer)
{
	TIMER_STATUS_t status;

	status = TIMER_Stop(handle_timer);
 80293ea:	4868      	ldr	r0, [pc, #416]	; (802958c <bsp_update+0x2d4>)
 80293ec:	f7fc fd58 	bl	8025ea0 <TIMER_Stop>

	status |= TIMER_Clear(handle_timer);
 80293f0:	4866      	ldr	r0, [pc, #408]	; (802958c <bsp_update+0x2d4>)
 80293f2:	f7fc fde1 	bl	8025fb8 <TIMER_Clear>

TIMER_STATUS_t bsp_timer_stop_clear(TIMER_t *const handle_timer)
{
	TIMER_STATUS_t status;

	status = TIMER_Stop(handle_timer);
 80293f6:	4866      	ldr	r0, [pc, #408]	; (8029590 <bsp_update+0x2d8>)
 80293f8:	f7fc fd52 	bl	8025ea0 <TIMER_Stop>

	status |= TIMER_Clear(handle_timer);
 80293fc:	4864      	ldr	r0, [pc, #400]	; (8029590 <bsp_update+0x2d8>)
 80293fe:	f7fc fddb 	bl	8025fb8 <TIMER_Clear>
    PWM_CCU8_SetFreqAndDutyCycleSymmetric(&PWM_CCU8_BGT_VCC, 2000, 50 * 100, 20 * 100);
  */

	/* Configure PWM master for BGT VCC and BGT TX On control signals */
	/* For example, for 5us On time and a period of 500us the duty_ch1_bgt_vcc will be ((5us / 500us) * 100) * 100 */
	duty_ch1_bgt_vcc = ((100 * 100 * pulse_width_usec) / sample_and_hold_periodic_time_usec);
 8029402:	f242 7310 	movw	r3, #10000	; 0x2710
 8029406:	fb03 f705 	mul.w	r7, r3, r5

	//TODO: Check the returning error!
	/* Configure PWM BGT control signals */
	PWM_CCU8_SetFreqAndDutyCycleSymmetric(&PWM_CCU8_BGT_VCC, doppler_sampling_freq_hz,
 802940a:	4659      	mov	r1, fp
    PWM_CCU8_SetFreqAndDutyCycleSymmetric(&PWM_CCU8_BGT_VCC, 2000, 50 * 100, 20 * 100);
  */

	/* Configure PWM master for BGT VCC and BGT TX On control signals */
	/* For example, for 5us On time and a period of 500us the duty_ch1_bgt_vcc will be ((5us / 500us) * 100) * 100 */
	duty_ch1_bgt_vcc = ((100 * 100 * pulse_width_usec) / sample_and_hold_periodic_time_usec);
 802940c:	fbb7 f2f6 	udiv	r2, r7, r6

	//TODO: Check the returning error!
	/* Configure PWM BGT control signals */
	PWM_CCU8_SetFreqAndDutyCycleSymmetric(&PWM_CCU8_BGT_VCC, doppler_sampling_freq_hz,
 8029410:	485b      	ldr	r0, [pc, #364]	; (8029580 <bsp_update+0x2c8>)
 8029412:	4613      	mov	r3, r2
 8029414:	f7fc ffba 	bl	802638c <PWM_CCU8_SetFreqAndDutyCycleSymmetric>
										  duty_ch1_bgt_vcc, duty_ch1_bgt_vcc);

	/* Configure PWM of BGT TX ON */
	/* Slightly shift the start of BGT TX On signal versus the BGT VCC signal */
	bgt_tx_on_freq = (1000 * 1000) / pulse_width_usec; /* In Hz */
 8029418:	4a54      	ldr	r2, [pc, #336]	; (802956c <bsp_update+0x2b4>)
	bgt_tx_on_duty = ((100 * 100 * pulse_width_usec) - 10 * BGT_TX_ON_DELAY_TIME_NSEC) / pulse_width_usec;
	bgt_tx_on_shift = (10 * BGT_TX_ON_START_DELAY_TIME_NSEC) / pulse_width_usec;
	PWM_CCU8_SetFreqAndDutyCycleAsymmetric(&PWM_CCU8_BGT_TX_ON, bgt_tx_on_freq,
 802941a:	4855      	ldr	r0, [pc, #340]	; (8029570 <bsp_update+0x2b8>)
	PWM_CCU8_SetFreqAndDutyCycleSymmetric(&PWM_CCU8_BGT_VCC, doppler_sampling_freq_hz,
										  duty_ch1_bgt_vcc, duty_ch1_bgt_vcc);

	/* Configure PWM of BGT TX ON */
	/* Slightly shift the start of BGT TX On signal versus the BGT VCC signal */
	bgt_tx_on_freq = (1000 * 1000) / pulse_width_usec; /* In Hz */
 802941c:	fbb2 faf5 	udiv	sl, r2, r5
	bgt_tx_on_duty = ((100 * 100 * pulse_width_usec) - 10 * BGT_TX_ON_DELAY_TIME_NSEC) / pulse_width_usec;
 8029420:	f5a7 637a 	sub.w	r3, r7, #4000	; 0xfa0
	bgt_tx_on_shift = (10 * BGT_TX_ON_START_DELAY_TIME_NSEC) / pulse_width_usec;
	PWM_CCU8_SetFreqAndDutyCycleAsymmetric(&PWM_CCU8_BGT_TX_ON, bgt_tx_on_freq,
 8029424:	4651      	mov	r1, sl
 8029426:	fbb3 f3f5 	udiv	r3, r3, r5

	/* Configure PWM of BGT TX ON */
	/* Slightly shift the start of BGT TX On signal versus the BGT VCC signal */
	bgt_tx_on_freq = (1000 * 1000) / pulse_width_usec; /* In Hz */
	bgt_tx_on_duty = ((100 * 100 * pulse_width_usec) - 10 * BGT_TX_ON_DELAY_TIME_NSEC) / pulse_width_usec;
	bgt_tx_on_shift = (10 * BGT_TX_ON_START_DELAY_TIME_NSEC) / pulse_width_usec;
 802942a:	f640 32b8 	movw	r2, #3000	; 0xbb8
	PWM_CCU8_SetFreqAndDutyCycleAsymmetric(&PWM_CCU8_BGT_TX_ON, bgt_tx_on_freq,
 802942e:	fbb2 f2f5 	udiv	r2, r2, r5
 8029432:	f7fc fff7 	bl	8026424 <PWM_CCU8_SetFreqAndDutyCycleAsymmetric>

	/* Configure PWM of start and holding time */
	/* Slightly shift the start of BGT TX On signal versus the BGT VCC signal */
	sample_hold_freq = (1000 * 1000) / pulse_width_usec; /* In Hz */

	hold_duty = ((100 * 100 * pulse_width_usec) - 10 * (SAMPLE_HOLD_ON_DELAY_TIME_NSEC + sample_hold_on_time_nsec)) / pulse_width_usec;
 8029436:	eb08 0888 	add.w	r8, r8, r8, lsl #2
 802943a:	f5a7 5396 	sub.w	r3, r7, #4800	; 0x12c0
	hold_shift = (10 * SAMPLE_HOLD_START_DELAY_TIME_NSEC) / pulse_width_usec;
	PWM_CCU8_SetFreqAndDutyCycleAsymmetric(&PWM_CCU8_SAMPLE_HOLD, sample_hold_freq,
 802943e:	4651      	mov	r1, sl

	/* Configure PWM of start and holding time */
	/* Slightly shift the start of BGT TX On signal versus the BGT VCC signal */
	sample_hold_freq = (1000 * 1000) / pulse_width_usec; /* In Hz */

	hold_duty = ((100 * 100 * pulse_width_usec) - 10 * (SAMPLE_HOLD_ON_DELAY_TIME_NSEC + sample_hold_on_time_nsec)) / pulse_width_usec;
 8029440:	eba3 0348 	sub.w	r3, r3, r8, lsl #1
	hold_shift = (10 * SAMPLE_HOLD_START_DELAY_TIME_NSEC) / pulse_width_usec;
 8029444:	f44f 627a 	mov.w	r2, #4000	; 0xfa0
	PWM_CCU8_SetFreqAndDutyCycleAsymmetric(&PWM_CCU8_SAMPLE_HOLD, sample_hold_freq,
 8029448:	fbb3 f3f5 	udiv	r3, r3, r5
 802944c:	fbb2 f2f5 	udiv	r2, r2, r5
 8029450:	484c      	ldr	r0, [pc, #304]	; (8029584 <bsp_update+0x2cc>)
 8029452:	f7fc ffe7 	bl	8026424 <PWM_CCU8_SetFreqAndDutyCycleAsymmetric>
										   hold_shift, hold_duty);

	/* Configure start of sampling: trigger ADC to acquire I and Q signals data */
	sample_duty = 500;
	sample_adc_freq = (1000 * 1000) / ((float)pulse_width_usec + 0.4); /* In Hz */
 8029456:	ee07 5a90 	vmov	s15, r5
 802945a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 802945e:	ee17 0a90 	vmov	r0, s15
 8029462:	f003 fa35 	bl	802c8d0 <__aeabi_f2d>
 8029466:	a33c      	add	r3, pc, #240	; (adr r3, 8029558 <bsp_update+0x2a0>)
 8029468:	e9d3 2300 	ldrd	r2, r3, [r3]
 802946c:	f003 f8d2 	bl	802c614 <__adddf3>
 8029470:	4602      	mov	r2, r0
 8029472:	460b      	mov	r3, r1
 8029474:	a13a      	add	r1, pc, #232	; (adr r1, 8029560 <bsp_update+0x2a8>)
 8029476:	e9d1 0100 	ldrd	r0, r1, [r1]
 802947a:	f003 fba7 	bl	802cbcc <__aeabi_ddiv>
 802947e:	f003 fd15 	bl	802ceac <__aeabi_d2uiz>
	PWM_CCU8_SetFreqAndDutyCycleSymmetric(&PWM_CCU8_ADC_SAMPLE, sample_adc_freq,
 8029482:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
	PWM_CCU8_SetFreqAndDutyCycleAsymmetric(&PWM_CCU8_SAMPLE_HOLD, sample_hold_freq,
										   hold_shift, hold_duty);

	/* Configure start of sampling: trigger ADC to acquire I and Q signals data */
	sample_duty = 500;
	sample_adc_freq = (1000 * 1000) / ((float)pulse_width_usec + 0.4); /* In Hz */
 8029486:	4601      	mov	r1, r0
	PWM_CCU8_SetFreqAndDutyCycleSymmetric(&PWM_CCU8_ADC_SAMPLE, sample_adc_freq,
 8029488:	4613      	mov	r3, r2
 802948a:	483f      	ldr	r0, [pc, #252]	; (8029588 <bsp_update+0x2d0>)
 802948c:	f7fc ff7e 	bl	802638c <PWM_CCU8_SetFreqAndDutyCycleSymmetric>
										  sample_duty, sample_duty);

	/* Set additional timers: */
	uint32_t delay_usec = sample_and_hold_periodic_time_usec - vptag_sh_release_delay_usec;
 8029490:	4b40      	ldr	r3, [pc, #256]	; (8029594 <bsp_update+0x2dc>)
	if (vptag_sh_release_delay_usec > sample_and_hold_periodic_time_usec)
	{
		delay_usec = PTAT_S_H_PULSE_WIDTH_USEC;
	}

	TIMER_SetTimeInterval(&TIMER_PTAT_S_H_DELAY, delay_usec * 100U);
 8029492:	483e      	ldr	r0, [pc, #248]	; (802958c <bsp_update+0x2d4>)
	sample_adc_freq = (1000 * 1000) / ((float)pulse_width_usec + 0.4); /* In Hz */
	PWM_CCU8_SetFreqAndDutyCycleSymmetric(&PWM_CCU8_ADC_SAMPLE, sample_adc_freq,
										  sample_duty, sample_duty);

	/* Set additional timers: */
	uint32_t delay_usec = sample_and_hold_periodic_time_usec - vptag_sh_release_delay_usec;
 8029494:	681b      	ldr	r3, [r3, #0]

	/* Ensure to set something reasonable! */
	if (vptag_sh_release_delay_usec > sample_and_hold_periodic_time_usec)
 8029496:	429e      	cmp	r6, r3
	sample_adc_freq = (1000 * 1000) / ((float)pulse_width_usec + 0.4); /* In Hz */
	PWM_CCU8_SetFreqAndDutyCycleSymmetric(&PWM_CCU8_ADC_SAMPLE, sample_adc_freq,
										  sample_duty, sample_duty);

	/* Set additional timers: */
	uint32_t delay_usec = sample_and_hold_periodic_time_usec - vptag_sh_release_delay_usec;
 8029498:	bf23      	ittte	cs
 802949a:	1af6      	subcs	r6, r6, r3
 802949c:	2164      	movcs	r1, #100	; 0x64
 802949e:	4371      	mulcs	r1, r6
 80294a0:	f44f 61fa 	movcc.w	r1, #2000	; 0x7d0
	if (vptag_sh_release_delay_usec > sample_and_hold_periodic_time_usec)
	{
		delay_usec = PTAT_S_H_PULSE_WIDTH_USEC;
	}

	TIMER_SetTimeInterval(&TIMER_PTAT_S_H_DELAY, delay_usec * 100U);
 80294a4:	f7fc fd10 	bl	8025ec8 <TIMER_SetTimeInterval>

	if (bb_pre_trigger_advance_usec > 0)
 80294a8:	f8d9 2000 	ldr.w	r2, [r9]
 80294ac:	2a00      	cmp	r2, #0
 80294ae:	dd3c      	ble.n	802952a <bsp_update+0x272>
	{
		if (TIMER_SetTimeInterval(&TIMER_BB_PRE_TRIGGER, bb_pre_trigger_advance_usec * 100U) != TIMER_STATUS_SUCCESS)
 80294b0:	2164      	movs	r1, #100	; 0x64
 80294b2:	fb01 f102 	mul.w	r1, r1, r2
 80294b6:	4836      	ldr	r0, [pc, #216]	; (8029590 <bsp_update+0x2d8>)
 80294b8:	f7fc fd06 	bl	8025ec8 <TIMER_SetTimeInterval>
 80294bc:	b9d0      	cbnz	r0, 80294f4 <bsp_update+0x23c>
		{
			while (1);
		}
	}

	if (ptat_switch_delay_usec > 0)
 80294be:	4b36      	ldr	r3, [pc, #216]	; (8029598 <bsp_update+0x2e0>)
 80294c0:	681b      	ldr	r3, [r3, #0]
 80294c2:	b133      	cbz	r3, 80294d2 <bsp_update+0x21a>
	{
		if (TIMER_SetTimeInterval(&TIMER_PTAT_DELAY, ptat_switch_delay_usec * 100U) != TIMER_STATUS_SUCCESS)
 80294c4:	2164      	movs	r1, #100	; 0x64
 80294c6:	fb01 f103 	mul.w	r1, r1, r3
 80294ca:	4834      	ldr	r0, [pc, #208]	; (802959c <bsp_update+0x2e4>)
 80294cc:	f7fc fcfc 	bl	8025ec8 <TIMER_SetTimeInterval>
 80294d0:	b988      	cbnz	r0, 80294f6 <bsp_update+0x23e>
			while (1);
		}
	}

	/* TX ON: Get ready to wait master's trigger signal */
	PWM_CCU8_Start(&PWM_CCU8_BGT_TX_ON);
 80294d2:	4827      	ldr	r0, [pc, #156]	; (8029570 <bsp_update+0x2b8>)
 80294d4:	f7fc ff2e 	bl	8026334 <PWM_CCU8_Start>

	/* Sample and hold: Get ready to wait master's trigger signal */
	PWM_CCU8_Start(&PWM_CCU8_SAMPLE_HOLD);
 80294d8:	482a      	ldr	r0, [pc, #168]	; (8029584 <bsp_update+0x2cc>)
 80294da:	f7fc ff2b 	bl	8026334 <PWM_CCU8_Start>

	/* ADC sampling: Get ready to wait master's trigger signal */
	PWM_CCU8_Start(&PWM_CCU8_ADC_SAMPLE);
 80294de:	482a      	ldr	r0, [pc, #168]	; (8029588 <bsp_update+0x2d0>)
 80294e0:	f7fc ff28 	bl	8026334 <PWM_CCU8_Start>

//============================================================================

void bsp_reset_frame_counter(void)
{
	bsp_frame_counter = 0;
 80294e4:	4b2e      	ldr	r3, [pc, #184]	; (80295a0 <bsp_update+0x2e8>)
 80294e6:	2000      	movs	r0, #0
 80294e8:	6018      	str	r0, [r3, #0]
	PWM_CCU8_Start(&PWM_CCU8_ADC_SAMPLE);

	/* Reset the current frame counter */
	bsp_reset_frame_counter();

	return (0);
 80294ea:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	uint32_t doppler_sampling_freq_hz = p_dev->adc_sampling_freq_Hz;
	uint32_t pulse_width_usec = p_dev->pulse_width_usec;
	uint32_t sample_hold_on_time_nsec = p_dev->sample_hold_on_time_nsec;

	if (doppler_sampling_freq_hz > BSP_MAX_DOPPLER_SAMPLING_FREQ_HZ || doppler_sampling_freq_hz < BSP_MIN_DOPPLER_SAMPLING_FREQ_HZ)
		return 1;
 80294ee:	2001      	movs	r0, #1

	/* Reset the current frame counter */
	bsp_reset_frame_counter();

	return (0);
}
 80294f0:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

	if (bb_pre_trigger_advance_usec > 0)
	{
		if (TIMER_SetTimeInterval(&TIMER_BB_PRE_TRIGGER, bb_pre_trigger_advance_usec * 100U) != TIMER_STATUS_SUCCESS)
		{
			while (1);
 80294f4:	e7fe      	b.n	80294f4 <bsp_update+0x23c>

	if (ptat_switch_delay_usec > 0)
	{
		if (TIMER_SetTimeInterval(&TIMER_PTAT_DELAY, ptat_switch_delay_usec * 100U) != TIMER_STATUS_SUCCESS)
		{
			while (1);
 80294f6:	e7fe      	b.n	80294f6 <bsp_update+0x23e>
	if (mode != RADAR_DATA_CONTINUOUS_MODE)
	{
		use_vptag_sh_duty_cycle = PTAT_S_H_SWITCHING;
		if (p_dev->frame_period_usec <= min_int + 2 * p_dev->ptat_delay_usec + BB_PRE_TRIGGER_ADVANCE_USEC - (p_dev->num_sample_skip_count * sample_and_hold_periodic_time_usec))
		{
			bb_pre_trigger_advance_usec = 0;
 80294f8:	f8df 90b0 	ldr.w	r9, [pc, #176]	; 80295ac <bsp_update+0x2f4>
	else
	{
		bb_pre_trigger_advance_usec = 0;
	}

	if (p_dev->frame_period_usec <= min_int + 2 * p_dev->ptat_delay_usec)
 80294fc:	4438      	add	r0, r7
	if (mode != RADAR_DATA_CONTINUOUS_MODE)
	{
		use_vptag_sh_duty_cycle = PTAT_S_H_SWITCHING;
		if (p_dev->frame_period_usec <= min_int + 2 * p_dev->ptat_delay_usec + BB_PRE_TRIGGER_ADVANCE_USEC - (p_dev->num_sample_skip_count * sample_and_hold_periodic_time_usec))
		{
			bb_pre_trigger_advance_usec = 0;
 80294fe:	2300      	movs	r3, #0
	else
	{
		bb_pre_trigger_advance_usec = 0;
	}

	if (p_dev->frame_period_usec <= min_int + 2 * p_dev->ptat_delay_usec)
 8029500:	4570      	cmp	r0, lr
	if (mode != RADAR_DATA_CONTINUOUS_MODE)
	{
		use_vptag_sh_duty_cycle = PTAT_S_H_SWITCHING;
		if (p_dev->frame_period_usec <= min_int + 2 * p_dev->ptat_delay_usec + BB_PRE_TRIGGER_ADVANCE_USEC - (p_dev->num_sample_skip_count * sample_and_hold_periodic_time_usec))
		{
			bb_pre_trigger_advance_usec = 0;
 8029502:	f8c9 3000 	str.w	r3, [r9]
		bb_pre_trigger_advance_usec = 0;
	}

	if (p_dev->frame_period_usec <= min_int + 2 * p_dev->ptat_delay_usec)
	{
		ptat_switching_status = 0;
 8029506:	4b1b      	ldr	r3, [pc, #108]	; (8029574 <bsp_update+0x2bc>)
	else
	{
		bb_pre_trigger_advance_usec = 0;
	}

	if (p_dev->frame_period_usec <= min_int + 2 * p_dev->ptat_delay_usec)
 8029508:	f4bf af55 	bcs.w	80293b6 <bsp_update+0xfe>
	{
		ptat_switching_status = 0;
	}

	if (ptat_switching_status != 0)
 802950c:	681b      	ldr	r3, [r3, #0]
 802950e:	2b00      	cmp	r3, #0
 8029510:	f43f af53 	beq.w	80293ba <bsp_update+0x102>
 8029514:	4b23      	ldr	r3, [pc, #140]	; (80295a4 <bsp_update+0x2ec>)
	{
		// if ptag is switched on before the acquisition
		DIGITAL_IO_SetOutputLow(&DIGITAL_IO_BGT_VCC_PTAT);
		use_vptag_sh_duty_cycle = 1;
 8029516:	4a24      	ldr	r2, [pc, #144]	; (80295a8 <bsp_update+0x2f0>)

__STATIC_INLINE void XMC_GPIO_SetOutputLow(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputLow: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = 0x10000U << pin;
 8029518:	7c18      	ldrb	r0, [r3, #16]
 802951a:	6819      	ldr	r1, [r3, #0]
 802951c:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8029520:	4083      	lsls	r3, r0
 8029522:	2001      	movs	r0, #1
 8029524:	604b      	str	r3, [r1, #4]
 8029526:	6010      	str	r0, [r2, #0]
 8029528:	e753      	b.n	80293d2 <bsp_update+0x11a>
		if (TIMER_SetTimeInterval(&TIMER_BB_PRE_TRIGGER, bb_pre_trigger_advance_usec * 100U) != TIMER_STATUS_SUCCESS)
		{
			while (1);
		}
	}
	else if (bb_pre_trigger_advance_usec < 0)
 802952a:	d0c8      	beq.n	80294be <bsp_update+0x206>
	{

		uint32_t bb_delay_usec = abs(bb_pre_trigger_advance_usec) + p_dev->ptat_delay_usec;
 802952c:	6be3      	ldr	r3, [r4, #60]	; 0x3c

		if (TIMER_SetTimeInterval(&TIMER_BB_PRE_TRIGGER, bb_delay_usec * 100U) != TIMER_STATUS_SUCCESS)
 802952e:	4818      	ldr	r0, [pc, #96]	; (8029590 <bsp_update+0x2d8>)
		}
	}
	else if (bb_pre_trigger_advance_usec < 0)
	{

		uint32_t bb_delay_usec = abs(bb_pre_trigger_advance_usec) + p_dev->ptat_delay_usec;
 8029530:	1a9b      	subs	r3, r3, r2

		if (TIMER_SetTimeInterval(&TIMER_BB_PRE_TRIGGER, bb_delay_usec * 100U) != TIMER_STATUS_SUCCESS)
 8029532:	2164      	movs	r1, #100	; 0x64
 8029534:	fb01 f103 	mul.w	r1, r1, r3
 8029538:	f7fc fcc6 	bl	8025ec8 <TIMER_SetTimeInterval>
 802953c:	2800      	cmp	r0, #0
 802953e:	d0be      	beq.n	80294be <bsp_update+0x206>
		{
			while (1);
 8029540:	e7fe      	b.n	8029540 <bsp_update+0x288>
			bb_pre_trigger_advance_usec = BB_PRE_TRIGGER_ADVANCE_USEC - (p_dev->num_sample_skip_count * sample_and_hold_periodic_time_usec) + p_dev->ptat_delay_usec;
		}
	}
	else
	{
		bb_pre_trigger_advance_usec = 0;
 8029542:	f8df 9068 	ldr.w	r9, [pc, #104]	; 80295ac <bsp_update+0x2f4>
 8029546:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 8029548:	f8d4 e020 	ldr.w	lr, [r4, #32]
 802954c:	2300      	movs	r3, #0
 802954e:	f8c9 3000 	str.w	r3, [r9]
 8029552:	0040      	lsls	r0, r0, #1
 8029554:	e72a      	b.n	80293ac <bsp_update+0xf4>
 8029556:	bf00      	nop
 8029558:	9999999a 	.word	0x9999999a
 802955c:	3fd99999 	.word	0x3fd99999
 8029560:	00000000 	.word	0x00000000
 8029564:	412e8480 	.word	0x412e8480
 8029568:	1ffe9600 	.word	0x1ffe9600
 802956c:	000f4240 	.word	0x000f4240
 8029570:	1ffe925c 	.word	0x1ffe925c
 8029574:	1ffeb4ac 	.word	0x1ffeb4ac
 8029578:	0802f858 	.word	0x0802f858
 802957c:	0802f844 	.word	0x0802f844
 8029580:	1ffe9228 	.word	0x1ffe9228
 8029584:	1ffe9290 	.word	0x1ffe9290
 8029588:	1ffe92c4 	.word	0x1ffe92c4
 802958c:	1ffe91b0 	.word	0x1ffe91b0
 8029590:	1ffe9158 	.word	0x1ffe9158
 8029594:	1ffe9604 	.word	0x1ffe9604
 8029598:	1ffeb4a8 	.word	0x1ffeb4a8
 802959c:	1ffe9120 	.word	0x1ffe9120
 80295a0:	1ffeb4a4 	.word	0x1ffeb4a4
 80295a4:	0802f86c 	.word	0x0802f86c
 80295a8:	1ffe9608 	.word	0x1ffe9608
 80295ac:	1ffe95fc 	.word	0x1ffe95fc

static void helper_switch_pwm_off(PWM_CCU8_t *handle_ptr)
{
	XMC_GPIO_MODE_t new_mode = XMC_GPIO_MODE_OUTPUT_PUSH_PULL;

	if ((bool)true == handle_ptr->config_ptr->gpio_ch1_out0_enable)
 80295b0:	f8df 911c 	ldr.w	r9, [pc, #284]	; 80296d0 <bsp_update+0x418>
 80295b4:	f8d9 3000 	ldr.w	r3, [r9]
 80295b8:	f893 204c 	ldrb.w	r2, [r3, #76]	; 0x4c
 80295bc:	2a00      	cmp	r2, #0
 80295be:	d13f      	bne.n	8029640 <bsp_update+0x388>
	{
		XMC_GPIO_SetMode(handle_ptr->config_ptr->gpio_ch1_out0_ptr, handle_ptr->config_ptr->gpio_ch1_out0_pin, new_mode);
	}

	if ((bool)true == handle_ptr->config_ptr->gpio_ch1_out1_enable)
 80295c0:	f893 205c 	ldrb.w	r2, [r3, #92]	; 0x5c
 80295c4:	2a00      	cmp	r2, #0
 80295c6:	d17a      	bne.n	80296be <bsp_update+0x406>
	{
		XMC_GPIO_SetMode(handle_ptr->config_ptr->gpio_ch1_out1_ptr, handle_ptr->config_ptr->gpio_ch1_out1_pin, new_mode);
	}

	if ((bool)true == handle_ptr->config_ptr->gpio_ch2_out2_enable)
 80295c8:	f893 206c 	ldrb.w	r2, [r3, #108]	; 0x6c
 80295cc:	2a00      	cmp	r2, #0
 80295ce:	d16d      	bne.n	80296ac <bsp_update+0x3f4>
	{
		XMC_GPIO_SetMode(handle_ptr->config_ptr->gpio_ch2_out2_ptr, handle_ptr->config_ptr->gpio_ch2_out2_pin, new_mode);
	}

	if ((bool)true == handle_ptr->config_ptr->gpio_ch2_out3_enable)
 80295d0:	f893 207c 	ldrb.w	r2, [r3, #124]	; 0x7c
 80295d4:	2a00      	cmp	r2, #0
 80295d6:	d161      	bne.n	802969c <bsp_update+0x3e4>

static void helper_switch_pwm_off(PWM_CCU8_t *handle_ptr)
{
	XMC_GPIO_MODE_t new_mode = XMC_GPIO_MODE_OUTPUT_PUSH_PULL;

	if ((bool)true == handle_ptr->config_ptr->gpio_ch1_out0_enable)
 80295d8:	f8df a0f8 	ldr.w	sl, [pc, #248]	; 80296d4 <bsp_update+0x41c>
 80295dc:	f8da 3000 	ldr.w	r3, [sl]
 80295e0:	f893 204c 	ldrb.w	r2, [r3, #76]	; 0x4c
 80295e4:	2a00      	cmp	r2, #0
 80295e6:	d150      	bne.n	802968a <bsp_update+0x3d2>
	{
		XMC_GPIO_SetMode(handle_ptr->config_ptr->gpio_ch1_out0_ptr, handle_ptr->config_ptr->gpio_ch1_out0_pin, new_mode);
	}

	if ((bool)true == handle_ptr->config_ptr->gpio_ch1_out1_enable)
 80295e8:	f893 205c 	ldrb.w	r2, [r3, #92]	; 0x5c
 80295ec:	2a00      	cmp	r2, #0
 80295ee:	d143      	bne.n	8029678 <bsp_update+0x3c0>
	{
		XMC_GPIO_SetMode(handle_ptr->config_ptr->gpio_ch1_out1_ptr, handle_ptr->config_ptr->gpio_ch1_out1_pin, new_mode);
	}

	if ((bool)true == handle_ptr->config_ptr->gpio_ch2_out2_enable)
 80295f0:	f893 206c 	ldrb.w	r2, [r3, #108]	; 0x6c
 80295f4:	2a00      	cmp	r2, #0
 80295f6:	d136      	bne.n	8029666 <bsp_update+0x3ae>
	{
		XMC_GPIO_SetMode(handle_ptr->config_ptr->gpio_ch2_out2_ptr, handle_ptr->config_ptr->gpio_ch2_out2_pin, new_mode);
	}

	if ((bool)true == handle_ptr->config_ptr->gpio_ch2_out3_enable)
 80295f8:	f893 207c 	ldrb.w	r2, [r3, #124]	; 0x7c
 80295fc:	bb4a      	cbnz	r2, 8029652 <bsp_update+0x39a>

static void switch_active_PWM_GPIO(PWM_CCU8_t *handle_ptr)
{
	XMC_GPIO_OUTPUT_LEVEL_t output_level;

	output_level = (handle_ptr->config_ptr->ccu8_cc8_slice_timer_ptr->passive_level_out0 == (uint32_t)XMC_CCU8_SLICE_OUTPUT_PASSIVE_LEVEL_LOW)
 80295fe:	6c99      	ldr	r1, [r3, #72]	; 0x48
 8029600:	f8d9 2000 	ldr.w	r2, [r9]
 8029604:	f891 9004 	ldrb.w	r9, [r1, #4]
__STATIC_INLINE void XMC_GPIO_SetOutputLevel(XMC_GPIO_PORT_t *const port, const uint8_t pin, const XMC_GPIO_OUTPUT_LEVEL_t level)
{
  XMC_ASSERT("XMC_GPIO_SetOutputLevel: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));
  XMC_ASSERT("XMC_GPIO_SetOutputLevel: Invalid output level", XMC_GPIO_CHECK_OUTPUT_LEVEL(level));
  
  port->OMR = (uint32_t)level << pin;
 8029608:	f893 c054 	ldrb.w	ip, [r3, #84]	; 0x54
 802960c:	6c91      	ldr	r1, [r2, #72]	; 0x48
					   ? XMC_GPIO_OUTPUT_LEVEL_HIGH
					   : XMC_GPIO_OUTPUT_LEVEL_LOW;

	XMC_GPIO_SetOutputLevel(handle_ptr->config_ptr->gpio_ch1_out0_ptr, handle_ptr->config_ptr->gpio_ch1_out0_pin, output_level);
 802960e:	f8d3 e050 	ldr.w	lr, [r3, #80]	; 0x50

static void switch_active_PWM_GPIO(PWM_CCU8_t *handle_ptr)
{
	XMC_GPIO_OUTPUT_LEVEL_t output_level;

	output_level = (handle_ptr->config_ptr->ccu8_cc8_slice_timer_ptr->passive_level_out0 == (uint32_t)XMC_CCU8_SLICE_OUTPUT_PASSIVE_LEVEL_LOW)
 8029612:	7908      	ldrb	r0, [r1, #4]
					   ? XMC_GPIO_OUTPUT_LEVEL_HIGH
					   : XMC_GPIO_OUTPUT_LEVEL_LOW;

	XMC_GPIO_SetOutputLevel(handle_ptr->config_ptr->gpio_ch1_out0_ptr, handle_ptr->config_ptr->gpio_ch1_out0_pin, output_level);
 8029614:	6d11      	ldr	r1, [r2, #80]	; 0x50

static void switch_active_PWM_GPIO(PWM_CCU8_t *handle_ptr)
{
	XMC_GPIO_OUTPUT_LEVEL_t output_level;

	output_level = (handle_ptr->config_ptr->ccu8_cc8_slice_timer_ptr->passive_level_out0 == (uint32_t)XMC_CCU8_SLICE_OUTPUT_PASSIVE_LEVEL_LOW)
 8029616:	f019 0f01 	tst.w	r9, #1
 802961a:	bf0c      	ite	eq
 802961c:	2301      	moveq	r3, #1
 802961e:	f44f 3380 	movne.w	r3, #65536	; 0x10000
 8029622:	fa03 f30c 	lsl.w	r3, r3, ip
 8029626:	f8ce 3004 	str.w	r3, [lr, #4]
 802962a:	f892 2054 	ldrb.w	r2, [r2, #84]	; 0x54
 802962e:	f010 0f01 	tst.w	r0, #1
 8029632:	bf0c      	ite	eq
 8029634:	2301      	moveq	r3, #1
 8029636:	f44f 3380 	movne.w	r3, #65536	; 0x10000
 802963a:	4093      	lsls	r3, r2
 802963c:	604b      	str	r3, [r1, #4]
 802963e:	e692      	b.n	8029366 <bsp_update+0xae>
{
	XMC_GPIO_MODE_t new_mode = XMC_GPIO_MODE_OUTPUT_PUSH_PULL;

	if ((bool)true == handle_ptr->config_ptr->gpio_ch1_out0_enable)
	{
		XMC_GPIO_SetMode(handle_ptr->config_ptr->gpio_ch1_out0_ptr, handle_ptr->config_ptr->gpio_ch1_out0_pin, new_mode);
 8029640:	6d18      	ldr	r0, [r3, #80]	; 0x50
 8029642:	f893 1054 	ldrb.w	r1, [r3, #84]	; 0x54
 8029646:	2280      	movs	r2, #128	; 0x80
 8029648:	f7f8 fbce 	bl	8021de8 <XMC_GPIO_SetMode>
 802964c:	f8d9 3000 	ldr.w	r3, [r9]
 8029650:	e7b6      	b.n	80295c0 <bsp_update+0x308>
		XMC_GPIO_SetMode(handle_ptr->config_ptr->gpio_ch2_out2_ptr, handle_ptr->config_ptr->gpio_ch2_out2_pin, new_mode);
	}

	if ((bool)true == handle_ptr->config_ptr->gpio_ch2_out3_enable)
	{
		XMC_GPIO_SetMode(handle_ptr->config_ptr->gpio_ch2_out3_ptr, handle_ptr->config_ptr->gpio_ch2_out3_pin, new_mode);
 8029652:	f8d3 0080 	ldr.w	r0, [r3, #128]	; 0x80
 8029656:	f893 1084 	ldrb.w	r1, [r3, #132]	; 0x84
 802965a:	2280      	movs	r2, #128	; 0x80
 802965c:	f7f8 fbc4 	bl	8021de8 <XMC_GPIO_SetMode>
 8029660:	f8da 3000 	ldr.w	r3, [sl]
 8029664:	e7cb      	b.n	80295fe <bsp_update+0x346>
		XMC_GPIO_SetMode(handle_ptr->config_ptr->gpio_ch1_out1_ptr, handle_ptr->config_ptr->gpio_ch1_out1_pin, new_mode);
	}

	if ((bool)true == handle_ptr->config_ptr->gpio_ch2_out2_enable)
	{
		XMC_GPIO_SetMode(handle_ptr->config_ptr->gpio_ch2_out2_ptr, handle_ptr->config_ptr->gpio_ch2_out2_pin, new_mode);
 8029666:	6f18      	ldr	r0, [r3, #112]	; 0x70
 8029668:	f893 1074 	ldrb.w	r1, [r3, #116]	; 0x74
 802966c:	2280      	movs	r2, #128	; 0x80
 802966e:	f7f8 fbbb 	bl	8021de8 <XMC_GPIO_SetMode>
 8029672:	f8da 3000 	ldr.w	r3, [sl]
 8029676:	e7bf      	b.n	80295f8 <bsp_update+0x340>
		XMC_GPIO_SetMode(handle_ptr->config_ptr->gpio_ch1_out0_ptr, handle_ptr->config_ptr->gpio_ch1_out0_pin, new_mode);
	}

	if ((bool)true == handle_ptr->config_ptr->gpio_ch1_out1_enable)
	{
		XMC_GPIO_SetMode(handle_ptr->config_ptr->gpio_ch1_out1_ptr, handle_ptr->config_ptr->gpio_ch1_out1_pin, new_mode);
 8029678:	6e18      	ldr	r0, [r3, #96]	; 0x60
 802967a:	f893 1064 	ldrb.w	r1, [r3, #100]	; 0x64
 802967e:	2280      	movs	r2, #128	; 0x80
 8029680:	f7f8 fbb2 	bl	8021de8 <XMC_GPIO_SetMode>
 8029684:	f8da 3000 	ldr.w	r3, [sl]
 8029688:	e7b2      	b.n	80295f0 <bsp_update+0x338>
{
	XMC_GPIO_MODE_t new_mode = XMC_GPIO_MODE_OUTPUT_PUSH_PULL;

	if ((bool)true == handle_ptr->config_ptr->gpio_ch1_out0_enable)
	{
		XMC_GPIO_SetMode(handle_ptr->config_ptr->gpio_ch1_out0_ptr, handle_ptr->config_ptr->gpio_ch1_out0_pin, new_mode);
 802968a:	6d18      	ldr	r0, [r3, #80]	; 0x50
 802968c:	f893 1054 	ldrb.w	r1, [r3, #84]	; 0x54
 8029690:	2280      	movs	r2, #128	; 0x80
 8029692:	f7f8 fba9 	bl	8021de8 <XMC_GPIO_SetMode>
 8029696:	f8da 3000 	ldr.w	r3, [sl]
 802969a:	e7a5      	b.n	80295e8 <bsp_update+0x330>
		XMC_GPIO_SetMode(handle_ptr->config_ptr->gpio_ch2_out2_ptr, handle_ptr->config_ptr->gpio_ch2_out2_pin, new_mode);
	}

	if ((bool)true == handle_ptr->config_ptr->gpio_ch2_out3_enable)
	{
		XMC_GPIO_SetMode(handle_ptr->config_ptr->gpio_ch2_out3_ptr, handle_ptr->config_ptr->gpio_ch2_out3_pin, new_mode);
 802969c:	f8d3 0080 	ldr.w	r0, [r3, #128]	; 0x80
 80296a0:	f893 1084 	ldrb.w	r1, [r3, #132]	; 0x84
 80296a4:	2280      	movs	r2, #128	; 0x80
 80296a6:	f7f8 fb9f 	bl	8021de8 <XMC_GPIO_SetMode>
 80296aa:	e795      	b.n	80295d8 <bsp_update+0x320>
		XMC_GPIO_SetMode(handle_ptr->config_ptr->gpio_ch1_out1_ptr, handle_ptr->config_ptr->gpio_ch1_out1_pin, new_mode);
	}

	if ((bool)true == handle_ptr->config_ptr->gpio_ch2_out2_enable)
	{
		XMC_GPIO_SetMode(handle_ptr->config_ptr->gpio_ch2_out2_ptr, handle_ptr->config_ptr->gpio_ch2_out2_pin, new_mode);
 80296ac:	6f18      	ldr	r0, [r3, #112]	; 0x70
 80296ae:	f893 1074 	ldrb.w	r1, [r3, #116]	; 0x74
 80296b2:	2280      	movs	r2, #128	; 0x80
 80296b4:	f7f8 fb98 	bl	8021de8 <XMC_GPIO_SetMode>
 80296b8:	f8d9 3000 	ldr.w	r3, [r9]
 80296bc:	e788      	b.n	80295d0 <bsp_update+0x318>
		XMC_GPIO_SetMode(handle_ptr->config_ptr->gpio_ch1_out0_ptr, handle_ptr->config_ptr->gpio_ch1_out0_pin, new_mode);
	}

	if ((bool)true == handle_ptr->config_ptr->gpio_ch1_out1_enable)
	{
		XMC_GPIO_SetMode(handle_ptr->config_ptr->gpio_ch1_out1_ptr, handle_ptr->config_ptr->gpio_ch1_out1_pin, new_mode);
 80296be:	6e18      	ldr	r0, [r3, #96]	; 0x60
 80296c0:	f893 1064 	ldrb.w	r1, [r3, #100]	; 0x64
 80296c4:	2280      	movs	r2, #128	; 0x80
 80296c6:	f7f8 fb8f 	bl	8021de8 <XMC_GPIO_SetMode>
 80296ca:	f8d9 3000 	ldr.w	r3, [r9]
 80296ce:	e77b      	b.n	80295c8 <bsp_update+0x310>
 80296d0:	1ffe925c 	.word	0x1ffe925c
 80296d4:	1ffe9228 	.word	0x1ffe9228

080296d8 <bsp_init>:
    6. EXPORTED FUNCTIONS
==============================================================================
 */

uint8_t bsp_init(device_settings_t *p_dev)
{
 80296d8:	b538      	push	{r3, r4, r5, lr}
 80296da:	4a11      	ldr	r2, [pc, #68]	; (8029720 <bsp_init+0x48>)
	/* Set all data acquisition functions callback to NULL */
	bsp_cb.bsp_acq_started_cb = NULL;
 80296dc:	4b11      	ldr	r3, [pc, #68]	; (8029724 <bsp_init+0x4c>)
 */
__STATIC_INLINE void DMA_CH_Disable(DMA_CH_t *const obj)
{
  XMC_ASSERT("DMA_CH_Disable: NULL DMA_CH_t object", (obj != NULL));

  XMC_DMA_CH_Disable(obj->dma_global->dma, obj->ch_num);
 80296de:	6815      	ldr	r5, [r2, #0]
 80296e0:	7b11      	ldrb	r1, [r2, #12]
    6. EXPORTED FUNCTIONS
==============================================================================
 */

uint8_t bsp_init(device_settings_t *p_dev)
{
 80296e2:	4604      	mov	r4, r0
	/* Set all data acquisition functions callback to NULL */
	bsp_cb.bsp_acq_started_cb = NULL;
 80296e4:	2200      	movs	r2, #0
 80296e6:	6828      	ldr	r0, [r5, #0]
 80296e8:	601a      	str	r2, [r3, #0]
	bsp_cb.bsp_acq_done_cb = NULL;
 80296ea:	605a      	str	r2, [r3, #4]
 80296ec:	f7f8 f926 	bl	802193c <XMC_DMA_CH_Disable>
 80296f0:	4b0d      	ldr	r3, [pc, #52]	; (8029728 <bsp_init+0x50>)
 80296f2:	681a      	ldr	r2, [r3, #0]
 80296f4:	7b19      	ldrb	r1, [r3, #12]
 80296f6:	6810      	ldr	r0, [r2, #0]
 80296f8:	f7f8 f920 	bl	802193c <XMC_DMA_CH_Disable>
 80296fc:	4b0b      	ldr	r3, [pc, #44]	; (802972c <bsp_init+0x54>)
 80296fe:	681a      	ldr	r2, [r3, #0]
 8029700:	7b19      	ldrb	r1, [r3, #12]
 8029702:	6810      	ldr	r0, [r2, #0]
 8029704:	f7f8 f91a 	bl	802193c <XMC_DMA_CH_Disable>
 8029708:	4b09      	ldr	r3, [pc, #36]	; (8029730 <bsp_init+0x58>)
 802970a:	681a      	ldr	r2, [r3, #0]
 802970c:	7b19      	ldrb	r1, [r3, #12]
 802970e:	6810      	ldr	r0, [r2, #0]
 8029710:	f7f8 f914 	bl	802193c <XMC_DMA_CH_Disable>

	/* Disable DMA */
	dma_disable();

	return bsp_update(p_dev);
 8029714:	4620      	mov	r0, r4
}
 8029716:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	bsp_cb.bsp_acq_done_cb = NULL;

	/* Disable DMA */
	dma_disable();

	return bsp_update(p_dev);
 802971a:	f7ff bdcd 	b.w	80292b8 <bsp_update>
 802971e:	bf00      	nop
 8029720:	1ffe93c0 	.word	0x1ffe93c0
 8029724:	1ffedc0c 	.word	0x1ffedc0c
 8029728:	1ffe93d0 	.word	0x1ffe93d0
 802972c:	1ffe93e0 	.word	0x1ffe93e0
 8029730:	1ffe93f0 	.word	0x1ffe93f0

08029734 <CCU80_3_IRQHandler>:

//============================================================================

void INTERRUPT_BGT_VCC_ON_handler(void)
{
	if (l_acq_started)
 8029734:	4b12      	ldr	r3, [pc, #72]	; (8029780 <CCU80_3_IRQHandler+0x4c>)
 8029736:	681b      	ldr	r3, [r3, #0]
 8029738:	b183      	cbz	r3, 802975c <CCU80_3_IRQHandler+0x28>
	{
		if (use_vptag_sh_duty_cycle)
 802973a:	4b12      	ldr	r3, [pc, #72]	; (8029784 <CCU80_3_IRQHandler+0x50>)
 802973c:	681b      	ldr	r3, [r3, #0]
}

//============================================================================

void INTERRUPT_BGT_VCC_ON_handler(void)
{
 802973e:	b430      	push	{r4, r5}
	if (l_acq_started)
	{
		if (use_vptag_sh_duty_cycle)
 8029740:	b96b      	cbnz	r3, 802975e <CCU80_3_IRQHandler+0x2a>
 8029742:	4a11      	ldr	r2, [pc, #68]	; (8029788 <CCU80_3_IRQHandler+0x54>)
 8029744:	4b11      	ldr	r3, [pc, #68]	; (802978c <CCU80_3_IRQHandler+0x58>)

__STATIC_INLINE void XMC_GPIO_SetOutputHigh(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputHigh: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = (uint32_t)0x1U << pin;
 8029746:	7c10      	ldrb	r0, [r2, #16]
 8029748:	7c1c      	ldrb	r4, [r3, #16]
 802974a:	6811      	ldr	r1, [r2, #0]
 802974c:	681a      	ldr	r2, [r3, #0]
 802974e:	2301      	movs	r3, #1
 8029750:	fa03 f000 	lsl.w	r0, r3, r0
 8029754:	40a3      	lsls	r3, r4
			DIGITAL_IO_SetOutputHigh(&DIGITAL_IO_BGT_VCC_PTAT);
			/* ensure V_PTAT_SH_EN is enabled */
			DIGITAL_IO_SetOutputHigh(&DIGITAL_IO_V_PTAT_SH_EN);
		}
	}
}
 8029756:	bc30      	pop	{r4, r5}
 8029758:	6048      	str	r0, [r1, #4]
 802975a:	6053      	str	r3, [r2, #4]
 802975c:	4770      	bx	lr
 802975e:	4a0b      	ldr	r2, [pc, #44]	; (802978c <CCU80_3_IRQHandler+0x58>)
 8029760:	4b09      	ldr	r3, [pc, #36]	; (8029788 <CCU80_3_IRQHandler+0x54>)

__STATIC_INLINE void XMC_GPIO_SetOutputLow(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputLow: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = 0x10000U << pin;
 8029762:	7c14      	ldrb	r4, [r2, #16]
 8029764:	7c1d      	ldrb	r5, [r3, #16]
 8029766:	6811      	ldr	r1, [r2, #0]
 8029768:	681a      	ldr	r2, [r3, #0]

TIMER_STATUS_t bsp_timer_start(TIMER_t *const handle_timer)
{
	TIMER_STATUS_t status;

	status = TIMER_Start(handle_timer);
 802976a:	4809      	ldr	r0, [pc, #36]	; (8029790 <CCU80_3_IRQHandler+0x5c>)
 802976c:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8029770:	fa03 f404 	lsl.w	r4, r3, r4
 8029774:	40ab      	lsls	r3, r5
 8029776:	604c      	str	r4, [r1, #4]
 8029778:	6053      	str	r3, [r2, #4]
			DIGITAL_IO_SetOutputHigh(&DIGITAL_IO_BGT_VCC_PTAT);
			/* ensure V_PTAT_SH_EN is enabled */
			DIGITAL_IO_SetOutputHigh(&DIGITAL_IO_V_PTAT_SH_EN);
		}
	}
}
 802977a:	bc30      	pop	{r4, r5}

TIMER_STATUS_t bsp_timer_start(TIMER_t *const handle_timer)
{
	TIMER_STATUS_t status;

	status = TIMER_Start(handle_timer);
 802977c:	f7fc bb80 	b.w	8025e80 <TIMER_Start>
 8029780:	1ffeb4a0 	.word	0x1ffeb4a0
 8029784:	1ffe9608 	.word	0x1ffe9608
 8029788:	0802f86c 	.word	0x0802f86c
 802978c:	0802f8f8 	.word	0x0802f8f8
 8029790:	1ffe91b0 	.word	0x1ffe91b0

08029794 <CCU43_0_IRQHandler>:

//============================================================================

void INTERRUPT_PTAT_S_H_DELAY_handler(void)
{
	if (l_acq_started)
 8029794:	4b0b      	ldr	r3, [pc, #44]	; (80297c4 <CCU43_0_IRQHandler+0x30>)
 8029796:	681b      	ldr	r3, [r3, #0]
}

//============================================================================

void INTERRUPT_PTAT_S_H_DELAY_handler(void)
{
 8029798:	b510      	push	{r4, lr}
	if (l_acq_started)
 802979a:	b15b      	cbz	r3, 80297b4 <CCU43_0_IRQHandler+0x20>
 802979c:	4a0a      	ldr	r2, [pc, #40]	; (80297c8 <CCU43_0_IRQHandler+0x34>)
 802979e:	4b0b      	ldr	r3, [pc, #44]	; (80297cc <CCU43_0_IRQHandler+0x38>)

__STATIC_INLINE void XMC_GPIO_SetOutputHigh(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputHigh: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = (uint32_t)0x1U << pin;
 80297a0:	7c10      	ldrb	r0, [r2, #16]
 80297a2:	7c1c      	ldrb	r4, [r3, #16]
 80297a4:	6811      	ldr	r1, [r2, #0]
 80297a6:	681a      	ldr	r2, [r3, #0]
 80297a8:	2301      	movs	r3, #1
 80297aa:	fa03 f000 	lsl.w	r0, r3, r0
 80297ae:	40a3      	lsls	r3, r4
 80297b0:	6048      	str	r0, [r1, #4]
 80297b2:	6053      	str	r3, [r2, #4]

TIMER_STATUS_t bsp_timer_stop_clear(TIMER_t *const handle_timer)
{
	TIMER_STATUS_t status;

	status = TIMER_Stop(handle_timer);
 80297b4:	4806      	ldr	r0, [pc, #24]	; (80297d0 <CCU43_0_IRQHandler+0x3c>)
 80297b6:	f7fc fb73 	bl	8025ea0 <TIMER_Stop>

	status |= TIMER_Clear(handle_timer);
 80297ba:	4805      	ldr	r0, [pc, #20]	; (80297d0 <CCU43_0_IRQHandler+0x3c>)

		/* ensure V_PTAT_SH_EN is set to sample */
		DIGITAL_IO_SetOutputHigh(&DIGITAL_IO_V_PTAT_SH_EN);
	}
	bsp_timer_stop_clear(&TIMER_PTAT_S_H_DELAY);
}
 80297bc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
{
	TIMER_STATUS_t status;

	status = TIMER_Stop(handle_timer);

	status |= TIMER_Clear(handle_timer);
 80297c0:	f7fc bbfa 	b.w	8025fb8 <TIMER_Clear>
 80297c4:	1ffeb4a0 	.word	0x1ffeb4a0
 80297c8:	0802f86c 	.word	0x0802f86c
 80297cc:	0802f8f8 	.word	0x0802f8f8
 80297d0:	1ffe91b0 	.word	0x1ffe91b0

080297d4 <CCU43_2_IRQHandler>:
}

//============================================================================

void INTERRUPT_BB_PRE_TRIGGER_handler(void)
{
 80297d4:	b510      	push	{r4, lr}

TIMER_STATUS_t bsp_timer_stop_clear(TIMER_t *const handle_timer)
{
	TIMER_STATUS_t status;

	status = TIMER_Stop(handle_timer);
 80297d6:	4810      	ldr	r0, [pc, #64]	; (8029818 <CCU43_2_IRQHandler+0x44>)
 80297d8:	f7fc fb62 	bl	8025ea0 <TIMER_Stop>

	status |= TIMER_Clear(handle_timer);
 80297dc:	480e      	ldr	r0, [pc, #56]	; (8029818 <CCU43_2_IRQHandler+0x44>)
 80297de:	f7fc fbeb 	bl	8025fb8 <TIMER_Clear>

void INTERRUPT_BB_PRE_TRIGGER_handler(void)
{
	bsp_timer_stop_clear(&TIMER_BB_PRE_TRIGGER);

	if (ptat_switch_delay_usec > 0 && (bb_pre_trigger_advance_usec > (int32_t)ptat_switch_delay_usec))
 80297e2:	4b0e      	ldr	r3, [pc, #56]	; (802981c <CCU43_2_IRQHandler+0x48>)
 80297e4:	681b      	ldr	r3, [r3, #0]
 80297e6:	b11b      	cbz	r3, 80297f0 <CCU43_2_IRQHandler+0x1c>
 80297e8:	4a0d      	ldr	r2, [pc, #52]	; (8029820 <CCU43_2_IRQHandler+0x4c>)
 80297ea:	6812      	ldr	r2, [r2, #0]
 80297ec:	4293      	cmp	r3, r2
 80297ee:	db0c      	blt.n	802980a <CCU43_2_IRQHandler+0x36>
 80297f0:	4a0c      	ldr	r2, [pc, #48]	; (8029824 <CCU43_2_IRQHandler+0x50>)
 80297f2:	4b0d      	ldr	r3, [pc, #52]	; (8029828 <CCU43_2_IRQHandler+0x54>)
 80297f4:	7c10      	ldrb	r0, [r2, #16]
 80297f6:	7c1c      	ldrb	r4, [r3, #16]
 80297f8:	6811      	ldr	r1, [r2, #0]
 80297fa:	681a      	ldr	r2, [r3, #0]
 80297fc:	2301      	movs	r3, #1
 80297fe:	fa03 f000 	lsl.w	r0, r3, r0
 8029802:	40a3      	lsls	r3, r4
 8029804:	6048      	str	r0, [r1, #4]
 8029806:	6053      	str	r3, [r2, #4]
 8029808:	bd10      	pop	{r4, pc}

TIMER_STATUS_t bsp_timer_start(TIMER_t *const handle_timer)
{
	TIMER_STATUS_t status;

	status = TIMER_Start(handle_timer);
 802980a:	4808      	ldr	r0, [pc, #32]	; (802982c <CCU43_2_IRQHandler+0x58>)
 802980c:	f7fc fb38 	bl	8025e80 <TIMER_Start>
 8029810:	4a07      	ldr	r2, [pc, #28]	; (8029830 <CCU43_2_IRQHandler+0x5c>)
 8029812:	4b08      	ldr	r3, [pc, #32]	; (8029834 <CCU43_2_IRQHandler+0x60>)
 8029814:	e7ee      	b.n	80297f4 <CCU43_2_IRQHandler+0x20>
 8029816:	bf00      	nop
 8029818:	1ffe9158 	.word	0x1ffe9158
 802981c:	1ffeb4a8 	.word	0x1ffeb4a8
 8029820:	1ffe95fc 	.word	0x1ffe95fc
 8029824:	0802f844 	.word	0x0802f844
 8029828:	0802f858 	.word	0x0802f858
 802982c:	1ffe9120 	.word	0x1ffe9120
 8029830:	0802f86c 	.word	0x0802f86c
 8029834:	0802f8f8 	.word	0x0802f8f8

08029838 <bsp_bgt_shut_down>:
//============================================================================

static void bgt24ltr1x_shut_down(void)
{
	/* Stop BGT */
	PWM_CCU8_Stop(&PWM_CCU8_BGT_VCC);
 8029838:	4801      	ldr	r0, [pc, #4]	; (8029840 <bsp_bgt_shut_down+0x8>)
 802983a:	f7fc bd95 	b.w	8026368 <PWM_CCU8_Stop>
 802983e:	bf00      	nop
 8029840:	1ffe9228 	.word	0x1ffe9228

08029844 <bsp_timer_stop_clear>:
}

//============================================================================

TIMER_STATUS_t bsp_timer_stop_clear(TIMER_t *const handle_timer)
{
 8029844:	b538      	push	{r3, r4, r5, lr}
 8029846:	4605      	mov	r5, r0
	TIMER_STATUS_t status;

	status = TIMER_Stop(handle_timer);
 8029848:	f7fc fb2a 	bl	8025ea0 <TIMER_Stop>
 802984c:	4604      	mov	r4, r0

	status |= TIMER_Clear(handle_timer);
 802984e:	4628      	mov	r0, r5
 8029850:	f7fc fbb2 	bl	8025fb8 <TIMER_Clear>
 8029854:	4320      	orrs	r0, r4

	return (status);
}
 8029856:	b2c0      	uxtb	r0, r0
 8029858:	bd38      	pop	{r3, r4, r5, pc}
 802985a:	bf00      	nop

0802985c <bsp_timer_start>:

TIMER_STATUS_t bsp_timer_start(TIMER_t *const handle_timer)
{
	TIMER_STATUS_t status;

	status = TIMER_Start(handle_timer);
 802985c:	f7fc bb10 	b.w	8025e80 <TIMER_Start>

08029860 <bsp_dma_set_adc_control_from_acq_buf_obj>:
}

//============================================================================

void bsp_dma_set_adc_control_from_acq_buf_obj(acq_buf_obj *acq_buf)
{
 8029860:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	pDMA_src_G1 = (uint32_t *)&ADC_MEASUREMENT_ADV_G1_CH_G1_RES;
	pDMA_src_G2 = (uint32_t *)&ADC_MEASUREMENT_ADV_G2_CH_G2_RES;
	pDMA_src_G3 = (uint32_t *)&ADC_MEASUREMENT_ADV_G3_CH_G3_RES;

	/* Set the source address pointers for each DMA transfer */
	XMC_DMA_CH_SetSourceAddress(DMA_CH_G0.dma_global->dma, DMA_CH_G0.ch_num, (uint32_t)pDMA_src_G0);
 8029864:	4b36      	ldr	r3, [pc, #216]	; (8029940 <bsp_dma_set_adc_control_from_acq_buf_obj+0xe0>)
//============================================================================

static void dma_set_source_addr(void)
{
	/* DMA Source/Destination Address setup */
	pDMA_src_G0 = (uint32_t *)&ADC_MEASUREMENT_ADV_G0_CH_G0_RES;
 8029866:	4c37      	ldr	r4, [pc, #220]	; (8029944 <bsp_dma_set_adc_control_from_acq_buf_obj+0xe4>)
	pDMA_src_G1 = (uint32_t *)&ADC_MEASUREMENT_ADV_G1_CH_G1_RES;
	pDMA_src_G2 = (uint32_t *)&ADC_MEASUREMENT_ADV_G2_CH_G2_RES;
	pDMA_src_G3 = (uint32_t *)&ADC_MEASUREMENT_ADV_G3_CH_G3_RES;

	/* Set the source address pointers for each DMA transfer */
	XMC_DMA_CH_SetSourceAddress(DMA_CH_G0.dma_global->dma, DMA_CH_G0.ch_num, (uint32_t)pDMA_src_G0);
 8029868:	6819      	ldr	r1, [r3, #0]
 * \par<b>Related API: </b><br>
 * ::XMC_DMA_CH_SetDestinationAddress() <br>
 */
__STATIC_INLINE void XMC_DMA_CH_SetSourceAddress(XMC_DMA_t *const dma, const uint8_t channel, uint32_t addr)
{
  dma->CH[channel].SAR = addr;
 802986a:	7b1a      	ldrb	r2, [r3, #12]
 802986c:	f8d1 8000 	ldr.w	r8, [r1]
//============================================================================

static void dma_set_source_addr(void)
{
	/* DMA Source/Destination Address setup */
	pDMA_src_G0 = (uint32_t *)&ADC_MEASUREMENT_ADV_G0_CH_G0_RES;
 8029870:	4935      	ldr	r1, [pc, #212]	; (8029948 <bsp_dma_set_adc_control_from_acq_buf_obj+0xe8>)
 8029872:	6021      	str	r1, [r4, #0]
 8029874:	2458      	movs	r4, #88	; 0x58
 8029876:	fb04 f202 	mul.w	r2, r4, r2
	pDMA_src_G1 = (uint32_t *)&ADC_MEASUREMENT_ADV_G1_CH_G1_RES;
 802987a:	4f34      	ldr	r7, [pc, #208]	; (802994c <bsp_dma_set_adc_control_from_acq_buf_obj+0xec>)
	pDMA_src_G2 = (uint32_t *)&ADC_MEASUREMENT_ADV_G2_CH_G2_RES;
 802987c:	4e34      	ldr	r6, [pc, #208]	; (8029950 <bsp_dma_set_adc_control_from_acq_buf_obj+0xf0>)
	pDMA_src_G3 = (uint32_t *)&ADC_MEASUREMENT_ADV_G3_CH_G3_RES;
 802987e:	4b35      	ldr	r3, [pc, #212]	; (8029954 <bsp_dma_set_adc_control_from_acq_buf_obj+0xf4>)

static void dma_set_source_addr(void)
{
	/* DMA Source/Destination Address setup */
	pDMA_src_G0 = (uint32_t *)&ADC_MEASUREMENT_ADV_G0_CH_G0_RES;
	pDMA_src_G1 = (uint32_t *)&ADC_MEASUREMENT_ADV_G1_CH_G1_RES;
 8029880:	f8df a0e0 	ldr.w	sl, [pc, #224]	; 8029964 <bsp_dma_set_adc_control_from_acq_buf_obj+0x104>
	pDMA_src_G2 = (uint32_t *)&ADC_MEASUREMENT_ADV_G2_CH_G2_RES;
 8029884:	f8df c0e0 	ldr.w	ip, [pc, #224]	; 8029968 <bsp_dma_set_adc_control_from_acq_buf_obj+0x108>
	pDMA_src_G3 = (uint32_t *)&ADC_MEASUREMENT_ADV_G3_CH_G3_RES;
 8029888:	4d33      	ldr	r5, [pc, #204]	; (8029958 <bsp_dma_set_adc_control_from_acq_buf_obj+0xf8>)

static void dma_set_source_addr(void)
{
	/* DMA Source/Destination Address setup */
	pDMA_src_G0 = (uint32_t *)&ADC_MEASUREMENT_ADV_G0_CH_G0_RES;
	pDMA_src_G1 = (uint32_t *)&ADC_MEASUREMENT_ADV_G1_CH_G1_RES;
 802988a:	f8c7 a000 	str.w	sl, [r7]
	pDMA_src_G2 = (uint32_t *)&ADC_MEASUREMENT_ADV_G2_CH_G2_RES;
 802988e:	f8c6 c000 	str.w	ip, [r6]
	pDMA_src_G3 = (uint32_t *)&ADC_MEASUREMENT_ADV_G3_CH_G3_RES;
 8029892:	601d      	str	r5, [r3, #0]
 8029894:	f848 1002 	str.w	r1, [r8, r2]

	/* Set the source address pointers for each DMA transfer */
	XMC_DMA_CH_SetSourceAddress(DMA_CH_G0.dma_global->dma, DMA_CH_G0.ch_num, (uint32_t)pDMA_src_G0);
	XMC_DMA_CH_SetSourceAddress(DMA_CH_G1.dma_global->dma, DMA_CH_G1.ch_num, (uint32_t)pDMA_src_G1);
 8029898:	4b30      	ldr	r3, [pc, #192]	; (802995c <bsp_dma_set_adc_control_from_acq_buf_obj+0xfc>)
	XMC_DMA_CH_SetSourceAddress(DMA_CH_G2.dma_global->dma, DMA_CH_G2.ch_num, (uint32_t)pDMA_src_G2);
	XMC_DMA_CH_SetSourceAddress(DMA_CH_G3.dma_global->dma, DMA_CH_G3.ch_num, (uint32_t)pDMA_src_G3);
 802989a:	f8df e0d0 	ldr.w	lr, [pc, #208]	; 802996c <bsp_dma_set_adc_control_from_acq_buf_obj+0x10c>
	pDMA_src_G2 = (uint32_t *)&ADC_MEASUREMENT_ADV_G2_CH_G2_RES;
	pDMA_src_G3 = (uint32_t *)&ADC_MEASUREMENT_ADV_G3_CH_G3_RES;

	/* Set the source address pointers for each DMA transfer */
	XMC_DMA_CH_SetSourceAddress(DMA_CH_G0.dma_global->dma, DMA_CH_G0.ch_num, (uint32_t)pDMA_src_G0);
	XMC_DMA_CH_SetSourceAddress(DMA_CH_G1.dma_global->dma, DMA_CH_G1.ch_num, (uint32_t)pDMA_src_G1);
 802989e:	6819      	ldr	r1, [r3, #0]
	XMC_DMA_CH_SetSourceAddress(DMA_CH_G2.dma_global->dma, DMA_CH_G2.ch_num, (uint32_t)pDMA_src_G2);
 80298a0:	f8df 90cc 	ldr.w	r9, [pc, #204]	; 8029970 <bsp_dma_set_adc_control_from_acq_buf_obj+0x110>
 80298a4:	7b1b      	ldrb	r3, [r3, #12]
	pDMA_src_G2 = (uint32_t *)&ADC_MEASUREMENT_ADV_G2_CH_G2_RES;
	pDMA_src_G3 = (uint32_t *)&ADC_MEASUREMENT_ADV_G3_CH_G3_RES;

	/* Set the source address pointers for each DMA transfer */
	XMC_DMA_CH_SetSourceAddress(DMA_CH_G0.dma_global->dma, DMA_CH_G0.ch_num, (uint32_t)pDMA_src_G0);
	XMC_DMA_CH_SetSourceAddress(DMA_CH_G1.dma_global->dma, DMA_CH_G1.ch_num, (uint32_t)pDMA_src_G1);
 80298a6:	680e      	ldr	r6, [r1, #0]
	XMC_DMA_CH_SetSourceAddress(DMA_CH_G2.dma_global->dma, DMA_CH_G2.ch_num, (uint32_t)pDMA_src_G2);
 80298a8:	f8d9 7000 	ldr.w	r7, [r9]
	XMC_DMA_CH_SetSourceAddress(DMA_CH_G3.dma_global->dma, DMA_CH_G3.ch_num, (uint32_t)pDMA_src_G3);
 80298ac:	f8de 1000 	ldr.w	r1, [lr]
	pDMA_src_G3 = (uint32_t *)&ADC_MEASUREMENT_ADV_G3_CH_G3_RES;

	/* Set the source address pointers for each DMA transfer */
	XMC_DMA_CH_SetSourceAddress(DMA_CH_G0.dma_global->dma, DMA_CH_G0.ch_num, (uint32_t)pDMA_src_G0);
	XMC_DMA_CH_SetSourceAddress(DMA_CH_G1.dma_global->dma, DMA_CH_G1.ch_num, (uint32_t)pDMA_src_G1);
	XMC_DMA_CH_SetSourceAddress(DMA_CH_G2.dma_global->dma, DMA_CH_G2.ch_num, (uint32_t)pDMA_src_G2);
 80298b0:	683f      	ldr	r7, [r7, #0]
	XMC_DMA_CH_SetSourceAddress(DMA_CH_G3.dma_global->dma, DMA_CH_G3.ch_num, (uint32_t)pDMA_src_G3);
 80298b2:	f8d1 b000 	ldr.w	fp, [r1]
void bsp_dma_set_adc_control_from_acq_buf_obj(acq_buf_obj *acq_buf)
{
	dma_set_source_addr();

	/* We use a 2nd buffer here, to be able to run the signal processing in parallel to the data acquisition */
	pDMA_dst_G0 = (uint32_t *)&data_buffer[0][0];
 80298b6:	492a      	ldr	r1, [pc, #168]	; (8029960 <bsp_dma_set_adc_control_from_acq_buf_obj+0x100>)
 80298b8:	fb04 f303 	mul.w	r3, r4, r3
 80298bc:	4442      	add	r2, r8
 80298be:	f846 a003 	str.w	sl, [r6, r3]
 80298c2:	f899 900c 	ldrb.w	r9, [r9, #12]
	XMC_DMA_CH_SetDestinationAddress(DMA_CH_G0.dma_global->dma, DMA_CH_G0.ch_num, (uint32_t)pDMA_dst_G0);
	XMC_DMA_CH_SetDestinationAddress(DMA_CH_G1.dma_global->dma, DMA_CH_G1.ch_num, (uint32_t)pDMA_dst_G1);
	XMC_DMA_CH_SetDestinationAddress(DMA_CH_G2.dma_global->dma, DMA_CH_G2.ch_num, (uint32_t)pDMA_dst_G2);
	XMC_DMA_CH_SetDestinationAddress(DMA_CH_G3.dma_global->dma, DMA_CH_G3.ch_num, (uint32_t)pDMA_dst_G3);

	uint32_t block_size = acq_buf->internals.skip_count + acq_buf->params.num_of_samples_per_chirp;
 80298c6:	f8b0 a002 	ldrh.w	sl, [r0, #2]
 80298ca:	69c0      	ldr	r0, [r0, #28]
 80298cc:	fb04 f909 	mul.w	r9, r4, r9
 80298d0:	4433      	add	r3, r6
 80298d2:	f847 c009 	str.w	ip, [r7, r9]
 80298d6:	f89e 800c 	ldrb.w	r8, [lr, #12]

	/* We use a 2nd buffer here, to be able to run the signal processing in parallel to the data acquisition */
	pDMA_dst_G0 = (uint32_t *)&data_buffer[0][0];
	pDMA_dst_G1 = (uint32_t *)&data_buffer[1][0];
	pDMA_dst_G2 = (uint32_t *)&data_buffer[2][0];
	pDMA_dst_G3 = (uint32_t *)&data_buffer[3][0];
 80298da:	f8df c098 	ldr.w	ip, [pc, #152]	; 8029974 <bsp_dma_set_adc_control_from_acq_buf_obj+0x114>
{
	dma_set_source_addr();

	/* We use a 2nd buffer here, to be able to run the signal processing in parallel to the data acquisition */
	pDMA_dst_G0 = (uint32_t *)&data_buffer[0][0];
	pDMA_dst_G1 = (uint32_t *)&data_buffer[1][0];
 80298de:	f8df e098 	ldr.w	lr, [pc, #152]	; 8029978 <bsp_dma_set_adc_control_from_acq_buf_obj+0x118>
 80298e2:	fb04 f408 	mul.w	r4, r4, r8
 80298e6:	44b9      	add	r9, r7
 80298e8:	f84b 5004 	str.w	r5, [fp, r4]
 * see ::XMC_DMA_CH_Enable() for more information.
 *
 */
__STATIC_INLINE void XMC_DMA_CH_SetBlockSize(XMC_DMA_t *const dma, const uint8_t channel, uint32_t block_size)
{
  dma->CH[channel].CTLH = block_size;
 80298ec:	f102 0718 	add.w	r7, r2, #24
 * \par<b>Related API: </b><br>
 * ::XMC_DMA_CH_SetSourceAddress() <br>
 */
__STATIC_INLINE void XMC_DMA_CH_SetDestinationAddress(XMC_DMA_t *const dma, const uint8_t channel, uint32_t addr)
{
  dma->CH[channel].DAR = addr;
 80298f0:	6091      	str	r1, [r2, #8]
 80298f2:	f501 621d 	add.w	r2, r1, #2512	; 0x9d0
 80298f6:	609a      	str	r2, [r3, #8]
 * see ::XMC_DMA_CH_Enable() for more information.
 *
 */
__STATIC_INLINE void XMC_DMA_CH_SetBlockSize(XMC_DMA_t *const dma, const uint8_t channel, uint32_t block_size)
{
  dma->CH[channel].CTLH = block_size;
 80298f8:	f103 0618 	add.w	r6, r3, #24
	pDMA_dst_G2 = (uint32_t *)&data_buffer[2][0];
 80298fc:	f501 539d 	add.w	r3, r1, #5024	; 0x13a0
 * \par<b>Related API: </b><br>
 * ::XMC_DMA_CH_SetSourceAddress() <br>
 */
__STATIC_INLINE void XMC_DMA_CH_SetDestinationAddress(XMC_DMA_t *const dma, const uint8_t channel, uint32_t addr)
{
  dma->CH[channel].DAR = addr;
 8029900:	f8c9 3008 	str.w	r3, [r9, #8]
	XMC_DMA_CH_SetDestinationAddress(DMA_CH_G0.dma_global->dma, DMA_CH_G0.ch_num, (uint32_t)pDMA_dst_G0);
	XMC_DMA_CH_SetDestinationAddress(DMA_CH_G1.dma_global->dma, DMA_CH_G1.ch_num, (uint32_t)pDMA_dst_G1);
	XMC_DMA_CH_SetDestinationAddress(DMA_CH_G2.dma_global->dma, DMA_CH_G2.ch_num, (uint32_t)pDMA_dst_G2);
	XMC_DMA_CH_SetDestinationAddress(DMA_CH_G3.dma_global->dma, DMA_CH_G3.ch_num, (uint32_t)pDMA_dst_G3);

	uint32_t block_size = acq_buf->internals.skip_count + acq_buf->params.num_of_samples_per_chirp;
 8029904:	4450      	add	r0, sl
 * \par<b>Related API: </b><br>
 * ::XMC_DMA_CH_SetDestinationAddress() <br>
 */
__STATIC_INLINE void XMC_DMA_CH_SetSourceAddress(XMC_DMA_t *const dma, const uint8_t channel, uint32_t addr)
{
  dma->CH[channel].SAR = addr;
 8029906:	eb0b 0804 	add.w	r8, fp, r4
 * see ::XMC_DMA_CH_Enable() for more information.
 *
 */
__STATIC_INLINE void XMC_DMA_CH_SetBlockSize(XMC_DMA_t *const dma, const uint8_t channel, uint32_t block_size)
{
  dma->CH[channel].CTLH = block_size;
 802990a:	f109 0a18 	add.w	sl, r9, #24

	/* We use a 2nd buffer here, to be able to run the signal processing in parallel to the data acquisition */
	pDMA_dst_G0 = (uint32_t *)&data_buffer[0][0];
	pDMA_dst_G1 = (uint32_t *)&data_buffer[1][0];
	pDMA_dst_G2 = (uint32_t *)&data_buffer[2][0];
	pDMA_dst_G3 = (uint32_t *)&data_buffer[3][0];
 802990e:	f501 54eb 	add.w	r4, r1, #7520	; 0x1d60
	dma_set_source_addr();

	/* We use a 2nd buffer here, to be able to run the signal processing in parallel to the data acquisition */
	pDMA_dst_G0 = (uint32_t *)&data_buffer[0][0];
	pDMA_dst_G1 = (uint32_t *)&data_buffer[1][0];
	pDMA_dst_G2 = (uint32_t *)&data_buffer[2][0];
 8029912:	f8df b068 	ldr.w	fp, [pc, #104]	; 802997c <bsp_dma_set_adc_control_from_acq_buf_obj+0x11c>
void bsp_dma_set_adc_control_from_acq_buf_obj(acq_buf_obj *acq_buf)
{
	dma_set_source_addr();

	/* We use a 2nd buffer here, to be able to run the signal processing in parallel to the data acquisition */
	pDMA_dst_G0 = (uint32_t *)&data_buffer[0][0];
 8029916:	f8df 9068 	ldr.w	r9, [pc, #104]	; 8029980 <bsp_dma_set_adc_control_from_acq_buf_obj+0x120>
	pDMA_dst_G1 = (uint32_t *)&data_buffer[1][0];
 802991a:	f8ce 2000 	str.w	r2, [lr]
	pDMA_dst_G2 = (uint32_t *)&data_buffer[2][0];
	pDMA_dst_G3 = (uint32_t *)&data_buffer[3][0];
 802991e:	3410      	adds	r4, #16
 * \par<b>Related API: </b><br>
 * ::XMC_DMA_CH_SetSourceAddress() <br>
 */
__STATIC_INLINE void XMC_DMA_CH_SetDestinationAddress(XMC_DMA_t *const dma, const uint8_t channel, uint32_t addr)
{
  dma->CH[channel].DAR = addr;
 8029920:	f8c8 4008 	str.w	r4, [r8, #8]
 8029924:	f8cc 4000 	str.w	r4, [ip]
 * see ::XMC_DMA_CH_Enable() for more information.
 *
 */
__STATIC_INLINE void XMC_DMA_CH_SetBlockSize(XMC_DMA_t *const dma, const uint8_t channel, uint32_t block_size)
{
  dma->CH[channel].CTLH = block_size;
 8029928:	6078      	str	r0, [r7, #4]
	dma_set_source_addr();

	/* We use a 2nd buffer here, to be able to run the signal processing in parallel to the data acquisition */
	pDMA_dst_G0 = (uint32_t *)&data_buffer[0][0];
	pDMA_dst_G1 = (uint32_t *)&data_buffer[1][0];
	pDMA_dst_G2 = (uint32_t *)&data_buffer[2][0];
 802992a:	f8cb 3000 	str.w	r3, [fp]
 802992e:	6070      	str	r0, [r6, #4]
 8029930:	f8ca 0004 	str.w	r0, [sl, #4]
void bsp_dma_set_adc_control_from_acq_buf_obj(acq_buf_obj *acq_buf)
{
	dma_set_source_addr();

	/* We use a 2nd buffer here, to be able to run the signal processing in parallel to the data acquisition */
	pDMA_dst_G0 = (uint32_t *)&data_buffer[0][0];
 8029934:	f8c9 1000 	str.w	r1, [r9]
 8029938:	f8c8 001c 	str.w	r0, [r8, #28]
 802993c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8029940:	1ffe93c0 	.word	0x1ffe93c0
 8029944:	1ffedbf4 	.word	0x1ffedbf4
 8029948:	4000473c 	.word	0x4000473c
 802994c:	1ffedbf8 	.word	0x1ffedbf8
 8029950:	1ffedbfc 	.word	0x1ffedbfc
 8029954:	1ffedc00 	.word	0x1ffedc00
 8029958:	40005310 	.word	0x40005310
 802995c:	1ffe93d0 	.word	0x1ffe93d0
 8029960:	1ffeb4b0 	.word	0x1ffeb4b0
 8029964:	40004b0c 	.word	0x40004b0c
 8029968:	40004f00 	.word	0x40004f00
 802996c:	1ffe93f0 	.word	0x1ffe93f0
 8029970:	1ffe93e0 	.word	0x1ffe93e0
 8029974:	1ffeb498 	.word	0x1ffeb498
 8029978:	1ffedc08 	.word	0x1ffedc08
 802997c:	1ffedbf0 	.word	0x1ffedbf0
 8029980:	1ffedc04 	.word	0x1ffedc04

08029984 <bsp_trigger_new_frame>:
}

//============================================================================

void bsp_trigger_new_frame(void)
{
 8029984:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8029988:	4f2c      	ldr	r7, [pc, #176]	; (8029a3c <bsp_trigger_new_frame+0xb8>)
 802998a:	4e2d      	ldr	r6, [pc, #180]	; (8029a40 <bsp_trigger_new_frame+0xbc>)
 802998c:	683a      	ldr	r2, [r7, #0]
==============================================================================
 */

static void trigger_dma_start(void)
{
	watchdog_status = 0;
 802998e:	4b2d      	ldr	r3, [pc, #180]	; (8029a44 <bsp_trigger_new_frame+0xc0>)
 8029990:	6810      	ldr	r0, [r2, #0]
 8029992:	7b39      	ldrb	r1, [r7, #12]
 8029994:	4d2c      	ldr	r5, [pc, #176]	; (8029a48 <bsp_trigger_new_frame+0xc4>)
 8029996:	4c2d      	ldr	r4, [pc, #180]	; (8029a4c <bsp_trigger_new_frame+0xc8>)
}

//============================================================================

void bsp_trigger_new_frame(void)
{
 8029998:	b081      	sub	sp, #4
==============================================================================
 */

static void trigger_dma_start(void)
{
	watchdog_status = 0;
 802999a:	f04f 0800 	mov.w	r8, #0
 802999e:	f883 8000 	strb.w	r8, [r3]
 80299a2:	f7f7 ffcb 	bl	802193c <XMC_DMA_CH_Disable>
 80299a6:	6833      	ldr	r3, [r6, #0]
 80299a8:	7b31      	ldrb	r1, [r6, #12]
 80299aa:	6818      	ldr	r0, [r3, #0]
 80299ac:	f7f7 ffc6 	bl	802193c <XMC_DMA_CH_Disable>
 80299b0:	682b      	ldr	r3, [r5, #0]
 80299b2:	7b29      	ldrb	r1, [r5, #12]
 80299b4:	6818      	ldr	r0, [r3, #0]
 80299b6:	f7f7 ffc1 	bl	802193c <XMC_DMA_CH_Disable>
 80299ba:	6823      	ldr	r3, [r4, #0]
 80299bc:	7b21      	ldrb	r1, [r4, #12]
 80299be:	6818      	ldr	r0, [r3, #0]
 80299c0:	f7f7 ffbc 	bl	802193c <XMC_DMA_CH_Disable>

	/* DMA Reconfiguration */
	dma_disable();

	acq_buf_obj *p_acq_buf = ds_get_active_acq_buf();
 80299c4:	f7f6 fd94 	bl	80204f0 <ds_get_active_acq_buf>

	bsp_dma_set_adc_control_from_acq_buf_obj(p_acq_buf);
 80299c8:	f7ff ff4a 	bl	8029860 <bsp_dma_set_adc_control_from_acq_buf_obj>
//============================================================================

static void bgt24ltr1x_start_up(void)
{
	/* Start BGT */
	PWM_CCU8_Start(&PWM_CCU8_BGT_VCC);
 80299cc:	4820      	ldr	r0, [pc, #128]	; (8029a50 <bsp_trigger_new_frame+0xcc>)
 80299ce:	f7fc fcb1 	bl	8026334 <PWM_CCU8_Start>
 */
__STATIC_INLINE void DMA_CH_Enable(DMA_CH_t *const obj)
{
  XMC_ASSERT("DMA_CH_Enable: NULL DMA_CH_t object", (obj != NULL));

  XMC_DMA_CH_Enable(obj->dma_global->dma, obj->ch_num);
 80299d2:	6830      	ldr	r0, [r6, #0]
 80299d4:	6829      	ldr	r1, [r5, #0]
 80299d6:	6822      	ldr	r2, [r4, #0]
{
	/* Get the raw ADC data */
	trigger_dma_start();

	/* This callback is used to inform upper layers about the beginning of data acquisition process */
	if (bsp_cb.bsp_acq_started_cb != NULL)
 80299d8:	4b1e      	ldr	r3, [pc, #120]	; (8029a54 <bsp_trigger_new_frame+0xd0>)
 80299da:	f8d7 b000 	ldr.w	fp, [r7]
 * ensure that the GPDMA module itself is enabled before calling this function.
 * See ::XMC_DMA_Enable() for details.
 */
__STATIC_INLINE void XMC_DMA_CH_Enable(XMC_DMA_t *const dma, const uint8_t channel)
{
  dma->CHENREG = (uint32_t)(0x101UL << channel);   
 80299de:	f894 c00c 	ldrb.w	ip, [r4, #12]
 80299e2:	f897 e00c 	ldrb.w	lr, [r7, #12]
 80299e6:	f896 900c 	ldrb.w	r9, [r6, #12]
 80299ea:	f895 a00c 	ldrb.w	sl, [r5, #12]
 80299ee:	f8db 7000 	ldr.w	r7, [fp]
 80299f2:	6805      	ldr	r5, [r0, #0]
	bsp_bgt_start_up();

	/* Enable DMA */
	dma_enable();

	l_acq_started = 1;
 80299f4:	4e18      	ldr	r6, [pc, #96]	; (8029a58 <bsp_trigger_new_frame+0xd4>)
 80299f6:	6808      	ldr	r0, [r1, #0]
 80299f8:	6811      	ldr	r1, [r2, #0]
{
	/* Get the raw ADC data */
	trigger_dma_start();

	/* This callback is used to inform upper layers about the beginning of data acquisition process */
	if (bsp_cb.bsp_acq_started_cb != NULL)
 80299fa:	681a      	ldr	r2, [r3, #0]
 80299fc:	f240 1301 	movw	r3, #257	; 0x101
 8029a00:	fa03 fe0e 	lsl.w	lr, r3, lr
 8029a04:	fa03 f909 	lsl.w	r9, r3, r9
 8029a08:	fa03 f40a 	lsl.w	r4, r3, sl
 8029a0c:	fa03 f30c 	lsl.w	r3, r3, ip
	bsp_bgt_start_up();

	/* Enable DMA */
	dma_enable();

	l_acq_started = 1;
 8029a10:	f04f 0c01 	mov.w	ip, #1
 8029a14:	f8c7 e3a0 	str.w	lr, [r7, #928]	; 0x3a0
 8029a18:	f8c6 c000 	str.w	ip, [r6]
 8029a1c:	f8c5 93a0 	str.w	r9, [r5, #928]	; 0x3a0
 8029a20:	f8c0 43a0 	str.w	r4, [r0, #928]	; 0x3a0
 8029a24:	f8c1 33a0 	str.w	r3, [r1, #928]	; 0x3a0
{
	/* Get the raw ADC data */
	trigger_dma_start();

	/* This callback is used to inform upper layers about the beginning of data acquisition process */
	if (bsp_cb.bsp_acq_started_cb != NULL)
 8029a28:	b122      	cbz	r2, 8029a34 <bsp_trigger_new_frame+0xb0>
	{
		bsp_cb.bsp_acq_started_cb(NULL);
 8029a2a:	4640      	mov	r0, r8
	}
}
 8029a2c:	b001      	add	sp, #4
 8029a2e:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	trigger_dma_start();

	/* This callback is used to inform upper layers about the beginning of data acquisition process */
	if (bsp_cb.bsp_acq_started_cb != NULL)
	{
		bsp_cb.bsp_acq_started_cb(NULL);
 8029a32:	4710      	bx	r2
	}
}
 8029a34:	b001      	add	sp, #4
 8029a36:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8029a3a:	bf00      	nop
 8029a3c:	1ffe93c0 	.word	0x1ffe93c0
 8029a40:	1ffe93d0 	.word	0x1ffe93d0
 8029a44:	1ffeb49c 	.word	0x1ffeb49c
 8029a48:	1ffe93e0 	.word	0x1ffe93e0
 8029a4c:	1ffe93f0 	.word	0x1ffe93f0
 8029a50:	1ffe9228 	.word	0x1ffe9228
 8029a54:	1ffedc0c 	.word	0x1ffedc0c
 8029a58:	1ffeb4a0 	.word	0x1ffeb4a0

08029a5c <DMA_Event_Handler>:

//============================================================================

void DMA_Event_Handler(XMC_DMA_CH_EVENT_t dma_event)
{
	if ((dma_event & XMC_DMA_CH_EVENT_BLOCK_TRANSFER_COMPLETE) != 0)
 8029a5c:	0783      	lsls	r3, r0, #30
 8029a5e:	d400      	bmi.n	8029a62 <DMA_Event_Handler+0x6>
 8029a60:	4770      	bx	lr
}

//============================================================================

void DMA_Event_Handler(XMC_DMA_CH_EVENT_t dma_event)
{
 8029a62:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8029a66:	b087      	sub	sp, #28
	if ((dma_event & XMC_DMA_CH_EVENT_BLOCK_TRANSFER_COMPLETE) != 0)
	{
		/* In case of continuous mode */
		if (radar_get_data_acq_mode() == RADAR_DATA_CONTINUOUS_MODE)
 8029a68:	f7f7 f8a0 	bl	8020bac <radar_get_data_acq_mode>
 8029a6c:	2802      	cmp	r0, #2
 8029a6e:	4681      	mov	r9, r0
 8029a70:	f000 80bb 	beq.w	8029bea <DMA_Event_Handler+0x18e>
			bsp_frame_counter++;
		}
		else /* In normal mode */
		{

			l_acq_started = 0;
 8029a74:	4baf      	ldr	r3, [pc, #700]	; (8029d34 <DMA_Event_Handler+0x2d8>)

TIMER_STATUS_t bsp_timer_stop_clear(TIMER_t *const handle_timer)
{
	TIMER_STATUS_t status;

	status = TIMER_Stop(handle_timer);
 8029a76:	48b0      	ldr	r0, [pc, #704]	; (8029d38 <DMA_Event_Handler+0x2dc>)
			bsp_frame_counter++;
		}
		else /* In normal mode */
		{

			l_acq_started = 0;
 8029a78:	2200      	movs	r2, #0
 8029a7a:	601a      	str	r2, [r3, #0]

TIMER_STATUS_t bsp_timer_stop_clear(TIMER_t *const handle_timer)
{
	TIMER_STATUS_t status;

	status = TIMER_Stop(handle_timer);
 8029a7c:	f7fc fa10 	bl	8025ea0 <TIMER_Stop>

	status |= TIMER_Clear(handle_timer);
 8029a80:	48ad      	ldr	r0, [pc, #692]	; (8029d38 <DMA_Event_Handler+0x2dc>)
 8029a82:	f7fc fa99 	bl	8025fb8 <TIMER_Clear>

			l_acq_started = 0;

			bsp_timer_stop_clear(&TIMER_PTAT_S_H_DELAY);

			if (ptat_switching_status != 0)
 8029a86:	4bad      	ldr	r3, [pc, #692]	; (8029d3c <DMA_Event_Handler+0x2e0>)
 8029a88:	681b      	ldr	r3, [r3, #0]
 8029a8a:	b163      	cbz	r3, 8029aa6 <DMA_Event_Handler+0x4a>
 8029a8c:	4aac      	ldr	r2, [pc, #688]	; (8029d40 <DMA_Event_Handler+0x2e4>)
 8029a8e:	4bad      	ldr	r3, [pc, #692]	; (8029d44 <DMA_Event_Handler+0x2e8>)

__STATIC_INLINE void XMC_GPIO_SetOutputLow(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputLow: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = 0x10000U << pin;
 8029a90:	7c10      	ldrb	r0, [r2, #16]
 8029a92:	7c1c      	ldrb	r4, [r3, #16]
 8029a94:	6811      	ldr	r1, [r2, #0]
 8029a96:	681a      	ldr	r2, [r3, #0]
 8029a98:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8029a9c:	fa03 f000 	lsl.w	r0, r3, r0
 8029aa0:	40a3      	lsls	r3, r4
 8029aa2:	6048      	str	r0, [r1, #4]
 8029aa4:	6053      	str	r3, [r2, #4]

				/* Disable ptat straight after acquisition */
				DIGITAL_IO_SetOutputLow(&DIGITAL_IO_BGT_VCC_PTAT);
			}

			if (bb_pre_trigger_advance_usec != 0)
 8029aa6:	4ba8      	ldr	r3, [pc, #672]	; (8029d48 <DMA_Event_Handler+0x2ec>)
 8029aa8:	681b      	ldr	r3, [r3, #0]
 8029aaa:	2b00      	cmp	r3, #0
 8029aac:	f040 808f 	bne.w	8029bce <DMA_Event_Handler+0x172>
 8029ab0:	f8df 92c4 	ldr.w	r9, [pc, #708]	; 8029d78 <DMA_Event_Handler+0x31c>
//============================================================================

static void bgt24ltr1x_shut_down(void)
{
	/* Stop BGT */
	PWM_CCU8_Stop(&PWM_CCU8_BGT_VCC);
 8029ab4:	48a5      	ldr	r0, [pc, #660]	; (8029d4c <DMA_Event_Handler+0x2f0>)
 8029ab6:	4ea6      	ldr	r6, [pc, #664]	; (8029d50 <DMA_Event_Handler+0x2f4>)
 8029ab8:	4da6      	ldr	r5, [pc, #664]	; (8029d54 <DMA_Event_Handler+0x2f8>)
 8029aba:	4ca7      	ldr	r4, [pc, #668]	; (8029d58 <DMA_Event_Handler+0x2fc>)
			dma_reset_dlr();

			acq_buf_obj *p_acq_buf = ds_get_active_acq_buf();

			/* copy data buffer into target buffer, if skip count is active*/
			copyDataBuffer2AcqBuffer(p_acq_buf, bsp_frame_counter);
 8029abc:	f8df 82b4 	ldr.w	r8, [pc, #692]	; 8029d74 <DMA_Event_Handler+0x318>
	  uint16_t *p_dst_Ch3 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 3, 0);

	  uint32_t skip_count = p_acq_buf->internals.skip_count;
	  uint32_t byte_count = p_acq_buf->params.num_of_samples_per_chirp*sizeof(uint16_t);

	  memcpy(p_dst_Ch0, &data_buffer[0][skip_count], byte_count);
 8029ac0:	4fa6      	ldr	r7, [pc, #664]	; (8029d5c <DMA_Event_Handler+0x300>)
//============================================================================

static void bgt24ltr1x_shut_down(void)
{
	/* Stop BGT */
	PWM_CCU8_Stop(&PWM_CCU8_BGT_VCC);
 8029ac2:	f7fc fc51 	bl	8026368 <PWM_CCU8_Stop>
 */
__STATIC_INLINE void DMA_CH_Disable(DMA_CH_t *const obj)
{
  XMC_ASSERT("DMA_CH_Disable: NULL DMA_CH_t object", (obj != NULL));

  XMC_DMA_CH_Disable(obj->dma_global->dma, obj->ch_num);
 8029ac6:	f8d9 3000 	ldr.w	r3, [r9]
 8029aca:	f899 100c 	ldrb.w	r1, [r9, #12]
 8029ace:	6818      	ldr	r0, [r3, #0]
 8029ad0:	f7f7 ff34 	bl	802193c <XMC_DMA_CH_Disable>
 8029ad4:	6833      	ldr	r3, [r6, #0]
 8029ad6:	7b31      	ldrb	r1, [r6, #12]
 8029ad8:	6818      	ldr	r0, [r3, #0]
 8029ada:	f7f7 ff2f 	bl	802193c <XMC_DMA_CH_Disable>
 8029ade:	682b      	ldr	r3, [r5, #0]
 8029ae0:	7b29      	ldrb	r1, [r5, #12]
 8029ae2:	6818      	ldr	r0, [r3, #0]
 8029ae4:	f7f7 ff2a 	bl	802193c <XMC_DMA_CH_Disable>
 8029ae8:	6823      	ldr	r3, [r4, #0]
 8029aea:	7b21      	ldrb	r1, [r4, #12]
 8029aec:	6818      	ldr	r0, [r3, #0]
 8029aee:	f7f7 ff25 	bl	802193c <XMC_DMA_CH_Disable>

//============================================================================

static void dma_reset_dlr(void)
{
	XMC_DMA_CH_ClearSourcePeripheralRequest(DMA_CH_G0.dma_global->dma, DMA_CH_G0.ch_num);
 8029af2:	f8d9 3000 	ldr.w	r3, [r9]
 8029af6:	f899 100c 	ldrb.w	r1, [r9, #12]
 8029afa:	6818      	ldr	r0, [r3, #0]
 8029afc:	f7f8 f89c 	bl	8021c38 <XMC_DMA_CH_ClearSourcePeripheralRequest>
	XMC_DMA_CH_ClearSourcePeripheralRequest(DMA_CH_G1.dma_global->dma, DMA_CH_G1.ch_num);
 8029b00:	6833      	ldr	r3, [r6, #0]
 8029b02:	7b31      	ldrb	r1, [r6, #12]
 8029b04:	6818      	ldr	r0, [r3, #0]
 8029b06:	f7f8 f897 	bl	8021c38 <XMC_DMA_CH_ClearSourcePeripheralRequest>
	XMC_DMA_CH_ClearSourcePeripheralRequest(DMA_CH_G2.dma_global->dma, DMA_CH_G2.ch_num);
 8029b0a:	682b      	ldr	r3, [r5, #0]
 8029b0c:	7b29      	ldrb	r1, [r5, #12]
 8029b0e:	6818      	ldr	r0, [r3, #0]
 8029b10:	f7f8 f892 	bl	8021c38 <XMC_DMA_CH_ClearSourcePeripheralRequest>
	XMC_DMA_CH_ClearSourcePeripheralRequest(DMA_CH_G3.dma_global->dma, DMA_CH_G3.ch_num);
 8029b14:	6823      	ldr	r3, [r4, #0]
 8029b16:	7b21      	ldrb	r1, [r4, #12]
 8029b18:	6818      	ldr	r0, [r3, #0]
 8029b1a:	f7f8 f88d 	bl	8021c38 <XMC_DMA_CH_ClearSourcePeripheralRequest>

			/* Clear the request from source peripheral even though DMA was disabled by itself.
	         * We should consider the pending request from external peripheral. */
			dma_reset_dlr();

			acq_buf_obj *p_acq_buf = ds_get_active_acq_buf();
 8029b1e:	f7f6 fce7 	bl	80204f0 <ds_get_active_acq_buf>

//============================================================================

void copyDataBuffer2AcqBuffer(acq_buf_obj *p_acq_buf, uint32_t frame_counter)
{
	  uint16_t *p_dst_Ch0 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 0, 0);
 8029b22:	2100      	movs	r1, #0
			dma_reset_dlr();

			acq_buf_obj *p_acq_buf = ds_get_active_acq_buf();

			/* copy data buffer into target buffer, if skip count is active*/
			copyDataBuffer2AcqBuffer(p_acq_buf, bsp_frame_counter);
 8029b24:	f8d8 3000 	ldr.w	r3, [r8]
 8029b28:	9301      	str	r3, [sp, #4]

//============================================================================

void copyDataBuffer2AcqBuffer(acq_buf_obj *p_acq_buf, uint32_t frame_counter)
{
	  uint16_t *p_dst_Ch0 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 0, 0);
 8029b2a:	460a      	mov	r2, r1

			/* Clear the request from source peripheral even though DMA was disabled by itself.
	         * We should consider the pending request from external peripheral. */
			dma_reset_dlr();

			acq_buf_obj *p_acq_buf = ds_get_active_acq_buf();
 8029b2c:	4604      	mov	r4, r0

//============================================================================

void copyDataBuffer2AcqBuffer(acq_buf_obj *p_acq_buf, uint32_t frame_counter)
{
	  uint16_t *p_dst_Ch0 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 0, 0);
 8029b2e:	f7f6 fe87 	bl	8020840 <get_buffer_address_by_chirp>
	  uint16_t *p_dst_Ch1 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 1, 0);
 8029b32:	2101      	movs	r1, #1

//============================================================================

void copyDataBuffer2AcqBuffer(acq_buf_obj *p_acq_buf, uint32_t frame_counter)
{
	  uint16_t *p_dst_Ch0 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 0, 0);
 8029b34:	9002      	str	r0, [sp, #8]
	  uint16_t *p_dst_Ch1 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 1, 0);
 8029b36:	2200      	movs	r2, #0
 8029b38:	4620      	mov	r0, r4
 8029b3a:	f7f6 fe81 	bl	8020840 <get_buffer_address_by_chirp>
	  uint16_t *p_dst_Ch2 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 2, 0);
 8029b3e:	2102      	movs	r1, #2
//============================================================================

void copyDataBuffer2AcqBuffer(acq_buf_obj *p_acq_buf, uint32_t frame_counter)
{
	  uint16_t *p_dst_Ch0 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 0, 0);
	  uint16_t *p_dst_Ch1 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 1, 0);
 8029b40:	4681      	mov	r9, r0
	  uint16_t *p_dst_Ch2 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 2, 0);
 8029b42:	2200      	movs	r2, #0
 8029b44:	4620      	mov	r0, r4
 8029b46:	f7f6 fe7b 	bl	8020840 <get_buffer_address_by_chirp>
	  uint16_t *p_dst_Ch3 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 3, 0);
 8029b4a:	2103      	movs	r1, #3

void copyDataBuffer2AcqBuffer(acq_buf_obj *p_acq_buf, uint32_t frame_counter)
{
	  uint16_t *p_dst_Ch0 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 0, 0);
	  uint16_t *p_dst_Ch1 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 1, 0);
	  uint16_t *p_dst_Ch2 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 2, 0);
 8029b4c:	4683      	mov	fp, r0
	  uint16_t *p_dst_Ch3 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 3, 0);
 8029b4e:	2200      	movs	r2, #0
 8029b50:	4620      	mov	r0, r4
 8029b52:	f7f6 fe75 	bl	8020840 <get_buffer_address_by_chirp>

	  uint32_t skip_count = p_acq_buf->internals.skip_count;
	  uint32_t byte_count = p_acq_buf->params.num_of_samples_per_chirp*sizeof(uint16_t);
 8029b56:	8866      	ldrh	r6, [r4, #2]
	  uint16_t *p_dst_Ch0 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 0, 0);
	  uint16_t *p_dst_Ch1 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 1, 0);
	  uint16_t *p_dst_Ch2 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 2, 0);
	  uint16_t *p_dst_Ch3 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 3, 0);

	  uint32_t skip_count = p_acq_buf->internals.skip_count;
 8029b58:	69e5      	ldr	r5, [r4, #28]
	  uint32_t byte_count = p_acq_buf->params.num_of_samples_per_chirp*sizeof(uint16_t);

	  memcpy(p_dst_Ch0, &data_buffer[0][skip_count], byte_count);
 8029b5a:	f8dd c008 	ldr.w	ip, [sp, #8]
	  uint16_t *p_dst_Ch1 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 1, 0);
	  uint16_t *p_dst_Ch2 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 2, 0);
	  uint16_t *p_dst_Ch3 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 3, 0);

	  uint32_t skip_count = p_acq_buf->internals.skip_count;
	  uint32_t byte_count = p_acq_buf->params.num_of_samples_per_chirp*sizeof(uint16_t);
 8029b5e:	0076      	lsls	r6, r6, #1
void copyDataBuffer2AcqBuffer(acq_buf_obj *p_acq_buf, uint32_t frame_counter)
{
	  uint16_t *p_dst_Ch0 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 0, 0);
	  uint16_t *p_dst_Ch1 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 1, 0);
	  uint16_t *p_dst_Ch2 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 2, 0);
	  uint16_t *p_dst_Ch3 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 3, 0);
 8029b60:	4682      	mov	sl, r0

	  uint32_t skip_count = p_acq_buf->internals.skip_count;
	  uint32_t byte_count = p_acq_buf->params.num_of_samples_per_chirp*sizeof(uint16_t);

	  memcpy(p_dst_Ch0, &data_buffer[0][skip_count], byte_count);
 8029b62:	4632      	mov	r2, r6
 8029b64:	4660      	mov	r0, ip
 8029b66:	eb07 0145 	add.w	r1, r7, r5, lsl #1
 8029b6a:	f003 fcf1 	bl	802d550 <memcpy>
	  memcpy(p_dst_Ch1, &data_buffer[1][skip_count], byte_count);
 8029b6e:	f505 619d 	add.w	r1, r5, #1256	; 0x4e8
 8029b72:	4632      	mov	r2, r6
 8029b74:	eb07 0141 	add.w	r1, r7, r1, lsl #1
 8029b78:	4648      	mov	r0, r9
 8029b7a:	f003 fce9 	bl	802d550 <memcpy>
	  memcpy(p_dst_Ch2, &data_buffer[2][skip_count], byte_count);
 8029b7e:	f505 611d 	add.w	r1, r5, #2512	; 0x9d0
 8029b82:	4632      	mov	r2, r6
 8029b84:	eb07 0141 	add.w	r1, r7, r1, lsl #1
 8029b88:	4658      	mov	r0, fp
 8029b8a:	f003 fce1 	bl	802d550 <memcpy>
	  memcpy(p_dst_Ch3, &data_buffer[3][skip_count], byte_count);
 8029b8e:	f605 61b8 	addw	r1, r5, #3768	; 0xeb8
 8029b92:	4632      	mov	r2, r6
 8029b94:	eb07 0141 	add.w	r1, r7, r1, lsl #1
 8029b98:	4650      	mov	r0, sl
 8029b9a:	f003 fcd9 	bl	802d550 <memcpy>
			acq_buf_obj *p_acq_buf = ds_get_active_acq_buf();

			/* copy data buffer into target buffer, if skip count is active*/
			copyDataBuffer2AcqBuffer(p_acq_buf, bsp_frame_counter);

			bsp_frame_counter++;
 8029b9e:	f8d8 3000 	ldr.w	r3, [r8]
	  memcpy(p_dst_Ch0, &data_buffer[0][skip_count], byte_count);
	  memcpy(p_dst_Ch1, &data_buffer[1][skip_count], byte_count);
	  memcpy(p_dst_Ch2, &data_buffer[2][skip_count], byte_count);
	  memcpy(p_dst_Ch3, &data_buffer[3][skip_count], byte_count);

	  p_acq_buf->frame_counter = frame_counter;
 8029ba2:	9a01      	ldr	r2, [sp, #4]
 8029ba4:	6362      	str	r2, [r4, #52]	; 0x34
			acq_buf_obj *p_acq_buf = ds_get_active_acq_buf();

			/* copy data buffer into target buffer, if skip count is active*/
			copyDataBuffer2AcqBuffer(p_acq_buf, bsp_frame_counter);

			bsp_frame_counter++;
 8029ba6:	3301      	adds	r3, #1
 8029ba8:	f8c8 3000 	str.w	r3, [r8]

		g_adc_sampling_completed = true;

		/* One frame is ready */
		/* This callback is used to inform upper layers that a valid data is available and ADC sampling is completed */
		if ((bsp_cb.bsp_acq_done_cb != NULL) & (watchdog_status == 0))
 8029bac:	4b6c      	ldr	r3, [pc, #432]	; (8029d60 <DMA_Event_Handler+0x304>)
			copyDataBuffer2AcqBuffer(p_acq_buf, bsp_frame_counter);

			bsp_frame_counter++;
		}

		g_adc_sampling_completed = true;
 8029bae:	496d      	ldr	r1, [pc, #436]	; (8029d64 <DMA_Event_Handler+0x308>)

		/* One frame is ready */
		/* This callback is used to inform upper layers that a valid data is available and ADC sampling is completed */
		if ((bsp_cb.bsp_acq_done_cb != NULL) & (watchdog_status == 0))
 8029bb0:	781a      	ldrb	r2, [r3, #0]
 8029bb2:	4b6d      	ldr	r3, [pc, #436]	; (8029d68 <DMA_Event_Handler+0x30c>)
			copyDataBuffer2AcqBuffer(p_acq_buf, bsp_frame_counter);

			bsp_frame_counter++;
		}

		g_adc_sampling_completed = true;
 8029bb4:	2001      	movs	r0, #1
 8029bb6:	6008      	str	r0, [r1, #0]

		/* One frame is ready */
		/* This callback is used to inform upper layers that a valid data is available and ADC sampling is completed */
		if ((bsp_cb.bsp_acq_done_cb != NULL) & (watchdog_status == 0))
 8029bb8:	685b      	ldr	r3, [r3, #4]
 8029bba:	b92a      	cbnz	r2, 8029bc8 <DMA_Event_Handler+0x16c>
 8029bbc:	b123      	cbz	r3, 8029bc8 <DMA_Event_Handler+0x16c>
		{
			bsp_cb.bsp_acq_done_cb(NULL);
 8029bbe:	2000      	movs	r0, #0
		}
	}
}
 8029bc0:	b007      	add	sp, #28
 8029bc2:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

		/* One frame is ready */
		/* This callback is used to inform upper layers that a valid data is available and ADC sampling is completed */
		if ((bsp_cb.bsp_acq_done_cb != NULL) & (watchdog_status == 0))
		{
			bsp_cb.bsp_acq_done_cb(NULL);
 8029bc6:	4718      	bx	r3
		}
	}
}
 8029bc8:	b007      	add	sp, #28
 8029bca:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8029bce:	4a67      	ldr	r2, [pc, #412]	; (8029d6c <DMA_Event_Handler+0x310>)
 8029bd0:	4b67      	ldr	r3, [pc, #412]	; (8029d70 <DMA_Event_Handler+0x314>)
 8029bd2:	7c10      	ldrb	r0, [r2, #16]
 8029bd4:	7c1c      	ldrb	r4, [r3, #16]
 8029bd6:	6811      	ldr	r1, [r2, #0]
 8029bd8:	681a      	ldr	r2, [r3, #0]
 8029bda:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8029bde:	fa03 f000 	lsl.w	r0, r3, r0
 8029be2:	40a3      	lsls	r3, r4
 8029be4:	6048      	str	r0, [r1, #4]
 8029be6:	6053      	str	r3, [r2, #4]
 8029be8:	e762      	b.n	8029ab0 <DMA_Event_Handler+0x54>
 8029bea:	f8df 818c 	ldr.w	r8, [pc, #396]	; 8029d78 <DMA_Event_Handler+0x31c>
 8029bee:	4f58      	ldr	r7, [pc, #352]	; (8029d50 <DMA_Event_Handler+0x2f4>)
 8029bf0:	f8d8 3000 	ldr.w	r3, [r8]
 8029bf4:	f898 100c 	ldrb.w	r1, [r8, #12]
 8029bf8:	6818      	ldr	r0, [r3, #0]
 8029bfa:	4e56      	ldr	r6, [pc, #344]	; (8029d54 <DMA_Event_Handler+0x2f8>)
 8029bfc:	4d56      	ldr	r5, [pc, #344]	; (8029d58 <DMA_Event_Handler+0x2fc>)
	  uint16_t *p_dst_Ch3 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 3, 0);

	  uint32_t skip_count = p_acq_buf->internals.skip_count;
	  uint32_t byte_count = p_acq_buf->params.num_of_samples_per_chirp*sizeof(uint16_t);

	  memcpy(p_dst_Ch0, &data_buffer[0][skip_count], byte_count);
 8029bfe:	f8df b15c 	ldr.w	fp, [pc, #348]	; 8029d5c <DMA_Event_Handler+0x300>
 8029c02:	f7f7 fe9b 	bl	802193c <XMC_DMA_CH_Disable>
 8029c06:	683b      	ldr	r3, [r7, #0]
 8029c08:	7b39      	ldrb	r1, [r7, #12]
 8029c0a:	6818      	ldr	r0, [r3, #0]
 8029c0c:	f7f7 fe96 	bl	802193c <XMC_DMA_CH_Disable>
 8029c10:	6833      	ldr	r3, [r6, #0]
 8029c12:	7b31      	ldrb	r1, [r6, #12]
 8029c14:	6818      	ldr	r0, [r3, #0]
 8029c16:	f7f7 fe91 	bl	802193c <XMC_DMA_CH_Disable>
 8029c1a:	682b      	ldr	r3, [r5, #0]
 8029c1c:	7b29      	ldrb	r1, [r5, #12]
 8029c1e:	6818      	ldr	r0, [r3, #0]
 8029c20:	f7f7 fe8c 	bl	802193c <XMC_DMA_CH_Disable>

//============================================================================

static void dma_reset_dlr(void)
{
	XMC_DMA_CH_ClearSourcePeripheralRequest(DMA_CH_G0.dma_global->dma, DMA_CH_G0.ch_num);
 8029c24:	f8d8 3000 	ldr.w	r3, [r8]
 8029c28:	f898 100c 	ldrb.w	r1, [r8, #12]
 8029c2c:	6818      	ldr	r0, [r3, #0]
 8029c2e:	f7f8 f803 	bl	8021c38 <XMC_DMA_CH_ClearSourcePeripheralRequest>
	XMC_DMA_CH_ClearSourcePeripheralRequest(DMA_CH_G1.dma_global->dma, DMA_CH_G1.ch_num);
 8029c32:	683b      	ldr	r3, [r7, #0]
 8029c34:	7b39      	ldrb	r1, [r7, #12]
 8029c36:	6818      	ldr	r0, [r3, #0]
 8029c38:	f7f7 fffe 	bl	8021c38 <XMC_DMA_CH_ClearSourcePeripheralRequest>
	XMC_DMA_CH_ClearSourcePeripheralRequest(DMA_CH_G2.dma_global->dma, DMA_CH_G2.ch_num);
 8029c3c:	6833      	ldr	r3, [r6, #0]
 8029c3e:	7b31      	ldrb	r1, [r6, #12]
 8029c40:	6818      	ldr	r0, [r3, #0]
 8029c42:	f7f7 fff9 	bl	8021c38 <XMC_DMA_CH_ClearSourcePeripheralRequest>
	XMC_DMA_CH_ClearSourcePeripheralRequest(DMA_CH_G3.dma_global->dma, DMA_CH_G3.ch_num);
 8029c46:	682b      	ldr	r3, [r5, #0]
 8029c48:	7b29      	ldrb	r1, [r5, #12]
 8029c4a:	6818      	ldr	r0, [r3, #0]
 8029c4c:	f7f7 fff4 	bl	8021c38 <XMC_DMA_CH_ClearSourcePeripheralRequest>

			/* Clear the request from source peripheral even though DMA was disabled by itself.
	         * We should consider the pending request from external peripheral. */
			dma_reset_dlr();

			acq_buf_obj *p_acq_buf = ds_get_active_acq_buf();
 8029c50:	f7f6 fc4e 	bl	80204f0 <ds_get_active_acq_buf>

			/* copy data buffer into target buffer, if skip count is active*/
			copyDataBuffer2AcqBuffer(p_acq_buf, bsp_frame_counter);
 8029c54:	4b47      	ldr	r3, [pc, #284]	; (8029d74 <DMA_Event_Handler+0x318>)

//============================================================================

void copyDataBuffer2AcqBuffer(acq_buf_obj *p_acq_buf, uint32_t frame_counter)
{
	  uint16_t *p_dst_Ch0 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 0, 0);
 8029c56:	2100      	movs	r1, #0
			dma_reset_dlr();

			acq_buf_obj *p_acq_buf = ds_get_active_acq_buf();

			/* copy data buffer into target buffer, if skip count is active*/
			copyDataBuffer2AcqBuffer(p_acq_buf, bsp_frame_counter);
 8029c58:	681b      	ldr	r3, [r3, #0]
 8029c5a:	9301      	str	r3, [sp, #4]

//============================================================================

void copyDataBuffer2AcqBuffer(acq_buf_obj *p_acq_buf, uint32_t frame_counter)
{
	  uint16_t *p_dst_Ch0 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 0, 0);
 8029c5c:	460a      	mov	r2, r1

			/* Clear the request from source peripheral even though DMA was disabled by itself.
	         * We should consider the pending request from external peripheral. */
			dma_reset_dlr();

			acq_buf_obj *p_acq_buf = ds_get_active_acq_buf();
 8029c5e:	4604      	mov	r4, r0

//============================================================================

void copyDataBuffer2AcqBuffer(acq_buf_obj *p_acq_buf, uint32_t frame_counter)
{
	  uint16_t *p_dst_Ch0 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 0, 0);
 8029c60:	f7f6 fdee 	bl	8020840 <get_buffer_address_by_chirp>
	  uint16_t *p_dst_Ch1 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 1, 0);
 8029c64:	2101      	movs	r1, #1

//============================================================================

void copyDataBuffer2AcqBuffer(acq_buf_obj *p_acq_buf, uint32_t frame_counter)
{
	  uint16_t *p_dst_Ch0 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 0, 0);
 8029c66:	9005      	str	r0, [sp, #20]
	  uint16_t *p_dst_Ch1 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 1, 0);
 8029c68:	2200      	movs	r2, #0
 8029c6a:	4620      	mov	r0, r4
 8029c6c:	f7f6 fde8 	bl	8020840 <get_buffer_address_by_chirp>
	  uint16_t *p_dst_Ch2 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 2, 0);
 8029c70:	4649      	mov	r1, r9
//============================================================================

void copyDataBuffer2AcqBuffer(acq_buf_obj *p_acq_buf, uint32_t frame_counter)
{
	  uint16_t *p_dst_Ch0 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 0, 0);
	  uint16_t *p_dst_Ch1 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 1, 0);
 8029c72:	9004      	str	r0, [sp, #16]
	  uint16_t *p_dst_Ch2 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 2, 0);
 8029c74:	2200      	movs	r2, #0
 8029c76:	4620      	mov	r0, r4
 8029c78:	f7f6 fde2 	bl	8020840 <get_buffer_address_by_chirp>
	  uint16_t *p_dst_Ch3 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 3, 0);
 8029c7c:	2103      	movs	r1, #3

void copyDataBuffer2AcqBuffer(acq_buf_obj *p_acq_buf, uint32_t frame_counter)
{
	  uint16_t *p_dst_Ch0 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 0, 0);
	  uint16_t *p_dst_Ch1 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 1, 0);
	  uint16_t *p_dst_Ch2 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 2, 0);
 8029c7e:	9002      	str	r0, [sp, #8]
	  uint16_t *p_dst_Ch3 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 3, 0);
 8029c80:	2200      	movs	r2, #0
 8029c82:	4620      	mov	r0, r4
 8029c84:	f7f6 fddc 	bl	8020840 <get_buffer_address_by_chirp>

	  uint32_t skip_count = p_acq_buf->internals.skip_count;
	  uint32_t byte_count = p_acq_buf->params.num_of_samples_per_chirp*sizeof(uint16_t);
 8029c88:	f8b4 a002 	ldrh.w	sl, [r4, #2]

	  memcpy(p_dst_Ch0, &data_buffer[0][skip_count], byte_count);
 8029c8c:	f8dd c014 	ldr.w	ip, [sp, #20]
	  uint16_t *p_dst_Ch0 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 0, 0);
	  uint16_t *p_dst_Ch1 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 1, 0);
	  uint16_t *p_dst_Ch2 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 2, 0);
	  uint16_t *p_dst_Ch3 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 3, 0);

	  uint32_t skip_count = p_acq_buf->internals.skip_count;
 8029c90:	f8d4 901c 	ldr.w	r9, [r4, #28]
void copyDataBuffer2AcqBuffer(acq_buf_obj *p_acq_buf, uint32_t frame_counter)
{
	  uint16_t *p_dst_Ch0 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 0, 0);
	  uint16_t *p_dst_Ch1 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 1, 0);
	  uint16_t *p_dst_Ch2 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 2, 0);
	  uint16_t *p_dst_Ch3 = (uint16_t*) get_buffer_address_by_chirp(p_acq_buf, 3, 0);
 8029c94:	9003      	str	r0, [sp, #12]

	  uint32_t skip_count = p_acq_buf->internals.skip_count;
	  uint32_t byte_count = p_acq_buf->params.num_of_samples_per_chirp*sizeof(uint16_t);
 8029c96:	ea4f 0a4a 	mov.w	sl, sl, lsl #1

	  memcpy(p_dst_Ch0, &data_buffer[0][skip_count], byte_count);
 8029c9a:	4660      	mov	r0, ip
 8029c9c:	4652      	mov	r2, sl
 8029c9e:	eb0b 0149 	add.w	r1, fp, r9, lsl #1
 8029ca2:	f003 fc55 	bl	802d550 <memcpy>
	  memcpy(p_dst_Ch1, &data_buffer[1][skip_count], byte_count);
 8029ca6:	9b04      	ldr	r3, [sp, #16]
 8029ca8:	f509 619d 	add.w	r1, r9, #1256	; 0x4e8
 8029cac:	4618      	mov	r0, r3
 8029cae:	4652      	mov	r2, sl
 8029cb0:	eb0b 0141 	add.w	r1, fp, r1, lsl #1
 8029cb4:	f003 fc4c 	bl	802d550 <memcpy>
	  memcpy(p_dst_Ch2, &data_buffer[2][skip_count], byte_count);
 8029cb8:	f509 611d 	add.w	r1, r9, #2512	; 0x9d0
 8029cbc:	4652      	mov	r2, sl
 8029cbe:	eb0b 0141 	add.w	r1, fp, r1, lsl #1
 8029cc2:	9802      	ldr	r0, [sp, #8]
 8029cc4:	f003 fc44 	bl	802d550 <memcpy>
	  memcpy(p_dst_Ch3, &data_buffer[3][skip_count], byte_count);
 8029cc8:	f609 61b8 	addw	r1, r9, #3768	; 0xeb8
 8029ccc:	4652      	mov	r2, sl
 8029cce:	eb0b 0141 	add.w	r1, fp, r1, lsl #1
 8029cd2:	9803      	ldr	r0, [sp, #12]
 8029cd4:	f003 fc3c 	bl	802d550 <memcpy>

	  p_acq_buf->frame_counter = frame_counter;
 8029cd8:	9b01      	ldr	r3, [sp, #4]
 8029cda:	6363      	str	r3, [r4, #52]	; 0x34

			/* copy data buffer into target buffer, if skip count is active*/
			copyDataBuffer2AcqBuffer(p_acq_buf, bsp_frame_counter);

			/* DMA Reconfiguration */
			bsp_dma_set_adc_control_from_acq_buf_obj(p_acq_buf);
 8029cdc:	4620      	mov	r0, r4
 8029cde:	f7ff fdbf 	bl	8029860 <bsp_dma_set_adc_control_from_acq_buf_obj>
 */
__STATIC_INLINE void DMA_CH_Enable(DMA_CH_t *const obj)
{
  XMC_ASSERT("DMA_CH_Enable: NULL DMA_CH_t object", (obj != NULL));

  XMC_DMA_CH_Enable(obj->dma_global->dma, obj->ch_num);
 8029ce2:	f8d8 4000 	ldr.w	r4, [r8]
 8029ce6:	6839      	ldr	r1, [r7, #0]
 8029ce8:	6832      	ldr	r2, [r6, #0]
 8029cea:	682b      	ldr	r3, [r5, #0]
 8029cec:	f897 c00c 	ldrb.w	ip, [r7, #12]
 8029cf0:	7b30      	ldrb	r0, [r6, #12]
 8029cf2:	f895 e00c 	ldrb.w	lr, [r5, #12]
 8029cf6:	f898 800c 	ldrb.w	r8, [r8, #12]
 8029cfa:	6826      	ldr	r6, [r4, #0]
 8029cfc:	680c      	ldr	r4, [r1, #0]
 8029cfe:	6811      	ldr	r1, [r2, #0]
 8029d00:	681a      	ldr	r2, [r3, #0]
 8029d02:	f240 1301 	movw	r3, #257	; 0x101
 8029d06:	fa03 f708 	lsl.w	r7, r3, r8
 8029d0a:	fa03 f50c 	lsl.w	r5, r3, ip
 8029d0e:	fa03 f000 	lsl.w	r0, r3, r0
 8029d12:	fa03 f30e 	lsl.w	r3, r3, lr
 8029d16:	f8c6 73a0 	str.w	r7, [r6, #928]	; 0x3a0
 8029d1a:	f8c4 53a0 	str.w	r5, [r4, #928]	; 0x3a0
 8029d1e:	f8c1 03a0 	str.w	r0, [r1, #928]	; 0x3a0
 8029d22:	f8c2 33a0 	str.w	r3, [r2, #928]	; 0x3a0

			/* Enable DMA */
			dma_enable();

			bsp_frame_counter++;
 8029d26:	4b13      	ldr	r3, [pc, #76]	; (8029d74 <DMA_Event_Handler+0x318>)
 8029d28:	4a12      	ldr	r2, [pc, #72]	; (8029d74 <DMA_Event_Handler+0x318>)
 8029d2a:	681b      	ldr	r3, [r3, #0]
 8029d2c:	3301      	adds	r3, #1
 8029d2e:	6013      	str	r3, [r2, #0]
 8029d30:	e73c      	b.n	8029bac <DMA_Event_Handler+0x150>
 8029d32:	bf00      	nop
 8029d34:	1ffeb4a0 	.word	0x1ffeb4a0
 8029d38:	1ffe91b0 	.word	0x1ffe91b0
 8029d3c:	1ffeb4ac 	.word	0x1ffeb4ac
 8029d40:	0802f8f8 	.word	0x0802f8f8
 8029d44:	0802f86c 	.word	0x0802f86c
 8029d48:	1ffe95fc 	.word	0x1ffe95fc
 8029d4c:	1ffe9228 	.word	0x1ffe9228
 8029d50:	1ffe93d0 	.word	0x1ffe93d0
 8029d54:	1ffe93e0 	.word	0x1ffe93e0
 8029d58:	1ffe93f0 	.word	0x1ffe93f0
 8029d5c:	1ffeb4b0 	.word	0x1ffeb4b0
 8029d60:	1ffeb49c 	.word	0x1ffeb49c
 8029d64:	1ffe9784 	.word	0x1ffe9784
 8029d68:	1ffedc0c 	.word	0x1ffedc0c
 8029d6c:	0802f844 	.word	0x0802f844
 8029d70:	0802f858 	.word	0x0802f858
 8029d74:	1ffeb4a4 	.word	0x1ffeb4a4
 8029d78:	1ffe93c0 	.word	0x1ffe93c0

08029d7c <CCU43_1_IRQHandler>:
}

//============================================================================

void trigger_ptat_delay(void)
{
 8029d7c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

TIMER_STATUS_t bsp_timer_stop_clear(TIMER_t *const handle_timer)
{
	TIMER_STATUS_t status;

	status = TIMER_Stop(handle_timer);
 8029d80:	482f      	ldr	r0, [pc, #188]	; (8029e40 <CCU43_1_IRQHandler+0xc4>)
 8029d82:	4f30      	ldr	r7, [pc, #192]	; (8029e44 <CCU43_1_IRQHandler+0xc8>)
 8029d84:	4e30      	ldr	r6, [pc, #192]	; (8029e48 <CCU43_1_IRQHandler+0xcc>)
 8029d86:	4d31      	ldr	r5, [pc, #196]	; (8029e4c <CCU43_1_IRQHandler+0xd0>)
 8029d88:	4c31      	ldr	r4, [pc, #196]	; (8029e50 <CCU43_1_IRQHandler+0xd4>)
}

//============================================================================

void trigger_ptat_delay(void)
{
 8029d8a:	b081      	sub	sp, #4

TIMER_STATUS_t bsp_timer_stop_clear(TIMER_t *const handle_timer)
{
	TIMER_STATUS_t status;

	status = TIMER_Stop(handle_timer);
 8029d8c:	f7fc f888 	bl	8025ea0 <TIMER_Stop>

	status |= TIMER_Clear(handle_timer);
 8029d90:	482b      	ldr	r0, [pc, #172]	; (8029e40 <CCU43_1_IRQHandler+0xc4>)
 8029d92:	f7fc f911 	bl	8025fb8 <TIMER_Clear>
 */
__STATIC_INLINE void DMA_CH_Disable(DMA_CH_t *const obj)
{
  XMC_ASSERT("DMA_CH_Disable: NULL DMA_CH_t object", (obj != NULL));

  XMC_DMA_CH_Disable(obj->dma_global->dma, obj->ch_num);
 8029d96:	683a      	ldr	r2, [r7, #0]
==============================================================================
 */

static void trigger_dma_start(void)
{
	watchdog_status = 0;
 8029d98:	4b2e      	ldr	r3, [pc, #184]	; (8029e54 <CCU43_1_IRQHandler+0xd8>)
 8029d9a:	6810      	ldr	r0, [r2, #0]
 8029d9c:	7b39      	ldrb	r1, [r7, #12]
 8029d9e:	f04f 0800 	mov.w	r8, #0
 8029da2:	f883 8000 	strb.w	r8, [r3]
 8029da6:	f7f7 fdc9 	bl	802193c <XMC_DMA_CH_Disable>
 8029daa:	6833      	ldr	r3, [r6, #0]
 8029dac:	7b31      	ldrb	r1, [r6, #12]
 8029dae:	6818      	ldr	r0, [r3, #0]
 8029db0:	f7f7 fdc4 	bl	802193c <XMC_DMA_CH_Disable>
 8029db4:	682b      	ldr	r3, [r5, #0]
 8029db6:	7b29      	ldrb	r1, [r5, #12]
 8029db8:	6818      	ldr	r0, [r3, #0]
 8029dba:	f7f7 fdbf 	bl	802193c <XMC_DMA_CH_Disable>
 8029dbe:	6823      	ldr	r3, [r4, #0]
 8029dc0:	7b21      	ldrb	r1, [r4, #12]
 8029dc2:	6818      	ldr	r0, [r3, #0]
 8029dc4:	f7f7 fdba 	bl	802193c <XMC_DMA_CH_Disable>

	/* DMA Reconfiguration */
	dma_disable();

	acq_buf_obj *p_acq_buf = ds_get_active_acq_buf();
 8029dc8:	f7f6 fb92 	bl	80204f0 <ds_get_active_acq_buf>

	bsp_dma_set_adc_control_from_acq_buf_obj(p_acq_buf);
 8029dcc:	f7ff fd48 	bl	8029860 <bsp_dma_set_adc_control_from_acq_buf_obj>
//============================================================================

static void bgt24ltr1x_start_up(void)
{
	/* Start BGT */
	PWM_CCU8_Start(&PWM_CCU8_BGT_VCC);
 8029dd0:	4821      	ldr	r0, [pc, #132]	; (8029e58 <CCU43_1_IRQHandler+0xdc>)
 8029dd2:	f7fc faaf 	bl	8026334 <PWM_CCU8_Start>
 */
__STATIC_INLINE void DMA_CH_Enable(DMA_CH_t *const obj)
{
  XMC_ASSERT("DMA_CH_Enable: NULL DMA_CH_t object", (obj != NULL));

  XMC_DMA_CH_Enable(obj->dma_global->dma, obj->ch_num);
 8029dd6:	6830      	ldr	r0, [r6, #0]
 8029dd8:	6829      	ldr	r1, [r5, #0]
 8029dda:	6822      	ldr	r2, [r4, #0]
{
	/* Get the raw ADC data */
	trigger_dma_start();

	/* This callback is used to inform upper layers about the beginning of data acquisition process */
	if (bsp_cb.bsp_acq_started_cb != NULL)
 8029ddc:	4b1f      	ldr	r3, [pc, #124]	; (8029e5c <CCU43_1_IRQHandler+0xe0>)
 8029dde:	f8d7 b000 	ldr.w	fp, [r7]
 8029de2:	f894 c00c 	ldrb.w	ip, [r4, #12]
 8029de6:	f897 e00c 	ldrb.w	lr, [r7, #12]
 8029dea:	f896 900c 	ldrb.w	r9, [r6, #12]
 8029dee:	f895 a00c 	ldrb.w	sl, [r5, #12]
 8029df2:	f8db 7000 	ldr.w	r7, [fp]
 8029df6:	6805      	ldr	r5, [r0, #0]
	bsp_bgt_start_up();

	/* Enable DMA */
	dma_enable();

	l_acq_started = 1;
 8029df8:	4e19      	ldr	r6, [pc, #100]	; (8029e60 <CCU43_1_IRQHandler+0xe4>)
 8029dfa:	6808      	ldr	r0, [r1, #0]
 8029dfc:	6811      	ldr	r1, [r2, #0]
{
	/* Get the raw ADC data */
	trigger_dma_start();

	/* This callback is used to inform upper layers about the beginning of data acquisition process */
	if (bsp_cb.bsp_acq_started_cb != NULL)
 8029dfe:	681a      	ldr	r2, [r3, #0]
 8029e00:	f240 1301 	movw	r3, #257	; 0x101
 8029e04:	fa03 fe0e 	lsl.w	lr, r3, lr
 8029e08:	fa03 f909 	lsl.w	r9, r3, r9
 8029e0c:	fa03 f40a 	lsl.w	r4, r3, sl
 8029e10:	fa03 f30c 	lsl.w	r3, r3, ip
	bsp_bgt_start_up();

	/* Enable DMA */
	dma_enable();

	l_acq_started = 1;
 8029e14:	f04f 0c01 	mov.w	ip, #1
 8029e18:	f8c7 e3a0 	str.w	lr, [r7, #928]	; 0x3a0
 8029e1c:	f8c6 c000 	str.w	ip, [r6]
 8029e20:	f8c5 93a0 	str.w	r9, [r5, #928]	; 0x3a0
 8029e24:	f8c0 43a0 	str.w	r4, [r0, #928]	; 0x3a0
 8029e28:	f8c1 33a0 	str.w	r3, [r1, #928]	; 0x3a0
{
	/* Get the raw ADC data */
	trigger_dma_start();

	/* This callback is used to inform upper layers about the beginning of data acquisition process */
	if (bsp_cb.bsp_acq_started_cb != NULL)
 8029e2c:	b122      	cbz	r2, 8029e38 <CCU43_1_IRQHandler+0xbc>
	{
		bsp_cb.bsp_acq_started_cb(NULL);
 8029e2e:	4640      	mov	r0, r8
void trigger_ptat_delay(void)
{
	bsp_timer_stop_clear(&TIMER_PTAT_DELAY);
	// ptat delay expired, start the actual acquisition
	bsp_trigger_new_frame();
}
 8029e30:	b001      	add	sp, #4
 8029e32:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	trigger_dma_start();

	/* This callback is used to inform upper layers about the beginning of data acquisition process */
	if (bsp_cb.bsp_acq_started_cb != NULL)
	{
		bsp_cb.bsp_acq_started_cb(NULL);
 8029e36:	4710      	bx	r2
void trigger_ptat_delay(void)
{
	bsp_timer_stop_clear(&TIMER_PTAT_DELAY);
	// ptat delay expired, start the actual acquisition
	bsp_trigger_new_frame();
}
 8029e38:	b001      	add	sp, #4
 8029e3a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8029e3e:	bf00      	nop
 8029e40:	1ffe9120 	.word	0x1ffe9120
 8029e44:	1ffe93c0 	.word	0x1ffe93c0
 8029e48:	1ffe93d0 	.word	0x1ffe93d0
 8029e4c:	1ffe93e0 	.word	0x1ffe93e0
 8029e50:	1ffe93f0 	.word	0x1ffe93f0
 8029e54:	1ffeb49c 	.word	0x1ffeb49c
 8029e58:	1ffe9228 	.word	0x1ffe9228
 8029e5c:	1ffedc0c 	.word	0x1ffedc0c
 8029e60:	1ffeb4a0 	.word	0x1ffeb4a0

08029e64 <CCU41_1_IRQHandler>:
}

//============================================================================

void triggerFrameISR(void)
{
 8029e64:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8029e68:	b083      	sub	sp, #12
	Radar_Data_Acq_Mode_t mode = radar_get_data_acq_mode();
 8029e6a:	f7f6 fe9f 	bl	8020bac <radar_get_data_acq_mode>

	if (mode == RADAR_DATA_CONTINUOUS_MODE)
 8029e6e:	2802      	cmp	r0, #2
 8029e70:	f000 80bf 	beq.w	8029ff2 <CCU41_1_IRQHandler+0x18e>
		/* ensure V_PTAT_SH_EN is enabled */
		DIGITAL_IO_SetOutputHigh(&DIGITAL_IO_V_PTAT_SH_EN);

		bsp_trigger_new_frame();
	}
	else if (bb_pre_trigger_advance_usec > 0)
 8029e74:	4c6f      	ldr	r4, [pc, #444]	; (802a034 <CCU41_1_IRQHandler+0x1d0>)
 8029e76:	6823      	ldr	r3, [r4, #0]
 8029e78:	2b00      	cmp	r3, #0
 8029e7a:	f300 80a2 	bgt.w	8029fc2 <CCU41_1_IRQHandler+0x15e>
		DIGITAL_IO_SetOutputHigh(&DIGITAL_IO_BB1_EN);
		DIGITAL_IO_SetOutputHigh(&DIGITAL_IO_BB2_EN);

		bsp_timer_start(&TIMER_BB_PRE_TRIGGER);
	}
	else if (ptat_switching_status != 0 && ptat_switch_delay_usec > 0)
 8029e7e:	4a6e      	ldr	r2, [pc, #440]	; (802a038 <CCU41_1_IRQHandler+0x1d4>)
 8029e80:	6812      	ldr	r2, [r2, #0]
 8029e82:	2a00      	cmp	r2, #0
 8029e84:	d178      	bne.n	8029f78 <CCU41_1_IRQHandler+0x114>
			enable_Baseband(true);
		}
	}
	else
	{
		if (bb_pre_trigger_advance_usec < 0)
 8029e86:	2b00      	cmp	r3, #0
 8029e88:	f040 80af 	bne.w	8029fea <CCU41_1_IRQHandler+0x186>
 8029e8c:	4a6b      	ldr	r2, [pc, #428]	; (802a03c <CCU41_1_IRQHandler+0x1d8>)
 8029e8e:	4b6c      	ldr	r3, [pc, #432]	; (802a040 <CCU41_1_IRQHandler+0x1dc>)

__STATIC_INLINE void XMC_GPIO_SetOutputHigh(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputHigh: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = (uint32_t)0x1U << pin;
 8029e90:	7c10      	ldrb	r0, [r2, #16]
 8029e92:	7c1c      	ldrb	r4, [r3, #16]
 8029e94:	6811      	ldr	r1, [r2, #0]
 8029e96:	681a      	ldr	r2, [r3, #0]
 8029e98:	2301      	movs	r3, #1
 8029e9a:	fa03 f000 	lsl.w	r0, r3, r0
 8029e9e:	40a3      	lsls	r3, r4
 8029ea0:	6048      	str	r0, [r1, #4]
 8029ea2:	6053      	str	r3, [r2, #4]
 8029ea4:	4a67      	ldr	r2, [pc, #412]	; (802a044 <CCU41_1_IRQHandler+0x1e0>)
 8029ea6:	4b68      	ldr	r3, [pc, #416]	; (802a048 <CCU41_1_IRQHandler+0x1e4>)

__STATIC_INLINE void XMC_GPIO_SetOutputLow(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputLow: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = 0x10000U << pin;
 8029ea8:	f892 e010 	ldrb.w	lr, [r2, #16]
 8029eac:	f893 c010 	ldrb.w	ip, [r3, #16]
 8029eb0:	681b      	ldr	r3, [r3, #0]
 8029eb2:	6811      	ldr	r1, [r2, #0]
 8029eb4:	9301      	str	r3, [sp, #4]
 8029eb6:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8029eba:	fa03 f20e 	lsl.w	r2, r3, lr
 8029ebe:	604a      	str	r2, [r1, #4]
 8029ec0:	9a01      	ldr	r2, [sp, #4]
 8029ec2:	4f62      	ldr	r7, [pc, #392]	; (802a04c <CCU41_1_IRQHandler+0x1e8>)

TIMER_STATUS_t bsp_timer_start(TIMER_t *const handle_timer)
{
	TIMER_STATUS_t status;

	status = TIMER_Start(handle_timer);
 8029ec4:	4862      	ldr	r0, [pc, #392]	; (802a050 <CCU41_1_IRQHandler+0x1ec>)
 8029ec6:	4e63      	ldr	r6, [pc, #396]	; (802a054 <CCU41_1_IRQHandler+0x1f0>)
 8029ec8:	4d63      	ldr	r5, [pc, #396]	; (802a058 <CCU41_1_IRQHandler+0x1f4>)
 8029eca:	4c64      	ldr	r4, [pc, #400]	; (802a05c <CCU41_1_IRQHandler+0x1f8>)
 8029ecc:	fa03 f30c 	lsl.w	r3, r3, ip
 8029ed0:	6053      	str	r3, [r2, #4]
 8029ed2:	f7fb ffd5 	bl	8025e80 <TIMER_Start>
 */
__STATIC_INLINE void DMA_CH_Disable(DMA_CH_t *const obj)
{
  XMC_ASSERT("DMA_CH_Disable: NULL DMA_CH_t object", (obj != NULL));

  XMC_DMA_CH_Disable(obj->dma_global->dma, obj->ch_num);
 8029ed6:	683a      	ldr	r2, [r7, #0]
==============================================================================
 */

static void trigger_dma_start(void)
{
	watchdog_status = 0;
 8029ed8:	4b61      	ldr	r3, [pc, #388]	; (802a060 <CCU41_1_IRQHandler+0x1fc>)
 8029eda:	6810      	ldr	r0, [r2, #0]
 8029edc:	7b39      	ldrb	r1, [r7, #12]
 8029ede:	f04f 0800 	mov.w	r8, #0
 8029ee2:	f883 8000 	strb.w	r8, [r3]
 8029ee6:	f7f7 fd29 	bl	802193c <XMC_DMA_CH_Disable>
 8029eea:	6833      	ldr	r3, [r6, #0]
 8029eec:	7b31      	ldrb	r1, [r6, #12]
 8029eee:	6818      	ldr	r0, [r3, #0]
 8029ef0:	f7f7 fd24 	bl	802193c <XMC_DMA_CH_Disable>
 8029ef4:	682b      	ldr	r3, [r5, #0]
 8029ef6:	7b29      	ldrb	r1, [r5, #12]
 8029ef8:	6818      	ldr	r0, [r3, #0]
 8029efa:	f7f7 fd1f 	bl	802193c <XMC_DMA_CH_Disable>
 8029efe:	6823      	ldr	r3, [r4, #0]
 8029f00:	7b21      	ldrb	r1, [r4, #12]
 8029f02:	6818      	ldr	r0, [r3, #0]
 8029f04:	f7f7 fd1a 	bl	802193c <XMC_DMA_CH_Disable>

	/* DMA Reconfiguration */
	dma_disable();

	acq_buf_obj *p_acq_buf = ds_get_active_acq_buf();
 8029f08:	f7f6 faf2 	bl	80204f0 <ds_get_active_acq_buf>

	bsp_dma_set_adc_control_from_acq_buf_obj(p_acq_buf);
 8029f0c:	f7ff fca8 	bl	8029860 <bsp_dma_set_adc_control_from_acq_buf_obj>
//============================================================================

static void bgt24ltr1x_start_up(void)
{
	/* Start BGT */
	PWM_CCU8_Start(&PWM_CCU8_BGT_VCC);
 8029f10:	4854      	ldr	r0, [pc, #336]	; (802a064 <CCU41_1_IRQHandler+0x200>)
 8029f12:	f7fc fa0f 	bl	8026334 <PWM_CCU8_Start>
 */
__STATIC_INLINE void DMA_CH_Enable(DMA_CH_t *const obj)
{
  XMC_ASSERT("DMA_CH_Enable: NULL DMA_CH_t object", (obj != NULL));

  XMC_DMA_CH_Enable(obj->dma_global->dma, obj->ch_num);
 8029f16:	6830      	ldr	r0, [r6, #0]
 8029f18:	6829      	ldr	r1, [r5, #0]
 8029f1a:	6822      	ldr	r2, [r4, #0]
{
	/* Get the raw ADC data */
	trigger_dma_start();

	/* This callback is used to inform upper layers about the beginning of data acquisition process */
	if (bsp_cb.bsp_acq_started_cb != NULL)
 8029f1c:	4b52      	ldr	r3, [pc, #328]	; (802a068 <CCU41_1_IRQHandler+0x204>)
 8029f1e:	f8d7 b000 	ldr.w	fp, [r7]
 8029f22:	f894 c00c 	ldrb.w	ip, [r4, #12]
 8029f26:	f897 e00c 	ldrb.w	lr, [r7, #12]
 8029f2a:	f896 900c 	ldrb.w	r9, [r6, #12]
 8029f2e:	f895 a00c 	ldrb.w	sl, [r5, #12]
 8029f32:	f8db 7000 	ldr.w	r7, [fp]
 8029f36:	6805      	ldr	r5, [r0, #0]
	bsp_bgt_start_up();

	/* Enable DMA */
	dma_enable();

	l_acq_started = 1;
 8029f38:	4e4c      	ldr	r6, [pc, #304]	; (802a06c <CCU41_1_IRQHandler+0x208>)
 8029f3a:	6808      	ldr	r0, [r1, #0]
 8029f3c:	6811      	ldr	r1, [r2, #0]
{
	/* Get the raw ADC data */
	trigger_dma_start();

	/* This callback is used to inform upper layers about the beginning of data acquisition process */
	if (bsp_cb.bsp_acq_started_cb != NULL)
 8029f3e:	681a      	ldr	r2, [r3, #0]
 8029f40:	f240 1301 	movw	r3, #257	; 0x101
 8029f44:	fa03 fe0e 	lsl.w	lr, r3, lr
 8029f48:	fa03 f909 	lsl.w	r9, r3, r9
 8029f4c:	fa03 f40a 	lsl.w	r4, r3, sl
 8029f50:	fa03 f30c 	lsl.w	r3, r3, ip
	bsp_bgt_start_up();

	/* Enable DMA */
	dma_enable();

	l_acq_started = 1;
 8029f54:	f04f 0c01 	mov.w	ip, #1
 8029f58:	f8c7 e3a0 	str.w	lr, [r7, #928]	; 0x3a0
 8029f5c:	f8c6 c000 	str.w	ip, [r6]
 8029f60:	f8c5 93a0 	str.w	r9, [r5, #928]	; 0x3a0
 8029f64:	f8c0 43a0 	str.w	r4, [r0, #928]	; 0x3a0
 8029f68:	f8c1 33a0 	str.w	r3, [r1, #928]	; 0x3a0
{
	/* Get the raw ADC data */
	trigger_dma_start();

	/* This callback is used to inform upper layers about the beginning of data acquisition process */
	if (bsp_cb.bsp_acq_started_cb != NULL)
 8029f6c:	b332      	cbz	r2, 8029fbc <CCU41_1_IRQHandler+0x158>
	{
		bsp_cb.bsp_acq_started_cb(NULL);
 8029f6e:	4640      	mov	r0, r8

		bsp_timer_start(&TIMER_PTAT_S_H_DELAY);

		bsp_trigger_new_frame();
	}
}
 8029f70:	b003      	add	sp, #12
 8029f72:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	trigger_dma_start();

	/* This callback is used to inform upper layers about the beginning of data acquisition process */
	if (bsp_cb.bsp_acq_started_cb != NULL)
	{
		bsp_cb.bsp_acq_started_cb(NULL);
 8029f76:	4710      	bx	r2
		DIGITAL_IO_SetOutputHigh(&DIGITAL_IO_BB1_EN);
		DIGITAL_IO_SetOutputHigh(&DIGITAL_IO_BB2_EN);

		bsp_timer_start(&TIMER_BB_PRE_TRIGGER);
	}
	else if (ptat_switching_status != 0 && ptat_switch_delay_usec > 0)
 8029f78:	4a3d      	ldr	r2, [pc, #244]	; (802a070 <CCU41_1_IRQHandler+0x20c>)
 8029f7a:	6812      	ldr	r2, [r2, #0]
 8029f7c:	2a00      	cmp	r2, #0
 8029f7e:	d082      	beq.n	8029e86 <CCU41_1_IRQHandler+0x22>

TIMER_STATUS_t bsp_timer_start(TIMER_t *const handle_timer)
{
	TIMER_STATUS_t status;

	status = TIMER_Start(handle_timer);
 8029f80:	483c      	ldr	r0, [pc, #240]	; (802a074 <CCU41_1_IRQHandler+0x210>)
 8029f82:	f7fb ff7d 	bl	8025e80 <TIMER_Start>
 8029f86:	4a2f      	ldr	r2, [pc, #188]	; (802a044 <CCU41_1_IRQHandler+0x1e0>)
 8029f88:	4b2f      	ldr	r3, [pc, #188]	; (802a048 <CCU41_1_IRQHandler+0x1e4>)

__STATIC_INLINE void XMC_GPIO_SetOutputHigh(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputHigh: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = (uint32_t)0x1U << pin;
 8029f8a:	7c15      	ldrb	r5, [r2, #16]
 8029f8c:	7c18      	ldrb	r0, [r3, #16]

		/* ensure V_PTAT_SH_EN is enabled */
		DIGITAL_IO_SetOutputHigh(&DIGITAL_IO_V_PTAT_SH_EN);

		/* if bb_pre_trigger advance is negative or smaller then ptat_switch delay, then it is actually a delay */
		if (bb_pre_trigger_advance_usec < 0)
 8029f8e:	6821      	ldr	r1, [r4, #0]
 8029f90:	6814      	ldr	r4, [r2, #0]
 8029f92:	681a      	ldr	r2, [r3, #0]
 8029f94:	2301      	movs	r3, #1
 8029f96:	fa03 f505 	lsl.w	r5, r3, r5
 8029f9a:	fa03 f000 	lsl.w	r0, r3, r0
 8029f9e:	2900      	cmp	r1, #0
 8029fa0:	6065      	str	r5, [r4, #4]
 8029fa2:	6050      	str	r0, [r2, #4]
 8029fa4:	db44      	blt.n	802a030 <CCU41_1_IRQHandler+0x1cc>
 8029fa6:	4925      	ldr	r1, [pc, #148]	; (802a03c <CCU41_1_IRQHandler+0x1d8>)
 8029fa8:	4a25      	ldr	r2, [pc, #148]	; (802a040 <CCU41_1_IRQHandler+0x1dc>)
 8029faa:	7c08      	ldrb	r0, [r1, #16]
 8029fac:	7c14      	ldrb	r4, [r2, #16]
 8029fae:	6809      	ldr	r1, [r1, #0]
 8029fb0:	6812      	ldr	r2, [r2, #0]
 8029fb2:	fa03 f000 	lsl.w	r0, r3, r0
 8029fb6:	40a3      	lsls	r3, r4
 8029fb8:	6048      	str	r0, [r1, #4]
 8029fba:	6053      	str	r3, [r2, #4]

		bsp_timer_start(&TIMER_PTAT_S_H_DELAY);

		bsp_trigger_new_frame();
	}
}
 8029fbc:	b003      	add	sp, #12
 8029fbe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8029fc2:	4a1e      	ldr	r2, [pc, #120]	; (802a03c <CCU41_1_IRQHandler+0x1d8>)
 8029fc4:	4b1e      	ldr	r3, [pc, #120]	; (802a040 <CCU41_1_IRQHandler+0x1dc>)
 8029fc6:	7c14      	ldrb	r4, [r2, #16]
 8029fc8:	7c1d      	ldrb	r5, [r3, #16]
 8029fca:	6811      	ldr	r1, [r2, #0]
 8029fcc:	681a      	ldr	r2, [r3, #0]

TIMER_STATUS_t bsp_timer_start(TIMER_t *const handle_timer)
{
	TIMER_STATUS_t status;

	status = TIMER_Start(handle_timer);
 8029fce:	482a      	ldr	r0, [pc, #168]	; (802a078 <CCU41_1_IRQHandler+0x214>)
 8029fd0:	2301      	movs	r3, #1
 8029fd2:	fa03 f404 	lsl.w	r4, r3, r4
 8029fd6:	40ab      	lsls	r3, r5
 8029fd8:	604c      	str	r4, [r1, #4]
 8029fda:	6053      	str	r3, [r2, #4]
 8029fdc:	604c      	str	r4, [r1, #4]
 8029fde:	6053      	str	r3, [r2, #4]

		bsp_timer_start(&TIMER_PTAT_S_H_DELAY);

		bsp_trigger_new_frame();
	}
}
 8029fe0:	b003      	add	sp, #12
 8029fe2:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

TIMER_STATUS_t bsp_timer_start(TIMER_t *const handle_timer)
{
	TIMER_STATUS_t status;

	status = TIMER_Start(handle_timer);
 8029fe6:	f7fb bf4b 	b.w	8025e80 <TIMER_Start>
 8029fea:	4823      	ldr	r0, [pc, #140]	; (802a078 <CCU41_1_IRQHandler+0x214>)
 8029fec:	f7fb ff48 	bl	8025e80 <TIMER_Start>
 8029ff0:	e758      	b.n	8029ea4 <CCU41_1_IRQHandler+0x40>
 8029ff2:	4913      	ldr	r1, [pc, #76]	; (802a040 <CCU41_1_IRQHandler+0x1dc>)
 8029ff4:	4a13      	ldr	r2, [pc, #76]	; (802a044 <CCU41_1_IRQHandler+0x1e0>)
 8029ff6:	4b14      	ldr	r3, [pc, #80]	; (802a048 <CCU41_1_IRQHandler+0x1e4>)
 8029ff8:	4810      	ldr	r0, [pc, #64]	; (802a03c <CCU41_1_IRQHandler+0x1d8>)
 8029ffa:	7c0e      	ldrb	r6, [r1, #16]
 8029ffc:	7c07      	ldrb	r7, [r0, #16]
 8029ffe:	7c15      	ldrb	r5, [r2, #16]
 802a000:	f893 e010 	ldrb.w	lr, [r3, #16]
 802a004:	680c      	ldr	r4, [r1, #0]
 802a006:	6800      	ldr	r0, [r0, #0]
 802a008:	6811      	ldr	r1, [r2, #0]
 802a00a:	681a      	ldr	r2, [r3, #0]
 802a00c:	2301      	movs	r3, #1
 802a00e:	fa03 f707 	lsl.w	r7, r3, r7
 802a012:	fa03 f606 	lsl.w	r6, r3, r6
 802a016:	fa03 f505 	lsl.w	r5, r3, r5
 802a01a:	fa03 f30e 	lsl.w	r3, r3, lr
 802a01e:	6047      	str	r7, [r0, #4]
 802a020:	6066      	str	r6, [r4, #4]
 802a022:	604d      	str	r5, [r1, #4]
 802a024:	6053      	str	r3, [r2, #4]

		bsp_timer_start(&TIMER_PTAT_S_H_DELAY);

		bsp_trigger_new_frame();
	}
}
 802a026:	b003      	add	sp, #12
 802a028:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		DIGITAL_IO_SetOutputHigh(&DIGITAL_IO_BGT_VCC_PTAT);

		/* ensure V_PTAT_SH_EN is enabled */
		DIGITAL_IO_SetOutputHigh(&DIGITAL_IO_V_PTAT_SH_EN);

		bsp_trigger_new_frame();
 802a02c:	f7ff bcaa 	b.w	8029984 <bsp_trigger_new_frame>

TIMER_STATUS_t bsp_timer_start(TIMER_t *const handle_timer)
{
	TIMER_STATUS_t status;

	status = TIMER_Start(handle_timer);
 802a030:	4811      	ldr	r0, [pc, #68]	; (802a078 <CCU41_1_IRQHandler+0x214>)
 802a032:	e7d5      	b.n	8029fe0 <CCU41_1_IRQHandler+0x17c>
 802a034:	1ffe95fc 	.word	0x1ffe95fc
 802a038:	1ffeb4ac 	.word	0x1ffeb4ac
 802a03c:	0802f844 	.word	0x0802f844
 802a040:	0802f858 	.word	0x0802f858
 802a044:	0802f86c 	.word	0x0802f86c
 802a048:	0802f8f8 	.word	0x0802f8f8
 802a04c:	1ffe93c0 	.word	0x1ffe93c0
 802a050:	1ffe91b0 	.word	0x1ffe91b0
 802a054:	1ffe93d0 	.word	0x1ffe93d0
 802a058:	1ffe93e0 	.word	0x1ffe93e0
 802a05c:	1ffe93f0 	.word	0x1ffe93f0
 802a060:	1ffeb49c 	.word	0x1ffeb49c
 802a064:	1ffe9228 	.word	0x1ffe9228
 802a068:	1ffedc0c 	.word	0x1ffedc0c
 802a06c:	1ffeb4a0 	.word	0x1ffeb4a0
 802a070:	1ffeb4a8 	.word	0x1ffeb4a8
 802a074:	1ffe9120 	.word	0x1ffe9120
 802a078:	1ffe9158 	.word	0x1ffe9158

0802a07c <bsp_reset_frame_counter>:

//============================================================================

void bsp_reset_frame_counter(void)
{
	bsp_frame_counter = 0;
 802a07c:	4b01      	ldr	r3, [pc, #4]	; (802a084 <bsp_reset_frame_counter+0x8>)
 802a07e:	2200      	movs	r2, #0
 802a080:	601a      	str	r2, [r3, #0]
 802a082:	4770      	bx	lr
 802a084:	1ffeb4a4 	.word	0x1ffeb4a4

0802a088 <bsp_register_callback>:
uint8_t bsp_register_callback(Bsp_Callback_ID_t cb_id, void (*pcallback)(void *parameter))
{
	uint8_t status = 0;

	/* Check if he callback function is valid */
	if (pcallback == NULL)
 802a088:	b139      	cbz	r1, 802a09a <bsp_register_callback+0x12>
	{
		return (1);
	}

	/* Register user callback function based on callback ID */
	switch (cb_id)
 802a08a:	2801      	cmp	r0, #1
 802a08c:	d007      	beq.n	802a09e <bsp_register_callback+0x16>
 802a08e:	2802      	cmp	r0, #2
 802a090:	d103      	bne.n	802a09a <bsp_register_callback+0x12>
	case BSP_ACQUISITION_STARTED_CB_ID:
		bsp_cb.bsp_acq_started_cb = pcallback;
		break;

	case BSP_ACQUISITION_DONE_CB_ID:
		bsp_cb.bsp_acq_done_cb = pcallback;
 802a092:	4b05      	ldr	r3, [pc, #20]	; (802a0a8 <bsp_register_callback+0x20>)

//============================================================================

uint8_t bsp_register_callback(Bsp_Callback_ID_t cb_id, void (*pcallback)(void *parameter))
{
	uint8_t status = 0;
 802a094:	2000      	movs	r0, #0
	case BSP_ACQUISITION_STARTED_CB_ID:
		bsp_cb.bsp_acq_started_cb = pcallback;
		break;

	case BSP_ACQUISITION_DONE_CB_ID:
		bsp_cb.bsp_acq_done_cb = pcallback;
 802a096:	6059      	str	r1, [r3, #4]
		break;
 802a098:	4770      	bx	lr

	default:
		/* Return error status */
		status = 1;
 802a09a:	2001      	movs	r0, #1
		break;
	}

	return (status);
}
 802a09c:	4770      	bx	lr

	/* Register user callback function based on callback ID */
	switch (cb_id)
	{
	case BSP_ACQUISITION_STARTED_CB_ID:
		bsp_cb.bsp_acq_started_cb = pcallback;
 802a09e:	4b02      	ldr	r3, [pc, #8]	; (802a0a8 <bsp_register_callback+0x20>)

//============================================================================

uint8_t bsp_register_callback(Bsp_Callback_ID_t cb_id, void (*pcallback)(void *parameter))
{
	uint8_t status = 0;
 802a0a0:	2000      	movs	r0, #0

	/* Register user callback function based on callback ID */
	switch (cb_id)
	{
	case BSP_ACQUISITION_STARTED_CB_ID:
		bsp_cb.bsp_acq_started_cb = pcallback;
 802a0a2:	6019      	str	r1, [r3, #0]
		break;
 802a0a4:	4770      	bx	lr
 802a0a6:	bf00      	nop
 802a0a8:	1ffedc0c 	.word	0x1ffedc0c

0802a0ac <bsp_start_frame_intervall_timer>:
}

//============================================================================

uint32_t bsp_start_frame_intervall_timer(uint32_t frame_interval_usec)
{
 802a0ac:	b508      	push	{r3, lr}

	/* Update time period of Automatic Trigger */
	if (TIMER_SetTimeInterval(&TIMER_FRAME_TRIG, frame_interval_usec * 100U) != TIMER_STATUS_SUCCESS)
 802a0ae:	2164      	movs	r1, #100	; 0x64
 802a0b0:	fb01 f100 	mul.w	r1, r1, r0
 802a0b4:	4803      	ldr	r0, [pc, #12]	; (802a0c4 <bsp_start_frame_intervall_timer+0x18>)
 802a0b6:	f7fb ff07 	bl	8025ec8 <TIMER_SetTimeInterval>
	{
		return 0;
	}
	return 1;
}
 802a0ba:	fab0 f080 	clz	r0, r0
 802a0be:	0940      	lsrs	r0, r0, #5
 802a0c0:	bd08      	pop	{r3, pc}
 802a0c2:	bf00      	nop
 802a0c4:	1ffe9200 	.word	0x1ffe9200

0802a0c8 <bsp_calc_min_frame_interval_usec>:

//============================================================================

uint32_t bsp_calc_min_frame_interval_usec(device_settings_t *p_dev)
{
	uint32_t min_frame_interval_usec = p_dev->num_of_chirps_per_frame * (((p_dev->num_samples_per_chirp + p_dev->num_sample_skip_count) * 1000U * 1000U) / p_dev->adc_sampling_freq_Hz); // units in us
 802a0c8:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 802a0ca:	6a41      	ldr	r1, [r0, #36]	; 0x24
 802a0cc:	4a06      	ldr	r2, [pc, #24]	; (802a0e8 <bsp_calc_min_frame_interval_usec+0x20>)
}

//============================================================================

uint32_t bsp_calc_min_frame_interval_usec(device_settings_t *p_dev)
{
 802a0ce:	b410      	push	{r4}
	uint32_t min_frame_interval_usec = p_dev->num_of_chirps_per_frame * (((p_dev->num_samples_per_chirp + p_dev->num_sample_skip_count) * 1000U * 1000U) / p_dev->adc_sampling_freq_Hz); // units in us
 802a0d0:	69c4      	ldr	r4, [r0, #28]
 802a0d2:	6940      	ldr	r0, [r0, #20]
 802a0d4:	440b      	add	r3, r1
 802a0d6:	fb02 f303 	mul.w	r3, r2, r3
 802a0da:	fbb3 f0f0 	udiv	r0, r3, r0

	return min_frame_interval_usec;
}
 802a0de:	fb04 f000 	mul.w	r0, r4, r0
 802a0e2:	f85d 4b04 	ldr.w	r4, [sp], #4
 802a0e6:	4770      	bx	lr
 802a0e8:	000f4240 	.word	0x000f4240

0802a0ec <bsp_set_ptat_switch_status>:

//============================================================================

void bsp_set_ptat_switch_status(uint32_t new_status, uint32_t new_delay_usec)
{
	ptat_switching_status  = new_status;
 802a0ec:	4a02      	ldr	r2, [pc, #8]	; (802a0f8 <bsp_set_ptat_switch_status+0xc>)
	ptat_switch_delay_usec = new_delay_usec;
 802a0ee:	4b03      	ldr	r3, [pc, #12]	; (802a0fc <bsp_set_ptat_switch_status+0x10>)

//============================================================================

void bsp_set_ptat_switch_status(uint32_t new_status, uint32_t new_delay_usec)
{
	ptat_switching_status  = new_status;
 802a0f0:	6010      	str	r0, [r2, #0]
	ptat_switch_delay_usec = new_delay_usec;
 802a0f2:	6019      	str	r1, [r3, #0]
 802a0f4:	4770      	bx	lr
 802a0f6:	bf00      	nop
 802a0f8:	1ffeb4ac 	.word	0x1ffeb4ac
 802a0fc:	1ffeb4a8 	.word	0x1ffeb4a8

0802a100 <bsp_usb_init>:
    6. EXPORTED FUNCTIONS
==============================================================================
 */

uint8_t bsp_usb_init(uint32_t timeout_delay)
{
 802a100:	b538      	push	{r3, r4, r5, lr}
 802a102:	4605      	mov	r5, r0
	uint32_t timeout_cnt = 0;

	if (USBD_VCOM_Connect() != USBD_VCOM_STATUS_SUCCESS)
 802a104:	f7fa ffa4 	bl	8025050 <USBD_VCOM_Connect>
 802a108:	b958      	cbnz	r0, 802a122 <bsp_usb_init+0x22>
	{
		return (1); /* Fail */
	}

	while (timeout_cnt < timeout_delay)
 802a10a:	b155      	cbz	r5, 802a122 <bsp_usb_init+0x22>
 802a10c:	4604      	mov	r4, r0
 802a10e:	e001      	b.n	802a114 <bsp_usb_init+0x14>
 802a110:	42ac      	cmp	r4, r5
 802a112:	d006      	beq.n	802a122 <bsp_usb_init+0x22>
	{
		if (USBD_VCOM_IsEnumDone())
 802a114:	f7fa ff3c 	bl	8024f90 <USBD_VCOM_IsEnumDone>
		{
			return (0); /* Success */
		}

		timeout_cnt++;
 802a118:	3401      	adds	r4, #1
		return (1); /* Fail */
	}

	while (timeout_cnt < timeout_delay)
	{
		if (USBD_VCOM_IsEnumDone())
 802a11a:	2800      	cmp	r0, #0
 802a11c:	d0f8      	beq.n	802a110 <bsp_usb_init+0x10>
		{
			return (0); /* Success */
 802a11e:	2000      	movs	r0, #0

		timeout_cnt++;
	}

	return (1); /* Fail */
}
 802a120:	bd38      	pop	{r3, r4, r5, pc}
{
	uint32_t timeout_cnt = 0;

	if (USBD_VCOM_Connect() != USBD_VCOM_STATUS_SUCCESS)
	{
		return (1); /* Fail */
 802a122:	2001      	movs	r0, #1
 802a124:	bd38      	pop	{r3, r4, r5, pc}
 802a126:	bf00      	nop

0802a128 <app_data_acq_started_cb>:
/* This callback function will be executed by radar control when starting data acquisition process
 *   it can be used to get information about the beginning of data acquisition
 */
void app_data_acq_started_cb(void *parameter)
{
	acq_started += 1;
 802a128:	4a02      	ldr	r2, [pc, #8]	; (802a134 <app_data_acq_started_cb+0xc>)
 802a12a:	6813      	ldr	r3, [r2, #0]
 802a12c:	3301      	adds	r3, #1
 802a12e:	6013      	str	r3, [r2, #0]
 802a130:	4770      	bx	lr
 802a132:	bf00      	nop
 802a134:	1ffedc4c 	.word	0x1ffedc4c

0802a138 <system_reset>:

//============================================================================

/* This function yet to be filled in case of software reset */
void system_reset(void)
{
 802a138:	4770      	bx	lr
 802a13a:	bf00      	nop

0802a13c <app_data_acq_done_cb>:
/* This callback function will be executed by radar control at the end of data acquisition,
 * it is used to inform upper layers that data sampling is done and data is ready in user buffer
 */
void app_data_acq_done_cb(void *parameter)
{
	acq_completed += 1;
 802a13c:	4a02      	ldr	r2, [pc, #8]	; (802a148 <app_data_acq_done_cb+0xc>)
 802a13e:	6813      	ldr	r3, [r2, #0]
 802a140:	3301      	adds	r3, #1
 802a142:	6013      	str	r3, [r2, #0]
	acq_completed_cb();
 802a144:	f000 bc0c 	b.w	802a960 <acq_completed_cb>
 802a148:	1ffedc40 	.word	0x1ffedc40

0802a14c <app_init>:
==============================================================================
 */

/* Initialize all firmware and algorithm parameters and start communication protocol */
void app_init(void)
{
 802a14c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  /* Initialize USB */
  if (bsp_usb_init(BSP_USB_TIMEOUT) == 0)
 802a150:	f640 70ff 	movw	r0, #4095	; 0xfff
==============================================================================
 */

/* Initialize all firmware and algorithm parameters and start communication protocol */
void app_init(void)
{
 802a154:	b09d      	sub	sp, #116	; 0x74
  /* Initialize USB */
  if (bsp_usb_init(BSP_USB_TIMEOUT) == 0)
 802a156:	f7ff ffd3 	bl	802a100 <bsp_usb_init>
 802a15a:	b910      	cbnz	r0, 802a162 <app_init+0x16>
  {
    g_usb_init = true;
 802a15c:	4b34      	ldr	r3, [pc, #208]	; (802a230 <app_init+0xe4>)
 802a15e:	2201      	movs	r2, #1
 802a160:	701a      	strb	r2, [r3, #0]
  }

  /* Register all endpoints to the communication protocol */
  Endpoint_t ep_list[NUMBER_SUPPORTED_ENDPOINTS] =
 802a162:	4d34      	ldr	r5, [pc, #208]	; (802a234 <app_init+0xe8>)
  {
    EP_RADAR_MCUBASE_LIST_ENTRY(h_radar_device),
  	EP_RADAR_DEVICE_STATUS_LIST_ENTRY(h_radar_device)
  };

  app_initalized = 0;
 802a164:	4e34      	ldr	r6, [pc, #208]	; (802a238 <app_init+0xec>)
  {
    g_usb_init = true;
  }

  /* Register all endpoints to the communication protocol */
  Endpoint_t ep_list[NUMBER_SUPPORTED_ENDPOINTS] =
 802a166:	6828      	ldr	r0, [r5, #0]
 802a168:	f8df 80f0 	ldr.w	r8, [pc, #240]	; 802a25c <app_init+0x110>
 802a16c:	f8df c0f0 	ldr.w	ip, [pc, #240]	; 802a260 <app_init+0x114>
 802a170:	f8df e0f0 	ldr.w	lr, [pc, #240]	; 802a264 <app_init+0x118>
 802a174:	4f31      	ldr	r7, [pc, #196]	; (802a23c <app_init+0xf0>)
 802a176:	4a32      	ldr	r2, [pc, #200]	; (802a240 <app_init+0xf4>)
 802a178:	4b32      	ldr	r3, [pc, #200]	; (802a244 <app_init+0xf8>)
 802a17a:	f8df b0ec 	ldr.w	fp, [pc, #236]	; 802a268 <app_init+0x11c>
 802a17e:	f8df a0ec 	ldr.w	sl, [pc, #236]	; 802a26c <app_init+0x120>
 802a182:	f8df 90ec 	ldr.w	r9, [pc, #236]	; 802a270 <app_init+0x124>
 802a186:	9010      	str	r0, [sp, #64]	; 0x40
  {
    EP_RADAR_MCUBASE_LIST_ENTRY(h_radar_device),
  	EP_RADAR_DEVICE_STATUS_LIST_ENTRY(h_radar_device)
  };

  app_initalized = 0;
 802a188:	2400      	movs	r4, #0
  {
    g_usb_init = true;
  }

  /* Register all endpoints to the communication protocol */
  Endpoint_t ep_list[NUMBER_SUPPORTED_ENDPOINTS] =
 802a18a:	9015      	str	r0, [sp, #84]	; 0x54
 802a18c:	901a      	str	r0, [sp, #104]	; 0x68
	EP_RADAR_S2GLPULSE_LIST_ENTRY(h_radar_device),
  	EP_RADAR_DEVICE_STATUS_LIST_ENTRY(h_radar_device)
  };

  /* Register all endpoints in case of init error to the communication protocol */
  Endpoint_t ep_err_list[2] =
 802a18e:	9006      	str	r0, [sp, #24]
 802a190:	900b      	str	r0, [sp, #44]	; 0x2c
  {
    EP_RADAR_MCUBASE_LIST_ENTRY(h_radar_device),
  	EP_RADAR_DEVICE_STATUS_LIST_ENTRY(h_radar_device)
  };

  app_initalized = 0;
 802a192:	6034      	str	r4, [r6, #0]
  uint8_t num_of_ep = sizeof(ep_err_list)/sizeof(ep_err_list[0]);
  Endpoint_t *pEndPoints = &ep_err_list[0];

  /* Open the available radar device */
  if (radar_open_device(0, &h_radar_device) == RADAR_ERR_OK)
 802a194:	4620      	mov	r0, r4
 802a196:	4629      	mov	r1, r5
  {
    g_usb_init = true;
  }

  /* Register all endpoints to the communication protocol */
  Endpoint_t ep_list[NUMBER_SUPPORTED_ENDPOINTS] =
 802a198:	2401      	movs	r4, #1
 802a19a:	f8cd 8034 	str.w	r8, [sp, #52]	; 0x34
	EP_RADAR_S2GLPULSE_LIST_ENTRY(h_radar_device),
  	EP_RADAR_DEVICE_STATUS_LIST_ENTRY(h_radar_device)
  };

  /* Register all endpoints in case of init error to the communication protocol */
  Endpoint_t ep_err_list[2] =
 802a19e:	f8cd 800c 	str.w	r8, [sp, #12]
  {
    g_usb_init = true;
  }

  /* Register all endpoints to the communication protocol */
  Endpoint_t ep_list[NUMBER_SUPPORTED_ENDPOINTS] =
 802a1a2:	f8ad 4038 	strh.w	r4, [sp, #56]	; 0x38
 802a1a6:	f8ad 404c 	strh.w	r4, [sp, #76]	; 0x4c
 802a1aa:	f8ad 4060 	strh.w	r4, [sp, #96]	; 0x60
	EP_RADAR_S2GLPULSE_LIST_ENTRY(h_radar_device),
  	EP_RADAR_DEVICE_STATUS_LIST_ENTRY(h_radar_device)
  };

  /* Register all endpoints in case of init error to the communication protocol */
  Endpoint_t ep_err_list[2] =
 802a1ae:	f8ad 4010 	strh.w	r4, [sp, #16]
 802a1b2:	f8ad 4024 	strh.w	r4, [sp, #36]	; 0x24
  {
    g_usb_init = true;
  }

  /* Register all endpoints to the communication protocol */
  Endpoint_t ep_list[NUMBER_SUPPORTED_ENDPOINTS] =
 802a1b6:	f8cd c03c 	str.w	ip, [sp, #60]	; 0x3c
	EP_RADAR_S2GLPULSE_LIST_ENTRY(h_radar_device),
  	EP_RADAR_DEVICE_STATUS_LIST_ENTRY(h_radar_device)
  };

  /* Register all endpoints in case of init error to the communication protocol */
  Endpoint_t ep_err_list[2] =
 802a1ba:	f8cd c014 	str.w	ip, [sp, #20]
  {
    g_usb_init = true;
  }

  /* Register all endpoints to the communication protocol */
  Endpoint_t ep_list[NUMBER_SUPPORTED_ENDPOINTS] =
 802a1be:	f8cd e044 	str.w	lr, [sp, #68]	; 0x44
	EP_RADAR_S2GLPULSE_LIST_ENTRY(h_radar_device),
  	EP_RADAR_DEVICE_STATUS_LIST_ENTRY(h_radar_device)
  };

  /* Register all endpoints in case of init error to the communication protocol */
  Endpoint_t ep_err_list[2] =
 802a1c2:	f8cd e01c 	str.w	lr, [sp, #28]
  {
    g_usb_init = true;
  }

  /* Register all endpoints to the communication protocol */
  Endpoint_t ep_list[NUMBER_SUPPORTED_ENDPOINTS] =
 802a1c6:	f8cd b048 	str.w	fp, [sp, #72]	; 0x48
 802a1ca:	f8cd a050 	str.w	sl, [sp, #80]	; 0x50
 802a1ce:	f8cd 9058 	str.w	r9, [sp, #88]	; 0x58
 802a1d2:	9717      	str	r7, [sp, #92]	; 0x5c
	EP_RADAR_S2GLPULSE_LIST_ENTRY(h_radar_device),
  	EP_RADAR_DEVICE_STATUS_LIST_ENTRY(h_radar_device)
  };

  /* Register all endpoints in case of init error to the communication protocol */
  Endpoint_t ep_err_list[2] =
 802a1d4:	9708      	str	r7, [sp, #32]
  {
    g_usb_init = true;
  }

  /* Register all endpoints to the communication protocol */
  Endpoint_t ep_list[NUMBER_SUPPORTED_ENDPOINTS] =
 802a1d6:	9219      	str	r2, [sp, #100]	; 0x64
	EP_RADAR_S2GLPULSE_LIST_ENTRY(h_radar_device),
  	EP_RADAR_DEVICE_STATUS_LIST_ENTRY(h_radar_device)
  };

  /* Register all endpoints in case of init error to the communication protocol */
  Endpoint_t ep_err_list[2] =
 802a1d8:	920a      	str	r2, [sp, #40]	; 0x28
  {
    g_usb_init = true;
  }

  /* Register all endpoints to the communication protocol */
  Endpoint_t ep_list[NUMBER_SUPPORTED_ENDPOINTS] =
 802a1da:	931b      	str	r3, [sp, #108]	; 0x6c
	EP_RADAR_S2GLPULSE_LIST_ENTRY(h_radar_device),
  	EP_RADAR_DEVICE_STATUS_LIST_ENTRY(h_radar_device)
  };

  /* Register all endpoints in case of init error to the communication protocol */
  Endpoint_t ep_err_list[2] =
 802a1dc:	930c      	str	r3, [sp, #48]	; 0x30
  app_initalized = 0;
  uint8_t num_of_ep = sizeof(ep_err_list)/sizeof(ep_err_list[0]);
  Endpoint_t *pEndPoints = &ep_err_list[0];

  /* Open the available radar device */
  if (radar_open_device(0, &h_radar_device) == RADAR_ERR_OK)
 802a1de:	f7f6 fba7 	bl	8020930 <radar_open_device>
 802a1e2:	b1c0      	cbz	r0, 802a216 <app_init+0xca>
 802a1e4:	2228      	movs	r2, #40	; 0x28
  	EP_RADAR_DEVICE_STATUS_LIST_ENTRY(h_radar_device)
  };

  app_initalized = 0;
  uint8_t num_of_ep = sizeof(ep_err_list)/sizeof(ep_err_list[0]);
  Endpoint_t *pEndPoints = &ep_err_list[0];
 802a1e6:	a903      	add	r1, sp, #12
    EP_RADAR_MCUBASE_LIST_ENTRY(h_radar_device),
  	EP_RADAR_DEVICE_STATUS_LIST_ENTRY(h_radar_device)
  };

  app_initalized = 0;
  uint8_t num_of_ep = sizeof(ep_err_list)/sizeof(ep_err_list[0]);
 802a1e8:	2402      	movs	r4, #2
	  radar_register_callback(RADAR_ACQUISITION_DONE_CB_ID, app_data_acq_done_cb);

	  num_of_ep = sizeof(ep_list)/sizeof(ep_list[0]);
	  pEndPoints = &ep_list[0];
  }
  memcpy(endpoint_list, pEndPoints, num_of_ep * sizeof(Endpoint_t));
 802a1ea:	4817      	ldr	r0, [pc, #92]	; (802a248 <app_init+0xfc>)
 802a1ec:	f003 f9b0 	bl	802d550 <memcpy>

  /* Initialize the internal protocol state and the communication interface */
  protocol_init(endpoint_list, num_of_ep, NULL, BSP_HOST_TIMEOUT_USEC, system_reset);
 802a1f0:	4b16      	ldr	r3, [pc, #88]	; (802a24c <app_init+0x100>)
 802a1f2:	9300      	str	r3, [sp, #0]
 802a1f4:	4621      	mov	r1, r4
 802a1f6:	4b16      	ldr	r3, [pc, #88]	; (802a250 <app_init+0x104>)
 802a1f8:	4813      	ldr	r0, [pc, #76]	; (802a248 <app_init+0xfc>)
 802a1fa:	2200      	movs	r2, #0
 802a1fc:	f7fa f90e 	bl	802441c <protocol_init>

  /* Initialize the internal protocol state and the communication interface */
  if (app_initalized)
 802a200:	6833      	ldr	r3, [r6, #0]
 802a202:	b913      	cbnz	r3, 802a20a <app_init+0xbe>
	  {
		XMC_DEBUG("Starting Radar data acquisition failed\n");
		while (1U);
	  }
  }
}
 802a204:	b01d      	add	sp, #116	; 0x74
 802a206:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

  /* Initialize the internal protocol state and the communication interface */
  if (app_initalized)
  {
	  /* Start data acquisition at the defined frame interval */
	  if (radar_start_acquisition(h_radar_device) != RADAR_ERR_OK)
 802a20a:	6828      	ldr	r0, [r5, #0]
 802a20c:	f7f6 fc7e 	bl	8020b0c <radar_start_acquisition>
 802a210:	2800      	cmp	r0, #0
 802a212:	d0f7      	beq.n	802a204 <app_init+0xb8>
	  {
		XMC_DEBUG("Starting Radar data acquisition failed\n");
		while (1U);
 802a214:	e7fe      	b.n	802a214 <app_init+0xc8>
  /* Open the available radar device */
  if (radar_open_device(0, &h_radar_device) == RADAR_ERR_OK)
  {
	  app_initalized = 1;
	  /* Register user callback functions */
	  radar_register_callback(RADAR_ACQUISITION_STARTED_CB_ID, app_data_acq_started_cb);
 802a216:	4620      	mov	r0, r4
 802a218:	490e      	ldr	r1, [pc, #56]	; (802a254 <app_init+0x108>)
  Endpoint_t *pEndPoints = &ep_err_list[0];

  /* Open the available radar device */
  if (radar_open_device(0, &h_radar_device) == RADAR_ERR_OK)
  {
	  app_initalized = 1;
 802a21a:	6034      	str	r4, [r6, #0]
	  /* Register user callback functions */
	  radar_register_callback(RADAR_ACQUISITION_STARTED_CB_ID, app_data_acq_started_cb);
 802a21c:	f7f6 fc86 	bl	8020b2c <radar_register_callback>
	  radar_register_callback(RADAR_ACQUISITION_DONE_CB_ID, app_data_acq_done_cb);
 802a220:	490d      	ldr	r1, [pc, #52]	; (802a258 <app_init+0x10c>)
 802a222:	2002      	movs	r0, #2
 802a224:	f7f6 fc82 	bl	8020b2c <radar_register_callback>

	  num_of_ep = sizeof(ep_list)/sizeof(ep_list[0]);
 802a228:	2403      	movs	r4, #3
  if (radar_open_device(0, &h_radar_device) == RADAR_ERR_OK)
  {
	  app_initalized = 1;
	  /* Register user callback functions */
	  radar_register_callback(RADAR_ACQUISITION_STARTED_CB_ID, app_data_acq_started_cb);
	  radar_register_callback(RADAR_ACQUISITION_DONE_CB_ID, app_data_acq_done_cb);
 802a22a:	223c      	movs	r2, #60	; 0x3c

	  num_of_ep = sizeof(ep_list)/sizeof(ep_list[0]);
	  pEndPoints = &ep_list[0];
 802a22c:	a90d      	add	r1, sp, #52	; 0x34
 802a22e:	e7dc      	b.n	802a1ea <app_init+0x9e>
 802a230:	1ffedc14 	.word	0x1ffedc14
 802a234:	1ffedc48 	.word	0x1ffedc48
 802a238:	1ffedc50 	.word	0x1ffedc50
 802a23c:	44455653 	.word	0x44455653
 802a240:	08023a1d 	.word	0x08023a1d
 802a244:	08023a41 	.word	0x08023a41
 802a248:	1fff06f4 	.word	0x1fff06f4
 802a24c:	0802a139 	.word	0x0802a139
 802a250:	00989680 	.word	0x00989680
 802a254:	0802a129 	.word	0x0802a129
 802a258:	0802a13d 	.word	0x0802a13d
 802a25c:	544a4241 	.word	0x544a4241
 802a260:	08023b0d 	.word	0x08023b0d
 802a264:	08023c91 	.word	0x08023c91
 802a268:	544a5055 	.word	0x544a5055
 802a26c:	08023f8d 	.word	0x08023f8d
 802a270:	080243ad 	.word	0x080243ad

0802a274 <app_register_algo_process>:

/* Register algorithm processing function */
void app_register_algo_process(algorithm algo_processor)
{
  /* Register algo processing function */
  algo_processing_function = algo_processor;
 802a274:	4b01      	ldr	r3, [pc, #4]	; (802a27c <app_register_algo_process+0x8>)
 802a276:	6018      	str	r0, [r3, #0]
 802a278:	4770      	bx	lr
 802a27a:	bf00      	nop
 802a27c:	1ffedc44 	.word	0x1ffedc44

0802a280 <calcCurrentConsumption_mA>:
float calcCurrentConsumption_mA(device_settings_t *pDev)
{
	float retval = 0.0F;
	extern bool pwm_bgt_enabled;

	if (!pwm_bgt_enabled)
 802a280:	4b5b      	ldr	r3, [pc, #364]	; (802a3f0 <calcCurrentConsumption_mA+0x170>)
 802a282:	781b      	ldrb	r3, [r3, #0]
 802a284:	b923      	cbnz	r3, 802a290 <calcCurrentConsumption_mA+0x10>
		return 0.0F; /* invalid! */
 802a286:	eddf 7a5b 	vldr	s15, [pc, #364]	; 802a3f4 <calcCurrentConsumption_mA+0x174>

		retval = (bgt_duty_cycle * bgt_on_current_mA) + (ptat_duty_cycle * ptat_on_current_mA) + (bbf_duty_cycle * bbf_on_current_mA);
	}

	return retval;
}
 802a28a:	ee17 0a90 	vmov	r0, s15
 802a28e:	4770      	bx	lr
}

//============================================================================

float calcCurrentConsumption_mA(device_settings_t *pDev)
{
 802a290:	b510      	push	{r4, lr}
 802a292:	4604      	mov	r4, r0
	extern bool pwm_bgt_enabled;

	if (!pwm_bgt_enabled)
		return 0.0F; /* invalid! */

	if (ds_get_board_variant() == 1)
 802a294:	f7f5 feb4 	bl	8020000 <ds_get_board_variant>
 802a298:	2801      	cmp	r0, #1
 802a29a:	d063      	beq.n	802a364 <calcCurrentConsumption_mA+0xe4>
	{
		float bgt_on_current_mA   = BSP_BGT_ON_CURRENT_mA;
		float ptat_on_current_mA  = BSP_PTAT_ON_CURRENT_mA;
		float bbf_on_current_mA   = BSP_BBF_ON_CURRENT_mA;

		float f_sample            = (float)pDev->adc_sampling_freq_Hz;
 802a29c:	edd4 3a05 	vldr	s7, [r4, #20]
		float frame_period_sec    = (float)pDev->frame_period_usec / 1000000.0F;
		float pulse_width_sec     = (float)pDev->pulse_width_usec / 1000000.0F;
		float skipped_samples     = (float)pDev->num_sample_skip_count;
		float samples             = (float)pDev->num_samples_per_chirp;
 802a2a0:	edd4 6a09 	vldr	s13, [r4, #36]	; 0x24
		float bgt_on_current_mA   = BSP_BGT_ON_CURRENT_mA;
		float ptat_on_current_mA  = BSP_PTAT_ON_CURRENT_mA;
		float bbf_on_current_mA   = BSP_BBF_ON_CURRENT_mA;

		float f_sample            = (float)pDev->adc_sampling_freq_Hz;
		float frame_period_sec    = (float)pDev->frame_period_usec / 1000000.0F;
 802a2a4:	ed94 7a08 	vldr	s14, [r4, #32]
 802a2a8:	ed9f 3a53 	vldr	s6, [pc, #332]	; 802a3f8 <calcCurrentConsumption_mA+0x178>
		float ptat_pulse_time_sec = (float)PTAT_S_H_PULSE_WIDTH_USEC / 1000000.0F;
		float bbf_advance_sec     = (float)BB_PRE_TRIGGER_ADVANCE_USEC / 1000000.0F;

		float total_samples       = (skipped_samples + samples);

		if (fabs(samples / f_sample - frame_period_sec) < 0.001F) // equidistant mode
 802a2ac:	eddf 7a53 	vldr	s15, [pc, #332]	; 802a3fc <calcCurrentConsumption_mA+0x17c>
		float f_sample            = (float)pDev->adc_sampling_freq_Hz;
		float frame_period_sec    = (float)pDev->frame_period_usec / 1000000.0F;
		float pulse_width_sec     = (float)pDev->pulse_width_usec / 1000000.0F;
		float skipped_samples     = (float)pDev->num_sample_skip_count;
		float samples             = (float)pDev->num_samples_per_chirp;
		float ptat_delay_sec      = (float)pDev->ptat_delay_usec / 1000000.0F;
 802a2b0:	6be3      	ldr	r3, [r4, #60]	; 0x3c
		float bbf_on_current_mA   = BSP_BBF_ON_CURRENT_mA;

		float f_sample            = (float)pDev->adc_sampling_freq_Hz;
		float frame_period_sec    = (float)pDev->frame_period_usec / 1000000.0F;
		float pulse_width_sec     = (float)pDev->pulse_width_usec / 1000000.0F;
		float skipped_samples     = (float)pDev->num_sample_skip_count;
 802a2b2:	edd4 5a0b 	vldr	s11, [r4, #44]	; 0x2c
		float ptat_on_current_mA  = BSP_PTAT_ON_CURRENT_mA;
		float bbf_on_current_mA   = BSP_BBF_ON_CURRENT_mA;

		float f_sample            = (float)pDev->adc_sampling_freq_Hz;
		float frame_period_sec    = (float)pDev->frame_period_usec / 1000000.0F;
		float pulse_width_sec     = (float)pDev->pulse_width_usec / 1000000.0F;
 802a2b6:	edd4 4a0c 	vldr	s9, [r4, #48]	; 0x30

		if (fabs(samples / f_sample - frame_period_sec) < 0.001F) // equidistant mode
			ptat_delay_sec = 0.0F;

		float bgt_on_time_sec     = total_samples * pulse_width_sec;
		float ptat_on_time_sec    = total_samples * ptat_pulse_time_sec + ptat_delay_sec;
 802a2ba:	ed9f 2a51 	vldr	s4, [pc, #324]	; 802a400 <calcCurrentConsumption_mA+0x180>

		float DMA_TRANSFER_SEC    = 2.0F / 1000.0F;
		float bbf_on_time_sec     = bbf_advance_sec + (samples - 1) / f_sample + DMA_TRANSFER_SEC; // baseband filter is now switched
 802a2be:	eddf 2a51 	vldr	s5, [pc, #324]	; 802a404 <calcCurrentConsumption_mA+0x184>

		float f_sample            = (float)pDev->adc_sampling_freq_Hz;
		float frame_period_sec    = (float)pDev->frame_period_usec / 1000000.0F;
		float pulse_width_sec     = (float)pDev->pulse_width_usec / 1000000.0F;
		float skipped_samples     = (float)pDev->num_sample_skip_count;
		float samples             = (float)pDev->num_samples_per_chirp;
 802a2c2:	eef8 6a66 	vcvt.f32.u32	s13, s13
	{
		float bgt_on_current_mA   = BSP_BGT_ON_CURRENT_mA;
		float ptat_on_current_mA  = BSP_PTAT_ON_CURRENT_mA;
		float bbf_on_current_mA   = BSP_BBF_ON_CURRENT_mA;

		float f_sample            = (float)pDev->adc_sampling_freq_Hz;
 802a2c6:	eef8 3a63 	vcvt.f32.u32	s7, s7
		float frame_period_sec    = (float)pDev->frame_period_usec / 1000000.0F;
 802a2ca:	eeb8 7a47 	vcvt.f32.u32	s14, s14
		float ptat_pulse_time_sec = (float)PTAT_S_H_PULSE_WIDTH_USEC / 1000000.0F;
		float bbf_advance_sec     = (float)BB_PRE_TRIGGER_ADVANCE_USEC / 1000000.0F;

		float total_samples       = (skipped_samples + samples);

		if (fabs(samples / f_sample - frame_period_sec) < 0.001F) // equidistant mode
 802a2ce:	ee86 4aa3 	vdiv.f32	s8, s13, s7
		float bgt_on_current_mA   = BSP_BGT_ON_CURRENT_mA;
		float ptat_on_current_mA  = BSP_PTAT_ON_CURRENT_mA;
		float bbf_on_current_mA   = BSP_BBF_ON_CURRENT_mA;

		float f_sample            = (float)pDev->adc_sampling_freq_Hz;
		float frame_period_sec    = (float)pDev->frame_period_usec / 1000000.0F;
 802a2d2:	ee87 5a03 	vdiv.f32	s10, s14, s6
		float pulse_width_sec     = (float)pDev->pulse_width_usec / 1000000.0F;
		float skipped_samples     = (float)pDev->num_sample_skip_count;
 802a2d6:	eeb8 6a65 	vcvt.f32.u32	s12, s11
		float ptat_pulse_time_sec = (float)PTAT_S_H_PULSE_WIDTH_USEC / 1000000.0F;
		float bbf_advance_sec     = (float)BB_PRE_TRIGGER_ADVANCE_USEC / 1000000.0F;

		float total_samples       = (skipped_samples + samples);

		if (fabs(samples / f_sample - frame_period_sec) < 0.001F) // equidistant mode
 802a2da:	ee34 4a45 	vsub.f32	s8, s8, s10
		float samples             = (float)pDev->num_samples_per_chirp;
		float ptat_delay_sec      = (float)pDev->ptat_delay_usec / 1000000.0F;
		float ptat_pulse_time_sec = (float)PTAT_S_H_PULSE_WIDTH_USEC / 1000000.0F;
		float bbf_advance_sec     = (float)BB_PRE_TRIGGER_ADVANCE_USEC / 1000000.0F;

		float total_samples       = (skipped_samples + samples);
 802a2de:	ee76 5a26 	vadd.f32	s11, s12, s13

		if (fabs(samples / f_sample - frame_period_sec) < 0.001F) // equidistant mode
 802a2e2:	eeb0 4ac4 	vabs.f32	s8, s8
 802a2e6:	eeb4 4ae7 	vcmpe.f32	s8, s15
 802a2ea:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
		float f_sample            = (float)pDev->adc_sampling_freq_Hz;
		float frame_period_sec    = (float)pDev->frame_period_usec / 1000000.0F;
		float pulse_width_sec     = (float)pDev->pulse_width_usec / 1000000.0F;
		float skipped_samples     = (float)pDev->num_sample_skip_count;
		float samples             = (float)pDev->num_samples_per_chirp;
		float ptat_delay_sec      = (float)pDev->ptat_delay_usec / 1000000.0F;
 802a2ee:	bf5c      	itt	pl
 802a2f0:	ee07 3a90 	vmovpl	s15, r3
 802a2f4:	eef8 7a67 	vcvtpl.f32.u32	s15, s15

		float bgt_on_time_sec     = total_samples * pulse_width_sec;
		float ptat_on_time_sec    = total_samples * ptat_pulse_time_sec + ptat_delay_sec;

		float DMA_TRANSFER_SEC    = 2.0F / 1000.0F;
		float bbf_on_time_sec     = bbf_advance_sec + (samples - 1) / f_sample + DMA_TRANSFER_SEC; // baseband filter is now switched
 802a2f8:	eeb7 6a00 	vmov.f32	s12, #112	; 0x70
		float f_sample            = (float)pDev->adc_sampling_freq_Hz;
		float frame_period_sec    = (float)pDev->frame_period_usec / 1000000.0F;
		float pulse_width_sec     = (float)pDev->pulse_width_usec / 1000000.0F;
		float skipped_samples     = (float)pDev->num_sample_skip_count;
		float samples             = (float)pDev->num_samples_per_chirp;
		float ptat_delay_sec      = (float)pDev->ptat_delay_usec / 1000000.0F;
 802a2fc:	bf58      	it	pl
 802a2fe:	eec7 7a83 	vdivpl.f32	s15, s15, s6

		float bgt_on_time_sec     = total_samples * pulse_width_sec;
		float ptat_on_time_sec    = total_samples * ptat_pulse_time_sec + ptat_delay_sec;

		float DMA_TRANSFER_SEC    = 2.0F / 1000.0F;
		float bbf_on_time_sec     = bbf_advance_sec + (samples - 1) / f_sample + DMA_TRANSFER_SEC; // baseband filter is now switched
 802a302:	ee36 6ac6 	vsub.f32	s12, s13, s12
		float ptat_on_current_mA  = BSP_PTAT_ON_CURRENT_mA;
		float bbf_on_current_mA   = BSP_BBF_ON_CURRENT_mA;

		float f_sample            = (float)pDev->adc_sampling_freq_Hz;
		float frame_period_sec    = (float)pDev->frame_period_usec / 1000000.0F;
		float pulse_width_sec     = (float)pDev->pulse_width_usec / 1000000.0F;
 802a306:	eef8 4a64 	vcvt.f32.u32	s9, s9

		float bgt_on_time_sec     = total_samples * pulse_width_sec;
		float ptat_on_time_sec    = total_samples * ptat_pulse_time_sec + ptat_delay_sec;

		float DMA_TRANSFER_SEC    = 2.0F / 1000.0F;
		float bbf_on_time_sec     = bbf_advance_sec + (samples - 1) / f_sample + DMA_TRANSFER_SEC; // baseband filter is now switched
 802a30a:	eec6 6a23 	vdiv.f32	s13, s12, s7
		float ptat_on_current_mA  = BSP_PTAT_ON_CURRENT_mA;
		float bbf_on_current_mA   = BSP_BBF_ON_CURRENT_mA;

		float f_sample            = (float)pDev->adc_sampling_freq_Hz;
		float frame_period_sec    = (float)pDev->frame_period_usec / 1000000.0F;
		float pulse_width_sec     = (float)pDev->pulse_width_usec / 1000000.0F;
 802a30e:	eec4 4a83 	vdiv.f32	s9, s9, s6
		float bbf_advance_sec     = (float)BB_PRE_TRIGGER_ADVANCE_USEC / 1000000.0F;

		float total_samples       = (skipped_samples + samples);

		if (fabs(samples / f_sample - frame_period_sec) < 0.001F) // equidistant mode
			ptat_delay_sec = 0.0F;
 802a312:	bf48      	it	mi
 802a314:	eddf 7a37 	vldrmi	s15, [pc, #220]	; 802a3f4 <calcCurrentConsumption_mA+0x174>

		float bgt_on_time_sec     = total_samples * pulse_width_sec;
		float ptat_on_time_sec    = total_samples * ptat_pulse_time_sec + ptat_delay_sec;

		float DMA_TRANSFER_SEC    = 2.0F / 1000.0F;
		float bbf_on_time_sec     = bbf_advance_sec + (samples - 1) / f_sample + DMA_TRANSFER_SEC; // baseband filter is now switched
 802a318:	ed9f 7a3b 	vldr	s14, [pc, #236]	; 802a408 <calcCurrentConsumption_mA+0x188>

		float bgt_duty_cycle  = bgt_on_time_sec / frame_period_sec;
		float ptat_duty_cycle = ptat_on_time_sec / frame_period_sec;
		float bbf_duty_cycle  = bbf_on_time_sec / frame_period_sec;

		retval = (bgt_duty_cycle * bgt_on_current_mA) + (ptat_duty_cycle * ptat_on_current_mA) + (bbf_duty_cycle * bbf_on_current_mA);
 802a31c:	ed9f 3a3b 	vldr	s6, [pc, #236]	; 802a40c <calcCurrentConsumption_mA+0x18c>
 802a320:	ed9f 4a3b 	vldr	s8, [pc, #236]	; 802a410 <calcCurrentConsumption_mA+0x190>

		if (fabs(samples / f_sample - frame_period_sec) < 0.001F) // equidistant mode
			ptat_delay_sec = 0.0F;

		float bgt_on_time_sec     = total_samples * pulse_width_sec;
		float ptat_on_time_sec    = total_samples * ptat_pulse_time_sec + ptat_delay_sec;
 802a324:	eee5 7a82 	vfma.f32	s15, s11, s4

		float DMA_TRANSFER_SEC    = 2.0F / 1000.0F;
		float bbf_on_time_sec     = bbf_advance_sec + (samples - 1) / f_sample + DMA_TRANSFER_SEC; // baseband filter is now switched
 802a328:	ee76 6a87 	vadd.f32	s13, s13, s14
		float total_samples       = (skipped_samples + samples);

		if (fabs(samples / f_sample - frame_period_sec) < 0.001F) // equidistant mode
			ptat_delay_sec = 0.0F;

		float bgt_on_time_sec     = total_samples * pulse_width_sec;
 802a32c:	ee65 5aa4 	vmul.f32	s11, s11, s9
		float bbf_on_time_sec     = bbf_advance_sec + (samples - 1) / f_sample + DMA_TRANSFER_SEC; // baseband filter is now switched
		if (bbf_on_time_sec > frame_period_sec)
			bbf_on_time_sec = frame_period_sec;

		float bgt_duty_cycle  = bgt_on_time_sec / frame_period_sec;
		float ptat_duty_cycle = ptat_on_time_sec / frame_period_sec;
 802a330:	eec7 7a85 	vdiv.f32	s15, s15, s10

		float bgt_on_time_sec     = total_samples * pulse_width_sec;
		float ptat_on_time_sec    = total_samples * ptat_pulse_time_sec + ptat_delay_sec;

		float DMA_TRANSFER_SEC    = 2.0F / 1000.0F;
		float bbf_on_time_sec     = bbf_advance_sec + (samples - 1) / f_sample + DMA_TRANSFER_SEC; // baseband filter is now switched
 802a334:	ee36 7aa2 	vadd.f32	s14, s13, s5
		if (bbf_on_time_sec > frame_period_sec)
			bbf_on_time_sec = frame_period_sec;

		float bgt_duty_cycle  = bgt_on_time_sec / frame_period_sec;
 802a338:	eec5 5a85 	vdiv.f32	s11, s11, s10
		float ptat_on_time_sec    = total_samples * ptat_pulse_time_sec + ptat_delay_sec;

		float DMA_TRANSFER_SEC    = 2.0F / 1000.0F;
		float bbf_on_time_sec     = bbf_advance_sec + (samples - 1) / f_sample + DMA_TRANSFER_SEC; // baseband filter is now switched
		if (bbf_on_time_sec > frame_period_sec)
			bbf_on_time_sec = frame_period_sec;
 802a33c:	eeb4 5a47 	vcmp.f32	s10, s14
 802a340:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802a344:	bf48      	it	mi
 802a346:	eeb0 7a45 	vmovmi.f32	s14, s10

		float bgt_duty_cycle  = bgt_on_time_sec / frame_period_sec;
		float ptat_duty_cycle = ptat_on_time_sec / frame_period_sec;
		float bbf_duty_cycle  = bbf_on_time_sec / frame_period_sec;
 802a34a:	ee87 7a05 	vdiv.f32	s14, s14, s10

		retval = (bgt_duty_cycle * bgt_on_current_mA) + (ptat_duty_cycle * ptat_on_current_mA) + (bbf_duty_cycle * bbf_on_current_mA);
 802a34e:	eef7 6a08 	vmov.f32	s13, #120	; 0x78
 802a352:	ee67 7aa6 	vmul.f32	s15, s15, s13
 802a356:	eee5 7a83 	vfma.f32	s15, s11, s6
 802a35a:	eee7 7a04 	vfma.f32	s15, s14, s8
	}

	return retval;
}
 802a35e:	ee17 0a90 	vmov	r0, s15
 802a362:	bd10      	pop	{r4, pc}
		float bbf_on_current_mA   = BSP_BBF_ON_CURRENT_mA;

		float f_sample            = (float)pDev->adc_sampling_freq_Hz;
		float frame_period_sec    = (float)pDev->frame_period_usec / 1000000.0F;
		float pulse_width_sec     = (float)pDev->pulse_width_usec / 1000000.0F;
		float skipped_samples     = (float)pDev->num_sample_skip_count;
 802a364:	edd4 5a0b 	vldr	s11, [r4, #44]	; 0x2c
		float samples             = (float)pDev->num_samples_per_chirp;
 802a368:	ed94 6a09 	vldr	s12, [r4, #36]	; 0x24
		float ptat_on_current_mA  = BSP_PTAT_ON_CURRENT_mA;
		float bbf_on_current_mA   = BSP_BBF_ON_CURRENT_mA;

		float f_sample            = (float)pDev->adc_sampling_freq_Hz;
		float frame_period_sec    = (float)pDev->frame_period_usec / 1000000.0F;
		float pulse_width_sec     = (float)pDev->pulse_width_usec / 1000000.0F;
 802a36c:	6b22      	ldr	r2, [r4, #48]	; 0x30
	{
		float bgt_on_current_mA   = BSP_BGT_ON_CURRENT_mA;
		float ptat_on_current_mA  = BSP_PTAT_ON_CURRENT_mA;
		float bbf_on_current_mA   = BSP_BBF_ON_CURRENT_mA;

		float f_sample            = (float)pDev->adc_sampling_freq_Hz;
 802a36e:	edd4 7a05 	vldr	s15, [r4, #20]
		float frame_period_sec    = (float)pDev->frame_period_usec / 1000000.0F;
 802a372:	eddf 4a21 	vldr	s9, [pc, #132]	; 802a3f8 <calcCurrentConsumption_mA+0x178>
		float pulse_width_sec     = (float)pDev->pulse_width_usec / 1000000.0F;
		float skipped_samples     = (float)pDev->num_sample_skip_count;
		float samples             = (float)pDev->num_samples_per_chirp;
		float ptat_delay_sec      = (float)pDev->ptat_delay_usec / 1000000.0F;
 802a376:	ed94 5a0f 	vldr	s10, [r4, #60]	; 0x3c
		float bgt_on_current_mA   = BSP_BGT_ON_CURRENT_mA;
		float ptat_on_current_mA  = BSP_PTAT_ON_CURRENT_mA;
		float bbf_on_current_mA   = BSP_BBF_ON_CURRENT_mA;

		float f_sample            = (float)pDev->adc_sampling_freq_Hz;
		float frame_period_sec    = (float)pDev->frame_period_usec / 1000000.0F;
 802a37a:	6a23      	ldr	r3, [r4, #32]

		float bgt_duty_cycle      = bgt_on_time_sec / frame_period_sec;
		float ptat_duty_cycle     = ptat_on_time_sec / frame_period_sec;
		float bbf_duty_cycle      = bbf_on_time_sec / frame_period_sec;

		retval = (bgt_duty_cycle * bgt_on_current_mA) + (ptat_duty_cycle * ptat_on_current_mA) + (bbf_duty_cycle * bbf_on_current_mA);
 802a37c:	eddf 3a23 	vldr	s7, [pc, #140]	; 802a40c <calcCurrentConsumption_mA+0x18c>
 802a380:	ed9f 4a23 	vldr	s8, [pc, #140]	; 802a410 <calcCurrentConsumption_mA+0x190>
		float bbf_on_current_mA   = BSP_BBF_ON_CURRENT_mA;

		float f_sample            = (float)pDev->adc_sampling_freq_Hz;
		float frame_period_sec    = (float)pDev->frame_period_usec / 1000000.0F;
		float pulse_width_sec     = (float)pDev->pulse_width_usec / 1000000.0F;
		float skipped_samples     = (float)pDev->num_sample_skip_count;
 802a384:	eef8 5a65 	vcvt.f32.u32	s11, s11
		float samples             = (float)pDev->num_samples_per_chirp;
 802a388:	eeb8 6a46 	vcvt.f32.u32	s12, s12
		float ptat_delay_sec      = (float)pDev->ptat_delay_usec / 1000000.0F;

		float total_samples       = (skipped_samples + samples);

		float frame_on_time_sec   = (total_samples - 1) / f_sample + pulse_width_sec;
 802a38c:	eef7 6a00 	vmov.f32	s13, #112	; 0x70
		float pulse_width_sec     = (float)pDev->pulse_width_usec / 1000000.0F;
		float skipped_samples     = (float)pDev->num_sample_skip_count;
		float samples             = (float)pDev->num_samples_per_chirp;
		float ptat_delay_sec      = (float)pDev->ptat_delay_usec / 1000000.0F;

		float total_samples       = (skipped_samples + samples);
 802a390:	ee35 6a86 	vadd.f32	s12, s11, s12
	{
		float bgt_on_current_mA   = BSP_BGT_ON_CURRENT_mA;
		float ptat_on_current_mA  = BSP_PTAT_ON_CURRENT_mA;
		float bbf_on_current_mA   = BSP_BBF_ON_CURRENT_mA;

		float f_sample            = (float)pDev->adc_sampling_freq_Hz;
 802a394:	eef8 7a67 	vcvt.f32.u32	s15, s15
		float samples             = (float)pDev->num_samples_per_chirp;
		float ptat_delay_sec      = (float)pDev->ptat_delay_usec / 1000000.0F;

		float total_samples       = (skipped_samples + samples);

		float frame_on_time_sec   = (total_samples - 1) / f_sample + pulse_width_sec;
 802a398:	ee36 7a66 	vsub.f32	s14, s12, s13
		float ptat_on_current_mA  = BSP_PTAT_ON_CURRENT_mA;
		float bbf_on_current_mA   = BSP_BBF_ON_CURRENT_mA;

		float f_sample            = (float)pDev->adc_sampling_freq_Hz;
		float frame_period_sec    = (float)pDev->frame_period_usec / 1000000.0F;
		float pulse_width_sec     = (float)pDev->pulse_width_usec / 1000000.0F;
 802a39c:	ee06 2a90 	vmov	s13, r2
 802a3a0:	eef8 5a66 	vcvt.f32.u32	s11, s13
		float samples             = (float)pDev->num_samples_per_chirp;
		float ptat_delay_sec      = (float)pDev->ptat_delay_usec / 1000000.0F;

		float total_samples       = (skipped_samples + samples);

		float frame_on_time_sec   = (total_samples - 1) / f_sample + pulse_width_sec;
 802a3a4:	ee87 7a27 	vdiv.f32	s14, s14, s15
		float ptat_on_current_mA  = BSP_PTAT_ON_CURRENT_mA;
		float bbf_on_current_mA   = BSP_BBF_ON_CURRENT_mA;

		float f_sample            = (float)pDev->adc_sampling_freq_Hz;
		float frame_period_sec    = (float)pDev->frame_period_usec / 1000000.0F;
		float pulse_width_sec     = (float)pDev->pulse_width_usec / 1000000.0F;
 802a3a8:	eec5 5aa4 	vdiv.f32	s11, s11, s9
		float skipped_samples     = (float)pDev->num_sample_skip_count;
		float samples             = (float)pDev->num_samples_per_chirp;
		float ptat_delay_sec      = (float)pDev->ptat_delay_usec / 1000000.0F;
 802a3ac:	eef8 7a45 	vcvt.f32.u32	s15, s10
		float bgt_on_current_mA   = BSP_BGT_ON_CURRENT_mA;
		float ptat_on_current_mA  = BSP_PTAT_ON_CURRENT_mA;
		float bbf_on_current_mA   = BSP_BBF_ON_CURRENT_mA;

		float f_sample            = (float)pDev->adc_sampling_freq_Hz;
		float frame_period_sec    = (float)pDev->frame_period_usec / 1000000.0F;
 802a3b0:	ee06 3a90 	vmov	s13, r3
		float pulse_width_sec     = (float)pDev->pulse_width_usec / 1000000.0F;
		float skipped_samples     = (float)pDev->num_sample_skip_count;
		float samples             = (float)pDev->num_samples_per_chirp;
		float ptat_delay_sec      = (float)pDev->ptat_delay_usec / 1000000.0F;
 802a3b4:	ee87 5aa4 	vdiv.f32	s10, s15, s9
		float bgt_on_current_mA   = BSP_BGT_ON_CURRENT_mA;
		float ptat_on_current_mA  = BSP_PTAT_ON_CURRENT_mA;
		float bbf_on_current_mA   = BSP_BBF_ON_CURRENT_mA;

		float f_sample            = (float)pDev->adc_sampling_freq_Hz;
		float frame_period_sec    = (float)pDev->frame_period_usec / 1000000.0F;
 802a3b8:	eef8 6a66 	vcvt.f32.u32	s13, s13
		float samples             = (float)pDev->num_samples_per_chirp;
		float ptat_delay_sec      = (float)pDev->ptat_delay_usec / 1000000.0F;

		float total_samples       = (skipped_samples + samples);

		float frame_on_time_sec   = (total_samples - 1) / f_sample + pulse_width_sec;
 802a3bc:	ee77 7a25 	vadd.f32	s15, s14, s11
		float bgt_on_current_mA   = BSP_BGT_ON_CURRENT_mA;
		float ptat_on_current_mA  = BSP_PTAT_ON_CURRENT_mA;
		float bbf_on_current_mA   = BSP_BBF_ON_CURRENT_mA;

		float f_sample            = (float)pDev->adc_sampling_freq_Hz;
		float frame_period_sec    = (float)pDev->frame_period_usec / 1000000.0F;
 802a3c0:	eec6 6aa4 	vdiv.f32	s13, s13, s9

		float total_samples       = (skipped_samples + samples);

		float frame_on_time_sec   = (total_samples - 1) / f_sample + pulse_width_sec;
		float bgt_on_time_sec     = total_samples * pulse_width_sec;
		float ptat_on_time_sec    = frame_on_time_sec + ptat_delay_sec;
 802a3c4:	ee77 7a85 	vadd.f32	s15, s15, s10
		float ptat_delay_sec      = (float)pDev->ptat_delay_usec / 1000000.0F;

		float total_samples       = (skipped_samples + samples);

		float frame_on_time_sec   = (total_samples - 1) / f_sample + pulse_width_sec;
		float bgt_on_time_sec     = total_samples * pulse_width_sec;
 802a3c8:	ee26 6a25 	vmul.f32	s12, s12, s11
		float ptat_on_time_sec    = frame_on_time_sec + ptat_delay_sec;
		float bbf_on_time_sec     = frame_period_sec; // baseband filter is not switched, but always on!

		float bgt_duty_cycle      = bgt_on_time_sec / frame_period_sec;
		float ptat_duty_cycle     = ptat_on_time_sec / frame_period_sec;
 802a3cc:	eec7 7aa6 	vdiv.f32	s15, s15, s13
		float frame_on_time_sec   = (total_samples - 1) / f_sample + pulse_width_sec;
		float bgt_on_time_sec     = total_samples * pulse_width_sec;
		float ptat_on_time_sec    = frame_on_time_sec + ptat_delay_sec;
		float bbf_on_time_sec     = frame_period_sec; // baseband filter is not switched, but always on!

		float bgt_duty_cycle      = bgt_on_time_sec / frame_period_sec;
 802a3d0:	ee86 6a26 	vdiv.f32	s12, s12, s13
		float ptat_duty_cycle     = ptat_on_time_sec / frame_period_sec;
		float bbf_duty_cycle      = bbf_on_time_sec / frame_period_sec;
 802a3d4:	eec6 6aa6 	vdiv.f32	s13, s13, s13

		retval = (bgt_duty_cycle * bgt_on_current_mA) + (ptat_duty_cycle * ptat_on_current_mA) + (bbf_duty_cycle * bbf_on_current_mA);
 802a3d8:	eeb7 7a08 	vmov.f32	s14, #120	; 0x78
 802a3dc:	ee67 7a87 	vmul.f32	s15, s15, s14
 802a3e0:	eee6 7a23 	vfma.f32	s15, s12, s7
 802a3e4:	eee6 7a84 	vfma.f32	s15, s13, s8

		retval = (bgt_duty_cycle * bgt_on_current_mA) + (ptat_duty_cycle * ptat_on_current_mA) + (bbf_duty_cycle * bbf_on_current_mA);
	}

	return retval;
}
 802a3e8:	ee17 0a90 	vmov	r0, s15
 802a3ec:	bd10      	pop	{r4, pc}
 802a3ee:	bf00      	nop
 802a3f0:	1ffe9600 	.word	0x1ffe9600
 802a3f4:	00000000 	.word	0x00000000
 802a3f8:	49742400 	.word	0x49742400
 802a3fc:	3a83126f 	.word	0x3a83126f
 802a400:	37a7c5ac 	.word	0x37a7c5ac
 802a404:	3b03126f 	.word	0x3b03126f
 802a408:	3ca3d70a 	.word	0x3ca3d70a
 802a40c:	42340000 	.word	0x42340000
 802a410:	3eab851f 	.word	0x3eab851f

0802a414 <CCU43_3_IRQHandler>:
}

//============================================================================

void IRQ_ERROR_TOGGLE_Handler(void)
{
 802a414:	b508      	push	{r3, lr}
	bsp_led_red_toggle();
 802a416:	f7fe fcbd 	bl	8028d94 <bsp_led_red_toggle>
	bsp_timer_start(&TIMER_ERROR_TOGGLE);
 802a41a:	4802      	ldr	r0, [pc, #8]	; (802a424 <CCU43_3_IRQHandler+0x10>)
}
 802a41c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
//============================================================================

void IRQ_ERROR_TOGGLE_Handler(void)
{
	bsp_led_red_toggle();
	bsp_timer_start(&TIMER_ERROR_TOGGLE);
 802a420:	f7ff ba1c 	b.w	802985c <bsp_timer_start>
 802a424:	1ffe91d8 	.word	0x1ffe91d8

0802a428 <app_reset_protocol>:
static uint32_t app_connected = 0;
static uint32_t delayCount = 0;

void app_reset_protocol(void)
{
	delayCount = 0;
 802a428:	4902      	ldr	r1, [pc, #8]	; (802a434 <app_reset_protocol+0xc>)
	app_connected = 0;
 802a42a:	4a03      	ldr	r2, [pc, #12]	; (802a438 <app_reset_protocol+0x10>)
static uint32_t app_connected = 0;
static uint32_t delayCount = 0;

void app_reset_protocol(void)
{
	delayCount = 0;
 802a42c:	2300      	movs	r3, #0
 802a42e:	600b      	str	r3, [r1, #0]
	app_connected = 0;
 802a430:	6013      	str	r3, [r2, #0]
 802a432:	4770      	bx	lr
 802a434:	1ffedc3c 	.word	0x1ffedc3c
 802a438:	1ffedc34 	.word	0x1ffedc34

0802a43c <update_leds>:
}

//============================================================================

void update_leds(algo_result_t *pResult)
{
 802a43c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (pResult->target_approaching)
 802a43e:	7a43      	ldrb	r3, [r0, #9]
 802a440:	2b00      	cmp	r3, #0
 802a442:	d138      	bne.n	802a4b6 <update_leds+0x7a>
		/* Arduino status IO */
		DIGITAL_IO_SetOutputHigh(&DIGITAL_IO_ARD_D6);
		DIGITAL_IO_SetOutputLow(&DIGITAL_IO_ARD_D4);
		DIGITAL_IO_SetOutputLow(&DIGITAL_IO_ARD_D7);
	}
	else if (pResult->target_departing)
 802a444:	7a03      	ldrb	r3, [r0, #8]
 802a446:	2b00      	cmp	r3, #0
 802a448:	d13e      	bne.n	802a4c8 <update_leds+0x8c>
		/* Arduino IO */
		DIGITAL_IO_SetOutputHigh(&DIGITAL_IO_ARD_D7);
		DIGITAL_IO_SetOutputLow(&DIGITAL_IO_ARD_D4);
		DIGITAL_IO_SetOutputLow(&DIGITAL_IO_ARD_D6);
	}
	else if (pResult->motion_detected)
 802a44a:	7a83      	ldrb	r3, [r0, #10]
 802a44c:	b9cb      	cbnz	r3, 802a482 <update_leds+0x46>
		DIGITAL_IO_SetOutputLow(&DIGITAL_IO_ARD_D6);
		DIGITAL_IO_SetOutputLow(&DIGITAL_IO_ARD_D7);
	}
	else
	{
		bsp_led_red_off();
 802a44e:	f7fe fc97 	bl	8028d80 <bsp_led_red_off>
		bsp_led_blue_off();
 802a452:	f7fe fc81 	bl	8028d58 <bsp_led_blue_off>
		bsp_led_green_off();
 802a456:	f7fe fc6b 	bl	8028d30 <bsp_led_green_off>
 802a45a:	4920      	ldr	r1, [pc, #128]	; (802a4dc <update_leds+0xa0>)
 802a45c:	4a20      	ldr	r2, [pc, #128]	; (802a4e0 <update_leds+0xa4>)
 802a45e:	4b21      	ldr	r3, [pc, #132]	; (802a4e4 <update_leds+0xa8>)

__STATIC_INLINE void XMC_GPIO_SetOutputLow(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputLow: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = 0x10000U << pin;
 802a460:	7c0d      	ldrb	r5, [r1, #16]
 802a462:	7c10      	ldrb	r0, [r2, #16]
 802a464:	7c1e      	ldrb	r6, [r3, #16]
 802a466:	680c      	ldr	r4, [r1, #0]
 802a468:	6811      	ldr	r1, [r2, #0]
 802a46a:	681a      	ldr	r2, [r3, #0]
 802a46c:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 802a470:	fa03 f505 	lsl.w	r5, r3, r5
 802a474:	fa03 f000 	lsl.w	r0, r3, r0
 802a478:	40b3      	lsls	r3, r6
 802a47a:	6065      	str	r5, [r4, #4]
 802a47c:	6048      	str	r0, [r1, #4]
 802a47e:	6053      	str	r3, [r2, #4]
 802a480:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		DIGITAL_IO_SetOutputLow(&DIGITAL_IO_ARD_D4);
		DIGITAL_IO_SetOutputLow(&DIGITAL_IO_ARD_D6);
	}
	else if (pResult->motion_detected)
	{
		bsp_led_red_off();
 802a482:	f7fe fc7d 	bl	8028d80 <bsp_led_red_off>
		bsp_led_blue_on();
 802a486:	f7fe fc5d 	bl	8028d44 <bsp_led_blue_on>
		bsp_led_green_off();
 802a48a:	f7fe fc51 	bl	8028d30 <bsp_led_green_off>
 802a48e:	4913      	ldr	r1, [pc, #76]	; (802a4dc <update_leds+0xa0>)
 802a490:	4a13      	ldr	r2, [pc, #76]	; (802a4e0 <update_leds+0xa4>)
 802a492:	4b14      	ldr	r3, [pc, #80]	; (802a4e4 <update_leds+0xa8>)

__STATIC_INLINE void XMC_GPIO_SetOutputHigh(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputHigh: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = (uint32_t)0x1U << pin;
 802a494:	7c0f      	ldrb	r7, [r1, #16]

__STATIC_INLINE void XMC_GPIO_SetOutputLow(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputLow: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = 0x10000U << pin;
 802a496:	7c15      	ldrb	r5, [r2, #16]
 802a498:	7c1e      	ldrb	r6, [r3, #16]
 802a49a:	6808      	ldr	r0, [r1, #0]
 802a49c:	6814      	ldr	r4, [r2, #0]
 802a49e:	6819      	ldr	r1, [r3, #0]

__STATIC_INLINE void XMC_GPIO_SetOutputHigh(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputHigh: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = (uint32_t)0x1U << pin;
 802a4a0:	2201      	movs	r2, #1

__STATIC_INLINE void XMC_GPIO_SetOutputLow(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputLow: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = 0x10000U << pin;
 802a4a2:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 802a4a6:	fa03 f505 	lsl.w	r5, r3, r5

__STATIC_INLINE void XMC_GPIO_SetOutputHigh(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputHigh: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = (uint32_t)0x1U << pin;
 802a4aa:	40ba      	lsls	r2, r7

__STATIC_INLINE void XMC_GPIO_SetOutputLow(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputLow: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = 0x10000U << pin;
 802a4ac:	40b3      	lsls	r3, r6

__STATIC_INLINE void XMC_GPIO_SetOutputHigh(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputHigh: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = (uint32_t)0x1U << pin;
 802a4ae:	6042      	str	r2, [r0, #4]

__STATIC_INLINE void XMC_GPIO_SetOutputLow(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
  XMC_ASSERT("XMC_GPIO_SetOutputLow: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = 0x10000U << pin;
 802a4b0:	6065      	str	r5, [r4, #4]
 802a4b2:	604b      	str	r3, [r1, #4]
 802a4b4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

void update_leds(algo_result_t *pResult)
{
	if (pResult->target_approaching)
	{
		bsp_led_red_off();
 802a4b6:	f7fe fc63 	bl	8028d80 <bsp_led_red_off>
		bsp_led_blue_off();
 802a4ba:	f7fe fc4d 	bl	8028d58 <bsp_led_blue_off>
		bsp_led_green_on();
 802a4be:	f7fe fc2d 	bl	8028d1c <bsp_led_green_on>
 802a4c2:	4907      	ldr	r1, [pc, #28]	; (802a4e0 <update_leds+0xa4>)
 802a4c4:	4a05      	ldr	r2, [pc, #20]	; (802a4dc <update_leds+0xa0>)
 802a4c6:	e7e4      	b.n	802a492 <update_leds+0x56>
		DIGITAL_IO_SetOutputLow(&DIGITAL_IO_ARD_D4);
		DIGITAL_IO_SetOutputLow(&DIGITAL_IO_ARD_D7);
	}
	else if (pResult->target_departing)
	{
		bsp_led_red_on();
 802a4c8:	f7fe fc50 	bl	8028d6c <bsp_led_red_on>
		bsp_led_blue_off();
 802a4cc:	f7fe fc44 	bl	8028d58 <bsp_led_blue_off>
		bsp_led_green_off();
 802a4d0:	f7fe fc2e 	bl	8028d30 <bsp_led_green_off>
 802a4d4:	4903      	ldr	r1, [pc, #12]	; (802a4e4 <update_leds+0xa8>)
 802a4d6:	4a01      	ldr	r2, [pc, #4]	; (802a4dc <update_leds+0xa0>)
 802a4d8:	4b01      	ldr	r3, [pc, #4]	; (802a4e0 <update_leds+0xa4>)
 802a4da:	e7db      	b.n	802a494 <update_leds+0x58>
 802a4dc:	0802f880 	.word	0x0802f880
 802a4e0:	0802f894 	.word	0x0802f894
 802a4e4:	0802f8a8 	.word	0x0802f8a8

0802a4e8 <app_process>:

//============================================================================

/* Main application process */
void app_process(void)
{
 802a4e8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if (g_usb_init == true)
 802a4ec:	4c57      	ldr	r4, [pc, #348]	; (802a64c <app_process+0x164>)
 802a4ee:	7823      	ldrb	r3, [r4, #0]
 802a4f0:	2b01      	cmp	r3, #1
 802a4f2:	f000 808b 	beq.w	802a60c <app_process+0x124>
    protocol_run();
  }
  else
  {
    /* Initialize the USB low layer driver and start USB data communication */
    if (bsp_usb_init(BSP_USB_TIMEOUT) == 0)
 802a4f6:	f640 70ff 	movw	r0, #4095	; 0xfff
 802a4fa:	f7ff fe01 	bl	802a100 <bsp_usb_init>
 802a4fe:	b908      	cbnz	r0, 802a504 <app_process+0x1c>
    {
      g_usb_init = true;
 802a500:	2301      	movs	r3, #1
 802a502:	7023      	strb	r3, [r4, #0]
//============================================================================

/* Main radar application process */
void radar_app_process(void)
{
	if (acq_started)
 802a504:	4b52      	ldr	r3, [pc, #328]	; (802a650 <app_process+0x168>)
 802a506:	681a      	ldr	r2, [r3, #0]
 802a508:	b10a      	cbz	r2, 802a50e <app_process+0x26>
	{
		/* ... */
		acq_started = 0;
 802a50a:	2200      	movs	r2, #0
 802a50c:	601a      	str	r2, [r3, #0]
	}

	if (acq_completed)
 802a50e:	4d51      	ldr	r5, [pc, #324]	; (802a654 <app_process+0x16c>)
 802a510:	682b      	ldr	r3, [r5, #0]
 802a512:	b9cb      	cbnz	r3, 802a548 <app_process+0x60>
 802a514:	4c50      	ldr	r4, [pc, #320]	; (802a658 <app_process+0x170>)
 802a516:	6823      	ldr	r3, [r4, #0]
		}
#endif
		acq_completed = 0;
	}

	if (algo_completed)
 802a518:	2b00      	cmp	r3, #0
 802a51a:	d13e      	bne.n	802a59a <app_process+0xb2>
	{
		algo_completed_cb();
		algo_completed = 0;
	}

	if (app_initalized)
 802a51c:	4b4f      	ldr	r3, [pc, #316]	; (802a65c <app_process+0x174>)
	{
		switch (radar_app_state)
 802a51e:	4c50      	ldr	r4, [pc, #320]	; (802a660 <app_process+0x178>)
	{
		algo_completed_cb();
		algo_completed = 0;
	}

	if (app_initalized)
 802a520:	681b      	ldr	r3, [r3, #0]
 802a522:	b143      	cbz	r3, 802a536 <app_process+0x4e>
	{
		switch (radar_app_state)
 802a524:	7823      	ldrb	r3, [r4, #0]
 802a526:	3b01      	subs	r3, #1
 802a528:	2b04      	cmp	r3, #4
 802a52a:	d80b      	bhi.n	802a544 <app_process+0x5c>
 802a52c:	e8df f003 	tbb	[pc, r3]
 802a530:	3a604945 	.word	0x3a604945
 802a534:	67          	.byte	0x67
 802a535:	00          	.byte	0x00
			break;
		}
	}
	else
	{
		switch (radar_app_state)
 802a536:	7823      	ldrb	r3, [r4, #0]
 802a538:	2b04      	cmp	r3, #4
 802a53a:	d033      	beq.n	802a5a4 <app_process+0xbc>
 802a53c:	2b05      	cmp	r3, #5
 802a53e:	d068      	beq.n	802a612 <app_process+0x12a>
 802a540:	2b01      	cmp	r3, #1
 802a542:	d02f      	beq.n	802a5a4 <app_process+0xbc>
 802a544:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (acq_completed)
	{

#if defined(FMCW_SUPPORTED) || defined(DOPPLER_SUPPORTED)
		/* Start the processing of the algorithm assigned in the function pointer 'algo_processor' */
		if (algo_processing_function != NULL)
 802a548:	4c46      	ldr	r4, [pc, #280]	; (802a664 <app_process+0x17c>)
 802a54a:	6823      	ldr	r3, [r4, #0]
 802a54c:	b393      	cbz	r3, 802a5b4 <app_process+0xcc>

static algo_result_t algo_result;

void do_algo_helper(void)
{
	acq_buf_obj *p_acq_buf = ds_get_active_acq_buf();
 802a54e:	f7f5 ffcf 	bl	80204f0 <ds_get_active_acq_buf>
 802a552:	4607      	mov	r7, r0
	algo_settings_t *p_algo_settings = ds_algo_get_settings();
 802a554:	f7f5 fd60 	bl	8020018 <ds_algo_get_settings>
 802a558:	4680      	mov	r8, r0
	device_settings_t *p_dev_settings = ds_device_get_shadow_settings();
 802a55a:	f7f5 fdd3 	bl	8020104 <ds_device_get_shadow_settings>
 802a55e:	4606      	mov	r6, r0
	algo_result_t *p_algo_result = &algo_result;

	/* this is the async raw data streaming to host device */
	radar_pulse_raw_data(p_acq_buf, p_dev_settings);
 802a560:	4631      	mov	r1, r6
 802a562:	4638      	mov	r0, r7
 802a564:	f7f6 fbd2 	bl	8020d0c <radar_pulse_raw_data>

	algo_processing_function(p_acq_buf, p_algo_settings, p_dev_settings, p_algo_result);
 802a568:	4632      	mov	r2, r6
 802a56a:	4b3f      	ldr	r3, [pc, #252]	; (802a668 <app_process+0x180>)
 802a56c:	6826      	ldr	r6, [r4, #0]
#if defined(FMCW_SUPPORTED) || defined(DOPPLER_SUPPORTED)
		/* Start the processing of the algorithm assigned in the function pointer 'algo_processor' */
		if (algo_processing_function != NULL)
		{
			do_algo_helper();
			algo_completed += 1;
 802a56e:	4c3a      	ldr	r4, [pc, #232]	; (802a658 <app_process+0x170>)
	algo_result_t *p_algo_result = &algo_result;

	/* this is the async raw data streaming to host device */
	radar_pulse_raw_data(p_acq_buf, p_dev_settings);

	algo_processing_function(p_acq_buf, p_algo_settings, p_dev_settings, p_algo_result);
 802a570:	4641      	mov	r1, r8
 802a572:	4638      	mov	r0, r7
 802a574:	47b0      	blx	r6

	ds_store_algo_result_ptr(p_algo_result);
 802a576:	483c      	ldr	r0, [pc, #240]	; (802a668 <app_process+0x180>)
 802a578:	f7f5 fd48 	bl	802000c <ds_store_algo_result_ptr>

	radar_pulse_results_updates(p_algo_result);
 802a57c:	483a      	ldr	r0, [pc, #232]	; (802a668 <app_process+0x180>)
 802a57e:	f7f6 fbd7 	bl	8020d30 <radar_pulse_results_updates>

	mcu_base_updates();
 802a582:	f7f6 fb93 	bl	8020cac <mcu_base_updates>

	update_leds(p_algo_result);
 802a586:	4838      	ldr	r0, [pc, #224]	; (802a668 <app_process+0x180>)
 802a588:	f7ff ff58 	bl	802a43c <update_leds>
#if defined(FMCW_SUPPORTED) || defined(DOPPLER_SUPPORTED)
		/* Start the processing of the algorithm assigned in the function pointer 'algo_processor' */
		if (algo_processing_function != NULL)
		{
			do_algo_helper();
			algo_completed += 1;
 802a58c:	6823      	ldr	r3, [r4, #0]
 802a58e:	3301      	adds	r3, #1
 802a590:	6023      	str	r3, [r4, #0]
		}
#endif
		acq_completed = 0;
 802a592:	2200      	movs	r2, #0
 802a594:	602a      	str	r2, [r5, #0]
	}

	if (algo_completed)
 802a596:	2b00      	cmp	r3, #0
 802a598:	d0c0      	beq.n	802a51c <app_process+0x34>
	{
		algo_completed_cb();
 802a59a:	f000 f9e3 	bl	802a964 <algo_completed_cb>
		algo_completed = 0;
 802a59e:	2300      	movs	r3, #0
 802a5a0:	6023      	str	r3, [r4, #0]
 802a5a2:	e7bb      	b.n	802a51c <app_process+0x34>
			radar_app_state = APP_CHECK_FOR_ERROR;
			break;

		case APP_CHECK_FOR_ERROR:
		{
			int status = device_status_check();
 802a5a4:	f7f6 fb5c 	bl	8020c60 <device_status_check>
			if (status < 0)
 802a5a8:	2800      	cmp	r0, #0
 802a5aa:	db2b      	blt.n	802a604 <app_process+0x11c>
		}
		break;

		case APP_HANDLE_ERROR:
			send_device_status_response();
			radar_app_state = APP_IDLE;
 802a5ac:	2301      	movs	r3, #1
 802a5ae:	7023      	strb	r3, [r4, #0]
 802a5b0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802a5b4:	4c28      	ldr	r4, [pc, #160]	; (802a658 <app_process+0x170>)
 802a5b6:	6823      	ldr	r3, [r4, #0]
 802a5b8:	e7eb      	b.n	802a592 <app_process+0xaa>
	if (app_initalized)
	{
		switch (radar_app_state)
		{
		case APP_IDLE:
			radar_app_state = APP_CHECK_FOR_SETTINGS_UPDATE;
 802a5ba:	2303      	movs	r3, #3
 802a5bc:	7023      	strb	r3, [r4, #0]
 802a5be:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

//============================================================================

static uint32_t helper_do_hw_settings(void)
{
	device_settings_t *p_dev_settings = ds_device_get_settings();
 802a5c2:	f7f5 fd9b 	bl	80200fc <ds_device_get_settings>

	uint32_t error = radar_apply_hw_settings(h_radar_device, p_dev_settings);
 802a5c6:	4e29      	ldr	r6, [pc, #164]	; (802a66c <app_process+0x184>)

//============================================================================

static uint32_t helper_do_hw_settings(void)
{
	device_settings_t *p_dev_settings = ds_device_get_settings();
 802a5c8:	4605      	mov	r5, r0

	uint32_t error = radar_apply_hw_settings(h_radar_device, p_dev_settings);
 802a5ca:	4601      	mov	r1, r0
 802a5cc:	6830      	ldr	r0, [r6, #0]
 802a5ce:	f7f6 fabb 	bl	8020b48 <radar_apply_hw_settings>
	if (error == RADAR_ERR_OK)
 802a5d2:	b368      	cbz	r0, 802a630 <app_process+0x148>
		ds_device_settings_copy_to_shadow();
		/* add com-lib callback to send-out updated parameters!!! */
	}
	else
	{
		ds_device_settings_revert_from_shadow();
 802a5d4:	f7f5 fdbc 	bl	8020150 <ds_device_settings_revert_from_shadow>
		// current and new parameter differs, if an error occurred, tell to the application
	}
	radar_app_state = APP_IDLE;
 802a5d8:	2301      	movs	r3, #1
 802a5da:	7023      	strb	r3, [r4, #0]
	ds_clear_device_parameter_changed();
 802a5dc:	f7f6 f800 	bl	80205e0 <ds_clear_device_parameter_changed>

	error = radar_set_automatic_frame_trigger(h_radar_device, p_dev_settings->frame_period_usec);
 802a5e0:	6830      	ldr	r0, [r6, #0]
 802a5e2:	6a29      	ldr	r1, [r5, #32]
 802a5e4:	f7f6 fa04 	bl	80209f0 <radar_set_automatic_frame_trigger>
			}
			break;

		case APP_APPLY_DEVICE_SETTINGS:
			helper_do_hw_settings();
			radar_app_state = APP_CHECK_FOR_ERROR;
 802a5e8:	2304      	movs	r3, #4
 802a5ea:	7023      	strb	r3, [r4, #0]
 802a5ec:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			radar_app_state = APP_CHECK_FOR_SETTINGS_UPDATE;
			break;

		case APP_CHECK_FOR_SETTINGS_UPDATE:
			/* Check if a new hardware settings are required */
			if (ds_is_device_parameter_changed() || ds_is_device_settings_updated())
 802a5f0:	f7f5 fffc 	bl	80205ec <ds_is_device_parameter_changed>
 802a5f4:	b1f8      	cbz	r0, 802a636 <app_process+0x14e>
			{
				radar_app_state = APP_APPLY_DEVICE_SETTINGS;
 802a5f6:	2302      	movs	r3, #2
 802a5f8:	7023      	strb	r3, [r4, #0]
 802a5fa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			}
		}
		break;

		case APP_HANDLE_ERROR:
			send_device_status_response();
 802a5fe:	f7f9 fa03 	bl	8023a08 <send_device_status_response>
 802a602:	e7d3      	b.n	802a5ac <app_process+0xc4>
		case APP_CHECK_FOR_ERROR:
		{
			int status = device_status_check();
			if (status < 0)
			{
				radar_app_state = APP_HANDLE_ERROR;
 802a604:	2305      	movs	r3, #5
 802a606:	7023      	strb	r3, [r4, #0]
 802a608:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
void app_process(void)
{
  if (g_usb_init == true)
  {
    /* Run communication protocol */
    protocol_run();
 802a60c:	f7f9 ff2c 	bl	8024468 <protocol_run>
 802a610:	e778      	b.n	802a504 <app_process+0x1c>
		break;

		case APP_HANDLE_ERROR:
		{
			/* Send out error only once, if PC app is not requesting it! */
			if (!app_connected)
 802a612:	4d17      	ldr	r5, [pc, #92]	; (802a670 <app_process+0x188>)
 802a614:	682e      	ldr	r6, [r5, #0]
 802a616:	2e00      	cmp	r6, #0
 802a618:	d1e6      	bne.n	802a5e8 <app_process+0x100>
			{

				delayCount += 1;
 802a61a:	4f16      	ldr	r7, [pc, #88]	; (802a674 <app_process+0x18c>)
 802a61c:	683b      	ldr	r3, [r7, #0]
 802a61e:	3301      	adds	r3, #1
				if (delayCount == 100)
 802a620:	2b64      	cmp	r3, #100	; 0x64
		{
			/* Send out error only once, if PC app is not requesting it! */
			if (!app_connected)
			{

				delayCount += 1;
 802a622:	603b      	str	r3, [r7, #0]
				if (delayCount == 100)
 802a624:	d00c      	beq.n	802a640 <app_process+0x158>
				{
					send_device_status_response();
					app_connected = 1;
					delayCount = 0;
				}
				bsp_time_delay(20, BSP_TIMER_DELAY_MILLISECOND);
 802a626:	2014      	movs	r0, #20
 802a628:	2101      	movs	r1, #1
 802a62a:	f7fe fb53 	bl	8028cd4 <bsp_time_delay>
 802a62e:	e7db      	b.n	802a5e8 <app_process+0x100>
	device_settings_t *p_dev_settings = ds_device_get_settings();

	uint32_t error = radar_apply_hw_settings(h_radar_device, p_dev_settings);
	if (error == RADAR_ERR_OK)
	{
		ds_device_settings_copy_to_shadow();
 802a630:	f7f5 fd7a 	bl	8020128 <ds_device_settings_copy_to_shadow>
 802a634:	e7d0      	b.n	802a5d8 <app_process+0xf0>
			radar_app_state = APP_CHECK_FOR_SETTINGS_UPDATE;
			break;

		case APP_CHECK_FOR_SETTINGS_UPDATE:
			/* Check if a new hardware settings are required */
			if (ds_is_device_parameter_changed() || ds_is_device_settings_updated())
 802a636:	f7f5 fd69 	bl	802010c <ds_is_device_settings_updated>
 802a63a:	2800      	cmp	r0, #0
 802a63c:	d1db      	bne.n	802a5f6 <app_process+0x10e>
 802a63e:	e7d3      	b.n	802a5e8 <app_process+0x100>
			{

				delayCount += 1;
				if (delayCount == 100)
				{
					send_device_status_response();
 802a640:	f7f9 f9e2 	bl	8023a08 <send_device_status_response>
					app_connected = 1;
 802a644:	2301      	movs	r3, #1
					delayCount = 0;
 802a646:	603e      	str	r6, [r7, #0]

				delayCount += 1;
				if (delayCount == 100)
				{
					send_device_status_response();
					app_connected = 1;
 802a648:	602b      	str	r3, [r5, #0]
 802a64a:	e7ec      	b.n	802a626 <app_process+0x13e>
 802a64c:	1ffedc14 	.word	0x1ffedc14
 802a650:	1ffedc4c 	.word	0x1ffedc4c
 802a654:	1ffedc40 	.word	0x1ffedc40
 802a658:	1ffedc38 	.word	0x1ffedc38
 802a65c:	1ffedc50 	.word	0x1ffedc50
 802a660:	1ffe9618 	.word	0x1ffe9618
 802a664:	1ffedc44 	.word	0x1ffedc44
 802a668:	1ffedc18 	.word	0x1ffedc18
 802a66c:	1ffedc48 	.word	0x1ffedc48
 802a670:	1ffedc34 	.word	0x1ffedc34
 802a674:	1ffedc3c 	.word	0x1ffedc3c

0802a678 <doppler_calc_speed>:

//============================================================================

void doppler_calc_speed(FFT_Window_Struct_t fft_window, float* if1_i, float* if1_q, uint16_t number_samples,
		                const algo_settings_t  *cp_algo_settings, const device_settings_t *cp_dev_settings, algo_result_t *p_algo_result)
{
 802a678:	b084      	sub	sp, #16
 802a67a:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 802a67e:	ed2d 8b04 	vpush	{d8-d9}
 802a682:	b08e      	sub	sp, #56	; 0x38
 802a684:	ac1a      	add	r4, sp, #104	; 0x68
 802a686:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
	uint8_t motion_approaching = 0U;
	float   doppler_frequency  = 0.0f;
	float   doppler_velocity   = 0.0f;
	float   doppler_level = 0.0f;

	compute_fft_signal(fft_window, if1_i, if1_q, number_samples, FFT_SIZE, 1.0,
 802a68a:	4c66      	ldr	r4, [pc, #408]	; (802a824 <doppler_calc_speed+0x1ac>)
 802a68c:	9409      	str	r4, [sp, #36]	; 0x24
 802a68e:	ad0d      	add	r5, sp, #52	; 0x34
 802a690:	ab1a      	add	r3, sp, #104	; 0x68
 802a692:	cb0f      	ldmia	r3, {r0, r1, r2, r3}

void doppler_calc_speed(FFT_Window_Struct_t fft_window, float* if1_i, float* if1_q, uint16_t number_samples,
		                const algo_settings_t  *cp_algo_settings, const device_settings_t *cp_dev_settings, algo_result_t *p_algo_result)
{
	uint32_t maxBin = 0;
	float maxVal = 0;
 802a694:	ed9f 8a64 	vldr	s16, [pc, #400]	; 802a828 <doppler_calc_speed+0x1b0>
	uint8_t motion_approaching = 0U;
	float   doppler_frequency  = 0.0f;
	float   doppler_velocity   = 0.0f;
	float   doppler_level = 0.0f;

	compute_fft_signal(fft_window, if1_i, if1_q, number_samples, FFT_SIZE, 1.0,
 802a698:	9508      	str	r5, [sp, #32]
 802a69a:	2703      	movs	r7, #3

//============================================================================

void doppler_calc_speed(FFT_Window_Struct_t fft_window, float* if1_i, float* if1_q, uint16_t number_samples,
		                const algo_settings_t  *cp_algo_settings, const device_settings_t *cp_dev_settings, algo_result_t *p_algo_result)
{
 802a69c:	f8bd 5084 	ldrh.w	r5, [sp, #132]	; 0x84
	uint8_t motion_approaching = 0U;
	float   doppler_frequency  = 0.0f;
	float   doppler_velocity   = 0.0f;
	float   doppler_level = 0.0f;

	compute_fft_signal(fft_window, if1_i, if1_q, number_samples, FFT_SIZE, 1.0,
 802a6a0:	9706      	str	r7, [sp, #24]
 802a6a2:	ae0c      	add	r6, sp, #48	; 0x30
 802a6a4:	f04f 5e7e 	mov.w	lr, #1065353216	; 0x3f800000
 802a6a8:	f44f 7a80 	mov.w	sl, #256	; 0x100

//============================================================================

void doppler_calc_speed(FFT_Window_Struct_t fft_window, float* if1_i, float* if1_q, uint16_t number_samples,
		                const algo_settings_t  *cp_algo_settings, const device_settings_t *cp_dev_settings, algo_result_t *p_algo_result)
{
 802a6ac:	9f1f      	ldr	r7, [sp, #124]	; 0x7c
	uint8_t motion_approaching = 0U;
	float   doppler_frequency  = 0.0f;
	float   doppler_velocity   = 0.0f;
	float   doppler_level = 0.0f;

	compute_fft_signal(fft_window, if1_i, if1_q, number_samples, FFT_SIZE, 1.0,
 802a6ae:	9607      	str	r6, [sp, #28]
 802a6b0:	9503      	str	r5, [sp, #12]

//============================================================================

void doppler_calc_speed(FFT_Window_Struct_t fft_window, float* if1_i, float* if1_q, uint16_t number_samples,
		                const algo_settings_t  *cp_algo_settings, const device_settings_t *cp_dev_settings, algo_result_t *p_algo_result)
{
 802a6b2:	9e20      	ldr	r6, [sp, #128]	; 0x80
	uint8_t motion_approaching = 0U;
	float   doppler_frequency  = 0.0f;
	float   doppler_velocity   = 0.0f;
	float   doppler_level = 0.0f;

	compute_fft_signal(fft_window, if1_i, if1_q, number_samples, FFT_SIZE, 1.0,
 802a6b4:	9d1e      	ldr	r5, [sp, #120]	; 0x78
 802a6b6:	f8cd e014 	str.w	lr, [sp, #20]
//============================================================================

void doppler_calc_speed(FFT_Window_Struct_t fft_window, float* if1_i, float* if1_q, uint16_t number_samples,
		                const algo_settings_t  *cp_algo_settings, const device_settings_t *cp_dev_settings, algo_result_t *p_algo_result)
{
	uint32_t maxBin = 0;
 802a6ba:	f04f 0800 	mov.w	r8, #0

//============================================================================

void doppler_calc_speed(FFT_Window_Struct_t fft_window, float* if1_i, float* if1_q, uint16_t number_samples,
		                const algo_settings_t  *cp_algo_settings, const device_settings_t *cp_dev_settings, algo_result_t *p_algo_result)
{
 802a6be:	f8dd 908c 	ldr.w	r9, [sp, #140]	; 0x8c
	uint8_t motion_approaching = 0U;
	float   doppler_frequency  = 0.0f;
	float   doppler_velocity   = 0.0f;
	float   doppler_level = 0.0f;

	compute_fft_signal(fft_window, if1_i, if1_q, number_samples, FFT_SIZE, 1.0,
 802a6c2:	9701      	str	r7, [sp, #4]
 802a6c4:	9602      	str	r6, [sp, #8]
 802a6c6:	9500      	str	r5, [sp, #0]

//============================================================================

void doppler_calc_speed(FFT_Window_Struct_t fft_window, float* if1_i, float* if1_q, uint16_t number_samples,
		                const algo_settings_t  *cp_algo_settings, const device_settings_t *cp_dev_settings, algo_result_t *p_algo_result)
{
 802a6c8:	9e22      	ldr	r6, [sp, #136]	; 0x88
	uint8_t motion_approaching = 0U;
	float   doppler_frequency  = 0.0f;
	float   doppler_velocity   = 0.0f;
	float   doppler_level = 0.0f;

	compute_fft_signal(fft_window, if1_i, if1_q, number_samples, FFT_SIZE, 1.0,
 802a6ca:	f8cd a010 	str.w	sl, [sp, #16]

void doppler_calc_speed(FFT_Window_Struct_t fft_window, float* if1_i, float* if1_q, uint16_t number_samples,
		                const algo_settings_t  *cp_algo_settings, const device_settings_t *cp_dev_settings, algo_result_t *p_algo_result)
{
	uint32_t maxBin = 0;
	float maxVal = 0;
 802a6ce:	ed8d 8a0b 	vstr	s16, [sp, #44]	; 0x2c
//============================================================================

void doppler_calc_speed(FFT_Window_Struct_t fft_window, float* if1_i, float* if1_q, uint16_t number_samples,
		                const algo_settings_t  *cp_algo_settings, const device_settings_t *cp_dev_settings, algo_result_t *p_algo_result)
{
	uint32_t maxBin = 0;
 802a6d2:	f8cd 8028 	str.w	r8, [sp, #40]	; 0x28

//============================================================================

void doppler_calc_speed(FFT_Window_Struct_t fft_window, float* if1_i, float* if1_q, uint16_t number_samples,
		                const algo_settings_t  *cp_algo_settings, const device_settings_t *cp_dev_settings, algo_result_t *p_algo_result)
{
 802a6d6:	9d24      	ldr	r5, [sp, #144]	; 0x90
	uint8_t motion_approaching = 0U;
	float   doppler_frequency  = 0.0f;
	float   doppler_velocity   = 0.0f;
	float   doppler_level = 0.0f;

	compute_fft_signal(fft_window, if1_i, if1_q, number_samples, FFT_SIZE, 1.0,
 802a6d8:	f7fd ffe6 	bl	80286a8 <compute_fft_signal>
			           FFT_INPUT_COMPLEX, &if1_real, &if1_imag, doppler_fft_signal);

	compute_fft_spectrum(doppler_fft_signal, FFT_SIZE, doppler_spectrum);
 802a6dc:	4651      	mov	r1, sl
 802a6de:	4622      	mov	r2, r4
 802a6e0:	4620      	mov	r0, r4
 802a6e2:	f7fe f8db 	bl	802889c <compute_fft_spectrum>

	doppler_spectrum[0] = 0; // remove DC from spectrum
 802a6e6:	ed84 8a00 	vstr	s16, [r4]
	doppler_spectrum[FFT_SIZE/2] = 0; // remove DC from middle bin
 802a6ea:	ed84 8a80 	vstr	s16, [r4, #512]	; 0x200

	uint32_t fft_min_check = (uint32_t) ceilf(cp_algo_settings->min_speed_kmph*44.4f*FFT_SIZE/cp_dev_settings->adc_sampling_freq_Hz);
 802a6ee:	ed96 7a03 	vldr	s14, [r6, #12]
 802a6f2:	eddf 7a4e 	vldr	s15, [pc, #312]	; 802a82c <doppler_calc_speed+0x1b4>
 802a6f6:	eddf 6a4e 	vldr	s13, [pc, #312]	; 802a830 <doppler_calc_speed+0x1b8>
 802a6fa:	ee67 7a27 	vmul.f32	s15, s14, s15
 802a6fe:	ed99 7a05 	vldr	s14, [r9, #20]
 802a702:	ee67 7aa6 	vmul.f32	s15, s15, s13
 802a706:	eeb8 7a47 	vcvt.f32.u32	s14, s14
 802a70a:	eec7 7a87 	vdiv.f32	s15, s15, s14
 802a70e:	ee17 0a90 	vmov	r0, s15
 802a712:	f000 f929 	bl	802a968 <ceilf>
 802a716:	ee07 0a90 	vmov	s15, r0
 802a71a:	eefc 7ae7 	vcvt.u32.f32	s15, s15

	uint32_t size_check = FFT_SIZE - 2*fft_min_check + 1;

	/* Calculates maxValue and returns corresponding BIN value */
	arm_max_f32(&doppler_spectrum[fft_min_check], size_check, &maxVal, &maxBin);
 802a71e:	aa0b      	add	r2, sp, #44	; 0x2c
	compute_fft_spectrum(doppler_fft_signal, FFT_SIZE, doppler_spectrum);

	doppler_spectrum[0] = 0; // remove DC from spectrum
	doppler_spectrum[FFT_SIZE/2] = 0; // remove DC from middle bin

	uint32_t fft_min_check = (uint32_t) ceilf(cp_algo_settings->min_speed_kmph*44.4f*FFT_SIZE/cp_dev_settings->adc_sampling_freq_Hz);
 802a720:	ee17 7a90 	vmov	r7, s15

	uint32_t size_check = FFT_SIZE - 2*fft_min_check + 1;
 802a724:	0079      	lsls	r1, r7, #1

	/* Calculates maxValue and returns corresponding BIN value */
	arm_max_f32(&doppler_spectrum[fft_min_check], size_check, &maxVal, &maxBin);
 802a726:	ebc1 010a 	rsb	r1, r1, sl
 802a72a:	ab0a      	add	r3, sp, #40	; 0x28
 802a72c:	eb04 0087 	add.w	r0, r4, r7, lsl #2
 802a730:	3101      	adds	r1, #1
 802a732:	f7fc ffef 	bl	8027714 <arm_max_f32>

	doppler_Hz_per_bin =  cp_dev_settings->adc_sampling_freq_Hz / (float)FFT_SIZE;

	doppler_level = maxVal;

	if (maxVal > (float) cp_algo_settings->speed_detection_threshold) // if the threshold is exceeded, we have a doppler event
 802a736:	edd6 7a02 	vldr	s15, [r6, #8]
	arm_max_f32(&doppler_spectrum[fft_min_check], size_check, &maxVal, &maxBin);
	maxBin += fft_min_check;

	doppler_Hz_per_bin =  cp_dev_settings->adc_sampling_freq_Hz / (float)FFT_SIZE;

	doppler_level = maxVal;
 802a73a:	ed9d 9a0b 	vldr	s18, [sp, #44]	; 0x2c

	uint32_t size_check = FFT_SIZE - 2*fft_min_check + 1;

	/* Calculates maxValue and returns corresponding BIN value */
	arm_max_f32(&doppler_spectrum[fft_min_check], size_check, &maxVal, &maxBin);
	maxBin += fft_min_check;
 802a73e:	9b0a      	ldr	r3, [sp, #40]	; 0x28

	doppler_Hz_per_bin =  cp_dev_settings->adc_sampling_freq_Hz / (float)FFT_SIZE;
 802a740:	f8d9 2014 	ldr.w	r2, [r9, #20]

	doppler_level = maxVal;

	if (maxVal > (float) cp_algo_settings->speed_detection_threshold) // if the threshold is exceeded, we have a doppler event
 802a744:	eeb4 9ae7 	vcmpe.f32	s18, s15

	uint32_t size_check = FFT_SIZE - 2*fft_min_check + 1;

	/* Calculates maxValue and returns corresponding BIN value */
	arm_max_f32(&doppler_spectrum[fft_min_check], size_check, &maxVal, &maxBin);
	maxBin += fft_min_check;
 802a748:	443b      	add	r3, r7

	doppler_Hz_per_bin =  cp_dev_settings->adc_sampling_freq_Hz / (float)FFT_SIZE;

	doppler_level = maxVal;

	if (maxVal > (float) cp_algo_settings->speed_detection_threshold) // if the threshold is exceeded, we have a doppler event
 802a74a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr

	uint32_t size_check = FFT_SIZE - 2*fft_min_check + 1;

	/* Calculates maxValue and returns corresponding BIN value */
	arm_max_f32(&doppler_spectrum[fft_min_check], size_check, &maxVal, &maxBin);
	maxBin += fft_min_check;
 802a74e:	930a      	str	r3, [sp, #40]	; 0x28

	doppler_Hz_per_bin =  cp_dev_settings->adc_sampling_freq_Hz / (float)FFT_SIZE;

	doppler_level = maxVal;

	if (maxVal > (float) cp_algo_settings->speed_detection_threshold) // if the threshold is exceeded, we have a doppler event
 802a750:	dd2c      	ble.n	802a7ac <doppler_calc_speed+0x134>
	{
		if (maxBin < FFT_SIZE / 2)
 802a752:	2b7f      	cmp	r3, #127	; 0x7f
 802a754:	d85d      	bhi.n	802a812 <doppler_calc_speed+0x19a>
	    {
			motion_departing = 1;
 802a756:	2701      	movs	r7, #1

	/* Calculates maxValue and returns corresponding BIN value */
	arm_max_f32(&doppler_spectrum[fft_min_check], size_check, &maxVal, &maxBin);
	maxBin += fft_min_check;

	doppler_Hz_per_bin =  cp_dev_settings->adc_sampling_freq_Hz / (float)FFT_SIZE;
 802a758:	ee08 2a90 	vmov	s17, r2
	    	motion_approaching = 1;

	    	maxBin = FFT_SIZE - maxBin;
	    }

		doppler_frequency =  maxBin * doppler_Hz_per_bin;
 802a75c:	ee07 3a90 	vmov	s15, r3

	/* Calculates maxValue and returns corresponding BIN value */
	arm_max_f32(&doppler_spectrum[fft_min_check], size_check, &maxVal, &maxBin);
	maxBin += fft_min_check;

	doppler_Hz_per_bin =  cp_dev_settings->adc_sampling_freq_Hz / (float)FFT_SIZE;
 802a760:	eefb 8acc 	vcvt.f32.u32	s17, s17, #8
	    	motion_approaching = 1;

	    	maxBin = FFT_SIZE - maxBin;
	    }

		doppler_frequency =  maxBin * doppler_Hz_per_bin;
 802a764:	eef8 7a67 	vcvt.f32.u32	s15, s15

		doppler_velocity  =  doppler_frequency / 44.4f;
 802a768:	ed9f 8a30 	vldr	s16, [pc, #192]	; 802a82c <doppler_calc_speed+0x1b4>

		if (doppler_velocity < cp_algo_settings->min_speed_kmph || doppler_velocity > cp_algo_settings->max_speed_kmph)
 802a76c:	ed96 7a03 	vldr	s14, [r6, #12]
	    	motion_approaching = 1;

	    	maxBin = FFT_SIZE - maxBin;
	    }

		doppler_frequency =  maxBin * doppler_Hz_per_bin;
 802a770:	ee67 8aa8 	vmul.f32	s17, s15, s17

		doppler_velocity  =  doppler_frequency / 44.4f;
 802a774:	ee88 8a88 	vdiv.f32	s16, s17, s16

		if (doppler_velocity < cp_algo_settings->min_speed_kmph || doppler_velocity > cp_algo_settings->max_speed_kmph)
 802a778:	eeb4 8ac7 	vcmpe.f32	s16, s14
 802a77c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802a780:	d410      	bmi.n	802a7a4 <doppler_calc_speed+0x12c>
 802a782:	edd6 7a04 	vldr	s15, [r6, #16]
 802a786:	eeb4 8ae7 	vcmpe.f32	s16, s15
 802a78a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802a78e:	dc09      	bgt.n	802a7a4 <doppler_calc_speed+0x12c>
			doppler_velocity = 0.0;
			motion_departing = 0;
			motion_approaching = 0;
		}

		if (motion_departing == 1 && doppler_velocity > 0)
 802a790:	2f00      	cmp	r7, #0
 802a792:	d045      	beq.n	802a820 <doppler_calc_speed+0x1a8>
 802a794:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 802a798:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802a79c:	dd09      	ble.n	802a7b2 <doppler_calc_speed+0x13a>
		{
			doppler_velocity  =  -doppler_velocity; // negate  speed for departing targets
 802a79e:	eeb1 8a48 	vneg.f32	s16, s16
 802a7a2:	e006      	b.n	802a7b2 <doppler_calc_speed+0x13a>
 802a7a4:	ed9f 8a20 	vldr	s16, [pc, #128]	; 802a828 <doppler_calc_speed+0x1b0>
 802a7a8:	f04f 0800 	mov.w	r8, #0
 802a7ac:	eef0 8a48 	vmov.f32	s17, s16
 802a7b0:	4647      	mov	r7, r8

		doppler_frequency = 0.0;
		doppler_velocity = 0.0;
	}

	if (maxVal > (float) cp_algo_settings->motion_detection_threshold) // if the threshold is exceeded, we have a doppler event
 802a7b2:	edd6 7a06 	vldr	s15, [r6, #24]
 802a7b6:	eeb4 9ae7 	vcmpe.f32	s18, s15
 802a7ba:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
	uint32_t maxBin = 0;
	float maxVal = 0;
	float doppler_Hz_per_bin;
	float if1_real, if1_imag;

	uint8_t motion_detected    = 0U;
 802a7be:	bfcc      	ite	gt
 802a7c0:	2201      	movgt	r2, #1
 802a7c2:	2200      	movle	r2, #0
	if (maxVal > (float) cp_algo_settings->motion_detection_threshold) // if the threshold is exceeded, we have a doppler event
	{
		motion_detected = 1;
	}

	if (p_algo_result)
 802a7c4:	b195      	cbz	r5, 802a7ec <doppler_calc_speed+0x174>
	{
		p_algo_result->motion_detected = motion_detected;
		/* Store processing results into result structure */

		if (p_algo_result->p_doppler_spectrum)
 802a7c6:	6928      	ldr	r0, [r5, #16]
		motion_detected = 1;
	}

	if (p_algo_result)
	{
		p_algo_result->motion_detected = motion_detected;
 802a7c8:	72aa      	strb	r2, [r5, #10]
		/* Store processing results into result structure */

		if (p_algo_result->p_doppler_spectrum)
 802a7ca:	b130      	cbz	r0, 802a7da <doppler_calc_speed+0x162>
		{
			if (maxBin > FFT_SIZE / 2) {
 802a7cc:	2b80      	cmp	r3, #128	; 0x80
 802a7ce:	d814      	bhi.n	802a7fa <doppler_calc_speed+0x182>
					doppler_spectrum[idx] = doppler_spectrum[FFT_SIZE - 1 - idx];
				}
			}

			/* transfer spectrum to result structure, if there is memory allocated for it */
			memcpy(p_algo_result->p_doppler_spectrum, doppler_spectrum, p_algo_result->doppler_spectrum_elems*sizeof(float));
 802a7d0:	696a      	ldr	r2, [r5, #20]
 802a7d2:	4914      	ldr	r1, [pc, #80]	; (802a824 <doppler_calc_speed+0x1ac>)
 802a7d4:	0092      	lsls	r2, r2, #2
 802a7d6:	f002 febb 	bl	802d550 <memcpy>
		}

		p_algo_result->level 					= doppler_level;
 802a7da:	ed85 9a01 	vstr	s18, [r5, #4]
		p_algo_result->doppler_frequency_hz		= doppler_frequency;
 802a7de:	edc5 8a03 	vstr	s17, [r5, #12]

		p_algo_result->velocity_kmph 			= doppler_velocity;
 802a7e2:	ed85 8a00 	vstr	s16, [r5]
		p_algo_result->target_departing 		= motion_departing;
 802a7e6:	722f      	strb	r7, [r5, #8]
		p_algo_result->target_approaching   	= motion_approaching;
 802a7e8:	f885 8009 	strb.w	r8, [r5, #9]
	}
}
 802a7ec:	b00e      	add	sp, #56	; 0x38
 802a7ee:	ecbd 8b04 	vpop	{d8-d9}
 802a7f2:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 802a7f6:	b004      	add	sp, #16
 802a7f8:	4770      	bx	lr
 802a7fa:	4b0e      	ldr	r3, [pc, #56]	; (802a834 <doppler_calc_speed+0x1bc>)
 802a7fc:	f5a3 6280 	sub.w	r2, r3, #1024	; 0x400
 802a800:	f502 7400 	add.w	r4, r2, #512	; 0x200
		{
			if (maxBin > FFT_SIZE / 2) {
				/* prepare spectrum to be copied to results */
				for (uint32_t idx = 0; idx < FFT_SIZE/2; idx++)
				{
					doppler_spectrum[idx] = doppler_spectrum[FFT_SIZE - 1 - idx];
 802a804:	f853 1d04 	ldr.w	r1, [r3, #-4]!
 802a808:	f842 1b04 	str.w	r1, [r2], #4

		if (p_algo_result->p_doppler_spectrum)
		{
			if (maxBin > FFT_SIZE / 2) {
				/* prepare spectrum to be copied to results */
				for (uint32_t idx = 0; idx < FFT_SIZE/2; idx++)
 802a80c:	42a3      	cmp	r3, r4
 802a80e:	d1f9      	bne.n	802a804 <doppler_calc_speed+0x18c>
 802a810:	e7de      	b.n	802a7d0 <doppler_calc_speed+0x158>
	    else
	    {
	    	motion_departing = 0;
	    	motion_approaching = 1;

	    	maxBin = FFT_SIZE - maxBin;
 802a812:	ebc3 030a 	rsb	r3, r3, sl
			motion_departing = 1;
			motion_approaching = 0;
	    }
	    else
	    {
	    	motion_departing = 0;
 802a816:	4647      	mov	r7, r8
	    	motion_approaching = 1;

	    	maxBin = FFT_SIZE - maxBin;
 802a818:	930a      	str	r3, [sp, #40]	; 0x28
			motion_approaching = 0;
	    }
	    else
	    {
	    	motion_departing = 0;
	    	motion_approaching = 1;
 802a81a:	f04f 0801 	mov.w	r8, #1
 802a81e:	e79b      	b.n	802a758 <doppler_calc_speed+0xe0>
 802a820:	2700      	movs	r7, #0
 802a822:	e7c6      	b.n	802a7b2 <doppler_calc_speed+0x13a>
 802a824:	1ffee054 	.word	0x1ffee054
 802a828:	00000000 	.word	0x00000000
 802a82c:	4231999a 	.word	0x4231999a
 802a830:	43800000 	.word	0x43800000
 802a834:	1ffee454 	.word	0x1ffee454

0802a838 <doppler_do>:
==============================================================================
 */

void doppler_do(acq_buf_obj *p_acq_buf, const algo_settings_t *cp_algo_settings,
				const device_settings_t *cp_dev_settings, algo_result_t *p_algo_result)
{
 802a838:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

	uint16_t *p_temp[BSP_NUM_OF_ADC_CHANNELS];
	uint16_t Ns = p_acq_buf->params.num_of_samples_per_chirp;

	/* Generate FFT window, it will be used for FFT calculation */
	if (fft_fast_window_flag != Ns)
 802a83c:	f8df a0fc 	ldr.w	sl, [pc, #252]	; 802a93c <doppler_do+0x104>
	/* allocated as static memory, not on call stack */
	static float raw_data_i1[BSP_MAX_NUM_SAMPLES_PER_CHIRP];
	static float raw_data_q1[BSP_MAX_NUM_SAMPLES_PER_CHIRP];

	uint16_t *p_temp[BSP_NUM_OF_ADC_CHANNELS];
	uint16_t Ns = p_acq_buf->params.num_of_samples_per_chirp;
 802a840:	8845      	ldrh	r5, [r0, #2]

	/* Generate FFT window, it will be used for FFT calculation */
	if (fft_fast_window_flag != Ns)
	{
		fft_fast_time_window.fft_window_length = Ns; /* Number of elements in the FFT window  */
 802a842:	4c3a      	ldr	r4, [pc, #232]	; (802a92c <doppler_do+0xf4>)
==============================================================================
 */

void doppler_do(acq_buf_obj *p_acq_buf, const algo_settings_t *cp_algo_settings,
				const device_settings_t *cp_dev_settings, algo_result_t *p_algo_result)
{
 802a844:	4606      	mov	r6, r0

	uint16_t *p_temp[BSP_NUM_OF_ADC_CHANNELS];
	uint16_t Ns = p_acq_buf->params.num_of_samples_per_chirp;

	/* Generate FFT window, it will be used for FFT calculation */
	if (fft_fast_window_flag != Ns)
 802a846:	f8da 0000 	ldr.w	r0, [sl]
 802a84a:	4285      	cmp	r5, r0
==============================================================================
 */

void doppler_do(acq_buf_obj *p_acq_buf, const algo_settings_t *cp_algo_settings,
				const device_settings_t *cp_dev_settings, algo_result_t *p_algo_result)
{
 802a84c:	b089      	sub	sp, #36	; 0x24
 802a84e:	460f      	mov	r7, r1
 802a850:	4691      	mov	r9, r2
 802a852:	4698      	mov	r8, r3

	uint16_t *p_temp[BSP_NUM_OF_ADC_CHANNELS];
	uint16_t Ns = p_acq_buf->params.num_of_samples_per_chirp;

	/* Generate FFT window, it will be used for FFT calculation */
	if (fft_fast_window_flag != Ns)
 802a854:	d007      	beq.n	802a866 <doppler_do+0x2e>
	{
		fft_fast_time_window.fft_window_length = Ns; /* Number of elements in the FFT window  */
		if (fft_window_gen(&fft_fast_time_window) == 0)
 802a856:	4620      	mov	r0, r4
	uint16_t Ns = p_acq_buf->params.num_of_samples_per_chirp;

	/* Generate FFT window, it will be used for FFT calculation */
	if (fft_fast_window_flag != Ns)
	{
		fft_fast_time_window.fft_window_length = Ns; /* Number of elements in the FFT window  */
 802a858:	6065      	str	r5, [r4, #4]
		if (fft_window_gen(&fft_fast_time_window) == 0)
 802a85a:	f7fd fced 	bl	8028238 <fft_window_gen>
 802a85e:	2800      	cmp	r0, #0
 802a860:	d057      	beq.n	802a912 <doppler_do+0xda>
		{
			XMC_DEBUG("Invalid FFT window parameters !\n");
			while (1);
		}
		fft_fast_window_flag = Ns;
 802a862:	f8ca 5000 	str.w	r5, [sl]
	}

	/* clear array values that are not acquired */
	memset(raw_data_i1, 0, sizeof(raw_data_i1));
 802a866:	2100      	movs	r1, #0
 802a868:	f44f 6280 	mov.w	r2, #1024	; 0x400
 802a86c:	4830      	ldr	r0, [pc, #192]	; (802a930 <doppler_do+0xf8>)
 802a86e:	f002 fe7a 	bl	802d566 <memset>
	memset(raw_data_q1, 0, sizeof(raw_data_q1));
 802a872:	4830      	ldr	r0, [pc, #192]	; (802a934 <doppler_do+0xfc>)
 802a874:	2100      	movs	r1, #0
 802a876:	f44f 6280 	mov.w	r2, #1024	; 0x400
 802a87a:	f002 fe74 	bl	802d566 <memset>

	if (cp_algo_settings->use_high_gain_doppler)
 802a87e:	f8d7 b014 	ldr.w	fp, [r7, #20]
 802a882:	f1bb 0f00 	cmp.w	fp, #0
 802a886:	d045      	beq.n	802a914 <doppler_do+0xdc>
	{
		/* Only one chirp for Doppler */
		p_temp[0] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 0, 0);
 802a888:	2100      	movs	r1, #0
 802a88a:	460a      	mov	r2, r1
 802a88c:	4630      	mov	r0, r6
 802a88e:	f7f5 ffd7 	bl	8020840 <get_buffer_address_by_chirp>
		p_temp[1] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 1, 0);
 802a892:	2101      	movs	r1, #1
	memset(raw_data_q1, 0, sizeof(raw_data_q1));

	if (cp_algo_settings->use_high_gain_doppler)
	{
		/* Only one chirp for Doppler */
		p_temp[0] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 0, 0);
 802a894:	4682      	mov	sl, r0
		p_temp[1] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 1, 0);
 802a896:	2200      	movs	r2, #0
 802a898:	4630      	mov	r0, r6
 802a89a:	f7f5 ffd1 	bl	8020840 <get_buffer_address_by_chirp>
 802a89e:	f8df c090 	ldr.w	ip, [pc, #144]	; 802a930 <doppler_do+0xf8>
 802a8a2:	f8df b090 	ldr.w	fp, [pc, #144]	; 802a934 <doppler_do+0xfc>
		/* Only one chirp for Doppler */
		p_temp[0] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 2, 0);
		p_temp[1] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 3, 0);
	}

	for (uint32_t i = 0; i < Ns; i++)
 802a8a6:	b1f5      	cbz	r5, 802a8e6 <doppler_do+0xae>
	{
		raw_data_i1[i] = (float)((p_temp[0])[i]) * if_scale;
 802a8a8:	eddf 6a23 	vldr	s13, [pc, #140]	; 802a938 <doppler_do+0x100>
 802a8ac:	1e82      	subs	r2, r0, #2
 802a8ae:	f1aa 0e02 	sub.w	lr, sl, #2
 802a8b2:	4663      	mov	r3, ip
 802a8b4:	eb0c 0085 	add.w	r0, ip, r5, lsl #2
 802a8b8:	4659      	mov	r1, fp
 802a8ba:	f83e af02 	ldrh.w	sl, [lr, #2]!
 802a8be:	ee07 aa10 	vmov	s14, sl
		raw_data_q1[i] = (float)((p_temp[1])[i]) * if_scale;
 802a8c2:	f832 af02 	ldrh.w	sl, [r2, #2]!
		p_temp[1] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 3, 0);
	}

	for (uint32_t i = 0; i < Ns; i++)
	{
		raw_data_i1[i] = (float)((p_temp[0])[i]) * if_scale;
 802a8c6:	eeb8 7a47 	vcvt.f32.u32	s14, s14
		raw_data_q1[i] = (float)((p_temp[1])[i]) * if_scale;
 802a8ca:	ee07 aa90 	vmov	s15, sl
		p_temp[1] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 3, 0);
	}

	for (uint32_t i = 0; i < Ns; i++)
	{
		raw_data_i1[i] = (float)((p_temp[0])[i]) * if_scale;
 802a8ce:	ee27 7a26 	vmul.f32	s14, s14, s13
		raw_data_q1[i] = (float)((p_temp[1])[i]) * if_scale;
 802a8d2:	eef8 7a67 	vcvt.f32.u32	s15, s15
		p_temp[1] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 3, 0);
	}

	for (uint32_t i = 0; i < Ns; i++)
	{
		raw_data_i1[i] = (float)((p_temp[0])[i]) * if_scale;
 802a8d6:	eca3 7a01 	vstmia	r3!, {s14}
		raw_data_q1[i] = (float)((p_temp[1])[i]) * if_scale;
 802a8da:	ee67 7aa6 	vmul.f32	s15, s15, s13
		/* Only one chirp for Doppler */
		p_temp[0] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 2, 0);
		p_temp[1] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 3, 0);
	}

	for (uint32_t i = 0; i < Ns; i++)
 802a8de:	4283      	cmp	r3, r0
	{
		raw_data_i1[i] = (float)((p_temp[0])[i]) * if_scale;
		raw_data_q1[i] = (float)((p_temp[1])[i]) * if_scale;
 802a8e0:	ece1 7a01 	vstmia	r1!, {s15}
		/* Only one chirp for Doppler */
		p_temp[0] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 2, 0);
		p_temp[1] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 3, 0);
	}

	for (uint32_t i = 0; i < Ns; i++)
 802a8e4:	d1e9      	bne.n	802a8ba <doppler_do+0x82>
	{
		raw_data_i1[i] = (float)((p_temp[0])[i]) * if_scale;
		raw_data_q1[i] = (float)((p_temp[1])[i]) * if_scale;
	}

	doppler_calc_speed(fft_fast_time_window, raw_data_i1, raw_data_q1, Ns, cp_algo_settings, cp_dev_settings, p_algo_result);
 802a8e6:	6923      	ldr	r3, [r4, #16]
 802a8e8:	9300      	str	r3, [sp, #0]
 802a8ea:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
 802a8ee:	f8cd c004 	str.w	ip, [sp, #4]
 802a8f2:	f8cd b008 	str.w	fp, [sp, #8]
 802a8f6:	9503      	str	r5, [sp, #12]
 802a8f8:	9704      	str	r7, [sp, #16]
 802a8fa:	f8cd 9014 	str.w	r9, [sp, #20]
 802a8fe:	f8cd 8018 	str.w	r8, [sp, #24]
 802a902:	f7ff feb9 	bl	802a678 <doppler_calc_speed>

	/* indicated, that the results are taken from dedicated frame */
	p_algo_result->frame_counter = p_acq_buf->frame_counter;
 802a906:	6b73      	ldr	r3, [r6, #52]	; 0x34
 802a908:	f8c8 3018 	str.w	r3, [r8, #24]
}
 802a90c:	b009      	add	sp, #36	; 0x24
 802a90e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	{
		fft_fast_time_window.fft_window_length = Ns; /* Number of elements in the FFT window  */
		if (fft_window_gen(&fft_fast_time_window) == 0)
		{
			XMC_DEBUG("Invalid FFT window parameters !\n");
			while (1);
 802a912:	e7fe      	b.n	802a912 <doppler_do+0xda>
		p_temp[1] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 1, 0);
	}
	else
	{
		/* Only one chirp for Doppler */
		p_temp[0] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 2, 0);
 802a914:	465a      	mov	r2, fp
 802a916:	4630      	mov	r0, r6
 802a918:	2102      	movs	r1, #2
 802a91a:	f7f5 ff91 	bl	8020840 <get_buffer_address_by_chirp>
		p_temp[1] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 3, 0);
 802a91e:	465a      	mov	r2, fp
		p_temp[1] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 1, 0);
	}
	else
	{
		/* Only one chirp for Doppler */
		p_temp[0] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 2, 0);
 802a920:	4682      	mov	sl, r0
		p_temp[1] = (uint16_t *)get_buffer_address_by_chirp(p_acq_buf, 3, 0);
 802a922:	2103      	movs	r1, #3
 802a924:	4630      	mov	r0, r6
 802a926:	f7f5 ff8b 	bl	8020840 <get_buffer_address_by_chirp>
 802a92a:	e7b8      	b.n	802a89e <doppler_do+0x66>
 802a92c:	1ffe961c 	.word	0x1ffe961c
 802a930:	1ffeec54 	.word	0x1ffeec54
 802a934:	1ffee854 	.word	0x1ffee854
 802a938:	3bd34067 	.word	0x3bd34067
 802a93c:	1ffef054 	.word	0x1ffef054

0802a940 <main>:
   2. MAIN METHOD
==============================================================================
 */

int main(void)
{
 802a940:	b508      	push	{r3, lr}
  DAVE_STATUS_t status;
  
  /* Initialize DAVE APPs */
  status = DAVE_Init();
 802a942:	f7fd fb53 	bl	8027fec <DAVE_Init>
  
  if (status != DAVE_STATUS_SUCCESS)
 802a946:	b100      	cbz	r0, 802a94a <main+0xa>
  {
    /* Placeholder for error handler code. The while loop below can be replaced with an user error handler. */
    XMC_DEBUG("DAVE APPs initialization failed\n");
    while (1U);
 802a948:	e7fe      	b.n	802a948 <main+0x8>
  }
  
  /* Register algorithm processing function:
     Set the algorithm processing function pointer, it will
     be used by the application for algorithm data processing */
    app_register_algo_process(doppler_do);
 802a94a:	4804      	ldr	r0, [pc, #16]	; (802a95c <main+0x1c>)
 802a94c:	f7ff fc92 	bl	802a274 <app_register_algo_process>

  /* Initialize the application */
  app_init();
 802a950:	f7ff fbfc 	bl	802a14c <app_init>
  
  /* Infinite loop */
  while (1U)
  {
    /* Main application process */
    app_process();
 802a954:	f7ff fdc8 	bl	802a4e8 <app_process>
  }
 802a958:	e7fc      	b.n	802a954 <main+0x14>
 802a95a:	bf00      	nop
 802a95c:	0802a839 	.word	0x0802a839

0802a960 <acq_completed_cb>:
}

void acq_completed_cb(void)
{
 802a960:	4770      	bx	lr
 802a962:	bf00      	nop

0802a964 <algo_completed_cb>:
  
  */
}

void algo_completed_cb(void)
{
 802a964:	4770      	bx	lr
 802a966:	bf00      	nop

0802a968 <ceilf>:
 802a968:	b410      	push	{r4}
 802a96a:	b083      	sub	sp, #12
 802a96c:	9001      	str	r0, [sp, #4]
 802a96e:	9a01      	ldr	r2, [sp, #4]
 802a970:	f022 4100 	bic.w	r1, r2, #2147483648	; 0x80000000
 802a974:	0dcb      	lsrs	r3, r1, #23
 802a976:	3b7f      	subs	r3, #127	; 0x7f
 802a978:	2b16      	cmp	r3, #22
 802a97a:	dc1e      	bgt.n	802a9ba <ceilf+0x52>
 802a97c:	2b00      	cmp	r3, #0
 802a97e:	4614      	mov	r4, r2
 802a980:	db2d      	blt.n	802a9de <ceilf+0x76>
 802a982:	4824      	ldr	r0, [pc, #144]	; (802aa14 <ceilf+0xac>)
 802a984:	4118      	asrs	r0, r3
 802a986:	4210      	tst	r0, r2
 802a988:	d01a      	beq.n	802a9c0 <ceilf+0x58>
 802a98a:	eddf 7a23 	vldr	s15, [pc, #140]	; 802aa18 <ceilf+0xb0>
 802a98e:	ed9d 7a01 	vldr	s14, [sp, #4]
 802a992:	ee77 7a27 	vadd.f32	s15, s14, s15
 802a996:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 802a99a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802a99e:	dd32      	ble.n	802aa06 <ceilf+0x9e>
 802a9a0:	2a00      	cmp	r2, #0
 802a9a2:	dd04      	ble.n	802a9ae <ceilf+0x46>
 802a9a4:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
 802a9a8:	fa42 f303 	asr.w	r3, r2, r3
 802a9ac:	441c      	add	r4, r3
 802a9ae:	ea24 0000 	bic.w	r0, r4, r0
 802a9b2:	b003      	add	sp, #12
 802a9b4:	f85d 4b04 	ldr.w	r4, [sp], #4
 802a9b8:	4770      	bx	lr
 802a9ba:	f1b1 4fff 	cmp.w	r1, #2139095040	; 0x7f800000
 802a9be:	d204      	bcs.n	802a9ca <ceilf+0x62>
 802a9c0:	9801      	ldr	r0, [sp, #4]
 802a9c2:	b003      	add	sp, #12
 802a9c4:	f85d 4b04 	ldr.w	r4, [sp], #4
 802a9c8:	4770      	bx	lr
 802a9ca:	eddd 7a01 	vldr	s15, [sp, #4]
 802a9ce:	ee77 7aa7 	vadd.f32	s15, s15, s15
 802a9d2:	ee17 0a90 	vmov	r0, s15
 802a9d6:	b003      	add	sp, #12
 802a9d8:	f85d 4b04 	ldr.w	r4, [sp], #4
 802a9dc:	4770      	bx	lr
 802a9de:	eddf 7a0e 	vldr	s15, [pc, #56]	; 802aa18 <ceilf+0xb0>
 802a9e2:	ee07 0a10 	vmov	s14, r0
 802a9e6:	ee77 7a27 	vadd.f32	s15, s14, s15
 802a9ea:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 802a9ee:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802a9f2:	dde5      	ble.n	802a9c0 <ceilf+0x58>
 802a9f4:	2a00      	cmp	r2, #0
 802a9f6:	db09      	blt.n	802aa0c <ceilf+0xa4>
 802a9f8:	2900      	cmp	r1, #0
 802a9fa:	eef7 7a00 	vmov.f32	s15, #112	; 0x70
 802a9fe:	bf18      	it	ne
 802aa00:	ee17 0a90 	vmovne	r0, s15
 802aa04:	e7dd      	b.n	802a9c2 <ceilf+0x5a>
 802aa06:	ee17 0a10 	vmov	r0, s14
 802aa0a:	e7da      	b.n	802a9c2 <ceilf+0x5a>
 802aa0c:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
 802aa10:	e7d7      	b.n	802a9c2 <ceilf+0x5a>
 802aa12:	bf00      	nop
 802aa14:	007fffff 	.word	0x007fffff
 802aa18:	7149f2ca 	.word	0x7149f2ca

0802aa1c <acosf>:
 802aa1c:	b570      	push	{r4, r5, r6, lr}
 802aa1e:	4d25      	ldr	r5, [pc, #148]	; (802aab4 <acosf+0x98>)
 802aa20:	b08a      	sub	sp, #40	; 0x28
 802aa22:	4606      	mov	r6, r0
 802aa24:	f000 fae8 	bl	802aff8 <__ieee754_acosf>
 802aa28:	f995 3000 	ldrsb.w	r3, [r5]
 802aa2c:	3301      	adds	r3, #1
 802aa2e:	4604      	mov	r4, r0
 802aa30:	d003      	beq.n	802aa3a <acosf+0x1e>
 802aa32:	4630      	mov	r0, r6
 802aa34:	f001 fc24 	bl	802c280 <__fpclassifyf>
 802aa38:	b910      	cbnz	r0, 802aa40 <acosf+0x24>
 802aa3a:	4620      	mov	r0, r4
 802aa3c:	b00a      	add	sp, #40	; 0x28
 802aa3e:	bd70      	pop	{r4, r5, r6, pc}
 802aa40:	4630      	mov	r0, r6
 802aa42:	f001 fc11 	bl	802c268 <fabsf>
 802aa46:	ee07 0a10 	vmov	s14, r0
 802aa4a:	eef7 7a00 	vmov.f32	s15, #112	; 0x70
 802aa4e:	eeb4 7ae7 	vcmpe.f32	s14, s15
 802aa52:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802aa56:	ddf0      	ble.n	802aa3a <acosf+0x1e>
 802aa58:	2301      	movs	r3, #1
 802aa5a:	4a17      	ldr	r2, [pc, #92]	; (802aab8 <acosf+0x9c>)
 802aa5c:	9300      	str	r3, [sp, #0]
 802aa5e:	4630      	mov	r0, r6
 802aa60:	2300      	movs	r3, #0
 802aa62:	9201      	str	r2, [sp, #4]
 802aa64:	9308      	str	r3, [sp, #32]
 802aa66:	f001 ff33 	bl	802c8d0 <__aeabi_f2d>
 802aa6a:	4602      	mov	r2, r0
 802aa6c:	460b      	mov	r3, r1
 802aa6e:	4813      	ldr	r0, [pc, #76]	; (802aabc <acosf+0xa0>)
 802aa70:	e9cd 2304 	strd	r2, r3, [sp, #16]
 802aa74:	e9cd 2302 	strd	r2, r3, [sp, #8]
 802aa78:	f001 fa20 	bl	802bebc <nan>
 802aa7c:	f995 3000 	ldrsb.w	r3, [r5]
 802aa80:	2b02      	cmp	r3, #2
 802aa82:	e9cd 0106 	strd	r0, r1, [sp, #24]
 802aa86:	d00b      	beq.n	802aaa0 <acosf+0x84>
 802aa88:	4668      	mov	r0, sp
 802aa8a:	f001 fa15 	bl	802beb8 <matherr>
 802aa8e:	b138      	cbz	r0, 802aaa0 <acosf+0x84>
 802aa90:	9b08      	ldr	r3, [sp, #32]
 802aa92:	b953      	cbnz	r3, 802aaaa <acosf+0x8e>
 802aa94:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 802aa98:	f002 fa28 	bl	802ceec <__aeabi_d2f>
 802aa9c:	b00a      	add	sp, #40	; 0x28
 802aa9e:	bd70      	pop	{r4, r5, r6, pc}
 802aaa0:	f002 fd40 	bl	802d524 <__errno>
 802aaa4:	2321      	movs	r3, #33	; 0x21
 802aaa6:	6003      	str	r3, [r0, #0]
 802aaa8:	e7f2      	b.n	802aa90 <acosf+0x74>
 802aaaa:	f002 fd3b 	bl	802d524 <__errno>
 802aaae:	9b08      	ldr	r3, [sp, #32]
 802aab0:	6003      	str	r3, [r0, #0]
 802aab2:	e7ef      	b.n	802aa94 <acosf+0x78>
 802aab4:	1ffe9630 	.word	0x1ffe9630
 802aab8:	080319c4 	.word	0x080319c4
 802aabc:	0802f31c 	.word	0x0802f31c

0802aac0 <acoshf>:
 802aac0:	b5f0      	push	{r4, r5, r6, r7, lr}
 802aac2:	ed2d 8b02 	vpush	{d8}
 802aac6:	4d28      	ldr	r5, [pc, #160]	; (802ab68 <acoshf+0xa8>)
 802aac8:	b08b      	sub	sp, #44	; 0x2c
 802aaca:	ee08 0a10 	vmov	s16, r0
 802aace:	f000 fbbd 	bl	802b24c <__ieee754_acoshf>
 802aad2:	f995 3000 	ldrsb.w	r3, [r5]
 802aad6:	3301      	adds	r3, #1
 802aad8:	4604      	mov	r4, r0
 802aada:	d00b      	beq.n	802aaf4 <acoshf+0x34>
 802aadc:	ee18 0a10 	vmov	r0, s16
 802aae0:	f001 fbce 	bl	802c280 <__fpclassifyf>
 802aae4:	b130      	cbz	r0, 802aaf4 <acoshf+0x34>
 802aae6:	eef7 7a00 	vmov.f32	s15, #112	; 0x70
 802aaea:	eeb4 8ae7 	vcmpe.f32	s16, s15
 802aaee:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802aaf2:	d404      	bmi.n	802aafe <acoshf+0x3e>
 802aaf4:	4620      	mov	r0, r4
 802aaf6:	b00b      	add	sp, #44	; 0x2c
 802aaf8:	ecbd 8b02 	vpop	{d8}
 802aafc:	bdf0      	pop	{r4, r5, r6, r7, pc}
 802aafe:	2301      	movs	r3, #1
 802ab00:	4a1a      	ldr	r2, [pc, #104]	; (802ab6c <acoshf+0xac>)
 802ab02:	9300      	str	r3, [sp, #0]
 802ab04:	ee18 0a10 	vmov	r0, s16
 802ab08:	2300      	movs	r3, #0
 802ab0a:	9201      	str	r2, [sp, #4]
 802ab0c:	9308      	str	r3, [sp, #32]
 802ab0e:	f001 fedf 	bl	802c8d0 <__aeabi_f2d>
 802ab12:	4606      	mov	r6, r0
 802ab14:	460f      	mov	r7, r1
 802ab16:	2000      	movs	r0, #0
 802ab18:	2100      	movs	r1, #0
 802ab1a:	460b      	mov	r3, r1
 802ab1c:	4602      	mov	r2, r0
 802ab1e:	e9cd 6704 	strd	r6, r7, [sp, #16]
 802ab22:	e9cd 6702 	strd	r6, r7, [sp, #8]
 802ab26:	f002 f851 	bl	802cbcc <__aeabi_ddiv>
 802ab2a:	f995 3000 	ldrsb.w	r3, [r5]
 802ab2e:	2b02      	cmp	r3, #2
 802ab30:	e9cd 0106 	strd	r0, r1, [sp, #24]
 802ab34:	d00d      	beq.n	802ab52 <acoshf+0x92>
 802ab36:	4668      	mov	r0, sp
 802ab38:	f001 f9be 	bl	802beb8 <matherr>
 802ab3c:	b148      	cbz	r0, 802ab52 <acoshf+0x92>
 802ab3e:	9b08      	ldr	r3, [sp, #32]
 802ab40:	b963      	cbnz	r3, 802ab5c <acoshf+0x9c>
 802ab42:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 802ab46:	f002 f9d1 	bl	802ceec <__aeabi_d2f>
 802ab4a:	b00b      	add	sp, #44	; 0x2c
 802ab4c:	ecbd 8b02 	vpop	{d8}
 802ab50:	bdf0      	pop	{r4, r5, r6, r7, pc}
 802ab52:	f002 fce7 	bl	802d524 <__errno>
 802ab56:	2321      	movs	r3, #33	; 0x21
 802ab58:	6003      	str	r3, [r0, #0]
 802ab5a:	e7f0      	b.n	802ab3e <acoshf+0x7e>
 802ab5c:	f002 fce2 	bl	802d524 <__errno>
 802ab60:	9b08      	ldr	r3, [sp, #32]
 802ab62:	6003      	str	r3, [r0, #0]
 802ab64:	e7ed      	b.n	802ab42 <acoshf+0x82>
 802ab66:	bf00      	nop
 802ab68:	1ffe9630 	.word	0x1ffe9630
 802ab6c:	080319cc 	.word	0x080319cc

0802ab70 <coshf>:
 802ab70:	b570      	push	{r4, r5, r6, lr}
 802ab72:	4d26      	ldr	r5, [pc, #152]	; (802ac0c <coshf+0x9c>)
 802ab74:	b08a      	sub	sp, #40	; 0x28
 802ab76:	4606      	mov	r6, r0
 802ab78:	f000 fbd2 	bl	802b320 <__ieee754_coshf>
 802ab7c:	f995 3000 	ldrsb.w	r3, [r5]
 802ab80:	3301      	adds	r3, #1
 802ab82:	4604      	mov	r4, r0
 802ab84:	d003      	beq.n	802ab8e <coshf+0x1e>
 802ab86:	4630      	mov	r0, r6
 802ab88:	f001 fb7a 	bl	802c280 <__fpclassifyf>
 802ab8c:	b910      	cbnz	r0, 802ab94 <coshf+0x24>
 802ab8e:	4620      	mov	r0, r4
 802ab90:	b00a      	add	sp, #40	; 0x28
 802ab92:	bd70      	pop	{r4, r5, r6, pc}
 802ab94:	4630      	mov	r0, r6
 802ab96:	f001 fb67 	bl	802c268 <fabsf>
 802ab9a:	eddf 7a1d 	vldr	s15, [pc, #116]	; 802ac10 <coshf+0xa0>
 802ab9e:	ee07 0a10 	vmov	s14, r0
 802aba2:	eeb4 7ae7 	vcmpe.f32	s14, s15
 802aba6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802abaa:	ddf0      	ble.n	802ab8e <coshf+0x1e>
 802abac:	2303      	movs	r3, #3
 802abae:	4a19      	ldr	r2, [pc, #100]	; (802ac14 <coshf+0xa4>)
 802abb0:	9300      	str	r3, [sp, #0]
 802abb2:	4630      	mov	r0, r6
 802abb4:	2300      	movs	r3, #0
 802abb6:	9308      	str	r3, [sp, #32]
 802abb8:	9201      	str	r2, [sp, #4]
 802abba:	f001 fe89 	bl	802c8d0 <__aeabi_f2d>
 802abbe:	782b      	ldrb	r3, [r5, #0]
 802abc0:	e9cd 0104 	strd	r0, r1, [sp, #16]
 802abc4:	e9cd 0102 	strd	r0, r1, [sp, #8]
 802abc8:	b983      	cbnz	r3, 802abec <coshf+0x7c>
 802abca:	4b13      	ldr	r3, [pc, #76]	; (802ac18 <coshf+0xa8>)
 802abcc:	f04f 4260 	mov.w	r2, #3758096384	; 0xe0000000
 802abd0:	e9cd 2306 	strd	r2, r3, [sp, #24]
 802abd4:	4668      	mov	r0, sp
 802abd6:	f001 f96f 	bl	802beb8 <matherr>
 802abda:	b168      	cbz	r0, 802abf8 <coshf+0x88>
 802abdc:	9b08      	ldr	r3, [sp, #32]
 802abde:	b983      	cbnz	r3, 802ac02 <coshf+0x92>
 802abe0:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 802abe4:	f002 f982 	bl	802ceec <__aeabi_d2f>
 802abe8:	b00a      	add	sp, #40	; 0x28
 802abea:	bd70      	pop	{r4, r5, r6, pc}
 802abec:	490b      	ldr	r1, [pc, #44]	; (802ac1c <coshf+0xac>)
 802abee:	2000      	movs	r0, #0
 802abf0:	2b02      	cmp	r3, #2
 802abf2:	e9cd 0106 	strd	r0, r1, [sp, #24]
 802abf6:	d1ed      	bne.n	802abd4 <coshf+0x64>
 802abf8:	f002 fc94 	bl	802d524 <__errno>
 802abfc:	2322      	movs	r3, #34	; 0x22
 802abfe:	6003      	str	r3, [r0, #0]
 802ac00:	e7ec      	b.n	802abdc <coshf+0x6c>
 802ac02:	f002 fc8f 	bl	802d524 <__errno>
 802ac06:	9b08      	ldr	r3, [sp, #32]
 802ac08:	6003      	str	r3, [r0, #0]
 802ac0a:	e7e9      	b.n	802abe0 <coshf+0x70>
 802ac0c:	1ffe9630 	.word	0x1ffe9630
 802ac10:	42b2d4fc 	.word	0x42b2d4fc
 802ac14:	080319d4 	.word	0x080319d4
 802ac18:	47efffff 	.word	0x47efffff
 802ac1c:	7ff00000 	.word	0x7ff00000

0802ac20 <powf>:
 802ac20:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 802ac24:	4d9f      	ldr	r5, [pc, #636]	; (802aea4 <powf+0x284>)
 802ac26:	b08a      	sub	sp, #40	; 0x28
 802ac28:	4607      	mov	r7, r0
 802ac2a:	460e      	mov	r6, r1
 802ac2c:	f000 fde8 	bl	802b800 <__ieee754_powf>
 802ac30:	f995 3000 	ldrsb.w	r3, [r5]
 802ac34:	3301      	adds	r3, #1
 802ac36:	4604      	mov	r4, r0
 802ac38:	d003      	beq.n	802ac42 <powf+0x22>
 802ac3a:	4630      	mov	r0, r6
 802ac3c:	f001 fb20 	bl	802c280 <__fpclassifyf>
 802ac40:	b918      	cbnz	r0, 802ac4a <powf+0x2a>
 802ac42:	4620      	mov	r0, r4
 802ac44:	b00a      	add	sp, #40	; 0x28
 802ac46:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802ac4a:	4638      	mov	r0, r7
 802ac4c:	f001 fb18 	bl	802c280 <__fpclassifyf>
 802ac50:	4603      	mov	r3, r0
 802ac52:	2800      	cmp	r0, #0
 802ac54:	d132      	bne.n	802acbc <powf+0x9c>
 802ac56:	ee07 6a90 	vmov	s15, r6
 802ac5a:	eef5 7a40 	vcmp.f32	s15, #0.0
 802ac5e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802ac62:	d1ee      	bne.n	802ac42 <powf+0x22>
 802ac64:	4a90      	ldr	r2, [pc, #576]	; (802aea8 <powf+0x288>)
 802ac66:	9308      	str	r3, [sp, #32]
 802ac68:	4638      	mov	r0, r7
 802ac6a:	2101      	movs	r1, #1
 802ac6c:	e88d 0006 	stmia.w	sp, {r1, r2}
 802ac70:	f001 fe2e 	bl	802c8d0 <__aeabi_f2d>
 802ac74:	e9cd 0102 	strd	r0, r1, [sp, #8]
 802ac78:	4630      	mov	r0, r6
 802ac7a:	f001 fe29 	bl	802c8d0 <__aeabi_f2d>
 802ac7e:	f995 3000 	ldrsb.w	r3, [r5]
 802ac82:	4f8a      	ldr	r7, [pc, #552]	; (802aeac <powf+0x28c>)
 802ac84:	2600      	movs	r6, #0
 802ac86:	1c5a      	adds	r2, r3, #1
 802ac88:	e9cd 0104 	strd	r0, r1, [sp, #16]
 802ac8c:	e9cd 6706 	strd	r6, r7, [sp, #24]
 802ac90:	d00d      	beq.n	802acae <powf+0x8e>
 802ac92:	2b02      	cmp	r3, #2
 802ac94:	d00b      	beq.n	802acae <powf+0x8e>
 802ac96:	4668      	mov	r0, sp
 802ac98:	f001 f90e 	bl	802beb8 <matherr>
 802ac9c:	2800      	cmp	r0, #0
 802ac9e:	f000 809e 	beq.w	802adde <powf+0x1be>
 802aca2:	9b08      	ldr	r3, [sp, #32]
 802aca4:	b11b      	cbz	r3, 802acae <powf+0x8e>
 802aca6:	f002 fc3d 	bl	802d524 <__errno>
 802acaa:	9b08      	ldr	r3, [sp, #32]
 802acac:	6003      	str	r3, [r0, #0]
 802acae:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 802acb2:	f002 f91b 	bl	802ceec <__aeabi_d2f>
 802acb6:	b00a      	add	sp, #40	; 0x28
 802acb8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802acbc:	ee07 7a90 	vmov	s15, r7
 802acc0:	eef5 7a40 	vcmp.f32	s15, #0.0
 802acc4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802acc8:	d123      	bne.n	802ad12 <powf+0xf2>
 802acca:	ee07 6a90 	vmov	s15, r6
 802acce:	eef5 7a40 	vcmp.f32	s15, #0.0
 802acd2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802acd6:	d156      	bne.n	802ad86 <powf+0x166>
 802acd8:	2301      	movs	r3, #1
 802acda:	4a73      	ldr	r2, [pc, #460]	; (802aea8 <powf+0x288>)
 802acdc:	9300      	str	r3, [sp, #0]
 802acde:	4638      	mov	r0, r7
 802ace0:	2300      	movs	r3, #0
 802ace2:	9308      	str	r3, [sp, #32]
 802ace4:	9201      	str	r2, [sp, #4]
 802ace6:	f001 fdf3 	bl	802c8d0 <__aeabi_f2d>
 802acea:	e9cd 0102 	strd	r0, r1, [sp, #8]
 802acee:	4630      	mov	r0, r6
 802acf0:	f001 fdee 	bl	802c8d0 <__aeabi_f2d>
 802acf4:	f995 3000 	ldrsb.w	r3, [r5]
 802acf8:	2600      	movs	r6, #0
 802acfa:	2700      	movs	r7, #0
 802acfc:	e9cd 0104 	strd	r0, r1, [sp, #16]
 802ad00:	e9cd 6706 	strd	r6, r7, [sp, #24]
 802ad04:	2b00      	cmp	r3, #0
 802ad06:	d0c6      	beq.n	802ac96 <powf+0x76>
 802ad08:	4b68      	ldr	r3, [pc, #416]	; (802aeac <powf+0x28c>)
 802ad0a:	2200      	movs	r2, #0
 802ad0c:	e9cd 2306 	strd	r2, r3, [sp, #24]
 802ad10:	e7cd      	b.n	802acae <powf+0x8e>
 802ad12:	4620      	mov	r0, r4
 802ad14:	f001 faac 	bl	802c270 <finitef>
 802ad18:	4680      	mov	r8, r0
 802ad1a:	2800      	cmp	r0, #0
 802ad1c:	d064      	beq.n	802ade8 <powf+0x1c8>
 802ad1e:	ee07 4a90 	vmov	s15, r4
 802ad22:	eef5 7a40 	vcmp.f32	s15, #0.0
 802ad26:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802ad2a:	d18a      	bne.n	802ac42 <powf+0x22>
 802ad2c:	4638      	mov	r0, r7
 802ad2e:	f001 fa9f 	bl	802c270 <finitef>
 802ad32:	2800      	cmp	r0, #0
 802ad34:	d085      	beq.n	802ac42 <powf+0x22>
 802ad36:	4630      	mov	r0, r6
 802ad38:	f001 fa9a 	bl	802c270 <finitef>
 802ad3c:	2800      	cmp	r0, #0
 802ad3e:	d080      	beq.n	802ac42 <powf+0x22>
 802ad40:	2304      	movs	r3, #4
 802ad42:	4a59      	ldr	r2, [pc, #356]	; (802aea8 <powf+0x288>)
 802ad44:	9300      	str	r3, [sp, #0]
 802ad46:	4638      	mov	r0, r7
 802ad48:	2300      	movs	r3, #0
 802ad4a:	9308      	str	r3, [sp, #32]
 802ad4c:	9201      	str	r2, [sp, #4]
 802ad4e:	f001 fdbf 	bl	802c8d0 <__aeabi_f2d>
 802ad52:	e9cd 0102 	strd	r0, r1, [sp, #8]
 802ad56:	4630      	mov	r0, r6
 802ad58:	f001 fdba 	bl	802c8d0 <__aeabi_f2d>
 802ad5c:	f995 3000 	ldrsb.w	r3, [r5]
 802ad60:	2600      	movs	r6, #0
 802ad62:	2700      	movs	r7, #0
 802ad64:	2b02      	cmp	r3, #2
 802ad66:	e9cd 0104 	strd	r0, r1, [sp, #16]
 802ad6a:	e9cd 6706 	strd	r6, r7, [sp, #24]
 802ad6e:	f000 8094 	beq.w	802ae9a <powf+0x27a>
 802ad72:	4668      	mov	r0, sp
 802ad74:	f001 f8a0 	bl	802beb8 <matherr>
 802ad78:	2800      	cmp	r0, #0
 802ad7a:	f000 808e 	beq.w	802ae9a <powf+0x27a>
 802ad7e:	9b08      	ldr	r3, [sp, #32]
 802ad80:	2b00      	cmp	r3, #0
 802ad82:	d094      	beq.n	802acae <powf+0x8e>
 802ad84:	e78f      	b.n	802aca6 <powf+0x86>
 802ad86:	4630      	mov	r0, r6
 802ad88:	f001 fa72 	bl	802c270 <finitef>
 802ad8c:	2800      	cmp	r0, #0
 802ad8e:	f43f af58 	beq.w	802ac42 <powf+0x22>
 802ad92:	ee07 6a90 	vmov	s15, r6
 802ad96:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 802ad9a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802ad9e:	f57f af50 	bpl.w	802ac42 <powf+0x22>
 802ada2:	2301      	movs	r3, #1
 802ada4:	4a40      	ldr	r2, [pc, #256]	; (802aea8 <powf+0x288>)
 802ada6:	9300      	str	r3, [sp, #0]
 802ada8:	4638      	mov	r0, r7
 802adaa:	2300      	movs	r3, #0
 802adac:	9308      	str	r3, [sp, #32]
 802adae:	9201      	str	r2, [sp, #4]
 802adb0:	f001 fd8e 	bl	802c8d0 <__aeabi_f2d>
 802adb4:	e9cd 0102 	strd	r0, r1, [sp, #8]
 802adb8:	4630      	mov	r0, r6
 802adba:	f001 fd89 	bl	802c8d0 <__aeabi_f2d>
 802adbe:	782b      	ldrb	r3, [r5, #0]
 802adc0:	e9cd 0104 	strd	r0, r1, [sp, #16]
 802adc4:	2b00      	cmp	r3, #0
 802adc6:	d03f      	beq.n	802ae48 <powf+0x228>
 802adc8:	4939      	ldr	r1, [pc, #228]	; (802aeb0 <powf+0x290>)
 802adca:	2000      	movs	r0, #0
 802adcc:	2b02      	cmp	r3, #2
 802adce:	e9cd 0106 	strd	r0, r1, [sp, #24]
 802add2:	d133      	bne.n	802ae3c <powf+0x21c>
 802add4:	f002 fba6 	bl	802d524 <__errno>
 802add8:	2321      	movs	r3, #33	; 0x21
 802adda:	6003      	str	r3, [r0, #0]
 802addc:	e7cf      	b.n	802ad7e <powf+0x15e>
 802adde:	f002 fba1 	bl	802d524 <__errno>
 802ade2:	2321      	movs	r3, #33	; 0x21
 802ade4:	6003      	str	r3, [r0, #0]
 802ade6:	e75c      	b.n	802aca2 <powf+0x82>
 802ade8:	4638      	mov	r0, r7
 802adea:	f001 fa41 	bl	802c270 <finitef>
 802adee:	2800      	cmp	r0, #0
 802adf0:	d095      	beq.n	802ad1e <powf+0xfe>
 802adf2:	4630      	mov	r0, r6
 802adf4:	f001 fa3c 	bl	802c270 <finitef>
 802adf8:	2800      	cmp	r0, #0
 802adfa:	d090      	beq.n	802ad1e <powf+0xfe>
 802adfc:	4620      	mov	r0, r4
 802adfe:	f001 fa3f 	bl	802c280 <__fpclassifyf>
 802ae02:	4603      	mov	r3, r0
 802ae04:	bb28      	cbnz	r0, 802ae52 <powf+0x232>
 802ae06:	4a28      	ldr	r2, [pc, #160]	; (802aea8 <powf+0x288>)
 802ae08:	9308      	str	r3, [sp, #32]
 802ae0a:	2101      	movs	r1, #1
 802ae0c:	4638      	mov	r0, r7
 802ae0e:	e88d 0006 	stmia.w	sp, {r1, r2}
 802ae12:	f001 fd5d 	bl	802c8d0 <__aeabi_f2d>
 802ae16:	e9cd 0102 	strd	r0, r1, [sp, #8]
 802ae1a:	4630      	mov	r0, r6
 802ae1c:	f001 fd58 	bl	802c8d0 <__aeabi_f2d>
 802ae20:	782c      	ldrb	r4, [r5, #0]
 802ae22:	e9cd 0104 	strd	r0, r1, [sp, #16]
 802ae26:	b17c      	cbz	r4, 802ae48 <powf+0x228>
 802ae28:	2000      	movs	r0, #0
 802ae2a:	2100      	movs	r1, #0
 802ae2c:	4602      	mov	r2, r0
 802ae2e:	460b      	mov	r3, r1
 802ae30:	f001 fecc 	bl	802cbcc <__aeabi_ddiv>
 802ae34:	2c02      	cmp	r4, #2
 802ae36:	e9cd 0106 	strd	r0, r1, [sp, #24]
 802ae3a:	d0cb      	beq.n	802add4 <powf+0x1b4>
 802ae3c:	4668      	mov	r0, sp
 802ae3e:	f001 f83b 	bl	802beb8 <matherr>
 802ae42:	2800      	cmp	r0, #0
 802ae44:	d19b      	bne.n	802ad7e <powf+0x15e>
 802ae46:	e7c5      	b.n	802add4 <powf+0x1b4>
 802ae48:	2200      	movs	r2, #0
 802ae4a:	2300      	movs	r3, #0
 802ae4c:	e9cd 2306 	strd	r2, r3, [sp, #24]
 802ae50:	e7f4      	b.n	802ae3c <powf+0x21c>
 802ae52:	4b15      	ldr	r3, [pc, #84]	; (802aea8 <powf+0x288>)
 802ae54:	f8cd 8020 	str.w	r8, [sp, #32]
 802ae58:	2203      	movs	r2, #3
 802ae5a:	4638      	mov	r0, r7
 802ae5c:	e88d 000c 	stmia.w	sp, {r2, r3}
 802ae60:	f001 fd36 	bl	802c8d0 <__aeabi_f2d>
 802ae64:	e9cd 0102 	strd	r0, r1, [sp, #8]
 802ae68:	4630      	mov	r0, r6
 802ae6a:	f001 fd31 	bl	802c8d0 <__aeabi_f2d>
 802ae6e:	f995 3000 	ldrsb.w	r3, [r5]
 802ae72:	e9cd 0104 	strd	r0, r1, [sp, #16]
 802ae76:	b9fb      	cbnz	r3, 802aeb8 <powf+0x298>
 802ae78:	ee07 7a90 	vmov	s15, r7
 802ae7c:	4b0d      	ldr	r3, [pc, #52]	; (802aeb4 <powf+0x294>)
 802ae7e:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 802ae82:	f04f 4260 	mov.w	r2, #3758096384	; 0xe0000000
 802ae86:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802ae8a:	e9cd 2306 	strd	r2, r3, [sp, #24]
 802ae8e:	d439      	bmi.n	802af04 <powf+0x2e4>
 802ae90:	f995 3000 	ldrsb.w	r3, [r5]
 802ae94:	2b02      	cmp	r3, #2
 802ae96:	f47f af6c 	bne.w	802ad72 <powf+0x152>
 802ae9a:	f002 fb43 	bl	802d524 <__errno>
 802ae9e:	2322      	movs	r3, #34	; 0x22
 802aea0:	6003      	str	r3, [r0, #0]
 802aea2:	e76c      	b.n	802ad7e <powf+0x15e>
 802aea4:	1ffe9630 	.word	0x1ffe9630
 802aea8:	080319dc 	.word	0x080319dc
 802aeac:	3ff00000 	.word	0x3ff00000
 802aeb0:	fff00000 	.word	0xfff00000
 802aeb4:	47efffff 	.word	0x47efffff
 802aeb8:	ee07 7a90 	vmov	s15, r7
 802aebc:	4b1f      	ldr	r3, [pc, #124]	; (802af3c <powf+0x31c>)
 802aebe:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 802aec2:	2200      	movs	r2, #0
 802aec4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802aec8:	e9cd 2306 	strd	r2, r3, [sp, #24]
 802aecc:	d5e0      	bpl.n	802ae90 <powf+0x270>
 802aece:	ee07 6a10 	vmov	s14, r6
 802aed2:	eef6 7a00 	vmov.f32	s15, #96	; 0x60
 802aed6:	ee67 7a27 	vmul.f32	s15, s14, s15
 802aeda:	ee17 0a90 	vmov	r0, s15
 802aede:	f001 fcf7 	bl	802c8d0 <__aeabi_f2d>
 802aee2:	4606      	mov	r6, r0
 802aee4:	460f      	mov	r7, r1
 802aee6:	f000 ffef 	bl	802bec8 <rint>
 802aeea:	4602      	mov	r2, r0
 802aeec:	460b      	mov	r3, r1
 802aeee:	4630      	mov	r0, r6
 802aef0:	4639      	mov	r1, r7
 802aef2:	f001 ffa9 	bl	802ce48 <__aeabi_dcmpeq>
 802aef6:	2800      	cmp	r0, #0
 802aef8:	d1ca      	bne.n	802ae90 <powf+0x270>
 802aefa:	4b11      	ldr	r3, [pc, #68]	; (802af40 <powf+0x320>)
 802aefc:	2200      	movs	r2, #0
 802aefe:	e9cd 2306 	strd	r2, r3, [sp, #24]
 802af02:	e7c5      	b.n	802ae90 <powf+0x270>
 802af04:	ee07 6a10 	vmov	s14, r6
 802af08:	eef6 7a00 	vmov.f32	s15, #96	; 0x60
 802af0c:	ee67 7a27 	vmul.f32	s15, s14, s15
 802af10:	ee17 0a90 	vmov	r0, s15
 802af14:	f001 fcdc 	bl	802c8d0 <__aeabi_f2d>
 802af18:	4606      	mov	r6, r0
 802af1a:	460f      	mov	r7, r1
 802af1c:	f000 ffd4 	bl	802bec8 <rint>
 802af20:	4602      	mov	r2, r0
 802af22:	460b      	mov	r3, r1
 802af24:	4630      	mov	r0, r6
 802af26:	4639      	mov	r1, r7
 802af28:	f001 ff8e 	bl	802ce48 <__aeabi_dcmpeq>
 802af2c:	2800      	cmp	r0, #0
 802af2e:	d1af      	bne.n	802ae90 <powf+0x270>
 802af30:	4b04      	ldr	r3, [pc, #16]	; (802af44 <powf+0x324>)
 802af32:	f04f 4260 	mov.w	r2, #3758096384	; 0xe0000000
 802af36:	e9cd 2306 	strd	r2, r3, [sp, #24]
 802af3a:	e7a9      	b.n	802ae90 <powf+0x270>
 802af3c:	7ff00000 	.word	0x7ff00000
 802af40:	fff00000 	.word	0xfff00000
 802af44:	c7efffff 	.word	0xc7efffff

0802af48 <sqrtf>:
 802af48:	b530      	push	{r4, r5, lr}
 802af4a:	ed2d 8b02 	vpush	{d8}
 802af4e:	4d28      	ldr	r5, [pc, #160]	; (802aff0 <sqrtf+0xa8>)
 802af50:	b08b      	sub	sp, #44	; 0x2c
 802af52:	ee08 0a10 	vmov	s16, r0
 802af56:	f000 ff59 	bl	802be0c <__ieee754_sqrtf>
 802af5a:	f995 3000 	ldrsb.w	r3, [r5]
 802af5e:	3301      	adds	r3, #1
 802af60:	4604      	mov	r4, r0
 802af62:	d009      	beq.n	802af78 <sqrtf+0x30>
 802af64:	ee18 0a10 	vmov	r0, s16
 802af68:	f001 f98a 	bl	802c280 <__fpclassifyf>
 802af6c:	b120      	cbz	r0, 802af78 <sqrtf+0x30>
 802af6e:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 802af72:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802af76:	d404      	bmi.n	802af82 <sqrtf+0x3a>
 802af78:	4620      	mov	r0, r4
 802af7a:	b00b      	add	sp, #44	; 0x2c
 802af7c:	ecbd 8b02 	vpop	{d8}
 802af80:	bd30      	pop	{r4, r5, pc}
 802af82:	2301      	movs	r3, #1
 802af84:	4a1b      	ldr	r2, [pc, #108]	; (802aff4 <sqrtf+0xac>)
 802af86:	9300      	str	r3, [sp, #0]
 802af88:	ee18 0a10 	vmov	r0, s16
 802af8c:	2300      	movs	r3, #0
 802af8e:	9201      	str	r2, [sp, #4]
 802af90:	9308      	str	r3, [sp, #32]
 802af92:	f001 fc9d 	bl	802c8d0 <__aeabi_f2d>
 802af96:	782c      	ldrb	r4, [r5, #0]
 802af98:	e9cd 0104 	strd	r0, r1, [sp, #16]
 802af9c:	e9cd 0102 	strd	r0, r1, [sp, #8]
 802afa0:	b98c      	cbnz	r4, 802afc6 <sqrtf+0x7e>
 802afa2:	2200      	movs	r2, #0
 802afa4:	2300      	movs	r3, #0
 802afa6:	e9cd 2306 	strd	r2, r3, [sp, #24]
 802afaa:	4668      	mov	r0, sp
 802afac:	f000 ff84 	bl	802beb8 <matherr>
 802afb0:	b198      	cbz	r0, 802afda <sqrtf+0x92>
 802afb2:	9b08      	ldr	r3, [sp, #32]
 802afb4:	b9b3      	cbnz	r3, 802afe4 <sqrtf+0x9c>
 802afb6:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 802afba:	f001 ff97 	bl	802ceec <__aeabi_d2f>
 802afbe:	b00b      	add	sp, #44	; 0x2c
 802afc0:	ecbd 8b02 	vpop	{d8}
 802afc4:	bd30      	pop	{r4, r5, pc}
 802afc6:	2000      	movs	r0, #0
 802afc8:	2100      	movs	r1, #0
 802afca:	4602      	mov	r2, r0
 802afcc:	460b      	mov	r3, r1
 802afce:	f001 fdfd 	bl	802cbcc <__aeabi_ddiv>
 802afd2:	2c02      	cmp	r4, #2
 802afd4:	e9cd 0106 	strd	r0, r1, [sp, #24]
 802afd8:	d1e7      	bne.n	802afaa <sqrtf+0x62>
 802afda:	f002 faa3 	bl	802d524 <__errno>
 802afde:	2321      	movs	r3, #33	; 0x21
 802afe0:	6003      	str	r3, [r0, #0]
 802afe2:	e7e6      	b.n	802afb2 <sqrtf+0x6a>
 802afe4:	f002 fa9e 	bl	802d524 <__errno>
 802afe8:	9b08      	ldr	r3, [sp, #32]
 802afea:	6003      	str	r3, [r0, #0]
 802afec:	e7e3      	b.n	802afb6 <sqrtf+0x6e>
 802afee:	bf00      	nop
 802aff0:	1ffe9630 	.word	0x1ffe9630
 802aff4:	080319e4 	.word	0x080319e4

0802aff8 <__ieee754_acosf>:
 802aff8:	b508      	push	{r3, lr}
 802affa:	f020 4300 	bic.w	r3, r0, #2147483648	; 0x80000000
 802affe:	f1b3 5f7e 	cmp.w	r3, #1065353216	; 0x3f800000
 802b002:	ed2d 8b02 	vpush	{d8}
 802b006:	ee07 0a90 	vmov	s15, r0
 802b00a:	d016      	beq.n	802b03a <__ieee754_acosf+0x42>
 802b00c:	dc0c      	bgt.n	802b028 <__ieee754_acosf+0x30>
 802b00e:	f1b3 5f7c 	cmp.w	r3, #1056964608	; 0x3f000000
 802b012:	da1f      	bge.n	802b054 <__ieee754_acosf+0x5c>
 802b014:	f1b3 5f0c 	cmp.w	r3, #587202560	; 0x23000000
 802b018:	dc70      	bgt.n	802b0fc <__ieee754_acosf+0x104>
 802b01a:	ecbd 8b02 	vpop	{d8}
 802b01e:	eddf 7a7a 	vldr	s15, [pc, #488]	; 802b208 <__ieee754_acosf+0x210>
 802b022:	ee17 0a90 	vmov	r0, s15
 802b026:	bd08      	pop	{r3, pc}
 802b028:	ee77 7ae7 	vsub.f32	s15, s15, s15
 802b02c:	eec7 7aa7 	vdiv.f32	s15, s15, s15
 802b030:	ecbd 8b02 	vpop	{d8}
 802b034:	ee17 0a90 	vmov	r0, s15
 802b038:	bd08      	pop	{r3, pc}
 802b03a:	ecbd 8b02 	vpop	{d8}
 802b03e:	eddf 7a73 	vldr	s15, [pc, #460]	; 802b20c <__ieee754_acosf+0x214>
 802b042:	ed9f 7a73 	vldr	s14, [pc, #460]	; 802b210 <__ieee754_acosf+0x218>
 802b046:	2800      	cmp	r0, #0
 802b048:	bfd8      	it	le
 802b04a:	eef0 7a47 	vmovle.f32	s15, s14
 802b04e:	ee17 0a90 	vmov	r0, s15
 802b052:	bd08      	pop	{r3, pc}
 802b054:	2800      	cmp	r0, #0
 802b056:	f2c0 808e 	blt.w	802b176 <__ieee754_acosf+0x17e>
 802b05a:	eef7 8a00 	vmov.f32	s17, #112	; 0x70
 802b05e:	ee78 7ae7 	vsub.f32	s15, s17, s15
 802b062:	eeb6 8a00 	vmov.f32	s16, #96	; 0x60
 802b066:	ee27 8a88 	vmul.f32	s16, s15, s16
 802b06a:	ee18 0a10 	vmov	r0, s16
 802b06e:	f000 fecd 	bl	802be0c <__ieee754_sqrtf>
 802b072:	ed9f 7a68 	vldr	s14, [pc, #416]	; 802b214 <__ieee754_acosf+0x21c>
 802b076:	ed9f 3a68 	vldr	s6, [pc, #416]	; 802b218 <__ieee754_acosf+0x220>
 802b07a:	ed9f 4a68 	vldr	s8, [pc, #416]	; 802b21c <__ieee754_acosf+0x224>
 802b07e:	eddf 2a68 	vldr	s5, [pc, #416]	; 802b220 <__ieee754_acosf+0x228>
 802b082:	eddf 3a68 	vldr	s7, [pc, #416]	; 802b224 <__ieee754_acosf+0x22c>
 802b086:	ed9f 5a68 	vldr	s10, [pc, #416]	; 802b228 <__ieee754_acosf+0x230>
 802b08a:	eddf 4a68 	vldr	s9, [pc, #416]	; 802b22c <__ieee754_acosf+0x234>
 802b08e:	eddf 6a68 	vldr	s13, [pc, #416]	; 802b230 <__ieee754_acosf+0x238>
 802b092:	eddf 5a68 	vldr	s11, [pc, #416]	; 802b234 <__ieee754_acosf+0x23c>
 802b096:	eddf 7a68 	vldr	s15, [pc, #416]	; 802b238 <__ieee754_acosf+0x240>
 802b09a:	eea8 3a07 	vfma.f32	s6, s16, s14
 802b09e:	f420 637f 	bic.w	r3, r0, #4080	; 0xff0
 802b0a2:	f023 030f 	bic.w	r3, r3, #15
 802b0a6:	eee8 3a22 	vfma.f32	s7, s16, s5
 802b0aa:	eea3 4a08 	vfma.f32	s8, s6, s16
 802b0ae:	eee3 4a88 	vfma.f32	s9, s7, s16
 802b0b2:	eea4 5a08 	vfma.f32	s10, s8, s16
 802b0b6:	eee4 5a88 	vfma.f32	s11, s9, s16
 802b0ba:	eee5 6a08 	vfma.f32	s13, s10, s16
 802b0be:	ee07 3a10 	vmov	s14, r3
 802b0c2:	eee6 7a88 	vfma.f32	s15, s13, s16
 802b0c6:	eef0 6a48 	vmov.f32	s13, s16
 802b0ca:	ee06 0a10 	vmov	s12, r0
 802b0ce:	eee5 8a88 	vfma.f32	s17, s11, s16
 802b0d2:	eee7 6a47 	vfms.f32	s13, s14, s14
 802b0d6:	ee67 7a88 	vmul.f32	s15, s15, s16
 802b0da:	ee76 5a07 	vadd.f32	s11, s12, s14
 802b0de:	ee87 8aa8 	vdiv.f32	s16, s15, s17
 802b0e2:	eec6 7aa5 	vdiv.f32	s15, s13, s11
 802b0e6:	eee8 7a06 	vfma.f32	s15, s16, s12
 802b0ea:	ecbd 8b02 	vpop	{d8}
 802b0ee:	ee77 7a27 	vadd.f32	s15, s14, s15
 802b0f2:	ee77 7aa7 	vadd.f32	s15, s15, s15
 802b0f6:	ee17 0a90 	vmov	r0, s15
 802b0fa:	bd08      	pop	{r3, pc}
 802b0fc:	ee27 7aa7 	vmul.f32	s14, s15, s15
 802b100:	ed9f 1a44 	vldr	s2, [pc, #272]	; 802b214 <__ieee754_acosf+0x21c>
 802b104:	eddf 2a44 	vldr	s5, [pc, #272]	; 802b218 <__ieee754_acosf+0x220>
 802b108:	eddf 3a44 	vldr	s7, [pc, #272]	; 802b21c <__ieee754_acosf+0x224>
 802b10c:	eddf 1a44 	vldr	s3, [pc, #272]	; 802b220 <__ieee754_acosf+0x228>
 802b110:	ed9f 3a44 	vldr	s6, [pc, #272]	; 802b224 <__ieee754_acosf+0x22c>
 802b114:	eddf 5a44 	vldr	s11, [pc, #272]	; 802b228 <__ieee754_acosf+0x230>
 802b118:	ed9f 4a44 	vldr	s8, [pc, #272]	; 802b22c <__ieee754_acosf+0x234>
 802b11c:	eddf 4a44 	vldr	s9, [pc, #272]	; 802b230 <__ieee754_acosf+0x238>
 802b120:	ed9f 5a44 	vldr	s10, [pc, #272]	; 802b234 <__ieee754_acosf+0x23c>
 802b124:	eddf 6a44 	vldr	s13, [pc, #272]	; 802b238 <__ieee754_acosf+0x240>
 802b128:	ed9f 6a44 	vldr	s12, [pc, #272]	; 802b23c <__ieee754_acosf+0x244>
 802b12c:	ed9f 2a44 	vldr	s4, [pc, #272]	; 802b240 <__ieee754_acosf+0x248>
 802b130:	eee7 2a01 	vfma.f32	s5, s14, s2
 802b134:	ecbd 8b02 	vpop	{d8}
 802b138:	eee2 3a87 	vfma.f32	s7, s5, s14
 802b13c:	eea7 3a21 	vfma.f32	s6, s14, s3
 802b140:	eee3 5a87 	vfma.f32	s11, s7, s14
 802b144:	eea3 4a07 	vfma.f32	s8, s6, s14
 802b148:	eee5 4a87 	vfma.f32	s9, s11, s14
 802b14c:	eea4 5a07 	vfma.f32	s10, s8, s14
 802b150:	eee4 6a87 	vfma.f32	s13, s9, s14
 802b154:	eef7 5a00 	vmov.f32	s11, #112	; 0x70
 802b158:	eee5 5a07 	vfma.f32	s11, s10, s14
 802b15c:	ee26 7a87 	vmul.f32	s14, s13, s14
 802b160:	ee87 7a25 	vdiv.f32	s14, s14, s11
 802b164:	eea7 6ac7 	vfms.f32	s12, s15, s14
 802b168:	ee77 7ac6 	vsub.f32	s15, s15, s12
 802b16c:	ee72 7a67 	vsub.f32	s15, s4, s15
 802b170:	ee17 0a90 	vmov	r0, s15
 802b174:	bd08      	pop	{r3, pc}
 802b176:	eeb7 8a00 	vmov.f32	s16, #112	; 0x70
 802b17a:	ee77 7a88 	vadd.f32	s15, s15, s16
 802b17e:	eeb6 7a00 	vmov.f32	s14, #96	; 0x60
 802b182:	ee67 7a87 	vmul.f32	s15, s15, s14
 802b186:	eddf 2a23 	vldr	s5, [pc, #140]	; 802b214 <__ieee754_acosf+0x21c>
 802b18a:	eddf 3a23 	vldr	s7, [pc, #140]	; 802b218 <__ieee754_acosf+0x220>
 802b18e:	ed9f 3a24 	vldr	s6, [pc, #144]	; 802b220 <__ieee754_acosf+0x228>
 802b192:	eddf 4a22 	vldr	s9, [pc, #136]	; 802b21c <__ieee754_acosf+0x224>
 802b196:	ed9f 4a23 	vldr	s8, [pc, #140]	; 802b224 <__ieee754_acosf+0x22c>
 802b19a:	eddf 5a23 	vldr	s11, [pc, #140]	; 802b228 <__ieee754_acosf+0x230>
 802b19e:	ed9f 5a23 	vldr	s10, [pc, #140]	; 802b22c <__ieee754_acosf+0x234>
 802b1a2:	eddf 6a23 	vldr	s13, [pc, #140]	; 802b230 <__ieee754_acosf+0x238>
 802b1a6:	ed9f 6a23 	vldr	s12, [pc, #140]	; 802b234 <__ieee754_acosf+0x23c>
 802b1aa:	ed9f 7a23 	vldr	s14, [pc, #140]	; 802b238 <__ieee754_acosf+0x240>
 802b1ae:	eee7 3aa2 	vfma.f32	s7, s15, s5
 802b1b2:	eea7 4a83 	vfma.f32	s8, s15, s6
 802b1b6:	eee3 4aa7 	vfma.f32	s9, s7, s15
 802b1ba:	eea4 5a27 	vfma.f32	s10, s8, s15
 802b1be:	eee4 5aa7 	vfma.f32	s11, s9, s15
 802b1c2:	eea5 6a27 	vfma.f32	s12, s10, s15
 802b1c6:	eee5 6aa7 	vfma.f32	s13, s11, s15
 802b1ca:	eea6 8a27 	vfma.f32	s16, s12, s15
 802b1ce:	eea6 7aa7 	vfma.f32	s14, s13, s15
 802b1d2:	eef0 8a48 	vmov.f32	s17, s16
 802b1d6:	ee27 8a27 	vmul.f32	s16, s14, s15
 802b1da:	ee17 0a90 	vmov	r0, s15
 802b1de:	f000 fe15 	bl	802be0c <__ieee754_sqrtf>
 802b1e2:	ee88 8a28 	vdiv.f32	s16, s16, s17
 802b1e6:	ee06 0a90 	vmov	s13, r0
 802b1ea:	ed9f 7a16 	vldr	s14, [pc, #88]	; 802b244 <__ieee754_acosf+0x24c>
 802b1ee:	eddf 7a16 	vldr	s15, [pc, #88]	; 802b248 <__ieee754_acosf+0x250>
 802b1f2:	eea8 7a26 	vfma.f32	s14, s16, s13
 802b1f6:	ee06 0a10 	vmov	s12, r0
 802b1fa:	ee37 7a06 	vadd.f32	s14, s14, s12
 802b1fe:	eef0 6a00 	vmov.f32	s13, #0
 802b202:	eee7 7a66 	vfms.f32	s15, s14, s13
 802b206:	e713      	b.n	802b030 <__ieee754_acosf+0x38>
 802b208:	3fc90fdb 	.word	0x3fc90fdb
 802b20c:	00000000 	.word	0x00000000
 802b210:	40490fdb 	.word	0x40490fdb
 802b214:	3811ef08 	.word	0x3811ef08
 802b218:	3a4f7f04 	.word	0x3a4f7f04
 802b21c:	bd241146 	.word	0xbd241146
 802b220:	3d9dc62e 	.word	0x3d9dc62e
 802b224:	bf303361 	.word	0xbf303361
 802b228:	3e4e0aa8 	.word	0x3e4e0aa8
 802b22c:	4001572d 	.word	0x4001572d
 802b230:	bea6b090 	.word	0xbea6b090
 802b234:	c019d139 	.word	0xc019d139
 802b238:	3e2aaaab 	.word	0x3e2aaaab
 802b23c:	33a22168 	.word	0x33a22168
 802b240:	3fc90fda 	.word	0x3fc90fda
 802b244:	b3a22168 	.word	0xb3a22168
 802b248:	40490fda 	.word	0x40490fda

0802b24c <__ieee754_acoshf>:
 802b24c:	b508      	push	{r3, lr}
 802b24e:	f1b0 5f7e 	cmp.w	r0, #1065353216	; 0x3f800000
 802b252:	ed2d 8b02 	vpush	{d8}
 802b256:	ee08 0a10 	vmov	s16, r0
 802b25a:	db2c      	blt.n	802b2b6 <__ieee754_acoshf+0x6a>
 802b25c:	f1b0 4f9b 	cmp.w	r0, #1300234240	; 0x4d800000
 802b260:	db09      	blt.n	802b276 <__ieee754_acoshf+0x2a>
 802b262:	f1b0 4fff 	cmp.w	r0, #2139095040	; 0x7f800000
 802b266:	db4b      	blt.n	802b300 <__ieee754_acoshf+0xb4>
 802b268:	ee38 8a08 	vadd.f32	s16, s16, s16
 802b26c:	ee18 0a10 	vmov	r0, s16
 802b270:	ecbd 8b02 	vpop	{d8}
 802b274:	bd08      	pop	{r3, pc}
 802b276:	f1b0 5f7e 	cmp.w	r0, #1065353216	; 0x3f800000
 802b27a:	d04a      	beq.n	802b312 <__ieee754_acoshf+0xc6>
 802b27c:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 802b280:	dc22      	bgt.n	802b2c8 <__ieee754_acoshf+0x7c>
 802b282:	eef7 7a00 	vmov.f32	s15, #112	; 0x70
 802b286:	ee38 8a67 	vsub.f32	s16, s16, s15
 802b28a:	eeb0 7a00 	vmov.f32	s14, #0
 802b28e:	ee68 7a08 	vmul.f32	s15, s16, s16
 802b292:	eee8 7a07 	vfma.f32	s15, s16, s14
 802b296:	ee17 0a90 	vmov	r0, s15
 802b29a:	f000 fdb7 	bl	802be0c <__ieee754_sqrtf>
 802b29e:	ee07 0a90 	vmov	s15, r0
 802b2a2:	ee77 7a88 	vadd.f32	s15, s15, s16
 802b2a6:	ecbd 8b02 	vpop	{d8}
 802b2aa:	ee17 0a90 	vmov	r0, s15
 802b2ae:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 802b2b2:	f000 bfff 	b.w	802c2b4 <log1pf>
 802b2b6:	ee38 8a48 	vsub.f32	s16, s16, s16
 802b2ba:	ee88 8a08 	vdiv.f32	s16, s16, s16
 802b2be:	ee18 0a10 	vmov	r0, s16
 802b2c2:	ecbd 8b02 	vpop	{d8}
 802b2c6:	bd08      	pop	{r3, pc}
 802b2c8:	eeff 7a00 	vmov.f32	s15, #240	; 0xf0
 802b2cc:	eee8 7a08 	vfma.f32	s15, s16, s16
 802b2d0:	ee17 0a90 	vmov	r0, s15
 802b2d4:	f000 fd9a 	bl	802be0c <__ieee754_sqrtf>
 802b2d8:	ee07 0a90 	vmov	s15, r0
 802b2dc:	ee37 7a88 	vadd.f32	s14, s15, s16
 802b2e0:	eef7 7a00 	vmov.f32	s15, #112	; 0x70
 802b2e4:	eec7 7a87 	vdiv.f32	s15, s15, s14
 802b2e8:	eeb0 7a00 	vmov.f32	s14, #0
 802b2ec:	eed8 7a07 	vfnms.f32	s15, s16, s14
 802b2f0:	ecbd 8b02 	vpop	{d8}
 802b2f4:	ee17 0a90 	vmov	r0, s15
 802b2f8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 802b2fc:	f000 b96c 	b.w	802b5d8 <__ieee754_logf>
 802b300:	f000 f96a 	bl	802b5d8 <__ieee754_logf>
 802b304:	ed9f 8a04 	vldr	s16, [pc, #16]	; 802b318 <__ieee754_acoshf+0xcc>
 802b308:	ee07 0a90 	vmov	s15, r0
 802b30c:	ee37 8a88 	vadd.f32	s16, s15, s16
 802b310:	e7ac      	b.n	802b26c <__ieee754_acoshf+0x20>
 802b312:	ed9f 8a02 	vldr	s16, [pc, #8]	; 802b31c <__ieee754_acoshf+0xd0>
 802b316:	e7a9      	b.n	802b26c <__ieee754_acoshf+0x20>
 802b318:	3f317218 	.word	0x3f317218
 802b31c:	00000000 	.word	0x00000000

0802b320 <__ieee754_coshf>:
 802b320:	b510      	push	{r4, lr}
 802b322:	ed2d 8b02 	vpush	{d8}
 802b326:	b082      	sub	sp, #8
 802b328:	9001      	str	r0, [sp, #4]
 802b32a:	9c01      	ldr	r4, [sp, #4]
 802b32c:	f024 4400 	bic.w	r4, r4, #2147483648	; 0x80000000
 802b330:	f1b4 4fff 	cmp.w	r4, #2139095040	; 0x7f800000
 802b334:	da15      	bge.n	802b362 <__ieee754_coshf+0x42>
 802b336:	4b32      	ldr	r3, [pc, #200]	; (802b400 <__ieee754_coshf+0xe0>)
 802b338:	429c      	cmp	r4, r3
 802b33a:	dd1c      	ble.n	802b376 <__ieee754_coshf+0x56>
 802b33c:	4b31      	ldr	r3, [pc, #196]	; (802b404 <__ieee754_coshf+0xe4>)
 802b33e:	429c      	cmp	r4, r3
 802b340:	dd2f      	ble.n	802b3a2 <__ieee754_coshf+0x82>
 802b342:	4b31      	ldr	r3, [pc, #196]	; (802b408 <__ieee754_coshf+0xe8>)
 802b344:	429c      	cmp	r4, r3
 802b346:	dd3b      	ble.n	802b3c0 <__ieee754_coshf+0xa0>
 802b348:	4b30      	ldr	r3, [pc, #192]	; (802b40c <__ieee754_coshf+0xec>)
 802b34a:	429c      	cmp	r4, r3
 802b34c:	dd43      	ble.n	802b3d6 <__ieee754_coshf+0xb6>
 802b34e:	eddf 7a30 	vldr	s15, [pc, #192]	; 802b410 <__ieee754_coshf+0xf0>
 802b352:	ee67 7aa7 	vmul.f32	s15, s15, s15
 802b356:	ee17 0a90 	vmov	r0, s15
 802b35a:	b002      	add	sp, #8
 802b35c:	ecbd 8b02 	vpop	{d8}
 802b360:	bd10      	pop	{r4, pc}
 802b362:	ee07 0a90 	vmov	s15, r0
 802b366:	ee67 7aa7 	vmul.f32	s15, s15, s15
 802b36a:	ee17 0a90 	vmov	r0, s15
 802b36e:	b002      	add	sp, #8
 802b370:	ecbd 8b02 	vpop	{d8}
 802b374:	bd10      	pop	{r4, pc}
 802b376:	f000 ff77 	bl	802c268 <fabsf>
 802b37a:	f000 fe31 	bl	802bfe0 <expm1f>
 802b37e:	ee07 0a10 	vmov	s14, r0
 802b382:	eef7 6a00 	vmov.f32	s13, #112	; 0x70
 802b386:	f1b4 5f10 	cmp.w	r4, #603979776	; 0x24000000
 802b38a:	ee77 7a26 	vadd.f32	s15, s14, s13
 802b38e:	dbe2      	blt.n	802b356 <__ieee754_coshf+0x36>
 802b390:	ee27 7a07 	vmul.f32	s14, s14, s14
 802b394:	ee77 7aa7 	vadd.f32	s15, s15, s15
 802b398:	eec7 7a27 	vdiv.f32	s15, s14, s15
 802b39c:	ee77 7aa6 	vadd.f32	s15, s15, s13
 802b3a0:	e7d9      	b.n	802b356 <__ieee754_coshf+0x36>
 802b3a2:	f000 ff61 	bl	802c268 <fabsf>
 802b3a6:	f000 f835 	bl	802b414 <__ieee754_expf>
 802b3aa:	ee07 0a90 	vmov	s15, r0
 802b3ae:	eeb6 7a00 	vmov.f32	s14, #96	; 0x60
 802b3b2:	eec7 7a27 	vdiv.f32	s15, s14, s15
 802b3b6:	ee06 0a90 	vmov	s13, r0
 802b3ba:	eee6 7a87 	vfma.f32	s15, s13, s14
 802b3be:	e7ca      	b.n	802b356 <__ieee754_coshf+0x36>
 802b3c0:	f000 ff52 	bl	802c268 <fabsf>
 802b3c4:	f000 f826 	bl	802b414 <__ieee754_expf>
 802b3c8:	ee07 0a10 	vmov	s14, r0
 802b3cc:	eef6 7a00 	vmov.f32	s15, #96	; 0x60
 802b3d0:	ee67 7a27 	vmul.f32	s15, s14, s15
 802b3d4:	e7bf      	b.n	802b356 <__ieee754_coshf+0x36>
 802b3d6:	f000 ff47 	bl	802c268 <fabsf>
 802b3da:	ee07 0a90 	vmov	s15, r0
 802b3de:	eeb6 8a00 	vmov.f32	s16, #96	; 0x60
 802b3e2:	ee67 7a88 	vmul.f32	s15, s15, s16
 802b3e6:	ee17 0a90 	vmov	r0, s15
 802b3ea:	f000 f813 	bl	802b414 <__ieee754_expf>
 802b3ee:	ee07 0a90 	vmov	s15, r0
 802b3f2:	ee07 0a10 	vmov	s14, r0
 802b3f6:	ee67 7a88 	vmul.f32	s15, s15, s16
 802b3fa:	ee67 7a87 	vmul.f32	s15, s15, s14
 802b3fe:	e7aa      	b.n	802b356 <__ieee754_coshf+0x36>
 802b400:	3eb17217 	.word	0x3eb17217
 802b404:	41afffff 	.word	0x41afffff
 802b408:	42b17217 	.word	0x42b17217
 802b40c:	42b2d4fc 	.word	0x42b2d4fc
 802b410:	7149f2ca 	.word	0x7149f2ca

0802b414 <__ieee754_expf>:
 802b414:	f020 4200 	bic.w	r2, r0, #2147483648	; 0x80000000
 802b418:	f1b2 4fff 	cmp.w	r2, #2139095040	; 0x7f800000
 802b41c:	ee07 0a90 	vmov	s15, r0
 802b420:	4603      	mov	r3, r0
 802b422:	d859      	bhi.n	802b4d8 <__ieee754_expf+0xc4>
 802b424:	ea4f 71d0 	mov.w	r1, r0, lsr #31
 802b428:	d05b      	beq.n	802b4e2 <__ieee754_expf+0xce>
 802b42a:	4859      	ldr	r0, [pc, #356]	; (802b590 <__ieee754_expf+0x17c>)
 802b42c:	4283      	cmp	r3, r0
 802b42e:	dc7a      	bgt.n	802b526 <__ieee754_expf+0x112>
 802b430:	2b00      	cmp	r3, #0
 802b432:	db70      	blt.n	802b516 <__ieee754_expf+0x102>
 802b434:	4b57      	ldr	r3, [pc, #348]	; (802b594 <__ieee754_expf+0x180>)
 802b436:	429a      	cmp	r2, r3
 802b438:	d95c      	bls.n	802b4f4 <__ieee754_expf+0xe0>
 802b43a:	4b57      	ldr	r3, [pc, #348]	; (802b598 <__ieee754_expf+0x184>)
 802b43c:	429a      	cmp	r2, r3
 802b43e:	f200 8086 	bhi.w	802b54e <__ieee754_expf+0x13a>
 802b442:	4856      	ldr	r0, [pc, #344]	; (802b59c <__ieee754_expf+0x188>)
 802b444:	4a56      	ldr	r2, [pc, #344]	; (802b5a0 <__ieee754_expf+0x18c>)
 802b446:	008b      	lsls	r3, r1, #2
 802b448:	4418      	add	r0, r3
 802b44a:	ed90 7a00 	vldr	s14, [r0]
 802b44e:	441a      	add	r2, r3
 802b450:	ee77 3ac7 	vsub.f32	s7, s15, s14
 802b454:	f1c1 0301 	rsb	r3, r1, #1
 802b458:	ed92 6a00 	vldr	s12, [r2]
 802b45c:	1a5b      	subs	r3, r3, r1
 802b45e:	ee73 7ac6 	vsub.f32	s15, s7, s12
 802b462:	ee67 6aa7 	vmul.f32	s13, s15, s15
 802b466:	ed9f 7a4f 	vldr	s14, [pc, #316]	; 802b5a4 <__ieee754_expf+0x190>
 802b46a:	ed9f 4a4f 	vldr	s8, [pc, #316]	; 802b5a8 <__ieee754_expf+0x194>
 802b46e:	eddf 4a4f 	vldr	s9, [pc, #316]	; 802b5ac <__ieee754_expf+0x198>
 802b472:	ed9f 5a4f 	vldr	s10, [pc, #316]	; 802b5b0 <__ieee754_expf+0x19c>
 802b476:	eddf 5a4f 	vldr	s11, [pc, #316]	; 802b5b4 <__ieee754_expf+0x1a0>
 802b47a:	eea6 4a87 	vfma.f32	s8, s13, s14
 802b47e:	eeb0 7a67 	vmov.f32	s14, s15
 802b482:	eee4 4a26 	vfma.f32	s9, s8, s13
 802b486:	eea4 5aa6 	vfma.f32	s10, s9, s13
 802b48a:	eee5 5a26 	vfma.f32	s11, s10, s13
 802b48e:	eea5 7ae6 	vfms.f32	s14, s11, s13
 802b492:	eef0 6a47 	vmov.f32	s13, s14
 802b496:	eeb0 7a00 	vmov.f32	s14, #0
 802b49a:	2b00      	cmp	r3, #0
 802b49c:	d04a      	beq.n	802b534 <__ieee754_expf+0x120>
 802b49e:	ee67 7aa6 	vmul.f32	s15, s15, s13
 802b4a2:	ee77 6a66 	vsub.f32	s13, s14, s13
 802b4a6:	eef7 5a00 	vmov.f32	s11, #112	; 0x70
 802b4aa:	ee87 7aa6 	vdiv.f32	s14, s15, s13
 802b4ae:	f113 0f7d 	cmn.w	r3, #125	; 0x7d
 802b4b2:	ee36 6a47 	vsub.f32	s12, s12, s14
 802b4b6:	ee36 7a63 	vsub.f32	s14, s12, s7
 802b4ba:	ee75 7ac7 	vsub.f32	s15, s11, s14
 802b4be:	da60      	bge.n	802b582 <__ieee754_expf+0x16e>
 802b4c0:	ee17 2a90 	vmov	r2, s15
 802b4c4:	3364      	adds	r3, #100	; 0x64
 802b4c6:	eb02 53c3 	add.w	r3, r2, r3, lsl #23
 802b4ca:	eddf 6a3b 	vldr	s13, [pc, #236]	; 802b5b8 <__ieee754_expf+0x1a4>
 802b4ce:	ee07 3a90 	vmov	s15, r3
 802b4d2:	ee67 7aa6 	vmul.f32	s15, s15, s13
 802b4d6:	e001      	b.n	802b4dc <__ieee754_expf+0xc8>
 802b4d8:	ee77 7aa7 	vadd.f32	s15, s15, s15
 802b4dc:	ee17 0a90 	vmov	r0, s15
 802b4e0:	4770      	bx	lr
 802b4e2:	ed9f 7a36 	vldr	s14, [pc, #216]	; 802b5bc <__ieee754_expf+0x1a8>
 802b4e6:	2900      	cmp	r1, #0
 802b4e8:	bf18      	it	ne
 802b4ea:	eef0 7a47 	vmovne.f32	s15, s14
 802b4ee:	ee17 0a90 	vmov	r0, s15
 802b4f2:	4770      	bx	lr
 802b4f4:	f1b2 5f46 	cmp.w	r2, #830472192	; 0x31800000
 802b4f8:	d213      	bcs.n	802b522 <__ieee754_expf+0x10e>
 802b4fa:	ed9f 7a31 	vldr	s14, [pc, #196]	; 802b5c0 <__ieee754_expf+0x1ac>
 802b4fe:	ee37 7a87 	vadd.f32	s14, s15, s14
 802b502:	eef7 6a00 	vmov.f32	s13, #112	; 0x70
 802b506:	eeb4 7ae6 	vcmpe.f32	s14, s13
 802b50a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802b50e:	dd08      	ble.n	802b522 <__ieee754_expf+0x10e>
 802b510:	ee77 7aa6 	vadd.f32	s15, s15, s13
 802b514:	e7e2      	b.n	802b4dc <__ieee754_expf+0xc8>
 802b516:	4b2b      	ldr	r3, [pc, #172]	; (802b5c4 <__ieee754_expf+0x1b0>)
 802b518:	429a      	cmp	r2, r3
 802b51a:	d98b      	bls.n	802b434 <__ieee754_expf+0x20>
 802b51c:	eddf 7a27 	vldr	s15, [pc, #156]	; 802b5bc <__ieee754_expf+0x1a8>
 802b520:	e7dc      	b.n	802b4dc <__ieee754_expf+0xc8>
 802b522:	2300      	movs	r3, #0
 802b524:	e79d      	b.n	802b462 <__ieee754_expf+0x4e>
 802b526:	eddf 7a26 	vldr	s15, [pc, #152]	; 802b5c0 <__ieee754_expf+0x1ac>
 802b52a:	ee67 7aa7 	vmul.f32	s15, s15, s15
 802b52e:	ee17 0a90 	vmov	r0, s15
 802b532:	4770      	bx	lr
 802b534:	ee36 7ac7 	vsub.f32	s14, s13, s14
 802b538:	ee67 6aa6 	vmul.f32	s13, s15, s13
 802b53c:	eeb7 6a00 	vmov.f32	s12, #112	; 0x70
 802b540:	eec6 6a87 	vdiv.f32	s13, s13, s14
 802b544:	ee76 7ae7 	vsub.f32	s15, s13, s15
 802b548:	ee76 7a67 	vsub.f32	s15, s12, s15
 802b54c:	e7c6      	b.n	802b4dc <__ieee754_expf+0xc8>
 802b54e:	4b1e      	ldr	r3, [pc, #120]	; (802b5c8 <__ieee754_expf+0x1b4>)
 802b550:	eddf 6a1e 	vldr	s13, [pc, #120]	; 802b5cc <__ieee754_expf+0x1b8>
 802b554:	eddf 5a1e 	vldr	s11, [pc, #120]	; 802b5d0 <__ieee754_expf+0x1bc>
 802b558:	ed9f 6a1e 	vldr	s12, [pc, #120]	; 802b5d4 <__ieee754_expf+0x1c0>
 802b55c:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 802b560:	ed93 7a00 	vldr	s14, [r3]
 802b564:	eea7 7aa6 	vfma.f32	s14, s15, s13
 802b568:	eebd 7ac7 	vcvt.s32.f32	s14, s14
 802b56c:	eef8 6ac7 	vcvt.f32.s32	s13, s14
 802b570:	ee17 3a10 	vmov	r3, s14
 802b574:	eee6 7ae5 	vfms.f32	s15, s13, s11
 802b578:	ee26 6a86 	vmul.f32	s12, s13, s12
 802b57c:	eef0 3a67 	vmov.f32	s7, s15
 802b580:	e76d      	b.n	802b45e <__ieee754_expf+0x4a>
 802b582:	ee17 2a90 	vmov	r2, s15
 802b586:	eb02 53c3 	add.w	r3, r2, r3, lsl #23
 802b58a:	ee07 3a90 	vmov	s15, r3
 802b58e:	e7a5      	b.n	802b4dc <__ieee754_expf+0xc8>
 802b590:	42b17217 	.word	0x42b17217
 802b594:	3eb17218 	.word	0x3eb17218
 802b598:	3f851591 	.word	0x3f851591
 802b59c:	080319fc 	.word	0x080319fc
 802b5a0:	080319f4 	.word	0x080319f4
 802b5a4:	3331bb4c 	.word	0x3331bb4c
 802b5a8:	b5ddea0e 	.word	0xb5ddea0e
 802b5ac:	388ab355 	.word	0x388ab355
 802b5b0:	bb360b61 	.word	0xbb360b61
 802b5b4:	3e2aaaab 	.word	0x3e2aaaab
 802b5b8:	0d800000 	.word	0x0d800000
 802b5bc:	00000000 	.word	0x00000000
 802b5c0:	7149f2ca 	.word	0x7149f2ca
 802b5c4:	42cff1b5 	.word	0x42cff1b5
 802b5c8:	080319ec 	.word	0x080319ec
 802b5cc:	3fb8aa3b 	.word	0x3fb8aa3b
 802b5d0:	3f317180 	.word	0x3f317180
 802b5d4:	3717f7d1 	.word	0x3717f7d1

0802b5d8 <__ieee754_logf>:
 802b5d8:	b430      	push	{r4, r5}
 802b5da:	b082      	sub	sp, #8
 802b5dc:	9001      	str	r0, [sp, #4]
 802b5de:	9b01      	ldr	r3, [sp, #4]
 802b5e0:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
 802b5e4:	b372      	cbz	r2, 802b644 <__ieee754_logf+0x6c>
 802b5e6:	2b00      	cmp	r3, #0
 802b5e8:	db42      	blt.n	802b670 <__ieee754_logf+0x98>
 802b5ea:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
 802b5ee:	da4c      	bge.n	802b68a <__ieee754_logf+0xb2>
 802b5f0:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 802b5f4:	db31      	blt.n	802b65a <__ieee754_logf+0x82>
 802b5f6:	2200      	movs	r2, #0
 802b5f8:	4972      	ldr	r1, [pc, #456]	; (802b7c4 <__ieee754_logf+0x1ec>)
 802b5fa:	f3c3 0516 	ubfx	r5, r3, #0, #23
 802b5fe:	4429      	add	r1, r5
 802b600:	f401 0100 	and.w	r1, r1, #8388608	; 0x800000
 802b604:	15db      	asrs	r3, r3, #23
 802b606:	3b7f      	subs	r3, #127	; 0x7f
 802b608:	f081 547e 	eor.w	r4, r1, #1065353216	; 0x3f800000
 802b60c:	4413      	add	r3, r2
 802b60e:	f105 000f 	add.w	r0, r5, #15
 802b612:	ea44 0205 	orr.w	r2, r4, r5
 802b616:	ee07 2a90 	vmov	s15, r2
 802b61a:	f3c0 0216 	ubfx	r2, r0, #0, #23
 802b61e:	eeb7 7a00 	vmov.f32	s14, #112	; 0x70
 802b622:	2a0f      	cmp	r2, #15
 802b624:	eb03 53d1 	add.w	r3, r3, r1, lsr #23
 802b628:	ee37 7ac7 	vsub.f32	s14, s15, s14
 802b62c:	dc36      	bgt.n	802b69c <__ieee754_logf+0xc4>
 802b62e:	eeb5 7a40 	vcmp.f32	s14, #0.0
 802b632:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802b636:	d172      	bne.n	802b71e <__ieee754_logf+0x146>
 802b638:	2b00      	cmp	r3, #0
 802b63a:	f040 809e 	bne.w	802b77a <__ieee754_logf+0x1a2>
 802b63e:	eddf 7a62 	vldr	s15, [pc, #392]	; 802b7c8 <__ieee754_logf+0x1f0>
 802b642:	e005      	b.n	802b650 <__ieee754_logf+0x78>
 802b644:	eddf 7a61 	vldr	s15, [pc, #388]	; 802b7cc <__ieee754_logf+0x1f4>
 802b648:	ed9f 7a5f 	vldr	s14, [pc, #380]	; 802b7c8 <__ieee754_logf+0x1f0>
 802b64c:	eec7 7a87 	vdiv.f32	s15, s15, s14
 802b650:	ee17 0a90 	vmov	r0, s15
 802b654:	b002      	add	sp, #8
 802b656:	bc30      	pop	{r4, r5}
 802b658:	4770      	bx	lr
 802b65a:	eddf 7a5d 	vldr	s15, [pc, #372]	; 802b7d0 <__ieee754_logf+0x1f8>
 802b65e:	ed9d 7a01 	vldr	s14, [sp, #4]
 802b662:	ee67 7a27 	vmul.f32	s15, s14, s15
 802b666:	f06f 0218 	mvn.w	r2, #24
 802b66a:	ee17 3a90 	vmov	r3, s15
 802b66e:	e7c3      	b.n	802b5f8 <__ieee754_logf+0x20>
 802b670:	eddd 7a01 	vldr	s15, [sp, #4]
 802b674:	ed9f 7a54 	vldr	s14, [pc, #336]	; 802b7c8 <__ieee754_logf+0x1f0>
 802b678:	ee77 7ae7 	vsub.f32	s15, s15, s15
 802b67c:	eec7 7a87 	vdiv.f32	s15, s15, s14
 802b680:	ee17 0a90 	vmov	r0, s15
 802b684:	b002      	add	sp, #8
 802b686:	bc30      	pop	{r4, r5}
 802b688:	4770      	bx	lr
 802b68a:	eddd 7a01 	vldr	s15, [sp, #4]
 802b68e:	ee77 7aa7 	vadd.f32	s15, s15, s15
 802b692:	ee17 0a90 	vmov	r0, s15
 802b696:	b002      	add	sp, #8
 802b698:	bc30      	pop	{r4, r5}
 802b69a:	4770      	bx	lr
 802b69c:	eeb0 6a00 	vmov.f32	s12, #0
 802b6a0:	ee37 6a06 	vadd.f32	s12, s14, s12
 802b6a4:	ee06 3a90 	vmov	s13, r3
 802b6a8:	ee87 6a06 	vdiv.f32	s12, s14, s12
 802b6ac:	4a49      	ldr	r2, [pc, #292]	; (802b7d4 <__ieee754_logf+0x1fc>)
 802b6ae:	f5c5 1157 	rsb	r1, r5, #3522560	; 0x35c000
 802b6b2:	442a      	add	r2, r5
 802b6b4:	f501 7122 	add.w	r1, r1, #648	; 0x288
 802b6b8:	430a      	orrs	r2, r1
 802b6ba:	2a00      	cmp	r2, #0
 802b6bc:	ed9f 2a46 	vldr	s4, [pc, #280]	; 802b7d8 <__ieee754_logf+0x200>
 802b6c0:	eddf 3a46 	vldr	s7, [pc, #280]	; 802b7dc <__ieee754_logf+0x204>
 802b6c4:	eddf 4a46 	vldr	s9, [pc, #280]	; 802b7e0 <__ieee754_logf+0x208>
 802b6c8:	eddf 2a46 	vldr	s5, [pc, #280]	; 802b7e4 <__ieee754_logf+0x20c>
 802b6cc:	ed9f 4a46 	vldr	s8, [pc, #280]	; 802b7e8 <__ieee754_logf+0x210>
 802b6d0:	eddf 7a46 	vldr	s15, [pc, #280]	; 802b7ec <__ieee754_logf+0x214>
 802b6d4:	eddf 5a46 	vldr	s11, [pc, #280]	; 802b7f0 <__ieee754_logf+0x218>
 802b6d8:	ee26 5a06 	vmul.f32	s10, s12, s12
 802b6dc:	eeb8 3ae6 	vcvt.f32.s32	s6, s13
 802b6e0:	ee65 6a05 	vmul.f32	s13, s10, s10
 802b6e4:	eee6 3a82 	vfma.f32	s7, s13, s4
 802b6e8:	eea6 4aa2 	vfma.f32	s8, s13, s5
 802b6ec:	eee3 4aa6 	vfma.f32	s9, s7, s13
 802b6f0:	eee4 5a26 	vfma.f32	s11, s8, s13
 802b6f4:	eee4 7aa6 	vfma.f32	s15, s9, s13
 802b6f8:	ee67 7a85 	vmul.f32	s15, s15, s10
 802b6fc:	eee5 7aa6 	vfma.f32	s15, s11, s13
 802b700:	dd48      	ble.n	802b794 <__ieee754_logf+0x1bc>
 802b702:	eef6 5a00 	vmov.f32	s11, #96	; 0x60
 802b706:	ee67 5a25 	vmul.f32	s11, s14, s11
 802b70a:	ee65 5a87 	vmul.f32	s11, s11, s14
 802b70e:	b9a3      	cbnz	r3, 802b73a <__ieee754_logf+0x162>
 802b710:	ee75 6aa7 	vadd.f32	s13, s11, s15
 802b714:	eee6 5ac6 	vfms.f32	s11, s13, s12
 802b718:	ee77 7a65 	vsub.f32	s15, s14, s11
 802b71c:	e798      	b.n	802b650 <__ieee754_logf+0x78>
 802b71e:	eddf 6a35 	vldr	s13, [pc, #212]	; 802b7f4 <__ieee754_logf+0x21c>
 802b722:	eef6 7a00 	vmov.f32	s15, #96	; 0x60
 802b726:	eee7 7a66 	vfms.f32	s15, s14, s13
 802b72a:	ee67 6a07 	vmul.f32	s13, s14, s14
 802b72e:	ee66 7aa7 	vmul.f32	s15, s13, s15
 802b732:	b99b      	cbnz	r3, 802b75c <__ieee754_logf+0x184>
 802b734:	ee77 7a67 	vsub.f32	s15, s14, s15
 802b738:	e78a      	b.n	802b650 <__ieee754_logf+0x78>
 802b73a:	ed9f 5a2f 	vldr	s10, [pc, #188]	; 802b7f8 <__ieee754_logf+0x220>
 802b73e:	eddf 4a2f 	vldr	s9, [pc, #188]	; 802b7fc <__ieee754_logf+0x224>
 802b742:	ee75 6aa7 	vadd.f32	s13, s11, s15
 802b746:	ee63 7a05 	vmul.f32	s15, s6, s10
 802b74a:	eee6 7a86 	vfma.f32	s15, s13, s12
 802b74e:	ee75 7ae7 	vsub.f32	s15, s11, s15
 802b752:	ee77 7ac7 	vsub.f32	s15, s15, s14
 802b756:	eed3 7a24 	vfnms.f32	s15, s6, s9
 802b75a:	e779      	b.n	802b650 <__ieee754_logf+0x78>
 802b75c:	ee06 3a90 	vmov	s13, r3
 802b760:	eddf 5a25 	vldr	s11, [pc, #148]	; 802b7f8 <__ieee754_logf+0x220>
 802b764:	ed9f 6a25 	vldr	s12, [pc, #148]	; 802b7fc <__ieee754_logf+0x224>
 802b768:	eef8 6ae6 	vcvt.f32.s32	s13, s13
 802b76c:	eee6 7ae5 	vfms.f32	s15, s13, s11
 802b770:	ee77 7ac7 	vsub.f32	s15, s15, s14
 802b774:	eed6 7a86 	vfnms.f32	s15, s13, s12
 802b778:	e76a      	b.n	802b650 <__ieee754_logf+0x78>
 802b77a:	ee07 3a90 	vmov	s15, r3
 802b77e:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 802b782:	eddf 7a1d 	vldr	s15, [pc, #116]	; 802b7f8 <__ieee754_logf+0x220>
 802b786:	eddf 6a1d 	vldr	s13, [pc, #116]	; 802b7fc <__ieee754_logf+0x224>
 802b78a:	ee67 7a27 	vmul.f32	s15, s14, s15
 802b78e:	eee7 7a26 	vfma.f32	s15, s14, s13
 802b792:	e75d      	b.n	802b650 <__ieee754_logf+0x78>
 802b794:	b173      	cbz	r3, 802b7b4 <__ieee754_logf+0x1dc>
 802b796:	eddf 5a18 	vldr	s11, [pc, #96]	; 802b7f8 <__ieee754_logf+0x220>
 802b79a:	ed9f 5a18 	vldr	s10, [pc, #96]	; 802b7fc <__ieee754_logf+0x224>
 802b79e:	ee77 6a67 	vsub.f32	s13, s14, s15
 802b7a2:	ee65 7ac3 	vnmul.f32	s15, s11, s6
 802b7a6:	eee6 7a86 	vfma.f32	s15, s13, s12
 802b7aa:	ee77 7ac7 	vsub.f32	s15, s15, s14
 802b7ae:	eed3 7a05 	vfnms.f32	s15, s6, s10
 802b7b2:	e74d      	b.n	802b650 <__ieee754_logf+0x78>
 802b7b4:	ee77 7a67 	vsub.f32	s15, s14, s15
 802b7b8:	eea7 7ac6 	vfms.f32	s14, s15, s12
 802b7bc:	eef0 7a47 	vmov.f32	s15, s14
 802b7c0:	e746      	b.n	802b650 <__ieee754_logf+0x78>
 802b7c2:	bf00      	nop
 802b7c4:	004afb20 	.word	0x004afb20
 802b7c8:	00000000 	.word	0x00000000
 802b7cc:	cc000000 	.word	0xcc000000
 802b7d0:	4c000000 	.word	0x4c000000
 802b7d4:	ffcf5c30 	.word	0xffcf5c30
 802b7d8:	3e178897 	.word	0x3e178897
 802b7dc:	3e3a3325 	.word	0x3e3a3325
 802b7e0:	3e924925 	.word	0x3e924925
 802b7e4:	3e1cd04f 	.word	0x3e1cd04f
 802b7e8:	3e638e29 	.word	0x3e638e29
 802b7ec:	3f2aaaab 	.word	0x3f2aaaab
 802b7f0:	3ecccccd 	.word	0x3ecccccd
 802b7f4:	3eaaaaab 	.word	0x3eaaaaab
 802b7f8:	3717f7d1 	.word	0x3717f7d1
 802b7fc:	3f317180 	.word	0x3f317180

0802b800 <__ieee754_powf>:
 802b800:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 802b804:	ed2d 8b02 	vpush	{d8}
 802b808:	f031 4600 	bics.w	r6, r1, #2147483648	; 0x80000000
 802b80c:	b083      	sub	sp, #12
 802b80e:	460c      	mov	r4, r1
 802b810:	d014      	beq.n	802b83c <__ieee754_powf+0x3c>
 802b812:	f020 4700 	bic.w	r7, r0, #2147483648	; 0x80000000
 802b816:	f1b7 4fff 	cmp.w	r7, #2139095040	; 0x7f800000
 802b81a:	4605      	mov	r5, r0
 802b81c:	4680      	mov	r8, r0
 802b81e:	dd07      	ble.n	802b830 <__ieee754_powf+0x30>
 802b820:	4857      	ldr	r0, [pc, #348]	; (802b980 <__ieee754_powf+0x180>)
 802b822:	b003      	add	sp, #12
 802b824:	ecbd 8b02 	vpop	{d8}
 802b828:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
 802b82c:	f000 be62 	b.w	802c4f4 <nanf>
 802b830:	f1b6 4fff 	cmp.w	r6, #2139095040	; 0x7f800000
 802b834:	dd09      	ble.n	802b84a <__ieee754_powf+0x4a>
 802b836:	f1b7 5f7e 	cmp.w	r7, #1065353216	; 0x3f800000
 802b83a:	d1f1      	bne.n	802b820 <__ieee754_powf+0x20>
 802b83c:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 802b840:	b003      	add	sp, #12
 802b842:	ecbd 8b02 	vpop	{d8}
 802b846:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 802b84a:	2800      	cmp	r0, #0
 802b84c:	db5a      	blt.n	802b904 <__ieee754_powf+0x104>
 802b84e:	f04f 0900 	mov.w	r9, #0
 802b852:	f1b6 4fff 	cmp.w	r6, #2139095040	; 0x7f800000
 802b856:	d04d      	beq.n	802b8f4 <__ieee754_powf+0xf4>
 802b858:	f1b6 5f7e 	cmp.w	r6, #1065353216	; 0x3f800000
 802b85c:	d065      	beq.n	802b92a <__ieee754_powf+0x12a>
 802b85e:	f1b4 4f80 	cmp.w	r4, #1073741824	; 0x40000000
 802b862:	d06e      	beq.n	802b942 <__ieee754_powf+0x142>
 802b864:	f1b4 5f7c 	cmp.w	r4, #1056964608	; 0x3f000000
 802b868:	d01f      	beq.n	802b8aa <__ieee754_powf+0xaa>
 802b86a:	4628      	mov	r0, r5
 802b86c:	9101      	str	r1, [sp, #4]
 802b86e:	f000 fcfb 	bl	802c268 <fabsf>
 802b872:	f1b7 4fff 	cmp.w	r7, #2139095040	; 0x7f800000
 802b876:	ee07 0a90 	vmov	s15, r0
 802b87a:	d031      	beq.n	802b8e0 <__ieee754_powf+0xe0>
 802b87c:	9901      	ldr	r1, [sp, #4]
 802b87e:	b37f      	cbz	r7, 802b8e0 <__ieee754_powf+0xe0>
 802b880:	f1b7 5f7e 	cmp.w	r7, #1065353216	; 0x3f800000
 802b884:	d02c      	beq.n	802b8e0 <__ieee754_powf+0xe0>
 802b886:	ea4f 73d8 	mov.w	r3, r8, lsr #31
 802b88a:	3b01      	subs	r3, #1
 802b88c:	ea59 0203 	orrs.w	r2, r9, r3
 802b890:	d066      	beq.n	802b960 <__ieee754_powf+0x160>
 802b892:	f1b6 4f9a 	cmp.w	r6, #1291845632	; 0x4d000000
 802b896:	dd79      	ble.n	802b98c <__ieee754_powf+0x18c>
 802b898:	4a3a      	ldr	r2, [pc, #232]	; (802b984 <__ieee754_powf+0x184>)
 802b89a:	4297      	cmp	r7, r2
 802b89c:	f300 81dc 	bgt.w	802bc58 <__ieee754_powf+0x458>
 802b8a0:	2c00      	cmp	r4, #0
 802b8a2:	f2c0 81e0 	blt.w	802bc66 <__ieee754_powf+0x466>
 802b8a6:	2000      	movs	r0, #0
 802b8a8:	e7ca      	b.n	802b840 <__ieee754_powf+0x40>
 802b8aa:	f1b8 0f00 	cmp.w	r8, #0
 802b8ae:	da4f      	bge.n	802b950 <__ieee754_powf+0x150>
 802b8b0:	4628      	mov	r0, r5
 802b8b2:	9101      	str	r1, [sp, #4]
 802b8b4:	f000 fcd8 	bl	802c268 <fabsf>
 802b8b8:	f1b7 4fff 	cmp.w	r7, #2139095040	; 0x7f800000
 802b8bc:	ee07 0a90 	vmov	s15, r0
 802b8c0:	9901      	ldr	r1, [sp, #4]
 802b8c2:	d001      	beq.n	802b8c8 <__ieee754_powf+0xc8>
 802b8c4:	2f00      	cmp	r7, #0
 802b8c6:	d1db      	bne.n	802b880 <__ieee754_powf+0x80>
 802b8c8:	f1a7 577e 	sub.w	r7, r7, #1065353216	; 0x3f800000
 802b8cc:	ea59 0307 	orrs.w	r3, r9, r7
 802b8d0:	d048      	beq.n	802b964 <__ieee754_powf+0x164>
 802b8d2:	f1b9 0f01 	cmp.w	r9, #1
 802b8d6:	f000 81ba 	beq.w	802bc4e <__ieee754_powf+0x44e>
 802b8da:	ee17 0a90 	vmov	r0, s15
 802b8de:	e7af      	b.n	802b840 <__ieee754_powf+0x40>
 802b8e0:	2c00      	cmp	r4, #0
 802b8e2:	bfbc      	itt	lt
 802b8e4:	eeb7 7a00 	vmovlt.f32	s14, #112	; 0x70
 802b8e8:	eec7 7a27 	vdivlt.f32	s15, s14, s15
 802b8ec:	f1b8 0f00 	cmp.w	r8, #0
 802b8f0:	daf3      	bge.n	802b8da <__ieee754_powf+0xda>
 802b8f2:	e7e9      	b.n	802b8c8 <__ieee754_powf+0xc8>
 802b8f4:	f1b7 5f7e 	cmp.w	r7, #1065353216	; 0x3f800000
 802b8f8:	d0a0      	beq.n	802b83c <__ieee754_powf+0x3c>
 802b8fa:	dd1d      	ble.n	802b938 <__ieee754_powf+0x138>
 802b8fc:	2c00      	cmp	r4, #0
 802b8fe:	dbd2      	blt.n	802b8a6 <__ieee754_powf+0xa6>
 802b900:	4608      	mov	r0, r1
 802b902:	e79d      	b.n	802b840 <__ieee754_powf+0x40>
 802b904:	f1b6 4f97 	cmp.w	r6, #1266679808	; 0x4b800000
 802b908:	da13      	bge.n	802b932 <__ieee754_powf+0x132>
 802b90a:	f1b6 5f7e 	cmp.w	r6, #1065353216	; 0x3f800000
 802b90e:	db09      	blt.n	802b924 <__ieee754_powf+0x124>
 802b910:	15f3      	asrs	r3, r6, #23
 802b912:	f1c3 0396 	rsb	r3, r3, #150	; 0x96
 802b916:	fa46 f203 	asr.w	r2, r6, r3
 802b91a:	fa02 f303 	lsl.w	r3, r2, r3
 802b91e:	42b3      	cmp	r3, r6
 802b920:	f000 8190 	beq.w	802bc44 <__ieee754_powf+0x444>
 802b924:	f04f 0900 	mov.w	r9, #0
 802b928:	e796      	b.n	802b858 <__ieee754_powf+0x58>
 802b92a:	2c00      	cmp	r4, #0
 802b92c:	db1f      	blt.n	802b96e <__ieee754_powf+0x16e>
 802b92e:	4628      	mov	r0, r5
 802b930:	e786      	b.n	802b840 <__ieee754_powf+0x40>
 802b932:	f04f 0902 	mov.w	r9, #2
 802b936:	e78c      	b.n	802b852 <__ieee754_powf+0x52>
 802b938:	2c00      	cmp	r4, #0
 802b93a:	dab4      	bge.n	802b8a6 <__ieee754_powf+0xa6>
 802b93c:	f081 4000 	eor.w	r0, r1, #2147483648	; 0x80000000
 802b940:	e77e      	b.n	802b840 <__ieee754_powf+0x40>
 802b942:	ee07 5a90 	vmov	s15, r5
 802b946:	ee67 7aa7 	vmul.f32	s15, s15, s15
 802b94a:	ee17 0a90 	vmov	r0, s15
 802b94e:	e777      	b.n	802b840 <__ieee754_powf+0x40>
 802b950:	4628      	mov	r0, r5
 802b952:	b003      	add	sp, #12
 802b954:	ecbd 8b02 	vpop	{d8}
 802b958:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
 802b95c:	f000 ba56 	b.w	802be0c <__ieee754_sqrtf>
 802b960:	ee07 5a90 	vmov	s15, r5
 802b964:	ee77 7ae7 	vsub.f32	s15, s15, s15
 802b968:	eec7 7aa7 	vdiv.f32	s15, s15, s15
 802b96c:	e7b5      	b.n	802b8da <__ieee754_powf+0xda>
 802b96e:	ee07 5a10 	vmov	s14, r5
 802b972:	eef7 7a00 	vmov.f32	s15, #112	; 0x70
 802b976:	eec7 7a87 	vdiv.f32	s15, s15, s14
 802b97a:	ee17 0a90 	vmov	r0, s15
 802b97e:	e75f      	b.n	802b840 <__ieee754_powf+0x40>
 802b980:	0802f31c 	.word	0x0802f31c
 802b984:	3f7ffff7 	.word	0x3f7ffff7
 802b988:	4b800000 	.word	0x4b800000
 802b98c:	f5b7 0f00 	cmp.w	r7, #8388608	; 0x800000
 802b990:	f280 8173 	bge.w	802bc7a <__ieee754_powf+0x47a>
 802b994:	ed1f 7a04 	vldr	s14, [pc, #-16]	; 802b988 <__ieee754_powf+0x188>
 802b998:	ee67 7a87 	vmul.f32	s15, s15, s14
 802b99c:	f06f 0017 	mvn.w	r0, #23
 802b9a0:	ee17 7a90 	vmov	r7, s15
 802b9a4:	4dde      	ldr	r5, [pc, #888]	; (802bd20 <__ieee754_powf+0x520>)
 802b9a6:	15fa      	asrs	r2, r7, #23
 802b9a8:	f3c7 0716 	ubfx	r7, r7, #0, #23
 802b9ac:	3a7f      	subs	r2, #127	; 0x7f
 802b9ae:	42af      	cmp	r7, r5
 802b9b0:	4402      	add	r2, r0
 802b9b2:	f047 507e 	orr.w	r0, r7, #1065353216	; 0x3f800000
 802b9b6:	f340 815d 	ble.w	802bc74 <__ieee754_powf+0x474>
 802b9ba:	4dda      	ldr	r5, [pc, #872]	; (802bd24 <__ieee754_powf+0x524>)
 802b9bc:	42af      	cmp	r7, r5
 802b9be:	f340 81ab 	ble.w	802bd18 <__ieee754_powf+0x518>
 802b9c2:	2600      	movs	r6, #0
 802b9c4:	3201      	adds	r2, #1
 802b9c6:	f5a0 0000 	sub.w	r0, r0, #8388608	; 0x800000
 802b9ca:	4635      	mov	r5, r6
 802b9cc:	f8df c3b4 	ldr.w	ip, [pc, #948]	; 802bd84 <__ieee754_powf+0x584>
 802b9d0:	eddf 2ad5 	vldr	s5, [pc, #852]	; 802bd28 <__ieee754_powf+0x528>
 802b9d4:	ed9f 0ad5 	vldr	s0, [pc, #852]	; 802bd2c <__ieee754_powf+0x52c>
 802b9d8:	eddf 0ad5 	vldr	s1, [pc, #852]	; 802bd30 <__ieee754_powf+0x530>
 802b9dc:	ed9f 1aeb 	vldr	s2, [pc, #940]	; 802bd8c <__ieee754_powf+0x58c>
 802b9e0:	eddf 1ad4 	vldr	s3, [pc, #848]	; 802bd34 <__ieee754_powf+0x534>
 802b9e4:	ed9f 2ad4 	vldr	s4, [pc, #848]	; 802bd38 <__ieee754_powf+0x538>
 802b9e8:	eddf 7ad4 	vldr	s15, [pc, #848]	; 802bd3c <__ieee754_powf+0x53c>
 802b9ec:	ed9f 3ad4 	vldr	s6, [pc, #848]	; 802bd40 <__ieee754_powf+0x540>
 802b9f0:	4fd4      	ldr	r7, [pc, #848]	; (802bd44 <__ieee754_powf+0x544>)
 802b9f2:	ed9f 4ad5 	vldr	s8, [pc, #852]	; 802bd48 <__ieee754_powf+0x548>
 802b9f6:	f8df e390 	ldr.w	lr, [pc, #912]	; 802bd88 <__ieee754_powf+0x588>
 802b9fa:	00ad      	lsls	r5, r5, #2
 802b9fc:	44ac      	add	ip, r5
 802b9fe:	ee07 0a10 	vmov	s14, r0
 802ba02:	ed9c 6a00 	vldr	s12, [ip]
 802ba06:	ee77 5a06 	vadd.f32	s11, s14, s12
 802ba0a:	eef7 6a00 	vmov.f32	s13, #112	; 0x70
 802ba0e:	eec6 5aa5 	vdiv.f32	s11, s13, s11
 802ba12:	1040      	asrs	r0, r0, #1
 802ba14:	f040 5000 	orr.w	r0, r0, #536870912	; 0x20000000
 802ba18:	f500 2080 	add.w	r0, r0, #262144	; 0x40000
 802ba1c:	4430      	add	r0, r6
 802ba1e:	ee04 0a90 	vmov	s9, r0
 802ba22:	ee77 6a46 	vsub.f32	s13, s14, s12
 802ba26:	ee34 6ac6 	vsub.f32	s12, s9, s12
 802ba2a:	ee66 3aa5 	vmul.f32	s7, s13, s11
 802ba2e:	ee37 7a46 	vsub.f32	s14, s14, s12
 802ba32:	ee23 6aa3 	vmul.f32	s12, s7, s7
 802ba36:	ee13 6a90 	vmov	r6, s7
 802ba3a:	eea6 0a22 	vfma.f32	s0, s12, s5
 802ba3e:	f426 667f 	bic.w	r6, r6, #4080	; 0xff0
 802ba42:	f026 060f 	bic.w	r6, r6, #15
 802ba46:	ee05 6a10 	vmov	s10, r6
 802ba4a:	eee0 0a06 	vfma.f32	s1, s0, s12
 802ba4e:	1978      	adds	r0, r7, r5
 802ba50:	4475      	add	r5, lr
 802ba52:	eef1 2a45 	vneg.f32	s5, s10
 802ba56:	eee2 6aa4 	vfma.f32	s13, s5, s9
 802ba5a:	eef0 4a41 	vmov.f32	s9, s2
 802ba5e:	eee0 4a86 	vfma.f32	s9, s1, s12
 802ba62:	eee2 6a87 	vfma.f32	s13, s5, s14
 802ba66:	eee4 1a86 	vfma.f32	s3, s9, s12
 802ba6a:	ee66 5aa5 	vmul.f32	s11, s13, s11
 802ba6e:	eef0 6a42 	vmov.f32	s13, s4
 802ba72:	eee1 6a86 	vfma.f32	s13, s3, s12
 802ba76:	ee33 7a85 	vadd.f32	s14, s7, s10
 802ba7a:	ee26 6a06 	vmul.f32	s12, s12, s12
 802ba7e:	ee27 7a25 	vmul.f32	s14, s14, s11
 802ba82:	eef0 4a08 	vmov.f32	s9, #8
 802ba86:	eea6 7a26 	vfma.f32	s14, s12, s13
 802ba8a:	eef0 6a64 	vmov.f32	s13, s9
 802ba8e:	eee5 6a05 	vfma.f32	s13, s10, s10
 802ba92:	edd0 1a00 	vldr	s3, [r0]
 802ba96:	ed95 2a00 	vldr	s4, [r5]
 802ba9a:	ee36 6a87 	vadd.f32	s12, s13, s14
 802ba9e:	ee06 2a90 	vmov	s13, r2
 802baa2:	ee16 2a10 	vmov	r2, s12
 802baa6:	f422 627f 	bic.w	r2, r2, #4080	; 0xff0
 802baaa:	f022 020f 	bic.w	r2, r2, #15
 802baae:	ee06 2a10 	vmov	s12, r2
 802bab2:	ee76 4a64 	vsub.f32	s9, s12, s9
 802bab6:	eef8 6ae6 	vcvt.f32.s32	s13, s13
 802baba:	eee2 4a85 	vfma.f32	s9, s5, s10
 802babe:	ee37 7a64 	vsub.f32	s14, s14, s9
 802bac2:	ee27 7a23 	vmul.f32	s14, s14, s7
 802bac6:	eea5 7a86 	vfma.f32	s14, s11, s12
 802baca:	eef0 5a47 	vmov.f32	s11, s14
 802bace:	eee5 5a06 	vfma.f32	s11, s10, s12
 802bad2:	ee15 2a90 	vmov	r2, s11
 802bad6:	f422 627f 	bic.w	r2, r2, #4080	; 0xff0
 802bada:	f022 020f 	bic.w	r2, r2, #15
 802bade:	ee05 2a10 	vmov	s10, r2
 802bae2:	eea2 5a86 	vfma.f32	s10, s5, s12
 802bae6:	ee05 2a90 	vmov	s11, r2
 802baea:	ee37 7a45 	vsub.f32	s14, s14, s10
 802baee:	ee67 7a27 	vmul.f32	s15, s14, s15
 802baf2:	eee5 7a83 	vfma.f32	s15, s11, s6
 802baf6:	ee77 7aa1 	vadd.f32	s15, s15, s3
 802bafa:	eeb0 7a67 	vmov.f32	s14, s15
 802bafe:	eea5 7a84 	vfma.f32	s14, s11, s8
 802bb02:	ee37 7a02 	vadd.f32	s14, s14, s4
 802bb06:	ee37 7a26 	vadd.f32	s14, s14, s13
 802bb0a:	ee17 2a10 	vmov	r2, s14
 802bb0e:	f422 627f 	bic.w	r2, r2, #4080	; 0xff0
 802bb12:	f022 020f 	bic.w	r2, r2, #15
 802bb16:	ee07 2a10 	vmov	s14, r2
 802bb1a:	ee77 6a66 	vsub.f32	s13, s14, s13
 802bb1e:	ee36 7ac2 	vsub.f32	s14, s13, s4
 802bb22:	eea5 7ac4 	vfms.f32	s14, s11, s8
 802bb26:	ee77 7ac7 	vsub.f32	s15, s15, s14
 802bb2a:	f424 647f 	bic.w	r4, r4, #4080	; 0xff0
 802bb2e:	f024 040f 	bic.w	r4, r4, #15
 802bb32:	ee07 1a10 	vmov	s14, r1
 802bb36:	ee06 4a90 	vmov	s13, r4
 802bb3a:	ee67 7a27 	vmul.f32	s15, s14, s15
 802bb3e:	ee77 6a66 	vsub.f32	s13, s14, s13
 802bb42:	ee06 4a10 	vmov	s12, r4
 802bb46:	ee07 2a10 	vmov	s14, r2
 802bb4a:	ee27 7a06 	vmul.f32	s14, s14, s12
 802bb4e:	ee06 2a10 	vmov	s12, r2
 802bb52:	eee6 7a86 	vfma.f32	s15, s13, s12
 802bb56:	f109 39ff 	add.w	r9, r9, #4294967295
 802bb5a:	ea59 0303 	orrs.w	r3, r9, r3
 802bb5e:	eeb7 8a00 	vmov.f32	s16, #112	; 0x70
 802bb62:	ee77 6a87 	vadd.f32	s13, s15, s14
 802bb66:	eebf 6a00 	vmov.f32	s12, #240	; 0xf0
 802bb6a:	ee16 3a90 	vmov	r3, s13
 802bb6e:	bf08      	it	eq
 802bb70:	eeb0 8a46 	vmoveq.f32	s16, s12
 802bb74:	2b00      	cmp	r3, #0
 802bb76:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
 802bb7a:	f340 80b8 	ble.w	802bcee <__ieee754_powf+0x4ee>
 802bb7e:	f1b2 4f86 	cmp.w	r2, #1124073472	; 0x43000000
 802bb82:	f300 8087 	bgt.w	802bc94 <__ieee754_powf+0x494>
 802bb86:	d07a      	beq.n	802bc7e <__ieee754_powf+0x47e>
 802bb88:	f1b2 5f7c 	cmp.w	r2, #1056964608	; 0x3f000000
 802bb8c:	f300 808b 	bgt.w	802bca6 <__ieee754_powf+0x4a6>
 802bb90:	2200      	movs	r2, #0
 802bb92:	4611      	mov	r1, r2
 802bb94:	f423 637f 	bic.w	r3, r3, #4080	; 0xff0
 802bb98:	f023 030f 	bic.w	r3, r3, #15
 802bb9c:	ee06 3a10 	vmov	s12, r3
 802bba0:	eddf 6a6a 	vldr	s13, [pc, #424]	; 802bd4c <__ieee754_powf+0x54c>
 802bba4:	eddf 5a6a 	vldr	s11, [pc, #424]	; 802bd50 <__ieee754_powf+0x550>
 802bba8:	ed9f 3a6a 	vldr	s6, [pc, #424]	; 802bd54 <__ieee754_powf+0x554>
 802bbac:	ed9f 2a6a 	vldr	s4, [pc, #424]	; 802bd58 <__ieee754_powf+0x558>
 802bbb0:	eddf 3a6a 	vldr	s7, [pc, #424]	; 802bd5c <__ieee754_powf+0x55c>
 802bbb4:	ed9f 4a6a 	vldr	s8, [pc, #424]	; 802bd60 <__ieee754_powf+0x560>
 802bbb8:	eddf 4a6a 	vldr	s9, [pc, #424]	; 802bd64 <__ieee754_powf+0x564>
 802bbbc:	ed9f 5a6a 	vldr	s10, [pc, #424]	; 802bd68 <__ieee754_powf+0x568>
 802bbc0:	ee36 7a47 	vsub.f32	s14, s12, s14
 802bbc4:	eef0 2a00 	vmov.f32	s5, #0
 802bbc8:	ee77 7ac7 	vsub.f32	s15, s15, s14
 802bbcc:	ee26 7a26 	vmul.f32	s14, s12, s13
 802bbd0:	eea7 7aa5 	vfma.f32	s14, s15, s11
 802bbd4:	eef7 5a00 	vmov.f32	s11, #112	; 0x70
 802bbd8:	eef0 6a47 	vmov.f32	s13, s14
 802bbdc:	eee6 6a03 	vfma.f32	s13, s12, s6
 802bbe0:	eef0 7a47 	vmov.f32	s15, s14
 802bbe4:	ee26 7aa6 	vmul.f32	s14, s13, s13
 802bbe8:	eef0 1a66 	vmov.f32	s3, s13
 802bbec:	eee7 3a02 	vfma.f32	s7, s14, s4
 802bbf0:	eee6 1a43 	vfms.f32	s3, s12, s6
 802bbf4:	eea3 4a87 	vfma.f32	s8, s7, s14
 802bbf8:	eeb0 6a66 	vmov.f32	s12, s13
 802bbfc:	eee4 4a07 	vfma.f32	s9, s8, s14
 802bc00:	ee77 7ae1 	vsub.f32	s15, s15, s3
 802bc04:	eea4 5a87 	vfma.f32	s10, s9, s14
 802bc08:	eee6 7aa7 	vfma.f32	s15, s13, s15
 802bc0c:	eea5 6a47 	vfms.f32	s12, s10, s14
 802bc10:	ee26 7a86 	vmul.f32	s14, s13, s12
 802bc14:	ee36 6a62 	vsub.f32	s12, s12, s5
 802bc18:	ee87 7a06 	vdiv.f32	s14, s14, s12
 802bc1c:	ee77 7a67 	vsub.f32	s15, s14, s15
 802bc20:	ee77 7ae6 	vsub.f32	s15, s15, s13
 802bc24:	ee75 7ae7 	vsub.f32	s15, s11, s15
 802bc28:	ee17 3a90 	vmov	r3, s15
 802bc2c:	4413      	add	r3, r2
 802bc2e:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 802bc32:	f2c0 80e4 	blt.w	802bdfe <__ieee754_powf+0x5fe>
 802bc36:	ee07 3a90 	vmov	s15, r3
 802bc3a:	ee68 7a27 	vmul.f32	s15, s16, s15
 802bc3e:	ee17 0a90 	vmov	r0, s15
 802bc42:	e5fd      	b.n	802b840 <__ieee754_powf+0x40>
 802bc44:	f002 0201 	and.w	r2, r2, #1
 802bc48:	f1c2 0902 	rsb	r9, r2, #2
 802bc4c:	e604      	b.n	802b858 <__ieee754_powf+0x58>
 802bc4e:	eef1 7a67 	vneg.f32	s15, s15
 802bc52:	ee17 0a90 	vmov	r0, s15
 802bc56:	e5f3      	b.n	802b840 <__ieee754_powf+0x40>
 802bc58:	4a44      	ldr	r2, [pc, #272]	; (802bd6c <__ieee754_powf+0x56c>)
 802bc5a:	4297      	cmp	r7, r2
 802bc5c:	f340 809e 	ble.w	802bd9c <__ieee754_powf+0x59c>
 802bc60:	2c00      	cmp	r4, #0
 802bc62:	f77f ae20 	ble.w	802b8a6 <__ieee754_powf+0xa6>
 802bc66:	eddf 7a42 	vldr	s15, [pc, #264]	; 802bd70 <__ieee754_powf+0x570>
 802bc6a:	ee67 7aa7 	vmul.f32	s15, s15, s15
 802bc6e:	ee17 0a90 	vmov	r0, s15
 802bc72:	e5e5      	b.n	802b840 <__ieee754_powf+0x40>
 802bc74:	2600      	movs	r6, #0
 802bc76:	4635      	mov	r5, r6
 802bc78:	e6a8      	b.n	802b9cc <__ieee754_powf+0x1cc>
 802bc7a:	2000      	movs	r0, #0
 802bc7c:	e692      	b.n	802b9a4 <__ieee754_powf+0x1a4>
 802bc7e:	ed9f 6a3d 	vldr	s12, [pc, #244]	; 802bd74 <__ieee754_powf+0x574>
 802bc82:	ee76 6ac7 	vsub.f32	s13, s13, s14
 802bc86:	ee37 6a86 	vadd.f32	s12, s15, s12
 802bc8a:	eeb4 6ae6 	vcmpe.f32	s12, s13
 802bc8e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802bc92:	dd08      	ble.n	802bca6 <__ieee754_powf+0x4a6>
 802bc94:	eddf 7a36 	vldr	s15, [pc, #216]	; 802bd70 <__ieee754_powf+0x570>
 802bc98:	ee28 8a27 	vmul.f32	s16, s16, s15
 802bc9c:	ee68 7a27 	vmul.f32	s15, s16, s15
 802bca0:	ee17 0a90 	vmov	r0, s15
 802bca4:	e5cc      	b.n	802b840 <__ieee754_powf+0x40>
 802bca6:	15d2      	asrs	r2, r2, #23
 802bca8:	f44f 0100 	mov.w	r1, #8388608	; 0x800000
 802bcac:	3a7e      	subs	r2, #126	; 0x7e
 802bcae:	fa41 f202 	asr.w	r2, r1, r2
 802bcb2:	441a      	add	r2, r3
 802bcb4:	f3c2 50c7 	ubfx	r0, r2, #23, #8
 802bcb8:	4c2f      	ldr	r4, [pc, #188]	; (802bd78 <__ieee754_powf+0x578>)
 802bcba:	f1a0 057f 	sub.w	r5, r0, #127	; 0x7f
 802bcbe:	412c      	asrs	r4, r5
 802bcc0:	f3c2 0116 	ubfx	r1, r2, #0, #23
 802bcc4:	ea22 0204 	bic.w	r2, r2, r4
 802bcc8:	ee06 2a90 	vmov	s13, r2
 802bccc:	f1c0 0096 	rsb	r0, r0, #150	; 0x96
 802bcd0:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
 802bcd4:	ee37 7a66 	vsub.f32	s14, s14, s13
 802bcd8:	4101      	asrs	r1, r0
 802bcda:	ea81 71e3 	eor.w	r1, r1, r3, asr #31
 802bcde:	ee77 6a87 	vadd.f32	s13, s15, s14
 802bce2:	eb01 71d3 	add.w	r1, r1, r3, lsr #31
 802bce6:	05ca      	lsls	r2, r1, #23
 802bce8:	ee16 3a90 	vmov	r3, s13
 802bcec:	e752      	b.n	802bb94 <__ieee754_powf+0x394>
 802bcee:	4923      	ldr	r1, [pc, #140]	; (802bd7c <__ieee754_powf+0x57c>)
 802bcf0:	428a      	cmp	r2, r1
 802bcf2:	dc08      	bgt.n	802bd06 <__ieee754_powf+0x506>
 802bcf4:	f47f af48 	bne.w	802bb88 <__ieee754_powf+0x388>
 802bcf8:	ee76 6ac7 	vsub.f32	s13, s13, s14
 802bcfc:	eef4 7ae6 	vcmpe.f32	s15, s13
 802bd00:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802bd04:	d8cf      	bhi.n	802bca6 <__ieee754_powf+0x4a6>
 802bd06:	eddf 7a1e 	vldr	s15, [pc, #120]	; 802bd80 <__ieee754_powf+0x580>
 802bd0a:	ee28 8a27 	vmul.f32	s16, s16, s15
 802bd0e:	ee68 7a27 	vmul.f32	s15, s16, s15
 802bd12:	ee17 0a90 	vmov	r0, s15
 802bd16:	e593      	b.n	802b840 <__ieee754_powf+0x40>
 802bd18:	f44f 1600 	mov.w	r6, #2097152	; 0x200000
 802bd1c:	2501      	movs	r5, #1
 802bd1e:	e655      	b.n	802b9cc <__ieee754_powf+0x1cc>
 802bd20:	001cc471 	.word	0x001cc471
 802bd24:	005db3d6 	.word	0x005db3d6
 802bd28:	3e53f142 	.word	0x3e53f142
 802bd2c:	3e6c3255 	.word	0x3e6c3255
 802bd30:	3e8ba305 	.word	0x3e8ba305
 802bd34:	3edb6db7 	.word	0x3edb6db7
 802bd38:	3f19999a 	.word	0x3f19999a
 802bd3c:	3f76384f 	.word	0x3f76384f
 802bd40:	369dc3a0 	.word	0x369dc3a0
 802bd44:	08031a0c 	.word	0x08031a0c
 802bd48:	3f763800 	.word	0x3f763800
 802bd4c:	35bfbe8c 	.word	0x35bfbe8c
 802bd50:	3f317218 	.word	0x3f317218
 802bd54:	3f317200 	.word	0x3f317200
 802bd58:	3331bb4c 	.word	0x3331bb4c
 802bd5c:	b5ddea0e 	.word	0xb5ddea0e
 802bd60:	388ab355 	.word	0x388ab355
 802bd64:	bb360b61 	.word	0xbb360b61
 802bd68:	3e2aaaab 	.word	0x3e2aaaab
 802bd6c:	3f800007 	.word	0x3f800007
 802bd70:	7149f2ca 	.word	0x7149f2ca
 802bd74:	3338aa3c 	.word	0x3338aa3c
 802bd78:	007fffff 	.word	0x007fffff
 802bd7c:	43160000 	.word	0x43160000
 802bd80:	0da24260 	.word	0x0da24260
 802bd84:	08031a14 	.word	0x08031a14
 802bd88:	08031a04 	.word	0x08031a04
 802bd8c:	3eaaaaab 	.word	0x3eaaaaab
 802bd90:	3fb8aa3b 	.word	0x3fb8aa3b
 802bd94:	3fb8aa00 	.word	0x3fb8aa00
 802bd98:	36eca570 	.word	0x36eca570
 802bd9c:	eeb7 7a00 	vmov.f32	s14, #112	; 0x70
 802bda0:	ee77 7ac7 	vsub.f32	s15, s15, s14
 802bda4:	ed1f 6a07 	vldr	s12, [pc, #-28]	; 802bd8c <__ieee754_powf+0x58c>
 802bda8:	ed1f 7a07 	vldr	s14, [pc, #-28]	; 802bd90 <__ieee754_powf+0x590>
 802bdac:	ed5f 4a06 	vldr	s9, [pc, #-24]	; 802bd98 <__ieee754_powf+0x598>
 802bdb0:	ed5f 5a08 	vldr	s11, [pc, #-32]	; 802bd94 <__ieee754_powf+0x594>
 802bdb4:	eeb1 5a67 	vneg.f32	s10, s15
 802bdb8:	eef5 6a00 	vmov.f32	s13, #80	; 0x50
 802bdbc:	eea5 6a26 	vfma.f32	s12, s10, s13
 802bdc0:	eef6 6a00 	vmov.f32	s13, #96	; 0x60
 802bdc4:	eee6 6a67 	vfms.f32	s13, s12, s15
 802bdc8:	eeb0 6a66 	vmov.f32	s12, s13
 802bdcc:	ee67 6aa7 	vmul.f32	s13, s15, s15
 802bdd0:	ee66 6a86 	vmul.f32	s13, s13, s12
 802bdd4:	ee27 7a66 	vnmul.f32	s14, s14, s13
 802bdd8:	eea7 7aa4 	vfma.f32	s14, s15, s9
 802bddc:	eef0 6a47 	vmov.f32	s13, s14
 802bde0:	eee7 6aa5 	vfma.f32	s13, s15, s11
 802bde4:	ee16 2a90 	vmov	r2, s13
 802bde8:	f422 627f 	bic.w	r2, r2, #4080	; 0xff0
 802bdec:	f022 020f 	bic.w	r2, r2, #15
 802bdf0:	ee07 2a90 	vmov	s15, r2
 802bdf4:	eee5 7a25 	vfma.f32	s15, s10, s11
 802bdf8:	ee77 7a67 	vsub.f32	s15, s14, s15
 802bdfc:	e695      	b.n	802bb2a <__ieee754_powf+0x32a>
 802bdfe:	ee17 0a90 	vmov	r0, s15
 802be02:	f000 fb7b 	bl	802c4fc <scalbnf>
 802be06:	ee07 0a90 	vmov	s15, r0
 802be0a:	e716      	b.n	802bc3a <__ieee754_powf+0x43a>

0802be0c <__ieee754_sqrtf>:
 802be0c:	f020 4200 	bic.w	r2, r0, #2147483648	; 0x80000000
 802be10:	f1b2 4fff 	cmp.w	r2, #2139095040	; 0x7f800000
 802be14:	b470      	push	{r4, r5, r6}
 802be16:	ee07 0a90 	vmov	s15, r0
 802be1a:	4603      	mov	r3, r0
 802be1c:	d232      	bcs.n	802be84 <__ieee754_sqrtf+0x78>
 802be1e:	b36a      	cbz	r2, 802be7c <__ieee754_sqrtf+0x70>
 802be20:	2800      	cmp	r0, #0
 802be22:	db41      	blt.n	802bea8 <__ieee754_sqrtf+0x9c>
 802be24:	f5b2 0f00 	cmp.w	r2, #8388608	; 0x800000
 802be28:	ea4f 51e0 	mov.w	r1, r0, asr #23
 802be2c:	d330      	bcc.n	802be90 <__ieee754_sqrtf+0x84>
 802be2e:	f1a1 027f 	sub.w	r2, r1, #127	; 0x7f
 802be32:	f3c3 0316 	ubfx	r3, r3, #0, #23
 802be36:	07d1      	lsls	r1, r2, #31
 802be38:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 802be3c:	bf48      	it	mi
 802be3e:	005b      	lslmi	r3, r3, #1
 802be40:	2400      	movs	r4, #0
 802be42:	1056      	asrs	r6, r2, #1
 802be44:	005b      	lsls	r3, r3, #1
 802be46:	4625      	mov	r5, r4
 802be48:	2119      	movs	r1, #25
 802be4a:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 802be4e:	18a8      	adds	r0, r5, r2
 802be50:	4298      	cmp	r0, r3
 802be52:	dc02      	bgt.n	802be5a <__ieee754_sqrtf+0x4e>
 802be54:	1a1b      	subs	r3, r3, r0
 802be56:	1885      	adds	r5, r0, r2
 802be58:	4414      	add	r4, r2
 802be5a:	3901      	subs	r1, #1
 802be5c:	ea4f 0343 	mov.w	r3, r3, lsl #1
 802be60:	ea4f 0252 	mov.w	r2, r2, lsr #1
 802be64:	d1f3      	bne.n	802be4e <__ieee754_sqrtf+0x42>
 802be66:	b113      	cbz	r3, 802be6e <__ieee754_sqrtf+0x62>
 802be68:	f004 0301 	and.w	r3, r4, #1
 802be6c:	441c      	add	r4, r3
 802be6e:	1064      	asrs	r4, r4, #1
 802be70:	f104 547c 	add.w	r4, r4, #1056964608	; 0x3f000000
 802be74:	eb04 53c6 	add.w	r3, r4, r6, lsl #23
 802be78:	ee07 3a90 	vmov	s15, r3
 802be7c:	ee17 0a90 	vmov	r0, s15
 802be80:	bc70      	pop	{r4, r5, r6}
 802be82:	4770      	bx	lr
 802be84:	eee7 7aa7 	vfma.f32	s15, s15, s15
 802be88:	bc70      	pop	{r4, r5, r6}
 802be8a:	ee17 0a90 	vmov	r0, s15
 802be8e:	4770      	bx	lr
 802be90:	f410 0200 	ands.w	r2, r0, #8388608	; 0x800000
 802be94:	d10d      	bne.n	802beb2 <__ieee754_sqrtf+0xa6>
 802be96:	005b      	lsls	r3, r3, #1
 802be98:	0218      	lsls	r0, r3, #8
 802be9a:	f102 0201 	add.w	r2, r2, #1
 802be9e:	d5fa      	bpl.n	802be96 <__ieee754_sqrtf+0x8a>
 802bea0:	f1c2 0201 	rsb	r2, r2, #1
 802bea4:	4411      	add	r1, r2
 802bea6:	e7c2      	b.n	802be2e <__ieee754_sqrtf+0x22>
 802bea8:	ee77 7ae7 	vsub.f32	s15, s15, s15
 802beac:	eec7 7aa7 	vdiv.f32	s15, s15, s15
 802beb0:	e7e4      	b.n	802be7c <__ieee754_sqrtf+0x70>
 802beb2:	2201      	movs	r2, #1
 802beb4:	4411      	add	r1, r2
 802beb6:	e7ba      	b.n	802be2e <__ieee754_sqrtf+0x22>

0802beb8 <matherr>:
 802beb8:	2000      	movs	r0, #0
 802beba:	4770      	bx	lr

0802bebc <nan>:
 802bebc:	2000      	movs	r0, #0
 802bebe:	4901      	ldr	r1, [pc, #4]	; (802bec4 <nan+0x8>)
 802bec0:	4770      	bx	lr
 802bec2:	bf00      	nop
 802bec4:	7ff80000 	.word	0x7ff80000

0802bec8 <rint>:
 802bec8:	b5f0      	push	{r4, r5, r6, r7, lr}
 802beca:	f3c1 5e0a 	ubfx	lr, r1, #20, #11
 802bece:	f2ae 35ff 	subw	r5, lr, #1023	; 0x3ff
 802bed2:	2d13      	cmp	r5, #19
 802bed4:	b083      	sub	sp, #12
 802bed6:	4602      	mov	r2, r0
 802bed8:	460b      	mov	r3, r1
 802beda:	460c      	mov	r4, r1
 802bedc:	ea4f 76d1 	mov.w	r6, r1, lsr #31
 802bee0:	4607      	mov	r7, r0
 802bee2:	dc2e      	bgt.n	802bf42 <rint+0x7a>
 802bee4:	2d00      	cmp	r5, #0
 802bee6:	db48      	blt.n	802bf7a <rint+0xb2>
 802bee8:	493b      	ldr	r1, [pc, #236]	; (802bfd8 <rint+0x110>)
 802beea:	4129      	asrs	r1, r5
 802beec:	ea01 0003 	and.w	r0, r1, r3
 802bef0:	4310      	orrs	r0, r2
 802bef2:	d02b      	beq.n	802bf4c <rint+0x84>
 802bef4:	0849      	lsrs	r1, r1, #1
 802bef6:	400b      	ands	r3, r1
 802bef8:	ea53 0702 	orrs.w	r7, r3, r2
 802befc:	d00c      	beq.n	802bf18 <rint+0x50>
 802befe:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 802bf02:	2d13      	cmp	r5, #19
 802bf04:	ea24 0101 	bic.w	r1, r4, r1
 802bf08:	fa43 f405 	asr.w	r4, r3, r5
 802bf0c:	ea44 0401 	orr.w	r4, r4, r1
 802bf10:	bf0c      	ite	eq
 802bf12:	f04f 4700 	moveq.w	r7, #2147483648	; 0x80000000
 802bf16:	2700      	movne	r7, #0
 802bf18:	4930      	ldr	r1, [pc, #192]	; (802bfdc <rint+0x114>)
 802bf1a:	eb01 06c6 	add.w	r6, r1, r6, lsl #3
 802bf1e:	4623      	mov	r3, r4
 802bf20:	e9d6 4500 	ldrd	r4, r5, [r6]
 802bf24:	463a      	mov	r2, r7
 802bf26:	4620      	mov	r0, r4
 802bf28:	4629      	mov	r1, r5
 802bf2a:	f000 fb73 	bl	802c614 <__adddf3>
 802bf2e:	e9cd 0100 	strd	r0, r1, [sp]
 802bf32:	4622      	mov	r2, r4
 802bf34:	462b      	mov	r3, r5
 802bf36:	e9dd 0100 	ldrd	r0, r1, [sp]
 802bf3a:	f000 fb69 	bl	802c610 <__aeabi_dsub>
 802bf3e:	b003      	add	sp, #12
 802bf40:	bdf0      	pop	{r4, r5, r6, r7, pc}
 802bf42:	2d33      	cmp	r5, #51	; 0x33
 802bf44:	dd06      	ble.n	802bf54 <rint+0x8c>
 802bf46:	f5b5 6f80 	cmp.w	r5, #1024	; 0x400
 802bf4a:	d041      	beq.n	802bfd0 <rint+0x108>
 802bf4c:	4610      	mov	r0, r2
 802bf4e:	4619      	mov	r1, r3
 802bf50:	b003      	add	sp, #12
 802bf52:	bdf0      	pop	{r4, r5, r6, r7, pc}
 802bf54:	f2ae 4e13 	subw	lr, lr, #1043	; 0x413
 802bf58:	f04f 31ff 	mov.w	r1, #4294967295
 802bf5c:	fa21 f10e 	lsr.w	r1, r1, lr
 802bf60:	4201      	tst	r1, r0
 802bf62:	d0f3      	beq.n	802bf4c <rint+0x84>
 802bf64:	0849      	lsrs	r1, r1, #1
 802bf66:	4201      	tst	r1, r0
 802bf68:	d0d6      	beq.n	802bf18 <rint+0x50>
 802bf6a:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 802bf6e:	ea20 0101 	bic.w	r1, r0, r1
 802bf72:	fa43 f70e 	asr.w	r7, r3, lr
 802bf76:	430f      	orrs	r7, r1
 802bf78:	e7ce      	b.n	802bf18 <rint+0x50>
 802bf7a:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 802bf7e:	4301      	orrs	r1, r0
 802bf80:	d0e4      	beq.n	802bf4c <rint+0x84>
 802bf82:	f3c3 0113 	ubfx	r1, r3, #0, #20
 802bf86:	ea41 0c00 	orr.w	ip, r1, r0
 802bf8a:	f1cc 0100 	rsb	r1, ip, #0
 802bf8e:	ea41 0c0c 	orr.w	ip, r1, ip
 802bf92:	4912      	ldr	r1, [pc, #72]	; (802bfdc <rint+0x114>)
 802bf94:	0c5c      	lsrs	r4, r3, #17
 802bf96:	ea4f 3c1c 	mov.w	ip, ip, lsr #12
 802bf9a:	f40c 2c00 	and.w	ip, ip, #524288	; 0x80000
 802bf9e:	0464      	lsls	r4, r4, #17
 802bfa0:	eb01 01c6 	add.w	r1, r1, r6, lsl #3
 802bfa4:	ea4c 0304 	orr.w	r3, ip, r4
 802bfa8:	e9d1 4500 	ldrd	r4, r5, [r1]
 802bfac:	4620      	mov	r0, r4
 802bfae:	4629      	mov	r1, r5
 802bfb0:	f000 fb30 	bl	802c614 <__adddf3>
 802bfb4:	e9cd 0100 	strd	r0, r1, [sp]
 802bfb8:	4622      	mov	r2, r4
 802bfba:	462b      	mov	r3, r5
 802bfbc:	e9dd 0100 	ldrd	r0, r1, [sp]
 802bfc0:	f000 fb26 	bl	802c610 <__aeabi_dsub>
 802bfc4:	f021 4400 	bic.w	r4, r1, #2147483648	; 0x80000000
 802bfc8:	ea44 73c6 	orr.w	r3, r4, r6, lsl #31
 802bfcc:	4619      	mov	r1, r3
 802bfce:	e7bf      	b.n	802bf50 <rint+0x88>
 802bfd0:	f000 fb20 	bl	802c614 <__adddf3>
 802bfd4:	e7bc      	b.n	802bf50 <rint+0x88>
 802bfd6:	bf00      	nop
 802bfd8:	000fffff 	.word	0x000fffff
 802bfdc:	08031a20 	.word	0x08031a20

0802bfe0 <expm1f>:
 802bfe0:	4992      	ldr	r1, [pc, #584]	; (802c22c <expm1f+0x24c>)
 802bfe2:	f020 4200 	bic.w	r2, r0, #2147483648	; 0x80000000
 802bfe6:	428a      	cmp	r2, r1
 802bfe8:	ee07 0a90 	vmov	s15, r0
 802bfec:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
 802bff0:	d913      	bls.n	802c01a <expm1f+0x3a>
 802bff2:	f1b2 4fff 	cmp.w	r2, #2139095040	; 0x7f800000
 802bff6:	f200 8085 	bhi.w	802c104 <expm1f+0x124>
 802bffa:	f000 80d2 	beq.w	802c1a2 <expm1f+0x1c2>
 802bffe:	2b00      	cmp	r3, #0
 802c000:	f040 80a4 	bne.w	802c14c <expm1f+0x16c>
 802c004:	4b8a      	ldr	r3, [pc, #552]	; (802c230 <expm1f+0x250>)
 802c006:	429a      	cmp	r2, r3
 802c008:	f200 8108 	bhi.w	802c21c <expm1f+0x23c>
 802c00c:	eddf 6a89 	vldr	s13, [pc, #548]	; 802c234 <expm1f+0x254>
 802c010:	eeb6 6a00 	vmov.f32	s12, #96	; 0x60
 802c014:	ee27 7aa6 	vmul.f32	s14, s15, s13
 802c018:	e085      	b.n	802c126 <expm1f+0x146>
 802c01a:	4987      	ldr	r1, [pc, #540]	; (802c238 <expm1f+0x258>)
 802c01c:	428a      	cmp	r2, r1
 802c01e:	d855      	bhi.n	802c0cc <expm1f+0xec>
 802c020:	f1b2 5f4c 	cmp.w	r2, #855638016	; 0x33000000
 802c024:	f0c0 80b2 	bcc.w	802c18c <expm1f+0x1ac>
 802c028:	2300      	movs	r3, #0
 802c02a:	eef6 2a00 	vmov.f32	s5, #96	; 0x60
 802c02e:	ee67 3aa2 	vmul.f32	s7, s15, s5
 802c032:	eddf 5a82 	vldr	s11, [pc, #520]	; 802c23c <expm1f+0x25c>
 802c036:	ed9f 5a82 	vldr	s10, [pc, #520]	; 802c240 <expm1f+0x260>
 802c03a:	ed9f 4a82 	vldr	s8, [pc, #520]	; 802c244 <expm1f+0x264>
 802c03e:	eddf 4a82 	vldr	s9, [pc, #520]	; 802c248 <expm1f+0x268>
 802c042:	ed9f 7a82 	vldr	s14, [pc, #520]	; 802c24c <expm1f+0x26c>
 802c046:	ee27 6aa3 	vmul.f32	s12, s15, s7
 802c04a:	eeb7 3a00 	vmov.f32	s6, #112	; 0x70
 802c04e:	eea6 5a25 	vfma.f32	s10, s12, s11
 802c052:	eef0 5a08 	vmov.f32	s11, #8
 802c056:	eea5 4a06 	vfma.f32	s8, s10, s12
 802c05a:	eeb1 5a08 	vmov.f32	s10, #24
 802c05e:	eee4 4a06 	vfma.f32	s9, s8, s12
 802c062:	eea4 7a86 	vfma.f32	s14, s9, s12
 802c066:	eef0 4a43 	vmov.f32	s9, s6
 802c06a:	eee7 4a06 	vfma.f32	s9, s14, s12
 802c06e:	eee4 5ae3 	vfms.f32	s11, s9, s7
 802c072:	eea7 5ae5 	vfms.f32	s10, s15, s11
 802c076:	ee34 7ae5 	vsub.f32	s14, s9, s11
 802c07a:	ee87 7a05 	vdiv.f32	s14, s14, s10
 802c07e:	ee27 7a06 	vmul.f32	s14, s14, s12
 802c082:	b3b3      	cbz	r3, 802c0f2 <expm1f+0x112>
 802c084:	ee37 7a66 	vsub.f32	s14, s14, s13
 802c088:	1c5a      	adds	r2, r3, #1
 802c08a:	eed7 6a27 	vfnms.f32	s13, s14, s15
 802c08e:	ee76 6ac6 	vsub.f32	s13, s13, s12
 802c092:	f000 80a1 	beq.w	802c1d8 <expm1f+0x1f8>
 802c096:	2b01      	cmp	r3, #1
 802c098:	d068      	beq.n	802c16c <expm1f+0x18c>
 802c09a:	1c5a      	adds	r2, r3, #1
 802c09c:	2a39      	cmp	r2, #57	; 0x39
 802c09e:	f200 808e 	bhi.w	802c1be <expm1f+0x1de>
 802c0a2:	2b16      	cmp	r3, #22
 802c0a4:	f300 809f 	bgt.w	802c1e6 <expm1f+0x206>
 802c0a8:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 802c0ac:	411a      	asrs	r2, r3
 802c0ae:	f1c2 527e 	rsb	r2, r2, #1065353216	; 0x3f800000
 802c0b2:	ee76 6ae7 	vsub.f32	s13, s13, s15
 802c0b6:	ee07 2a90 	vmov	s15, r2
 802c0ba:	ee77 7ae6 	vsub.f32	s15, s15, s13
 802c0be:	ee17 2a90 	vmov	r2, s15
 802c0c2:	eb02 53c3 	add.w	r3, r2, r3, lsl #23
 802c0c6:	ee07 3a90 	vmov	s15, r3
 802c0ca:	e018      	b.n	802c0fe <expm1f+0x11e>
 802c0cc:	4960      	ldr	r1, [pc, #384]	; (802c250 <expm1f+0x270>)
 802c0ce:	428a      	cmp	r2, r1
 802c0d0:	d81d      	bhi.n	802c10e <expm1f+0x12e>
 802c0d2:	ed9f 6a60 	vldr	s12, [pc, #384]	; 802c254 <expm1f+0x274>
 802c0d6:	2b00      	cmp	r3, #0
 802c0d8:	d16a      	bne.n	802c1b0 <expm1f+0x1d0>
 802c0da:	eddf 6a5f 	vldr	s13, [pc, #380]	; 802c258 <expm1f+0x278>
 802c0de:	ee37 7ac6 	vsub.f32	s14, s15, s12
 802c0e2:	2301      	movs	r3, #1
 802c0e4:	ee77 7a66 	vsub.f32	s15, s14, s13
 802c0e8:	ee37 7a67 	vsub.f32	s14, s14, s15
 802c0ec:	ee77 6a66 	vsub.f32	s13, s14, s13
 802c0f0:	e79b      	b.n	802c02a <expm1f+0x4a>
 802c0f2:	eef0 6a46 	vmov.f32	s13, s12
 802c0f6:	eed7 6a87 	vfnms.f32	s13, s15, s14
 802c0fa:	ee77 7ae6 	vsub.f32	s15, s15, s13
 802c0fe:	ee17 0a90 	vmov	r0, s15
 802c102:	4770      	bx	lr
 802c104:	ee77 7aa7 	vadd.f32	s15, s15, s15
 802c108:	ee17 0a90 	vmov	r0, s15
 802c10c:	4770      	bx	lr
 802c10e:	eddf 6a49 	vldr	s13, [pc, #292]	; 802c234 <expm1f+0x254>
 802c112:	2b00      	cmp	r3, #0
 802c114:	eeb6 6a00 	vmov.f32	s12, #96	; 0x60
 802c118:	eefe 5a00 	vmov.f32	s11, #224	; 0xe0
 802c11c:	ee27 7aa6 	vmul.f32	s14, s15, s13
 802c120:	bf18      	it	ne
 802c122:	eeb0 6a65 	vmovne.f32	s12, s11
 802c126:	ee37 7a06 	vadd.f32	s14, s14, s12
 802c12a:	eddf 5a4a 	vldr	s11, [pc, #296]	; 802c254 <expm1f+0x274>
 802c12e:	ed9f 6a4a 	vldr	s12, [pc, #296]	; 802c258 <expm1f+0x278>
 802c132:	eebd 7ac7 	vcvt.s32.f32	s14, s14
 802c136:	eef8 6ac7 	vcvt.f32.s32	s13, s14
 802c13a:	ee17 3a10 	vmov	r3, s14
 802c13e:	eee6 7ae5 	vfms.f32	s15, s13, s11
 802c142:	ee66 6a86 	vmul.f32	s13, s13, s12
 802c146:	eeb0 7a67 	vmov.f32	s14, s15
 802c14a:	e7cb      	b.n	802c0e4 <expm1f+0x104>
 802c14c:	ed9f 7a43 	vldr	s14, [pc, #268]	; 802c25c <expm1f+0x27c>
 802c150:	ee37 7a87 	vadd.f32	s14, s15, s14
 802c154:	eeb5 7ac0 	vcmpe.f32	s14, #0.0
 802c158:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802c15c:	d463      	bmi.n	802c226 <expm1f+0x246>
 802c15e:	eddf 6a35 	vldr	s13, [pc, #212]	; 802c234 <expm1f+0x254>
 802c162:	eebe 6a00 	vmov.f32	s12, #224	; 0xe0
 802c166:	ee27 7aa6 	vmul.f32	s14, s15, s13
 802c16a:	e7dc      	b.n	802c126 <expm1f+0x146>
 802c16c:	eebd 7a00 	vmov.f32	s14, #208	; 0xd0
 802c170:	eef4 7ac7 	vcmpe.f32	s15, s14
 802c174:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802c178:	d547      	bpl.n	802c20a <expm1f+0x22a>
 802c17a:	ee77 7aa2 	vadd.f32	s15, s15, s5
 802c17e:	eeb8 7a00 	vmov.f32	s14, #128	; 0x80
 802c182:	ee76 7ae7 	vsub.f32	s15, s13, s15
 802c186:	ee67 7a87 	vmul.f32	s15, s15, s14
 802c18a:	e7b8      	b.n	802c0fe <expm1f+0x11e>
 802c18c:	ed9f 7a34 	vldr	s14, [pc, #208]	; 802c260 <expm1f+0x280>
 802c190:	ee37 7a87 	vadd.f32	s14, s15, s14
 802c194:	ee37 7a47 	vsub.f32	s14, s14, s14
 802c198:	ee77 7ac7 	vsub.f32	s15, s15, s14
 802c19c:	ee17 0a90 	vmov	r0, s15
 802c1a0:	4770      	bx	lr
 802c1a2:	2b00      	cmp	r3, #0
 802c1a4:	eebf 7a00 	vmov.f32	s14, #240	; 0xf0
 802c1a8:	bf18      	it	ne
 802c1aa:	eef0 7a47 	vmovne.f32	s15, s14
 802c1ae:	e7a6      	b.n	802c0fe <expm1f+0x11e>
 802c1b0:	eddf 6a2c 	vldr	s13, [pc, #176]	; 802c264 <expm1f+0x284>
 802c1b4:	ee37 7a86 	vadd.f32	s14, s15, s12
 802c1b8:	f04f 33ff 	mov.w	r3, #4294967295
 802c1bc:	e792      	b.n	802c0e4 <expm1f+0x104>
 802c1be:	ee76 6ae7 	vsub.f32	s13, s13, s15
 802c1c2:	ee73 6a66 	vsub.f32	s13, s6, s13
 802c1c6:	ee16 2a90 	vmov	r2, s13
 802c1ca:	eb02 53c3 	add.w	r3, r2, r3, lsl #23
 802c1ce:	ee07 3a90 	vmov	s15, r3
 802c1d2:	ee77 7ac3 	vsub.f32	s15, s15, s6
 802c1d6:	e792      	b.n	802c0fe <expm1f+0x11e>
 802c1d8:	ee77 6ae6 	vsub.f32	s13, s15, s13
 802c1dc:	eefe 7a00 	vmov.f32	s15, #224	; 0xe0
 802c1e0:	eee6 7aa2 	vfma.f32	s15, s13, s5
 802c1e4:	e78b      	b.n	802c0fe <expm1f+0x11e>
 802c1e6:	f1c3 027f 	rsb	r2, r3, #127	; 0x7f
 802c1ea:	05d2      	lsls	r2, r2, #23
 802c1ec:	ee07 2a10 	vmov	s14, r2
 802c1f0:	ee76 6a87 	vadd.f32	s13, s13, s14
 802c1f4:	ee77 6ae6 	vsub.f32	s13, s15, s13
 802c1f8:	ee76 7a83 	vadd.f32	s15, s13, s6
 802c1fc:	ee17 2a90 	vmov	r2, s15
 802c200:	eb02 53c3 	add.w	r3, r2, r3, lsl #23
 802c204:	ee07 3a90 	vmov	s15, r3
 802c208:	e779      	b.n	802c0fe <expm1f+0x11e>
 802c20a:	ee77 6ae6 	vsub.f32	s13, s15, s13
 802c20e:	eef0 7a00 	vmov.f32	s15, #0
 802c212:	eea6 3aa7 	vfma.f32	s6, s13, s15
 802c216:	eef0 7a43 	vmov.f32	s15, s6
 802c21a:	e770      	b.n	802c0fe <expm1f+0x11e>
 802c21c:	eddf 7a10 	vldr	s15, [pc, #64]	; 802c260 <expm1f+0x280>
 802c220:	ee67 7aa7 	vmul.f32	s15, s15, s15
 802c224:	e76b      	b.n	802c0fe <expm1f+0x11e>
 802c226:	eeff 7a00 	vmov.f32	s15, #240	; 0xf0
 802c22a:	e768      	b.n	802c0fe <expm1f+0x11e>
 802c22c:	4195b843 	.word	0x4195b843
 802c230:	42b17217 	.word	0x42b17217
 802c234:	3fb8aa3b 	.word	0x3fb8aa3b
 802c238:	3eb17218 	.word	0x3eb17218
 802c23c:	b457edbb 	.word	0xb457edbb
 802c240:	36867e54 	.word	0x36867e54
 802c244:	b8a670cd 	.word	0xb8a670cd
 802c248:	3ad00d01 	.word	0x3ad00d01
 802c24c:	bd088889 	.word	0xbd088889
 802c250:	3f851591 	.word	0x3f851591
 802c254:	3f317180 	.word	0x3f317180
 802c258:	3717f7d1 	.word	0x3717f7d1
 802c25c:	0da24260 	.word	0x0da24260
 802c260:	7149f2ca 	.word	0x7149f2ca
 802c264:	b717f7d1 	.word	0xb717f7d1

0802c268 <fabsf>:
 802c268:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
 802c26c:	4770      	bx	lr
 802c26e:	bf00      	nop

0802c270 <finitef>:
 802c270:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
 802c274:	f1b0 4fff 	cmp.w	r0, #2139095040	; 0x7f800000
 802c278:	bfac      	ite	ge
 802c27a:	2000      	movge	r0, #0
 802c27c:	2001      	movlt	r0, #1
 802c27e:	4770      	bx	lr

0802c280 <__fpclassifyf>:
 802c280:	f030 4000 	bics.w	r0, r0, #2147483648	; 0x80000000
 802c284:	d101      	bne.n	802c28a <__fpclassifyf+0xa>
 802c286:	2002      	movs	r0, #2
 802c288:	4770      	bx	lr
 802c28a:	f5a0 0300 	sub.w	r3, r0, #8388608	; 0x800000
 802c28e:	f1b3 4ffe 	cmp.w	r3, #2130706432	; 0x7f000000
 802c292:	d201      	bcs.n	802c298 <__fpclassifyf+0x18>
 802c294:	2004      	movs	r0, #4
 802c296:	4770      	bx	lr
 802c298:	4b05      	ldr	r3, [pc, #20]	; (802c2b0 <__fpclassifyf+0x30>)
 802c29a:	1e42      	subs	r2, r0, #1
 802c29c:	429a      	cmp	r2, r3
 802c29e:	d801      	bhi.n	802c2a4 <__fpclassifyf+0x24>
 802c2a0:	2003      	movs	r0, #3
 802c2a2:	4770      	bx	lr
 802c2a4:	f1a0 40ff 	sub.w	r0, r0, #2139095040	; 0x7f800000
 802c2a8:	fab0 f080 	clz	r0, r0
 802c2ac:	0940      	lsrs	r0, r0, #5
 802c2ae:	4770      	bx	lr
 802c2b0:	007ffffe 	.word	0x007ffffe

0802c2b4 <log1pf>:
 802c2b4:	f1b0 4fff 	cmp.w	r0, #2139095040	; 0x7f800000
 802c2b8:	ee07 0a90 	vmov	s15, r0
 802c2bc:	4603      	mov	r3, r0
 802c2be:	da46      	bge.n	802c34e <log1pf+0x9a>
 802c2c0:	4a7d      	ldr	r2, [pc, #500]	; (802c4b8 <log1pf+0x204>)
 802c2c2:	4290      	cmp	r0, r2
 802c2c4:	dc1a      	bgt.n	802c2fc <log1pf+0x48>
 802c2c6:	f020 4200 	bic.w	r2, r0, #2147483648	; 0x80000000
 802c2ca:	f1b2 5f7e 	cmp.w	r2, #1065353216	; 0x3f800000
 802c2ce:	da43      	bge.n	802c358 <log1pf+0xa4>
 802c2d0:	f1b2 5f44 	cmp.w	r2, #822083584	; 0x31000000
 802c2d4:	da4e      	bge.n	802c374 <log1pf+0xc0>
 802c2d6:	ed9f 7a79 	vldr	s14, [pc, #484]	; 802c4bc <log1pf+0x208>
 802c2da:	ee37 7a87 	vadd.f32	s14, s15, s14
 802c2de:	eeb5 7ac0 	vcmpe.f32	s14, #0.0
 802c2e2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802c2e6:	dd02      	ble.n	802c2ee <log1pf+0x3a>
 802c2e8:	f1b2 5f12 	cmp.w	r2, #612368384	; 0x24800000
 802c2ec:	db31      	blt.n	802c352 <log1pf+0x9e>
 802c2ee:	ee67 6ae7 	vnmul.f32	s13, s15, s15
 802c2f2:	eeb6 7a00 	vmov.f32	s14, #96	; 0x60
 802c2f6:	eee6 7a87 	vfma.f32	s15, s13, s14
 802c2fa:	e02a      	b.n	802c352 <log1pf+0x9e>
 802c2fc:	f1b0 4fb4 	cmp.w	r0, #1509949440	; 0x5a000000
 802c300:	db3d      	blt.n	802c37e <log1pf+0xca>
 802c302:	15da      	asrs	r2, r3, #23
 802c304:	eddf 4a6e 	vldr	s9, [pc, #440]	; 802c4c0 <log1pf+0x20c>
 802c308:	3a7f      	subs	r2, #127	; 0x7f
 802c30a:	496e      	ldr	r1, [pc, #440]	; (802c4c4 <log1pf+0x210>)
 802c30c:	f3c3 0316 	ubfx	r3, r3, #0, #23
 802c310:	428b      	cmp	r3, r1
 802c312:	f300 8090 	bgt.w	802c436 <log1pf+0x182>
 802c316:	f043 517e 	orr.w	r1, r3, #1065353216	; 0x3f800000
 802c31a:	ee07 1a90 	vmov	s15, r1
 802c31e:	eef7 6a00 	vmov.f32	s13, #112	; 0x70
 802c322:	ee37 6ae6 	vsub.f32	s12, s15, s13
 802c326:	eeb6 7a00 	vmov.f32	s14, #96	; 0x60
 802c32a:	ee26 7a07 	vmul.f32	s14, s12, s14
 802c32e:	ee26 7a07 	vmul.f32	s14, s12, s14
 802c332:	2b00      	cmp	r3, #0
 802c334:	d141      	bne.n	802c3ba <log1pf+0x106>
 802c336:	eeb5 6a40 	vcmp.f32	s12, #0.0
 802c33a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802c33e:	f040 8083 	bne.w	802c448 <log1pf+0x194>
 802c342:	2a00      	cmp	r2, #0
 802c344:	f040 80a9 	bne.w	802c49a <log1pf+0x1e6>
 802c348:	eddf 7a5d 	vldr	s15, [pc, #372]	; 802c4c0 <log1pf+0x20c>
 802c34c:	e001      	b.n	802c352 <log1pf+0x9e>
 802c34e:	ee77 7aa7 	vadd.f32	s15, s15, s15
 802c352:	ee17 0a90 	vmov	r0, s15
 802c356:	4770      	bx	lr
 802c358:	eebf 7a00 	vmov.f32	s14, #240	; 0xf0
 802c35c:	eef4 7a47 	vcmp.f32	s15, s14
 802c360:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802c364:	d17a      	bne.n	802c45c <log1pf+0x1a8>
 802c366:	eddf 7a58 	vldr	s15, [pc, #352]	; 802c4c8 <log1pf+0x214>
 802c36a:	ed9f 7a55 	vldr	s14, [pc, #340]	; 802c4c0 <log1pf+0x20c>
 802c36e:	eec7 7a87 	vdiv.f32	s15, s15, s14
 802c372:	e7ee      	b.n	802c352 <log1pf+0x9e>
 802c374:	4a55      	ldr	r2, [pc, #340]	; (802c4cc <log1pf+0x218>)
 802c376:	4611      	mov	r1, r2
 802c378:	4402      	add	r2, r0
 802c37a:	428a      	cmp	r2, r1
 802c37c:	d814      	bhi.n	802c3a8 <log1pf+0xf4>
 802c37e:	eef7 6a00 	vmov.f32	s13, #112	; 0x70
 802c382:	ee77 4aa6 	vadd.f32	s9, s15, s13
 802c386:	ee14 3a90 	vmov	r3, s9
 802c38a:	15da      	asrs	r2, r3, #23
 802c38c:	3a7f      	subs	r2, #127	; 0x7f
 802c38e:	2a00      	cmp	r2, #0
 802c390:	bfcb      	itete	gt
 802c392:	ee74 7ae7 	vsubgt.f32	s15, s9, s15
 802c396:	ee74 6ae6 	vsuble.f32	s13, s9, s13
 802c39a:	ee76 7ae7 	vsubgt.f32	s15, s13, s15
 802c39e:	ee77 7ae6 	vsuble.f32	s15, s15, s13
 802c3a2:	eec7 4aa4 	vdiv.f32	s9, s15, s9
 802c3a6:	e7b0      	b.n	802c30a <log1pf+0x56>
 802c3a8:	eeb6 7a00 	vmov.f32	s14, #96	; 0x60
 802c3ac:	ee27 7a87 	vmul.f32	s14, s15, s14
 802c3b0:	ee06 0a10 	vmov	s12, r0
 802c3b4:	ee27 7a87 	vmul.f32	s14, s15, s14
 802c3b8:	2200      	movs	r2, #0
 802c3ba:	eef0 5a00 	vmov.f32	s11, #0
 802c3be:	ee76 5a25 	vadd.f32	s11, s12, s11
 802c3c2:	ed9f 2a43 	vldr	s4, [pc, #268]	; 802c4d0 <log1pf+0x21c>
 802c3c6:	eddf 2a43 	vldr	s5, [pc, #268]	; 802c4d4 <log1pf+0x220>
 802c3ca:	ed9f 3a43 	vldr	s6, [pc, #268]	; 802c4d8 <log1pf+0x224>
 802c3ce:	eddf 3a43 	vldr	s7, [pc, #268]	; 802c4dc <log1pf+0x228>
 802c3d2:	ed9f 4a43 	vldr	s8, [pc, #268]	; 802c4e0 <log1pf+0x22c>
 802c3d6:	eddf 7a43 	vldr	s15, [pc, #268]	; 802c4e4 <log1pf+0x230>
 802c3da:	ed9f 5a43 	vldr	s10, [pc, #268]	; 802c4e8 <log1pf+0x234>
 802c3de:	eec6 5a25 	vdiv.f32	s11, s12, s11
 802c3e2:	ee65 6aa5 	vmul.f32	s13, s11, s11
 802c3e6:	eee6 2a82 	vfma.f32	s5, s13, s4
 802c3ea:	eea2 3aa6 	vfma.f32	s6, s5, s13
 802c3ee:	eee3 3a26 	vfma.f32	s7, s6, s13
 802c3f2:	eea3 4aa6 	vfma.f32	s8, s7, s13
 802c3f6:	eee4 7a26 	vfma.f32	s15, s8, s13
 802c3fa:	eea7 5aa6 	vfma.f32	s10, s15, s13
 802c3fe:	ee25 5a26 	vmul.f32	s10, s10, s13
 802c402:	b382      	cbz	r2, 802c466 <log1pf+0x1b2>
 802c404:	ee07 2a90 	vmov	s15, r2
 802c408:	eef8 6ae7 	vcvt.f32.s32	s13, s15
 802c40c:	eddf 7a37 	vldr	s15, [pc, #220]	; 802c4ec <log1pf+0x238>
 802c410:	ed9f 4a37 	vldr	s8, [pc, #220]	; 802c4f0 <log1pf+0x23c>
 802c414:	eee6 4aa7 	vfma.f32	s9, s13, s15
 802c418:	ee37 5a05 	vadd.f32	s10, s14, s10
 802c41c:	eef0 7a64 	vmov.f32	s15, s9
 802c420:	eee5 7a25 	vfma.f32	s15, s10, s11
 802c424:	ee37 7a67 	vsub.f32	s14, s14, s15
 802c428:	ee77 7a46 	vsub.f32	s15, s14, s12
 802c42c:	eed6 7a84 	vfnms.f32	s15, s13, s8
 802c430:	ee17 0a90 	vmov	r0, s15
 802c434:	4770      	bx	lr
 802c436:	f5c3 0100 	rsb	r1, r3, #8388608	; 0x800000
 802c43a:	f043 537c 	orr.w	r3, r3, #1056964608	; 0x3f000000
 802c43e:	ee07 3a90 	vmov	s15, r3
 802c442:	3201      	adds	r2, #1
 802c444:	108b      	asrs	r3, r1, #2
 802c446:	e76a      	b.n	802c31e <log1pf+0x6a>
 802c448:	eddf 7a27 	vldr	s15, [pc, #156]	; 802c4e8 <log1pf+0x234>
 802c44c:	eee6 6a67 	vfms.f32	s13, s12, s15
 802c450:	ee26 7a87 	vmul.f32	s14, s13, s14
 802c454:	b982      	cbnz	r2, 802c478 <log1pf+0x1c4>
 802c456:	ee76 7a47 	vsub.f32	s15, s12, s14
 802c45a:	e77a      	b.n	802c352 <log1pf+0x9e>
 802c45c:	ee77 7ae7 	vsub.f32	s15, s15, s15
 802c460:	eec7 7aa7 	vdiv.f32	s15, s15, s15
 802c464:	e775      	b.n	802c352 <log1pf+0x9e>
 802c466:	ee37 5a05 	vadd.f32	s10, s14, s10
 802c46a:	eef0 7a47 	vmov.f32	s15, s14
 802c46e:	eee5 7a65 	vfms.f32	s15, s10, s11
 802c472:	ee76 7a67 	vsub.f32	s15, s12, s15
 802c476:	e76c      	b.n	802c352 <log1pf+0x9e>
 802c478:	ee07 2a90 	vmov	s15, r2
 802c47c:	eef8 6ae7 	vcvt.f32.s32	s13, s15
 802c480:	eddf 7a1a 	vldr	s15, [pc, #104]	; 802c4ec <log1pf+0x238>
 802c484:	eddf 5a1a 	vldr	s11, [pc, #104]	; 802c4f0 <log1pf+0x23c>
 802c488:	eee6 4aa7 	vfma.f32	s9, s13, s15
 802c48c:	ee77 7a64 	vsub.f32	s15, s14, s9
 802c490:	ee77 7ac6 	vsub.f32	s15, s15, s12
 802c494:	eed6 7aa5 	vfnms.f32	s15, s13, s11
 802c498:	e75b      	b.n	802c352 <log1pf+0x9e>
 802c49a:	ee07 2a90 	vmov	s15, r2
 802c49e:	eef8 6ae7 	vcvt.f32.s32	s13, s15
 802c4a2:	eddf 7a12 	vldr	s15, [pc, #72]	; 802c4ec <log1pf+0x238>
 802c4a6:	ed9f 7a12 	vldr	s14, [pc, #72]	; 802c4f0 <log1pf+0x23c>
 802c4aa:	eee6 4aa7 	vfma.f32	s9, s13, s15
 802c4ae:	eef0 7a64 	vmov.f32	s15, s9
 802c4b2:	eee6 7a87 	vfma.f32	s15, s13, s14
 802c4b6:	e74c      	b.n	802c352 <log1pf+0x9e>
 802c4b8:	3ed413d6 	.word	0x3ed413d6
 802c4bc:	4c000000 	.word	0x4c000000
 802c4c0:	00000000 	.word	0x00000000
 802c4c4:	003504f6 	.word	0x003504f6
 802c4c8:	cc000000 	.word	0xcc000000
 802c4cc:	416a09e0 	.word	0x416a09e0
 802c4d0:	3e178897 	.word	0x3e178897
 802c4d4:	3e1cd04f 	.word	0x3e1cd04f
 802c4d8:	3e3a3325 	.word	0x3e3a3325
 802c4dc:	3e638e29 	.word	0x3e638e29
 802c4e0:	3e924925 	.word	0x3e924925
 802c4e4:	3ecccccd 	.word	0x3ecccccd
 802c4e8:	3f2aaaab 	.word	0x3f2aaaab
 802c4ec:	3717f7d1 	.word	0x3717f7d1
 802c4f0:	3f317180 	.word	0x3f317180

0802c4f4 <nanf>:
 802c4f4:	4800      	ldr	r0, [pc, #0]	; (802c4f8 <nanf+0x4>)
 802c4f6:	4770      	bx	lr
 802c4f8:	7fc00000 	.word	0x7fc00000

0802c4fc <scalbnf>:
 802c4fc:	b500      	push	{lr}
 802c4fe:	ed2d 8b02 	vpush	{d8}
 802c502:	b083      	sub	sp, #12
 802c504:	9001      	str	r0, [sp, #4]
 802c506:	9b01      	ldr	r3, [sp, #4]
 802c508:	f033 4200 	bics.w	r2, r3, #2147483648	; 0x80000000
 802c50c:	d023      	beq.n	802c556 <scalbnf+0x5a>
 802c50e:	f1b2 4fff 	cmp.w	r2, #2139095040	; 0x7f800000
 802c512:	d215      	bcs.n	802c540 <scalbnf+0x44>
 802c514:	f5b2 0f00 	cmp.w	r2, #8388608	; 0x800000
 802c518:	d326      	bcc.n	802c568 <scalbnf+0x6c>
 802c51a:	0dd2      	lsrs	r2, r2, #23
 802c51c:	440a      	add	r2, r1
 802c51e:	2afe      	cmp	r2, #254	; 0xfe
 802c520:	dc3c      	bgt.n	802c59c <scalbnf+0xa0>
 802c522:	2a00      	cmp	r2, #0
 802c524:	dd30      	ble.n	802c588 <scalbnf+0x8c>
 802c526:	f023 43ff 	bic.w	r3, r3, #2139095040	; 0x7f800000
 802c52a:	ea43 53c2 	orr.w	r3, r3, r2, lsl #23
 802c52e:	ee07 3a90 	vmov	s15, r3
 802c532:	ee17 0a90 	vmov	r0, s15
 802c536:	b003      	add	sp, #12
 802c538:	ecbd 8b02 	vpop	{d8}
 802c53c:	f85d fb04 	ldr.w	pc, [sp], #4
 802c540:	ee07 0a90 	vmov	s15, r0
 802c544:	ee77 7aa7 	vadd.f32	s15, s15, s15
 802c548:	ee17 0a90 	vmov	r0, s15
 802c54c:	b003      	add	sp, #12
 802c54e:	ecbd 8b02 	vpop	{d8}
 802c552:	f85d fb04 	ldr.w	pc, [sp], #4
 802c556:	eddd 7a01 	vldr	s15, [sp, #4]
 802c55a:	ee17 0a90 	vmov	r0, s15
 802c55e:	b003      	add	sp, #12
 802c560:	ecbd 8b02 	vpop	{d8}
 802c564:	f85d fb04 	ldr.w	pc, [sp], #4
 802c568:	ed9d 7a01 	vldr	s14, [sp, #4]
 802c56c:	eddf 7a1e 	vldr	s15, [pc, #120]	; 802c5e8 <scalbnf+0xec>
 802c570:	4b1e      	ldr	r3, [pc, #120]	; (802c5ec <scalbnf+0xf0>)
 802c572:	ee67 7a27 	vmul.f32	s15, s14, s15
 802c576:	4299      	cmp	r1, r3
 802c578:	edcd 7a01 	vstr	s15, [sp, #4]
 802c57c:	db20      	blt.n	802c5c0 <scalbnf+0xc4>
 802c57e:	9b01      	ldr	r3, [sp, #4]
 802c580:	f3c3 52c7 	ubfx	r2, r3, #23, #8
 802c584:	3a19      	subs	r2, #25
 802c586:	e7c9      	b.n	802c51c <scalbnf+0x20>
 802c588:	f112 0f16 	cmn.w	r2, #22
 802c58c:	da1f      	bge.n	802c5ce <scalbnf+0xd2>
 802c58e:	f24c 3350 	movw	r3, #50000	; 0xc350
 802c592:	4299      	cmp	r1, r3
 802c594:	dc02      	bgt.n	802c59c <scalbnf+0xa0>
 802c596:	ed9f 8a16 	vldr	s16, [pc, #88]	; 802c5f0 <scalbnf+0xf4>
 802c59a:	e001      	b.n	802c5a0 <scalbnf+0xa4>
 802c59c:	ed9f 8a15 	vldr	s16, [pc, #84]	; 802c5f4 <scalbnf+0xf8>
 802c5a0:	9901      	ldr	r1, [sp, #4]
 802c5a2:	ee18 0a10 	vmov	r0, s16
 802c5a6:	f000 f829 	bl	802c5fc <copysignf>
 802c5aa:	ee07 0a90 	vmov	s15, r0
 802c5ae:	ee67 7a88 	vmul.f32	s15, s15, s16
 802c5b2:	ee17 0a90 	vmov	r0, s15
 802c5b6:	b003      	add	sp, #12
 802c5b8:	ecbd 8b02 	vpop	{d8}
 802c5bc:	f85d fb04 	ldr.w	pc, [sp], #4
 802c5c0:	eddf 7a0b 	vldr	s15, [pc, #44]	; 802c5f0 <scalbnf+0xf4>
 802c5c4:	ed9d 7a01 	vldr	s14, [sp, #4]
 802c5c8:	ee67 7a27 	vmul.f32	s15, s14, s15
 802c5cc:	e7bc      	b.n	802c548 <scalbnf+0x4c>
 802c5ce:	3219      	adds	r2, #25
 802c5d0:	f023 43ff 	bic.w	r3, r3, #2139095040	; 0x7f800000
 802c5d4:	ea43 53c2 	orr.w	r3, r3, r2, lsl #23
 802c5d8:	ed9f 7a07 	vldr	s14, [pc, #28]	; 802c5f8 <scalbnf+0xfc>
 802c5dc:	ee07 3a90 	vmov	s15, r3
 802c5e0:	ee67 7a87 	vmul.f32	s15, s15, s14
 802c5e4:	e7b0      	b.n	802c548 <scalbnf+0x4c>
 802c5e6:	bf00      	nop
 802c5e8:	4c000000 	.word	0x4c000000
 802c5ec:	ffff3cb0 	.word	0xffff3cb0
 802c5f0:	0da24260 	.word	0x0da24260
 802c5f4:	7149f2ca 	.word	0x7149f2ca
 802c5f8:	33000000 	.word	0x33000000

0802c5fc <copysignf>:
 802c5fc:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 802c600:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
 802c604:	4308      	orrs	r0, r1
 802c606:	4770      	bx	lr

0802c608 <__aeabi_drsub>:
 802c608:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 802c60c:	e002      	b.n	802c614 <__adddf3>
 802c60e:	bf00      	nop

0802c610 <__aeabi_dsub>:
 802c610:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

0802c614 <__adddf3>:
 802c614:	b530      	push	{r4, r5, lr}
 802c616:	ea4f 0441 	mov.w	r4, r1, lsl #1
 802c61a:	ea4f 0543 	mov.w	r5, r3, lsl #1
 802c61e:	ea94 0f05 	teq	r4, r5
 802c622:	bf08      	it	eq
 802c624:	ea90 0f02 	teqeq	r0, r2
 802c628:	bf1f      	itttt	ne
 802c62a:	ea54 0c00 	orrsne.w	ip, r4, r0
 802c62e:	ea55 0c02 	orrsne.w	ip, r5, r2
 802c632:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 802c636:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 802c63a:	f000 80e2 	beq.w	802c802 <__adddf3+0x1ee>
 802c63e:	ea4f 5454 	mov.w	r4, r4, lsr #21
 802c642:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 802c646:	bfb8      	it	lt
 802c648:	426d      	neglt	r5, r5
 802c64a:	dd0c      	ble.n	802c666 <__adddf3+0x52>
 802c64c:	442c      	add	r4, r5
 802c64e:	ea80 0202 	eor.w	r2, r0, r2
 802c652:	ea81 0303 	eor.w	r3, r1, r3
 802c656:	ea82 0000 	eor.w	r0, r2, r0
 802c65a:	ea83 0101 	eor.w	r1, r3, r1
 802c65e:	ea80 0202 	eor.w	r2, r0, r2
 802c662:	ea81 0303 	eor.w	r3, r1, r3
 802c666:	2d36      	cmp	r5, #54	; 0x36
 802c668:	bf88      	it	hi
 802c66a:	bd30      	pophi	{r4, r5, pc}
 802c66c:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 802c670:	ea4f 3101 	mov.w	r1, r1, lsl #12
 802c674:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 802c678:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 802c67c:	d002      	beq.n	802c684 <__adddf3+0x70>
 802c67e:	4240      	negs	r0, r0
 802c680:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 802c684:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 802c688:	ea4f 3303 	mov.w	r3, r3, lsl #12
 802c68c:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 802c690:	d002      	beq.n	802c698 <__adddf3+0x84>
 802c692:	4252      	negs	r2, r2
 802c694:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 802c698:	ea94 0f05 	teq	r4, r5
 802c69c:	f000 80a7 	beq.w	802c7ee <__adddf3+0x1da>
 802c6a0:	f1a4 0401 	sub.w	r4, r4, #1
 802c6a4:	f1d5 0e20 	rsbs	lr, r5, #32
 802c6a8:	db0d      	blt.n	802c6c6 <__adddf3+0xb2>
 802c6aa:	fa02 fc0e 	lsl.w	ip, r2, lr
 802c6ae:	fa22 f205 	lsr.w	r2, r2, r5
 802c6b2:	1880      	adds	r0, r0, r2
 802c6b4:	f141 0100 	adc.w	r1, r1, #0
 802c6b8:	fa03 f20e 	lsl.w	r2, r3, lr
 802c6bc:	1880      	adds	r0, r0, r2
 802c6be:	fa43 f305 	asr.w	r3, r3, r5
 802c6c2:	4159      	adcs	r1, r3
 802c6c4:	e00e      	b.n	802c6e4 <__adddf3+0xd0>
 802c6c6:	f1a5 0520 	sub.w	r5, r5, #32
 802c6ca:	f10e 0e20 	add.w	lr, lr, #32
 802c6ce:	2a01      	cmp	r2, #1
 802c6d0:	fa03 fc0e 	lsl.w	ip, r3, lr
 802c6d4:	bf28      	it	cs
 802c6d6:	f04c 0c02 	orrcs.w	ip, ip, #2
 802c6da:	fa43 f305 	asr.w	r3, r3, r5
 802c6de:	18c0      	adds	r0, r0, r3
 802c6e0:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 802c6e4:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 802c6e8:	d507      	bpl.n	802c6fa <__adddf3+0xe6>
 802c6ea:	f04f 0e00 	mov.w	lr, #0
 802c6ee:	f1dc 0c00 	rsbs	ip, ip, #0
 802c6f2:	eb7e 0000 	sbcs.w	r0, lr, r0
 802c6f6:	eb6e 0101 	sbc.w	r1, lr, r1
 802c6fa:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 802c6fe:	d31b      	bcc.n	802c738 <__adddf3+0x124>
 802c700:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 802c704:	d30c      	bcc.n	802c720 <__adddf3+0x10c>
 802c706:	0849      	lsrs	r1, r1, #1
 802c708:	ea5f 0030 	movs.w	r0, r0, rrx
 802c70c:	ea4f 0c3c 	mov.w	ip, ip, rrx
 802c710:	f104 0401 	add.w	r4, r4, #1
 802c714:	ea4f 5244 	mov.w	r2, r4, lsl #21
 802c718:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 802c71c:	f080 809a 	bcs.w	802c854 <__adddf3+0x240>
 802c720:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 802c724:	bf08      	it	eq
 802c726:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 802c72a:	f150 0000 	adcs.w	r0, r0, #0
 802c72e:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 802c732:	ea41 0105 	orr.w	r1, r1, r5
 802c736:	bd30      	pop	{r4, r5, pc}
 802c738:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 802c73c:	4140      	adcs	r0, r0
 802c73e:	eb41 0101 	adc.w	r1, r1, r1
 802c742:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 802c746:	f1a4 0401 	sub.w	r4, r4, #1
 802c74a:	d1e9      	bne.n	802c720 <__adddf3+0x10c>
 802c74c:	f091 0f00 	teq	r1, #0
 802c750:	bf04      	itt	eq
 802c752:	4601      	moveq	r1, r0
 802c754:	2000      	moveq	r0, #0
 802c756:	fab1 f381 	clz	r3, r1
 802c75a:	bf08      	it	eq
 802c75c:	3320      	addeq	r3, #32
 802c75e:	f1a3 030b 	sub.w	r3, r3, #11
 802c762:	f1b3 0220 	subs.w	r2, r3, #32
 802c766:	da0c      	bge.n	802c782 <__adddf3+0x16e>
 802c768:	320c      	adds	r2, #12
 802c76a:	dd08      	ble.n	802c77e <__adddf3+0x16a>
 802c76c:	f102 0c14 	add.w	ip, r2, #20
 802c770:	f1c2 020c 	rsb	r2, r2, #12
 802c774:	fa01 f00c 	lsl.w	r0, r1, ip
 802c778:	fa21 f102 	lsr.w	r1, r1, r2
 802c77c:	e00c      	b.n	802c798 <__adddf3+0x184>
 802c77e:	f102 0214 	add.w	r2, r2, #20
 802c782:	bfd8      	it	le
 802c784:	f1c2 0c20 	rsble	ip, r2, #32
 802c788:	fa01 f102 	lsl.w	r1, r1, r2
 802c78c:	fa20 fc0c 	lsr.w	ip, r0, ip
 802c790:	bfdc      	itt	le
 802c792:	ea41 010c 	orrle.w	r1, r1, ip
 802c796:	4090      	lslle	r0, r2
 802c798:	1ae4      	subs	r4, r4, r3
 802c79a:	bfa2      	ittt	ge
 802c79c:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 802c7a0:	4329      	orrge	r1, r5
 802c7a2:	bd30      	popge	{r4, r5, pc}
 802c7a4:	ea6f 0404 	mvn.w	r4, r4
 802c7a8:	3c1f      	subs	r4, #31
 802c7aa:	da1c      	bge.n	802c7e6 <__adddf3+0x1d2>
 802c7ac:	340c      	adds	r4, #12
 802c7ae:	dc0e      	bgt.n	802c7ce <__adddf3+0x1ba>
 802c7b0:	f104 0414 	add.w	r4, r4, #20
 802c7b4:	f1c4 0220 	rsb	r2, r4, #32
 802c7b8:	fa20 f004 	lsr.w	r0, r0, r4
 802c7bc:	fa01 f302 	lsl.w	r3, r1, r2
 802c7c0:	ea40 0003 	orr.w	r0, r0, r3
 802c7c4:	fa21 f304 	lsr.w	r3, r1, r4
 802c7c8:	ea45 0103 	orr.w	r1, r5, r3
 802c7cc:	bd30      	pop	{r4, r5, pc}
 802c7ce:	f1c4 040c 	rsb	r4, r4, #12
 802c7d2:	f1c4 0220 	rsb	r2, r4, #32
 802c7d6:	fa20 f002 	lsr.w	r0, r0, r2
 802c7da:	fa01 f304 	lsl.w	r3, r1, r4
 802c7de:	ea40 0003 	orr.w	r0, r0, r3
 802c7e2:	4629      	mov	r1, r5
 802c7e4:	bd30      	pop	{r4, r5, pc}
 802c7e6:	fa21 f004 	lsr.w	r0, r1, r4
 802c7ea:	4629      	mov	r1, r5
 802c7ec:	bd30      	pop	{r4, r5, pc}
 802c7ee:	f094 0f00 	teq	r4, #0
 802c7f2:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 802c7f6:	bf06      	itte	eq
 802c7f8:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 802c7fc:	3401      	addeq	r4, #1
 802c7fe:	3d01      	subne	r5, #1
 802c800:	e74e      	b.n	802c6a0 <__adddf3+0x8c>
 802c802:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 802c806:	bf18      	it	ne
 802c808:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 802c80c:	d029      	beq.n	802c862 <__adddf3+0x24e>
 802c80e:	ea94 0f05 	teq	r4, r5
 802c812:	bf08      	it	eq
 802c814:	ea90 0f02 	teqeq	r0, r2
 802c818:	d005      	beq.n	802c826 <__adddf3+0x212>
 802c81a:	ea54 0c00 	orrs.w	ip, r4, r0
 802c81e:	bf04      	itt	eq
 802c820:	4619      	moveq	r1, r3
 802c822:	4610      	moveq	r0, r2
 802c824:	bd30      	pop	{r4, r5, pc}
 802c826:	ea91 0f03 	teq	r1, r3
 802c82a:	bf1e      	ittt	ne
 802c82c:	2100      	movne	r1, #0
 802c82e:	2000      	movne	r0, #0
 802c830:	bd30      	popne	{r4, r5, pc}
 802c832:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 802c836:	d105      	bne.n	802c844 <__adddf3+0x230>
 802c838:	0040      	lsls	r0, r0, #1
 802c83a:	4149      	adcs	r1, r1
 802c83c:	bf28      	it	cs
 802c83e:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 802c842:	bd30      	pop	{r4, r5, pc}
 802c844:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 802c848:	bf3c      	itt	cc
 802c84a:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 802c84e:	bd30      	popcc	{r4, r5, pc}
 802c850:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 802c854:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 802c858:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 802c85c:	f04f 0000 	mov.w	r0, #0
 802c860:	bd30      	pop	{r4, r5, pc}
 802c862:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 802c866:	bf1a      	itte	ne
 802c868:	4619      	movne	r1, r3
 802c86a:	4610      	movne	r0, r2
 802c86c:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 802c870:	bf1c      	itt	ne
 802c872:	460b      	movne	r3, r1
 802c874:	4602      	movne	r2, r0
 802c876:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 802c87a:	bf06      	itte	eq
 802c87c:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 802c880:	ea91 0f03 	teqeq	r1, r3
 802c884:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 802c888:	bd30      	pop	{r4, r5, pc}
 802c88a:	bf00      	nop

0802c88c <__aeabi_ui2d>:
 802c88c:	f090 0f00 	teq	r0, #0
 802c890:	bf04      	itt	eq
 802c892:	2100      	moveq	r1, #0
 802c894:	4770      	bxeq	lr
 802c896:	b530      	push	{r4, r5, lr}
 802c898:	f44f 6480 	mov.w	r4, #1024	; 0x400
 802c89c:	f104 0432 	add.w	r4, r4, #50	; 0x32
 802c8a0:	f04f 0500 	mov.w	r5, #0
 802c8a4:	f04f 0100 	mov.w	r1, #0
 802c8a8:	e750      	b.n	802c74c <__adddf3+0x138>
 802c8aa:	bf00      	nop

0802c8ac <__aeabi_i2d>:
 802c8ac:	f090 0f00 	teq	r0, #0
 802c8b0:	bf04      	itt	eq
 802c8b2:	2100      	moveq	r1, #0
 802c8b4:	4770      	bxeq	lr
 802c8b6:	b530      	push	{r4, r5, lr}
 802c8b8:	f44f 6480 	mov.w	r4, #1024	; 0x400
 802c8bc:	f104 0432 	add.w	r4, r4, #50	; 0x32
 802c8c0:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 802c8c4:	bf48      	it	mi
 802c8c6:	4240      	negmi	r0, r0
 802c8c8:	f04f 0100 	mov.w	r1, #0
 802c8cc:	e73e      	b.n	802c74c <__adddf3+0x138>
 802c8ce:	bf00      	nop

0802c8d0 <__aeabi_f2d>:
 802c8d0:	0042      	lsls	r2, r0, #1
 802c8d2:	ea4f 01e2 	mov.w	r1, r2, asr #3
 802c8d6:	ea4f 0131 	mov.w	r1, r1, rrx
 802c8da:	ea4f 7002 	mov.w	r0, r2, lsl #28
 802c8de:	bf1f      	itttt	ne
 802c8e0:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 802c8e4:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 802c8e8:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 802c8ec:	4770      	bxne	lr
 802c8ee:	f092 0f00 	teq	r2, #0
 802c8f2:	bf14      	ite	ne
 802c8f4:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 802c8f8:	4770      	bxeq	lr
 802c8fa:	b530      	push	{r4, r5, lr}
 802c8fc:	f44f 7460 	mov.w	r4, #896	; 0x380
 802c900:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 802c904:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 802c908:	e720      	b.n	802c74c <__adddf3+0x138>
 802c90a:	bf00      	nop

0802c90c <__aeabi_ul2d>:
 802c90c:	ea50 0201 	orrs.w	r2, r0, r1
 802c910:	bf08      	it	eq
 802c912:	4770      	bxeq	lr
 802c914:	b530      	push	{r4, r5, lr}
 802c916:	f04f 0500 	mov.w	r5, #0
 802c91a:	e00a      	b.n	802c932 <__aeabi_l2d+0x16>

0802c91c <__aeabi_l2d>:
 802c91c:	ea50 0201 	orrs.w	r2, r0, r1
 802c920:	bf08      	it	eq
 802c922:	4770      	bxeq	lr
 802c924:	b530      	push	{r4, r5, lr}
 802c926:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 802c92a:	d502      	bpl.n	802c932 <__aeabi_l2d+0x16>
 802c92c:	4240      	negs	r0, r0
 802c92e:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 802c932:	f44f 6480 	mov.w	r4, #1024	; 0x400
 802c936:	f104 0432 	add.w	r4, r4, #50	; 0x32
 802c93a:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 802c93e:	f43f aedc 	beq.w	802c6fa <__adddf3+0xe6>
 802c942:	f04f 0203 	mov.w	r2, #3
 802c946:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 802c94a:	bf18      	it	ne
 802c94c:	3203      	addne	r2, #3
 802c94e:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 802c952:	bf18      	it	ne
 802c954:	3203      	addne	r2, #3
 802c956:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 802c95a:	f1c2 0320 	rsb	r3, r2, #32
 802c95e:	fa00 fc03 	lsl.w	ip, r0, r3
 802c962:	fa20 f002 	lsr.w	r0, r0, r2
 802c966:	fa01 fe03 	lsl.w	lr, r1, r3
 802c96a:	ea40 000e 	orr.w	r0, r0, lr
 802c96e:	fa21 f102 	lsr.w	r1, r1, r2
 802c972:	4414      	add	r4, r2
 802c974:	e6c1      	b.n	802c6fa <__adddf3+0xe6>
 802c976:	bf00      	nop

0802c978 <__aeabi_dmul>:
 802c978:	b570      	push	{r4, r5, r6, lr}
 802c97a:	f04f 0cff 	mov.w	ip, #255	; 0xff
 802c97e:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 802c982:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 802c986:	bf1d      	ittte	ne
 802c988:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 802c98c:	ea94 0f0c 	teqne	r4, ip
 802c990:	ea95 0f0c 	teqne	r5, ip
 802c994:	f000 f8de 	bleq	802cb54 <__aeabi_dmul+0x1dc>
 802c998:	442c      	add	r4, r5
 802c99a:	ea81 0603 	eor.w	r6, r1, r3
 802c99e:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 802c9a2:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 802c9a6:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 802c9aa:	bf18      	it	ne
 802c9ac:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 802c9b0:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 802c9b4:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 802c9b8:	d038      	beq.n	802ca2c <__aeabi_dmul+0xb4>
 802c9ba:	fba0 ce02 	umull	ip, lr, r0, r2
 802c9be:	f04f 0500 	mov.w	r5, #0
 802c9c2:	fbe1 e502 	umlal	lr, r5, r1, r2
 802c9c6:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 802c9ca:	fbe0 e503 	umlal	lr, r5, r0, r3
 802c9ce:	f04f 0600 	mov.w	r6, #0
 802c9d2:	fbe1 5603 	umlal	r5, r6, r1, r3
 802c9d6:	f09c 0f00 	teq	ip, #0
 802c9da:	bf18      	it	ne
 802c9dc:	f04e 0e01 	orrne.w	lr, lr, #1
 802c9e0:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 802c9e4:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 802c9e8:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 802c9ec:	d204      	bcs.n	802c9f8 <__aeabi_dmul+0x80>
 802c9ee:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 802c9f2:	416d      	adcs	r5, r5
 802c9f4:	eb46 0606 	adc.w	r6, r6, r6
 802c9f8:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 802c9fc:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 802ca00:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 802ca04:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 802ca08:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 802ca0c:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 802ca10:	bf88      	it	hi
 802ca12:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 802ca16:	d81e      	bhi.n	802ca56 <__aeabi_dmul+0xde>
 802ca18:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 802ca1c:	bf08      	it	eq
 802ca1e:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 802ca22:	f150 0000 	adcs.w	r0, r0, #0
 802ca26:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 802ca2a:	bd70      	pop	{r4, r5, r6, pc}
 802ca2c:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 802ca30:	ea46 0101 	orr.w	r1, r6, r1
 802ca34:	ea40 0002 	orr.w	r0, r0, r2
 802ca38:	ea81 0103 	eor.w	r1, r1, r3
 802ca3c:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 802ca40:	bfc2      	ittt	gt
 802ca42:	ebd4 050c 	rsbsgt	r5, r4, ip
 802ca46:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 802ca4a:	bd70      	popgt	{r4, r5, r6, pc}
 802ca4c:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 802ca50:	f04f 0e00 	mov.w	lr, #0
 802ca54:	3c01      	subs	r4, #1
 802ca56:	f300 80ab 	bgt.w	802cbb0 <__aeabi_dmul+0x238>
 802ca5a:	f114 0f36 	cmn.w	r4, #54	; 0x36
 802ca5e:	bfde      	ittt	le
 802ca60:	2000      	movle	r0, #0
 802ca62:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 802ca66:	bd70      	pople	{r4, r5, r6, pc}
 802ca68:	f1c4 0400 	rsb	r4, r4, #0
 802ca6c:	3c20      	subs	r4, #32
 802ca6e:	da35      	bge.n	802cadc <__aeabi_dmul+0x164>
 802ca70:	340c      	adds	r4, #12
 802ca72:	dc1b      	bgt.n	802caac <__aeabi_dmul+0x134>
 802ca74:	f104 0414 	add.w	r4, r4, #20
 802ca78:	f1c4 0520 	rsb	r5, r4, #32
 802ca7c:	fa00 f305 	lsl.w	r3, r0, r5
 802ca80:	fa20 f004 	lsr.w	r0, r0, r4
 802ca84:	fa01 f205 	lsl.w	r2, r1, r5
 802ca88:	ea40 0002 	orr.w	r0, r0, r2
 802ca8c:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 802ca90:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 802ca94:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 802ca98:	fa21 f604 	lsr.w	r6, r1, r4
 802ca9c:	eb42 0106 	adc.w	r1, r2, r6
 802caa0:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 802caa4:	bf08      	it	eq
 802caa6:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 802caaa:	bd70      	pop	{r4, r5, r6, pc}
 802caac:	f1c4 040c 	rsb	r4, r4, #12
 802cab0:	f1c4 0520 	rsb	r5, r4, #32
 802cab4:	fa00 f304 	lsl.w	r3, r0, r4
 802cab8:	fa20 f005 	lsr.w	r0, r0, r5
 802cabc:	fa01 f204 	lsl.w	r2, r1, r4
 802cac0:	ea40 0002 	orr.w	r0, r0, r2
 802cac4:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 802cac8:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 802cacc:	f141 0100 	adc.w	r1, r1, #0
 802cad0:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 802cad4:	bf08      	it	eq
 802cad6:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 802cada:	bd70      	pop	{r4, r5, r6, pc}
 802cadc:	f1c4 0520 	rsb	r5, r4, #32
 802cae0:	fa00 f205 	lsl.w	r2, r0, r5
 802cae4:	ea4e 0e02 	orr.w	lr, lr, r2
 802cae8:	fa20 f304 	lsr.w	r3, r0, r4
 802caec:	fa01 f205 	lsl.w	r2, r1, r5
 802caf0:	ea43 0302 	orr.w	r3, r3, r2
 802caf4:	fa21 f004 	lsr.w	r0, r1, r4
 802caf8:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 802cafc:	fa21 f204 	lsr.w	r2, r1, r4
 802cb00:	ea20 0002 	bic.w	r0, r0, r2
 802cb04:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 802cb08:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 802cb0c:	bf08      	it	eq
 802cb0e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 802cb12:	bd70      	pop	{r4, r5, r6, pc}
 802cb14:	f094 0f00 	teq	r4, #0
 802cb18:	d10f      	bne.n	802cb3a <__aeabi_dmul+0x1c2>
 802cb1a:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 802cb1e:	0040      	lsls	r0, r0, #1
 802cb20:	eb41 0101 	adc.w	r1, r1, r1
 802cb24:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 802cb28:	bf08      	it	eq
 802cb2a:	3c01      	subeq	r4, #1
 802cb2c:	d0f7      	beq.n	802cb1e <__aeabi_dmul+0x1a6>
 802cb2e:	ea41 0106 	orr.w	r1, r1, r6
 802cb32:	f095 0f00 	teq	r5, #0
 802cb36:	bf18      	it	ne
 802cb38:	4770      	bxne	lr
 802cb3a:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 802cb3e:	0052      	lsls	r2, r2, #1
 802cb40:	eb43 0303 	adc.w	r3, r3, r3
 802cb44:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 802cb48:	bf08      	it	eq
 802cb4a:	3d01      	subeq	r5, #1
 802cb4c:	d0f7      	beq.n	802cb3e <__aeabi_dmul+0x1c6>
 802cb4e:	ea43 0306 	orr.w	r3, r3, r6
 802cb52:	4770      	bx	lr
 802cb54:	ea94 0f0c 	teq	r4, ip
 802cb58:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 802cb5c:	bf18      	it	ne
 802cb5e:	ea95 0f0c 	teqne	r5, ip
 802cb62:	d00c      	beq.n	802cb7e <__aeabi_dmul+0x206>
 802cb64:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 802cb68:	bf18      	it	ne
 802cb6a:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 802cb6e:	d1d1      	bne.n	802cb14 <__aeabi_dmul+0x19c>
 802cb70:	ea81 0103 	eor.w	r1, r1, r3
 802cb74:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 802cb78:	f04f 0000 	mov.w	r0, #0
 802cb7c:	bd70      	pop	{r4, r5, r6, pc}
 802cb7e:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 802cb82:	bf06      	itte	eq
 802cb84:	4610      	moveq	r0, r2
 802cb86:	4619      	moveq	r1, r3
 802cb88:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 802cb8c:	d019      	beq.n	802cbc2 <__aeabi_dmul+0x24a>
 802cb8e:	ea94 0f0c 	teq	r4, ip
 802cb92:	d102      	bne.n	802cb9a <__aeabi_dmul+0x222>
 802cb94:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 802cb98:	d113      	bne.n	802cbc2 <__aeabi_dmul+0x24a>
 802cb9a:	ea95 0f0c 	teq	r5, ip
 802cb9e:	d105      	bne.n	802cbac <__aeabi_dmul+0x234>
 802cba0:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 802cba4:	bf1c      	itt	ne
 802cba6:	4610      	movne	r0, r2
 802cba8:	4619      	movne	r1, r3
 802cbaa:	d10a      	bne.n	802cbc2 <__aeabi_dmul+0x24a>
 802cbac:	ea81 0103 	eor.w	r1, r1, r3
 802cbb0:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 802cbb4:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 802cbb8:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 802cbbc:	f04f 0000 	mov.w	r0, #0
 802cbc0:	bd70      	pop	{r4, r5, r6, pc}
 802cbc2:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 802cbc6:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 802cbca:	bd70      	pop	{r4, r5, r6, pc}

0802cbcc <__aeabi_ddiv>:
 802cbcc:	b570      	push	{r4, r5, r6, lr}
 802cbce:	f04f 0cff 	mov.w	ip, #255	; 0xff
 802cbd2:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 802cbd6:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 802cbda:	bf1d      	ittte	ne
 802cbdc:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 802cbe0:	ea94 0f0c 	teqne	r4, ip
 802cbe4:	ea95 0f0c 	teqne	r5, ip
 802cbe8:	f000 f8a7 	bleq	802cd3a <__aeabi_ddiv+0x16e>
 802cbec:	eba4 0405 	sub.w	r4, r4, r5
 802cbf0:	ea81 0e03 	eor.w	lr, r1, r3
 802cbf4:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 802cbf8:	ea4f 3101 	mov.w	r1, r1, lsl #12
 802cbfc:	f000 8088 	beq.w	802cd10 <__aeabi_ddiv+0x144>
 802cc00:	ea4f 3303 	mov.w	r3, r3, lsl #12
 802cc04:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 802cc08:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 802cc0c:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 802cc10:	ea4f 2202 	mov.w	r2, r2, lsl #8
 802cc14:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 802cc18:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 802cc1c:	ea4f 2600 	mov.w	r6, r0, lsl #8
 802cc20:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 802cc24:	429d      	cmp	r5, r3
 802cc26:	bf08      	it	eq
 802cc28:	4296      	cmpeq	r6, r2
 802cc2a:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 802cc2e:	f504 7440 	add.w	r4, r4, #768	; 0x300
 802cc32:	d202      	bcs.n	802cc3a <__aeabi_ddiv+0x6e>
 802cc34:	085b      	lsrs	r3, r3, #1
 802cc36:	ea4f 0232 	mov.w	r2, r2, rrx
 802cc3a:	1ab6      	subs	r6, r6, r2
 802cc3c:	eb65 0503 	sbc.w	r5, r5, r3
 802cc40:	085b      	lsrs	r3, r3, #1
 802cc42:	ea4f 0232 	mov.w	r2, r2, rrx
 802cc46:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 802cc4a:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 802cc4e:	ebb6 0e02 	subs.w	lr, r6, r2
 802cc52:	eb75 0e03 	sbcs.w	lr, r5, r3
 802cc56:	bf22      	ittt	cs
 802cc58:	1ab6      	subcs	r6, r6, r2
 802cc5a:	4675      	movcs	r5, lr
 802cc5c:	ea40 000c 	orrcs.w	r0, r0, ip
 802cc60:	085b      	lsrs	r3, r3, #1
 802cc62:	ea4f 0232 	mov.w	r2, r2, rrx
 802cc66:	ebb6 0e02 	subs.w	lr, r6, r2
 802cc6a:	eb75 0e03 	sbcs.w	lr, r5, r3
 802cc6e:	bf22      	ittt	cs
 802cc70:	1ab6      	subcs	r6, r6, r2
 802cc72:	4675      	movcs	r5, lr
 802cc74:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 802cc78:	085b      	lsrs	r3, r3, #1
 802cc7a:	ea4f 0232 	mov.w	r2, r2, rrx
 802cc7e:	ebb6 0e02 	subs.w	lr, r6, r2
 802cc82:	eb75 0e03 	sbcs.w	lr, r5, r3
 802cc86:	bf22      	ittt	cs
 802cc88:	1ab6      	subcs	r6, r6, r2
 802cc8a:	4675      	movcs	r5, lr
 802cc8c:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 802cc90:	085b      	lsrs	r3, r3, #1
 802cc92:	ea4f 0232 	mov.w	r2, r2, rrx
 802cc96:	ebb6 0e02 	subs.w	lr, r6, r2
 802cc9a:	eb75 0e03 	sbcs.w	lr, r5, r3
 802cc9e:	bf22      	ittt	cs
 802cca0:	1ab6      	subcs	r6, r6, r2
 802cca2:	4675      	movcs	r5, lr
 802cca4:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 802cca8:	ea55 0e06 	orrs.w	lr, r5, r6
 802ccac:	d018      	beq.n	802cce0 <__aeabi_ddiv+0x114>
 802ccae:	ea4f 1505 	mov.w	r5, r5, lsl #4
 802ccb2:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 802ccb6:	ea4f 1606 	mov.w	r6, r6, lsl #4
 802ccba:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 802ccbe:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 802ccc2:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 802ccc6:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 802ccca:	d1c0      	bne.n	802cc4e <__aeabi_ddiv+0x82>
 802cccc:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 802ccd0:	d10b      	bne.n	802ccea <__aeabi_ddiv+0x11e>
 802ccd2:	ea41 0100 	orr.w	r1, r1, r0
 802ccd6:	f04f 0000 	mov.w	r0, #0
 802ccda:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 802ccde:	e7b6      	b.n	802cc4e <__aeabi_ddiv+0x82>
 802cce0:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 802cce4:	bf04      	itt	eq
 802cce6:	4301      	orreq	r1, r0
 802cce8:	2000      	moveq	r0, #0
 802ccea:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 802ccee:	bf88      	it	hi
 802ccf0:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 802ccf4:	f63f aeaf 	bhi.w	802ca56 <__aeabi_dmul+0xde>
 802ccf8:	ebb5 0c03 	subs.w	ip, r5, r3
 802ccfc:	bf04      	itt	eq
 802ccfe:	ebb6 0c02 	subseq.w	ip, r6, r2
 802cd02:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 802cd06:	f150 0000 	adcs.w	r0, r0, #0
 802cd0a:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 802cd0e:	bd70      	pop	{r4, r5, r6, pc}
 802cd10:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 802cd14:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 802cd18:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 802cd1c:	bfc2      	ittt	gt
 802cd1e:	ebd4 050c 	rsbsgt	r5, r4, ip
 802cd22:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 802cd26:	bd70      	popgt	{r4, r5, r6, pc}
 802cd28:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 802cd2c:	f04f 0e00 	mov.w	lr, #0
 802cd30:	3c01      	subs	r4, #1
 802cd32:	e690      	b.n	802ca56 <__aeabi_dmul+0xde>
 802cd34:	ea45 0e06 	orr.w	lr, r5, r6
 802cd38:	e68d      	b.n	802ca56 <__aeabi_dmul+0xde>
 802cd3a:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 802cd3e:	ea94 0f0c 	teq	r4, ip
 802cd42:	bf08      	it	eq
 802cd44:	ea95 0f0c 	teqeq	r5, ip
 802cd48:	f43f af3b 	beq.w	802cbc2 <__aeabi_dmul+0x24a>
 802cd4c:	ea94 0f0c 	teq	r4, ip
 802cd50:	d10a      	bne.n	802cd68 <__aeabi_ddiv+0x19c>
 802cd52:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 802cd56:	f47f af34 	bne.w	802cbc2 <__aeabi_dmul+0x24a>
 802cd5a:	ea95 0f0c 	teq	r5, ip
 802cd5e:	f47f af25 	bne.w	802cbac <__aeabi_dmul+0x234>
 802cd62:	4610      	mov	r0, r2
 802cd64:	4619      	mov	r1, r3
 802cd66:	e72c      	b.n	802cbc2 <__aeabi_dmul+0x24a>
 802cd68:	ea95 0f0c 	teq	r5, ip
 802cd6c:	d106      	bne.n	802cd7c <__aeabi_ddiv+0x1b0>
 802cd6e:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 802cd72:	f43f aefd 	beq.w	802cb70 <__aeabi_dmul+0x1f8>
 802cd76:	4610      	mov	r0, r2
 802cd78:	4619      	mov	r1, r3
 802cd7a:	e722      	b.n	802cbc2 <__aeabi_dmul+0x24a>
 802cd7c:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 802cd80:	bf18      	it	ne
 802cd82:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 802cd86:	f47f aec5 	bne.w	802cb14 <__aeabi_dmul+0x19c>
 802cd8a:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 802cd8e:	f47f af0d 	bne.w	802cbac <__aeabi_dmul+0x234>
 802cd92:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 802cd96:	f47f aeeb 	bne.w	802cb70 <__aeabi_dmul+0x1f8>
 802cd9a:	e712      	b.n	802cbc2 <__aeabi_dmul+0x24a>

0802cd9c <__gedf2>:
 802cd9c:	f04f 3cff 	mov.w	ip, #4294967295
 802cda0:	e006      	b.n	802cdb0 <__cmpdf2+0x4>
 802cda2:	bf00      	nop

0802cda4 <__ledf2>:
 802cda4:	f04f 0c01 	mov.w	ip, #1
 802cda8:	e002      	b.n	802cdb0 <__cmpdf2+0x4>
 802cdaa:	bf00      	nop

0802cdac <__cmpdf2>:
 802cdac:	f04f 0c01 	mov.w	ip, #1
 802cdb0:	f84d cd04 	str.w	ip, [sp, #-4]!
 802cdb4:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 802cdb8:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 802cdbc:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 802cdc0:	bf18      	it	ne
 802cdc2:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
 802cdc6:	d01b      	beq.n	802ce00 <__cmpdf2+0x54>
 802cdc8:	b001      	add	sp, #4
 802cdca:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
 802cdce:	bf0c      	ite	eq
 802cdd0:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
 802cdd4:	ea91 0f03 	teqne	r1, r3
 802cdd8:	bf02      	ittt	eq
 802cdda:	ea90 0f02 	teqeq	r0, r2
 802cdde:	2000      	moveq	r0, #0
 802cde0:	4770      	bxeq	lr
 802cde2:	f110 0f00 	cmn.w	r0, #0
 802cde6:	ea91 0f03 	teq	r1, r3
 802cdea:	bf58      	it	pl
 802cdec:	4299      	cmppl	r1, r3
 802cdee:	bf08      	it	eq
 802cdf0:	4290      	cmpeq	r0, r2
 802cdf2:	bf2c      	ite	cs
 802cdf4:	17d8      	asrcs	r0, r3, #31
 802cdf6:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
 802cdfa:	f040 0001 	orr.w	r0, r0, #1
 802cdfe:	4770      	bx	lr
 802ce00:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 802ce04:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 802ce08:	d102      	bne.n	802ce10 <__cmpdf2+0x64>
 802ce0a:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 802ce0e:	d107      	bne.n	802ce20 <__cmpdf2+0x74>
 802ce10:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 802ce14:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 802ce18:	d1d6      	bne.n	802cdc8 <__cmpdf2+0x1c>
 802ce1a:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 802ce1e:	d0d3      	beq.n	802cdc8 <__cmpdf2+0x1c>
 802ce20:	f85d 0b04 	ldr.w	r0, [sp], #4
 802ce24:	4770      	bx	lr
 802ce26:	bf00      	nop

0802ce28 <__aeabi_cdrcmple>:
 802ce28:	4684      	mov	ip, r0
 802ce2a:	4610      	mov	r0, r2
 802ce2c:	4662      	mov	r2, ip
 802ce2e:	468c      	mov	ip, r1
 802ce30:	4619      	mov	r1, r3
 802ce32:	4663      	mov	r3, ip
 802ce34:	e000      	b.n	802ce38 <__aeabi_cdcmpeq>
 802ce36:	bf00      	nop

0802ce38 <__aeabi_cdcmpeq>:
 802ce38:	b501      	push	{r0, lr}
 802ce3a:	f7ff ffb7 	bl	802cdac <__cmpdf2>
 802ce3e:	2800      	cmp	r0, #0
 802ce40:	bf48      	it	mi
 802ce42:	f110 0f00 	cmnmi.w	r0, #0
 802ce46:	bd01      	pop	{r0, pc}

0802ce48 <__aeabi_dcmpeq>:
 802ce48:	f84d ed08 	str.w	lr, [sp, #-8]!
 802ce4c:	f7ff fff4 	bl	802ce38 <__aeabi_cdcmpeq>
 802ce50:	bf0c      	ite	eq
 802ce52:	2001      	moveq	r0, #1
 802ce54:	2000      	movne	r0, #0
 802ce56:	f85d fb08 	ldr.w	pc, [sp], #8
 802ce5a:	bf00      	nop

0802ce5c <__aeabi_dcmplt>:
 802ce5c:	f84d ed08 	str.w	lr, [sp, #-8]!
 802ce60:	f7ff ffea 	bl	802ce38 <__aeabi_cdcmpeq>
 802ce64:	bf34      	ite	cc
 802ce66:	2001      	movcc	r0, #1
 802ce68:	2000      	movcs	r0, #0
 802ce6a:	f85d fb08 	ldr.w	pc, [sp], #8
 802ce6e:	bf00      	nop

0802ce70 <__aeabi_dcmple>:
 802ce70:	f84d ed08 	str.w	lr, [sp, #-8]!
 802ce74:	f7ff ffe0 	bl	802ce38 <__aeabi_cdcmpeq>
 802ce78:	bf94      	ite	ls
 802ce7a:	2001      	movls	r0, #1
 802ce7c:	2000      	movhi	r0, #0
 802ce7e:	f85d fb08 	ldr.w	pc, [sp], #8
 802ce82:	bf00      	nop

0802ce84 <__aeabi_dcmpge>:
 802ce84:	f84d ed08 	str.w	lr, [sp, #-8]!
 802ce88:	f7ff ffce 	bl	802ce28 <__aeabi_cdrcmple>
 802ce8c:	bf94      	ite	ls
 802ce8e:	2001      	movls	r0, #1
 802ce90:	2000      	movhi	r0, #0
 802ce92:	f85d fb08 	ldr.w	pc, [sp], #8
 802ce96:	bf00      	nop

0802ce98 <__aeabi_dcmpgt>:
 802ce98:	f84d ed08 	str.w	lr, [sp, #-8]!
 802ce9c:	f7ff ffc4 	bl	802ce28 <__aeabi_cdrcmple>
 802cea0:	bf34      	ite	cc
 802cea2:	2001      	movcc	r0, #1
 802cea4:	2000      	movcs	r0, #0
 802cea6:	f85d fb08 	ldr.w	pc, [sp], #8
 802ceaa:	bf00      	nop

0802ceac <__aeabi_d2uiz>:
 802ceac:	004a      	lsls	r2, r1, #1
 802ceae:	d211      	bcs.n	802ced4 <__aeabi_d2uiz+0x28>
 802ceb0:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 802ceb4:	d211      	bcs.n	802ceda <__aeabi_d2uiz+0x2e>
 802ceb6:	d50d      	bpl.n	802ced4 <__aeabi_d2uiz+0x28>
 802ceb8:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 802cebc:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 802cec0:	d40e      	bmi.n	802cee0 <__aeabi_d2uiz+0x34>
 802cec2:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 802cec6:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 802ceca:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 802cece:	fa23 f002 	lsr.w	r0, r3, r2
 802ced2:	4770      	bx	lr
 802ced4:	f04f 0000 	mov.w	r0, #0
 802ced8:	4770      	bx	lr
 802ceda:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 802cede:	d102      	bne.n	802cee6 <__aeabi_d2uiz+0x3a>
 802cee0:	f04f 30ff 	mov.w	r0, #4294967295
 802cee4:	4770      	bx	lr
 802cee6:	f04f 0000 	mov.w	r0, #0
 802ceea:	4770      	bx	lr

0802ceec <__aeabi_d2f>:
 802ceec:	ea4f 0241 	mov.w	r2, r1, lsl #1
 802cef0:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
 802cef4:	bf24      	itt	cs
 802cef6:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
 802cefa:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
 802cefe:	d90d      	bls.n	802cf1c <__aeabi_d2f+0x30>
 802cf00:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 802cf04:	ea4f 02c0 	mov.w	r2, r0, lsl #3
 802cf08:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
 802cf0c:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
 802cf10:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
 802cf14:	bf08      	it	eq
 802cf16:	f020 0001 	biceq.w	r0, r0, #1
 802cf1a:	4770      	bx	lr
 802cf1c:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
 802cf20:	d121      	bne.n	802cf66 <__aeabi_d2f+0x7a>
 802cf22:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
 802cf26:	bfbc      	itt	lt
 802cf28:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
 802cf2c:	4770      	bxlt	lr
 802cf2e:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 802cf32:	ea4f 5252 	mov.w	r2, r2, lsr #21
 802cf36:	f1c2 0218 	rsb	r2, r2, #24
 802cf3a:	f1c2 0c20 	rsb	ip, r2, #32
 802cf3e:	fa10 f30c 	lsls.w	r3, r0, ip
 802cf42:	fa20 f002 	lsr.w	r0, r0, r2
 802cf46:	bf18      	it	ne
 802cf48:	f040 0001 	orrne.w	r0, r0, #1
 802cf4c:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 802cf50:	ea4f 23d3 	mov.w	r3, r3, lsr #11
 802cf54:	fa03 fc0c 	lsl.w	ip, r3, ip
 802cf58:	ea40 000c 	orr.w	r0, r0, ip
 802cf5c:	fa23 f302 	lsr.w	r3, r3, r2
 802cf60:	ea4f 0343 	mov.w	r3, r3, lsl #1
 802cf64:	e7cc      	b.n	802cf00 <__aeabi_d2f+0x14>
 802cf66:	ea7f 5362 	mvns.w	r3, r2, asr #21
 802cf6a:	d107      	bne.n	802cf7c <__aeabi_d2f+0x90>
 802cf6c:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
 802cf70:	bf1e      	ittt	ne
 802cf72:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
 802cf76:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
 802cf7a:	4770      	bxne	lr
 802cf7c:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
 802cf80:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 802cf84:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 802cf88:	4770      	bx	lr
 802cf8a:	bf00      	nop

0802cf8c <__aeabi_uldivmod>:
 802cf8c:	b94b      	cbnz	r3, 802cfa2 <__aeabi_uldivmod+0x16>
 802cf8e:	b942      	cbnz	r2, 802cfa2 <__aeabi_uldivmod+0x16>
 802cf90:	2900      	cmp	r1, #0
 802cf92:	bf08      	it	eq
 802cf94:	2800      	cmpeq	r0, #0
 802cf96:	d002      	beq.n	802cf9e <__aeabi_uldivmod+0x12>
 802cf98:	f04f 31ff 	mov.w	r1, #4294967295
 802cf9c:	4608      	mov	r0, r1
 802cf9e:	f000 b83b 	b.w	802d018 <__aeabi_idiv0>
 802cfa2:	b082      	sub	sp, #8
 802cfa4:	46ec      	mov	ip, sp
 802cfa6:	e92d 5000 	stmdb	sp!, {ip, lr}
 802cfaa:	f000 f81d 	bl	802cfe8 <__gnu_uldivmod_helper>
 802cfae:	f8dd e004 	ldr.w	lr, [sp, #4]
 802cfb2:	b002      	add	sp, #8
 802cfb4:	bc0c      	pop	{r2, r3}
 802cfb6:	4770      	bx	lr

0802cfb8 <__gnu_ldivmod_helper>:
 802cfb8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 802cfbc:	9c06      	ldr	r4, [sp, #24]
 802cfbe:	4615      	mov	r5, r2
 802cfc0:	4606      	mov	r6, r0
 802cfc2:	460f      	mov	r7, r1
 802cfc4:	4698      	mov	r8, r3
 802cfc6:	f000 f829 	bl	802d01c <__divdi3>
 802cfca:	fb05 f301 	mul.w	r3, r5, r1
 802cfce:	fb00 3808 	mla	r8, r0, r8, r3
 802cfd2:	fba5 2300 	umull	r2, r3, r5, r0
 802cfd6:	1ab2      	subs	r2, r6, r2
 802cfd8:	4443      	add	r3, r8
 802cfda:	eb67 0303 	sbc.w	r3, r7, r3
 802cfde:	e9c4 2300 	strd	r2, r3, [r4]
 802cfe2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802cfe6:	bf00      	nop

0802cfe8 <__gnu_uldivmod_helper>:
 802cfe8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 802cfec:	9c06      	ldr	r4, [sp, #24]
 802cfee:	4690      	mov	r8, r2
 802cff0:	4606      	mov	r6, r0
 802cff2:	460f      	mov	r7, r1
 802cff4:	461d      	mov	r5, r3
 802cff6:	f000 f95f 	bl	802d2b8 <__udivdi3>
 802cffa:	fb00 f505 	mul.w	r5, r0, r5
 802cffe:	fba0 2308 	umull	r2, r3, r0, r8
 802d002:	fb08 5501 	mla	r5, r8, r1, r5
 802d006:	1ab2      	subs	r2, r6, r2
 802d008:	442b      	add	r3, r5
 802d00a:	eb67 0303 	sbc.w	r3, r7, r3
 802d00e:	e9c4 2300 	strd	r2, r3, [r4]
 802d012:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802d016:	bf00      	nop

0802d018 <__aeabi_idiv0>:
 802d018:	4770      	bx	lr
 802d01a:	bf00      	nop

0802d01c <__divdi3>:
 802d01c:	2900      	cmp	r1, #0
 802d01e:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 802d022:	f2c0 80a6 	blt.w	802d172 <__divdi3+0x156>
 802d026:	2600      	movs	r6, #0
 802d028:	2b00      	cmp	r3, #0
 802d02a:	f2c0 809c 	blt.w	802d166 <__divdi3+0x14a>
 802d02e:	4688      	mov	r8, r1
 802d030:	4694      	mov	ip, r2
 802d032:	469e      	mov	lr, r3
 802d034:	4615      	mov	r5, r2
 802d036:	4604      	mov	r4, r0
 802d038:	460f      	mov	r7, r1
 802d03a:	2b00      	cmp	r3, #0
 802d03c:	d13d      	bne.n	802d0ba <__divdi3+0x9e>
 802d03e:	428a      	cmp	r2, r1
 802d040:	d959      	bls.n	802d0f6 <__divdi3+0xda>
 802d042:	fab2 f382 	clz	r3, r2
 802d046:	b13b      	cbz	r3, 802d058 <__divdi3+0x3c>
 802d048:	f1c3 0220 	rsb	r2, r3, #32
 802d04c:	409f      	lsls	r7, r3
 802d04e:	fa20 f202 	lsr.w	r2, r0, r2
 802d052:	409d      	lsls	r5, r3
 802d054:	4317      	orrs	r7, r2
 802d056:	409c      	lsls	r4, r3
 802d058:	0c29      	lsrs	r1, r5, #16
 802d05a:	0c22      	lsrs	r2, r4, #16
 802d05c:	fbb7 fef1 	udiv	lr, r7, r1
 802d060:	b2a8      	uxth	r0, r5
 802d062:	fb01 771e 	mls	r7, r1, lr, r7
 802d066:	ea42 4707 	orr.w	r7, r2, r7, lsl #16
 802d06a:	fb00 f30e 	mul.w	r3, r0, lr
 802d06e:	42bb      	cmp	r3, r7
 802d070:	d90a      	bls.n	802d088 <__divdi3+0x6c>
 802d072:	197f      	adds	r7, r7, r5
 802d074:	f10e 32ff 	add.w	r2, lr, #4294967295
 802d078:	f080 8105 	bcs.w	802d286 <__divdi3+0x26a>
 802d07c:	42bb      	cmp	r3, r7
 802d07e:	f240 8102 	bls.w	802d286 <__divdi3+0x26a>
 802d082:	f1ae 0e02 	sub.w	lr, lr, #2
 802d086:	442f      	add	r7, r5
 802d088:	1aff      	subs	r7, r7, r3
 802d08a:	b2a4      	uxth	r4, r4
 802d08c:	fbb7 f3f1 	udiv	r3, r7, r1
 802d090:	fb01 7713 	mls	r7, r1, r3, r7
 802d094:	ea44 4707 	orr.w	r7, r4, r7, lsl #16
 802d098:	fb00 f003 	mul.w	r0, r0, r3
 802d09c:	42b8      	cmp	r0, r7
 802d09e:	d908      	bls.n	802d0b2 <__divdi3+0x96>
 802d0a0:	197f      	adds	r7, r7, r5
 802d0a2:	f103 32ff 	add.w	r2, r3, #4294967295
 802d0a6:	f080 80f0 	bcs.w	802d28a <__divdi3+0x26e>
 802d0aa:	42b8      	cmp	r0, r7
 802d0ac:	f240 80ed 	bls.w	802d28a <__divdi3+0x26e>
 802d0b0:	3b02      	subs	r3, #2
 802d0b2:	ea43 430e 	orr.w	r3, r3, lr, lsl #16
 802d0b6:	2200      	movs	r2, #0
 802d0b8:	e003      	b.n	802d0c2 <__divdi3+0xa6>
 802d0ba:	428b      	cmp	r3, r1
 802d0bc:	d90f      	bls.n	802d0de <__divdi3+0xc2>
 802d0be:	2200      	movs	r2, #0
 802d0c0:	4613      	mov	r3, r2
 802d0c2:	1c34      	adds	r4, r6, #0
 802d0c4:	bf18      	it	ne
 802d0c6:	2401      	movne	r4, #1
 802d0c8:	4260      	negs	r0, r4
 802d0ca:	f04f 0500 	mov.w	r5, #0
 802d0ce:	eb65 0145 	sbc.w	r1, r5, r5, lsl #1
 802d0d2:	4058      	eors	r0, r3
 802d0d4:	4051      	eors	r1, r2
 802d0d6:	1900      	adds	r0, r0, r4
 802d0d8:	4169      	adcs	r1, r5
 802d0da:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 802d0de:	fab3 f283 	clz	r2, r3
 802d0e2:	2a00      	cmp	r2, #0
 802d0e4:	f040 8086 	bne.w	802d1f4 <__divdi3+0x1d8>
 802d0e8:	428b      	cmp	r3, r1
 802d0ea:	d302      	bcc.n	802d0f2 <__divdi3+0xd6>
 802d0ec:	4584      	cmp	ip, r0
 802d0ee:	f200 80db 	bhi.w	802d2a8 <__divdi3+0x28c>
 802d0f2:	2301      	movs	r3, #1
 802d0f4:	e7e5      	b.n	802d0c2 <__divdi3+0xa6>
 802d0f6:	b912      	cbnz	r2, 802d0fe <__divdi3+0xe2>
 802d0f8:	2301      	movs	r3, #1
 802d0fa:	fbb3 f5f2 	udiv	r5, r3, r2
 802d0fe:	fab5 f085 	clz	r0, r5
 802d102:	2800      	cmp	r0, #0
 802d104:	d13b      	bne.n	802d17e <__divdi3+0x162>
 802d106:	1b78      	subs	r0, r7, r5
 802d108:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 802d10c:	fa1f fc85 	uxth.w	ip, r5
 802d110:	2201      	movs	r2, #1
 802d112:	fbb0 f8fe 	udiv	r8, r0, lr
 802d116:	0c21      	lsrs	r1, r4, #16
 802d118:	fb0e 0718 	mls	r7, lr, r8, r0
 802d11c:	ea41 4707 	orr.w	r7, r1, r7, lsl #16
 802d120:	fb0c f308 	mul.w	r3, ip, r8
 802d124:	42bb      	cmp	r3, r7
 802d126:	d907      	bls.n	802d138 <__divdi3+0x11c>
 802d128:	197f      	adds	r7, r7, r5
 802d12a:	f108 31ff 	add.w	r1, r8, #4294967295
 802d12e:	d202      	bcs.n	802d136 <__divdi3+0x11a>
 802d130:	42bb      	cmp	r3, r7
 802d132:	f200 80bd 	bhi.w	802d2b0 <__divdi3+0x294>
 802d136:	4688      	mov	r8, r1
 802d138:	1aff      	subs	r7, r7, r3
 802d13a:	b2a4      	uxth	r4, r4
 802d13c:	fbb7 f3fe 	udiv	r3, r7, lr
 802d140:	fb0e 7713 	mls	r7, lr, r3, r7
 802d144:	ea44 4707 	orr.w	r7, r4, r7, lsl #16
 802d148:	fb0c fc03 	mul.w	ip, ip, r3
 802d14c:	45bc      	cmp	ip, r7
 802d14e:	d907      	bls.n	802d160 <__divdi3+0x144>
 802d150:	197f      	adds	r7, r7, r5
 802d152:	f103 31ff 	add.w	r1, r3, #4294967295
 802d156:	d202      	bcs.n	802d15e <__divdi3+0x142>
 802d158:	45bc      	cmp	ip, r7
 802d15a:	f200 80a7 	bhi.w	802d2ac <__divdi3+0x290>
 802d15e:	460b      	mov	r3, r1
 802d160:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 802d164:	e7ad      	b.n	802d0c2 <__divdi3+0xa6>
 802d166:	4252      	negs	r2, r2
 802d168:	ea6f 0606 	mvn.w	r6, r6
 802d16c:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 802d170:	e75d      	b.n	802d02e <__divdi3+0x12>
 802d172:	4240      	negs	r0, r0
 802d174:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 802d178:	f04f 36ff 	mov.w	r6, #4294967295
 802d17c:	e754      	b.n	802d028 <__divdi3+0xc>
 802d17e:	f1c0 0220 	rsb	r2, r0, #32
 802d182:	fa24 f102 	lsr.w	r1, r4, r2
 802d186:	fa07 f300 	lsl.w	r3, r7, r0
 802d18a:	4085      	lsls	r5, r0
 802d18c:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 802d190:	40d7      	lsrs	r7, r2
 802d192:	4319      	orrs	r1, r3
 802d194:	fbb7 f2fe 	udiv	r2, r7, lr
 802d198:	0c0b      	lsrs	r3, r1, #16
 802d19a:	fb0e 7712 	mls	r7, lr, r2, r7
 802d19e:	fa1f fc85 	uxth.w	ip, r5
 802d1a2:	ea43 4307 	orr.w	r3, r3, r7, lsl #16
 802d1a6:	fb0c f702 	mul.w	r7, ip, r2
 802d1aa:	429f      	cmp	r7, r3
 802d1ac:	fa04 f400 	lsl.w	r4, r4, r0
 802d1b0:	d907      	bls.n	802d1c2 <__divdi3+0x1a6>
 802d1b2:	195b      	adds	r3, r3, r5
 802d1b4:	f102 30ff 	add.w	r0, r2, #4294967295
 802d1b8:	d274      	bcs.n	802d2a4 <__divdi3+0x288>
 802d1ba:	429f      	cmp	r7, r3
 802d1bc:	d972      	bls.n	802d2a4 <__divdi3+0x288>
 802d1be:	3a02      	subs	r2, #2
 802d1c0:	442b      	add	r3, r5
 802d1c2:	1bdf      	subs	r7, r3, r7
 802d1c4:	b289      	uxth	r1, r1
 802d1c6:	fbb7 f8fe 	udiv	r8, r7, lr
 802d1ca:	fb0e 7318 	mls	r3, lr, r8, r7
 802d1ce:	ea41 4303 	orr.w	r3, r1, r3, lsl #16
 802d1d2:	fb0c f708 	mul.w	r7, ip, r8
 802d1d6:	429f      	cmp	r7, r3
 802d1d8:	d908      	bls.n	802d1ec <__divdi3+0x1d0>
 802d1da:	195b      	adds	r3, r3, r5
 802d1dc:	f108 31ff 	add.w	r1, r8, #4294967295
 802d1e0:	d25c      	bcs.n	802d29c <__divdi3+0x280>
 802d1e2:	429f      	cmp	r7, r3
 802d1e4:	d95a      	bls.n	802d29c <__divdi3+0x280>
 802d1e6:	f1a8 0802 	sub.w	r8, r8, #2
 802d1ea:	442b      	add	r3, r5
 802d1ec:	1bd8      	subs	r0, r3, r7
 802d1ee:	ea48 4202 	orr.w	r2, r8, r2, lsl #16
 802d1f2:	e78e      	b.n	802d112 <__divdi3+0xf6>
 802d1f4:	f1c2 0320 	rsb	r3, r2, #32
 802d1f8:	fa2c f103 	lsr.w	r1, ip, r3
 802d1fc:	fa0e fe02 	lsl.w	lr, lr, r2
 802d200:	fa20 f703 	lsr.w	r7, r0, r3
 802d204:	ea41 0e0e 	orr.w	lr, r1, lr
 802d208:	fa08 f002 	lsl.w	r0, r8, r2
 802d20c:	fa28 f103 	lsr.w	r1, r8, r3
 802d210:	ea4f 451e 	mov.w	r5, lr, lsr #16
 802d214:	4338      	orrs	r0, r7
 802d216:	fbb1 f8f5 	udiv	r8, r1, r5
 802d21a:	0c03      	lsrs	r3, r0, #16
 802d21c:	fb05 1118 	mls	r1, r5, r8, r1
 802d220:	fa1f f78e 	uxth.w	r7, lr
 802d224:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
 802d228:	fb07 f308 	mul.w	r3, r7, r8
 802d22c:	428b      	cmp	r3, r1
 802d22e:	fa0c fc02 	lsl.w	ip, ip, r2
 802d232:	d909      	bls.n	802d248 <__divdi3+0x22c>
 802d234:	eb11 010e 	adds.w	r1, r1, lr
 802d238:	f108 39ff 	add.w	r9, r8, #4294967295
 802d23c:	d230      	bcs.n	802d2a0 <__divdi3+0x284>
 802d23e:	428b      	cmp	r3, r1
 802d240:	d92e      	bls.n	802d2a0 <__divdi3+0x284>
 802d242:	f1a8 0802 	sub.w	r8, r8, #2
 802d246:	4471      	add	r1, lr
 802d248:	1ac9      	subs	r1, r1, r3
 802d24a:	b280      	uxth	r0, r0
 802d24c:	fbb1 f3f5 	udiv	r3, r1, r5
 802d250:	fb05 1113 	mls	r1, r5, r3, r1
 802d254:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
 802d258:	fb07 f703 	mul.w	r7, r7, r3
 802d25c:	428f      	cmp	r7, r1
 802d25e:	d908      	bls.n	802d272 <__divdi3+0x256>
 802d260:	eb11 010e 	adds.w	r1, r1, lr
 802d264:	f103 30ff 	add.w	r0, r3, #4294967295
 802d268:	d216      	bcs.n	802d298 <__divdi3+0x27c>
 802d26a:	428f      	cmp	r7, r1
 802d26c:	d914      	bls.n	802d298 <__divdi3+0x27c>
 802d26e:	3b02      	subs	r3, #2
 802d270:	4471      	add	r1, lr
 802d272:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 802d276:	1bc9      	subs	r1, r1, r7
 802d278:	fba3 890c 	umull	r8, r9, r3, ip
 802d27c:	4549      	cmp	r1, r9
 802d27e:	d309      	bcc.n	802d294 <__divdi3+0x278>
 802d280:	d005      	beq.n	802d28e <__divdi3+0x272>
 802d282:	2200      	movs	r2, #0
 802d284:	e71d      	b.n	802d0c2 <__divdi3+0xa6>
 802d286:	4696      	mov	lr, r2
 802d288:	e6fe      	b.n	802d088 <__divdi3+0x6c>
 802d28a:	4613      	mov	r3, r2
 802d28c:	e711      	b.n	802d0b2 <__divdi3+0x96>
 802d28e:	4094      	lsls	r4, r2
 802d290:	4544      	cmp	r4, r8
 802d292:	d2f6      	bcs.n	802d282 <__divdi3+0x266>
 802d294:	3b01      	subs	r3, #1
 802d296:	e7f4      	b.n	802d282 <__divdi3+0x266>
 802d298:	4603      	mov	r3, r0
 802d29a:	e7ea      	b.n	802d272 <__divdi3+0x256>
 802d29c:	4688      	mov	r8, r1
 802d29e:	e7a5      	b.n	802d1ec <__divdi3+0x1d0>
 802d2a0:	46c8      	mov	r8, r9
 802d2a2:	e7d1      	b.n	802d248 <__divdi3+0x22c>
 802d2a4:	4602      	mov	r2, r0
 802d2a6:	e78c      	b.n	802d1c2 <__divdi3+0x1a6>
 802d2a8:	4613      	mov	r3, r2
 802d2aa:	e70a      	b.n	802d0c2 <__divdi3+0xa6>
 802d2ac:	3b02      	subs	r3, #2
 802d2ae:	e757      	b.n	802d160 <__divdi3+0x144>
 802d2b0:	f1a8 0802 	sub.w	r8, r8, #2
 802d2b4:	442f      	add	r7, r5
 802d2b6:	e73f      	b.n	802d138 <__divdi3+0x11c>

0802d2b8 <__udivdi3>:
 802d2b8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 802d2bc:	2b00      	cmp	r3, #0
 802d2be:	d144      	bne.n	802d34a <__udivdi3+0x92>
 802d2c0:	428a      	cmp	r2, r1
 802d2c2:	4615      	mov	r5, r2
 802d2c4:	4604      	mov	r4, r0
 802d2c6:	d94f      	bls.n	802d368 <__udivdi3+0xb0>
 802d2c8:	fab2 f782 	clz	r7, r2
 802d2cc:	460e      	mov	r6, r1
 802d2ce:	b14f      	cbz	r7, 802d2e4 <__udivdi3+0x2c>
 802d2d0:	f1c7 0320 	rsb	r3, r7, #32
 802d2d4:	40b9      	lsls	r1, r7
 802d2d6:	fa20 f603 	lsr.w	r6, r0, r3
 802d2da:	fa02 f507 	lsl.w	r5, r2, r7
 802d2de:	430e      	orrs	r6, r1
 802d2e0:	fa00 f407 	lsl.w	r4, r0, r7
 802d2e4:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 802d2e8:	0c23      	lsrs	r3, r4, #16
 802d2ea:	fbb6 f0fe 	udiv	r0, r6, lr
 802d2ee:	b2af      	uxth	r7, r5
 802d2f0:	fb0e 6110 	mls	r1, lr, r0, r6
 802d2f4:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 802d2f8:	fb07 f100 	mul.w	r1, r7, r0
 802d2fc:	4299      	cmp	r1, r3
 802d2fe:	d909      	bls.n	802d314 <__udivdi3+0x5c>
 802d300:	195b      	adds	r3, r3, r5
 802d302:	f100 32ff 	add.w	r2, r0, #4294967295
 802d306:	f080 80ec 	bcs.w	802d4e2 <__udivdi3+0x22a>
 802d30a:	4299      	cmp	r1, r3
 802d30c:	f240 80e9 	bls.w	802d4e2 <__udivdi3+0x22a>
 802d310:	3802      	subs	r0, #2
 802d312:	442b      	add	r3, r5
 802d314:	1a5a      	subs	r2, r3, r1
 802d316:	b2a4      	uxth	r4, r4
 802d318:	fbb2 f3fe 	udiv	r3, r2, lr
 802d31c:	fb0e 2213 	mls	r2, lr, r3, r2
 802d320:	ea44 4202 	orr.w	r2, r4, r2, lsl #16
 802d324:	fb07 f703 	mul.w	r7, r7, r3
 802d328:	4297      	cmp	r7, r2
 802d32a:	d908      	bls.n	802d33e <__udivdi3+0x86>
 802d32c:	1952      	adds	r2, r2, r5
 802d32e:	f103 31ff 	add.w	r1, r3, #4294967295
 802d332:	f080 80d8 	bcs.w	802d4e6 <__udivdi3+0x22e>
 802d336:	4297      	cmp	r7, r2
 802d338:	f240 80d5 	bls.w	802d4e6 <__udivdi3+0x22e>
 802d33c:	3b02      	subs	r3, #2
 802d33e:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 802d342:	2600      	movs	r6, #0
 802d344:	4631      	mov	r1, r6
 802d346:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802d34a:	428b      	cmp	r3, r1
 802d34c:	d847      	bhi.n	802d3de <__udivdi3+0x126>
 802d34e:	fab3 f683 	clz	r6, r3
 802d352:	2e00      	cmp	r6, #0
 802d354:	d148      	bne.n	802d3e8 <__udivdi3+0x130>
 802d356:	428b      	cmp	r3, r1
 802d358:	d302      	bcc.n	802d360 <__udivdi3+0xa8>
 802d35a:	4282      	cmp	r2, r0
 802d35c:	f200 80cd 	bhi.w	802d4fa <__udivdi3+0x242>
 802d360:	2001      	movs	r0, #1
 802d362:	4631      	mov	r1, r6
 802d364:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802d368:	b912      	cbnz	r2, 802d370 <__udivdi3+0xb8>
 802d36a:	2501      	movs	r5, #1
 802d36c:	fbb5 f5f2 	udiv	r5, r5, r2
 802d370:	fab5 f885 	clz	r8, r5
 802d374:	f1b8 0f00 	cmp.w	r8, #0
 802d378:	d177      	bne.n	802d46a <__udivdi3+0x1b2>
 802d37a:	1b4a      	subs	r2, r1, r5
 802d37c:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 802d380:	b2af      	uxth	r7, r5
 802d382:	2601      	movs	r6, #1
 802d384:	fbb2 f0fe 	udiv	r0, r2, lr
 802d388:	0c23      	lsrs	r3, r4, #16
 802d38a:	fb0e 2110 	mls	r1, lr, r0, r2
 802d38e:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
 802d392:	fb07 f300 	mul.w	r3, r7, r0
 802d396:	428b      	cmp	r3, r1
 802d398:	d907      	bls.n	802d3aa <__udivdi3+0xf2>
 802d39a:	1949      	adds	r1, r1, r5
 802d39c:	f100 32ff 	add.w	r2, r0, #4294967295
 802d3a0:	d202      	bcs.n	802d3a8 <__udivdi3+0xf0>
 802d3a2:	428b      	cmp	r3, r1
 802d3a4:	f200 80ba 	bhi.w	802d51c <__udivdi3+0x264>
 802d3a8:	4610      	mov	r0, r2
 802d3aa:	1ac9      	subs	r1, r1, r3
 802d3ac:	b2a4      	uxth	r4, r4
 802d3ae:	fbb1 f3fe 	udiv	r3, r1, lr
 802d3b2:	fb0e 1113 	mls	r1, lr, r3, r1
 802d3b6:	ea44 4401 	orr.w	r4, r4, r1, lsl #16
 802d3ba:	fb07 f703 	mul.w	r7, r7, r3
 802d3be:	42a7      	cmp	r7, r4
 802d3c0:	d908      	bls.n	802d3d4 <__udivdi3+0x11c>
 802d3c2:	1964      	adds	r4, r4, r5
 802d3c4:	f103 32ff 	add.w	r2, r3, #4294967295
 802d3c8:	f080 808f 	bcs.w	802d4ea <__udivdi3+0x232>
 802d3cc:	42a7      	cmp	r7, r4
 802d3ce:	f240 808c 	bls.w	802d4ea <__udivdi3+0x232>
 802d3d2:	3b02      	subs	r3, #2
 802d3d4:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 802d3d8:	4631      	mov	r1, r6
 802d3da:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802d3de:	2600      	movs	r6, #0
 802d3e0:	4630      	mov	r0, r6
 802d3e2:	4631      	mov	r1, r6
 802d3e4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802d3e8:	f1c6 0420 	rsb	r4, r6, #32
 802d3ec:	fa22 f504 	lsr.w	r5, r2, r4
 802d3f0:	40b3      	lsls	r3, r6
 802d3f2:	432b      	orrs	r3, r5
 802d3f4:	fa20 fc04 	lsr.w	ip, r0, r4
 802d3f8:	fa01 f706 	lsl.w	r7, r1, r6
 802d3fc:	fa21 f504 	lsr.w	r5, r1, r4
 802d400:	ea4f 4e13 	mov.w	lr, r3, lsr #16
 802d404:	ea4c 0707 	orr.w	r7, ip, r7
 802d408:	fbb5 f8fe 	udiv	r8, r5, lr
 802d40c:	0c39      	lsrs	r1, r7, #16
 802d40e:	fb0e 5518 	mls	r5, lr, r8, r5
 802d412:	fa1f fc83 	uxth.w	ip, r3
 802d416:	ea41 4505 	orr.w	r5, r1, r5, lsl #16
 802d41a:	fb0c f108 	mul.w	r1, ip, r8
 802d41e:	42a9      	cmp	r1, r5
 802d420:	fa02 f206 	lsl.w	r2, r2, r6
 802d424:	d904      	bls.n	802d430 <__udivdi3+0x178>
 802d426:	18ed      	adds	r5, r5, r3
 802d428:	f108 34ff 	add.w	r4, r8, #4294967295
 802d42c:	d367      	bcc.n	802d4fe <__udivdi3+0x246>
 802d42e:	46a0      	mov	r8, r4
 802d430:	1a6d      	subs	r5, r5, r1
 802d432:	b2bf      	uxth	r7, r7
 802d434:	fbb5 f4fe 	udiv	r4, r5, lr
 802d438:	fb0e 5514 	mls	r5, lr, r4, r5
 802d43c:	ea47 4105 	orr.w	r1, r7, r5, lsl #16
 802d440:	fb0c fc04 	mul.w	ip, ip, r4
 802d444:	458c      	cmp	ip, r1
 802d446:	d904      	bls.n	802d452 <__udivdi3+0x19a>
 802d448:	18c9      	adds	r1, r1, r3
 802d44a:	f104 35ff 	add.w	r5, r4, #4294967295
 802d44e:	d35c      	bcc.n	802d50a <__udivdi3+0x252>
 802d450:	462c      	mov	r4, r5
 802d452:	ea44 4408 	orr.w	r4, r4, r8, lsl #16
 802d456:	ebcc 0101 	rsb	r1, ip, r1
 802d45a:	fba4 2302 	umull	r2, r3, r4, r2
 802d45e:	4299      	cmp	r1, r3
 802d460:	d348      	bcc.n	802d4f4 <__udivdi3+0x23c>
 802d462:	d044      	beq.n	802d4ee <__udivdi3+0x236>
 802d464:	4620      	mov	r0, r4
 802d466:	2600      	movs	r6, #0
 802d468:	e76c      	b.n	802d344 <__udivdi3+0x8c>
 802d46a:	f1c8 0420 	rsb	r4, r8, #32
 802d46e:	fa01 f308 	lsl.w	r3, r1, r8
 802d472:	fa05 f508 	lsl.w	r5, r5, r8
 802d476:	fa20 f704 	lsr.w	r7, r0, r4
 802d47a:	40e1      	lsrs	r1, r4
 802d47c:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 802d480:	431f      	orrs	r7, r3
 802d482:	fbb1 f6fe 	udiv	r6, r1, lr
 802d486:	0c3a      	lsrs	r2, r7, #16
 802d488:	fb0e 1116 	mls	r1, lr, r6, r1
 802d48c:	fa1f fc85 	uxth.w	ip, r5
 802d490:	ea42 4301 	orr.w	r3, r2, r1, lsl #16
 802d494:	fb0c f206 	mul.w	r2, ip, r6
 802d498:	429a      	cmp	r2, r3
 802d49a:	fa00 f408 	lsl.w	r4, r0, r8
 802d49e:	d907      	bls.n	802d4b0 <__udivdi3+0x1f8>
 802d4a0:	195b      	adds	r3, r3, r5
 802d4a2:	f106 31ff 	add.w	r1, r6, #4294967295
 802d4a6:	d237      	bcs.n	802d518 <__udivdi3+0x260>
 802d4a8:	429a      	cmp	r2, r3
 802d4aa:	d935      	bls.n	802d518 <__udivdi3+0x260>
 802d4ac:	3e02      	subs	r6, #2
 802d4ae:	442b      	add	r3, r5
 802d4b0:	1a9b      	subs	r3, r3, r2
 802d4b2:	b2bf      	uxth	r7, r7
 802d4b4:	fbb3 f0fe 	udiv	r0, r3, lr
 802d4b8:	fb0e 3310 	mls	r3, lr, r0, r3
 802d4bc:	ea47 4303 	orr.w	r3, r7, r3, lsl #16
 802d4c0:	fb0c f100 	mul.w	r1, ip, r0
 802d4c4:	4299      	cmp	r1, r3
 802d4c6:	d907      	bls.n	802d4d8 <__udivdi3+0x220>
 802d4c8:	195b      	adds	r3, r3, r5
 802d4ca:	f100 32ff 	add.w	r2, r0, #4294967295
 802d4ce:	d221      	bcs.n	802d514 <__udivdi3+0x25c>
 802d4d0:	4299      	cmp	r1, r3
 802d4d2:	d91f      	bls.n	802d514 <__udivdi3+0x25c>
 802d4d4:	3802      	subs	r0, #2
 802d4d6:	442b      	add	r3, r5
 802d4d8:	1a5a      	subs	r2, r3, r1
 802d4da:	ea40 4606 	orr.w	r6, r0, r6, lsl #16
 802d4de:	4667      	mov	r7, ip
 802d4e0:	e750      	b.n	802d384 <__udivdi3+0xcc>
 802d4e2:	4610      	mov	r0, r2
 802d4e4:	e716      	b.n	802d314 <__udivdi3+0x5c>
 802d4e6:	460b      	mov	r3, r1
 802d4e8:	e729      	b.n	802d33e <__udivdi3+0x86>
 802d4ea:	4613      	mov	r3, r2
 802d4ec:	e772      	b.n	802d3d4 <__udivdi3+0x11c>
 802d4ee:	40b0      	lsls	r0, r6
 802d4f0:	4290      	cmp	r0, r2
 802d4f2:	d2b7      	bcs.n	802d464 <__udivdi3+0x1ac>
 802d4f4:	1e60      	subs	r0, r4, #1
 802d4f6:	2600      	movs	r6, #0
 802d4f8:	e724      	b.n	802d344 <__udivdi3+0x8c>
 802d4fa:	4630      	mov	r0, r6
 802d4fc:	e722      	b.n	802d344 <__udivdi3+0x8c>
 802d4fe:	42a9      	cmp	r1, r5
 802d500:	d995      	bls.n	802d42e <__udivdi3+0x176>
 802d502:	f1a8 0802 	sub.w	r8, r8, #2
 802d506:	441d      	add	r5, r3
 802d508:	e792      	b.n	802d430 <__udivdi3+0x178>
 802d50a:	458c      	cmp	ip, r1
 802d50c:	d9a0      	bls.n	802d450 <__udivdi3+0x198>
 802d50e:	3c02      	subs	r4, #2
 802d510:	4419      	add	r1, r3
 802d512:	e79e      	b.n	802d452 <__udivdi3+0x19a>
 802d514:	4610      	mov	r0, r2
 802d516:	e7df      	b.n	802d4d8 <__udivdi3+0x220>
 802d518:	460e      	mov	r6, r1
 802d51a:	e7c9      	b.n	802d4b0 <__udivdi3+0x1f8>
 802d51c:	3802      	subs	r0, #2
 802d51e:	4429      	add	r1, r5
 802d520:	e743      	b.n	802d3aa <__udivdi3+0xf2>
 802d522:	bf00      	nop

0802d524 <__errno>:
 802d524:	4b01      	ldr	r3, [pc, #4]	; (802d52c <__errno+0x8>)
 802d526:	6818      	ldr	r0, [r3, #0]
 802d528:	4770      	bx	lr
 802d52a:	bf00      	nop
 802d52c:	1ffe9694 	.word	0x1ffe9694

0802d530 <memcmp>:
 802d530:	b510      	push	{r4, lr}
 802d532:	440a      	add	r2, r1
 802d534:	1e44      	subs	r4, r0, #1
 802d536:	4291      	cmp	r1, r2
 802d538:	d008      	beq.n	802d54c <memcmp+0x1c>
 802d53a:	f814 3f01 	ldrb.w	r3, [r4, #1]!
 802d53e:	7808      	ldrb	r0, [r1, #0]
 802d540:	4283      	cmp	r3, r0
 802d542:	d001      	beq.n	802d548 <memcmp+0x18>
 802d544:	1a18      	subs	r0, r3, r0
 802d546:	bd10      	pop	{r4, pc}
 802d548:	3101      	adds	r1, #1
 802d54a:	e7f4      	b.n	802d536 <memcmp+0x6>
 802d54c:	2000      	movs	r0, #0
 802d54e:	bd10      	pop	{r4, pc}

0802d550 <memcpy>:
 802d550:	b510      	push	{r4, lr}
 802d552:	1e43      	subs	r3, r0, #1
 802d554:	440a      	add	r2, r1
 802d556:	4291      	cmp	r1, r2
 802d558:	d004      	beq.n	802d564 <memcpy+0x14>
 802d55a:	f811 4b01 	ldrb.w	r4, [r1], #1
 802d55e:	f803 4f01 	strb.w	r4, [r3, #1]!
 802d562:	e7f8      	b.n	802d556 <memcpy+0x6>
 802d564:	bd10      	pop	{r4, pc}

0802d566 <memset>:
 802d566:	4402      	add	r2, r0
 802d568:	4603      	mov	r3, r0
 802d56a:	4293      	cmp	r3, r2
 802d56c:	d002      	beq.n	802d574 <memset+0xe>
 802d56e:	f803 1b01 	strb.w	r1, [r3], #1
 802d572:	e7fa      	b.n	802d56a <memset+0x4>
 802d574:	4770      	bx	lr

0802d576 <__cvt>:
 802d576:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 802d57a:	b088      	sub	sp, #32
 802d57c:	2b00      	cmp	r3, #0
 802d57e:	9f14      	ldr	r7, [sp, #80]	; 0x50
 802d580:	9912      	ldr	r1, [sp, #72]	; 0x48
 802d582:	9e10      	ldr	r6, [sp, #64]	; 0x40
 802d584:	f8dd a04c 	ldr.w	sl, [sp, #76]	; 0x4c
 802d588:	461d      	mov	r5, r3
 802d58a:	bfb8      	it	lt
 802d58c:	f105 4300 	addlt.w	r3, r5, #2147483648	; 0x80000000
 802d590:	f027 0720 	bic.w	r7, r7, #32
 802d594:	bfb6      	itet	lt
 802d596:	461d      	movlt	r5, r3
 802d598:	2300      	movge	r3, #0
 802d59a:	232d      	movlt	r3, #45	; 0x2d
 802d59c:	4614      	mov	r4, r2
 802d59e:	bfb8      	it	lt
 802d5a0:	4614      	movlt	r4, r2
 802d5a2:	2f46      	cmp	r7, #70	; 0x46
 802d5a4:	700b      	strb	r3, [r1, #0]
 802d5a6:	d003      	beq.n	802d5b0 <__cvt+0x3a>
 802d5a8:	2f45      	cmp	r7, #69	; 0x45
 802d5aa:	d103      	bne.n	802d5b4 <__cvt+0x3e>
 802d5ac:	3601      	adds	r6, #1
 802d5ae:	e001      	b.n	802d5b4 <__cvt+0x3e>
 802d5b0:	2303      	movs	r3, #3
 802d5b2:	e000      	b.n	802d5b6 <__cvt+0x40>
 802d5b4:	2302      	movs	r3, #2
 802d5b6:	e88d 0448 	stmia.w	sp, {r3, r6, sl}
 802d5ba:	ab06      	add	r3, sp, #24
 802d5bc:	9303      	str	r3, [sp, #12]
 802d5be:	ab07      	add	r3, sp, #28
 802d5c0:	9304      	str	r3, [sp, #16]
 802d5c2:	4622      	mov	r2, r4
 802d5c4:	462b      	mov	r3, r5
 802d5c6:	f000 fbe3 	bl	802dd90 <_dtoa_r>
 802d5ca:	2f47      	cmp	r7, #71	; 0x47
 802d5cc:	4680      	mov	r8, r0
 802d5ce:	d102      	bne.n	802d5d6 <__cvt+0x60>
 802d5d0:	9b11      	ldr	r3, [sp, #68]	; 0x44
 802d5d2:	07db      	lsls	r3, r3, #31
 802d5d4:	d526      	bpl.n	802d624 <__cvt+0xae>
 802d5d6:	2f46      	cmp	r7, #70	; 0x46
 802d5d8:	eb08 0906 	add.w	r9, r8, r6
 802d5dc:	d111      	bne.n	802d602 <__cvt+0x8c>
 802d5de:	f898 3000 	ldrb.w	r3, [r8]
 802d5e2:	2b30      	cmp	r3, #48	; 0x30
 802d5e4:	d10a      	bne.n	802d5fc <__cvt+0x86>
 802d5e6:	4620      	mov	r0, r4
 802d5e8:	4629      	mov	r1, r5
 802d5ea:	2200      	movs	r2, #0
 802d5ec:	2300      	movs	r3, #0
 802d5ee:	f7ff fc2b 	bl	802ce48 <__aeabi_dcmpeq>
 802d5f2:	b918      	cbnz	r0, 802d5fc <__cvt+0x86>
 802d5f4:	f1c6 0601 	rsb	r6, r6, #1
 802d5f8:	f8ca 6000 	str.w	r6, [sl]
 802d5fc:	f8da 3000 	ldr.w	r3, [sl]
 802d600:	4499      	add	r9, r3
 802d602:	4620      	mov	r0, r4
 802d604:	4629      	mov	r1, r5
 802d606:	2200      	movs	r2, #0
 802d608:	2300      	movs	r3, #0
 802d60a:	f7ff fc1d 	bl	802ce48 <__aeabi_dcmpeq>
 802d60e:	b108      	cbz	r0, 802d614 <__cvt+0x9e>
 802d610:	f8cd 901c 	str.w	r9, [sp, #28]
 802d614:	9b07      	ldr	r3, [sp, #28]
 802d616:	454b      	cmp	r3, r9
 802d618:	d204      	bcs.n	802d624 <__cvt+0xae>
 802d61a:	1c5a      	adds	r2, r3, #1
 802d61c:	9207      	str	r2, [sp, #28]
 802d61e:	2230      	movs	r2, #48	; 0x30
 802d620:	701a      	strb	r2, [r3, #0]
 802d622:	e7f7      	b.n	802d614 <__cvt+0x9e>
 802d624:	9b07      	ldr	r3, [sp, #28]
 802d626:	9a15      	ldr	r2, [sp, #84]	; 0x54
 802d628:	ebc8 0303 	rsb	r3, r8, r3
 802d62c:	4640      	mov	r0, r8
 802d62e:	6013      	str	r3, [r2, #0]
 802d630:	b008      	add	sp, #32
 802d632:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0802d636 <__exponent>:
 802d636:	b573      	push	{r0, r1, r4, r5, r6, lr}
 802d638:	4603      	mov	r3, r0
 802d63a:	2900      	cmp	r1, #0
 802d63c:	bfb8      	it	lt
 802d63e:	4249      	neglt	r1, r1
 802d640:	f803 2b02 	strb.w	r2, [r3], #2
 802d644:	bfb4      	ite	lt
 802d646:	222d      	movlt	r2, #45	; 0x2d
 802d648:	222b      	movge	r2, #43	; 0x2b
 802d64a:	2909      	cmp	r1, #9
 802d64c:	7042      	strb	r2, [r0, #1]
 802d64e:	dd19      	ble.n	802d684 <__exponent+0x4e>
 802d650:	f10d 0407 	add.w	r4, sp, #7
 802d654:	4626      	mov	r6, r4
 802d656:	220a      	movs	r2, #10
 802d658:	fb91 f5f2 	sdiv	r5, r1, r2
 802d65c:	fb02 1115 	mls	r1, r2, r5, r1
 802d660:	3130      	adds	r1, #48	; 0x30
 802d662:	2d09      	cmp	r5, #9
 802d664:	f804 1d01 	strb.w	r1, [r4, #-1]!
 802d668:	4629      	mov	r1, r5
 802d66a:	dcf4      	bgt.n	802d656 <__exponent+0x20>
 802d66c:	3130      	adds	r1, #48	; 0x30
 802d66e:	1e65      	subs	r5, r4, #1
 802d670:	f804 1c01 	strb.w	r1, [r4, #-1]
 802d674:	42b5      	cmp	r5, r6
 802d676:	461a      	mov	r2, r3
 802d678:	d20a      	bcs.n	802d690 <__exponent+0x5a>
 802d67a:	f815 2b01 	ldrb.w	r2, [r5], #1
 802d67e:	f803 2b01 	strb.w	r2, [r3], #1
 802d682:	e7f7      	b.n	802d674 <__exponent+0x3e>
 802d684:	2430      	movs	r4, #48	; 0x30
 802d686:	461a      	mov	r2, r3
 802d688:	4421      	add	r1, r4
 802d68a:	f802 4b02 	strb.w	r4, [r2], #2
 802d68e:	7059      	strb	r1, [r3, #1]
 802d690:	1a10      	subs	r0, r2, r0
 802d692:	b002      	add	sp, #8
 802d694:	bd70      	pop	{r4, r5, r6, pc}
	...

0802d698 <_printf_float>:
 802d698:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802d69c:	b091      	sub	sp, #68	; 0x44
 802d69e:	468b      	mov	fp, r1
 802d6a0:	4615      	mov	r5, r2
 802d6a2:	461e      	mov	r6, r3
 802d6a4:	9f1a      	ldr	r7, [sp, #104]	; 0x68
 802d6a6:	4604      	mov	r4, r0
 802d6a8:	f001 f936 	bl	802e918 <_localeconv_r>
 802d6ac:	f8d0 a000 	ldr.w	sl, [r0]
 802d6b0:	4650      	mov	r0, sl
 802d6b2:	f000 fad5 	bl	802dc60 <strlen>
 802d6b6:	2300      	movs	r3, #0
 802d6b8:	930e      	str	r3, [sp, #56]	; 0x38
 802d6ba:	683b      	ldr	r3, [r7, #0]
 802d6bc:	9009      	str	r0, [sp, #36]	; 0x24
 802d6be:	3307      	adds	r3, #7
 802d6c0:	f023 0307 	bic.w	r3, r3, #7
 802d6c4:	e9d3 0100 	ldrd	r0, r1, [r3]
 802d6c8:	f103 0208 	add.w	r2, r3, #8
 802d6cc:	f89b 8018 	ldrb.w	r8, [fp, #24]
 802d6d0:	603a      	str	r2, [r7, #0]
 802d6d2:	e9cb 0112 	strd	r0, r1, [fp, #72]	; 0x48
 802d6d6:	f000 fa99 	bl	802dc0c <__fpclassifyd>
 802d6da:	2801      	cmp	r0, #1
 802d6dc:	e9db 0112 	ldrd	r0, r1, [fp, #72]	; 0x48
 802d6e0:	d119      	bne.n	802d716 <_printf_float+0x7e>
 802d6e2:	2200      	movs	r2, #0
 802d6e4:	2300      	movs	r3, #0
 802d6e6:	f7ff fbb9 	bl	802ce5c <__aeabi_dcmplt>
 802d6ea:	b110      	cbz	r0, 802d6f2 <_printf_float+0x5a>
 802d6ec:	232d      	movs	r3, #45	; 0x2d
 802d6ee:	f88b 3043 	strb.w	r3, [fp, #67]	; 0x43
 802d6f2:	4ba0      	ldr	r3, [pc, #640]	; (802d974 <_printf_float+0x2dc>)
 802d6f4:	4fa0      	ldr	r7, [pc, #640]	; (802d978 <_printf_float+0x2e0>)
 802d6f6:	f1b8 0f47 	cmp.w	r8, #71	; 0x47
 802d6fa:	bf88      	it	hi
 802d6fc:	461f      	movhi	r7, r3
 802d6fe:	2303      	movs	r3, #3
 802d700:	f8cb 3010 	str.w	r3, [fp, #16]
 802d704:	f8db 3000 	ldr.w	r3, [fp]
 802d708:	f023 0304 	bic.w	r3, r3, #4
 802d70c:	f8cb 3000 	str.w	r3, [fp]
 802d710:	f04f 0900 	mov.w	r9, #0
 802d714:	e0a1      	b.n	802d85a <_printf_float+0x1c2>
 802d716:	f000 fa79 	bl	802dc0c <__fpclassifyd>
 802d71a:	f8db 3000 	ldr.w	r3, [fp]
 802d71e:	b948      	cbnz	r0, 802d734 <_printf_float+0x9c>
 802d720:	4a96      	ldr	r2, [pc, #600]	; (802d97c <_printf_float+0x2e4>)
 802d722:	4f97      	ldr	r7, [pc, #604]	; (802d980 <_printf_float+0x2e8>)
 802d724:	f1b8 0f47 	cmp.w	r8, #71	; 0x47
 802d728:	bf88      	it	hi
 802d72a:	4617      	movhi	r7, r2
 802d72c:	2203      	movs	r2, #3
 802d72e:	f8cb 2010 	str.w	r2, [fp, #16]
 802d732:	e7e9      	b.n	802d708 <_printf_float+0x70>
 802d734:	f8db 2004 	ldr.w	r2, [fp, #4]
 802d738:	ed9b 7b12 	vldr	d7, [fp, #72]	; 0x48
 802d73c:	1c57      	adds	r7, r2, #1
 802d73e:	ed8d 7b0a 	vstr	d7, [sp, #40]	; 0x28
 802d742:	d101      	bne.n	802d748 <_printf_float+0xb0>
 802d744:	2206      	movs	r2, #6
 802d746:	e009      	b.n	802d75c <_printf_float+0xc4>
 802d748:	f1b8 0f67 	cmp.w	r8, #103	; 0x67
 802d74c:	d002      	beq.n	802d754 <_printf_float+0xbc>
 802d74e:	f1b8 0f47 	cmp.w	r8, #71	; 0x47
 802d752:	d105      	bne.n	802d760 <_printf_float+0xc8>
 802d754:	2a00      	cmp	r2, #0
 802d756:	f040 81c7 	bne.w	802dae8 <_printf_float+0x450>
 802d75a:	2201      	movs	r2, #1
 802d75c:	f8cb 2004 	str.w	r2, [fp, #4]
 802d760:	f8db 2004 	ldr.w	r2, [fp, #4]
 802d764:	f8cd 8010 	str.w	r8, [sp, #16]
 802d768:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 802d76c:	e88d 000c 	stmia.w	sp, {r2, r3}
 802d770:	f8cb 3000 	str.w	r3, [fp]
 802d774:	f10d 0333 	add.w	r3, sp, #51	; 0x33
 802d778:	9302      	str	r3, [sp, #8]
 802d77a:	ab0d      	add	r3, sp, #52	; 0x34
 802d77c:	9303      	str	r3, [sp, #12]
 802d77e:	ab0e      	add	r3, sp, #56	; 0x38
 802d780:	9305      	str	r3, [sp, #20]
 802d782:	2300      	movs	r3, #0
 802d784:	9306      	str	r3, [sp, #24]
 802d786:	4620      	mov	r0, r4
 802d788:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
 802d78c:	f7ff fef3 	bl	802d576 <__cvt>
 802d790:	f008 03df 	and.w	r3, r8, #223	; 0xdf
 802d794:	2b47      	cmp	r3, #71	; 0x47
 802d796:	4607      	mov	r7, r0
 802d798:	d10a      	bne.n	802d7b0 <_printf_float+0x118>
 802d79a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 802d79c:	1cd8      	adds	r0, r3, #3
 802d79e:	db03      	blt.n	802d7a8 <_printf_float+0x110>
 802d7a0:	f8db 2004 	ldr.w	r2, [fp, #4]
 802d7a4:	4293      	cmp	r3, r2
 802d7a6:	dd37      	ble.n	802d818 <_printf_float+0x180>
 802d7a8:	f1a8 0802 	sub.w	r8, r8, #2
 802d7ac:	fa5f f888 	uxtb.w	r8, r8
 802d7b0:	f1b8 0f65 	cmp.w	r8, #101	; 0x65
 802d7b4:	990d      	ldr	r1, [sp, #52]	; 0x34
 802d7b6:	d815      	bhi.n	802d7e4 <_printf_float+0x14c>
 802d7b8:	3901      	subs	r1, #1
 802d7ba:	4642      	mov	r2, r8
 802d7bc:	f10b 0050 	add.w	r0, fp, #80	; 0x50
 802d7c0:	910d      	str	r1, [sp, #52]	; 0x34
 802d7c2:	f7ff ff38 	bl	802d636 <__exponent>
 802d7c6:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 802d7c8:	1883      	adds	r3, r0, r2
 802d7ca:	2a01      	cmp	r2, #1
 802d7cc:	4681      	mov	r9, r0
 802d7ce:	f8cb 3010 	str.w	r3, [fp, #16]
 802d7d2:	dc03      	bgt.n	802d7dc <_printf_float+0x144>
 802d7d4:	f8db 2000 	ldr.w	r2, [fp]
 802d7d8:	07d1      	lsls	r1, r2, #31
 802d7da:	d538      	bpl.n	802d84e <_printf_float+0x1b6>
 802d7dc:	3301      	adds	r3, #1
 802d7de:	f8cb 3010 	str.w	r3, [fp, #16]
 802d7e2:	e034      	b.n	802d84e <_printf_float+0x1b6>
 802d7e4:	f1b8 0f66 	cmp.w	r8, #102	; 0x66
 802d7e8:	d118      	bne.n	802d81c <_printf_float+0x184>
 802d7ea:	2900      	cmp	r1, #0
 802d7ec:	f8db 3004 	ldr.w	r3, [fp, #4]
 802d7f0:	dd09      	ble.n	802d806 <_printf_float+0x16e>
 802d7f2:	f8cb 1010 	str.w	r1, [fp, #16]
 802d7f6:	b91b      	cbnz	r3, 802d800 <_printf_float+0x168>
 802d7f8:	f8db 2000 	ldr.w	r2, [fp]
 802d7fc:	07d2      	lsls	r2, r2, #31
 802d7fe:	d521      	bpl.n	802d844 <_printf_float+0x1ac>
 802d800:	3301      	adds	r3, #1
 802d802:	440b      	add	r3, r1
 802d804:	e01c      	b.n	802d840 <_printf_float+0x1a8>
 802d806:	b91b      	cbnz	r3, 802d810 <_printf_float+0x178>
 802d808:	f8db 2000 	ldr.w	r2, [fp]
 802d80c:	07d0      	lsls	r0, r2, #31
 802d80e:	d501      	bpl.n	802d814 <_printf_float+0x17c>
 802d810:	3302      	adds	r3, #2
 802d812:	e015      	b.n	802d840 <_printf_float+0x1a8>
 802d814:	2301      	movs	r3, #1
 802d816:	e013      	b.n	802d840 <_printf_float+0x1a8>
 802d818:	f04f 0867 	mov.w	r8, #103	; 0x67
 802d81c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 802d81e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 802d820:	4293      	cmp	r3, r2
 802d822:	db07      	blt.n	802d834 <_printf_float+0x19c>
 802d824:	f8db 2000 	ldr.w	r2, [fp]
 802d828:	f8cb 3010 	str.w	r3, [fp, #16]
 802d82c:	07d1      	lsls	r1, r2, #31
 802d82e:	d509      	bpl.n	802d844 <_printf_float+0x1ac>
 802d830:	3301      	adds	r3, #1
 802d832:	e005      	b.n	802d840 <_printf_float+0x1a8>
 802d834:	2b00      	cmp	r3, #0
 802d836:	bfd4      	ite	le
 802d838:	f1c3 0302 	rsble	r3, r3, #2
 802d83c:	2301      	movgt	r3, #1
 802d83e:	4413      	add	r3, r2
 802d840:	f8cb 3010 	str.w	r3, [fp, #16]
 802d844:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 802d846:	f8cb 3058 	str.w	r3, [fp, #88]	; 0x58
 802d84a:	f04f 0900 	mov.w	r9, #0
 802d84e:	f89d 3033 	ldrb.w	r3, [sp, #51]	; 0x33
 802d852:	b113      	cbz	r3, 802d85a <_printf_float+0x1c2>
 802d854:	232d      	movs	r3, #45	; 0x2d
 802d856:	f88b 3043 	strb.w	r3, [fp, #67]	; 0x43
 802d85a:	9600      	str	r6, [sp, #0]
 802d85c:	4620      	mov	r0, r4
 802d85e:	4659      	mov	r1, fp
 802d860:	aa0f      	add	r2, sp, #60	; 0x3c
 802d862:	462b      	mov	r3, r5
 802d864:	f000 f95c 	bl	802db20 <_printf_common>
 802d868:	3001      	adds	r0, #1
 802d86a:	d102      	bne.n	802d872 <_printf_float+0x1da>
 802d86c:	f04f 30ff 	mov.w	r0, #4294967295
 802d870:	e152      	b.n	802db18 <_printf_float+0x480>
 802d872:	f8db 3000 	ldr.w	r3, [fp]
 802d876:	055a      	lsls	r2, r3, #21
 802d878:	d405      	bmi.n	802d886 <_printf_float+0x1ee>
 802d87a:	4620      	mov	r0, r4
 802d87c:	4629      	mov	r1, r5
 802d87e:	463a      	mov	r2, r7
 802d880:	f8db 3010 	ldr.w	r3, [fp, #16]
 802d884:	e108      	b.n	802da98 <_printf_float+0x400>
 802d886:	f1b8 0f65 	cmp.w	r8, #101	; 0x65
 802d88a:	f240 80d0 	bls.w	802da2e <_printf_float+0x396>
 802d88e:	e9db 0112 	ldrd	r0, r1, [fp, #72]	; 0x48
 802d892:	2200      	movs	r2, #0
 802d894:	2300      	movs	r3, #0
 802d896:	f7ff fad7 	bl	802ce48 <__aeabi_dcmpeq>
 802d89a:	b350      	cbz	r0, 802d8f2 <_printf_float+0x25a>
 802d89c:	4620      	mov	r0, r4
 802d89e:	4629      	mov	r1, r5
 802d8a0:	4a38      	ldr	r2, [pc, #224]	; (802d984 <_printf_float+0x2ec>)
 802d8a2:	2301      	movs	r3, #1
 802d8a4:	47b0      	blx	r6
 802d8a6:	3001      	adds	r0, #1
 802d8a8:	d0e0      	beq.n	802d86c <_printf_float+0x1d4>
 802d8aa:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 802d8ac:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 802d8ae:	429a      	cmp	r2, r3
 802d8b0:	db09      	blt.n	802d8c6 <_printf_float+0x22e>
 802d8b2:	f8db 3000 	ldr.w	r3, [fp]
 802d8b6:	07d8      	lsls	r0, r3, #31
 802d8b8:	d405      	bmi.n	802d8c6 <_printf_float+0x22e>
 802d8ba:	f8db 3000 	ldr.w	r3, [fp]
 802d8be:	079f      	lsls	r7, r3, #30
 802d8c0:	f100 8110 	bmi.w	802dae4 <_printf_float+0x44c>
 802d8c4:	e107      	b.n	802dad6 <_printf_float+0x43e>
 802d8c6:	4620      	mov	r0, r4
 802d8c8:	4629      	mov	r1, r5
 802d8ca:	4652      	mov	r2, sl
 802d8cc:	9b09      	ldr	r3, [sp, #36]	; 0x24
 802d8ce:	47b0      	blx	r6
 802d8d0:	3001      	adds	r0, #1
 802d8d2:	d0cb      	beq.n	802d86c <_printf_float+0x1d4>
 802d8d4:	2700      	movs	r7, #0
 802d8d6:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 802d8d8:	3b01      	subs	r3, #1
 802d8da:	429f      	cmp	r7, r3
 802d8dc:	daed      	bge.n	802d8ba <_printf_float+0x222>
 802d8de:	4620      	mov	r0, r4
 802d8e0:	4629      	mov	r1, r5
 802d8e2:	f10b 021a 	add.w	r2, fp, #26
 802d8e6:	2301      	movs	r3, #1
 802d8e8:	47b0      	blx	r6
 802d8ea:	3001      	adds	r0, #1
 802d8ec:	d0be      	beq.n	802d86c <_printf_float+0x1d4>
 802d8ee:	3701      	adds	r7, #1
 802d8f0:	e7f1      	b.n	802d8d6 <_printf_float+0x23e>
 802d8f2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 802d8f4:	2b00      	cmp	r3, #0
 802d8f6:	dc29      	bgt.n	802d94c <_printf_float+0x2b4>
 802d8f8:	4620      	mov	r0, r4
 802d8fa:	4629      	mov	r1, r5
 802d8fc:	4a21      	ldr	r2, [pc, #132]	; (802d984 <_printf_float+0x2ec>)
 802d8fe:	2301      	movs	r3, #1
 802d900:	47b0      	blx	r6
 802d902:	3001      	adds	r0, #1
 802d904:	d0b2      	beq.n	802d86c <_printf_float+0x1d4>
 802d906:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 802d908:	b92b      	cbnz	r3, 802d916 <_printf_float+0x27e>
 802d90a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 802d90c:	b91b      	cbnz	r3, 802d916 <_printf_float+0x27e>
 802d90e:	f8db 3000 	ldr.w	r3, [fp]
 802d912:	07d9      	lsls	r1, r3, #31
 802d914:	d5d1      	bpl.n	802d8ba <_printf_float+0x222>
 802d916:	4620      	mov	r0, r4
 802d918:	4629      	mov	r1, r5
 802d91a:	4652      	mov	r2, sl
 802d91c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 802d91e:	47b0      	blx	r6
 802d920:	3001      	adds	r0, #1
 802d922:	d0a3      	beq.n	802d86c <_printf_float+0x1d4>
 802d924:	f04f 0800 	mov.w	r8, #0
 802d928:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 802d92a:	425b      	negs	r3, r3
 802d92c:	4598      	cmp	r8, r3
 802d92e:	4620      	mov	r0, r4
 802d930:	4629      	mov	r1, r5
 802d932:	da08      	bge.n	802d946 <_printf_float+0x2ae>
 802d934:	f10b 021a 	add.w	r2, fp, #26
 802d938:	2301      	movs	r3, #1
 802d93a:	47b0      	blx	r6
 802d93c:	3001      	adds	r0, #1
 802d93e:	d095      	beq.n	802d86c <_printf_float+0x1d4>
 802d940:	f108 0801 	add.w	r8, r8, #1
 802d944:	e7f0      	b.n	802d928 <_printf_float+0x290>
 802d946:	463a      	mov	r2, r7
 802d948:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 802d94a:	e0a5      	b.n	802da98 <_printf_float+0x400>
 802d94c:	f8db 2058 	ldr.w	r2, [fp, #88]	; 0x58
 802d950:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 802d952:	429a      	cmp	r2, r3
 802d954:	bfa8      	it	ge
 802d956:	461a      	movge	r2, r3
 802d958:	2a00      	cmp	r2, #0
 802d95a:	4691      	mov	r9, r2
 802d95c:	dc02      	bgt.n	802d964 <_printf_float+0x2cc>
 802d95e:	f04f 0800 	mov.w	r8, #0
 802d962:	e01c      	b.n	802d99e <_printf_float+0x306>
 802d964:	4620      	mov	r0, r4
 802d966:	4629      	mov	r1, r5
 802d968:	463a      	mov	r2, r7
 802d96a:	464b      	mov	r3, r9
 802d96c:	47b0      	blx	r6
 802d96e:	3001      	adds	r0, #1
 802d970:	d1f5      	bne.n	802d95e <_printf_float+0x2c6>
 802d972:	e77b      	b.n	802d86c <_printf_float+0x1d4>
 802d974:	08031a36 	.word	0x08031a36
 802d978:	08031a32 	.word	0x08031a32
 802d97c:	08031a3e 	.word	0x08031a3e
 802d980:	08031a3a 	.word	0x08031a3a
 802d984:	08031a42 	.word	0x08031a42
 802d988:	4620      	mov	r0, r4
 802d98a:	4629      	mov	r1, r5
 802d98c:	f10b 021a 	add.w	r2, fp, #26
 802d990:	2301      	movs	r3, #1
 802d992:	47b0      	blx	r6
 802d994:	3001      	adds	r0, #1
 802d996:	f43f af69 	beq.w	802d86c <_printf_float+0x1d4>
 802d99a:	f108 0801 	add.w	r8, r8, #1
 802d99e:	f8db 3058 	ldr.w	r3, [fp, #88]	; 0x58
 802d9a2:	f1b9 0f00 	cmp.w	r9, #0
 802d9a6:	bfac      	ite	ge
 802d9a8:	ebc9 0203 	rsbge	r2, r9, r3
 802d9ac:	461a      	movlt	r2, r3
 802d9ae:	4590      	cmp	r8, r2
 802d9b0:	dbea      	blt.n	802d988 <_printf_float+0x2f0>
 802d9b2:	eb07 0803 	add.w	r8, r7, r3
 802d9b6:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 802d9b8:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 802d9ba:	429a      	cmp	r2, r3
 802d9bc:	db10      	blt.n	802d9e0 <_printf_float+0x348>
 802d9be:	f8db 3000 	ldr.w	r3, [fp]
 802d9c2:	07da      	lsls	r2, r3, #31
 802d9c4:	d40c      	bmi.n	802d9e0 <_printf_float+0x348>
 802d9c6:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 802d9c8:	4417      	add	r7, r2
 802d9ca:	ebc8 0307 	rsb	r3, r8, r7
 802d9ce:	9f0d      	ldr	r7, [sp, #52]	; 0x34
 802d9d0:	1bd2      	subs	r2, r2, r7
 802d9d2:	4293      	cmp	r3, r2
 802d9d4:	bfa8      	it	ge
 802d9d6:	4613      	movge	r3, r2
 802d9d8:	2b00      	cmp	r3, #0
 802d9da:	461f      	mov	r7, r3
 802d9dc:	dc08      	bgt.n	802d9f0 <_printf_float+0x358>
 802d9de:	e00e      	b.n	802d9fe <_printf_float+0x366>
 802d9e0:	4620      	mov	r0, r4
 802d9e2:	4629      	mov	r1, r5
 802d9e4:	4652      	mov	r2, sl
 802d9e6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 802d9e8:	47b0      	blx	r6
 802d9ea:	3001      	adds	r0, #1
 802d9ec:	d1eb      	bne.n	802d9c6 <_printf_float+0x32e>
 802d9ee:	e73d      	b.n	802d86c <_printf_float+0x1d4>
 802d9f0:	4620      	mov	r0, r4
 802d9f2:	4629      	mov	r1, r5
 802d9f4:	4642      	mov	r2, r8
 802d9f6:	47b0      	blx	r6
 802d9f8:	3001      	adds	r0, #1
 802d9fa:	f43f af37 	beq.w	802d86c <_printf_float+0x1d4>
 802d9fe:	f04f 0800 	mov.w	r8, #0
 802da02:	e00a      	b.n	802da1a <_printf_float+0x382>
 802da04:	4620      	mov	r0, r4
 802da06:	4629      	mov	r1, r5
 802da08:	f10b 021a 	add.w	r2, fp, #26
 802da0c:	2301      	movs	r3, #1
 802da0e:	47b0      	blx	r6
 802da10:	3001      	adds	r0, #1
 802da12:	f43f af2b 	beq.w	802d86c <_printf_float+0x1d4>
 802da16:	f108 0801 	add.w	r8, r8, #1
 802da1a:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 802da1c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 802da1e:	2f00      	cmp	r7, #0
 802da20:	eba3 0302 	sub.w	r3, r3, r2
 802da24:	bfa8      	it	ge
 802da26:	1bdb      	subge	r3, r3, r7
 802da28:	4598      	cmp	r8, r3
 802da2a:	dbeb      	blt.n	802da04 <_printf_float+0x36c>
 802da2c:	e745      	b.n	802d8ba <_printf_float+0x222>
 802da2e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 802da30:	2a01      	cmp	r2, #1
 802da32:	dc01      	bgt.n	802da38 <_printf_float+0x3a0>
 802da34:	07db      	lsls	r3, r3, #31
 802da36:	d536      	bpl.n	802daa6 <_printf_float+0x40e>
 802da38:	4620      	mov	r0, r4
 802da3a:	4629      	mov	r1, r5
 802da3c:	463a      	mov	r2, r7
 802da3e:	2301      	movs	r3, #1
 802da40:	47b0      	blx	r6
 802da42:	3001      	adds	r0, #1
 802da44:	f43f af12 	beq.w	802d86c <_printf_float+0x1d4>
 802da48:	4620      	mov	r0, r4
 802da4a:	4629      	mov	r1, r5
 802da4c:	4652      	mov	r2, sl
 802da4e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 802da50:	47b0      	blx	r6
 802da52:	3001      	adds	r0, #1
 802da54:	f43f af0a 	beq.w	802d86c <_printf_float+0x1d4>
 802da58:	e9db 0112 	ldrd	r0, r1, [fp, #72]	; 0x48
 802da5c:	2200      	movs	r2, #0
 802da5e:	2300      	movs	r3, #0
 802da60:	f7ff f9f2 	bl	802ce48 <__aeabi_dcmpeq>
 802da64:	b9e8      	cbnz	r0, 802daa2 <_printf_float+0x40a>
 802da66:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 802da68:	4620      	mov	r0, r4
 802da6a:	4629      	mov	r1, r5
 802da6c:	1c7a      	adds	r2, r7, #1
 802da6e:	3b01      	subs	r3, #1
 802da70:	e01d      	b.n	802daae <_printf_float+0x416>
 802da72:	4620      	mov	r0, r4
 802da74:	4629      	mov	r1, r5
 802da76:	f10b 021a 	add.w	r2, fp, #26
 802da7a:	2301      	movs	r3, #1
 802da7c:	47b0      	blx	r6
 802da7e:	3001      	adds	r0, #1
 802da80:	f43f aef4 	beq.w	802d86c <_printf_float+0x1d4>
 802da84:	3701      	adds	r7, #1
 802da86:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 802da88:	3b01      	subs	r3, #1
 802da8a:	429f      	cmp	r7, r3
 802da8c:	dbf1      	blt.n	802da72 <_printf_float+0x3da>
 802da8e:	4620      	mov	r0, r4
 802da90:	4629      	mov	r1, r5
 802da92:	f10b 0250 	add.w	r2, fp, #80	; 0x50
 802da96:	464b      	mov	r3, r9
 802da98:	47b0      	blx	r6
 802da9a:	3001      	adds	r0, #1
 802da9c:	f47f af0d 	bne.w	802d8ba <_printf_float+0x222>
 802daa0:	e6e4      	b.n	802d86c <_printf_float+0x1d4>
 802daa2:	2700      	movs	r7, #0
 802daa4:	e7ef      	b.n	802da86 <_printf_float+0x3ee>
 802daa6:	4620      	mov	r0, r4
 802daa8:	4629      	mov	r1, r5
 802daaa:	463a      	mov	r2, r7
 802daac:	2301      	movs	r3, #1
 802daae:	47b0      	blx	r6
 802dab0:	3001      	adds	r0, #1
 802dab2:	d1ec      	bne.n	802da8e <_printf_float+0x3f6>
 802dab4:	e6da      	b.n	802d86c <_printf_float+0x1d4>
 802dab6:	4620      	mov	r0, r4
 802dab8:	4629      	mov	r1, r5
 802daba:	f10b 0219 	add.w	r2, fp, #25
 802dabe:	2301      	movs	r3, #1
 802dac0:	47b0      	blx	r6
 802dac2:	3001      	adds	r0, #1
 802dac4:	f43f aed2 	beq.w	802d86c <_printf_float+0x1d4>
 802dac8:	3701      	adds	r7, #1
 802daca:	f8db 300c 	ldr.w	r3, [fp, #12]
 802dace:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 802dad0:	1a9b      	subs	r3, r3, r2
 802dad2:	429f      	cmp	r7, r3
 802dad4:	dbef      	blt.n	802dab6 <_printf_float+0x41e>
 802dad6:	f8db 000c 	ldr.w	r0, [fp, #12]
 802dada:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 802dadc:	4298      	cmp	r0, r3
 802dade:	bfb8      	it	lt
 802dae0:	4618      	movlt	r0, r3
 802dae2:	e019      	b.n	802db18 <_printf_float+0x480>
 802dae4:	2700      	movs	r7, #0
 802dae6:	e7f0      	b.n	802daca <_printf_float+0x432>
 802dae8:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 802daec:	e88d 000c 	stmia.w	sp, {r2, r3}
 802daf0:	f8cb 3000 	str.w	r3, [fp]
 802daf4:	f10d 0333 	add.w	r3, sp, #51	; 0x33
 802daf8:	9302      	str	r3, [sp, #8]
 802dafa:	ab0d      	add	r3, sp, #52	; 0x34
 802dafc:	9303      	str	r3, [sp, #12]
 802dafe:	ab0e      	add	r3, sp, #56	; 0x38
 802db00:	9305      	str	r3, [sp, #20]
 802db02:	2300      	movs	r3, #0
 802db04:	9306      	str	r3, [sp, #24]
 802db06:	f8cd 8010 	str.w	r8, [sp, #16]
 802db0a:	4620      	mov	r0, r4
 802db0c:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
 802db10:	f7ff fd31 	bl	802d576 <__cvt>
 802db14:	4607      	mov	r7, r0
 802db16:	e640      	b.n	802d79a <_printf_float+0x102>
 802db18:	b011      	add	sp, #68	; 0x44
 802db1a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802db1e:	bf00      	nop

0802db20 <_printf_common>:
 802db20:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 802db24:	4691      	mov	r9, r2
 802db26:	461f      	mov	r7, r3
 802db28:	688a      	ldr	r2, [r1, #8]
 802db2a:	690b      	ldr	r3, [r1, #16]
 802db2c:	f8dd 8020 	ldr.w	r8, [sp, #32]
 802db30:	4293      	cmp	r3, r2
 802db32:	bfb8      	it	lt
 802db34:	4613      	movlt	r3, r2
 802db36:	f8c9 3000 	str.w	r3, [r9]
 802db3a:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
 802db3e:	4606      	mov	r6, r0
 802db40:	460c      	mov	r4, r1
 802db42:	b112      	cbz	r2, 802db4a <_printf_common+0x2a>
 802db44:	3301      	adds	r3, #1
 802db46:	f8c9 3000 	str.w	r3, [r9]
 802db4a:	6823      	ldr	r3, [r4, #0]
 802db4c:	0699      	lsls	r1, r3, #26
 802db4e:	bf42      	ittt	mi
 802db50:	f8d9 3000 	ldrmi.w	r3, [r9]
 802db54:	3302      	addmi	r3, #2
 802db56:	f8c9 3000 	strmi.w	r3, [r9]
 802db5a:	6825      	ldr	r5, [r4, #0]
 802db5c:	f015 0506 	ands.w	r5, r5, #6
 802db60:	d01c      	beq.n	802db9c <_printf_common+0x7c>
 802db62:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
 802db66:	6822      	ldr	r2, [r4, #0]
 802db68:	3300      	adds	r3, #0
 802db6a:	bf18      	it	ne
 802db6c:	2301      	movne	r3, #1
 802db6e:	0692      	lsls	r2, r2, #26
 802db70:	d51f      	bpl.n	802dbb2 <_printf_common+0x92>
 802db72:	18e1      	adds	r1, r4, r3
 802db74:	1c5a      	adds	r2, r3, #1
 802db76:	2030      	movs	r0, #48	; 0x30
 802db78:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
 802db7c:	4422      	add	r2, r4
 802db7e:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
 802db82:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
 802db86:	3302      	adds	r3, #2
 802db88:	e013      	b.n	802dbb2 <_printf_common+0x92>
 802db8a:	4630      	mov	r0, r6
 802db8c:	4639      	mov	r1, r7
 802db8e:	f104 0219 	add.w	r2, r4, #25
 802db92:	2301      	movs	r3, #1
 802db94:	47c0      	blx	r8
 802db96:	3001      	adds	r0, #1
 802db98:	d007      	beq.n	802dbaa <_printf_common+0x8a>
 802db9a:	3501      	adds	r5, #1
 802db9c:	68e3      	ldr	r3, [r4, #12]
 802db9e:	f8d9 2000 	ldr.w	r2, [r9]
 802dba2:	1a9b      	subs	r3, r3, r2
 802dba4:	429d      	cmp	r5, r3
 802dba6:	dbf0      	blt.n	802db8a <_printf_common+0x6a>
 802dba8:	e7db      	b.n	802db62 <_printf_common+0x42>
 802dbaa:	f04f 30ff 	mov.w	r0, #4294967295
 802dbae:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 802dbb2:	4630      	mov	r0, r6
 802dbb4:	4639      	mov	r1, r7
 802dbb6:	f104 0243 	add.w	r2, r4, #67	; 0x43
 802dbba:	47c0      	blx	r8
 802dbbc:	3001      	adds	r0, #1
 802dbbe:	d0f4      	beq.n	802dbaa <_printf_common+0x8a>
 802dbc0:	6822      	ldr	r2, [r4, #0]
 802dbc2:	f8d9 5000 	ldr.w	r5, [r9]
 802dbc6:	68e3      	ldr	r3, [r4, #12]
 802dbc8:	f002 0206 	and.w	r2, r2, #6
 802dbcc:	2a04      	cmp	r2, #4
 802dbce:	bf08      	it	eq
 802dbd0:	1b5d      	subeq	r5, r3, r5
 802dbd2:	6922      	ldr	r2, [r4, #16]
 802dbd4:	68a3      	ldr	r3, [r4, #8]
 802dbd6:	bf0c      	ite	eq
 802dbd8:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 802dbdc:	2500      	movne	r5, #0
 802dbde:	4293      	cmp	r3, r2
 802dbe0:	bfc4      	itt	gt
 802dbe2:	1a9b      	subgt	r3, r3, r2
 802dbe4:	18ed      	addgt	r5, r5, r3
 802dbe6:	f04f 0900 	mov.w	r9, #0
 802dbea:	45a9      	cmp	r9, r5
 802dbec:	da0a      	bge.n	802dc04 <_printf_common+0xe4>
 802dbee:	4630      	mov	r0, r6
 802dbf0:	4639      	mov	r1, r7
 802dbf2:	f104 021a 	add.w	r2, r4, #26
 802dbf6:	2301      	movs	r3, #1
 802dbf8:	47c0      	blx	r8
 802dbfa:	3001      	adds	r0, #1
 802dbfc:	d0d5      	beq.n	802dbaa <_printf_common+0x8a>
 802dbfe:	f109 0901 	add.w	r9, r9, #1
 802dc02:	e7f2      	b.n	802dbea <_printf_common+0xca>
 802dc04:	2000      	movs	r0, #0
 802dc06:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	...

0802dc0c <__fpclassifyd>:
 802dc0c:	460a      	mov	r2, r1
 802dc0e:	f031 4100 	bics.w	r1, r1, #2147483648	; 0x80000000
 802dc12:	b510      	push	{r4, lr}
 802dc14:	4603      	mov	r3, r0
 802dc16:	d01b      	beq.n	802dc50 <__fpclassifyd+0x44>
 802dc18:	480f      	ldr	r0, [pc, #60]	; (802dc58 <__fpclassifyd+0x4c>)
 802dc1a:	f5a2 1480 	sub.w	r4, r2, #1048576	; 0x100000
 802dc1e:	4284      	cmp	r4, r0
 802dc20:	d910      	bls.n	802dc44 <__fpclassifyd+0x38>
 802dc22:	f102 42ff 	add.w	r2, r2, #2139095040	; 0x7f800000
 802dc26:	480c      	ldr	r0, [pc, #48]	; (802dc58 <__fpclassifyd+0x4c>)
 802dc28:	f502 02e0 	add.w	r2, r2, #7340032	; 0x700000
 802dc2c:	4282      	cmp	r2, r0
 802dc2e:	d909      	bls.n	802dc44 <__fpclassifyd+0x38>
 802dc30:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 802dc34:	d308      	bcc.n	802dc48 <__fpclassifyd+0x3c>
 802dc36:	4a09      	ldr	r2, [pc, #36]	; (802dc5c <__fpclassifyd+0x50>)
 802dc38:	4291      	cmp	r1, r2
 802dc3a:	d107      	bne.n	802dc4c <__fpclassifyd+0x40>
 802dc3c:	fab3 f083 	clz	r0, r3
 802dc40:	0940      	lsrs	r0, r0, #5
 802dc42:	bd10      	pop	{r4, pc}
 802dc44:	2004      	movs	r0, #4
 802dc46:	bd10      	pop	{r4, pc}
 802dc48:	2003      	movs	r0, #3
 802dc4a:	bd10      	pop	{r4, pc}
 802dc4c:	2000      	movs	r0, #0
 802dc4e:	bd10      	pop	{r4, pc}
 802dc50:	2800      	cmp	r0, #0
 802dc52:	d1e6      	bne.n	802dc22 <__fpclassifyd+0x16>
 802dc54:	2002      	movs	r0, #2
 802dc56:	bd10      	pop	{r4, pc}
 802dc58:	7fdfffff 	.word	0x7fdfffff
 802dc5c:	7ff00000 	.word	0x7ff00000

0802dc60 <strlen>:
 802dc60:	4603      	mov	r3, r0
 802dc62:	f813 2b01 	ldrb.w	r2, [r3], #1
 802dc66:	2a00      	cmp	r2, #0
 802dc68:	d1fb      	bne.n	802dc62 <strlen+0x2>
 802dc6a:	1a18      	subs	r0, r3, r0
 802dc6c:	3801      	subs	r0, #1
 802dc6e:	4770      	bx	lr

0802dc70 <quorem>:
 802dc70:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802dc74:	6903      	ldr	r3, [r0, #16]
 802dc76:	690c      	ldr	r4, [r1, #16]
 802dc78:	42a3      	cmp	r3, r4
 802dc7a:	4680      	mov	r8, r0
 802dc7c:	f2c0 8081 	blt.w	802dd82 <quorem+0x112>
 802dc80:	3c01      	subs	r4, #1
 802dc82:	f101 0714 	add.w	r7, r1, #20
 802dc86:	ea4f 0e84 	mov.w	lr, r4, lsl #2
 802dc8a:	f100 0614 	add.w	r6, r0, #20
 802dc8e:	f857 5024 	ldr.w	r5, [r7, r4, lsl #2]
 802dc92:	eb06 030e 	add.w	r3, r6, lr
 802dc96:	9301      	str	r3, [sp, #4]
 802dc98:	3501      	adds	r5, #1
 802dc9a:	f856 3024 	ldr.w	r3, [r6, r4, lsl #2]
 802dc9e:	fbb3 f5f5 	udiv	r5, r3, r5
 802dca2:	eb07 090e 	add.w	r9, r7, lr
 802dca6:	b3c5      	cbz	r5, 802dd1a <quorem+0xaa>
 802dca8:	f04f 0a00 	mov.w	sl, #0
 802dcac:	4638      	mov	r0, r7
 802dcae:	46b4      	mov	ip, r6
 802dcb0:	46d3      	mov	fp, sl
 802dcb2:	f850 3b04 	ldr.w	r3, [r0], #4
 802dcb6:	b29a      	uxth	r2, r3
 802dcb8:	0c1b      	lsrs	r3, r3, #16
 802dcba:	fb02 a205 	mla	r2, r2, r5, sl
 802dcbe:	436b      	muls	r3, r5
 802dcc0:	eb03 4312 	add.w	r3, r3, r2, lsr #16
 802dcc4:	b292      	uxth	r2, r2
 802dcc6:	ebc2 020b 	rsb	r2, r2, fp
 802dcca:	f8bc b000 	ldrh.w	fp, [ip]
 802dcce:	ea4f 4a13 	mov.w	sl, r3, lsr #16
 802dcd2:	fa12 f28b 	uxtah	r2, r2, fp
 802dcd6:	fa1f fb83 	uxth.w	fp, r3
 802dcda:	f8dc 3000 	ldr.w	r3, [ip]
 802dcde:	ebcb 4313 	rsb	r3, fp, r3, lsr #16
 802dce2:	eb03 4322 	add.w	r3, r3, r2, asr #16
 802dce6:	b292      	uxth	r2, r2
 802dce8:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
 802dcec:	4548      	cmp	r0, r9
 802dcee:	ea4f 4b23 	mov.w	fp, r3, asr #16
 802dcf2:	f84c 2b04 	str.w	r2, [ip], #4
 802dcf6:	d9dc      	bls.n	802dcb2 <quorem+0x42>
 802dcf8:	f856 300e 	ldr.w	r3, [r6, lr]
 802dcfc:	b96b      	cbnz	r3, 802dd1a <quorem+0xaa>
 802dcfe:	9b01      	ldr	r3, [sp, #4]
 802dd00:	3b04      	subs	r3, #4
 802dd02:	42b3      	cmp	r3, r6
 802dd04:	461a      	mov	r2, r3
 802dd06:	d802      	bhi.n	802dd0e <quorem+0x9e>
 802dd08:	f8c8 4010 	str.w	r4, [r8, #16]
 802dd0c:	e005      	b.n	802dd1a <quorem+0xaa>
 802dd0e:	6812      	ldr	r2, [r2, #0]
 802dd10:	3b04      	subs	r3, #4
 802dd12:	2a00      	cmp	r2, #0
 802dd14:	d1f8      	bne.n	802dd08 <quorem+0x98>
 802dd16:	3c01      	subs	r4, #1
 802dd18:	e7f3      	b.n	802dd02 <quorem+0x92>
 802dd1a:	4640      	mov	r0, r8
 802dd1c:	f001 f81b 	bl	802ed56 <__mcmp>
 802dd20:	2800      	cmp	r0, #0
 802dd22:	db2c      	blt.n	802dd7e <quorem+0x10e>
 802dd24:	3501      	adds	r5, #1
 802dd26:	4630      	mov	r0, r6
 802dd28:	f04f 0e00 	mov.w	lr, #0
 802dd2c:	f857 1b04 	ldr.w	r1, [r7], #4
 802dd30:	f8d0 c000 	ldr.w	ip, [r0]
 802dd34:	b28a      	uxth	r2, r1
 802dd36:	ebc2 030e 	rsb	r3, r2, lr
 802dd3a:	0c09      	lsrs	r1, r1, #16
 802dd3c:	fa13 f38c 	uxtah	r3, r3, ip
 802dd40:	ebc1 421c 	rsb	r2, r1, ip, lsr #16
 802dd44:	eb02 4223 	add.w	r2, r2, r3, asr #16
 802dd48:	b29b      	uxth	r3, r3
 802dd4a:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 802dd4e:	454f      	cmp	r7, r9
 802dd50:	ea4f 4e22 	mov.w	lr, r2, asr #16
 802dd54:	f840 3b04 	str.w	r3, [r0], #4
 802dd58:	d9e8      	bls.n	802dd2c <quorem+0xbc>
 802dd5a:	f856 2024 	ldr.w	r2, [r6, r4, lsl #2]
 802dd5e:	eb06 0384 	add.w	r3, r6, r4, lsl #2
 802dd62:	b962      	cbnz	r2, 802dd7e <quorem+0x10e>
 802dd64:	3b04      	subs	r3, #4
 802dd66:	42b3      	cmp	r3, r6
 802dd68:	461a      	mov	r2, r3
 802dd6a:	d802      	bhi.n	802dd72 <quorem+0x102>
 802dd6c:	f8c8 4010 	str.w	r4, [r8, #16]
 802dd70:	e005      	b.n	802dd7e <quorem+0x10e>
 802dd72:	6812      	ldr	r2, [r2, #0]
 802dd74:	3b04      	subs	r3, #4
 802dd76:	2a00      	cmp	r2, #0
 802dd78:	d1f8      	bne.n	802dd6c <quorem+0xfc>
 802dd7a:	3c01      	subs	r4, #1
 802dd7c:	e7f3      	b.n	802dd66 <quorem+0xf6>
 802dd7e:	4628      	mov	r0, r5
 802dd80:	e000      	b.n	802dd84 <quorem+0x114>
 802dd82:	2000      	movs	r0, #0
 802dd84:	b003      	add	sp, #12
 802dd86:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802dd8a:	0000      	movs	r0, r0
 802dd8c:	0000      	movs	r0, r0
	...

0802dd90 <_dtoa_r>:
 802dd90:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802dd94:	6a45      	ldr	r5, [r0, #36]	; 0x24
 802dd96:	b097      	sub	sp, #92	; 0x5c
 802dd98:	4682      	mov	sl, r0
 802dd9a:	9c23      	ldr	r4, [sp, #140]	; 0x8c
 802dd9c:	e9cd 2302 	strd	r2, r3, [sp, #8]
 802dda0:	b945      	cbnz	r5, 802ddb4 <_dtoa_r+0x24>
 802dda2:	2010      	movs	r0, #16
 802dda4:	f000 fdbc 	bl	802e920 <malloc>
 802dda8:	f8ca 0024 	str.w	r0, [sl, #36]	; 0x24
 802ddac:	6045      	str	r5, [r0, #4]
 802ddae:	6085      	str	r5, [r0, #8]
 802ddb0:	6005      	str	r5, [r0, #0]
 802ddb2:	60c5      	str	r5, [r0, #12]
 802ddb4:	f8da 3024 	ldr.w	r3, [sl, #36]	; 0x24
 802ddb8:	6819      	ldr	r1, [r3, #0]
 802ddba:	b159      	cbz	r1, 802ddd4 <_dtoa_r+0x44>
 802ddbc:	685a      	ldr	r2, [r3, #4]
 802ddbe:	604a      	str	r2, [r1, #4]
 802ddc0:	2301      	movs	r3, #1
 802ddc2:	4093      	lsls	r3, r2
 802ddc4:	608b      	str	r3, [r1, #8]
 802ddc6:	4650      	mov	r0, sl
 802ddc8:	f000 fde7 	bl	802e99a <_Bfree>
 802ddcc:	f8da 3024 	ldr.w	r3, [sl, #36]	; 0x24
 802ddd0:	2200      	movs	r2, #0
 802ddd2:	601a      	str	r2, [r3, #0]
 802ddd4:	9b03      	ldr	r3, [sp, #12]
 802ddd6:	4aa2      	ldr	r2, [pc, #648]	; (802e060 <_dtoa_r+0x2d0>)
 802ddd8:	2b00      	cmp	r3, #0
 802ddda:	bfbf      	itttt	lt
 802dddc:	2301      	movlt	r3, #1
 802ddde:	6023      	strlt	r3, [r4, #0]
 802dde0:	9b03      	ldrlt	r3, [sp, #12]
 802dde2:	f023 4300 	biclt.w	r3, r3, #2147483648	; 0x80000000
 802dde6:	bfb8      	it	lt
 802dde8:	9303      	strlt	r3, [sp, #12]
 802ddea:	9f03      	ldr	r7, [sp, #12]
 802ddec:	bfa4      	itt	ge
 802ddee:	2300      	movge	r3, #0
 802ddf0:	6023      	strge	r3, [r4, #0]
 802ddf2:	f027 4300 	bic.w	r3, r7, #2147483648	; 0x80000000
 802ddf6:	0d1b      	lsrs	r3, r3, #20
 802ddf8:	051b      	lsls	r3, r3, #20
 802ddfa:	4293      	cmp	r3, r2
 802ddfc:	d11d      	bne.n	802de3a <_dtoa_r+0xaa>
 802ddfe:	9a22      	ldr	r2, [sp, #136]	; 0x88
 802de00:	f242 730f 	movw	r3, #9999	; 0x270f
 802de04:	6013      	str	r3, [r2, #0]
 802de06:	9b02      	ldr	r3, [sp, #8]
 802de08:	b943      	cbnz	r3, 802de1c <_dtoa_r+0x8c>
 802de0a:	4a96      	ldr	r2, [pc, #600]	; (802e064 <_dtoa_r+0x2d4>)
 802de0c:	4b96      	ldr	r3, [pc, #600]	; (802e068 <_dtoa_r+0x2d8>)
 802de0e:	f3c7 0013 	ubfx	r0, r7, #0, #20
 802de12:	2800      	cmp	r0, #0
 802de14:	bf14      	ite	ne
 802de16:	4618      	movne	r0, r3
 802de18:	4610      	moveq	r0, r2
 802de1a:	e000      	b.n	802de1e <_dtoa_r+0x8e>
 802de1c:	4892      	ldr	r0, [pc, #584]	; (802e068 <_dtoa_r+0x2d8>)
 802de1e:	9b24      	ldr	r3, [sp, #144]	; 0x90
 802de20:	2b00      	cmp	r3, #0
 802de22:	f000 8573 	beq.w	802e90c <_dtoa_r+0xb7c>
 802de26:	78c3      	ldrb	r3, [r0, #3]
 802de28:	b113      	cbz	r3, 802de30 <_dtoa_r+0xa0>
 802de2a:	f100 0308 	add.w	r3, r0, #8
 802de2e:	e000      	b.n	802de32 <_dtoa_r+0xa2>
 802de30:	1cc3      	adds	r3, r0, #3
 802de32:	9a24      	ldr	r2, [sp, #144]	; 0x90
 802de34:	6013      	str	r3, [r2, #0]
 802de36:	f000 bd69 	b.w	802e90c <_dtoa_r+0xb7c>
 802de3a:	e9dd 4502 	ldrd	r4, r5, [sp, #8]
 802de3e:	2200      	movs	r2, #0
 802de40:	4620      	mov	r0, r4
 802de42:	4629      	mov	r1, r5
 802de44:	2300      	movs	r3, #0
 802de46:	f7fe ffff 	bl	802ce48 <__aeabi_dcmpeq>
 802de4a:	4680      	mov	r8, r0
 802de4c:	b158      	cbz	r0, 802de66 <_dtoa_r+0xd6>
 802de4e:	9a22      	ldr	r2, [sp, #136]	; 0x88
 802de50:	2301      	movs	r3, #1
 802de52:	6013      	str	r3, [r2, #0]
 802de54:	9b24      	ldr	r3, [sp, #144]	; 0x90
 802de56:	2b00      	cmp	r3, #0
 802de58:	f000 8546 	beq.w	802e8e8 <_dtoa_r+0xb58>
 802de5c:	4883      	ldr	r0, [pc, #524]	; (802e06c <_dtoa_r+0x2dc>)
 802de5e:	6018      	str	r0, [r3, #0]
 802de60:	3801      	subs	r0, #1
 802de62:	f000 bd53 	b.w	802e90c <_dtoa_r+0xb7c>
 802de66:	ab15      	add	r3, sp, #84	; 0x54
 802de68:	9300      	str	r3, [sp, #0]
 802de6a:	ab14      	add	r3, sp, #80	; 0x50
 802de6c:	9301      	str	r3, [sp, #4]
 802de6e:	4650      	mov	r0, sl
 802de70:	4622      	mov	r2, r4
 802de72:	462b      	mov	r3, r5
 802de74:	f000 ffea 	bl	802ee4c <__d2b>
 802de78:	f3c7 560a 	ubfx	r6, r7, #20, #11
 802de7c:	9007      	str	r0, [sp, #28]
 802de7e:	b15e      	cbz	r6, 802de98 <_dtoa_r+0x108>
 802de80:	f3c5 0313 	ubfx	r3, r5, #0, #20
 802de84:	f043 517f 	orr.w	r1, r3, #1069547520	; 0x3fc00000
 802de88:	4620      	mov	r0, r4
 802de8a:	f441 1140 	orr.w	r1, r1, #3145728	; 0x300000
 802de8e:	f2a6 36ff 	subw	r6, r6, #1023	; 0x3ff
 802de92:	f8cd 804c 	str.w	r8, [sp, #76]	; 0x4c
 802de96:	e01d      	b.n	802ded4 <_dtoa_r+0x144>
 802de98:	9b15      	ldr	r3, [sp, #84]	; 0x54
 802de9a:	9e14      	ldr	r6, [sp, #80]	; 0x50
 802de9c:	441e      	add	r6, r3
 802de9e:	f46f 6382 	mvn.w	r3, #1040	; 0x410
 802dea2:	429e      	cmp	r6, r3
 802dea4:	bfad      	iteet	ge
 802dea6:	9a02      	ldrge	r2, [sp, #8]
 802dea8:	4b71      	ldrlt	r3, [pc, #452]	; (802e070 <_dtoa_r+0x2e0>)
 802deaa:	9a02      	ldrlt	r2, [sp, #8]
 802deac:	f206 4312 	addwge	r3, r6, #1042	; 0x412
 802deb0:	bfa3      	ittte	ge
 802deb2:	fa22 f003 	lsrge.w	r0, r2, r3
 802deb6:	4b6f      	ldrge	r3, [pc, #444]	; (802e074 <_dtoa_r+0x2e4>)
 802deb8:	1b9b      	subge	r3, r3, r6
 802deba:	1b9b      	sublt	r3, r3, r6
 802debc:	bfaa      	itet	ge
 802debe:	409f      	lslge	r7, r3
 802dec0:	fa02 f003 	lsllt.w	r0, r2, r3
 802dec4:	4338      	orrge	r0, r7
 802dec6:	f7fe fce1 	bl	802c88c <__aeabi_ui2d>
 802deca:	2301      	movs	r3, #1
 802decc:	f1a1 71f8 	sub.w	r1, r1, #32505856	; 0x1f00000
 802ded0:	3e01      	subs	r6, #1
 802ded2:	9313      	str	r3, [sp, #76]	; 0x4c
 802ded4:	2200      	movs	r2, #0
 802ded6:	4b68      	ldr	r3, [pc, #416]	; (802e078 <_dtoa_r+0x2e8>)
 802ded8:	f7fe fb9a 	bl	802c610 <__aeabi_dsub>
 802dedc:	a35a      	add	r3, pc, #360	; (adr r3, 802e048 <_dtoa_r+0x2b8>)
 802dede:	e9d3 2300 	ldrd	r2, r3, [r3]
 802dee2:	f7fe fd49 	bl	802c978 <__aeabi_dmul>
 802dee6:	a35a      	add	r3, pc, #360	; (adr r3, 802e050 <_dtoa_r+0x2c0>)
 802dee8:	e9d3 2300 	ldrd	r2, r3, [r3]
 802deec:	f7fe fb92 	bl	802c614 <__adddf3>
 802def0:	4604      	mov	r4, r0
 802def2:	4630      	mov	r0, r6
 802def4:	460d      	mov	r5, r1
 802def6:	f7fe fcd9 	bl	802c8ac <__aeabi_i2d>
 802defa:	a357      	add	r3, pc, #348	; (adr r3, 802e058 <_dtoa_r+0x2c8>)
 802defc:	e9d3 2300 	ldrd	r2, r3, [r3]
 802df00:	f7fe fd3a 	bl	802c978 <__aeabi_dmul>
 802df04:	4602      	mov	r2, r0
 802df06:	460b      	mov	r3, r1
 802df08:	4620      	mov	r0, r4
 802df0a:	4629      	mov	r1, r5
 802df0c:	f7fe fb82 	bl	802c614 <__adddf3>
 802df10:	4604      	mov	r4, r0
 802df12:	460d      	mov	r5, r1
 802df14:	f001 f860 	bl	802efd8 <__aeabi_d2iz>
 802df18:	4629      	mov	r1, r5
 802df1a:	4683      	mov	fp, r0
 802df1c:	2200      	movs	r2, #0
 802df1e:	4620      	mov	r0, r4
 802df20:	2300      	movs	r3, #0
 802df22:	f7fe ff9b 	bl	802ce5c <__aeabi_dcmplt>
 802df26:	b158      	cbz	r0, 802df40 <_dtoa_r+0x1b0>
 802df28:	4658      	mov	r0, fp
 802df2a:	f7fe fcbf 	bl	802c8ac <__aeabi_i2d>
 802df2e:	4602      	mov	r2, r0
 802df30:	460b      	mov	r3, r1
 802df32:	4620      	mov	r0, r4
 802df34:	4629      	mov	r1, r5
 802df36:	f7fe ff87 	bl	802ce48 <__aeabi_dcmpeq>
 802df3a:	b908      	cbnz	r0, 802df40 <_dtoa_r+0x1b0>
 802df3c:	f10b 3bff 	add.w	fp, fp, #4294967295
 802df40:	f1bb 0f16 	cmp.w	fp, #22
 802df44:	d80d      	bhi.n	802df62 <_dtoa_r+0x1d2>
 802df46:	4b4d      	ldr	r3, [pc, #308]	; (802e07c <_dtoa_r+0x2ec>)
 802df48:	eb03 03cb 	add.w	r3, r3, fp, lsl #3
 802df4c:	e9d3 0100 	ldrd	r0, r1, [r3]
 802df50:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 802df54:	f7fe ffa0 	bl	802ce98 <__aeabi_dcmpgt>
 802df58:	b130      	cbz	r0, 802df68 <_dtoa_r+0x1d8>
 802df5a:	f10b 3bff 	add.w	fp, fp, #4294967295
 802df5e:	2300      	movs	r3, #0
 802df60:	e000      	b.n	802df64 <_dtoa_r+0x1d4>
 802df62:	2301      	movs	r3, #1
 802df64:	9312      	str	r3, [sp, #72]	; 0x48
 802df66:	e000      	b.n	802df6a <_dtoa_r+0x1da>
 802df68:	9012      	str	r0, [sp, #72]	; 0x48
 802df6a:	9b14      	ldr	r3, [sp, #80]	; 0x50
 802df6c:	1b9e      	subs	r6, r3, r6
 802df6e:	1e73      	subs	r3, r6, #1
 802df70:	930a      	str	r3, [sp, #40]	; 0x28
 802df72:	bf45      	ittet	mi
 802df74:	425b      	negmi	r3, r3
 802df76:	9309      	strmi	r3, [sp, #36]	; 0x24
 802df78:	2300      	movpl	r3, #0
 802df7a:	2300      	movmi	r3, #0
 802df7c:	bf4c      	ite	mi
 802df7e:	930a      	strmi	r3, [sp, #40]	; 0x28
 802df80:	9309      	strpl	r3, [sp, #36]	; 0x24
 802df82:	f1bb 0f00 	cmp.w	fp, #0
 802df86:	db07      	blt.n	802df98 <_dtoa_r+0x208>
 802df88:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 802df8a:	f8cd b034 	str.w	fp, [sp, #52]	; 0x34
 802df8e:	445b      	add	r3, fp
 802df90:	930a      	str	r3, [sp, #40]	; 0x28
 802df92:	2300      	movs	r3, #0
 802df94:	930b      	str	r3, [sp, #44]	; 0x2c
 802df96:	e008      	b.n	802dfaa <_dtoa_r+0x21a>
 802df98:	9b09      	ldr	r3, [sp, #36]	; 0x24
 802df9a:	ebcb 0303 	rsb	r3, fp, r3
 802df9e:	9309      	str	r3, [sp, #36]	; 0x24
 802dfa0:	f1cb 0300 	rsb	r3, fp, #0
 802dfa4:	930b      	str	r3, [sp, #44]	; 0x2c
 802dfa6:	2300      	movs	r3, #0
 802dfa8:	930d      	str	r3, [sp, #52]	; 0x34
 802dfaa:	9b20      	ldr	r3, [sp, #128]	; 0x80
 802dfac:	2b09      	cmp	r3, #9
 802dfae:	d828      	bhi.n	802e002 <_dtoa_r+0x272>
 802dfb0:	2b05      	cmp	r3, #5
 802dfb2:	bfc4      	itt	gt
 802dfb4:	3b04      	subgt	r3, #4
 802dfb6:	9320      	strgt	r3, [sp, #128]	; 0x80
 802dfb8:	9b20      	ldr	r3, [sp, #128]	; 0x80
 802dfba:	f1a3 0302 	sub.w	r3, r3, #2
 802dfbe:	bfcc      	ite	gt
 802dfc0:	2500      	movgt	r5, #0
 802dfc2:	2501      	movle	r5, #1
 802dfc4:	2b03      	cmp	r3, #3
 802dfc6:	d821      	bhi.n	802e00c <_dtoa_r+0x27c>
 802dfc8:	e8df f003 	tbb	[pc, r3]
 802dfcc:	10040e02 	.word	0x10040e02
 802dfd0:	2300      	movs	r3, #0
 802dfd2:	e000      	b.n	802dfd6 <_dtoa_r+0x246>
 802dfd4:	2301      	movs	r3, #1
 802dfd6:	930c      	str	r3, [sp, #48]	; 0x30
 802dfd8:	9b21      	ldr	r3, [sp, #132]	; 0x84
 802dfda:	2b00      	cmp	r3, #0
 802dfdc:	dc20      	bgt.n	802e020 <_dtoa_r+0x290>
 802dfde:	2301      	movs	r3, #1
 802dfe0:	9306      	str	r3, [sp, #24]
 802dfe2:	9305      	str	r3, [sp, #20]
 802dfe4:	461a      	mov	r2, r3
 802dfe6:	e019      	b.n	802e01c <_dtoa_r+0x28c>
 802dfe8:	2300      	movs	r3, #0
 802dfea:	e000      	b.n	802dfee <_dtoa_r+0x25e>
 802dfec:	2301      	movs	r3, #1
 802dfee:	930c      	str	r3, [sp, #48]	; 0x30
 802dff0:	9b21      	ldr	r3, [sp, #132]	; 0x84
 802dff2:	445b      	add	r3, fp
 802dff4:	9306      	str	r3, [sp, #24]
 802dff6:	3301      	adds	r3, #1
 802dff8:	2b01      	cmp	r3, #1
 802dffa:	9305      	str	r3, [sp, #20]
 802dffc:	bfb8      	it	lt
 802dffe:	2301      	movlt	r3, #1
 802e000:	e011      	b.n	802e026 <_dtoa_r+0x296>
 802e002:	2501      	movs	r5, #1
 802e004:	2300      	movs	r3, #0
 802e006:	9320      	str	r3, [sp, #128]	; 0x80
 802e008:	950c      	str	r5, [sp, #48]	; 0x30
 802e00a:	e001      	b.n	802e010 <_dtoa_r+0x280>
 802e00c:	2301      	movs	r3, #1
 802e00e:	930c      	str	r3, [sp, #48]	; 0x30
 802e010:	f04f 33ff 	mov.w	r3, #4294967295
 802e014:	9306      	str	r3, [sp, #24]
 802e016:	9305      	str	r3, [sp, #20]
 802e018:	2200      	movs	r2, #0
 802e01a:	2312      	movs	r3, #18
 802e01c:	9221      	str	r2, [sp, #132]	; 0x84
 802e01e:	e002      	b.n	802e026 <_dtoa_r+0x296>
 802e020:	9b21      	ldr	r3, [sp, #132]	; 0x84
 802e022:	9306      	str	r3, [sp, #24]
 802e024:	9305      	str	r3, [sp, #20]
 802e026:	f8da 4024 	ldr.w	r4, [sl, #36]	; 0x24
 802e02a:	2200      	movs	r2, #0
 802e02c:	6062      	str	r2, [r4, #4]
 802e02e:	2104      	movs	r1, #4
 802e030:	f101 0214 	add.w	r2, r1, #20
 802e034:	429a      	cmp	r2, r3
 802e036:	d823      	bhi.n	802e080 <_dtoa_r+0x2f0>
 802e038:	6862      	ldr	r2, [r4, #4]
 802e03a:	3201      	adds	r2, #1
 802e03c:	6062      	str	r2, [r4, #4]
 802e03e:	0049      	lsls	r1, r1, #1
 802e040:	e7f6      	b.n	802e030 <_dtoa_r+0x2a0>
 802e042:	bf00      	nop
 802e044:	f3af 8000 	nop.w
 802e048:	636f4361 	.word	0x636f4361
 802e04c:	3fd287a7 	.word	0x3fd287a7
 802e050:	8b60c8b3 	.word	0x8b60c8b3
 802e054:	3fc68a28 	.word	0x3fc68a28
 802e058:	509f79fb 	.word	0x509f79fb
 802e05c:	3fd34413 	.word	0x3fd34413
 802e060:	7ff00000 	.word	0x7ff00000
 802e064:	08031a44 	.word	0x08031a44
 802e068:	08031a4d 	.word	0x08031a4d
 802e06c:	08031a43 	.word	0x08031a43
 802e070:	fffffbee 	.word	0xfffffbee
 802e074:	fffffc0e 	.word	0xfffffc0e
 802e078:	3ff80000 	.word	0x3ff80000
 802e07c:	08031a60 	.word	0x08031a60
 802e080:	4650      	mov	r0, sl
 802e082:	6861      	ldr	r1, [r4, #4]
 802e084:	f000 fc54 	bl	802e930 <_Balloc>
 802e088:	f8da 3024 	ldr.w	r3, [sl, #36]	; 0x24
 802e08c:	6020      	str	r0, [r4, #0]
 802e08e:	681b      	ldr	r3, [r3, #0]
 802e090:	9308      	str	r3, [sp, #32]
 802e092:	9b05      	ldr	r3, [sp, #20]
 802e094:	2b0e      	cmp	r3, #14
 802e096:	f200 814b 	bhi.w	802e330 <_dtoa_r+0x5a0>
 802e09a:	2d00      	cmp	r5, #0
 802e09c:	f000 8148 	beq.w	802e330 <_dtoa_r+0x5a0>
 802e0a0:	ed9d 7b02 	vldr	d7, [sp, #8]
 802e0a4:	f1bb 0f00 	cmp.w	fp, #0
 802e0a8:	ed8d 7b10 	vstr	d7, [sp, #64]	; 0x40
 802e0ac:	dd31      	ble.n	802e112 <_dtoa_r+0x382>
 802e0ae:	4ab3      	ldr	r2, [pc, #716]	; (802e37c <_dtoa_r+0x5ec>)
 802e0b0:	f00b 030f 	and.w	r3, fp, #15
 802e0b4:	ea4f 172b 	mov.w	r7, fp, asr #4
 802e0b8:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 802e0bc:	06f8      	lsls	r0, r7, #27
 802e0be:	e9d3 4500 	ldrd	r4, r5, [r3]
 802e0c2:	d50c      	bpl.n	802e0de <_dtoa_r+0x34e>
 802e0c4:	4bae      	ldr	r3, [pc, #696]	; (802e380 <_dtoa_r+0x5f0>)
 802e0c6:	ec51 0b17 	vmov	r0, r1, d7
 802e0ca:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
 802e0ce:	f7fe fd7d 	bl	802cbcc <__aeabi_ddiv>
 802e0d2:	f007 070f 	and.w	r7, r7, #15
 802e0d6:	e9cd 0102 	strd	r0, r1, [sp, #8]
 802e0da:	2603      	movs	r6, #3
 802e0dc:	e000      	b.n	802e0e0 <_dtoa_r+0x350>
 802e0de:	2602      	movs	r6, #2
 802e0e0:	f8df 829c 	ldr.w	r8, [pc, #668]	; 802e380 <_dtoa_r+0x5f0>
 802e0e4:	b177      	cbz	r7, 802e104 <_dtoa_r+0x374>
 802e0e6:	07f9      	lsls	r1, r7, #31
 802e0e8:	d508      	bpl.n	802e0fc <_dtoa_r+0x36c>
 802e0ea:	4620      	mov	r0, r4
 802e0ec:	4629      	mov	r1, r5
 802e0ee:	e9d8 2300 	ldrd	r2, r3, [r8]
 802e0f2:	f7fe fc41 	bl	802c978 <__aeabi_dmul>
 802e0f6:	3601      	adds	r6, #1
 802e0f8:	4604      	mov	r4, r0
 802e0fa:	460d      	mov	r5, r1
 802e0fc:	107f      	asrs	r7, r7, #1
 802e0fe:	f108 0808 	add.w	r8, r8, #8
 802e102:	e7ef      	b.n	802e0e4 <_dtoa_r+0x354>
 802e104:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 802e108:	4622      	mov	r2, r4
 802e10a:	462b      	mov	r3, r5
 802e10c:	f7fe fd5e 	bl	802cbcc <__aeabi_ddiv>
 802e110:	e01b      	b.n	802e14a <_dtoa_r+0x3ba>
 802e112:	f1cb 0400 	rsb	r4, fp, #0
 802e116:	b1dc      	cbz	r4, 802e150 <_dtoa_r+0x3c0>
 802e118:	4b98      	ldr	r3, [pc, #608]	; (802e37c <_dtoa_r+0x5ec>)
 802e11a:	4d99      	ldr	r5, [pc, #612]	; (802e380 <_dtoa_r+0x5f0>)
 802e11c:	f004 020f 	and.w	r2, r4, #15
 802e120:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 802e124:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	; 0x40
 802e128:	e9d3 2300 	ldrd	r2, r3, [r3]
 802e12c:	f7fe fc24 	bl	802c978 <__aeabi_dmul>
 802e130:	1124      	asrs	r4, r4, #4
 802e132:	2602      	movs	r6, #2
 802e134:	b14c      	cbz	r4, 802e14a <_dtoa_r+0x3ba>
 802e136:	07e2      	lsls	r2, r4, #31
 802e138:	d504      	bpl.n	802e144 <_dtoa_r+0x3b4>
 802e13a:	e9d5 2300 	ldrd	r2, r3, [r5]
 802e13e:	3601      	adds	r6, #1
 802e140:	f7fe fc1a 	bl	802c978 <__aeabi_dmul>
 802e144:	1064      	asrs	r4, r4, #1
 802e146:	3508      	adds	r5, #8
 802e148:	e7f4      	b.n	802e134 <_dtoa_r+0x3a4>
 802e14a:	e9cd 0102 	strd	r0, r1, [sp, #8]
 802e14e:	e000      	b.n	802e152 <_dtoa_r+0x3c2>
 802e150:	2602      	movs	r6, #2
 802e152:	9b12      	ldr	r3, [sp, #72]	; 0x48
 802e154:	b1db      	cbz	r3, 802e18e <_dtoa_r+0x3fe>
 802e156:	e9dd 4502 	ldrd	r4, r5, [sp, #8]
 802e15a:	2200      	movs	r2, #0
 802e15c:	4620      	mov	r0, r4
 802e15e:	4629      	mov	r1, r5
 802e160:	4b88      	ldr	r3, [pc, #544]	; (802e384 <_dtoa_r+0x5f4>)
 802e162:	f7fe fe7b 	bl	802ce5c <__aeabi_dcmplt>
 802e166:	b190      	cbz	r0, 802e18e <_dtoa_r+0x3fe>
 802e168:	9b05      	ldr	r3, [sp, #20]
 802e16a:	b183      	cbz	r3, 802e18e <_dtoa_r+0x3fe>
 802e16c:	9b06      	ldr	r3, [sp, #24]
 802e16e:	2b00      	cmp	r3, #0
 802e170:	f340 80da 	ble.w	802e328 <_dtoa_r+0x598>
 802e174:	4629      	mov	r1, r5
 802e176:	4620      	mov	r0, r4
 802e178:	2200      	movs	r2, #0
 802e17a:	4b83      	ldr	r3, [pc, #524]	; (802e388 <_dtoa_r+0x5f8>)
 802e17c:	f7fe fbfc 	bl	802c978 <__aeabi_dmul>
 802e180:	f10b 37ff 	add.w	r7, fp, #4294967295
 802e184:	e9cd 0102 	strd	r0, r1, [sp, #8]
 802e188:	3601      	adds	r6, #1
 802e18a:	9d06      	ldr	r5, [sp, #24]
 802e18c:	e001      	b.n	802e192 <_dtoa_r+0x402>
 802e18e:	9d05      	ldr	r5, [sp, #20]
 802e190:	465f      	mov	r7, fp
 802e192:	ed9d 7b02 	vldr	d7, [sp, #8]
 802e196:	4630      	mov	r0, r6
 802e198:	ed8d 7b0e 	vstr	d7, [sp, #56]	; 0x38
 802e19c:	f7fe fb86 	bl	802c8ac <__aeabi_i2d>
 802e1a0:	e9dd 230e 	ldrd	r2, r3, [sp, #56]	; 0x38
 802e1a4:	f7fe fbe8 	bl	802c978 <__aeabi_dmul>
 802e1a8:	2200      	movs	r2, #0
 802e1aa:	4b78      	ldr	r3, [pc, #480]	; (802e38c <_dtoa_r+0x5fc>)
 802e1ac:	f7fe fa32 	bl	802c614 <__adddf3>
 802e1b0:	4680      	mov	r8, r0
 802e1b2:	f1a1 7950 	sub.w	r9, r1, #54525952	; 0x3400000
 802e1b6:	b9cd      	cbnz	r5, 802e1ec <_dtoa_r+0x45c>
 802e1b8:	2200      	movs	r2, #0
 802e1ba:	4b75      	ldr	r3, [pc, #468]	; (802e390 <_dtoa_r+0x600>)
 802e1bc:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
 802e1c0:	f7fe fa26 	bl	802c610 <__aeabi_dsub>
 802e1c4:	4642      	mov	r2, r8
 802e1c6:	464b      	mov	r3, r9
 802e1c8:	e9cd 0102 	strd	r0, r1, [sp, #8]
 802e1cc:	f7fe fe64 	bl	802ce98 <__aeabi_dcmpgt>
 802e1d0:	2800      	cmp	r0, #0
 802e1d2:	f040 8246 	bne.w	802e662 <_dtoa_r+0x8d2>
 802e1d6:	4642      	mov	r2, r8
 802e1d8:	f109 4300 	add.w	r3, r9, #2147483648	; 0x80000000
 802e1dc:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 802e1e0:	f7fe fe3c 	bl	802ce5c <__aeabi_dcmplt>
 802e1e4:	2800      	cmp	r0, #0
 802e1e6:	f040 8236 	bne.w	802e656 <_dtoa_r+0x8c6>
 802e1ea:	e09d      	b.n	802e328 <_dtoa_r+0x598>
 802e1ec:	4b63      	ldr	r3, [pc, #396]	; (802e37c <_dtoa_r+0x5ec>)
 802e1ee:	990c      	ldr	r1, [sp, #48]	; 0x30
 802e1f0:	1e6a      	subs	r2, r5, #1
 802e1f2:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 802e1f6:	2900      	cmp	r1, #0
 802e1f8:	d049      	beq.n	802e28e <_dtoa_r+0x4fe>
 802e1fa:	e9d3 2300 	ldrd	r2, r3, [r3]
 802e1fe:	2000      	movs	r0, #0
 802e200:	4964      	ldr	r1, [pc, #400]	; (802e394 <_dtoa_r+0x604>)
 802e202:	f7fe fce3 	bl	802cbcc <__aeabi_ddiv>
 802e206:	4642      	mov	r2, r8
 802e208:	464b      	mov	r3, r9
 802e20a:	f7fe fa01 	bl	802c610 <__aeabi_dsub>
 802e20e:	e9dd 890e 	ldrd	r8, r9, [sp, #56]	; 0x38
 802e212:	e9cd 0102 	strd	r0, r1, [sp, #8]
 802e216:	9c08      	ldr	r4, [sp, #32]
 802e218:	4649      	mov	r1, r9
 802e21a:	4640      	mov	r0, r8
 802e21c:	f000 fedc 	bl	802efd8 <__aeabi_d2iz>
 802e220:	4606      	mov	r6, r0
 802e222:	f7fe fb43 	bl	802c8ac <__aeabi_i2d>
 802e226:	4602      	mov	r2, r0
 802e228:	460b      	mov	r3, r1
 802e22a:	4640      	mov	r0, r8
 802e22c:	4649      	mov	r1, r9
 802e22e:	f7fe f9ef 	bl	802c610 <__aeabi_dsub>
 802e232:	3630      	adds	r6, #48	; 0x30
 802e234:	f804 6b01 	strb.w	r6, [r4], #1
 802e238:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 802e23c:	4680      	mov	r8, r0
 802e23e:	4689      	mov	r9, r1
 802e240:	f7fe fe0c 	bl	802ce5c <__aeabi_dcmplt>
 802e244:	2800      	cmp	r0, #0
 802e246:	f040 8340 	bne.w	802e8ca <_dtoa_r+0xb3a>
 802e24a:	4642      	mov	r2, r8
 802e24c:	464b      	mov	r3, r9
 802e24e:	2000      	movs	r0, #0
 802e250:	494c      	ldr	r1, [pc, #304]	; (802e384 <_dtoa_r+0x5f4>)
 802e252:	f7fe f9dd 	bl	802c610 <__aeabi_dsub>
 802e256:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 802e25a:	f7fe fdff 	bl	802ce5c <__aeabi_dcmplt>
 802e25e:	2800      	cmp	r0, #0
 802e260:	f040 80d3 	bne.w	802e40a <_dtoa_r+0x67a>
 802e264:	9b08      	ldr	r3, [sp, #32]
 802e266:	1ae3      	subs	r3, r4, r3
 802e268:	42ab      	cmp	r3, r5
 802e26a:	da5d      	bge.n	802e328 <_dtoa_r+0x598>
 802e26c:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 802e270:	2200      	movs	r2, #0
 802e272:	4b45      	ldr	r3, [pc, #276]	; (802e388 <_dtoa_r+0x5f8>)
 802e274:	f7fe fb80 	bl	802c978 <__aeabi_dmul>
 802e278:	2200      	movs	r2, #0
 802e27a:	e9cd 0102 	strd	r0, r1, [sp, #8]
 802e27e:	4b42      	ldr	r3, [pc, #264]	; (802e388 <_dtoa_r+0x5f8>)
 802e280:	4640      	mov	r0, r8
 802e282:	4649      	mov	r1, r9
 802e284:	f7fe fb78 	bl	802c978 <__aeabi_dmul>
 802e288:	4680      	mov	r8, r0
 802e28a:	4689      	mov	r9, r1
 802e28c:	e7c4      	b.n	802e218 <_dtoa_r+0x488>
 802e28e:	e9d3 0100 	ldrd	r0, r1, [r3]
 802e292:	4642      	mov	r2, r8
 802e294:	464b      	mov	r3, r9
 802e296:	f7fe fb6f 	bl	802c978 <__aeabi_dmul>
 802e29a:	9b08      	ldr	r3, [sp, #32]
 802e29c:	e9cd 0102 	strd	r0, r1, [sp, #8]
 802e2a0:	e9dd 890e 	ldrd	r8, r9, [sp, #56]	; 0x38
 802e2a4:	195c      	adds	r4, r3, r5
 802e2a6:	461d      	mov	r5, r3
 802e2a8:	4649      	mov	r1, r9
 802e2aa:	4640      	mov	r0, r8
 802e2ac:	f000 fe94 	bl	802efd8 <__aeabi_d2iz>
 802e2b0:	4606      	mov	r6, r0
 802e2b2:	f7fe fafb 	bl	802c8ac <__aeabi_i2d>
 802e2b6:	3630      	adds	r6, #48	; 0x30
 802e2b8:	4602      	mov	r2, r0
 802e2ba:	460b      	mov	r3, r1
 802e2bc:	4640      	mov	r0, r8
 802e2be:	4649      	mov	r1, r9
 802e2c0:	f7fe f9a6 	bl	802c610 <__aeabi_dsub>
 802e2c4:	f805 6b01 	strb.w	r6, [r5], #1
 802e2c8:	42a5      	cmp	r5, r4
 802e2ca:	4680      	mov	r8, r0
 802e2cc:	4689      	mov	r9, r1
 802e2ce:	d124      	bne.n	802e31a <_dtoa_r+0x58a>
 802e2d0:	2200      	movs	r2, #0
 802e2d2:	4b30      	ldr	r3, [pc, #192]	; (802e394 <_dtoa_r+0x604>)
 802e2d4:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 802e2d8:	f7fe f99c 	bl	802c614 <__adddf3>
 802e2dc:	4602      	mov	r2, r0
 802e2de:	460b      	mov	r3, r1
 802e2e0:	4640      	mov	r0, r8
 802e2e2:	4649      	mov	r1, r9
 802e2e4:	f7fe fdd8 	bl	802ce98 <__aeabi_dcmpgt>
 802e2e8:	2800      	cmp	r0, #0
 802e2ea:	f040 808e 	bne.w	802e40a <_dtoa_r+0x67a>
 802e2ee:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 802e2f2:	2000      	movs	r0, #0
 802e2f4:	4927      	ldr	r1, [pc, #156]	; (802e394 <_dtoa_r+0x604>)
 802e2f6:	f7fe f98b 	bl	802c610 <__aeabi_dsub>
 802e2fa:	4602      	mov	r2, r0
 802e2fc:	460b      	mov	r3, r1
 802e2fe:	4640      	mov	r0, r8
 802e300:	4649      	mov	r1, r9
 802e302:	f7fe fdab 	bl	802ce5c <__aeabi_dcmplt>
 802e306:	b178      	cbz	r0, 802e328 <_dtoa_r+0x598>
 802e308:	f814 3c01 	ldrb.w	r3, [r4, #-1]
 802e30c:	2b30      	cmp	r3, #48	; 0x30
 802e30e:	f104 32ff 	add.w	r2, r4, #4294967295
 802e312:	f040 82da 	bne.w	802e8ca <_dtoa_r+0xb3a>
 802e316:	4614      	mov	r4, r2
 802e318:	e7f6      	b.n	802e308 <_dtoa_r+0x578>
 802e31a:	2200      	movs	r2, #0
 802e31c:	4b1a      	ldr	r3, [pc, #104]	; (802e388 <_dtoa_r+0x5f8>)
 802e31e:	f7fe fb2b 	bl	802c978 <__aeabi_dmul>
 802e322:	4680      	mov	r8, r0
 802e324:	4689      	mov	r9, r1
 802e326:	e7bf      	b.n	802e2a8 <_dtoa_r+0x518>
 802e328:	e9dd 2310 	ldrd	r2, r3, [sp, #64]	; 0x40
 802e32c:	e9cd 2302 	strd	r2, r3, [sp, #8]
 802e330:	9b15      	ldr	r3, [sp, #84]	; 0x54
 802e332:	2b00      	cmp	r3, #0
 802e334:	f2c0 808b 	blt.w	802e44e <_dtoa_r+0x6be>
 802e338:	f1bb 0f0e 	cmp.w	fp, #14
 802e33c:	f300 8087 	bgt.w	802e44e <_dtoa_r+0x6be>
 802e340:	4b0e      	ldr	r3, [pc, #56]	; (802e37c <_dtoa_r+0x5ec>)
 802e342:	eb03 03cb 	add.w	r3, r3, fp, lsl #3
 802e346:	e9d3 6700 	ldrd	r6, r7, [r3]
 802e34a:	9b21      	ldr	r3, [sp, #132]	; 0x84
 802e34c:	2b00      	cmp	r3, #0
 802e34e:	da23      	bge.n	802e398 <_dtoa_r+0x608>
 802e350:	9b05      	ldr	r3, [sp, #20]
 802e352:	2b00      	cmp	r3, #0
 802e354:	dc20      	bgt.n	802e398 <_dtoa_r+0x608>
 802e356:	f040 817d 	bne.w	802e654 <_dtoa_r+0x8c4>
 802e35a:	4630      	mov	r0, r6
 802e35c:	2200      	movs	r2, #0
 802e35e:	4b0c      	ldr	r3, [pc, #48]	; (802e390 <_dtoa_r+0x600>)
 802e360:	4639      	mov	r1, r7
 802e362:	f7fe fb09 	bl	802c978 <__aeabi_dmul>
 802e366:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 802e36a:	f7fe fd8b 	bl	802ce84 <__aeabi_dcmpge>
 802e36e:	9d05      	ldr	r5, [sp, #20]
 802e370:	462e      	mov	r6, r5
 802e372:	2800      	cmp	r0, #0
 802e374:	f040 8170 	bne.w	802e658 <_dtoa_r+0x8c8>
 802e378:	e175      	b.n	802e666 <_dtoa_r+0x8d6>
 802e37a:	bf00      	nop
 802e37c:	08031a60 	.word	0x08031a60
 802e380:	08031b28 	.word	0x08031b28
 802e384:	3ff00000 	.word	0x3ff00000
 802e388:	40240000 	.word	0x40240000
 802e38c:	401c0000 	.word	0x401c0000
 802e390:	40140000 	.word	0x40140000
 802e394:	3fe00000 	.word	0x3fe00000
 802e398:	e9dd 8902 	ldrd	r8, r9, [sp, #8]
 802e39c:	9c08      	ldr	r4, [sp, #32]
 802e39e:	4632      	mov	r2, r6
 802e3a0:	463b      	mov	r3, r7
 802e3a2:	4640      	mov	r0, r8
 802e3a4:	4649      	mov	r1, r9
 802e3a6:	f7fe fc11 	bl	802cbcc <__aeabi_ddiv>
 802e3aa:	f000 fe15 	bl	802efd8 <__aeabi_d2iz>
 802e3ae:	4605      	mov	r5, r0
 802e3b0:	f7fe fa7c 	bl	802c8ac <__aeabi_i2d>
 802e3b4:	4632      	mov	r2, r6
 802e3b6:	463b      	mov	r3, r7
 802e3b8:	f7fe fade 	bl	802c978 <__aeabi_dmul>
 802e3bc:	460b      	mov	r3, r1
 802e3be:	4602      	mov	r2, r0
 802e3c0:	4649      	mov	r1, r9
 802e3c2:	4640      	mov	r0, r8
 802e3c4:	f7fe f924 	bl	802c610 <__aeabi_dsub>
 802e3c8:	f105 0e30 	add.w	lr, r5, #48	; 0x30
 802e3cc:	9b08      	ldr	r3, [sp, #32]
 802e3ce:	f804 eb01 	strb.w	lr, [r4], #1
 802e3d2:	ebc3 0e04 	rsb	lr, r3, r4
 802e3d6:	9b05      	ldr	r3, [sp, #20]
 802e3d8:	459e      	cmp	lr, r3
 802e3da:	d12b      	bne.n	802e434 <_dtoa_r+0x6a4>
 802e3dc:	4602      	mov	r2, r0
 802e3de:	460b      	mov	r3, r1
 802e3e0:	f7fe f918 	bl	802c614 <__adddf3>
 802e3e4:	4632      	mov	r2, r6
 802e3e6:	463b      	mov	r3, r7
 802e3e8:	4680      	mov	r8, r0
 802e3ea:	4689      	mov	r9, r1
 802e3ec:	f7fe fd54 	bl	802ce98 <__aeabi_dcmpgt>
 802e3f0:	b970      	cbnz	r0, 802e410 <_dtoa_r+0x680>
 802e3f2:	4640      	mov	r0, r8
 802e3f4:	4649      	mov	r1, r9
 802e3f6:	4632      	mov	r2, r6
 802e3f8:	463b      	mov	r3, r7
 802e3fa:	f7fe fd25 	bl	802ce48 <__aeabi_dcmpeq>
 802e3fe:	2800      	cmp	r0, #0
 802e400:	f000 8264 	beq.w	802e8cc <_dtoa_r+0xb3c>
 802e404:	07eb      	lsls	r3, r5, #31
 802e406:	d403      	bmi.n	802e410 <_dtoa_r+0x680>
 802e408:	e260      	b.n	802e8cc <_dtoa_r+0xb3c>
 802e40a:	46bb      	mov	fp, r7
 802e40c:	e000      	b.n	802e410 <_dtoa_r+0x680>
 802e40e:	461c      	mov	r4, r3
 802e410:	f814 2c01 	ldrb.w	r2, [r4, #-1]
 802e414:	2a39      	cmp	r2, #57	; 0x39
 802e416:	f104 33ff 	add.w	r3, r4, #4294967295
 802e41a:	d107      	bne.n	802e42c <_dtoa_r+0x69c>
 802e41c:	9a08      	ldr	r2, [sp, #32]
 802e41e:	4293      	cmp	r3, r2
 802e420:	d1f5      	bne.n	802e40e <_dtoa_r+0x67e>
 802e422:	2330      	movs	r3, #48	; 0x30
 802e424:	7013      	strb	r3, [r2, #0]
 802e426:	f10b 0b01 	add.w	fp, fp, #1
 802e42a:	4613      	mov	r3, r2
 802e42c:	781a      	ldrb	r2, [r3, #0]
 802e42e:	3201      	adds	r2, #1
 802e430:	701a      	strb	r2, [r3, #0]
 802e432:	e24b      	b.n	802e8cc <_dtoa_r+0xb3c>
 802e434:	2200      	movs	r2, #0
 802e436:	4ba4      	ldr	r3, [pc, #656]	; (802e6c8 <_dtoa_r+0x938>)
 802e438:	f7fe fa9e 	bl	802c978 <__aeabi_dmul>
 802e43c:	2200      	movs	r2, #0
 802e43e:	2300      	movs	r3, #0
 802e440:	4680      	mov	r8, r0
 802e442:	4689      	mov	r9, r1
 802e444:	f7fe fd00 	bl	802ce48 <__aeabi_dcmpeq>
 802e448:	2800      	cmp	r0, #0
 802e44a:	d0a8      	beq.n	802e39e <_dtoa_r+0x60e>
 802e44c:	e23e      	b.n	802e8cc <_dtoa_r+0xb3c>
 802e44e:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 802e450:	2a00      	cmp	r2, #0
 802e452:	d032      	beq.n	802e4ba <_dtoa_r+0x72a>
 802e454:	9a20      	ldr	r2, [sp, #128]	; 0x80
 802e456:	2a01      	cmp	r2, #1
 802e458:	dc0a      	bgt.n	802e470 <_dtoa_r+0x6e0>
 802e45a:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 802e45c:	b112      	cbz	r2, 802e464 <_dtoa_r+0x6d4>
 802e45e:	f203 4333 	addw	r3, r3, #1075	; 0x433
 802e462:	e002      	b.n	802e46a <_dtoa_r+0x6da>
 802e464:	9b14      	ldr	r3, [sp, #80]	; 0x50
 802e466:	f1c3 0336 	rsb	r3, r3, #54	; 0x36
 802e46a:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 802e46c:	9c09      	ldr	r4, [sp, #36]	; 0x24
 802e46e:	e018      	b.n	802e4a2 <_dtoa_r+0x712>
 802e470:	9b05      	ldr	r3, [sp, #20]
 802e472:	1e5d      	subs	r5, r3, #1
 802e474:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 802e476:	42ab      	cmp	r3, r5
 802e478:	bfbf      	itttt	lt
 802e47a:	9b0b      	ldrlt	r3, [sp, #44]	; 0x2c
 802e47c:	950b      	strlt	r5, [sp, #44]	; 0x2c
 802e47e:	1aea      	sublt	r2, r5, r3
 802e480:	9b0d      	ldrlt	r3, [sp, #52]	; 0x34
 802e482:	bfb6      	itet	lt
 802e484:	189b      	addlt	r3, r3, r2
 802e486:	1b5d      	subge	r5, r3, r5
 802e488:	930d      	strlt	r3, [sp, #52]	; 0x34
 802e48a:	9b05      	ldr	r3, [sp, #20]
 802e48c:	bfb8      	it	lt
 802e48e:	2500      	movlt	r5, #0
 802e490:	2b00      	cmp	r3, #0
 802e492:	bfb9      	ittee	lt
 802e494:	9b09      	ldrlt	r3, [sp, #36]	; 0x24
 802e496:	9a05      	ldrlt	r2, [sp, #20]
 802e498:	9c09      	ldrge	r4, [sp, #36]	; 0x24
 802e49a:	9b05      	ldrge	r3, [sp, #20]
 802e49c:	bfbc      	itt	lt
 802e49e:	1a9c      	sublt	r4, r3, r2
 802e4a0:	2300      	movlt	r3, #0
 802e4a2:	9a09      	ldr	r2, [sp, #36]	; 0x24
 802e4a4:	441a      	add	r2, r3
 802e4a6:	9209      	str	r2, [sp, #36]	; 0x24
 802e4a8:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 802e4aa:	4650      	mov	r0, sl
 802e4ac:	441a      	add	r2, r3
 802e4ae:	2101      	movs	r1, #1
 802e4b0:	920a      	str	r2, [sp, #40]	; 0x28
 802e4b2:	f000 fb14 	bl	802eade <__i2b>
 802e4b6:	4606      	mov	r6, r0
 802e4b8:	e002      	b.n	802e4c0 <_dtoa_r+0x730>
 802e4ba:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 802e4bc:	9c09      	ldr	r4, [sp, #36]	; 0x24
 802e4be:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 802e4c0:	b164      	cbz	r4, 802e4dc <_dtoa_r+0x74c>
 802e4c2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 802e4c4:	2b00      	cmp	r3, #0
 802e4c6:	dd09      	ble.n	802e4dc <_dtoa_r+0x74c>
 802e4c8:	42a3      	cmp	r3, r4
 802e4ca:	9a09      	ldr	r2, [sp, #36]	; 0x24
 802e4cc:	bfa8      	it	ge
 802e4ce:	4623      	movge	r3, r4
 802e4d0:	1ad2      	subs	r2, r2, r3
 802e4d2:	9209      	str	r2, [sp, #36]	; 0x24
 802e4d4:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 802e4d6:	1ae4      	subs	r4, r4, r3
 802e4d8:	1ad3      	subs	r3, r2, r3
 802e4da:	930a      	str	r3, [sp, #40]	; 0x28
 802e4dc:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 802e4de:	2b00      	cmp	r3, #0
 802e4e0:	dd20      	ble.n	802e524 <_dtoa_r+0x794>
 802e4e2:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 802e4e4:	b1c3      	cbz	r3, 802e518 <_dtoa_r+0x788>
 802e4e6:	2d00      	cmp	r5, #0
 802e4e8:	dd10      	ble.n	802e50c <_dtoa_r+0x77c>
 802e4ea:	4631      	mov	r1, r6
 802e4ec:	462a      	mov	r2, r5
 802e4ee:	4650      	mov	r0, sl
 802e4f0:	f000 fb90 	bl	802ec14 <__pow5mult>
 802e4f4:	4606      	mov	r6, r0
 802e4f6:	4631      	mov	r1, r6
 802e4f8:	9a07      	ldr	r2, [sp, #28]
 802e4fa:	4650      	mov	r0, sl
 802e4fc:	f000 faf8 	bl	802eaf0 <__multiply>
 802e500:	9907      	ldr	r1, [sp, #28]
 802e502:	4607      	mov	r7, r0
 802e504:	4650      	mov	r0, sl
 802e506:	f000 fa48 	bl	802e99a <_Bfree>
 802e50a:	9707      	str	r7, [sp, #28]
 802e50c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 802e50e:	1b5a      	subs	r2, r3, r5
 802e510:	d008      	beq.n	802e524 <_dtoa_r+0x794>
 802e512:	4650      	mov	r0, sl
 802e514:	9907      	ldr	r1, [sp, #28]
 802e516:	e002      	b.n	802e51e <_dtoa_r+0x78e>
 802e518:	9907      	ldr	r1, [sp, #28]
 802e51a:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 802e51c:	4650      	mov	r0, sl
 802e51e:	f000 fb79 	bl	802ec14 <__pow5mult>
 802e522:	9007      	str	r0, [sp, #28]
 802e524:	4650      	mov	r0, sl
 802e526:	2101      	movs	r1, #1
 802e528:	f000 fad9 	bl	802eade <__i2b>
 802e52c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 802e52e:	2b00      	cmp	r3, #0
 802e530:	4605      	mov	r5, r0
 802e532:	dd0a      	ble.n	802e54a <_dtoa_r+0x7ba>
 802e534:	4629      	mov	r1, r5
 802e536:	461a      	mov	r2, r3
 802e538:	4650      	mov	r0, sl
 802e53a:	f000 fb6b 	bl	802ec14 <__pow5mult>
 802e53e:	9b20      	ldr	r3, [sp, #128]	; 0x80
 802e540:	2b01      	cmp	r3, #1
 802e542:	4605      	mov	r5, r0
 802e544:	dd04      	ble.n	802e550 <_dtoa_r+0x7c0>
 802e546:	2700      	movs	r7, #0
 802e548:	e01b      	b.n	802e582 <_dtoa_r+0x7f2>
 802e54a:	9b20      	ldr	r3, [sp, #128]	; 0x80
 802e54c:	2b01      	cmp	r3, #1
 802e54e:	dc13      	bgt.n	802e578 <_dtoa_r+0x7e8>
 802e550:	9b02      	ldr	r3, [sp, #8]
 802e552:	b98b      	cbnz	r3, 802e578 <_dtoa_r+0x7e8>
 802e554:	9b03      	ldr	r3, [sp, #12]
 802e556:	f3c3 0313 	ubfx	r3, r3, #0, #20
 802e55a:	b97b      	cbnz	r3, 802e57c <_dtoa_r+0x7ec>
 802e55c:	9b03      	ldr	r3, [sp, #12]
 802e55e:	f023 4700 	bic.w	r7, r3, #2147483648	; 0x80000000
 802e562:	0d3f      	lsrs	r7, r7, #20
 802e564:	053f      	lsls	r7, r7, #20
 802e566:	b157      	cbz	r7, 802e57e <_dtoa_r+0x7ee>
 802e568:	9b09      	ldr	r3, [sp, #36]	; 0x24
 802e56a:	3301      	adds	r3, #1
 802e56c:	9309      	str	r3, [sp, #36]	; 0x24
 802e56e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 802e570:	3301      	adds	r3, #1
 802e572:	930a      	str	r3, [sp, #40]	; 0x28
 802e574:	2701      	movs	r7, #1
 802e576:	e002      	b.n	802e57e <_dtoa_r+0x7ee>
 802e578:	2700      	movs	r7, #0
 802e57a:	e000      	b.n	802e57e <_dtoa_r+0x7ee>
 802e57c:	9f02      	ldr	r7, [sp, #8]
 802e57e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 802e580:	b143      	cbz	r3, 802e594 <_dtoa_r+0x804>
 802e582:	692b      	ldr	r3, [r5, #16]
 802e584:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 802e588:	6918      	ldr	r0, [r3, #16]
 802e58a:	f000 fa5b 	bl	802ea44 <__hi0bits>
 802e58e:	f1c0 0020 	rsb	r0, r0, #32
 802e592:	e000      	b.n	802e596 <_dtoa_r+0x806>
 802e594:	2001      	movs	r0, #1
 802e596:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 802e598:	4418      	add	r0, r3
 802e59a:	f010 001f 	ands.w	r0, r0, #31
 802e59e:	d008      	beq.n	802e5b2 <_dtoa_r+0x822>
 802e5a0:	f1c0 0320 	rsb	r3, r0, #32
 802e5a4:	2b04      	cmp	r3, #4
 802e5a6:	dd02      	ble.n	802e5ae <_dtoa_r+0x81e>
 802e5a8:	f1c0 001c 	rsb	r0, r0, #28
 802e5ac:	e002      	b.n	802e5b4 <_dtoa_r+0x824>
 802e5ae:	d008      	beq.n	802e5c2 <_dtoa_r+0x832>
 802e5b0:	4618      	mov	r0, r3
 802e5b2:	301c      	adds	r0, #28
 802e5b4:	9b09      	ldr	r3, [sp, #36]	; 0x24
 802e5b6:	4403      	add	r3, r0
 802e5b8:	9309      	str	r3, [sp, #36]	; 0x24
 802e5ba:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 802e5bc:	4403      	add	r3, r0
 802e5be:	4404      	add	r4, r0
 802e5c0:	930a      	str	r3, [sp, #40]	; 0x28
 802e5c2:	9b09      	ldr	r3, [sp, #36]	; 0x24
 802e5c4:	2b00      	cmp	r3, #0
 802e5c6:	dd05      	ble.n	802e5d4 <_dtoa_r+0x844>
 802e5c8:	4650      	mov	r0, sl
 802e5ca:	9907      	ldr	r1, [sp, #28]
 802e5cc:	461a      	mov	r2, r3
 802e5ce:	f000 fb6f 	bl	802ecb0 <__lshift>
 802e5d2:	9007      	str	r0, [sp, #28]
 802e5d4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 802e5d6:	2b00      	cmp	r3, #0
 802e5d8:	dd05      	ble.n	802e5e6 <_dtoa_r+0x856>
 802e5da:	4629      	mov	r1, r5
 802e5dc:	4650      	mov	r0, sl
 802e5de:	461a      	mov	r2, r3
 802e5e0:	f000 fb66 	bl	802ecb0 <__lshift>
 802e5e4:	4605      	mov	r5, r0
 802e5e6:	9b12      	ldr	r3, [sp, #72]	; 0x48
 802e5e8:	b1eb      	cbz	r3, 802e626 <_dtoa_r+0x896>
 802e5ea:	9807      	ldr	r0, [sp, #28]
 802e5ec:	4629      	mov	r1, r5
 802e5ee:	f000 fbb2 	bl	802ed56 <__mcmp>
 802e5f2:	2800      	cmp	r0, #0
 802e5f4:	da17      	bge.n	802e626 <_dtoa_r+0x896>
 802e5f6:	2300      	movs	r3, #0
 802e5f8:	4650      	mov	r0, sl
 802e5fa:	9907      	ldr	r1, [sp, #28]
 802e5fc:	220a      	movs	r2, #10
 802e5fe:	f000 f9e3 	bl	802e9c8 <__multadd>
 802e602:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 802e604:	9007      	str	r0, [sp, #28]
 802e606:	f10b 3bff 	add.w	fp, fp, #4294967295
 802e60a:	2b00      	cmp	r3, #0
 802e60c:	f000 8170 	beq.w	802e8f0 <_dtoa_r+0xb60>
 802e610:	4631      	mov	r1, r6
 802e612:	2300      	movs	r3, #0
 802e614:	4650      	mov	r0, sl
 802e616:	220a      	movs	r2, #10
 802e618:	f000 f9d6 	bl	802e9c8 <__multadd>
 802e61c:	9b06      	ldr	r3, [sp, #24]
 802e61e:	2b00      	cmp	r3, #0
 802e620:	4606      	mov	r6, r0
 802e622:	dc33      	bgt.n	802e68c <_dtoa_r+0x8fc>
 802e624:	e16d      	b.n	802e902 <_dtoa_r+0xb72>
 802e626:	9b05      	ldr	r3, [sp, #20]
 802e628:	2b00      	cmp	r3, #0
 802e62a:	dc26      	bgt.n	802e67a <_dtoa_r+0x8ea>
 802e62c:	9b20      	ldr	r3, [sp, #128]	; 0x80
 802e62e:	2b02      	cmp	r3, #2
 802e630:	dd23      	ble.n	802e67a <_dtoa_r+0x8ea>
 802e632:	9b05      	ldr	r3, [sp, #20]
 802e634:	9306      	str	r3, [sp, #24]
 802e636:	9b06      	ldr	r3, [sp, #24]
 802e638:	b973      	cbnz	r3, 802e658 <_dtoa_r+0x8c8>
 802e63a:	4629      	mov	r1, r5
 802e63c:	2205      	movs	r2, #5
 802e63e:	4650      	mov	r0, sl
 802e640:	f000 f9c2 	bl	802e9c8 <__multadd>
 802e644:	4605      	mov	r5, r0
 802e646:	4629      	mov	r1, r5
 802e648:	9807      	ldr	r0, [sp, #28]
 802e64a:	f000 fb84 	bl	802ed56 <__mcmp>
 802e64e:	2800      	cmp	r0, #0
 802e650:	dc09      	bgt.n	802e666 <_dtoa_r+0x8d6>
 802e652:	e001      	b.n	802e658 <_dtoa_r+0x8c8>
 802e654:	2500      	movs	r5, #0
 802e656:	462e      	mov	r6, r5
 802e658:	9b21      	ldr	r3, [sp, #132]	; 0x84
 802e65a:	9c08      	ldr	r4, [sp, #32]
 802e65c:	ea6f 0b03 	mvn.w	fp, r3
 802e660:	e008      	b.n	802e674 <_dtoa_r+0x8e4>
 802e662:	46bb      	mov	fp, r7
 802e664:	462e      	mov	r6, r5
 802e666:	9b08      	ldr	r3, [sp, #32]
 802e668:	9a08      	ldr	r2, [sp, #32]
 802e66a:	1c5c      	adds	r4, r3, #1
 802e66c:	2331      	movs	r3, #49	; 0x31
 802e66e:	7013      	strb	r3, [r2, #0]
 802e670:	f10b 0b01 	add.w	fp, fp, #1
 802e674:	46b1      	mov	r9, r6
 802e676:	2600      	movs	r6, #0
 802e678:	e114      	b.n	802e8a4 <_dtoa_r+0xb14>
 802e67a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 802e67c:	b923      	cbnz	r3, 802e688 <_dtoa_r+0x8f8>
 802e67e:	9b05      	ldr	r3, [sp, #20]
 802e680:	9306      	str	r3, [sp, #24]
 802e682:	9f08      	ldr	r7, [sp, #32]
 802e684:	9c07      	ldr	r4, [sp, #28]
 802e686:	e0cc      	b.n	802e822 <_dtoa_r+0xa92>
 802e688:	9b05      	ldr	r3, [sp, #20]
 802e68a:	9306      	str	r3, [sp, #24]
 802e68c:	2c00      	cmp	r4, #0
 802e68e:	dd05      	ble.n	802e69c <_dtoa_r+0x90c>
 802e690:	4631      	mov	r1, r6
 802e692:	4650      	mov	r0, sl
 802e694:	4622      	mov	r2, r4
 802e696:	f000 fb0b 	bl	802ecb0 <__lshift>
 802e69a:	4606      	mov	r6, r0
 802e69c:	b1b7      	cbz	r7, 802e6cc <_dtoa_r+0x93c>
 802e69e:	6871      	ldr	r1, [r6, #4]
 802e6a0:	4650      	mov	r0, sl
 802e6a2:	f000 f945 	bl	802e930 <_Balloc>
 802e6a6:	6932      	ldr	r2, [r6, #16]
 802e6a8:	3202      	adds	r2, #2
 802e6aa:	4604      	mov	r4, r0
 802e6ac:	f106 010c 	add.w	r1, r6, #12
 802e6b0:	0092      	lsls	r2, r2, #2
 802e6b2:	300c      	adds	r0, #12
 802e6b4:	f7fe ff4c 	bl	802d550 <memcpy>
 802e6b8:	4650      	mov	r0, sl
 802e6ba:	4621      	mov	r1, r4
 802e6bc:	2201      	movs	r2, #1
 802e6be:	f000 faf7 	bl	802ecb0 <__lshift>
 802e6c2:	4681      	mov	r9, r0
 802e6c4:	e003      	b.n	802e6ce <_dtoa_r+0x93e>
 802e6c6:	bf00      	nop
 802e6c8:	40240000 	.word	0x40240000
 802e6cc:	46b1      	mov	r9, r6
 802e6ce:	9f08      	ldr	r7, [sp, #32]
 802e6d0:	9c07      	ldr	r4, [sp, #28]
 802e6d2:	4629      	mov	r1, r5
 802e6d4:	4620      	mov	r0, r4
 802e6d6:	f7ff facb 	bl	802dc70 <quorem>
 802e6da:	4631      	mov	r1, r6
 802e6dc:	9009      	str	r0, [sp, #36]	; 0x24
 802e6de:	f100 0830 	add.w	r8, r0, #48	; 0x30
 802e6e2:	4620      	mov	r0, r4
 802e6e4:	f000 fb37 	bl	802ed56 <__mcmp>
 802e6e8:	464a      	mov	r2, r9
 802e6ea:	9005      	str	r0, [sp, #20]
 802e6ec:	4629      	mov	r1, r5
 802e6ee:	4650      	mov	r0, sl
 802e6f0:	f000 fb4d 	bl	802ed8e <__mdiff>
 802e6f4:	68c2      	ldr	r2, [r0, #12]
 802e6f6:	4603      	mov	r3, r0
 802e6f8:	b93a      	cbnz	r2, 802e70a <_dtoa_r+0x97a>
 802e6fa:	4619      	mov	r1, r3
 802e6fc:	4620      	mov	r0, r4
 802e6fe:	9307      	str	r3, [sp, #28]
 802e700:	f000 fb29 	bl	802ed56 <__mcmp>
 802e704:	9b07      	ldr	r3, [sp, #28]
 802e706:	4602      	mov	r2, r0
 802e708:	e000      	b.n	802e70c <_dtoa_r+0x97c>
 802e70a:	2201      	movs	r2, #1
 802e70c:	4650      	mov	r0, sl
 802e70e:	4619      	mov	r1, r3
 802e710:	9207      	str	r2, [sp, #28]
 802e712:	f000 f942 	bl	802e99a <_Bfree>
 802e716:	9a07      	ldr	r2, [sp, #28]
 802e718:	b9a2      	cbnz	r2, 802e744 <_dtoa_r+0x9b4>
 802e71a:	9b20      	ldr	r3, [sp, #128]	; 0x80
 802e71c:	b993      	cbnz	r3, 802e744 <_dtoa_r+0x9b4>
 802e71e:	9b02      	ldr	r3, [sp, #8]
 802e720:	f003 0301 	and.w	r3, r3, #1
 802e724:	b973      	cbnz	r3, 802e744 <_dtoa_r+0x9b4>
 802e726:	f1b8 0f39 	cmp.w	r8, #57	; 0x39
 802e72a:	463b      	mov	r3, r7
 802e72c:	9407      	str	r4, [sp, #28]
 802e72e:	d040      	beq.n	802e7b2 <_dtoa_r+0xa22>
 802e730:	9b05      	ldr	r3, [sp, #20]
 802e732:	2b00      	cmp	r3, #0
 802e734:	bfc8      	it	gt
 802e736:	9b09      	ldrgt	r3, [sp, #36]	; 0x24
 802e738:	f107 0401 	add.w	r4, r7, #1
 802e73c:	bfc8      	it	gt
 802e73e:	f103 0831 	addgt.w	r8, r3, #49	; 0x31
 802e742:	e03d      	b.n	802e7c0 <_dtoa_r+0xa30>
 802e744:	9b05      	ldr	r3, [sp, #20]
 802e746:	2b00      	cmp	r3, #0
 802e748:	da04      	bge.n	802e754 <_dtoa_r+0x9c4>
 802e74a:	2a00      	cmp	r2, #0
 802e74c:	46c4      	mov	ip, r8
 802e74e:	9407      	str	r4, [sp, #28]
 802e750:	dc08      	bgt.n	802e764 <_dtoa_r+0x9d4>
 802e752:	e021      	b.n	802e798 <_dtoa_r+0xa08>
 802e754:	d124      	bne.n	802e7a0 <_dtoa_r+0xa10>
 802e756:	9b20      	ldr	r3, [sp, #128]	; 0x80
 802e758:	bb13      	cbnz	r3, 802e7a0 <_dtoa_r+0xa10>
 802e75a:	9b02      	ldr	r3, [sp, #8]
 802e75c:	f003 0301 	and.w	r3, r3, #1
 802e760:	b9f3      	cbnz	r3, 802e7a0 <_dtoa_r+0xa10>
 802e762:	e7f2      	b.n	802e74a <_dtoa_r+0x9ba>
 802e764:	4621      	mov	r1, r4
 802e766:	2201      	movs	r2, #1
 802e768:	4650      	mov	r0, sl
 802e76a:	9705      	str	r7, [sp, #20]
 802e76c:	f8cd 8008 	str.w	r8, [sp, #8]
 802e770:	f000 fa9e 	bl	802ecb0 <__lshift>
 802e774:	4629      	mov	r1, r5
 802e776:	9007      	str	r0, [sp, #28]
 802e778:	f000 faed 	bl	802ed56 <__mcmp>
 802e77c:	2800      	cmp	r0, #0
 802e77e:	f8dd c008 	ldr.w	ip, [sp, #8]
 802e782:	9b05      	ldr	r3, [sp, #20]
 802e784:	dc03      	bgt.n	802e78e <_dtoa_r+0x9fe>
 802e786:	d107      	bne.n	802e798 <_dtoa_r+0xa08>
 802e788:	f018 0f01 	tst.w	r8, #1
 802e78c:	d004      	beq.n	802e798 <_dtoa_r+0xa08>
 802e78e:	f1b8 0f39 	cmp.w	r8, #57	; 0x39
 802e792:	d00e      	beq.n	802e7b2 <_dtoa_r+0xa22>
 802e794:	f108 0c01 	add.w	ip, r8, #1
 802e798:	1c7c      	adds	r4, r7, #1
 802e79a:	f887 c000 	strb.w	ip, [r7]
 802e79e:	e081      	b.n	802e8a4 <_dtoa_r+0xb14>
 802e7a0:	2a00      	cmp	r2, #0
 802e7a2:	f107 0201 	add.w	r2, r7, #1
 802e7a6:	dd0e      	ble.n	802e7c6 <_dtoa_r+0xa36>
 802e7a8:	f1b8 0f39 	cmp.w	r8, #57	; 0x39
 802e7ac:	463b      	mov	r3, r7
 802e7ae:	9407      	str	r4, [sp, #28]
 802e7b0:	d103      	bne.n	802e7ba <_dtoa_r+0xa2a>
 802e7b2:	2239      	movs	r2, #57	; 0x39
 802e7b4:	3701      	adds	r7, #1
 802e7b6:	701a      	strb	r2, [r3, #0]
 802e7b8:	e057      	b.n	802e86a <_dtoa_r+0xada>
 802e7ba:	4614      	mov	r4, r2
 802e7bc:	f108 0801 	add.w	r8, r8, #1
 802e7c0:	f887 8000 	strb.w	r8, [r7]
 802e7c4:	e06e      	b.n	802e8a4 <_dtoa_r+0xb14>
 802e7c6:	9b08      	ldr	r3, [sp, #32]
 802e7c8:	f802 8c01 	strb.w	r8, [r2, #-1]
 802e7cc:	1ad3      	subs	r3, r2, r3
 802e7ce:	4617      	mov	r7, r2
 802e7d0:	9a06      	ldr	r2, [sp, #24]
 802e7d2:	4293      	cmp	r3, r2
 802e7d4:	d03a      	beq.n	802e84c <_dtoa_r+0xabc>
 802e7d6:	4621      	mov	r1, r4
 802e7d8:	220a      	movs	r2, #10
 802e7da:	2300      	movs	r3, #0
 802e7dc:	4650      	mov	r0, sl
 802e7de:	f000 f8f3 	bl	802e9c8 <__multadd>
 802e7e2:	454e      	cmp	r6, r9
 802e7e4:	4604      	mov	r4, r0
 802e7e6:	4631      	mov	r1, r6
 802e7e8:	4650      	mov	r0, sl
 802e7ea:	f04f 020a 	mov.w	r2, #10
 802e7ee:	f04f 0300 	mov.w	r3, #0
 802e7f2:	d104      	bne.n	802e7fe <_dtoa_r+0xa6e>
 802e7f4:	f000 f8e8 	bl	802e9c8 <__multadd>
 802e7f8:	4606      	mov	r6, r0
 802e7fa:	4681      	mov	r9, r0
 802e7fc:	e769      	b.n	802e6d2 <_dtoa_r+0x942>
 802e7fe:	f000 f8e3 	bl	802e9c8 <__multadd>
 802e802:	4649      	mov	r1, r9
 802e804:	4606      	mov	r6, r0
 802e806:	220a      	movs	r2, #10
 802e808:	4650      	mov	r0, sl
 802e80a:	2300      	movs	r3, #0
 802e80c:	f000 f8dc 	bl	802e9c8 <__multadd>
 802e810:	4681      	mov	r9, r0
 802e812:	e75e      	b.n	802e6d2 <_dtoa_r+0x942>
 802e814:	4621      	mov	r1, r4
 802e816:	4650      	mov	r0, sl
 802e818:	220a      	movs	r2, #10
 802e81a:	2300      	movs	r3, #0
 802e81c:	f000 f8d4 	bl	802e9c8 <__multadd>
 802e820:	4604      	mov	r4, r0
 802e822:	4620      	mov	r0, r4
 802e824:	4629      	mov	r1, r5
 802e826:	f7ff fa23 	bl	802dc70 <quorem>
 802e82a:	f100 0830 	add.w	r8, r0, #48	; 0x30
 802e82e:	f807 8b01 	strb.w	r8, [r7], #1
 802e832:	9b08      	ldr	r3, [sp, #32]
 802e834:	9a06      	ldr	r2, [sp, #24]
 802e836:	1afb      	subs	r3, r7, r3
 802e838:	4293      	cmp	r3, r2
 802e83a:	dbeb      	blt.n	802e814 <_dtoa_r+0xa84>
 802e83c:	9b08      	ldr	r3, [sp, #32]
 802e83e:	2a01      	cmp	r2, #1
 802e840:	bfac      	ite	ge
 802e842:	189b      	addge	r3, r3, r2
 802e844:	3301      	addlt	r3, #1
 802e846:	46b1      	mov	r9, r6
 802e848:	461f      	mov	r7, r3
 802e84a:	2600      	movs	r6, #0
 802e84c:	4621      	mov	r1, r4
 802e84e:	2201      	movs	r2, #1
 802e850:	4650      	mov	r0, sl
 802e852:	f000 fa2d 	bl	802ecb0 <__lshift>
 802e856:	4629      	mov	r1, r5
 802e858:	9007      	str	r0, [sp, #28]
 802e85a:	f000 fa7c 	bl	802ed56 <__mcmp>
 802e85e:	2800      	cmp	r0, #0
 802e860:	dc03      	bgt.n	802e86a <_dtoa_r+0xada>
 802e862:	d116      	bne.n	802e892 <_dtoa_r+0xb02>
 802e864:	f018 0f01 	tst.w	r8, #1
 802e868:	d013      	beq.n	802e892 <_dtoa_r+0xb02>
 802e86a:	463c      	mov	r4, r7
 802e86c:	f814 3c01 	ldrb.w	r3, [r4, #-1]
 802e870:	2b39      	cmp	r3, #57	; 0x39
 802e872:	f104 32ff 	add.w	r2, r4, #4294967295
 802e876:	d109      	bne.n	802e88c <_dtoa_r+0xafc>
 802e878:	9b08      	ldr	r3, [sp, #32]
 802e87a:	429a      	cmp	r2, r3
 802e87c:	d104      	bne.n	802e888 <_dtoa_r+0xaf8>
 802e87e:	f10b 0b01 	add.w	fp, fp, #1
 802e882:	2331      	movs	r3, #49	; 0x31
 802e884:	9a08      	ldr	r2, [sp, #32]
 802e886:	e002      	b.n	802e88e <_dtoa_r+0xafe>
 802e888:	4614      	mov	r4, r2
 802e88a:	e7ef      	b.n	802e86c <_dtoa_r+0xadc>
 802e88c:	3301      	adds	r3, #1
 802e88e:	7013      	strb	r3, [r2, #0]
 802e890:	e008      	b.n	802e8a4 <_dtoa_r+0xb14>
 802e892:	463c      	mov	r4, r7
 802e894:	f814 3c01 	ldrb.w	r3, [r4, #-1]
 802e898:	2b30      	cmp	r3, #48	; 0x30
 802e89a:	f104 32ff 	add.w	r2, r4, #4294967295
 802e89e:	d101      	bne.n	802e8a4 <_dtoa_r+0xb14>
 802e8a0:	4614      	mov	r4, r2
 802e8a2:	e7f7      	b.n	802e894 <_dtoa_r+0xb04>
 802e8a4:	4650      	mov	r0, sl
 802e8a6:	4629      	mov	r1, r5
 802e8a8:	f000 f877 	bl	802e99a <_Bfree>
 802e8ac:	f1b9 0f00 	cmp.w	r9, #0
 802e8b0:	d00c      	beq.n	802e8cc <_dtoa_r+0xb3c>
 802e8b2:	b12e      	cbz	r6, 802e8c0 <_dtoa_r+0xb30>
 802e8b4:	454e      	cmp	r6, r9
 802e8b6:	d003      	beq.n	802e8c0 <_dtoa_r+0xb30>
 802e8b8:	4650      	mov	r0, sl
 802e8ba:	4631      	mov	r1, r6
 802e8bc:	f000 f86d 	bl	802e99a <_Bfree>
 802e8c0:	4650      	mov	r0, sl
 802e8c2:	4649      	mov	r1, r9
 802e8c4:	f000 f869 	bl	802e99a <_Bfree>
 802e8c8:	e000      	b.n	802e8cc <_dtoa_r+0xb3c>
 802e8ca:	46bb      	mov	fp, r7
 802e8cc:	4650      	mov	r0, sl
 802e8ce:	9907      	ldr	r1, [sp, #28]
 802e8d0:	f000 f863 	bl	802e99a <_Bfree>
 802e8d4:	2300      	movs	r3, #0
 802e8d6:	9a22      	ldr	r2, [sp, #136]	; 0x88
 802e8d8:	7023      	strb	r3, [r4, #0]
 802e8da:	f10b 0301 	add.w	r3, fp, #1
 802e8de:	6013      	str	r3, [r2, #0]
 802e8e0:	9b24      	ldr	r3, [sp, #144]	; 0x90
 802e8e2:	b11b      	cbz	r3, 802e8ec <_dtoa_r+0xb5c>
 802e8e4:	601c      	str	r4, [r3, #0]
 802e8e6:	e001      	b.n	802e8ec <_dtoa_r+0xb5c>
 802e8e8:	480a      	ldr	r0, [pc, #40]	; (802e914 <_dtoa_r+0xb84>)
 802e8ea:	e00f      	b.n	802e90c <_dtoa_r+0xb7c>
 802e8ec:	9808      	ldr	r0, [sp, #32]
 802e8ee:	e00d      	b.n	802e90c <_dtoa_r+0xb7c>
 802e8f0:	9b06      	ldr	r3, [sp, #24]
 802e8f2:	2b00      	cmp	r3, #0
 802e8f4:	f73f aec5 	bgt.w	802e682 <_dtoa_r+0x8f2>
 802e8f8:	9b20      	ldr	r3, [sp, #128]	; 0x80
 802e8fa:	2b02      	cmp	r3, #2
 802e8fc:	f73f ae9b 	bgt.w	802e636 <_dtoa_r+0x8a6>
 802e900:	e6bf      	b.n	802e682 <_dtoa_r+0x8f2>
 802e902:	9b20      	ldr	r3, [sp, #128]	; 0x80
 802e904:	2b02      	cmp	r3, #2
 802e906:	f73f ae96 	bgt.w	802e636 <_dtoa_r+0x8a6>
 802e90a:	e6bf      	b.n	802e68c <_dtoa_r+0x8fc>
 802e90c:	b017      	add	sp, #92	; 0x5c
 802e90e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802e912:	bf00      	nop
 802e914:	08031a42 	.word	0x08031a42

0802e918 <_localeconv_r>:
 802e918:	4800      	ldr	r0, [pc, #0]	; (802e91c <_localeconv_r+0x4>)
 802e91a:	4770      	bx	lr
 802e91c:	1ffe9698 	.word	0x1ffe9698

0802e920 <malloc>:
 802e920:	4b02      	ldr	r3, [pc, #8]	; (802e92c <malloc+0xc>)
 802e922:	4601      	mov	r1, r0
 802e924:	6818      	ldr	r0, [r3, #0]
 802e926:	f000 baf1 	b.w	802ef0c <_malloc_r>
 802e92a:	bf00      	nop
 802e92c:	1ffe9694 	.word	0x1ffe9694

0802e930 <_Balloc>:
 802e930:	b570      	push	{r4, r5, r6, lr}
 802e932:	6a45      	ldr	r5, [r0, #36]	; 0x24
 802e934:	4604      	mov	r4, r0
 802e936:	460e      	mov	r6, r1
 802e938:	b93d      	cbnz	r5, 802e94a <_Balloc+0x1a>
 802e93a:	2010      	movs	r0, #16
 802e93c:	f7ff fff0 	bl	802e920 <malloc>
 802e940:	6260      	str	r0, [r4, #36]	; 0x24
 802e942:	6045      	str	r5, [r0, #4]
 802e944:	6085      	str	r5, [r0, #8]
 802e946:	6005      	str	r5, [r0, #0]
 802e948:	60c5      	str	r5, [r0, #12]
 802e94a:	6a65      	ldr	r5, [r4, #36]	; 0x24
 802e94c:	68eb      	ldr	r3, [r5, #12]
 802e94e:	b143      	cbz	r3, 802e962 <_Balloc+0x32>
 802e950:	6a63      	ldr	r3, [r4, #36]	; 0x24
 802e952:	68db      	ldr	r3, [r3, #12]
 802e954:	f853 0026 	ldr.w	r0, [r3, r6, lsl #2]
 802e958:	b178      	cbz	r0, 802e97a <_Balloc+0x4a>
 802e95a:	6802      	ldr	r2, [r0, #0]
 802e95c:	f843 2026 	str.w	r2, [r3, r6, lsl #2]
 802e960:	e017      	b.n	802e992 <_Balloc+0x62>
 802e962:	4620      	mov	r0, r4
 802e964:	2104      	movs	r1, #4
 802e966:	2221      	movs	r2, #33	; 0x21
 802e968:	f000 fac2 	bl	802eef0 <_calloc_r>
 802e96c:	6a63      	ldr	r3, [r4, #36]	; 0x24
 802e96e:	60e8      	str	r0, [r5, #12]
 802e970:	68db      	ldr	r3, [r3, #12]
 802e972:	2b00      	cmp	r3, #0
 802e974:	d1ec      	bne.n	802e950 <_Balloc+0x20>
 802e976:	2000      	movs	r0, #0
 802e978:	bd70      	pop	{r4, r5, r6, pc}
 802e97a:	2101      	movs	r1, #1
 802e97c:	fa01 f506 	lsl.w	r5, r1, r6
 802e980:	1d6a      	adds	r2, r5, #5
 802e982:	4620      	mov	r0, r4
 802e984:	0092      	lsls	r2, r2, #2
 802e986:	f000 fab3 	bl	802eef0 <_calloc_r>
 802e98a:	2800      	cmp	r0, #0
 802e98c:	d0f3      	beq.n	802e976 <_Balloc+0x46>
 802e98e:	6046      	str	r6, [r0, #4]
 802e990:	6085      	str	r5, [r0, #8]
 802e992:	2300      	movs	r3, #0
 802e994:	6103      	str	r3, [r0, #16]
 802e996:	60c3      	str	r3, [r0, #12]
 802e998:	bd70      	pop	{r4, r5, r6, pc}

0802e99a <_Bfree>:
 802e99a:	b570      	push	{r4, r5, r6, lr}
 802e99c:	6a44      	ldr	r4, [r0, #36]	; 0x24
 802e99e:	4606      	mov	r6, r0
 802e9a0:	460d      	mov	r5, r1
 802e9a2:	b93c      	cbnz	r4, 802e9b4 <_Bfree+0x1a>
 802e9a4:	2010      	movs	r0, #16
 802e9a6:	f7ff ffbb 	bl	802e920 <malloc>
 802e9aa:	6270      	str	r0, [r6, #36]	; 0x24
 802e9ac:	6044      	str	r4, [r0, #4]
 802e9ae:	6084      	str	r4, [r0, #8]
 802e9b0:	6004      	str	r4, [r0, #0]
 802e9b2:	60c4      	str	r4, [r0, #12]
 802e9b4:	b13d      	cbz	r5, 802e9c6 <_Bfree+0x2c>
 802e9b6:	6a73      	ldr	r3, [r6, #36]	; 0x24
 802e9b8:	686a      	ldr	r2, [r5, #4]
 802e9ba:	68db      	ldr	r3, [r3, #12]
 802e9bc:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 802e9c0:	6029      	str	r1, [r5, #0]
 802e9c2:	f843 5022 	str.w	r5, [r3, r2, lsl #2]
 802e9c6:	bd70      	pop	{r4, r5, r6, pc}

0802e9c8 <__multadd>:
 802e9c8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 802e9cc:	690f      	ldr	r7, [r1, #16]
 802e9ce:	4698      	mov	r8, r3
 802e9d0:	4606      	mov	r6, r0
 802e9d2:	460c      	mov	r4, r1
 802e9d4:	f101 0e14 	add.w	lr, r1, #20
 802e9d8:	2300      	movs	r3, #0
 802e9da:	f8de 0000 	ldr.w	r0, [lr]
 802e9de:	b285      	uxth	r5, r0
 802e9e0:	0c01      	lsrs	r1, r0, #16
 802e9e2:	fb02 8505 	mla	r5, r2, r5, r8
 802e9e6:	4351      	muls	r1, r2
 802e9e8:	eb01 4115 	add.w	r1, r1, r5, lsr #16
 802e9ec:	3301      	adds	r3, #1
 802e9ee:	b2ad      	uxth	r5, r5
 802e9f0:	ea4f 4811 	mov.w	r8, r1, lsr #16
 802e9f4:	42bb      	cmp	r3, r7
 802e9f6:	eb05 4101 	add.w	r1, r5, r1, lsl #16
 802e9fa:	f84e 1b04 	str.w	r1, [lr], #4
 802e9fe:	dbec      	blt.n	802e9da <__multadd+0x12>
 802ea00:	f1b8 0f00 	cmp.w	r8, #0
 802ea04:	d01b      	beq.n	802ea3e <__multadd+0x76>
 802ea06:	68a3      	ldr	r3, [r4, #8]
 802ea08:	429f      	cmp	r7, r3
 802ea0a:	db12      	blt.n	802ea32 <__multadd+0x6a>
 802ea0c:	6861      	ldr	r1, [r4, #4]
 802ea0e:	4630      	mov	r0, r6
 802ea10:	3101      	adds	r1, #1
 802ea12:	f7ff ff8d 	bl	802e930 <_Balloc>
 802ea16:	6922      	ldr	r2, [r4, #16]
 802ea18:	3202      	adds	r2, #2
 802ea1a:	f104 010c 	add.w	r1, r4, #12
 802ea1e:	4605      	mov	r5, r0
 802ea20:	0092      	lsls	r2, r2, #2
 802ea22:	300c      	adds	r0, #12
 802ea24:	f7fe fd94 	bl	802d550 <memcpy>
 802ea28:	4621      	mov	r1, r4
 802ea2a:	4630      	mov	r0, r6
 802ea2c:	f7ff ffb5 	bl	802e99a <_Bfree>
 802ea30:	462c      	mov	r4, r5
 802ea32:	eb04 0387 	add.w	r3, r4, r7, lsl #2
 802ea36:	3701      	adds	r7, #1
 802ea38:	f8c3 8014 	str.w	r8, [r3, #20]
 802ea3c:	6127      	str	r7, [r4, #16]
 802ea3e:	4620      	mov	r0, r4
 802ea40:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0802ea44 <__hi0bits>:
 802ea44:	0c03      	lsrs	r3, r0, #16
 802ea46:	041b      	lsls	r3, r3, #16
 802ea48:	b913      	cbnz	r3, 802ea50 <__hi0bits+0xc>
 802ea4a:	0400      	lsls	r0, r0, #16
 802ea4c:	2310      	movs	r3, #16
 802ea4e:	e000      	b.n	802ea52 <__hi0bits+0xe>
 802ea50:	2300      	movs	r3, #0
 802ea52:	f010 4f7f 	tst.w	r0, #4278190080	; 0xff000000
 802ea56:	bf04      	itt	eq
 802ea58:	0200      	lsleq	r0, r0, #8
 802ea5a:	3308      	addeq	r3, #8
 802ea5c:	f010 4f70 	tst.w	r0, #4026531840	; 0xf0000000
 802ea60:	bf04      	itt	eq
 802ea62:	0100      	lsleq	r0, r0, #4
 802ea64:	3304      	addeq	r3, #4
 802ea66:	f010 4f40 	tst.w	r0, #3221225472	; 0xc0000000
 802ea6a:	bf04      	itt	eq
 802ea6c:	0080      	lsleq	r0, r0, #2
 802ea6e:	3302      	addeq	r3, #2
 802ea70:	2800      	cmp	r0, #0
 802ea72:	db03      	blt.n	802ea7c <__hi0bits+0x38>
 802ea74:	0042      	lsls	r2, r0, #1
 802ea76:	d503      	bpl.n	802ea80 <__hi0bits+0x3c>
 802ea78:	1c58      	adds	r0, r3, #1
 802ea7a:	4770      	bx	lr
 802ea7c:	4618      	mov	r0, r3
 802ea7e:	4770      	bx	lr
 802ea80:	2020      	movs	r0, #32
 802ea82:	4770      	bx	lr

0802ea84 <__lo0bits>:
 802ea84:	6803      	ldr	r3, [r0, #0]
 802ea86:	f013 0207 	ands.w	r2, r3, #7
 802ea8a:	d00b      	beq.n	802eaa4 <__lo0bits+0x20>
 802ea8c:	07d9      	lsls	r1, r3, #31
 802ea8e:	d422      	bmi.n	802ead6 <__lo0bits+0x52>
 802ea90:	079a      	lsls	r2, r3, #30
 802ea92:	bf4b      	itete	mi
 802ea94:	085b      	lsrmi	r3, r3, #1
 802ea96:	089b      	lsrpl	r3, r3, #2
 802ea98:	6003      	strmi	r3, [r0, #0]
 802ea9a:	6003      	strpl	r3, [r0, #0]
 802ea9c:	bf4c      	ite	mi
 802ea9e:	2001      	movmi	r0, #1
 802eaa0:	2002      	movpl	r0, #2
 802eaa2:	4770      	bx	lr
 802eaa4:	b299      	uxth	r1, r3
 802eaa6:	b909      	cbnz	r1, 802eaac <__lo0bits+0x28>
 802eaa8:	0c1b      	lsrs	r3, r3, #16
 802eaaa:	2210      	movs	r2, #16
 802eaac:	f013 0fff 	tst.w	r3, #255	; 0xff
 802eab0:	bf04      	itt	eq
 802eab2:	0a1b      	lsreq	r3, r3, #8
 802eab4:	3208      	addeq	r2, #8
 802eab6:	0719      	lsls	r1, r3, #28
 802eab8:	bf04      	itt	eq
 802eaba:	091b      	lsreq	r3, r3, #4
 802eabc:	3204      	addeq	r2, #4
 802eabe:	0799      	lsls	r1, r3, #30
 802eac0:	bf04      	itt	eq
 802eac2:	089b      	lsreq	r3, r3, #2
 802eac4:	3202      	addeq	r2, #2
 802eac6:	07d9      	lsls	r1, r3, #31
 802eac8:	d402      	bmi.n	802ead0 <__lo0bits+0x4c>
 802eaca:	085b      	lsrs	r3, r3, #1
 802eacc:	d005      	beq.n	802eada <__lo0bits+0x56>
 802eace:	3201      	adds	r2, #1
 802ead0:	6003      	str	r3, [r0, #0]
 802ead2:	4610      	mov	r0, r2
 802ead4:	4770      	bx	lr
 802ead6:	2000      	movs	r0, #0
 802ead8:	4770      	bx	lr
 802eada:	2020      	movs	r0, #32
 802eadc:	4770      	bx	lr

0802eade <__i2b>:
 802eade:	b510      	push	{r4, lr}
 802eae0:	460c      	mov	r4, r1
 802eae2:	2101      	movs	r1, #1
 802eae4:	f7ff ff24 	bl	802e930 <_Balloc>
 802eae8:	2201      	movs	r2, #1
 802eaea:	6144      	str	r4, [r0, #20]
 802eaec:	6102      	str	r2, [r0, #16]
 802eaee:	bd10      	pop	{r4, pc}

0802eaf0 <__multiply>:
 802eaf0:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802eaf4:	4614      	mov	r4, r2
 802eaf6:	690a      	ldr	r2, [r1, #16]
 802eaf8:	6923      	ldr	r3, [r4, #16]
 802eafa:	429a      	cmp	r2, r3
 802eafc:	bfb8      	it	lt
 802eafe:	460b      	movlt	r3, r1
 802eb00:	4688      	mov	r8, r1
 802eb02:	bfbc      	itt	lt
 802eb04:	46a0      	movlt	r8, r4
 802eb06:	461c      	movlt	r4, r3
 802eb08:	f8d8 7010 	ldr.w	r7, [r8, #16]
 802eb0c:	f8d4 9010 	ldr.w	r9, [r4, #16]
 802eb10:	f8d8 3008 	ldr.w	r3, [r8, #8]
 802eb14:	f8d8 1004 	ldr.w	r1, [r8, #4]
 802eb18:	eb07 0609 	add.w	r6, r7, r9
 802eb1c:	429e      	cmp	r6, r3
 802eb1e:	bfc8      	it	gt
 802eb20:	3101      	addgt	r1, #1
 802eb22:	f7ff ff05 	bl	802e930 <_Balloc>
 802eb26:	f100 0514 	add.w	r5, r0, #20
 802eb2a:	eb05 0c86 	add.w	ip, r5, r6, lsl #2
 802eb2e:	462b      	mov	r3, r5
 802eb30:	4563      	cmp	r3, ip
 802eb32:	d203      	bcs.n	802eb3c <__multiply+0x4c>
 802eb34:	2200      	movs	r2, #0
 802eb36:	f843 2b04 	str.w	r2, [r3], #4
 802eb3a:	e7f9      	b.n	802eb30 <__multiply+0x40>
 802eb3c:	f104 0214 	add.w	r2, r4, #20
 802eb40:	f108 0114 	add.w	r1, r8, #20
 802eb44:	eb02 0389 	add.w	r3, r2, r9, lsl #2
 802eb48:	eb01 0787 	add.w	r7, r1, r7, lsl #2
 802eb4c:	9300      	str	r3, [sp, #0]
 802eb4e:	9b00      	ldr	r3, [sp, #0]
 802eb50:	9201      	str	r2, [sp, #4]
 802eb52:	429a      	cmp	r2, r3
 802eb54:	d257      	bcs.n	802ec06 <__multiply+0x116>
 802eb56:	f8b2 b000 	ldrh.w	fp, [r2]
 802eb5a:	f1bb 0f00 	cmp.w	fp, #0
 802eb5e:	d023      	beq.n	802eba8 <__multiply+0xb8>
 802eb60:	4689      	mov	r9, r1
 802eb62:	46ae      	mov	lr, r5
 802eb64:	f04f 0800 	mov.w	r8, #0
 802eb68:	f859 4b04 	ldr.w	r4, [r9], #4
 802eb6c:	f8be a000 	ldrh.w	sl, [lr]
 802eb70:	b2a3      	uxth	r3, r4
 802eb72:	fb0b a303 	mla	r3, fp, r3, sl
 802eb76:	ea4f 4a14 	mov.w	sl, r4, lsr #16
 802eb7a:	f8de 4000 	ldr.w	r4, [lr]
 802eb7e:	4443      	add	r3, r8
 802eb80:	ea4f 4814 	mov.w	r8, r4, lsr #16
 802eb84:	fb0b 840a 	mla	r4, fp, sl, r8
 802eb88:	eb04 4413 	add.w	r4, r4, r3, lsr #16
 802eb8c:	46f2      	mov	sl, lr
 802eb8e:	b29b      	uxth	r3, r3
 802eb90:	ea43 4304 	orr.w	r3, r3, r4, lsl #16
 802eb94:	454f      	cmp	r7, r9
 802eb96:	ea4f 4814 	mov.w	r8, r4, lsr #16
 802eb9a:	f84a 3b04 	str.w	r3, [sl], #4
 802eb9e:	d901      	bls.n	802eba4 <__multiply+0xb4>
 802eba0:	46d6      	mov	lr, sl
 802eba2:	e7e1      	b.n	802eb68 <__multiply+0x78>
 802eba4:	f8ce 8004 	str.w	r8, [lr, #4]
 802eba8:	9b01      	ldr	r3, [sp, #4]
 802ebaa:	f8b3 a002 	ldrh.w	sl, [r3, #2]
 802ebae:	3204      	adds	r2, #4
 802ebb0:	f1ba 0f00 	cmp.w	sl, #0
 802ebb4:	d021      	beq.n	802ebfa <__multiply+0x10a>
 802ebb6:	682b      	ldr	r3, [r5, #0]
 802ebb8:	462c      	mov	r4, r5
 802ebba:	4689      	mov	r9, r1
 802ebbc:	f04f 0800 	mov.w	r8, #0
 802ebc0:	f8b9 e000 	ldrh.w	lr, [r9]
 802ebc4:	f8b4 b002 	ldrh.w	fp, [r4, #2]
 802ebc8:	fb0a be0e 	mla	lr, sl, lr, fp
 802ebcc:	44f0      	add	r8, lr
 802ebce:	46a3      	mov	fp, r4
 802ebd0:	b29b      	uxth	r3, r3
 802ebd2:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 802ebd6:	f84b 3b04 	str.w	r3, [fp], #4
 802ebda:	f859 3b04 	ldr.w	r3, [r9], #4
 802ebde:	f8b4 e004 	ldrh.w	lr, [r4, #4]
 802ebe2:	0c1b      	lsrs	r3, r3, #16
 802ebe4:	fb0a e303 	mla	r3, sl, r3, lr
 802ebe8:	eb03 4318 	add.w	r3, r3, r8, lsr #16
 802ebec:	45b9      	cmp	r9, r7
 802ebee:	ea4f 4813 	mov.w	r8, r3, lsr #16
 802ebf2:	d201      	bcs.n	802ebf8 <__multiply+0x108>
 802ebf4:	465c      	mov	r4, fp
 802ebf6:	e7e3      	b.n	802ebc0 <__multiply+0xd0>
 802ebf8:	6063      	str	r3, [r4, #4]
 802ebfa:	3504      	adds	r5, #4
 802ebfc:	e7a7      	b.n	802eb4e <__multiply+0x5e>
 802ebfe:	f85c 3d04 	ldr.w	r3, [ip, #-4]!
 802ec02:	b913      	cbnz	r3, 802ec0a <__multiply+0x11a>
 802ec04:	3e01      	subs	r6, #1
 802ec06:	2e00      	cmp	r6, #0
 802ec08:	dcf9      	bgt.n	802ebfe <__multiply+0x10e>
 802ec0a:	6106      	str	r6, [r0, #16]
 802ec0c:	b003      	add	sp, #12
 802ec0e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	...

0802ec14 <__pow5mult>:
 802ec14:	f012 0303 	ands.w	r3, r2, #3
 802ec18:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 802ec1c:	4606      	mov	r6, r0
 802ec1e:	460f      	mov	r7, r1
 802ec20:	4615      	mov	r5, r2
 802ec22:	d007      	beq.n	802ec34 <__pow5mult+0x20>
 802ec24:	3b01      	subs	r3, #1
 802ec26:	4a21      	ldr	r2, [pc, #132]	; (802ecac <__pow5mult+0x98>)
 802ec28:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 802ec2c:	2300      	movs	r3, #0
 802ec2e:	f7ff fecb 	bl	802e9c8 <__multadd>
 802ec32:	4607      	mov	r7, r0
 802ec34:	10ad      	asrs	r5, r5, #2
 802ec36:	d035      	beq.n	802eca4 <__pow5mult+0x90>
 802ec38:	6a74      	ldr	r4, [r6, #36]	; 0x24
 802ec3a:	b93c      	cbnz	r4, 802ec4c <__pow5mult+0x38>
 802ec3c:	2010      	movs	r0, #16
 802ec3e:	f7ff fe6f 	bl	802e920 <malloc>
 802ec42:	6270      	str	r0, [r6, #36]	; 0x24
 802ec44:	6044      	str	r4, [r0, #4]
 802ec46:	6084      	str	r4, [r0, #8]
 802ec48:	6004      	str	r4, [r0, #0]
 802ec4a:	60c4      	str	r4, [r0, #12]
 802ec4c:	f8d6 8024 	ldr.w	r8, [r6, #36]	; 0x24
 802ec50:	f8d8 4008 	ldr.w	r4, [r8, #8]
 802ec54:	b97c      	cbnz	r4, 802ec76 <__pow5mult+0x62>
 802ec56:	4630      	mov	r0, r6
 802ec58:	f240 2171 	movw	r1, #625	; 0x271
 802ec5c:	f7ff ff3f 	bl	802eade <__i2b>
 802ec60:	2300      	movs	r3, #0
 802ec62:	f8c8 0008 	str.w	r0, [r8, #8]
 802ec66:	4604      	mov	r4, r0
 802ec68:	6003      	str	r3, [r0, #0]
 802ec6a:	e004      	b.n	802ec76 <__pow5mult+0x62>
 802ec6c:	106d      	asrs	r5, r5, #1
 802ec6e:	d019      	beq.n	802eca4 <__pow5mult+0x90>
 802ec70:	6820      	ldr	r0, [r4, #0]
 802ec72:	b170      	cbz	r0, 802ec92 <__pow5mult+0x7e>
 802ec74:	4604      	mov	r4, r0
 802ec76:	07eb      	lsls	r3, r5, #31
 802ec78:	d5f8      	bpl.n	802ec6c <__pow5mult+0x58>
 802ec7a:	4639      	mov	r1, r7
 802ec7c:	4622      	mov	r2, r4
 802ec7e:	4630      	mov	r0, r6
 802ec80:	f7ff ff36 	bl	802eaf0 <__multiply>
 802ec84:	4639      	mov	r1, r7
 802ec86:	4680      	mov	r8, r0
 802ec88:	4630      	mov	r0, r6
 802ec8a:	f7ff fe86 	bl	802e99a <_Bfree>
 802ec8e:	4647      	mov	r7, r8
 802ec90:	e7ec      	b.n	802ec6c <__pow5mult+0x58>
 802ec92:	4630      	mov	r0, r6
 802ec94:	4621      	mov	r1, r4
 802ec96:	4622      	mov	r2, r4
 802ec98:	f7ff ff2a 	bl	802eaf0 <__multiply>
 802ec9c:	2300      	movs	r3, #0
 802ec9e:	6020      	str	r0, [r4, #0]
 802eca0:	6003      	str	r3, [r0, #0]
 802eca2:	e7e7      	b.n	802ec74 <__pow5mult+0x60>
 802eca4:	4638      	mov	r0, r7
 802eca6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802ecaa:	bf00      	nop
 802ecac:	08031b50 	.word	0x08031b50

0802ecb0 <__lshift>:
 802ecb0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 802ecb4:	460c      	mov	r4, r1
 802ecb6:	ea4f 1a62 	mov.w	sl, r2, asr #5
 802ecba:	6923      	ldr	r3, [r4, #16]
 802ecbc:	6849      	ldr	r1, [r1, #4]
 802ecbe:	eb0a 0903 	add.w	r9, sl, r3
 802ecc2:	68a3      	ldr	r3, [r4, #8]
 802ecc4:	4607      	mov	r7, r0
 802ecc6:	4616      	mov	r6, r2
 802ecc8:	f109 0501 	add.w	r5, r9, #1
 802eccc:	429d      	cmp	r5, r3
 802ecce:	dd02      	ble.n	802ecd6 <__lshift+0x26>
 802ecd0:	3101      	adds	r1, #1
 802ecd2:	005b      	lsls	r3, r3, #1
 802ecd4:	e7fa      	b.n	802eccc <__lshift+0x1c>
 802ecd6:	4638      	mov	r0, r7
 802ecd8:	f7ff fe2a 	bl	802e930 <_Balloc>
 802ecdc:	2300      	movs	r3, #0
 802ecde:	4680      	mov	r8, r0
 802ece0:	f100 0114 	add.w	r1, r0, #20
 802ece4:	4553      	cmp	r3, sl
 802ece6:	da04      	bge.n	802ecf2 <__lshift+0x42>
 802ece8:	2200      	movs	r2, #0
 802ecea:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
 802ecee:	3301      	adds	r3, #1
 802ecf0:	e7f8      	b.n	802ece4 <__lshift+0x34>
 802ecf2:	ea2a 73ea 	bic.w	r3, sl, sl, asr #31
 802ecf6:	6920      	ldr	r0, [r4, #16]
 802ecf8:	eb01 0383 	add.w	r3, r1, r3, lsl #2
 802ecfc:	f016 021f 	ands.w	r2, r6, #31
 802ed00:	f104 0114 	add.w	r1, r4, #20
 802ed04:	eb01 0e80 	add.w	lr, r1, r0, lsl #2
 802ed08:	d014      	beq.n	802ed34 <__lshift+0x84>
 802ed0a:	f1c2 0c20 	rsb	ip, r2, #32
 802ed0e:	2000      	movs	r0, #0
 802ed10:	680e      	ldr	r6, [r1, #0]
 802ed12:	4096      	lsls	r6, r2
 802ed14:	4330      	orrs	r0, r6
 802ed16:	469a      	mov	sl, r3
 802ed18:	f843 0b04 	str.w	r0, [r3], #4
 802ed1c:	f851 0b04 	ldr.w	r0, [r1], #4
 802ed20:	4571      	cmp	r1, lr
 802ed22:	fa20 f00c 	lsr.w	r0, r0, ip
 802ed26:	d3f3      	bcc.n	802ed10 <__lshift+0x60>
 802ed28:	f8ca 0004 	str.w	r0, [sl, #4]
 802ed2c:	b148      	cbz	r0, 802ed42 <__lshift+0x92>
 802ed2e:	f109 0502 	add.w	r5, r9, #2
 802ed32:	e006      	b.n	802ed42 <__lshift+0x92>
 802ed34:	3b04      	subs	r3, #4
 802ed36:	f851 2b04 	ldr.w	r2, [r1], #4
 802ed3a:	f843 2f04 	str.w	r2, [r3, #4]!
 802ed3e:	4571      	cmp	r1, lr
 802ed40:	d3f9      	bcc.n	802ed36 <__lshift+0x86>
 802ed42:	3d01      	subs	r5, #1
 802ed44:	4638      	mov	r0, r7
 802ed46:	f8c8 5010 	str.w	r5, [r8, #16]
 802ed4a:	4621      	mov	r1, r4
 802ed4c:	f7ff fe25 	bl	802e99a <_Bfree>
 802ed50:	4640      	mov	r0, r8
 802ed52:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0802ed56 <__mcmp>:
 802ed56:	6903      	ldr	r3, [r0, #16]
 802ed58:	690a      	ldr	r2, [r1, #16]
 802ed5a:	1a9b      	subs	r3, r3, r2
 802ed5c:	b510      	push	{r4, lr}
 802ed5e:	d111      	bne.n	802ed84 <__mcmp+0x2e>
 802ed60:	0092      	lsls	r2, r2, #2
 802ed62:	3014      	adds	r0, #20
 802ed64:	3114      	adds	r1, #20
 802ed66:	1883      	adds	r3, r0, r2
 802ed68:	440a      	add	r2, r1
 802ed6a:	f853 4d04 	ldr.w	r4, [r3, #-4]!
 802ed6e:	f852 1d04 	ldr.w	r1, [r2, #-4]!
 802ed72:	428c      	cmp	r4, r1
 802ed74:	d002      	beq.n	802ed7c <__mcmp+0x26>
 802ed76:	d307      	bcc.n	802ed88 <__mcmp+0x32>
 802ed78:	2001      	movs	r0, #1
 802ed7a:	bd10      	pop	{r4, pc}
 802ed7c:	4283      	cmp	r3, r0
 802ed7e:	d8f4      	bhi.n	802ed6a <__mcmp+0x14>
 802ed80:	2000      	movs	r0, #0
 802ed82:	bd10      	pop	{r4, pc}
 802ed84:	4618      	mov	r0, r3
 802ed86:	bd10      	pop	{r4, pc}
 802ed88:	f04f 30ff 	mov.w	r0, #4294967295
 802ed8c:	bd10      	pop	{r4, pc}

0802ed8e <__mdiff>:
 802ed8e:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 802ed92:	4607      	mov	r7, r0
 802ed94:	460c      	mov	r4, r1
 802ed96:	4608      	mov	r0, r1
 802ed98:	4611      	mov	r1, r2
 802ed9a:	4615      	mov	r5, r2
 802ed9c:	f7ff ffdb 	bl	802ed56 <__mcmp>
 802eda0:	1e06      	subs	r6, r0, #0
 802eda2:	d108      	bne.n	802edb6 <__mdiff+0x28>
 802eda4:	4638      	mov	r0, r7
 802eda6:	4631      	mov	r1, r6
 802eda8:	f7ff fdc2 	bl	802e930 <_Balloc>
 802edac:	2301      	movs	r3, #1
 802edae:	6103      	str	r3, [r0, #16]
 802edb0:	6146      	str	r6, [r0, #20]
 802edb2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 802edb6:	bfbc      	itt	lt
 802edb8:	4623      	movlt	r3, r4
 802edba:	462c      	movlt	r4, r5
 802edbc:	4638      	mov	r0, r7
 802edbe:	6861      	ldr	r1, [r4, #4]
 802edc0:	bfba      	itte	lt
 802edc2:	461d      	movlt	r5, r3
 802edc4:	2601      	movlt	r6, #1
 802edc6:	2600      	movge	r6, #0
 802edc8:	f7ff fdb2 	bl	802e930 <_Balloc>
 802edcc:	692b      	ldr	r3, [r5, #16]
 802edce:	60c6      	str	r6, [r0, #12]
 802edd0:	6926      	ldr	r6, [r4, #16]
 802edd2:	f105 0914 	add.w	r9, r5, #20
 802edd6:	3414      	adds	r4, #20
 802edd8:	eb04 0786 	add.w	r7, r4, r6, lsl #2
 802eddc:	eb09 0883 	add.w	r8, r9, r3, lsl #2
 802ede0:	f100 0514 	add.w	r5, r0, #20
 802ede4:	f04f 0c00 	mov.w	ip, #0
 802ede8:	f854 3b04 	ldr.w	r3, [r4], #4
 802edec:	f859 2b04 	ldr.w	r2, [r9], #4
 802edf0:	fa1c f183 	uxtah	r1, ip, r3
 802edf4:	fa1f fe82 	uxth.w	lr, r2
 802edf8:	0c12      	lsrs	r2, r2, #16
 802edfa:	ebce 0101 	rsb	r1, lr, r1
 802edfe:	ebc2 4313 	rsb	r3, r2, r3, lsr #16
 802ee02:	eb03 4321 	add.w	r3, r3, r1, asr #16
 802ee06:	b289      	uxth	r1, r1
 802ee08:	ea4f 4c23 	mov.w	ip, r3, asr #16
 802ee0c:	45c8      	cmp	r8, r9
 802ee0e:	ea41 4303 	orr.w	r3, r1, r3, lsl #16
 802ee12:	46a6      	mov	lr, r4
 802ee14:	f845 3b04 	str.w	r3, [r5], #4
 802ee18:	d8e6      	bhi.n	802ede8 <__mdiff+0x5a>
 802ee1a:	45be      	cmp	lr, r7
 802ee1c:	d20e      	bcs.n	802ee3c <__mdiff+0xae>
 802ee1e:	f85e 2b04 	ldr.w	r2, [lr], #4
 802ee22:	fa1c f482 	uxtah	r4, ip, r2
 802ee26:	0c12      	lsrs	r2, r2, #16
 802ee28:	eb02 4224 	add.w	r2, r2, r4, asr #16
 802ee2c:	b2a4      	uxth	r4, r4
 802ee2e:	ea4f 4c22 	mov.w	ip, r2, asr #16
 802ee32:	ea44 4202 	orr.w	r2, r4, r2, lsl #16
 802ee36:	f845 2b04 	str.w	r2, [r5], #4
 802ee3a:	e7ee      	b.n	802ee1a <__mdiff+0x8c>
 802ee3c:	f855 3d04 	ldr.w	r3, [r5, #-4]!
 802ee40:	b90b      	cbnz	r3, 802ee46 <__mdiff+0xb8>
 802ee42:	3e01      	subs	r6, #1
 802ee44:	e7fa      	b.n	802ee3c <__mdiff+0xae>
 802ee46:	6106      	str	r6, [r0, #16]
 802ee48:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

0802ee4c <__d2b>:
 802ee4c:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 802ee50:	2101      	movs	r1, #1
 802ee52:	461d      	mov	r5, r3
 802ee54:	9f08      	ldr	r7, [sp, #32]
 802ee56:	9e09      	ldr	r6, [sp, #36]	; 0x24
 802ee58:	4614      	mov	r4, r2
 802ee5a:	f7ff fd69 	bl	802e930 <_Balloc>
 802ee5e:	f3c5 0313 	ubfx	r3, r5, #0, #20
 802ee62:	f3c5 550a 	ubfx	r5, r5, #20, #11
 802ee66:	4680      	mov	r8, r0
 802ee68:	b10d      	cbz	r5, 802ee6e <__d2b+0x22>
 802ee6a:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 802ee6e:	9301      	str	r3, [sp, #4]
 802ee70:	b1ec      	cbz	r4, 802eeae <__d2b+0x62>
 802ee72:	a802      	add	r0, sp, #8
 802ee74:	f840 4d08 	str.w	r4, [r0, #-8]!
 802ee78:	f7ff fe04 	bl	802ea84 <__lo0bits>
 802ee7c:	9b00      	ldr	r3, [sp, #0]
 802ee7e:	b150      	cbz	r0, 802ee96 <__d2b+0x4a>
 802ee80:	9a01      	ldr	r2, [sp, #4]
 802ee82:	f1c0 0120 	rsb	r1, r0, #32
 802ee86:	fa02 f101 	lsl.w	r1, r2, r1
 802ee8a:	430b      	orrs	r3, r1
 802ee8c:	40c2      	lsrs	r2, r0
 802ee8e:	f8c8 3014 	str.w	r3, [r8, #20]
 802ee92:	9201      	str	r2, [sp, #4]
 802ee94:	e001      	b.n	802ee9a <__d2b+0x4e>
 802ee96:	f8c8 3014 	str.w	r3, [r8, #20]
 802ee9a:	9b01      	ldr	r3, [sp, #4]
 802ee9c:	f8c8 3018 	str.w	r3, [r8, #24]
 802eea0:	2b00      	cmp	r3, #0
 802eea2:	bf14      	ite	ne
 802eea4:	2402      	movne	r4, #2
 802eea6:	2401      	moveq	r4, #1
 802eea8:	f8c8 4010 	str.w	r4, [r8, #16]
 802eeac:	e009      	b.n	802eec2 <__d2b+0x76>
 802eeae:	a801      	add	r0, sp, #4
 802eeb0:	f7ff fde8 	bl	802ea84 <__lo0bits>
 802eeb4:	2401      	movs	r4, #1
 802eeb6:	9b01      	ldr	r3, [sp, #4]
 802eeb8:	f8c8 3014 	str.w	r3, [r8, #20]
 802eebc:	f8c8 4010 	str.w	r4, [r8, #16]
 802eec0:	3020      	adds	r0, #32
 802eec2:	b135      	cbz	r5, 802eed2 <__d2b+0x86>
 802eec4:	f2a5 4533 	subw	r5, r5, #1075	; 0x433
 802eec8:	4405      	add	r5, r0
 802eeca:	603d      	str	r5, [r7, #0]
 802eecc:	f1c0 0035 	rsb	r0, r0, #53	; 0x35
 802eed0:	e009      	b.n	802eee6 <__d2b+0x9a>
 802eed2:	eb08 0384 	add.w	r3, r8, r4, lsl #2
 802eed6:	f2a0 4032 	subw	r0, r0, #1074	; 0x432
 802eeda:	6038      	str	r0, [r7, #0]
 802eedc:	6918      	ldr	r0, [r3, #16]
 802eede:	f7ff fdb1 	bl	802ea44 <__hi0bits>
 802eee2:	ebc0 1044 	rsb	r0, r0, r4, lsl #5
 802eee6:	6030      	str	r0, [r6, #0]
 802eee8:	4640      	mov	r0, r8
 802eeea:	b002      	add	sp, #8
 802eeec:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0802eef0 <_calloc_r>:
 802eef0:	b538      	push	{r3, r4, r5, lr}
 802eef2:	fb02 f401 	mul.w	r4, r2, r1
 802eef6:	4621      	mov	r1, r4
 802eef8:	f000 f808 	bl	802ef0c <_malloc_r>
 802eefc:	4605      	mov	r5, r0
 802eefe:	b118      	cbz	r0, 802ef08 <_calloc_r+0x18>
 802ef00:	2100      	movs	r1, #0
 802ef02:	4622      	mov	r2, r4
 802ef04:	f7fe fb2f 	bl	802d566 <memset>
 802ef08:	4628      	mov	r0, r5
 802ef0a:	bd38      	pop	{r3, r4, r5, pc}

0802ef0c <_malloc_r>:
 802ef0c:	b570      	push	{r4, r5, r6, lr}
 802ef0e:	1ccc      	adds	r4, r1, #3
 802ef10:	f024 0403 	bic.w	r4, r4, #3
 802ef14:	3408      	adds	r4, #8
 802ef16:	2c0c      	cmp	r4, #12
 802ef18:	bf38      	it	cc
 802ef1a:	240c      	movcc	r4, #12
 802ef1c:	2c00      	cmp	r4, #0
 802ef1e:	4606      	mov	r6, r0
 802ef20:	da03      	bge.n	802ef2a <_malloc_r+0x1e>
 802ef22:	230c      	movs	r3, #12
 802ef24:	6033      	str	r3, [r6, #0]
 802ef26:	2000      	movs	r0, #0
 802ef28:	bd70      	pop	{r4, r5, r6, pc}
 802ef2a:	428c      	cmp	r4, r1
 802ef2c:	d3f9      	bcc.n	802ef22 <_malloc_r+0x16>
 802ef2e:	4a20      	ldr	r2, [pc, #128]	; (802efb0 <_malloc_r+0xa4>)
 802ef30:	6813      	ldr	r3, [r2, #0]
 802ef32:	4610      	mov	r0, r2
 802ef34:	4619      	mov	r1, r3
 802ef36:	b1a1      	cbz	r1, 802ef62 <_malloc_r+0x56>
 802ef38:	680a      	ldr	r2, [r1, #0]
 802ef3a:	1b12      	subs	r2, r2, r4
 802ef3c:	d40e      	bmi.n	802ef5c <_malloc_r+0x50>
 802ef3e:	2a0b      	cmp	r2, #11
 802ef40:	d903      	bls.n	802ef4a <_malloc_r+0x3e>
 802ef42:	600a      	str	r2, [r1, #0]
 802ef44:	188b      	adds	r3, r1, r2
 802ef46:	508c      	str	r4, [r1, r2]
 802ef48:	e01f      	b.n	802ef8a <_malloc_r+0x7e>
 802ef4a:	428b      	cmp	r3, r1
 802ef4c:	bf0d      	iteet	eq
 802ef4e:	685a      	ldreq	r2, [r3, #4]
 802ef50:	684a      	ldrne	r2, [r1, #4]
 802ef52:	605a      	strne	r2, [r3, #4]
 802ef54:	6002      	streq	r2, [r0, #0]
 802ef56:	bf18      	it	ne
 802ef58:	460b      	movne	r3, r1
 802ef5a:	e016      	b.n	802ef8a <_malloc_r+0x7e>
 802ef5c:	460b      	mov	r3, r1
 802ef5e:	6849      	ldr	r1, [r1, #4]
 802ef60:	e7e9      	b.n	802ef36 <_malloc_r+0x2a>
 802ef62:	4d14      	ldr	r5, [pc, #80]	; (802efb4 <_malloc_r+0xa8>)
 802ef64:	682b      	ldr	r3, [r5, #0]
 802ef66:	b91b      	cbnz	r3, 802ef70 <_malloc_r+0x64>
 802ef68:	4630      	mov	r0, r6
 802ef6a:	f000 f825 	bl	802efb8 <_sbrk_r>
 802ef6e:	6028      	str	r0, [r5, #0]
 802ef70:	4630      	mov	r0, r6
 802ef72:	4621      	mov	r1, r4
 802ef74:	f000 f820 	bl	802efb8 <_sbrk_r>
 802ef78:	1c42      	adds	r2, r0, #1
 802ef7a:	4603      	mov	r3, r0
 802ef7c:	d0d1      	beq.n	802ef22 <_malloc_r+0x16>
 802ef7e:	1cc5      	adds	r5, r0, #3
 802ef80:	f025 0503 	bic.w	r5, r5, #3
 802ef84:	4285      	cmp	r5, r0
 802ef86:	d10a      	bne.n	802ef9e <_malloc_r+0x92>
 802ef88:	601c      	str	r4, [r3, #0]
 802ef8a:	f103 000b 	add.w	r0, r3, #11
 802ef8e:	1d1a      	adds	r2, r3, #4
 802ef90:	f020 0007 	bic.w	r0, r0, #7
 802ef94:	1a82      	subs	r2, r0, r2
 802ef96:	d00a      	beq.n	802efae <_malloc_r+0xa2>
 802ef98:	4251      	negs	r1, r2
 802ef9a:	5099      	str	r1, [r3, r2]
 802ef9c:	bd70      	pop	{r4, r5, r6, pc}
 802ef9e:	4630      	mov	r0, r6
 802efa0:	1ae9      	subs	r1, r5, r3
 802efa2:	f000 f809 	bl	802efb8 <_sbrk_r>
 802efa6:	3001      	adds	r0, #1
 802efa8:	d0bb      	beq.n	802ef22 <_malloc_r+0x16>
 802efaa:	462b      	mov	r3, r5
 802efac:	e7ec      	b.n	802ef88 <_malloc_r+0x7c>
 802efae:	bd70      	pop	{r4, r5, r6, pc}
 802efb0:	1ffef05c 	.word	0x1ffef05c
 802efb4:	1ffef058 	.word	0x1ffef058

0802efb8 <_sbrk_r>:
 802efb8:	b538      	push	{r3, r4, r5, lr}
 802efba:	4c06      	ldr	r4, [pc, #24]	; (802efd4 <_sbrk_r+0x1c>)
 802efbc:	2300      	movs	r3, #0
 802efbe:	4605      	mov	r5, r0
 802efc0:	4608      	mov	r0, r1
 802efc2:	6023      	str	r3, [r4, #0]
 802efc4:	f7f4 fc2c 	bl	8023820 <_sbrk>
 802efc8:	1c43      	adds	r3, r0, #1
 802efca:	d102      	bne.n	802efd2 <_sbrk_r+0x1a>
 802efcc:	6823      	ldr	r3, [r4, #0]
 802efce:	b103      	cbz	r3, 802efd2 <_sbrk_r+0x1a>
 802efd0:	602b      	str	r3, [r5, #0]
 802efd2:	bd38      	pop	{r3, r4, r5, pc}
 802efd4:	1fff0730 	.word	0x1fff0730

0802efd8 <__aeabi_d2iz>:
 802efd8:	ea4f 0241 	mov.w	r2, r1, lsl #1
 802efdc:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 802efe0:	d215      	bcs.n	802f00e <__aeabi_d2iz+0x36>
 802efe2:	d511      	bpl.n	802f008 <__aeabi_d2iz+0x30>
 802efe4:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 802efe8:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 802efec:	d912      	bls.n	802f014 <__aeabi_d2iz+0x3c>
 802efee:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 802eff2:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 802eff6:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 802effa:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 802effe:	fa23 f002 	lsr.w	r0, r3, r2
 802f002:	bf18      	it	ne
 802f004:	4240      	negne	r0, r0
 802f006:	4770      	bx	lr
 802f008:	f04f 0000 	mov.w	r0, #0
 802f00c:	4770      	bx	lr
 802f00e:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 802f012:	d105      	bne.n	802f020 <__aeabi_d2iz+0x48>
 802f014:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
 802f018:	bf08      	it	eq
 802f01a:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 802f01e:	4770      	bx	lr
 802f020:	f04f 0000 	mov.w	r0, #0
 802f024:	4770      	bx	lr
 802f026:	bf00      	nop

0802f028 <ds_default_device_settings>:
 802f028:	0040 0000 0e1e 0003 0001 0000 7ca8 4bb7     @............|.K
 802f038:	0000 0000 07d0 0000 000c 0000 0001 0000     ................
 802f048:	49f0 0002 0080 0000 0003 0000 0028 0000     .I..........(...
 802f058:	0005 0000 0000 0000 0001 0000 03e8 0000     ................
 802f068:	4252 5042 5644 3033 0000 0000 6553 736e     RBBPDV30....Sens
 802f078:	3265 6f47 204c 7550 736c 2065 4742 3254     e2GoL Pulse BGT2
 802f088:	4c34 5254 3131 4420 6d65 206f 6152 6164     4LTR11 Demo Rada
 802f098:	2072 6f42 7261 0064                         r Board.

0802f0a0 <cg_device_info_struct>:
 802f0a0:	f074 0802 97a8 016e a4e8 0171 0201 0101     t.....n...q.....
 802f0b0:	0002 0100 4e55 4e4b 574f 204e 5245 4f52     ....UNKNOWN ERRO
 802f0c0:	0052 0000 5245 4f52 3a52 2d20 4220 616f     R...ERROR: - Boa
 802f0d0:	6472 7520 736e 7075 6f70 7472 6465 0000     rd unsupported..
 802f0e0:	5245 4f52 3a52 2d20 4920 766e 6c61 6469     ERROR: - Invalid
 802f0f0:	4220 616f 6472 4920 2c44 6f20 2072 6f42      Board ID, or Bo
 802f100:	7261 2064 6f6e 2074 6f63 6e6e 6365 6574     ard not connecte
 802f110:	0064 0000 5245 4f52 3a52 2d20 4220 616f     d...ERROR: - Boa
 802f120:	6472 4920 2044 6f6e 2074 7270 676f 6172     rd ID not progra
 802f130:	6d6d 6465 0000 0000 416d 0000 7543 7272     mmed....mA..Curr
 802f140:	6e65 2074 6f43 736e 6d75 7470 6f69 006e     ent Consumption.

0802f150 <c_para_value_def_list>:
 802f150:	cccd 3dcc 0000 4040 cccd 3dcc 0000 4040     ...=..@@...=..@@
 802f160:	cccd 3d4c 0000 4000 0020 0040 0080 0100     ..L=...@ .@.....
 802f170:	0000 447a 4000 459c 0000 3f80 0000 44fa     ..zD.@.E...?...D
 802f180:	0000 3f80 0000 44fa 0000 0000 03e8 0000     ...?...D........
 802f190:	0004 0000 000a 0000 4252 5042 5644 3031     ........RBBPDV10
 802f1a0:	0000 0000 6553 736e 3265 6f47 204c 7550     ....Sense2GoL Pu
 802f1b0:	736c 2065 4742 3254 4c34 5254 3131 7320     lse BGT24LTR11 s
 802f1c0:	6968 6c65 2064 3156 302e 0000 7550 736c     hield V1.0..Puls
 802f1d0:	6465 4420 706f 6c70 7265 0000 6553 736e     ed Doppler..Sens
 802f1e0:	3265 6f47 204c 7550 736c 2065 4742 3254     e2GoL Pulse BGT2
 802f1f0:	4c34 5254 3131 7320 6968 6c65 2064 3356     4LTR11 shield V3
 802f200:	302e 0000                                   .0..

0802f204 <CSWTCH.37>:
	...
 802f20c:	0002 0000 0002 0000 000c 0000 000c 0000     ................
 802f21c:	000c 0000 000c 0000 0008 0000 000a 0000     ................

0802f22c <CSWTCH.38>:
 802f22c:	0003 0000 0003 0000 000c 0000 000c 0000     ................
 802f23c:	3000 0000 3000 0000 3000 0000 3000 0000     .0...0...0...0..
 802f24c:	0300 0000 0c00 0000                         ........

0802f254 <CSWTCH.43>:
 802f254:	0003 0000 0003 0000 000c 0000 000c 0000     ................
 802f264:	0030 0000 0030 0000 3000 0000 3000 0000     0...0....0...0..
 802f274:	0300 0000 0c00 0000                         ........

0802f27c <CSWTCH.44>:
	...
 802f284:	0002 0000 0002 0000 0004 0000 0004 0000     ................
 802f294:	000c 0000 000c 0000 0008 0000 000a 0000     ................

0802f2a4 <Driver_USBD0>:
 802f2a4:	1fc9 0802 2629 0802 2345 0802 1fe5 0802     ....)&..E#......
 802f2b4:	1ffd 0802 2015 0802 212d 0802 2369 0802     ..... ..-!..i#..
 802f2c4:	2215 0802 2145 0802 27f5 0802 25e9 0802     ."..E!...'...%..
 802f2d4:	28d5 0802 21d1 0802 2315 0802 2329 0802     .(...!...#..)#..

0802f2e4 <g_xmc_vadc_group_array>:
 802f2e4:	4400 4000 4800 4000 4c00 4000 5000 4000     .D.@.H.@.L.@.P.@
 802f2f4:	6f4e 4520 7272 726f 0000 0000 4d58 3443     No Error....XMC4
 802f304:	3037 2030 6152 6164 2072 6162 6573 6f62     700 Radar basebo
 802f314:	7261 2064 3256 302e 0000 0000               ard V2.0....

0802f320 <product_string>:
 802f320:	0310 0049 0046 0058 0020 0043 0044 0043     ..I.F.X. .C.D.C.
	...

0802f388 <device_descriptor>:
 802f388:	0112 0110 0002 4000 058b 0058 0001 0201     .......@..X.....
 802f398:	0100 0000                                   ....

0802f39c <language_string>:
 802f39c:	0304 0409 0000 0000 0000 0000 0000 0000     ................
	...

0802f404 <manufacturer_string>:
 802f404:	0312 0049 006e 0066 0069 006e 0065 006f     ..I.n.f.i.n.e.o.
 802f414:	006e 0000 0000 0000 0000 0000 0000 0000     n...............
	...

0802f46c <CSWTCH.1>:
 802f46c:	f39c 0802 f404 0802 f320 0802               ........ ...

0802f478 <CSWTCH.2>:
 802f478:	0004 0012 0010 0000                         ........

0802f480 <configuration_descriptor>:
 802f480:	0209 003e 0102 8000 0932 0004 0100 0202     ..>.....2.......
 802f490:	0001 2405 1000 0401 0224 0506 0624 0100     ...$....$...$...
 802f4a0:	0507 0381 0008 09ff 0104 0200 000a 0000     ................
 802f4b0:	0507 0203 0040 0701 8205 4002 0100 0000     ....@......@....

0802f4c0 <PWM_CCU8_SAMPLE_HOLD_ch1_out0_config>:
 802f4c0:	0098 0000 0000 0001 0004 0000               ............

0802f4cc <PWM_CCU8_ADC_SAMPLE_config_handle>:
 802f4cc:	0000 0e0f 0ca8 0708 0100 0000 0000 0000     ................
 802f4dc:	0000 0202 0000 0000 0000 0000 f6e8 0802     ................
 802f4ec:	f600 0802 f7bc 0802 0001 0000 0000 0000     ................
	...
 802f504:	0001 0000 0000 2000 f64c 0802 0001 0000     ....... L.......
 802f514:	f6ec 0802 0000 0000 0000 0000 0000 0000     ................
	...
 802f558:	9318 1ffe                                   ....

0802f55c <PWM_CCU8_BGT_TX_ON_event2_config>:
 802f55c:	0000 0001                                   ....

0802f560 <PWM_CCU8_BGT_TX_ON_dt_config>:
	...

0802f56c <PWM_CCU8_BGT_TX_ON_config_handle>:
 802f56c:	0000 0e0f 0451 0700 0000 0000 0000 0000     ....Q...........
	...
 802f588:	f7a8 0802 f634 0802 f55c 0802 0001 0002     ....4...\.......
	...
 802f5a4:	0001 0000 0000 0800 f560 0802 0001 0000     ........`.......
 802f5b4:	f608 0802 0001 0000 8500 4802 000a 0000     ...........H....
 802f5c4:	f79c 0802 0000 0000 0000 0000 0000 0000     ................
	...
 802f5f8:	9318 1ffe                                   ....

0802f5fc <PWM_CCU8_BGT_VCC_event0_config>:
 802f5fc:	0000 0001                                   ....

0802f600 <PWM_CCU8_ADC_SAMPLE_event1_config>:
 802f600:	0000 0001                                   ....

0802f604 <PWM_CCU8_SAMPLE_HOLD_event0_config>:
 802f604:	010c 0001                                   ....

0802f608 <PWM_CCU8_BGT_TX_ON_timer_handle>:
 802f608:	0002 0000 0000 0000 0015 0000 0001 0000     ................

0802f618 <PWM_CCU8_BGT_VCC_ch1_out0_config>:
 802f618:	0098 0000 0000 0001 0004 0000               ............

0802f624 <PWM_CCU8_SAMPLE_HOLD_timer_handle>:
 802f624:	0002 0000 0000 0000 0015 0000 0001 0000     ................

0802f634 <PWM_CCU8_BGT_TX_ON_event1_config>:
 802f634:	020c 0001                                   ....

0802f638 <PWM_CCU8_BGT_VCC_event2_config>:
 802f638:	0000 0001                                   ....

0802f63c <PWM_CCU8_BGT_VCC_dt_config>:
	...

0802f648 <PWM_CCU8_SAMPLE_HOLD_event2_config>:
 802f648:	0000 0001                                   ....

0802f64c <PWM_CCU8_ADC_SAMPLE_dt_config>:
	...

0802f658 <PWM_CCU8_BGT_VCC_config_handle>:
 802f658:	0000 000a 0009 0008 0100 0000 0000 0000     ................
 802f668:	0000 0303 0000 0000 0000 0000 f5fc 0802     ................
 802f678:	f7b8 0802 f638 0802 0000 0000 0000 0000     ....8...........
	...
 802f690:	0001 0000 0000 0400 f63c 0802 0001 0000     ........<.......
 802f6a0:	f78c 0802 0001 0000 8500 4802 000b 0000     ...........H....
 802f6b0:	f618 0802 0000 0000 0000 0000 0000 0000     ................
	...
 802f6e4:	9318 1ffe                                   ....

0802f6e8 <PWM_CCU8_ADC_SAMPLE_event0_config>:
 802f6e8:	010c 0001                                   ....

0802f6ec <PWM_CCU8_ADC_SAMPLE_timer_handle>:
 802f6ec:	0002 0000 0000 0000 0014 0000 0001 0000     ................

0802f6fc <PWM_CCU8_SAMPLE_HOLD_config_handle>:
 802f6fc:	0000 0e0f 0451 0700 0000 0000 0000 0000     ....Q...........
	...
 802f718:	f604 0802 f7c0 0802 f648 0802 0001 0002     ........H.......
	...
 802f734:	0001 0000 0000 1000 f7ac 0802 0001 0000     ................
 802f744:	f624 0802 0001 0000 8500 4802 0009 0000     $..........H....
 802f754:	f4c0 0802 0000 0000 0000 0000 0000 0000     ................
	...
 802f788:	9318 1ffe                                   ....

0802f78c <PWM_CCU8_BGT_VCC_timer_handle>:
 802f78c:	0000 0000 0001 0000 0014 0000 0007 0000     ................

0802f79c <PWM_CCU8_BGT_TX_ON_ch1_out0_config>:
 802f79c:	0098 0000 0000 0001 0004 0000               ............

0802f7a8 <PWM_CCU8_BGT_TX_ON_event0_config>:
 802f7a8:	010c 0001                                   ....

0802f7ac <PWM_CCU8_SAMPLE_HOLD_dt_config>:
	...

0802f7b8 <PWM_CCU8_BGT_VCC_event1_config>:
 802f7b8:	0000 0001                                   ....

0802f7bc <PWM_CCU8_ADC_SAMPLE_event2_config>:
 802f7bc:	0000 0001                                   ....

0802f7c0 <PWM_CCU8_SAMPLE_HOLD_event1_config>:
 802f7c0:	020c 0001                                   ....

0802f7c4 <INTERRUPT_ERROR_TOGGLE>:
 802f7c4:	3f3b 0100                                   ;?..

0802f7c8 <INTERRUPT_BB_PRE_TRIGGER>:
 802f7c8:	3f3a 0100                                   :?..

0802f7cc <INTERRUPT_PTAT_TIMER>:
 802f7cc:	3f39 0100                                   9?..

0802f7d0 <INTERRUPT_FRAME>:
 802f7d0:	3d31 0100                                   1=..

0802f7d4 <INTERRUPT_PTAT_S_H_DELAY>:
 802f7d4:	3f38 0100                                   8?..

0802f7d8 <INTERRUPT_BGT_VCC_ON>:
 802f7d8:	3f3f 0100                                   ??..

0802f7dc <group_init_handle0>:
	...

0802f7f0 <group_init_handle1>:
	...

0802f804 <group_init_handle3>:
	...

0802f818 <global_config>:
 802f818:	0000 0000 0004 0000 0000 0000 0000 0000     ................
	...

0802f830 <group_init_handle2>:
	...

0802f844 <DIGITAL_IO_BB1_EN>:
 802f844:	8300 4802 0080 0000 0000 0001 0004 0000     ...H............
 802f854:	0009 0000                                   ....

0802f858 <DIGITAL_IO_BB2_EN>:
 802f858:	8300 4802 0080 0000 0000 0001 0004 0000     ...H............
 802f868:	0004 0000                                   ....

0802f86c <DIGITAL_IO_BGT_VCC_PTAT>:
 802f86c:	8000 4802 0080 0000 0001 0000 0000 0000     ...H............
 802f87c:	000e 0000                                   ....

0802f880 <DIGITAL_IO_ARD_D4>:
 802f880:	8400 4802 0080 0000 0000 0001 0000 0000     ...H............
 802f890:	0006 0000                                   ....

0802f894 <DIGITAL_IO_ARD_D6>:
 802f894:	8700 4802 0080 0000 0000 0001 0000 0000     ...H............
 802f8a4:	0006 0000                                   ....

0802f8a8 <DIGITAL_IO_ARD_D7>:
 802f8a8:	8300 4802 0080 0000 0000 0001 0000 0000     ...H............
 802f8b8:	000a 0000                                   ....

0802f8bc <DIGITAL_IO_GREEN_LED>:
 802f8bc:	8100 4802 0080 0000 0001 0000 0000 0000     ...H............
 802f8cc:	000e 0000                                   ....

0802f8d0 <DIGITAL_IO_RED_LED>:
 802f8d0:	8100 4802 0080 0000 0001 0000 0000 0000     ...H............
 802f8e0:	000f 0000                                   ....

0802f8e4 <DIGITAL_IO_BLUE_LED>:
 802f8e4:	8100 4802 0080 0000 0001 0000 0000 0000     ...H............
 802f8f4:	000d 0000                                   ....

0802f8f8 <DIGITAL_IO_V_PTAT_SH_EN>:
 802f8f8:	8700 4802 0080 0000 0000 0001 0004 0000     ...H............
 802f908:	000a 0000                                   ....

0802f90c <armBitRevIndexTable64>:
 802f90c:	0008 0040 0010 0080 0018 00c0 0020 0100     ..@......... ...
 802f91c:	0028 0140 0030 0180 0038 01c0 0050 0088     (.@.0...8...P...
 802f92c:	0058 00c8 0060 0108 0068 0148 0070 0188     X...`...h.H.p...
 802f93c:	0078 01c8 0098 00d0 00a0 0110 00a8 0150     x.............P.
 802f94c:	00b0 0190 00b8 01d0 00e0 0118 00e8 0158     ..............X.
 802f95c:	00f0 0198 00f8 01d8 0128 0160 0130 01a0     ........(.`.0...
 802f96c:	0138 01e0 0170 01a8 0178 01e8 01b8 01f0     8...p...x.......

0802f97c <twiddleCoef_256>:
 802f97c:	0000 3f80 0000 0000 ec43 3f7f 0ab0 3cc9     ...?....C..?...<
 802f98c:	b10f 3f7f fb2f 3d48 4e6d 3f7f a905 3d96     ...?/.H=mN.?...=
 802f99c:	c46d 3f7e bd36 3dc8 1324 3f7e b273 3dfa     m.~?6..=$.~?s..=
 802f9ac:	3aac 3f7d 4083 3e16 3b28 3f7c 10a2 3e2f     .:}?.@.>(;|?../>
 802f9bc:	14be 3f7b c5c2 3e47 c79d 3f79 5c13 3e60     ..{?..G>..y?.\`>
 802f9cc:	53f8 3f78 cfcc 3e78 ba07 3f76 8e93 3e88     .Sx?..x>..v?...>
 802f9dc:	fa0b 3f74 a031 3e94 1447 3f73 9ae5 3ea0     ..t?1..>G.s?...>
 802f9ec:	0908 3f71 7cd4 3eac d89e 3f6e 442a 3eb8     ..q?.|.>..n?*D.>
 802f9fc:	835e 3f6c ef15 3ec3 09a7 3f6a 7bca 3ecf     ^.l?...>..j?.{.>
 802fa0c:	6bd8 3f67 e880 3eda aa59 3f64 3375 3ee6     .kg?...>Y.d?u3.>
 802fa1c:	c598 3f61 5aea 3ef1 be05 3f5e 5d27 3efc     ..a?.Z.>..^?'].>
 802fa2c:	941a 3f5b 9c3d 3f03 4853 3f58 f59b 3f08     ..[?=..?SHX?...?
 802fa3c:	db31 3f54 39da 3f0e 4d3d 3f51 682a 3f13     1.T?.9.?=MQ?*h.?
 802fa4c:	9f02 3f4d 7fc0 3f18 d112 3f49 7fd1 3f1d     ..M?...?..I?...?
 802fa5c:	e403 3f45 6799 3f22 d870 3f41 3656 3f27     ..E?.g"?p.A?V6'?
 802fa6c:	aef9 3f3d eb4a 3f2b 6842 3f39 85bb 3f30     ..=?J.+?Bh9?..0?
 802fa7c:	04f3 3f35 04f3 3f35 85bb 3f30 6842 3f39     ..5?..5?..0?Bh9?
 802fa8c:	eb4a 3f2b aef9 3f3d 3656 3f27 d870 3f41     J.+?..=?V6'?p.A?
 802fa9c:	6799 3f22 e403 3f45 7fd1 3f1d d112 3f49     .g"?..E?...?..I?
 802faac:	7fc0 3f18 9f02 3f4d 682a 3f13 4d3d 3f51     ...?..M?*h.?=MQ?
 802fabc:	39da 3f0e db31 3f54 f59b 3f08 4853 3f58     .9.?1.T?...?SHX?
 802facc:	9c3d 3f03 941a 3f5b 5d27 3efc be05 3f5e     =..?..[?'].>..^?
 802fadc:	5aea 3ef1 c598 3f61 3375 3ee6 aa59 3f64     .Z.>..a?u3.>Y.d?
 802faec:	e880 3eda 6bd8 3f67 7bca 3ecf 09a7 3f6a     ...>.kg?.{.>..j?
 802fafc:	ef15 3ec3 835e 3f6c 442a 3eb8 d89e 3f6e     ...>^.l?*D.>..n?
 802fb0c:	7cd4 3eac 0908 3f71 9ae5 3ea0 1447 3f73     .|.>..q?...>G.s?
 802fb1c:	a031 3e94 fa0b 3f74 8e93 3e88 ba07 3f76     1..>..t?...>..v?
 802fb2c:	cfcc 3e78 53f8 3f78 5c13 3e60 c79d 3f79     ..x>.Sx?.\`>..y?
 802fb3c:	c5c2 3e47 14be 3f7b 10a2 3e2f 3b28 3f7c     ..G>..{?../>(;|?
 802fb4c:	4083 3e16 3aac 3f7d b273 3dfa 1324 3f7e     .@.>.:}?s..=$.~?
 802fb5c:	bd36 3dc8 c46d 3f7e a905 3d96 4e6d 3f7f     6..=m.~?...=mN.?
 802fb6c:	fb2f 3d48 b10f 3f7f 0ab0 3cc9 ec43 3f7f     /.H=...?...<C..?
 802fb7c:	0000 0000 0000 3f80 0ab0 bcc9 ec43 3f7f     .......?....C..?
 802fb8c:	fb2f bd48 b10f 3f7f a905 bd96 4e6d 3f7f     /.H....?....mN.?
 802fb9c:	bd36 bdc8 c46d 3f7e b273 bdfa 1324 3f7e     6...m.~?s...$.~?
 802fbac:	4083 be16 3aac 3f7d 10a2 be2f 3b28 3f7c     .@...:}?../.(;|?
 802fbbc:	c5c2 be47 14be 3f7b 5c13 be60 c79d 3f79     ..G...{?.\`...y?
 802fbcc:	cfcc be78 53f8 3f78 8e93 be88 ba07 3f76     ..x..Sx?......v?
 802fbdc:	a031 be94 fa0b 3f74 9ae5 bea0 1447 3f73     1.....t?....G.s?
 802fbec:	7cd4 beac 0908 3f71 442a beb8 d89e 3f6e     .|....q?*D....n?
 802fbfc:	ef15 bec3 835e 3f6c 7bca becf 09a7 3f6a     ....^.l?.{....j?
 802fc0c:	e880 beda 6bd8 3f67 3375 bee6 aa59 3f64     .....kg?u3..Y.d?
 802fc1c:	5aea bef1 c598 3f61 5d27 befc be05 3f5e     .Z....a?']....^?
 802fc2c:	9c3d bf03 941a 3f5b f59b bf08 4853 3f58     =.....[?....SHX?
 802fc3c:	39da bf0e db31 3f54 682a bf13 4d3d 3f51     .9..1.T?*h..=MQ?
 802fc4c:	7fc0 bf18 9f02 3f4d 7fd1 bf1d d112 3f49     ......M?......I?
 802fc5c:	6799 bf22 e403 3f45 3656 bf27 d870 3f41     .g"...E?V6'.p.A?
 802fc6c:	eb4a bf2b aef9 3f3d 85bb bf30 6842 3f39     J.+...=?..0.Bh9?
 802fc7c:	04f3 bf35 04f3 3f35 6842 bf39 85bb 3f30     ..5...5?Bh9...0?
 802fc8c:	aef9 bf3d eb4a 3f2b d870 bf41 3656 3f27     ..=.J.+?p.A.V6'?
 802fc9c:	e403 bf45 6799 3f22 d112 bf49 7fd1 3f1d     ..E..g"?..I....?
 802fcac:	9f02 bf4d 7fc0 3f18 4d3d bf51 682a 3f13     ..M....?=MQ.*h.?
 802fcbc:	db31 bf54 39da 3f0e 4853 bf58 f59b 3f08     1.T..9.?SHX....?
 802fccc:	941a bf5b 9c3d 3f03 be05 bf5e 5d27 3efc     ..[.=..?..^.'].>
 802fcdc:	c598 bf61 5aea 3ef1 aa59 bf64 3375 3ee6     ..a..Z.>Y.d.u3.>
 802fcec:	6bd8 bf67 e880 3eda 09a7 bf6a 7bca 3ecf     .kg....>..j..{.>
 802fcfc:	835e bf6c ef15 3ec3 d89e bf6e 442a 3eb8     ^.l....>..n.*D.>
 802fd0c:	0908 bf71 7cd4 3eac 1447 bf73 9ae5 3ea0     ..q..|.>G.s....>
 802fd1c:	fa0b bf74 a031 3e94 ba07 bf76 8e93 3e88     ..t.1..>..v....>
 802fd2c:	53f8 bf78 cfcc 3e78 c79d bf79 5c13 3e60     .Sx...x>..y..\`>
 802fd3c:	14be bf7b c5c2 3e47 3b28 bf7c 10a2 3e2f     ..{...G>(;|.../>
 802fd4c:	3aac bf7d 4083 3e16 1324 bf7e b273 3dfa     .:}..@.>$.~.s..=
 802fd5c:	c46d bf7e bd36 3dc8 4e6d bf7f a905 3d96     m.~.6..=mN.....=
 802fd6c:	b10f bf7f fb2f 3d48 ec43 bf7f 0ab0 3cc9     ..../.H=C......<
 802fd7c:	0000 bf80 0000 0000 ec43 bf7f 0ab0 bcc9     ........C.......
 802fd8c:	b10f bf7f fb2f bd48 4e6d bf7f a905 bd96     ..../.H.mN......
 802fd9c:	c46d bf7e bd36 bdc8 1324 bf7e b273 bdfa     m.~.6...$.~.s...
 802fdac:	3aac bf7d 4083 be16 3b28 bf7c 10a2 be2f     .:}..@..(;|.../.
 802fdbc:	14be bf7b c5c2 be47 c79d bf79 5c13 be60     ..{...G...y..\`.
 802fdcc:	53f8 bf78 cfcc be78 ba07 bf76 8e93 be88     .Sx...x...v.....
 802fddc:	fa0b bf74 a031 be94 1447 bf73 9ae5 bea0     ..t.1...G.s.....
 802fdec:	0908 bf71 7cd4 beac d89e bf6e 442a beb8     ..q..|....n.*D..
 802fdfc:	835e bf6c ef15 bec3 09a7 bf6a 7bca becf     ^.l.......j..{..
 802fe0c:	6bd8 bf67 e880 beda aa59 bf64 3375 bee6     .kg.....Y.d.u3..
 802fe1c:	c598 bf61 5aea bef1 be05 bf5e 5d27 befc     ..a..Z....^.']..
 802fe2c:	941a bf5b 9c3d bf03 4853 bf58 f59b bf08     ..[.=...SHX.....
 802fe3c:	db31 bf54 39da bf0e 4d3d bf51 682a bf13     1.T..9..=MQ.*h..
 802fe4c:	9f02 bf4d 7fc0 bf18 d112 bf49 7fd1 bf1d     ..M.......I.....
 802fe5c:	e403 bf45 6799 bf22 d870 bf41 3656 bf27     ..E..g".p.A.V6'.
 802fe6c:	aef9 bf3d eb4a bf2b 6842 bf39 85bb bf30     ..=.J.+.Bh9...0.
 802fe7c:	04f3 bf35 04f3 bf35 85bb bf30 6842 bf39     ..5...5...0.Bh9.
 802fe8c:	eb4a bf2b aef9 bf3d 3656 bf27 d870 bf41     J.+...=.V6'.p.A.
 802fe9c:	6799 bf22 e403 bf45 7fd1 bf1d d112 bf49     .g"...E.......I.
 802feac:	7fc0 bf18 9f02 bf4d 682a bf13 4d3d bf51     ......M.*h..=MQ.
 802febc:	39da bf0e db31 bf54 f59b bf08 4853 bf58     .9..1.T.....SHX.
 802fecc:	9c3d bf03 941a bf5b 5d27 befc be05 bf5e     =.....[.']....^.
 802fedc:	5aea bef1 c598 bf61 3375 bee6 aa59 bf64     .Z....a.u3..Y.d.
 802feec:	e880 beda 6bd8 bf67 7bca becf 09a7 bf6a     .....kg..{....j.
 802fefc:	ef15 bec3 835e bf6c 442a beb8 d89e bf6e     ....^.l.*D....n.
 802ff0c:	7cd4 beac 0908 bf71 9ae5 bea0 1447 bf73     .|....q.....G.s.
 802ff1c:	a031 be94 fa0b bf74 8e93 be88 ba07 bf76     1.....t.......v.
 802ff2c:	cfcc be78 53f8 bf78 5c13 be60 c79d bf79     ..x..Sx..\`...y.
 802ff3c:	c5c2 be47 14be bf7b 10a2 be2f 3b28 bf7c     ..G...{.../.(;|.
 802ff4c:	4083 be16 3aac bf7d b273 bdfa 1324 bf7e     .@...:}.s...$.~.
 802ff5c:	bd36 bdc8 c46d bf7e a905 bd96 4e6d bf7f     6...m.~.....mN..
 802ff6c:	fb2f bd48 b10f bf7f 0ab0 bcc9 ec43 bf7f     /.H.........C...
 802ff7c:	0000 8000 0000 bf80 0ab0 3cc9 ec43 bf7f     ...........<C...
 802ff8c:	fb2f 3d48 b10f bf7f a905 3d96 4e6d bf7f     /.H=.......=mN..
 802ff9c:	bd36 3dc8 c46d bf7e b273 3dfa 1324 bf7e     6..=m.~.s..=$.~.
 802ffac:	4083 3e16 3aac bf7d 10a2 3e2f 3b28 bf7c     .@.>.:}.../>(;|.
 802ffbc:	c5c2 3e47 14be bf7b 5c13 3e60 c79d bf79     ..G>..{..\`>..y.
 802ffcc:	cfcc 3e78 53f8 bf78 8e93 3e88 ba07 bf76     ..x>.Sx....>..v.
 802ffdc:	a031 3e94 fa0b bf74 9ae5 3ea0 1447 bf73     1..>..t....>G.s.
 802ffec:	7cd4 3eac 0908 bf71 442a 3eb8 d89e bf6e     .|.>..q.*D.>..n.
 802fffc:	ef15 3ec3 835e bf6c 7bca 3ecf 09a7 bf6a     ...>^.l..{.>..j.
 803000c:	e880 3eda 6bd8 bf67 3375 3ee6 aa59 bf64     ...>.kg.u3.>Y.d.
 803001c:	5aea 3ef1 c598 bf61 5d27 3efc be05 bf5e     .Z.>..a.'].>..^.
 803002c:	9c3d 3f03 941a bf5b f59b 3f08 4853 bf58     =..?..[....?SHX.
 803003c:	39da 3f0e db31 bf54 682a 3f13 4d3d bf51     .9.?1.T.*h.?=MQ.
 803004c:	7fc0 3f18 9f02 bf4d 7fd1 3f1d d112 bf49     ...?..M....?..I.
 803005c:	6799 3f22 e403 bf45 3656 3f27 d870 bf41     .g"?..E.V6'?p.A.
 803006c:	eb4a 3f2b aef9 bf3d 85bb 3f30 6842 bf39     J.+?..=...0?Bh9.
 803007c:	04f3 3f35 04f3 bf35 6842 3f39 85bb bf30     ..5?..5.Bh9?..0.
 803008c:	aef9 3f3d eb4a bf2b d870 3f41 3656 bf27     ..=?J.+.p.A?V6'.
 803009c:	e403 3f45 6799 bf22 d112 3f49 7fd1 bf1d     ..E?.g"...I?....
 80300ac:	9f02 3f4d 7fc0 bf18 4d3d 3f51 682a bf13     ..M?....=MQ?*h..
 80300bc:	db31 3f54 39da bf0e 4853 3f58 f59b bf08     1.T?.9..SHX?....
 80300cc:	941a 3f5b 9c3d bf03 be05 3f5e 5d27 befc     ..[?=.....^?']..
 80300dc:	c598 3f61 5aea bef1 aa59 3f64 3375 bee6     ..a?.Z..Y.d?u3..
 80300ec:	6bd8 3f67 e880 beda 09a7 3f6a 7bca becf     .kg?......j?.{..
 80300fc:	835e 3f6c ef15 bec3 d89e 3f6e 442a beb8     ^.l?......n?*D..
 803010c:	0908 3f71 7cd4 beac 1447 3f73 9ae5 bea0     ..q?.|..G.s?....
 803011c:	fa0b 3f74 a031 be94 ba07 3f76 8e93 be88     ..t?1.....v?....
 803012c:	53f8 3f78 cfcc be78 c79d 3f79 5c13 be60     .Sx?..x...y?.\`.
 803013c:	14be 3f7b c5c2 be47 3b28 3f7c 10a2 be2f     ..{?..G.(;|?../.
 803014c:	3aac 3f7d 4083 be16 1324 3f7e b273 bdfa     .:}?.@..$.~?s...
 803015c:	c46d 3f7e bd36 bdc8 4e6d 3f7f a905 bd96     m.~?6...mN.?....
 803016c:	b10f 3f7f fb2f bd48 ec43 3f7f 0ab0 bcc9     ...?/.H.C..?....

0803017c <twiddleCoef_16>:
 803017c:	0000 3f80 0000 0000 835e 3f6c ef15 3ec3     ...?....^.l?...>
 803018c:	04f3 3f35 04f3 3f35 ef15 3ec3 835e 3f6c     ..5?..5?...>^.l?
 803019c:	0000 0000 0000 3f80 ef15 bec3 835e 3f6c     .......?....^.l?
 80301ac:	04f3 bf35 04f3 3f35 835e bf6c ef15 3ec3     ..5...5?^.l....>
 80301bc:	0000 bf80 0000 0000 835e bf6c ef15 bec3     ........^.l.....
 80301cc:	04f3 bf35 04f3 bf35 ef15 bec3 835e bf6c     ..5...5.....^.l.
 80301dc:	0000 8000 0000 bf80 ef15 3ec3 835e bf6c     ...........>^.l.
 80301ec:	04f3 3f35 04f3 bf35 835e 3f6c ef15 bec3     ..5?..5.^.l?....

080301fc <twiddleCoef_32>:
 80301fc:	0000 3f80 0000 0000 14be 3f7b c5c2 3e47     ...?......{?..G>
 803020c:	835e 3f6c ef15 3ec3 db31 3f54 39da 3f0e     ^.l?...>1.T?.9.?
 803021c:	04f3 3f35 04f3 3f35 39da 3f0e db31 3f54     ..5?..5?.9.?1.T?
 803022c:	ef15 3ec3 835e 3f6c c5c2 3e47 14be 3f7b     ...>^.l?..G>..{?
 803023c:	0000 0000 0000 3f80 c5c2 be47 14be 3f7b     .......?..G...{?
 803024c:	ef15 bec3 835e 3f6c 39da bf0e db31 3f54     ....^.l?.9..1.T?
 803025c:	04f3 bf35 04f3 3f35 db31 bf54 39da 3f0e     ..5...5?1.T..9.?
 803026c:	835e bf6c ef15 3ec3 14be bf7b c5c2 3e47     ^.l....>..{...G>
 803027c:	0000 bf80 0000 0000 14be bf7b c5c2 be47     ..........{...G.
 803028c:	835e bf6c ef15 bec3 db31 bf54 39da bf0e     ^.l.....1.T..9..
 803029c:	04f3 bf35 04f3 bf35 39da bf0e db31 bf54     ..5...5..9..1.T.
 80302ac:	ef15 bec3 835e bf6c c5c2 be47 14be bf7b     ....^.l...G...{.
 80302bc:	0000 8000 0000 bf80 c5c2 3e47 14be bf7b     ..........G>..{.
 80302cc:	ef15 3ec3 835e bf6c 39da 3f0e db31 bf54     ...>^.l..9.?1.T.
 80302dc:	04f3 3f35 04f3 bf35 db31 3f54 39da bf0e     ..5?..5.1.T?.9..
 80302ec:	835e 3f6c ef15 bec3 14be 3f7b c5c2 be47     ^.l?......{?..G.

080302fc <armBitRevIndexTable16>:
 80302fc:	0008 0040 0018 0048 0010 0040 0028 0050     ..@...H...@.(.P.
 803030c:	0020 0040 0038 0058 0030 0048 0058 0068      .@.8.X.0.H.X.h.
 803031c:	0048 0060 0068 0070                         H.`.h.p.

08030324 <armBitRevIndexTable32>:
 8030324:	0008 0040 0010 0080 0018 00c0 0020 0040     ..@......... .@.
 8030334:	0028 0048 0030 0088 0038 00c8 0040 0080     (.H.0...8...@...
 8030344:	0048 0050 0058 00d0 0050 0090 0060 00c0     H.P.X...P...`...
 8030354:	0068 00d0 0070 0098 0078 00d8 0088 00c0     h...p...x.......
 8030364:	0090 00a0 00a8 00d0 0098 00e0 00b0 00d0     ................
 8030374:	00b8 00e8 00d8 00f0 00c8 00e0 00e8 00f0     ................

08030384 <sinTable_f32>:
 8030384:	0000 0000 0e92 3c49 0ab1 3cc9 c32b 3d16     ......I<...<+..=
 8030394:	fb2e 3d48 2b75 3d7b a904 3d96 b680 3daf     ..H=u+{=...=...=
 80303a4:	bd36 3dc8 bc2f 3de1 b273 3dfa cf87 3e09     6..=/..=s..=...>
 80303b4:	4083 3e16 abb5 3e22 10a2 3e2f 6ecf 3e3b     .@.>..">../>.n;>
 80303c4:	c5c2 3e47 1501 3e54 5c13 3e60 9a7f 3e6c     ..G>..T>.\`>..l>
 80303d4:	cfcc 3e78 7dc0 3e82 8e93 3e88 9a22 3e8e     ..x>.}.>...>"..>
 80303e4:	a032 3e94 a086 3e9a 9ae5 3ea0 8f12 3ea6     2..>...>...>...>
 80303f4:	7cd4 3eac 63ef 3eb2 442a 3eb8 1d49 3ebe     .|.>.c.>*D.>I..>
 8030404:	ef15 3ec3 b953 3ec9 7bca 3ecf 3641 3ed5     ...>S..>.{.>A6.>
 8030414:	e880 3eda 924f 3ee0 3375 3ee6 cbbb 3eeb     ...>O..>u3.>...>
 8030424:	5aea 3ef1 e0cb 3ef6 5d27 3efc e7e4 3f00     .Z.>...>'].>...?
 8030434:	9c3d 3f03 4b82 3f06 f59b 3f08 9a6b 3f0b     =..?.K.?...?k..?
 8030444:	39da 3f0e d3cd 3f10 682a 3f13 f6d9 3f15     .9.?...?*h.?...?
 8030454:	7fc0 3f18 02c6 3f1b 7fd1 3f1d f6cb 3f1f     ...?...?...?...?
 8030464:	6799 3f22 d225 3f24 3656 3f27 9415 3f29     .g"?%.$?V6'?..)?
 8030474:	eb4a 3f2b 3bde 3f2e 85bb 3f30 c8c9 3f32     J.+?.;.?..0?..2?
 8030484:	04f3 3f35 3a23 3f37 6842 3f39 8f3b 3f3b     ..5?#:7?Bh9?;.;?
 8030494:	aef9 3f3d c767 3f3f d870 3f41 e201 3f43     ..=?g.??p.A?..C?
 80304a4:	e403 3f45 de65 3f47 d112 3f49 bbf8 3f4b     ..E?e.G?..I?..K?
 80304b4:	9f02 3f4d 7a20 3f4f 4d3d 3f51 1849 3f53     ..M? zO?=MQ?I.S?
 80304c4:	db31 3f54 95e5 3f56 4853 3f58 f26a 3f59     1.T?..V?SHX?j.Y?
 80304d4:	941a 3f5b 2d53 3f5d be05 3f5e 4621 3f60     ..[?S-]?..^?!F`?
 80304e4:	c597 3f61 3c5a 3f63 aa59 3f64 0f88 3f66     ..a?Z<c?Y.d?..f?
 80304f4:	6bd8 3f67 bf3c 3f68 09a7 3f6a 4b0c 3f6b     .kg?<.h?..j?.Kk?
 8030504:	835e 3f6c b293 3f6d d89e 3f6e f573 3f6f     ^.l?..m?..n?s.o?
 8030514:	0908 3f71 1352 3f72 1447 3f73 0bdd 3f74     ..q?R.r?G.s?..t?
 8030524:	fa0b 3f74 dec6 3f75 ba07 3f76 8bc5 3f77     ..t?..u?..v?..w?
 8030534:	53f8 3f78 1298 3f79 c79d 3f79 7302 3f7a     .Sx?..y?..y?.sz?
 8030544:	14be 3f7b accd 3f7b 3b28 3f7c bfc9 3f7c     ..{?..{?(;|?..|?
 8030554:	3aac 3f7d abcc 3f7d 1323 3f7e 70b0 3f7e     .:}?..}?#.~?.p~?
 8030564:	c46d 3f7e 0e58 3f7f 4e6d 3f7f 84ab 3f7f     m.~?X..?mN.?...?
 8030574:	b10f 3f7f d397 3f7f ec43 3f7f fb11 3f7f     ...?...?C..?...?
 8030584:	0000 3f80 fb11 3f7f ec43 3f7f d397 3f7f     ...?...?C..?...?
 8030594:	b10f 3f7f 84ab 3f7f 4e6d 3f7f 0e58 3f7f     ...?...?mN.?X..?
 80305a4:	c46d 3f7e 70b0 3f7e 1323 3f7e abcc 3f7d     m.~?.p~?#.~?..}?
 80305b4:	3aac 3f7d bfc9 3f7c 3b28 3f7c accd 3f7b     .:}?..|?(;|?..{?
 80305c4:	14be 3f7b 7302 3f7a c79d 3f79 1298 3f79     ..{?.sz?..y?..y?
 80305d4:	53f8 3f78 8bc5 3f77 ba07 3f76 dec6 3f75     .Sx?..w?..v?..u?
 80305e4:	fa0b 3f74 0bdd 3f74 1447 3f73 1352 3f72     ..t?..t?G.s?R.r?
 80305f4:	0908 3f71 f573 3f6f d89e 3f6e b293 3f6d     ..q?s.o?..n?..m?
 8030604:	835e 3f6c 4b0c 3f6b 09a7 3f6a bf3c 3f68     ^.l?.Kk?..j?<.h?
 8030614:	6bd8 3f67 0f88 3f66 aa59 3f64 3c5a 3f63     .kg?..f?Y.d?Z<c?
 8030624:	c597 3f61 4621 3f60 be05 3f5e 2d53 3f5d     ..a?!F`?..^?S-]?
 8030634:	941a 3f5b f26a 3f59 4853 3f58 95e5 3f56     ..[?j.Y?SHX?..V?
 8030644:	db31 3f54 1849 3f53 4d3d 3f51 7a20 3f4f     1.T?I.S?=MQ? zO?
 8030654:	9f02 3f4d bbf8 3f4b d112 3f49 de65 3f47     ..M?..K?..I?e.G?
 8030664:	e403 3f45 e201 3f43 d870 3f41 c767 3f3f     ..E?..C?p.A?g.??
 8030674:	aef9 3f3d 8f3b 3f3b 6842 3f39 3a23 3f37     ..=?;.;?Bh9?#:7?
 8030684:	04f3 3f35 c8c9 3f32 85bb 3f30 3bde 3f2e     ..5?..2?..0?.;.?
 8030694:	eb4a 3f2b 9415 3f29 3656 3f27 d225 3f24     J.+?..)?V6'?%.$?
 80306a4:	6799 3f22 f6cb 3f1f 7fd1 3f1d 02c6 3f1b     .g"?...?...?...?
 80306b4:	7fc0 3f18 f6d9 3f15 682a 3f13 d3cd 3f10     ...?...?*h.?...?
 80306c4:	39da 3f0e 9a6b 3f0b f59b 3f08 4b82 3f06     .9.?k..?...?.K.?
 80306d4:	9c3d 3f03 e7e4 3f00 5d27 3efc e0cb 3ef6     =..?...?'].>...>
 80306e4:	5aea 3ef1 cbbb 3eeb 3375 3ee6 924f 3ee0     .Z.>...>u3.>O..>
 80306f4:	e880 3eda 3641 3ed5 7bca 3ecf b953 3ec9     ...>A6.>.{.>S..>
 8030704:	ef15 3ec3 1d49 3ebe 442a 3eb8 63ef 3eb2     ...>I..>*D.>.c.>
 8030714:	7cd4 3eac 8f12 3ea6 9ae5 3ea0 a086 3e9a     .|.>...>...>...>
 8030724:	a032 3e94 9a22 3e8e 8e93 3e88 7dc0 3e82     2..>"..>...>.}.>
 8030734:	cfcc 3e78 9a7f 3e6c 5c13 3e60 1501 3e54     ..x>..l>.\`>..T>
 8030744:	c5c2 3e47 6ecf 3e3b 10a2 3e2f abb5 3e22     ..G>.n;>../>..">
 8030754:	4083 3e16 cf87 3e09 b273 3dfa bc2f 3de1     .@.>...>s..=/..=
 8030764:	bd36 3dc8 b680 3daf a904 3d96 2b75 3d7b     6..=...=...=u+{=
 8030774:	fb2e 3d48 c32b 3d16 0ab1 3cc9 0e92 3c49     ..H=+..=...<..I<
 8030784:	0000 0000 0e92 bc49 0ab1 bcc9 c32b bd16     ......I.....+...
 8030794:	fb2e bd48 2b75 bd7b a904 bd96 b680 bdaf     ..H.u+{.........
 80307a4:	bd36 bdc8 bc2f bde1 b273 bdfa cf87 be09     6.../...s.......
 80307b4:	4083 be16 abb5 be22 10a2 be2f 6ecf be3b     .@....".../..n;.
 80307c4:	c5c2 be47 1501 be54 5c13 be60 9a7f be6c     ..G...T..\`...l.
 80307d4:	cfcc be78 7dc0 be82 8e93 be88 9a22 be8e     ..x..}......"...
 80307e4:	a032 be94 a086 be9a 9ae5 bea0 8f12 bea6     2...............
 80307f4:	7cd4 beac 63ef beb2 442a beb8 1d49 bebe     .|...c..*D..I...
 8030804:	ef15 bec3 b953 bec9 7bca becf 3641 bed5     ....S....{..A6..
 8030814:	e880 beda 924f bee0 3375 bee6 cbbb beeb     ....O...u3......
 8030824:	5aea bef1 e0cb bef6 5d27 befc e7e4 bf00     .Z......']......
 8030834:	9c3d bf03 4b82 bf06 f59b bf08 9a6b bf0b     =....K......k...
 8030844:	39da bf0e d3cd bf10 682a bf13 f6d9 bf15     .9......*h......
 8030854:	7fc0 bf18 02c6 bf1b 7fd1 bf1d f6cb bf1f     ................
 8030864:	6799 bf22 d225 bf24 3656 bf27 9415 bf29     .g".%.$.V6'...).
 8030874:	eb4a bf2b 3bde bf2e 85bb bf30 c8c9 bf32     J.+..;....0...2.
 8030884:	04f3 bf35 3a23 bf37 6842 bf39 8f3b bf3b     ..5.#:7.Bh9.;.;.
 8030894:	aef9 bf3d c767 bf3f d870 bf41 e201 bf43     ..=.g.?.p.A...C.
 80308a4:	e403 bf45 de65 bf47 d112 bf49 bbf8 bf4b     ..E.e.G...I...K.
 80308b4:	9f02 bf4d 7a20 bf4f 4d3d bf51 1849 bf53     ..M. zO.=MQ.I.S.
 80308c4:	db31 bf54 95e5 bf56 4853 bf58 f26a bf59     1.T...V.SHX.j.Y.
 80308d4:	941a bf5b 2d53 bf5d be05 bf5e 4621 bf60     ..[.S-]...^.!F`.
 80308e4:	c597 bf61 3c5a bf63 aa59 bf64 0f88 bf66     ..a.Z<c.Y.d...f.
 80308f4:	6bd8 bf67 bf3c bf68 09a7 bf6a 4b0c bf6b     .kg.<.h...j..Kk.
 8030904:	835e bf6c b293 bf6d d89e bf6e f573 bf6f     ^.l...m...n.s.o.
 8030914:	0908 bf71 1352 bf72 1447 bf73 0bdd bf74     ..q.R.r.G.s...t.
 8030924:	fa0b bf74 dec6 bf75 ba07 bf76 8bc5 bf77     ..t...u...v...w.
 8030934:	53f8 bf78 1298 bf79 c79d bf79 7302 bf7a     .Sx...y...y..sz.
 8030944:	14be bf7b accd bf7b 3b28 bf7c bfc9 bf7c     ..{...{.(;|...|.
 8030954:	3aac bf7d abcc bf7d 1323 bf7e 70b0 bf7e     .:}...}.#.~..p~.
 8030964:	c46d bf7e 0e58 bf7f 4e6d bf7f 84ab bf7f     m.~.X...mN......
 8030974:	b10f bf7f d397 bf7f ec43 bf7f fb11 bf7f     ........C.......
 8030984:	0000 bf80 fb11 bf7f ec43 bf7f d397 bf7f     ........C.......
 8030994:	b10f bf7f 84ab bf7f 4e6d bf7f 0e58 bf7f     ........mN..X...
 80309a4:	c46d bf7e 70b0 bf7e 1323 bf7e abcc bf7d     m.~..p~.#.~...}.
 80309b4:	3aac bf7d bfc9 bf7c 3b28 bf7c accd bf7b     .:}...|.(;|...{.
 80309c4:	14be bf7b 7302 bf7a c79d bf79 1298 bf79     ..{..sz...y...y.
 80309d4:	53f8 bf78 8bc5 bf77 ba07 bf76 dec6 bf75     .Sx...w...v...u.
 80309e4:	fa0b bf74 0bdd bf74 1447 bf73 1352 bf72     ..t...t.G.s.R.r.
 80309f4:	0908 bf71 f573 bf6f d89e bf6e b293 bf6d     ..q.s.o...n...m.
 8030a04:	835e bf6c 4b0c bf6b 09a7 bf6a bf3c bf68     ^.l..Kk...j.<.h.
 8030a14:	6bd8 bf67 0f88 bf66 aa59 bf64 3c5a bf63     .kg...f.Y.d.Z<c.
 8030a24:	c597 bf61 4621 bf60 be05 bf5e 2d53 bf5d     ..a.!F`...^.S-].
 8030a34:	941a bf5b f26a bf59 4853 bf58 95e5 bf56     ..[.j.Y.SHX...V.
 8030a44:	db31 bf54 1849 bf53 4d3d bf51 7a20 bf4f     1.T.I.S.=MQ. zO.
 8030a54:	9f02 bf4d bbf8 bf4b d112 bf49 de65 bf47     ..M...K...I.e.G.
 8030a64:	e403 bf45 e201 bf43 d870 bf41 c767 bf3f     ..E...C.p.A.g.?.
 8030a74:	aef9 bf3d 8f3b bf3b 6842 bf39 3a23 bf37     ..=.;.;.Bh9.#:7.
 8030a84:	04f3 bf35 c8c9 bf32 85bb bf30 3bde bf2e     ..5...2...0..;..
 8030a94:	eb4a bf2b 9415 bf29 3656 bf27 d225 bf24     J.+...).V6'.%.$.
 8030aa4:	6799 bf22 f6cb bf1f 7fd1 bf1d 02c6 bf1b     .g".............
 8030ab4:	7fc0 bf18 f6d9 bf15 682a bf13 d3cd bf10     ........*h......
 8030ac4:	39da bf0e 9a6b bf0b f59b bf08 4b82 bf06     .9..k........K..
 8030ad4:	9c3d bf03 e7e4 bf00 5d27 befc e0cb bef6     =.......']......
 8030ae4:	5aea bef1 cbbb beeb 3375 bee6 924f bee0     .Z......u3..O...
 8030af4:	e880 beda 3641 bed5 7bca becf b953 bec9     ....A6...{..S...
 8030b04:	ef15 bec3 1d49 bebe 442a beb8 63ef beb2     ....I...*D...c..
 8030b14:	7cd4 beac 8f12 bea6 9ae5 bea0 a086 be9a     .|..............
 8030b24:	a032 be94 9a22 be8e 8e93 be88 7dc0 be82     2..."........}..
 8030b34:	cfcc be78 9a7f be6c 5c13 be60 1501 be54     ..x...l..\`...T.
 8030b44:	c5c2 be47 6ecf be3b 10a2 be2f abb5 be22     ..G..n;.../...".
 8030b54:	4083 be16 cf87 be09 b273 bdfa bc2f bde1     .@......s.../...
 8030b64:	bd36 bdc8 b680 bdaf a904 bd96 2b75 bd7b     6...........u+{.
 8030b74:	fb2e bd48 c32b bd16 0ab1 bcc9 0e92 bc49     ..H.+.........I.
 8030b84:	0000 8000                                   ....

08030b88 <twiddleCoef_128>:
 8030b88:	0000 3f80 0000 0000 b10f 3f7f fb2f 3d48     ...?.......?/.H=
 8030b98:	c46d 3f7e bd36 3dc8 3aac 3f7d 4083 3e16     m.~?6..=.:}?.@.>
 8030ba8:	14be 3f7b c5c2 3e47 53f8 3f78 cfcc 3e78     ..{?..G>.Sx?..x>
 8030bb8:	fa0b 3f74 a031 3e94 0908 3f71 7cd4 3eac     ..t?1..>..q?.|.>
 8030bc8:	835e 3f6c ef15 3ec3 6bd8 3f67 e880 3eda     ^.l?...>.kg?...>
 8030bd8:	c598 3f61 5aea 3ef1 941a 3f5b 9c3d 3f03     ..a?.Z.>..[?=..?
 8030be8:	db31 3f54 39da 3f0e 9f02 3f4d 7fc0 3f18     1.T?.9.?..M?...?
 8030bf8:	e403 3f45 6799 3f22 aef9 3f3d eb4a 3f2b     ..E?.g"?..=?J.+?
 8030c08:	04f3 3f35 04f3 3f35 eb4a 3f2b aef9 3f3d     ..5?..5?J.+?..=?
 8030c18:	6799 3f22 e403 3f45 7fc0 3f18 9f02 3f4d     .g"?..E?...?..M?
 8030c28:	39da 3f0e db31 3f54 9c3d 3f03 941a 3f5b     .9.?1.T?=..?..[?
 8030c38:	5aea 3ef1 c598 3f61 e880 3eda 6bd8 3f67     .Z.>..a?...>.kg?
 8030c48:	ef15 3ec3 835e 3f6c 7cd4 3eac 0908 3f71     ...>^.l?.|.>..q?
 8030c58:	a031 3e94 fa0b 3f74 cfcc 3e78 53f8 3f78     1..>..t?..x>.Sx?
 8030c68:	c5c2 3e47 14be 3f7b 4083 3e16 3aac 3f7d     ..G>..{?.@.>.:}?
 8030c78:	bd36 3dc8 c46d 3f7e fb2f 3d48 b10f 3f7f     6..=m.~?/.H=...?
 8030c88:	0000 0000 0000 3f80 fb2f bd48 b10f 3f7f     .......?/.H....?
 8030c98:	bd36 bdc8 c46d 3f7e 4083 be16 3aac 3f7d     6...m.~?.@...:}?
 8030ca8:	c5c2 be47 14be 3f7b cfcc be78 53f8 3f78     ..G...{?..x..Sx?
 8030cb8:	a031 be94 fa0b 3f74 7cd4 beac 0908 3f71     1.....t?.|....q?
 8030cc8:	ef15 bec3 835e 3f6c e880 beda 6bd8 3f67     ....^.l?.....kg?
 8030cd8:	5aea bef1 c598 3f61 9c3d bf03 941a 3f5b     .Z....a?=.....[?
 8030ce8:	39da bf0e db31 3f54 7fc0 bf18 9f02 3f4d     .9..1.T?......M?
 8030cf8:	6799 bf22 e403 3f45 eb4a bf2b aef9 3f3d     .g"...E?J.+...=?
 8030d08:	04f3 bf35 04f3 3f35 aef9 bf3d eb4a 3f2b     ..5...5?..=.J.+?
 8030d18:	e403 bf45 6799 3f22 9f02 bf4d 7fc0 3f18     ..E..g"?..M....?
 8030d28:	db31 bf54 39da 3f0e 941a bf5b 9c3d 3f03     1.T..9.?..[.=..?
 8030d38:	c598 bf61 5aea 3ef1 6bd8 bf67 e880 3eda     ..a..Z.>.kg....>
 8030d48:	835e bf6c ef15 3ec3 0908 bf71 7cd4 3eac     ^.l....>..q..|.>
 8030d58:	fa0b bf74 a031 3e94 53f8 bf78 cfcc 3e78     ..t.1..>.Sx...x>
 8030d68:	14be bf7b c5c2 3e47 3aac bf7d 4083 3e16     ..{...G>.:}..@.>
 8030d78:	c46d bf7e bd36 3dc8 b10f bf7f fb2f 3d48     m.~.6..=..../.H=
 8030d88:	0000 bf80 0000 0000 b10f bf7f fb2f bd48     ............/.H.
 8030d98:	c46d bf7e bd36 bdc8 3aac bf7d 4083 be16     m.~.6....:}..@..
 8030da8:	14be bf7b c5c2 be47 53f8 bf78 cfcc be78     ..{...G..Sx...x.
 8030db8:	fa0b bf74 a031 be94 0908 bf71 7cd4 beac     ..t.1.....q..|..
 8030dc8:	835e bf6c ef15 bec3 6bd8 bf67 e880 beda     ^.l......kg.....
 8030dd8:	c598 bf61 5aea bef1 941a bf5b 9c3d bf03     ..a..Z....[.=...
 8030de8:	db31 bf54 39da bf0e 9f02 bf4d 7fc0 bf18     1.T..9....M.....
 8030df8:	e403 bf45 6799 bf22 aef9 bf3d eb4a bf2b     ..E..g"...=.J.+.
 8030e08:	04f3 bf35 04f3 bf35 eb4a bf2b aef9 bf3d     ..5...5.J.+...=.
 8030e18:	6799 bf22 e403 bf45 7fc0 bf18 9f02 bf4d     .g"...E.......M.
 8030e28:	39da bf0e db31 bf54 9c3d bf03 941a bf5b     .9..1.T.=.....[.
 8030e38:	5aea bef1 c598 bf61 e880 beda 6bd8 bf67     .Z....a......kg.
 8030e48:	ef15 bec3 835e bf6c 7cd4 beac 0908 bf71     ....^.l..|....q.
 8030e58:	a031 be94 fa0b bf74 cfcc be78 53f8 bf78     1.....t...x..Sx.
 8030e68:	c5c2 be47 14be bf7b 4083 be16 3aac bf7d     ..G...{..@...:}.
 8030e78:	bd36 bdc8 c46d bf7e fb2f bd48 b10f bf7f     6...m.~./.H.....
 8030e88:	0000 8000 0000 bf80 fb2f 3d48 b10f bf7f     ......../.H=....
 8030e98:	bd36 3dc8 c46d bf7e 4083 3e16 3aac bf7d     6..=m.~..@.>.:}.
 8030ea8:	c5c2 3e47 14be bf7b cfcc 3e78 53f8 bf78     ..G>..{...x>.Sx.
 8030eb8:	a031 3e94 fa0b bf74 7cd4 3eac 0908 bf71     1..>..t..|.>..q.
 8030ec8:	ef15 3ec3 835e bf6c e880 3eda 6bd8 bf67     ...>^.l....>.kg.
 8030ed8:	5aea 3ef1 c598 bf61 9c3d 3f03 941a bf5b     .Z.>..a.=..?..[.
 8030ee8:	39da 3f0e db31 bf54 7fc0 3f18 9f02 bf4d     .9.?1.T....?..M.
 8030ef8:	6799 3f22 e403 bf45 eb4a 3f2b aef9 bf3d     .g"?..E.J.+?..=.
 8030f08:	04f3 3f35 04f3 bf35 aef9 3f3d eb4a bf2b     ..5?..5...=?J.+.
 8030f18:	e403 3f45 6799 bf22 9f02 3f4d 7fc0 bf18     ..E?.g"...M?....
 8030f28:	db31 3f54 39da bf0e 941a 3f5b 9c3d bf03     1.T?.9....[?=...
 8030f38:	c598 3f61 5aea bef1 6bd8 3f67 e880 beda     ..a?.Z...kg?....
 8030f48:	835e 3f6c ef15 bec3 0908 3f71 7cd4 beac     ^.l?......q?.|..
 8030f58:	fa0b 3f74 a031 be94 53f8 3f78 cfcc be78     ..t?1....Sx?..x.
 8030f68:	14be 3f7b c5c2 be47 3aac 3f7d 4083 be16     ..{?..G..:}?.@..
 8030f78:	c46d 3f7e bd36 bdc8 b10f 3f7f fb2f bd48     m.~?6......?/.H.

08030f88 <twiddleCoef_64>:
 8030f88:	0000 3f80 0000 0000 c46d 3f7e bd36 3dc8     ...?....m.~?6..=
 8030f98:	14be 3f7b c5c2 3e47 fa0b 3f74 a031 3e94     ..{?..G>..t?1..>
 8030fa8:	835e 3f6c ef15 3ec3 c598 3f61 5aea 3ef1     ^.l?...>..a?.Z.>
 8030fb8:	db31 3f54 39da 3f0e e403 3f45 6799 3f22     1.T?.9.?..E?.g"?
 8030fc8:	04f3 3f35 04f3 3f35 6799 3f22 e403 3f45     ..5?..5?.g"?..E?
 8030fd8:	39da 3f0e db31 3f54 5aea 3ef1 c598 3f61     .9.?1.T?.Z.>..a?
 8030fe8:	ef15 3ec3 835e 3f6c a031 3e94 fa0b 3f74     ...>^.l?1..>..t?
 8030ff8:	c5c2 3e47 14be 3f7b bd36 3dc8 c46d 3f7e     ..G>..{?6..=m.~?
 8031008:	0000 0000 0000 3f80 bd36 bdc8 c46d 3f7e     .......?6...m.~?
 8031018:	c5c2 be47 14be 3f7b a031 be94 fa0b 3f74     ..G...{?1.....t?
 8031028:	ef15 bec3 835e 3f6c 5aea bef1 c598 3f61     ....^.l?.Z....a?
 8031038:	39da bf0e db31 3f54 6799 bf22 e403 3f45     .9..1.T?.g"...E?
 8031048:	04f3 bf35 04f3 3f35 e403 bf45 6799 3f22     ..5...5?..E..g"?
 8031058:	db31 bf54 39da 3f0e c598 bf61 5aea 3ef1     1.T..9.?..a..Z.>
 8031068:	835e bf6c ef15 3ec3 fa0b bf74 a031 3e94     ^.l....>..t.1..>
 8031078:	14be bf7b c5c2 3e47 c46d bf7e bd36 3dc8     ..{...G>m.~.6..=
 8031088:	0000 bf80 0000 0000 c46d bf7e bd36 bdc8     ........m.~.6...
 8031098:	14be bf7b c5c2 be47 fa0b bf74 a031 be94     ..{...G...t.1...
 80310a8:	835e bf6c ef15 bec3 c598 bf61 5aea bef1     ^.l.......a..Z..
 80310b8:	db31 bf54 39da bf0e e403 bf45 6799 bf22     1.T..9....E..g".
 80310c8:	04f3 bf35 04f3 bf35 6799 bf22 e403 bf45     ..5...5..g"...E.
 80310d8:	39da bf0e db31 bf54 5aea bef1 c598 bf61     .9..1.T..Z....a.
 80310e8:	ef15 bec3 835e bf6c a031 be94 fa0b bf74     ....^.l.1.....t.
 80310f8:	c5c2 be47 14be bf7b bd36 bdc8 c46d bf7e     ..G...{.6...m.~.
 8031108:	0000 8000 0000 bf80 bd36 3dc8 c46d bf7e     ........6..=m.~.
 8031118:	c5c2 3e47 14be bf7b a031 3e94 fa0b bf74     ..G>..{.1..>..t.
 8031128:	ef15 3ec3 835e bf6c 5aea 3ef1 c598 bf61     ...>^.l..Z.>..a.
 8031138:	39da 3f0e db31 bf54 6799 3f22 e403 bf45     .9.?1.T..g"?..E.
 8031148:	04f3 3f35 04f3 bf35 e403 3f45 6799 bf22     ..5?..5...E?.g".
 8031158:	db31 3f54 39da bf0e c598 3f61 5aea bef1     1.T?.9....a?.Z..
 8031168:	835e 3f6c ef15 bec3 fa0b 3f74 a031 be94     ^.l?......t?1...
 8031178:	14be 3f7b c5c2 be47 c46d 3f7e bd36 bdc8     ..{?..G.m.~?6...

08031188 <armBitRevIndexTable256>:
 8031188:	0008 0200 0010 0400 0018 0600 0020 0040     ............ .@.
 8031198:	0028 0240 0030 0440 0038 0640 0040 0080     (.@.0.@.8.@.@...
 80311a8:	0048 0280 0050 0480 0058 0680 0060 00c0     H...P...X...`...
 80311b8:	0068 02c0 0070 04c0 0078 06c0 0080 0100     h...p...x.......
 80311c8:	0088 0300 0090 0500 0098 0700 00a0 0140     ..............@.
 80311d8:	00a8 0340 00b0 0540 00b8 0740 00c0 0180     ..@...@...@.....
 80311e8:	00c8 0380 00d0 0580 00d8 0780 00e0 01c0     ................
 80311f8:	00e8 03c0 00f0 05c0 00f8 07c0 0100 0200     ................
 8031208:	0108 0208 0110 0408 0118 0608 0120 0280     ............ ...
 8031218:	0128 0248 0130 0448 0138 0648 0140 0300     (.H.0.H.8.H.@...
 8031228:	0148 0288 0150 0488 0158 0688 0160 0380     H...P...X...`...
 8031238:	0168 02c8 0170 04c8 0178 06c8 0180 0208     h...p...x.......
 8031248:	0188 0308 0190 0508 0198 0708 01a0 0288     ................
 8031258:	01a8 0348 01b0 0548 01b8 0748 01c0 0308     ..H...H...H.....
 8031268:	01c8 0388 01d0 0588 01d8 0788 01e0 0388     ................
 8031278:	01e8 03c8 01f0 05c8 01f8 07c8 0208 0210     ................
 8031288:	0200 0400 0210 0410 0218 0610 0220 0480     ............ ...
 8031298:	0228 0250 0230 0450 0238 0650 0240 0500     (.P.0.P.8.P.@...
 80312a8:	0248 0290 0250 0490 0258 0690 0260 0580     H...P...X...`...
 80312b8:	0268 02d0 0270 04d0 0278 06d0 0280 0408     h...p...x.......
 80312c8:	0288 0310 0290 0510 0298 0710 02a0 0488     ................
 80312d8:	02a8 0350 02b0 0550 02b8 0750 02c0 0508     ..P...P...P.....
 80312e8:	02c8 0390 02d0 0590 02d8 0790 02e0 0588     ................
 80312f8:	02e8 03d0 02f0 05d0 02f8 07d0 0300 0600     ................
 8031308:	0308 0610 0310 0418 0318 0618 0320 0680     ............ ...
 8031318:	0328 0690 0330 0458 0338 0658 0340 0700     (...0.X.8.X.@...
 8031328:	0348 0710 0350 0498 0358 0698 0360 0780     H...P...X...`...
 8031338:	0368 0790 0370 04d8 0378 06d8 0380 0608     h...p...x.......
 8031348:	0388 0618 0390 0518 0398 0718 03a0 0688     ................
 8031358:	03a8 0698 03b0 0558 03b8 0758 03c0 0708     ......X...X.....
 8031368:	03c8 0718 03d0 0598 03d8 0798 03e0 0788     ................
 8031378:	03e8 0798 03f0 05d8 03f8 07d8 0408 0480     ................
 8031388:	0410 0420 0418 0620 0428 0580 0430 0460     .. ... .(...0.`.
 8031398:	0438 0660 0440 0600 0448 0488 0450 04a0     8.`.@...H...P...
 80313a8:	0458 06a0 0460 0610 0468 0588 0470 04e0     X...`...h...p...
 80313b8:	0478 06e0 0488 0680 0490 0520 0498 0720     x......... ... .
 80313c8:	04a0 0608 04a8 0780 04b0 0560 04b8 0760     ..........`...`.
 80313d8:	04c0 0620 04c8 0688 04d0 05a0 04d8 07a0     .. .............
 80313e8:	04e0 0618 04e8 0788 04f0 05e0 04f8 07e0     ................
 80313f8:	0508 0520 0510 0580 0518 0628 0528 0590     .. .......(.(...
 8031408:	0530 0588 0538 0668 0540 0700 0548 0720     0...8.h.@...H. .
 8031418:	0550 0780 0558 06a8 0560 0708 0568 0598     P...X...`...h...
 8031428:	0570 0788 0578 06e8 0588 0690 0598 0728     p...x.........(.
 8031438:	05a0 0628 05a8 0790 05b0 0728 05b8 0768     ..(.......(...h.
 8031448:	05c0 0710 05c8 0698 05d0 0790 05d8 07a8     ................
 8031458:	05e0 0718 05e8 0798 05f0 0798 05f8 07e8     ................
 8031468:	0618 0630 0638 0670 0640 0700 0648 0780     ..0.8.p.@...H...
 8031478:	0650 0708 0658 06b0 0660 0710 0668 0790     P...X...`...h...
 8031488:	0670 0718 0678 06f0 0688 06a0 0698 0730     p...x.........0.
 8031498:	06a8 07a0 06b0 0788 06b8 0770 06c0 0720     ..........p... .
 80314a8:	06c8 07a0 06d0 0728 06d8 07b0 06e0 0730     ......(.......0.
 80314b8:	06e8 07a8 06f0 0798 06f8 07f0 0748 0750     ............H.P.
 80314c8:	0738 0798 0750 0760 0758 0770 0760 07c0     8...P.`.X.p.`...
 80314d8:	0768 07d0 0778 07f0 0770 07e0 07b8 07f0     h...x...p.......
 80314e8:	07a8 07b0 07d8 07f0 07c8 07e0 07e8 07f0     ................

080314f8 <armBitRevIndexTable128>:
 80314f8:	0008 0200 0010 0040 0018 0240 0020 0080     ......@...@. ...
 8031508:	0028 0280 0030 00c0 0038 02c0 0040 0100     (...0...8...@...
 8031518:	0048 0300 0050 0140 0058 0340 0060 0180     H...P.@.X.@.`...
 8031528:	0068 0380 0070 01c0 0078 03c0 0080 0200     h...p...x.......
 8031538:	0088 0208 0090 0300 0098 0248 00a0 0208     ..........H.....
 8031548:	00a8 0288 00b0 00c8 00b8 02c8 00c0 0108     ................
 8031558:	00c8 0308 00d0 0148 00d8 0348 00e0 0188     ......H...H.....
 8031568:	00e8 0388 00f0 01c8 00f8 03c8 0108 0210     ................
 8031578:	0110 0140 0118 0250 0120 0300 0128 0290     ..@...P. ...(...
 8031588:	0130 0148 0138 02d0 0148 0310 0158 0350     0.H.8...H...X.P.
 8031598:	0160 0190 0168 0390 0170 01d0 0178 03d0     `...h...p...x...
 80315a8:	0180 0240 0188 0218 0190 0340 0198 0258     ..@.......@...X.
 80315b8:	01a0 0248 01a8 0298 01b0 0348 01b8 02d8     ..H.......H.....
 80315c8:	01c0 0250 01c8 0318 01d0 0350 01d8 0358     ..P.......P...X.
 80315d8:	01e0 0258 01e8 0398 01f0 0358 01f8 03d8     ..X.......X.....
 80315e8:	0208 0220 0210 0240 0218 0260 0228 02a0     .. ...@...`.(...
 80315f8:	0230 0260 0238 02e0 0240 0300 0248 0320     0.`.8...@...H. .
 8031608:	0250 0340 0258 0360 0260 0320 0268 03a0     P.@.X.`.`. .h...
 8031618:	0270 0360 0278 03e0 0288 02a0 0290 0380     p.`.x...........
 8031628:	0298 03a0 02b0 0388 02b8 02e8 02c0 0380     ................
 8031638:	02c8 0328 02d0 0390 02d8 0368 02e0 03a0     ..(.......h.....
 8031648:	02e8 03a8 02f0 0398 02f8 03e8 0308 0320     .............. .
 8031658:	0310 0340 0318 0360 0328 0388 0330 0360     ..@...`.(...0.`.
 8031668:	0338 0398 0348 0360 0358 0370 0368 03b0     8...H.`.X.p.h...
 8031678:	0378 03f0 0388 03a0 0390 03c0 0398 03e0     x...............
 8031688:	03b0 03c8 03b8 03e8 03c8 03e0 03d8 03f0     ................

08031698 <arm_cfft_sR_f32_len64>:
 8031698:	0040 0000 0f88 0803 f90c 0802 0038 0000     @...........8...

080316a8 <arm_cfft_sR_f32_len128>:
 80316a8:	0080 0000 0b88 0803 14f8 0803 00d0 0000     ................

080316b8 <arm_cfft_sR_f32_len16>:
 80316b8:	0010 0000 017c 0803 02fc 0803 0014 0000     ....|...........

080316c8 <arm_cfft_sR_f32_len256>:
 80316c8:	0100 0000 f97c 0802 1188 0803 01b8 0000     ....|...........

080316d8 <arm_cfft_sR_f32_len32>:
 80316d8:	0020 0000 01fc 0803 0324 0803 0030 0000      .......$...0...
 80316e8:	0230 0101 0000 0001 0000 0000 0000 0001     0...............
 80316f8:	0102 0101                                   ....

080316fc <group_ptrs>:
 80316fc:	4400 4000 4800 4000 4c00 4000 5000 4000     .D.@.H.@.L.@.P.@

0803170c <ADC_MEASUREMENT_ADV_G2_CH_G2_res_config>:
 803170c:	0000 8000                                   ....

08031710 <ADC_MEASUREMENT_ADV_G0_queue_handle>:
	...
 8031724:	1938 0803 0001 0000                         8.......

0803172c <ADC_MEASUREMENT_ADV_G0_CH_G3_handle>:
 803172c:	1928 0803 1898 0803 0003 0000               (...........

08031738 <ADC_MEASUREMENT_ADV_G2_queue_handle>:
	...
 803174c:	1760 0803 0001 0001                         `.......

08031754 <ADC_MEASUREMENT_ADV_G1_CH_G1_handle>:
 8031754:	1770 0803 176c 0803 0301 0000               p...l.......

08031760 <ADC_MEASUREMENT_ADV_G2_queue_config>:
 8031760:	000c 0000 4800 0000 0004 0000               .....H......

0803176c <ADC_MEASUREMENT_ADV_G1_CH_G1_res_config>:
 803176c:	0000 8000                                   ....

08031770 <ADC_MEASUREMENT_ADV_G1_CH_G1_ch_config>:
 8031770:	0400 0023 0000 0000 0000 0000 ff01 0000     ..#.............

08031780 <ADC_MEASUREMENT_ADV_G0_CH_G2_handle>:
 8031780:	1868 0803 17e0 0803 0002 0000               h...........

0803178c <ADC_MEASUREMENT_ADV_G0_CH_G1_handle>:
 803178c:	17c0 0803 18a0 0803 0001 0000               ............

08031798 <ADC_MEASUREMENT_ADV_G2_CH_G2_handle>:
 8031798:	1810 0803 170c 0803 0302 0000               ............

080317a4 <ADC_MEASUREMENT_SCAN>:
 80317a4:	95e4 1ffe 0000 0000 0000 0000 1948 0803     ............H...
 80317b4:	95ec 1ffe 0001 0102 0101 0000               ............

080317c0 <ADC_MEASUREMENT_ADV_G0_CH_G1_ch_config>:
 80317c0:	0003 002f 0000 0000 0000 0000 0201 0000     ../.............

080317d0 <ADC_MEASUREMENT_SCAN_BGT24_PTAT_handle>:
 80317d0:	183c 0803 17e8 0803 0602 0000               <...........

080317dc <ADC_MEASUREMENT_ADV_G2_CH_G2_queue_entry_0>:
 80317dc:	00a3 0000                                   ....

080317e0 <ADC_MEASUREMENT_ADV_G0_CH_G2_res_config>:
 80317e0:	0000 0000                                   ....

080317e4 <ADC_MEASUREMENT_ADV_G0_CH_G0_res_config>:
 80317e4:	0000 8000                                   ....

080317e8 <ADC_MEASUREMENT_SCAN_BGT24_PTAT_res_config>:
 80317e8:	0000 0000                                   ....

080317ec <ADC_MEASUREMENT_ADV_G1_queue_config>:
 80317ec:	000c 0000 4800 0000 0004 0000               .....H......

080317f8 <ADC_MEASUREMENT_ADV_G0_CH_G0_handle>:
 80317f8:	1888 0803 17e4 0803 0000 0000               ............

08031804 <ADC_MEASUREMENT_ADV_G3_CH_G3_handle>:
 8031804:	1914 0803 189c 0803 0103 0000               ............

08031810 <ADC_MEASUREMENT_ADV_G2_CH_G2_ch_config>:
 8031810:	0001 0020 0000 0000 0000 0000 ff01 0000     .. .............

08031820 <ADC_MEASUREMENT_ADV_G1_queue_handle>:
	...
 8031834:	17ec 0803 0001 0000                         ........

0803183c <ADC_MEASUREMENT_SCAN_BGT24_PTAT_ch_config>:
 803183c:	0000 0022 0000 0000 0000 0000 ff01 0000     ..".............

0803184c <ADC_MEASUREMENT_ADV_G3_queue_handle>:
	...
 8031860:	1878 0803 0001 0000                         x.......

08031868 <ADC_MEASUREMENT_ADV_G0_CH_G2_ch_config>:
 8031868:	0003 0021 0000 0000 0000 0000 ff01 0000     ..!.............

08031878 <ADC_MEASUREMENT_ADV_G3_queue_config>:
 8031878:	000c 0000 4800 0000 0004 0000               .....H......

08031884 <ADC_MEASUREMENT_ADV_G3_CH_G3_queue_entry_0>:
 8031884:	00a1 0000                                   ....

08031888 <ADC_MEASUREMENT_ADV_G0_CH_G0_ch_config>:
 8031888:	0400 002f 0000 0000 0000 0000 0601 0000     ../.............

08031898 <ADC_MEASUREMENT_ADV_G0_CH_G3_res_config>:
 8031898:	0000 0000                                   ....

0803189c <ADC_MEASUREMENT_ADV_G3_CH_G3_res_config>:
 803189c:	0000 8000                                   ....

080318a0 <ADC_MEASUREMENT_ADV_G0_CH_G1_res_config>:
 80318a0:	0000 0000                                   ....

080318a4 <ADC_MEASUREMENT_ADV_G0>:
 80318a4:	95c0 1ffe 95e8 1ffe 7fad 0802 1710 0803     ................
 80318b4:	95d0 1ffe 0e03 0100 0104 0001               ............

080318c0 <ADC_MEASUREMENT_ADV_G1>:
 80318c0:	95b8 1ffe 95e0 1ffe 7fbd 0802 1820 0803     ............ ...
 80318d0:	95d8 1ffe 0003 0101 0101 0001               ............

080318dc <ADC_MEASUREMENT_ADV_G2>:
 80318dc:	95bc 1ffe 95d4 1ffe 7fcd 0802 1738 0803     ............8...
 80318ec:	95d9 1ffe 0003 0102 0101 0000               ............

080318f8 <ADC_MEASUREMENT_ADV_G3>:
 80318f8:	95b4 1ffe 95dc 1ffe 7fdd 0802 184c 0803     ............L...
 8031908:	95da 1ffe 0003 0103 0101 0000               ............

08031914 <ADC_MEASUREMENT_ADV_G3_CH_G3_ch_config>:
 8031914:	0000 0024 0000 0000 0000 0000 ff01 0000     ..$.............

08031924 <ADC_MEASUREMENT_ADV_G0_CH_G0_queue_entry_0>:
 8031924:	00a0 0000                                   ....

08031928 <ADC_MEASUREMENT_ADV_G0_CH_G3_ch_config>:
 8031928:	0003 0029 0000 0000 0000 0000 0201 0000     ..).............

08031938 <ADC_MEASUREMENT_ADV_G0_queue_config>:
 8031938:	000c 0000 4800 0000 0004 0000               .....H......

08031944 <ADC_MEASUREMENT_ADV_G1_CH_G1_queue_entry_0>:
 8031944:	00a3 0000                                   ....

08031948 <ADC_MEASUREMENT_SCAN_scan_handle>:
	...
 803195c:	196c 0803 0001 0000 0040 0000 0000 0000     l.......@.......

0803196c <ADC_MEASUREMENT_SCAN_scan_config>:
 803196c:	000c 0000 4000 0000 0024 0000               .....@..$...

08031978 <I2C_MASTER_EEPROM_sda_pin_config>:
 8031978:	00d0 0000 0001 0000 0000 0000               ............

08031984 <I2C_MASTER_EEPROM_scl_pin_config>:
 8031984:	00d0 0000 0001 0000 0000 0000               ............

08031990 <I2C_MASTER_EEPROM_config>:
 8031990:	19bc 0803 91d1 0802 91b1 0802 9191 0802     ................
	...
 80319b4:	0202 0000 ffff 0000                         ........

080319bc <I2C_MASTER_EEPROM_channel_config>:
 80319bc:	1a80 0006 0000 0000 6361 736f 0066 0000     ........acosf...
 80319cc:	6361 736f 6668 0000 6f63 6873 0066 0000     acoshf..coshf...
 80319dc:	6f70 6677 0000 0000 7173 7472 0066 0000     powf....sqrtf...

080319ec <halF>:
 80319ec:	0000 3f00 0000 bf00                         ...?....

080319f4 <ln2LO>:
 80319f4:	f7d1 3717 f7d1 b717                         ...7....

080319fc <ln2HI>:
 80319fc:	7180 3f31 7180 bf31                         .q1?.q1.

08031a04 <dp_h>:
 8031a04:	0000 0000 c000 3f15                         .......?

08031a0c <dp_l>:
 8031a0c:	0000 0000 cfdc 35d1                         .......5

08031a14 <bp>:
 8031a14:	0000 3f80 0000 3fc0 0000 0000               ...?...?....

08031a20 <TWO52>:
 8031a20:	0000 0000 0000 4330 0000 0000 0000 c330     ......0C......0.
 8031a30:	0043 4e49 0046 6e69 0066 414e 004e 616e     C.INF.inf.NAN.na
 8031a40:	006e 0030 6e49 6966 696e 7974 4e00 4e61     n.0.Infinity.NaN
 8031a50:	5000 534f 5849 2e00 0000 0000 0000 0000     .POSIX..........

08031a60 <__mprec_tens>:
 8031a60:	0000 0000 0000 3ff0 0000 0000 0000 4024     .......?......$@
 8031a70:	0000 0000 0000 4059 0000 0000 4000 408f     ......Y@.....@.@
 8031a80:	0000 0000 8800 40c3 0000 0000 6a00 40f8     .......@.....j.@
 8031a90:	0000 0000 8480 412e 0000 0000 12d0 4163     .......A......cA
 8031aa0:	0000 0000 d784 4197 0000 0000 cd65 41cd     .......A....e..A
 8031ab0:	0000 2000 a05f 4202 0000 e800 4876 4237     ... _..B....vH7B
 8031ac0:	0000 a200 1a94 426d 0000 e540 309c 42a2     ......mB..@..0.B
 8031ad0:	0000 1e90 bcc4 42d6 0000 2634 6bf5 430c     .......B..4&.k.C
 8031ae0:	8000 37e0 c379 4341 a000 85d8 3457 4376     ...7y.AC....W4vC
 8031af0:	c800 674e c16d 43ab 3d00 6091 58e4 43e1     ..Ngm..C.=.`.X.C
 8031b00:	8c40 78b5 af1d 4415 ef50 d6e2 1ae4 444b     @..x...DP.....KD
 8031b10:	d592 064d f0cf 4480 4af6 c7e1 2d02 44b5     ..M....D.J...-.D
 8031b20:	9db4 79d9 7843 44ea                         ...yCx.D

08031b28 <__mprec_bigtens>:
 8031b28:	8000 37e0 c379 4341 6e17 b505 b8b5 4693     ...7y.AC.n.....F
 8031b38:	f9f5 e93f 4f03 4d38 1d32 f930 7748 5a82     ..?..O8M2.0.Hw.Z
 8031b48:	bf3c 7f73 4fdd 7515                         <.s..O.u

08031b50 <p05.5277>:
 8031b50:	0005 0000 0019 0000 007d 0000               ........}...
